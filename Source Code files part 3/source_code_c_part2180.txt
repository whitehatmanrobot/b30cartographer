is,pKey,pPropVar,pdwPropertyConstraint)	\
    ( (This)->lpVtbl -> Next(This,pKey,pPropVar,pdwPropertyConstraint) ) 

#define IProviderPropertyConstraintCollection_Skip(This)	\
    ( (This)->lpVtbl -> Skip(This) ) 

#define IProviderPropertyConstraintCollection_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProviderPropertyConstraintCollection_INTERFACE_DEFINED__ */


#ifndef __IFunctionDiscoveryServiceProvider_INTERFACE_DEFINED__
#define __IFunctionDiscoveryServiceProvider_INTERFACE_DEFINED__

/* interface IFunctionDiscoveryServiceProvider */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IFunctionDiscoveryServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4c81ed02-1b04-43f2-a451-69966cbcd1c2")
    IFunctionDiscoveryServiceProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IFunctionInstance *pIFunctionInstance,
            /* [in] */ __RPC__in REFIID riid,
            /* [retval][iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFunctionDiscoveryServiceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFunctionDiscoveryServiceProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFunctionDiscoveryServiceProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFunctionDiscoveryServiceProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IFunctionDiscoveryServiceProvider * This,
            /* [in] */ __RPC__in_opt IFunctionInstance *pIFunctionInstance,
            /* [in] */ __RPC__in REFIID riid,
            /* [retval][iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IFunctionDiscoveryServiceProviderVtbl;

    interface IFunctionDiscoveryServiceProvider
    {
        CONST_VTBL struct IFunctionDiscoveryServiceProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFunctionDiscoveryServiceProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFunctionDiscoveryServiceProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFunctionDiscoveryServiceProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFunctionDiscoveryServiceProvider_Initialize(This,pIFunctionInstance,riid,ppv)	\
    ( (This)->lpVtbl -> Initialize(This,pIFunctionInstance,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFunctionDiscoveryServiceProvider_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\functiondiscoveryproviderhelper.h ===
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//

#pragma once

class CFDProviderHelper
{
public:
    CFDProviderHelper() : m_hToken(NULL), m_dwSessionId((DWORD) -1)
    {
        InitializeSRWLock(&srwTokenLock);
    }
    ~CFDProviderHelper()
    {
        if ( NULL != m_hToken )
            CloseHandle( m_hToken );
    }

// Implementation
public:
    /////////////////////////////////////////////////////////////////////////////
    // CoSetProxyBlanket
    //
    // Purpose:
    //    If the provider is running in a process that doesn't have permissions
    //    to call back into the client process by default then CoSetProxyBlanket
    //    must be called to enable impersonation.
    //    This function wraps the necessary calls and provides the correct CoSetProxyBlanket
    //    parameters in a single function.
    //
    // Arguments:
    //    pIUnk: Interface proxy to enable callbacks on
    //
    // Returns: S_OK on success, appropriate HRESULT otherwise
    static HRESULT CoSetProxyBlanket( IUnknown *pIUnk )
    {
        HRESULT hr = S_OK;
        IUnknown* pRealUnknown; 

        // Try to see if it's a COM proxy.  If so, see if it's local to the process or a remote COM proxy.
        // If it's remote, set the proxy blanket
        ULONG_PTR ulRpcOptions = GetRpcOptions( pIUnk );
        
        if ( SERVER_LOCALITY_PROCESS_LOCAL != ulRpcOptions )
        {
            hr = CoImpersonateClient();
            if ( S_OK == hr )
            {
                hr = pIUnk->QueryInterface(IID_IUnknown, (LPVOID*)&pRealUnknown );
                if ( S_OK == hr )
                {
                    hr = ::CoSetProxyBlanket( pRealUnknown, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_NONE, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_STATIC_CLOAKING );
                    if ( S_OK == hr )
                    {
                        hr = ::CoSetProxyBlanket( pIUnk, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_NONE, COLE_DEFAULT_PRINCIPAL,
                                              RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_STATIC_CLOAKING );
                    }
                    if ( E_NOINTERFACE == hr )
                        hr = S_OK;  // Provider can end up being inproc if we are in the fdPHost process.  Ignore error and try to proceed.

                    pRealUnknown->Release();
                }
                if ( S_OK == hr )
                    hr = CoRevertToSelf();
                else
                    CoRevertToSelf();   // Don't want the return code
            }
        }

        return hr;
    }

    /////////////////////////////////////////////////////////////////////////////
    // CoSetProxyBlanketWithThreadToken
    //
    // Purpose:
    //    If the provider is running in a process that doesn't have permissions
    //    to call back into the client process by default then CoSetProxyBlanket
    //    must be called to enable impersonation.
    //    This function wraps the necessary calls to CoSetProxyBlanket if the
    //    provider thread is from a thread pool instead of a thread called directly
    //    by FD.
    //    If you want to use this method you must call Initialize on the class instance.
    //    This is best done in IFunctionDiscoveryProvider::Initialize.
    //    Initialize must be called from one of the methods called by the client process.
    //
    // Arguments:
    //    pIUnk: Interface proxy to enable callbacks on
    //
    // Returns: S_OK on success, appropriate HRESULT otherwise
    HRESULT CoSetProxyBlanketWithThreadToken( IUnknown *pIUnk )
    {
        if ( NULL == m_hToken )
            return S_OK;
        IUnknown* pRealUnknown;

        HRESULT hr = S_OK;

        AcquireSRWLockShared(&srwTokenLock);
        if ( !SetThreadToken( NULL, m_hToken ))
            hr = HRESULT_FROM_WIN32( GetLastError() );
        ReleaseSRWLockShared(&srwTokenLock);
        
        if ( S_OK == hr )
        {
            hr = pIUnk->QueryInterface(IID_IUnknown, (LPVOID*)&pRealUnknown );
            if ( S_OK == hr )
            {
                hr = ::CoSetProxyBlanket( pRealUnknown, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_NONE, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_STATIC_CLOAKING );
                if (S_OK == hr)
                    hr = ::CoSetProxyBlanket( pIUnk, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_NONE, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_STATIC_CLOAKING );
                if ( E_NOINTERFACE == hr )
                    hr = S_OK;  // Provider can end up being inproc if we are in the fdPHost process.  Ignore error and try to proceed.

                pRealUnknown->Release();
            }
            if ( !SetThreadToken( NULL, NULL ))
            {
                if ( S_OK == hr )
                    hr = HRESULT_FROM_WIN32( GetLastError() );
            }
        }

        return hr;
    }

    /////////////////////////////////////////////////////////////////////////////
    // Initialize
    //
    // Purpose:
    //    If the provider is running in a process that doesn't have permissions
    //    to call back into the client process by default then CoSetProxyBlanket
    //    must be called to enable impersonation.
    //    CoSetProxyBlanketWithThreadToken wraps the calls necessary to do this.
    //    Before using that function you must call Initialize on the class instance.
    //    This is best done in IFunctionDiscoveryProvider::Initialize.
    //    Initialize must be called from one of the methods called by the client process.
    //
    //    Note:  There are three cases we we will not impersonate
    //    1. If the caller is Local System we will not impersonate and subsequent
    //       calls to CoSetProxyBlanketWithThreadToken will effectively noop
    //    2. Similary if the provider is actually running in-proc no proxy blanket
    //       is required and CoImpersonateClient will fail with:
    //          Code=0x80010117 (2147549463): RPC_E_CALL_COMPLETE: "Call context cannot be accessed after call completed."
    //          Severity=FAILURE; Code=279 (0x117); Facility=1 (0x1) (FACILITY_RPC)
    //       Handle this case gracefully and effectively noop on the
    //       CoSetProxyBlanketWithThreadToken as well.
    //    3. If we get an inproc proxy to the provider we detect that and subsequent
    //       calls to CoSetProxyBlanketWithThreadToken will effectively noop.
    //
    // Returns: S_OK on success, appropriate HRESULT otherwise
    HRESULT Initialize( IUnknown *pIUnk )
    {
        if ( NULL != m_hToken )
            return S_FALSE;

        const SID LOCAL_SYSTEM_SID = { SID_REVISION, 1, {0,0,0,0,0,5}, SECURITY_LOCAL_SYSTEM_RID };
        BOOL isLocalSystem = FALSE;

        HRESULT hr = CoImpersonateClient();

        if ( S_OK == hr )
        {
            if ( !CheckTokenMembership( NULL, (PSID)&LOCAL_SYSTEM_SID, &isLocalSystem ))
            {
                DWORD dwRC = GetLastError();
                ULONG_PTR ulRpcOptions = GetRpcOptions( pIUnk );
                
                if ( SERVER_LOCALITY_PROCESS_LOCAL != ulRpcOptions )
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                else
                    isLocalSystem = TRUE;   // this is an inproc proxy so we don't need the token
            }
            if ( (S_OK == hr) && (!isLocalSystem) )
            {
                AcquireSRWLockExclusive(&srwTokenLock);
                if ( !OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_QUERY, FALSE, &m_hToken ))
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                if ( S_OK == hr )
                {
                    DWORD dwSizeReturned;
                    if ( !GetTokenInformation(m_hToken, TokenSessionId, &m_dwSessionId, sizeof(m_dwSessionId), &dwSizeReturned ))
                        hr = HRESULT_FROM_WIN32( GetLastError() );
                }
                ReleaseSRWLockExclusive(&srwTokenLock);
            }
            if ( S_OK == hr )
                hr = CoRevertToSelf();
            else
                CoRevertToSelf();   // Don't want the return code
        }
        else if ( RPC_E_CALL_COMPLETE == hr )
        {
            hr = S_OK;  // InProc :)
        }

        return hr;
    }

    BOOL ReleaseToken(DWORD dwSessionId)
    {
        BOOL bMatch = FALSE;
        
        AcquireSRWLockExclusive( &srwTokenLock );
        if ( NULL != m_hToken && dwSessionId == m_dwSessionId )
        {
            CloseHandle( m_hToken );
            m_hToken = NULL;
            bMatch = TRUE;
        }
        ReleaseSRWLockExclusive( &srwTokenLock );

        return bMatch;
    }
    VOID ReleaseToken()
    {
        AcquireSRWLockExclusive( &srwTokenLock );
        if ( NULL != m_hToken)
        {
            CloseHandle( m_hToken );
            m_hToken = NULL;
            m_dwSessionId = (DWORD) -1;
        }
        ReleaseSRWLockExclusive( &srwTokenLock );
    }

// Implementation
protected:
    /////////////////////////////////////////////////////////////////////////////
    // GetRpcOptions
    //
    // Purpose:
    //    Get the rpc options if this is a proxy.
    //
    // Arguments:
    //    pIUnk: Interface proxy.
    //
    // Returns: ULONG_PTR rpc options on success, assume it's inproc otherwise (SERVER_LOCALITY_PROCESS_LOCAL)
    static ULONG_PTR GetRpcOptions( IUnknown *pIUnk )
    {
        ULONG_PTR ulOptions = SERVER_LOCALITY_PROCESS_LOCAL;
        IRpcOptions* pRpcOptions;
        
        HRESULT hr = pIUnk->QueryInterface( __uuidof( IRpcOptions ), reinterpret_cast<LPVOID*>( &pRpcOptions ) );
        if ( S_OK == hr )
        {
            hr = pRpcOptions->Query( pIUnk, COMBND_SERVER_LOCALITY, &ulOptions );
            pRpcOptions->Release();
        }
        return ulOptions;
    }

// Attributes
protected:
    DWORD   m_dwSessionId;
    HANDLE  m_hToken;
    SRWLOCK srwTokenLock;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\functiondiscoveryconstraints.h ===
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//

///////////////////////////////////////////////////////////////////////////////
// QUERY Constraint defines
///////////////////////////////////////////////////////////////////////////////

#define MAX_FDCONSTRAINTNAME_LENGTH                     100
#define MAX_FDCONSTRAINTVALUE_LENGTH                    1000

// Common Provider specific Constraints
#define FD_QUERYCONSTRAINT_PROVIDERINSTANCEID           L"ProviderInstanceID"
#define FD_QUERYCONSTRAINT_SUBCATEGORY                  L"Subcategory"
#define FD_QUERYCONSTRAINT_RECURSESUBCATEGORY           L"RecurseSubcategory"
#define FD_QUERYCONSTRAINT_VISIBILITY                   L"Visibility"
    // FD_CONSTRAINTVALUE_VISIBILITY_DEFAULT you want just default instances (visible as defined by the provider)
    // FD_CONSTRAINTVALUE_VISIBILITY_ALL (default) you want both visible and not visible/hidden instances (as defined by the provider)
#define FD_QUERYCONSTRAINT_COMCLSCONTEXT                L"COMClsContext"

// Common Provider specific Constraints values
#define FD_CONSTRAINTVALUE_TRUE                         L"TRUE"
#define FD_CONSTRAINTVALUE_FALSE                        L"FALSE"
#define FD_CONSTRAINTVALUE_RECURSESUBCATEGORY_TRUE      FD_CONSTRAINTVALUE_TRUE
#define FD_CONSTRAINTVALUE_VISIBILITY_DEFAULT           L"0"
#define FD_CONSTRAINTVALUE_VISIBILITY_ALL               L"1"
#define FD_CONSTRAINTVALUE_COMCLSCONTEXT_INPROC_SERVER  L"1"
#define FD_CONSTRAINTVALUE_COMCLSCONTEXT_LOCAL_SERVER   L"4"

///////////////////////////////////////////////////////////////////////////////
// PNP Provider specific Constraints
#define PROVIDERPNP_QUERYCONSTRAINT_INTERFACECLASS      L"InterfaceClass"
#define PROVIDERPNP_QUERYCONSTRAINT_NOTPRESENT          L"NotPresent"
#define PROVIDERPNP_QUERYCONSTRAINT_NOTIFICATIONSONLY   L"NotifyOnly"
    // PNP_CONSTRAINTVALUE_NOTPRESENT you want "not present" instances as well
    // "FALSE" (default) you want only DIGCF_PRESENT instances.
// PNP Provider specific Constraints values
#define PNP_CONSTRAINTVALUE_NOTPRESENT                  FD_CONSTRAINTVALUE_TRUE
#define PNP_CONSTRAINTVALUE_NOTIFICATIONSONLY           FD_CONSTRAINTVALUE_TRUE

///////////////////////////////////////////////////////////////////////////////
// SSDP Provider specific Constraints
#define PROVIDERSSDP_QUERYCONSTRAINT_TYPE               L"Type"

// SSDP Provider specific Constraints values
#define SSDP_CONSTRAINTVALUE_TYPE_ALL                   L"ssdp:all"
#define SSDP_CONSTRAINTVALUE_TYPE_ROOT                  L"upnp:rootdevice"
#define SSDP_CONSTRAINTVALUE_TYPE_DEVICE_PREFIX         L"urn:schemas-upnp-org:device:"
#define SSDP_CONSTRAINTVALUE_TYPE_SVC_PREFIX            L"urn:schemas-upnp-org:service:"

#define SSDP_CONSTRAINTVALUE_TYPE_DEV_LIGHTING          SSDP_CONSTRAINTVALUE_TYPE_DEVICE_PREFIX L"Lighting:1"
#define SSDP_CONSTRAINTVALUE_TYPE_DEV_REMINDER          SSDP_CONSTRAINTVALUE_TYPE_DEVICE_PREFIX L"Reminder:1"
#define SSDP_CONSTRAINTVALUE_TYPE_DEV_POWERDEVICE       SSDP_CONSTRAINTVALUE_TYPE_DEVICE_PREFIX L"PowerDevice:1"
#define SSDP_CONSTRAINTVALUE_TYPE_DEV_IGD               SSDP_CONSTRAINTVALUE_TYPE_DEVICE_PREFIX L"InternetGatewayDevice:1"
#define SSDP_CONSTRAINTVALUE_TYPE_DEV_WANDEVICE         SSDP_CONSTRAINTVALUE_TYPE_DEVICE_PREFIX L"WANDevice:1"
#define SSDP_CONSTRAINTVALUE_TYPE_DEV_LANDEVICE         SSDP_CONSTRAINTVALUE_TYPE_DEVICE_PREFIX L"LANDevice:1"
#define SSDP_CONSTRAINTVALUE_TYPE_DEV_WANCONNDEVICE     SSDP_CONSTRAINTVALUE_TYPE_DEVICE_PREFIX L"WANConnectionDevice:1"
#define SSDP_CONSTRAINTVALUE_TYPE_DEV_LUXMETER          SSDP_CONSTRAINTVALUE_TYPE_DEVICE_PREFIX L"Luxmeter:1"
#define SSDP_CONSTRAINTVALUE_TYPE_DEV_MDARNDR           SSDP_CONSTRAINTVALUE_TYPE_DEVICE_PREFIX L"MediaRenderer:1"
#define SSDP_CONSTRAINTVALUE_TYPE_DEV_MDASRVR           SSDP_CONSTRAINTVALUE_TYPE_DEVICE_PREFIX L"MediaServer:1"

#define SSDP_CONSTRAINTVALUE_TYPE_SVC_SCANNER           SSDP_CONSTRAINTVALUE_TYPE_SVC_PREFIX L"Scanner:1"
#define SSDP_CONSTRAINTVALUE_TYPE_SVC_DIMMING           SSDP_CONSTRAINTVALUE_TYPE_SVC_PREFIX L"DimmingService:1"

///////////////////////////////////////////////////////////////////////////////
// WSD Provider specific Constraints
#define PROVIDERWSD_QUERYCONSTRAINT_DIRECTEDADDRESS     L"RemoteAddress"
#define PROVIDERWSD_QUERYCONSTRAINT_TYPE                L"Type"
#define PROVIDERWSD_QUERYCONSTRAINT_SCOPE               L"Scope"

///////////////////////////////////////////////////////////////////////////////
// NetBios Provider specific Constraints
#define PROVIDERWNET_QUERYCONSTRAINT_TYPE               L"Type"
#define PROVIDERWNET_QUERYCONSTRAINT_PROPERTIES         L"Properties"
#define PROVIDERWNET_QUERYCONSTRAINT_RESOURCETYPE       L"ResourceType"

#define WNET_CONSTRAINTVALUE_TYPE_ALL                   L"All"
#define WNET_CONSTRAINTVALUE_TYPE_SERVER                L"Server"   // Default
#define WNET_CONSTRAINTVALUE_TYPE_DOMAIN                L"Domain"

#define WNET_CONSTRAINTVALUE_PROPERTIES_ALL             L"All"
#define WNET_CONSTRAINTVALUE_PROPERTIES_LIMITED         L"Limited"  // Default

#define WNET_CONSTRAINTVALUE_RESOURCETYPE_DISK          L"Disk"             // All non-printer shares (dwDisplayType == RESOURCEDISPLAYTYPE_SHARE and dwType != RESOURCETYPE_PRINT)
#define WNET_CONSTRAINTVALUE_RESOURCETYPE_PRINTER       L"Printer"          // All printer shares (dwDisplayType == RESOURCEDISPLAYTYPE_SHARE and dwType == RESOURCETYPE_PRINT)
#define WNET_CONSTRAINTVALUE_RESOURCETYPE_DISKORPRINTER L"DiskOrPrinter"    // All shares (dwDisplayType == RESOURCEDISPLAYTYPE_SHARE)

///////////////////////////////////////////////////////////////////////////////
// PROPERTY Constraint defines
///////////////////////////////////////////////////////////////////////////////

#ifndef FDPropertyConstraint
typedef enum tagPropertyConstraint
{
    QC_EQUALS = 0,
    QC_NOTEQUAL = 1,
    QC_LESSTHAN = 2,
    QC_LESSTHANOREQUAL = 3,
    QC_GREATERTHAN = 4,
    QC_GREATERTHANOREQUAL = 5,
    QC_STARTSWITH = 6,   // Strings only
    QC_EXISTS = 7,
    QC_DOESNOTEXIST = 8,
    QC_CONTAINS = 9     // Strings and VT_VECTOR only
} PropertyConstraint;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\fwpstypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for fwpstypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __fwpstypes_h__
#define __fwpstypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "fwptypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_fwpstypes_0000_0000 */
/* [local] */ 

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
typedef struct FWPS_FILTER_CONDITION0_
    {
    UINT16 fieldId;
    UINT16 reserved;
    FWP_MATCH_TYPE matchType;
    FWP_CONDITION_VALUE0 conditionValue;
    } 	FWPS_FILTER_CONDITION0;

typedef struct FWPS_ACTION0_
    {
    FWP_ACTION_TYPE type;
    UINT32 calloutId;
    } 	FWPS_ACTION0;

#define FWPS_FILTER_FLAG_CLEAR_ACTION_RIGHT    (0x0001)
#define FWPS_FILTER_FLAG_PERMIT_IF_CALLOUT_UNREGISTERED   (0x0002)
typedef struct FWPM_PROVIDER_CONTEXT0_ FWPM_PROVIDER_CONTEXT0;

typedef struct FWPS_FILTER0_
    {
    UINT64 filterId;
    FWP_VALUE0 weight;
    UINT16 subLayerWeight;
    UINT16 flags;
    UINT32 numFilterConditions;
    FWPS_FILTER_CONDITION0 *filterCondition;
    FWPS_ACTION0 action;
    UINT64 context;
    FWPM_PROVIDER_CONTEXT0 *providerContext;
    } 	FWPS_FILTER0;

typedef struct FWPS_INCOMING_VALUE0_
    {
    FWP_VALUE0 value;
    } 	FWPS_INCOMING_VALUE0;

typedef struct FWPS_INCOMING_VALUES0_
    {
    UINT16 layerId;
    UINT32 valueCount;
    FWPS_INCOMING_VALUE0 *incomingValue;
    } 	FWPS_INCOMING_VALUES0;

typedef 
enum FWPS_DISCARD_MODULE0_
    {	FWPS_DISCARD_MODULE_NETWORK	= 0,
	FWPS_DISCARD_MODULE_TRANSPORT	= ( FWPS_DISCARD_MODULE_NETWORK + 1 ) ,
	FWPS_DISCARD_MODULE_GENERAL	= ( FWPS_DISCARD_MODULE_TRANSPORT + 1 ) ,
	FWPS_DISCARD_MODULE_MAX	= ( FWPS_DISCARD_MODULE_GENERAL + 1 ) 
    } 	FWPS_DISCARD_MODULE0;

typedef 
enum FWPS_GENERAL_DISCARD_REASON_
    {	FWPS_DISCARD_FIREWALL_POLICY	= 0,
	FWPS_DISCARD_IPSEC	= ( FWPS_DISCARD_FIREWALL_POLICY + 1 ) ,
	FWPS_GENERAL_DISCARD_REASON_MAX	= ( FWPS_DISCARD_IPSEC + 1 ) 
    } 	FWPS_GENERAL_DISCARD_REASON;

typedef struct FWPS_DISCARD_METADATA0_
    {
    FWPS_DISCARD_MODULE0 discardModule;
    UINT32 discardReason;
    UINT64 filterId;
    } 	FWPS_DISCARD_METADATA0;

typedef struct FWPS_INBOUND_FRAGMENT_METADATA0_
    {
    UINT32 fragmentIdentification;
    UINT16 fragmentOffset;
    ULONG fragmentLength;
    } 	FWPS_INBOUND_FRAGMENT_METADATA0;

#define FWPS_INCOMING_FLAG_CACHE_SAFE                         (0x00000001)
#define FWPS_INCOMING_FLAG_ENFORCE_QUERY                      (0x00000002)
#define FWPS_INCOMING_FLAG_ABSORB                             (0x00000004)
#define FWPS_INCOMING_FLAG_CONNECTION_FAILING_INDICATION      (0x00000008)
#define FWPS_RIGHT_ACTION_WRITE          (0x00000001)
#define FWPS_CLASSIFY_OUT_FLAG_ABSORB                      (0x00000001)
#define FWPS_CLASSIFY_OUT_FLAG_BUFFER_LIMIT_REACHED        (0x00000002)
#define FWPS_CLASSIFY_OUT_FLAG_NO_MORE_DATA                (0x00000004)
typedef struct FWPS_CLASSIFY_OUT0_
    {
    FWP_ACTION_TYPE actionType;
    UINT64 outContext;
    UINT64 filterId;
    UINT32 rights;
    UINT32 flags;
    UINT32 reserved;
    } 	FWPS_CLASSIFY_OUT0;

typedef 
enum FWPS_CALLOUT_NOTIFY_TYPE_
    {	FWPS_CALLOUT_NOTIFY_ADD_FILTER	= 0,
	FWPS_CALLOUT_NOTIFY_DELETE_FILTER	= ( FWPS_CALLOUT_NOTIFY_ADD_FILTER + 1 ) ,
	FWPS_CALLOUT_NOTIFY_TYPE_MAX	= ( FWPS_CALLOUT_NOTIFY_DELETE_FILTER + 1 ) 
    } 	FWPS_CALLOUT_NOTIFY_TYPE;

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_fwpstypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fwpstypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\fwpmtypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for fwpmtypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __fwpmtypes_h__
#define __fwpmtypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "fwptypes.h"
#include "iketypes.h"
#include "ipsectypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_fwpmtypes_0000_0000 */
/* [local] */ 

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
typedef struct FWPM_DISPLAY_DATA0_
    {
    wchar_t *name;
    wchar_t *description;
    } 	FWPM_DISPLAY_DATA0;

typedef /* [v1_enum] */ 
enum FWPM_CHANGE_TYPE_
    {	FWPM_CHANGE_ADD	= 1,
	FWPM_CHANGE_DELETE	= ( FWPM_CHANGE_ADD + 1 ) ,
	FWPM_CHANGE_TYPE_MAX	= ( FWPM_CHANGE_DELETE + 1 ) 
    } 	FWPM_CHANGE_TYPE;

#define FWPM_SUBSCRIPTION_FLAG_NOTIFY_ON_ADD    (0x00000001)
#define FWPM_SUBSCRIPTION_FLAG_NOTIFY_ON_DELETE (0x00000002)
typedef 
enum FWPM_SERVICE_STATE_
    {	FWPM_SERVICE_STOPPED	= 0,
	FWPM_SERVICE_START_PENDING	= ( FWPM_SERVICE_STOPPED + 1 ) ,
	FWPM_SERVICE_STOP_PENDING	= ( FWPM_SERVICE_START_PENDING + 1 ) ,
	FWPM_SERVICE_RUNNING	= ( FWPM_SERVICE_STOP_PENDING + 1 ) ,
	FWPM_SERVICE_STATE_MAX	= ( FWPM_SERVICE_RUNNING + 1 ) 
    } 	FWPM_SERVICE_STATE;

#define FWPM_NET_EVENT_KEYWORD_INBOUND_MCAST (0x00000001)
#define FWPM_NET_EVENT_KEYWORD_INBOUND_BCAST (0x00000002)
typedef 
enum FWPM_ENGINE_OPTION_
    {	FWPM_ENGINE_COLLECT_NET_EVENTS	= 0,
	FWPM_ENGINE_NET_EVENT_MATCH_ANY_KEYWORDS	= ( FWPM_ENGINE_COLLECT_NET_EVENTS + 1 ) ,
	FWPM_ENGINE_OPTION_MAX	= ( FWPM_ENGINE_NET_EVENT_MATCH_ANY_KEYWORDS + 1 ) 
    } 	FWPM_ENGINE_OPTION;

#define FWPM_SESSION_FLAG_DYNAMIC (0x00000001)
typedef struct FWPM_SESSION0_
    {
    GUID sessionKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    UINT32 txnWaitTimeoutInMSec;
    DWORD processId;
    SID *sid;
    wchar_t *username;
    BOOL kernelMode;
    } 	FWPM_SESSION0;

typedef struct FWPM_SESSION_ENUM_TEMPLATE0_
    {
    UINT64 reserved;
    } 	FWPM_SESSION_ENUM_TEMPLATE0;

#define FWPM_PROVIDER_FLAG_PERSISTENT  (0x00000001)
#define FWPM_PROVIDER_FLAG_DISABLED    (0x00000010)
typedef struct FWPM_PROVIDER0_
    {
    GUID providerKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    FWP_BYTE_BLOB providerData;
    wchar_t *serviceName;
    } 	FWPM_PROVIDER0;

typedef struct FWPM_PROVIDER_ENUM_TEMPLATE0_
    {
    UINT64 reserved;
    } 	FWPM_PROVIDER_ENUM_TEMPLATE0;

typedef struct FWPM_PROVIDER_CHANGE0_
    {
    FWPM_CHANGE_TYPE changeType;
    GUID providerKey;
    } 	FWPM_PROVIDER_CHANGE0;

typedef struct FWPM_PROVIDER_SUBSCRIPTION0_
    {
    FWPM_PROVIDER_ENUM_TEMPLATE0 *enumTemplate;
    UINT32 flags;
    GUID sessionKey;
    } 	FWPM_PROVIDER_SUBSCRIPTION0;

#define FWPM_PROVIDER_CONTEXT_FLAG_PERSISTENT  (0x00000001)
typedef struct FWPM_CLASSIFY_OPTION0_
    {
    FWP_CLASSIFY_OPTION_TYPE type;
    FWP_VALUE0 value;
    } 	FWPM_CLASSIFY_OPTION0;

typedef struct FWPM_CLASSIFY_OPTIONS0_
    {
    UINT32 numOptions;
    FWPM_CLASSIFY_OPTION0 *options;
    } 	FWPM_CLASSIFY_OPTIONS0;

typedef /* [v1_enum] */ 
enum FWPM_PROVIDER_CONTEXT_TYPE_
    {	FWPM_IPSEC_KEYING_CONTEXT	= 0,
	FWPM_IPSEC_IKE_QM_TRANSPORT_CONTEXT	= ( FWPM_IPSEC_KEYING_CONTEXT + 1 ) ,
	FWPM_IPSEC_IKE_QM_TUNNEL_CONTEXT	= ( FWPM_IPSEC_IKE_QM_TRANSPORT_CONTEXT + 1 ) ,
	FWPM_IPSEC_AUTHIP_QM_TRANSPORT_CONTEXT	= ( FWPM_IPSEC_IKE_QM_TUNNEL_CONTEXT + 1 ) ,
	FWPM_IPSEC_AUTHIP_QM_TUNNEL_CONTEXT	= ( FWPM_IPSEC_AUTHIP_QM_TRANSPORT_CONTEXT + 1 ) ,
	FWPM_IPSEC_IKE_MM_CONTEXT	= ( FWPM_IPSEC_AUTHIP_QM_TUNNEL_CONTEXT + 1 ) ,
	FWPM_IPSEC_AUTHIP_MM_CONTEXT	= ( FWPM_IPSEC_IKE_MM_CONTEXT + 1 ) ,
	FWPM_CLASSIFY_OPTIONS_CONTEXT	= ( FWPM_IPSEC_AUTHIP_MM_CONTEXT + 1 ) ,
	FWPM_GENERAL_CONTEXT	= ( FWPM_CLASSIFY_OPTIONS_CONTEXT + 1 ) ,
	FWPM_PROVIDER_CONTEXT_TYPE_MAX	= ( FWPM_GENERAL_CONTEXT + 1 ) 
    } 	FWPM_PROVIDER_CONTEXT_TYPE;

typedef struct FWPM_PROVIDER_CONTEXT0_
    {
    GUID providerContextKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    GUID *providerKey;
    FWP_BYTE_BLOB providerData;
    FWPM_PROVIDER_CONTEXT_TYPE type;
    union 
        {
        IPSEC_KEYING_POLICY0 *keyingPolicy;
        IPSEC_TRANSPORT_POLICY0 *ikeQmTransportPolicy;
        IPSEC_TUNNEL_POLICY0 *ikeQmTunnelPolicy;
        IPSEC_TRANSPORT_POLICY0 *authipQmTransportPolicy;
        IPSEC_TUNNEL_POLICY0 *authipQmTunnelPolicy;
        IKEEXT_POLICY0 *ikeMmPolicy;
        IKEEXT_POLICY0 *authIpMmPolicy;
        FWP_BYTE_BLOB *dataBuffer;
        FWPM_CLASSIFY_OPTIONS0 *classifyOptions;
        } 	;
    UINT64 providerContextId;
    } 	FWPM_PROVIDER_CONTEXT0;

typedef struct FWPM_PROVIDER_CONTEXT_ENUM_TEMPLATE0_
    {
    GUID *providerKey;
    FWPM_PROVIDER_CONTEXT_TYPE providerContextType;
    } 	FWPM_PROVIDER_CONTEXT_ENUM_TEMPLATE0;

typedef struct FWPM_PROVIDER_CONTEXT_CHANGE0_
    {
    FWPM_CHANGE_TYPE changeType;
    GUID providerContextKey;
    UINT64 providerContextId;
    } 	FWPM_PROVIDER_CONTEXT_CHANGE0;

typedef struct FWPM_PROVIDER_CONTEXT_SUBSCRIPTION0_
    {
    FWPM_PROVIDER_CONTEXT_ENUM_TEMPLATE0 *enumTemplate;
    UINT32 flags;
    GUID sessionKey;
    } 	FWPM_PROVIDER_CONTEXT_SUBSCRIPTION0;

#define FWPM_SUBLAYER_FLAG_PERSISTENT       (0x00000001)
typedef struct FWPM_SUBLAYER0_
    {
    GUID subLayerKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    GUID *providerKey;
    FWP_BYTE_BLOB providerData;
    UINT16 weight;
    } 	FWPM_SUBLAYER0;

typedef struct FWPM_SUBLAYER_ENUM_TEMPLATE0_
    {
    GUID *providerKey;
    } 	FWPM_SUBLAYER_ENUM_TEMPLATE0;

typedef struct FWPM_SUBLAYER_CHANGE0_
    {
    FWPM_CHANGE_TYPE changeType;
    GUID subLayerKey;
    } 	FWPM_SUBLAYER_CHANGE0;

typedef struct FWPM_SUBLAYER_SUBSCRIPTION0_
    {
    FWPM_SUBLAYER_ENUM_TEMPLATE0 *enumTemplate;
    UINT32 flags;
    GUID sessionKey;
    } 	FWPM_SUBLAYER_SUBSCRIPTION0;

#define FWPM_LAYER_FLAG_KERNEL           (0x00000001)
#define FWPM_LAYER_FLAG_BUILTIN          (0x00000002)
#define FWPM_LAYER_FLAG_CLASSIFY_MOSTLY  (0x00000004)
#define FWPM_LAYER_FLAG_BUFFERED         (0x00000008)
typedef /* [v1_enum] */ 
enum FWPM_FIELD_TYPE_
    {	FWPM_FIELD_RAW_DATA	= 0,
	FWPM_FIELD_IP_ADDRESS	= ( FWPM_FIELD_RAW_DATA + 1 ) ,
	FWPM_FIELD_FLAGS	= ( FWPM_FIELD_IP_ADDRESS + 1 ) ,
	FWPM_FIELD_TYPE_MAX	= ( FWPM_FIELD_FLAGS + 1 ) 
    } 	FWPM_FIELD_TYPE;

typedef struct FWPM_FIELD0_
    {
    GUID *fieldKey;
    FWPM_FIELD_TYPE type;
    FWP_DATA_TYPE dataType;
    } 	FWPM_FIELD0;

typedef struct FWPM_LAYER0_
    {
    GUID layerKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    UINT32 numFields;
    FWPM_FIELD0 *field;
    GUID defaultSubLayerKey;
    UINT16 layerId;
    } 	FWPM_LAYER0;

typedef struct FWPM_LAYER_ENUM_TEMPLATE0_
    {
    UINT64 reserved;
    } 	FWPM_LAYER_ENUM_TEMPLATE0;

#define FWPM_CALLOUT_FLAG_PERSISTENT             (0x00010000)
#define FWPM_CALLOUT_FLAG_USES_PROVIDER_CONTEXT  (0x00020000)
#define FWPM_CALLOUT_FLAG_REGISTERED             (0x00040000)
typedef struct FWPM_CALLOUT0_
    {
    GUID calloutKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    GUID *providerKey;
    FWP_BYTE_BLOB providerData;
    GUID applicableLayer;
    UINT32 calloutId;
    } 	FWPM_CALLOUT0;

typedef struct FWPM_CALLOUT_ENUM_TEMPLATE0_
    {
    GUID *providerKey;
    GUID layerKey;
    } 	FWPM_CALLOUT_ENUM_TEMPLATE0;

typedef struct FWPM_CALLOUT_CHANGE0_
    {
    FWPM_CHANGE_TYPE changeType;
    GUID calloutKey;
    UINT32 calloutId;
    } 	FWPM_CALLOUT_CHANGE0;

typedef struct FWPM_CALLOUT_SUBSCRIPTION0_
    {
    FWPM_CALLOUT_ENUM_TEMPLATE0 *enumTemplate;
    UINT32 flags;
    GUID sessionKey;
    } 	FWPM_CALLOUT_SUBSCRIPTION0;

typedef struct FWPM_ACTION0_
    {
    FWP_ACTION_TYPE type;
    /* [switch_type] */ union 
        {
        GUID filterType;
        GUID calloutKey;
        } 	;
    } 	FWPM_ACTION0;

typedef struct FWPM_FILTER_CONDITION0_
    {
    GUID fieldKey;
    FWP_MATCH_TYPE matchType;
    FWP_CONDITION_VALUE0 conditionValue;
    } 	FWPM_FILTER_CONDITION0;

#define FWPM_FILTER_FLAG_NONE (0x00000000)
#define FWPM_FILTER_FLAG_PERSISTENT (0x00000001)
#define FWPM_FILTER_FLAG_BOOTTIME (0x00000002)
#define FWPM_FILTER_FLAG_HAS_PROVIDER_CONTEXT  (0x00000004)
#define FWPM_FILTER_FLAG_CLEAR_ACTION_RIGHT (0x00000008)
#define FWPM_FILTER_FLAG_PERMIT_IF_CALLOUT_UNREGISTERED (0x00000010)
#define FWPM_FILTER_FLAG_DISABLED (0x00000020)
typedef struct FWPM_FILTER0_
    {
    GUID filterKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    GUID *providerKey;
    FWP_BYTE_BLOB providerData;
    GUID layerKey;
    GUID subLayerKey;
    FWP_VALUE0 weight;
    UINT32 numFilterConditions;
    FWPM_FILTER_CONDITION0 *filterCondition;
    FWPM_ACTION0 action;
    /* [switch_type] */ union 
        {
        UINT64 rawContext;
        GUID providerContextKey;
        } 	;
    GUID *reserved;
    UINT64 filterId;
    FWP_VALUE0 effectiveWeight;
    } 	FWPM_FILTER0;

typedef struct FWPM_FILTER_ENUM_TEMPLATE0_
    {
    GUID *providerKey;
    GUID layerKey;
    FWP_FILTER_ENUM_TYPE enumType;
    UINT32 flags;
    FWPM_PROVIDER_CONTEXT_ENUM_TEMPLATE0 *providerContextTemplate;
    UINT32 numFilterConditions;
    FWPM_FILTER_CONDITION0 *filterCondition;
    UINT32 actionMask;
    GUID *calloutKey;
    } 	FWPM_FILTER_ENUM_TEMPLATE0;

typedef struct FWPM_FILTER_CHANGE0_
    {
    FWPM_CHANGE_TYPE changeType;
    GUID filterKey;
    UINT64 filterId;
    } 	FWPM_FILTER_CHANGE0;

typedef struct FWPM_FILTER_SUBSCRIPTION0_
    {
    FWPM_FILTER_ENUM_TEMPLATE0 *enumTemplate;
    UINT32 flags;
    GUID sessionKey;
    } 	FWPM_FILTER_SUBSCRIPTION0;

typedef struct FWPM_LAYER_STATISTICS0_
    {
    GUID layerId;
    UINT32 classifyPermitCount;
    UINT32 classifyBlockCount;
    UINT32 classifyVetoCount;
    UINT32 numCacheEntries;
    } 	FWPM_LAYER_STATISTICS0;

typedef struct FWPM_STATISTICS0_
    {
    UINT32 numLayerStatistics;
    FWPM_LAYER_STATISTICS0 *layerStatistics;
    UINT32 inboundAllowedConnectionsV4;
    UINT32 inboundBlockedConnectionsV4;
    UINT32 outboundAllowedConnectionsV4;
    UINT32 outboundBlockedConnectionsV4;
    UINT32 inboundAllowedConnectionsV6;
    UINT32 inboundBlockedConnectionsV6;
    UINT32 outboundAllowedConnectionsV6;
    UINT32 outboundBlockedConnectionsV6;
    UINT32 inboundActiveConnectionsV4;
    UINT32 outboundActiveConnectionsV4;
    UINT32 inboundActiveConnectionsV6;
    UINT32 outboundActiveConnectionsV6;
    } 	FWPM_STATISTICS0;

#define FWPM_NET_EVENT_FLAG_IP_PROTOCOL_SET (0x00000001)
#define FWPM_NET_EVENT_FLAG_LOCAL_ADDR_SET  (0x00000002)
#define FWPM_NET_EVENT_FLAG_REMOTE_ADDR_SET (0x00000004)
#define FWPM_NET_EVENT_FLAG_LOCAL_PORT_SET  (0x00000008)
#define FWPM_NET_EVENT_FLAG_REMOTE_PORT_SET (0x00000010)
#define FWPM_NET_EVENT_FLAG_APP_ID_SET      (0x00000020)
#define FWPM_NET_EVENT_FLAG_USER_ID_SET     (0x00000040)
#define FWPM_NET_EVENT_FLAG_SCOPE_ID_SET    (0x00000080)
#define FWPM_NET_EVENT_FLAG_IP_VERSION_SET  (0x00000100)
typedef struct FWPM_NET_EVENT_HEADER0_
    {
    FILETIME timeStamp;
    UINT32 flags;
    FWP_IP_VERSION ipVersion;
    UINT8 ipProtocol;
    union 
        {
        UINT32 localAddrV4;
        FWP_BYTE_ARRAY16 localAddrV6;
        } 	;
    union 
        {
        UINT32 remoteAddrV4;
        FWP_BYTE_ARRAY16 remoteAddrV6;
        } 	;
    UINT16 localPort;
    UINT16 remotePort;
    UINT32 scopeId;
    FWP_BYTE_BLOB appId;
    SID *userId;
    } 	FWPM_NET_EVENT_HEADER0;

typedef /* [v1_enum] */ 
enum FWPM_NET_EVENT_TYPE_
    {	FWPM_NET_EVENT_TYPE_IKEEXT_MM_FAILURE	= 0,
	FWPM_NET_EVENT_TYPE_IKEEXT_QM_FAILURE	= ( FWPM_NET_EVENT_TYPE_IKEEXT_MM_FAILURE + 1 ) ,
	FWPM_NET_EVENT_TYPE_IKEEXT_EM_FAILURE	= ( FWPM_NET_EVENT_TYPE_IKEEXT_QM_FAILURE + 1 ) ,
	FWPM_NET_EVENT_TYPE_CLASSIFY_DROP	= ( FWPM_NET_EVENT_TYPE_IKEEXT_EM_FAILURE + 1 ) ,
	FWPM_NET_EVENT_TYPE_IPSEC_KERNEL_DROP	= ( FWPM_NET_EVENT_TYPE_CLASSIFY_DROP + 1 ) ,
	FWPM_NET_EVENT_TYPE_MAX	= ( FWPM_NET_EVENT_TYPE_IPSEC_KERNEL_DROP + 1 ) 
    } 	FWPM_NET_EVENT_TYPE;

#define IKEEXT_CERT_HASH_LEN 20
#define FWPM_NET_EVENT_IKEEXT_MM_FAILURE_FLAG_BENIGN (0x00000001)
#define FWPM_NET_EVENT_IKEEXT_MM_FAILURE_FLAG_MULTIPLE (0x00000002)
typedef struct FWPM_NET_EVENT_IKEEXT_MM_FAILURE0_
    {
    UINT32 failureErrorCode;
    IPSEC_FAILURE_POINT failurePoint;
    UINT32 flags;
    IKEEXT_KEY_MODULE_TYPE keyingModuleType;
    IKEEXT_MM_SA_STATE mmState;
    IKEEXT_SA_ROLE saRole;
    IKEEXT_AUTHENTICATION_METHOD_TYPE mmAuthMethod;
    UINT8 endCertHash[ 20 ];
    UINT64 mmId;
    UINT64 mmFilterId;
    } 	FWPM_NET_EVENT_IKEEXT_MM_FAILURE0;

typedef struct FWPM_NET_EVENT_IKEEXT_QM_FAILURE0_
    {
    UINT32 failureErrorCode;
    IPSEC_FAILURE_POINT failurePoint;
    IKEEXT_KEY_MODULE_TYPE keyingModuleType;
    IKEEXT_QM_SA_STATE qmState;
    IKEEXT_SA_ROLE saRole;
    IPSEC_TRAFFIC_TYPE saTrafficType;
    union 
        {
         /* Empty union arm */ 
        FWP_CONDITION_VALUE0 localSubNet;
        } 	;
    union 
        {
         /* Empty union arm */ 
        FWP_CONDITION_VALUE0 remoteSubNet;
        } 	;
    UINT64 qmFilterId;
    } 	FWPM_NET_EVENT_IKEEXT_QM_FAILURE0;

#define FWPM_NET_EVENT_IKEEXT_EM_FAILURE_FLAG_MULTIPLE (0x00000001)
typedef struct FWPM_NET_EVENT_IKEEXT_EM_FAILURE0_
    {
    UINT32 failureErrorCode;
    IPSEC_FAILURE_POINT failurePoint;
    UINT32 flags;
    IKEEXT_EM_SA_STATE emState;
    IKEEXT_SA_ROLE saRole;
    IKEEXT_AUTHENTICATION_METHOD_TYPE emAuthMethod;
    UINT8 endCertHash[ 20 ];
    UINT64 mmId;
    UINT64 qmFilterId;
    } 	FWPM_NET_EVENT_IKEEXT_EM_FAILURE0;

typedef struct FWPM_NET_EVENT_CLASSIFY_DROP0_
    {
    UINT64 filterId;
    UINT16 layerId;
    } 	FWPM_NET_EVENT_CLASSIFY_DROP0;

typedef struct FWPM_NET_EVENT_IPSEC_KERNEL_DROP0_
    {
    INT32 failureStatus;
    FWP_DIRECTION direction;
    IPSEC_SA_SPI spi;
    UINT64 filterId;
    UINT16 layerId;
    } 	FWPM_NET_EVENT_IPSEC_KERNEL_DROP0;

typedef struct FWPM_NET_EVENT0_
    {
    FWPM_NET_EVENT_HEADER0 header;
    FWPM_NET_EVENT_TYPE type;
    union 
        {
        FWPM_NET_EVENT_IKEEXT_MM_FAILURE0 *ikeMmFailure;
        FWPM_NET_EVENT_IKEEXT_QM_FAILURE0 *ikeQmFailure;
        FWPM_NET_EVENT_IKEEXT_EM_FAILURE0 *ikeEmFailure;
        FWPM_NET_EVENT_CLASSIFY_DROP0 *classifyDrop;
        FWPM_NET_EVENT_IPSEC_KERNEL_DROP0 *ipsecDrop;
        } 	;
    } 	FWPM_NET_EVENT0;

typedef struct FWPM_NET_EVENT_ENUM_TEMPLATE0_
    {
    FILETIME startTime;
    FILETIME endTime;
    UINT32 numFilterConditions;
    FWPM_FILTER_CONDITION0 *filterCondition;
    } 	FWPM_NET_EVENT_ENUM_TEMPLATE0;

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_fwpmtypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fwpmtypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\fusion.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for fusion.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fusion_h__
#define __fusion_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAssemblyCache_FWD_DEFINED__
#define __IAssemblyCache_FWD_DEFINED__
typedef interface IAssemblyCache IAssemblyCache;
#endif 	/* __IAssemblyCache_FWD_DEFINED__ */


#ifndef __IAssemblyCacheItem_FWD_DEFINED__
#define __IAssemblyCacheItem_FWD_DEFINED__
typedef interface IAssemblyCacheItem IAssemblyCacheItem;
#endif 	/* __IAssemblyCacheItem_FWD_DEFINED__ */


#ifndef __IAssemblyName_FWD_DEFINED__
#define __IAssemblyName_FWD_DEFINED__
typedef interface IAssemblyName IAssemblyName;
#endif 	/* __IAssemblyName_FWD_DEFINED__ */


#ifndef __IAssemblyEnum_FWD_DEFINED__
#define __IAssemblyEnum_FWD_DEFINED__
typedef interface IAssemblyEnum IAssemblyEnum;
#endif 	/* __IAssemblyEnum_FWD_DEFINED__ */


#ifndef __IInstallReferenceItem_FWD_DEFINED__
#define __IInstallReferenceItem_FWD_DEFINED__
typedef interface IInstallReferenceItem IInstallReferenceItem;
#endif 	/* __IInstallReferenceItem_FWD_DEFINED__ */


#ifndef __IInstallReferenceEnum_FWD_DEFINED__
#define __IInstallReferenceEnum_FWD_DEFINED__
typedef interface IInstallReferenceEnum IInstallReferenceEnum;
#endif 	/* __IInstallReferenceEnum_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_fusion_0000 */
/* [local] */ 


#ifdef _MSC_VER
#pragma comment(lib,"uuid.lib")
#endif

//---------------------------------------------------------------------------=
// Fusion Interfaces.

#ifdef _MSC_VER
#pragma once
#endif




typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0000_0001
    {	ASM_CACHE_ZAP	= 0x1,
	ASM_CACHE_GAC	= 0x2,
	ASM_CACHE_DOWNLOAD	= 0x4,
	ASM_CACHE_ROOT	= 0x8
    } 	ASM_CACHE_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0000_0002
    {	peNone	= 0,
	peMSIL	= 0x1,
	peI386	= 0x2,
	peIA64	= 0x3,
	peAMD64	= 0x4,
	peInvalid	= 0xffffffff
    } 	PEKIND;



extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_s_ifspec;

#ifndef __IAssemblyCache_INTERFACE_DEFINED__
#define __IAssemblyCache_INTERFACE_DEFINED__

/* interface IAssemblyCache */
/* [unique][uuid][object][local] */ 

// {8cedc215-ac4b-488b-93c0-a50a49cb2fb8}
EXTERN_GUID(FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID, 0x8cedc215, 0xac4b, 0x488b, 0x93, 0xc0, 0xa5, 0x0a, 0x49, 0xcb, 0x2f, 0xb8);

// {b02f9d65-fb77-4f7a-afa5-b391309f11c9}
EXTERN_GUID(FUSION_REFCOUNT_FILEPATH_GUID, 0xb02f9d65, 0xfb77, 0x4f7a, 0xaf, 0xa5, 0xb3, 0x91, 0x30, 0x9f, 0x11, 0xc9);

// {2ec93463-b0c3-45e1-8364-327e96aea856}
EXTERN_GUID(FUSION_REFCOUNT_OPAQUE_STRING_GUID, 0x2ec93463, 0xb0c3, 0x45e1, 0x83, 0x64, 0x32, 0x7e, 0x96, 0xae, 0xa8, 0x56);
 // {25df0fc1-7f97-4070-add7-4b13bbfd7cb8} // this GUID cannot be used for installing into GAC.
EXTERN_GUID(FUSION_REFCOUNT_MSI_GUID,  0x25df0fc1, 0x7f97, 0x4070, 0xad, 0xd7, 0x4b, 0x13, 0xbb, 0xfd, 0x7c, 0xb8); 
 // {d16d444c-56d8-11d5-882d-0080c847b195}
EXTERN_GUID(FUSION_REFCOUNT_OSINSTALL_GUID, 0xd16d444c, 0x56d8, 0x11d5, 0x88, 0x2d, 0x00, 0x80, 0xc8, 0x47, 0xb1, 0x95); 
typedef struct _FUSION_INSTALL_REFERENCE_
    {
    DWORD cbSize;
    DWORD dwFlags;
    GUID guidScheme;
    LPCWSTR szIdentifier;
    LPCWSTR szNonCannonicalData;
    } 	FUSION_INSTALL_REFERENCE;

typedef struct _FUSION_INSTALL_REFERENCE_ *LPFUSION_INSTALL_REFERENCE;

typedef const FUSION_INSTALL_REFERENCE *LPCFUSION_INSTALL_REFERENCE;

typedef struct _ASSEMBLY_INFO
    {
    ULONG cbAssemblyInfo;
    DWORD dwAssemblyFlags;
    ULARGE_INTEGER uliAssemblySizeInKB;
    LPWSTR pszCurrentAssemblyPathBuf;
    ULONG cchBuf;
    } 	ASSEMBLY_INFO;

#define IASSEMBLYCACHE_INSTALL_FLAG_REFRESH       (0x00000001)
#define IASSEMBLYCACHE_INSTALL_FLAG_FORCE_REFRESH (0x00000002)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED (1)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE (2)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED (3)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING (4)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES (5)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND (6)
#define QUERYASMINFO_FLAG_VALIDATE        (0x00000001)
#define QUERYASMINFO_FLAG_GETSIZE         (0x00000002)
#define ASSEMBLYINFO_FLAG_INSTALLED       (0x00000001)
#define ASSEMBLYINFO_FLAG_PAYLOADRESIDENT (0x00000002)

EXTERN_C const IID IID_IAssemblyCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e707dcde-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UninstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAssemblyInfo( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyCacheItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyScavenger( 
            /* [out] */ IUnknown **ppUnkReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *UninstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAssemblyInfo )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyCacheItem )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyScavenger )( 
            IAssemblyCache * This,
            /* [out] */ IUnknown **ppUnkReserved);
        
        HRESULT ( STDMETHODCALLTYPE *InstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData);
        
        END_INTERFACE
    } IAssemblyCacheVtbl;

    interface IAssemblyCache
    {
        CONST_VTBL struct IAssemblyCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCache_UninstallAssembly(This,dwFlags,pszAssemblyName,pRefData,pulDisposition)	\
    (This)->lpVtbl -> UninstallAssembly(This,dwFlags,pszAssemblyName,pRefData,pulDisposition)

#define IAssemblyCache_QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)	\
    (This)->lpVtbl -> QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)

#define IAssemblyCache_CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)	\
    (This)->lpVtbl -> CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)

#define IAssemblyCache_CreateAssemblyScavenger(This,ppUnkReserved)	\
    (This)->lpVtbl -> CreateAssemblyScavenger(This,ppUnkReserved)

#define IAssemblyCache_InstallAssembly(This,dwFlags,pszManifestFilePath,pRefData)	\
    (This)->lpVtbl -> InstallAssembly(This,dwFlags,pszManifestFilePath,pRefData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCache_UninstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCache_UninstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_QueryAssemblyInfo_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);


void __RPC_STUB IAssemblyCache_QueryAssemblyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyCacheItem_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ PVOID pvReserved,
    /* [out] */ IAssemblyCacheItem **ppAsmItem,
    /* [optional][in] */ LPCWSTR pszAssemblyName);


void __RPC_STUB IAssemblyCache_CreateAssemblyCacheItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyScavenger_Proxy( 
    IAssemblyCache * This,
    /* [out] */ IUnknown **ppUnkReserved);


void __RPC_STUB IAssemblyCache_CreateAssemblyScavenger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_InstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszManifestFilePath,
    /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData);


void __RPC_STUB IAssemblyCache_InstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCache_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCacheItem_INTERFACE_DEFINED__
#define __IAssemblyCacheItem_INTERFACE_DEFINED__

/* interface IAssemblyCacheItem */
/* [unique][uuid][object][local] */ 

#define STREAM_FORMAT_COMPLIB_MODULE    0
#define STREAM_FORMAT_COMPLIB_MANIFEST  1
#define STREAM_FORMAT_WIN32_MODULE      2
#define STREAM_FORMAT_WIN32_MANIFEST    4
#define IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH       (0x00000001)
#define IASSEMBLYCACHEITEM_COMMIT_FLAG_FORCE_REFRESH (0x00000002)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED (1)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED (2)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED (3)

EXTERN_C const IID IID_IAssemblyCacheItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCacheItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortItem( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCacheItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCacheItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCacheItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *AbortItem )( 
            IAssemblyCacheItem * This);
        
        END_INTERFACE
    } IAssemblyCacheItemVtbl;

    interface IAssemblyCacheItem
    {
        CONST_VTBL struct IAssemblyCacheItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCacheItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCacheItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCacheItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCacheItem_CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)	\
    (This)->lpVtbl -> CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)

#define IAssemblyCacheItem_Commit(This,dwFlags,pulDisposition)	\
    (This)->lpVtbl -> Commit(This,dwFlags,pulDisposition)

#define IAssemblyCacheItem_AbortItem(This)	\
    (This)->lpVtbl -> AbortItem(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_CreateStream_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszStreamName,
    /* [in] */ DWORD dwFormat,
    /* [in] */ DWORD dwFormatFlags,
    /* [out] */ IStream **ppIStream,
    /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);


void __RPC_STUB IAssemblyCacheItem_CreateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_Commit_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCacheItem_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_AbortItem_Proxy( 
    IAssemblyCacheItem * This);


void __RPC_STUB IAssemblyCacheItem_AbortItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCacheItem_INTERFACE_DEFINED__ */


#ifndef __IAssemblyName_INTERFACE_DEFINED__
#define __IAssemblyName_INTERFACE_DEFINED__

/* interface IAssemblyName */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyName *LPASSEMBLYNAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0001
    {	CANOF_PARSE_DISPLAY_NAME	= 0x1,
	CANOF_SET_DEFAULT_VALUES	= 0x2,
	CANOF_VERIFY_FRIEND_ASSEMBLYNAME	= 0x4,
	CANOF_PARSE_FRIEND_DISPLAY_NAME	= CANOF_PARSE_DISPLAY_NAME | CANOF_VERIFY_FRIEND_ASSEMBLYNAME
    } 	CREATE_ASM_NAME_OBJ_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0002
    {	ASM_NAME_PUBLIC_KEY	= 0,
	ASM_NAME_PUBLIC_KEY_TOKEN	= ASM_NAME_PUBLIC_KEY + 1,
	ASM_NAME_HASH_VALUE	= ASM_NAME_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NAME	= ASM_NAME_HASH_VALUE + 1,
	ASM_NAME_MAJOR_VERSION	= ASM_NAME_NAME + 1,
	ASM_NAME_MINOR_VERSION	= ASM_NAME_MAJOR_VERSION + 1,
	ASM_NAME_BUILD_NUMBER	= ASM_NAME_MINOR_VERSION + 1,
	ASM_NAME_REVISION_NUMBER	= ASM_NAME_BUILD_NUMBER + 1,
	ASM_NAME_CULTURE	= ASM_NAME_REVISION_NUMBER + 1,
	ASM_NAME_PROCESSOR_ID_ARRAY	= ASM_NAME_CULTURE + 1,
	ASM_NAME_OSINFO_ARRAY	= ASM_NAME_PROCESSOR_ID_ARRAY + 1,
	ASM_NAME_HASH_ALGID	= ASM_NAME_OSINFO_ARRAY + 1,
	ASM_NAME_ALIAS	= ASM_NAME_HASH_ALGID + 1,
	ASM_NAME_CODEBASE_URL	= ASM_NAME_ALIAS + 1,
	ASM_NAME_CODEBASE_LASTMOD	= ASM_NAME_CODEBASE_URL + 1,
	ASM_NAME_NULL_PUBLIC_KEY	= ASM_NAME_CODEBASE_LASTMOD + 1,
	ASM_NAME_NULL_PUBLIC_KEY_TOKEN	= ASM_NAME_NULL_PUBLIC_KEY + 1,
	ASM_NAME_CUSTOM	= ASM_NAME_NULL_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NULL_CUSTOM	= ASM_NAME_CUSTOM + 1,
	ASM_NAME_MVID	= ASM_NAME_NULL_CUSTOM + 1,
	ASM_NAME_FILE_MAJOR_VERSION	= ASM_NAME_MVID + 1,
	ASM_NAME_FILE_MINOR_VERSION	= ASM_NAME_FILE_MAJOR_VERSION + 1,
	ASM_NAME_FILE_BUILD_NUMBER	= ASM_NAME_FILE_MINOR_VERSION + 1,
	ASM_NAME_FILE_REVISION_NUMBER	= ASM_NAME_FILE_BUILD_NUMBER + 1,
	ASM_NAME_RETARGET	= ASM_NAME_FILE_REVISION_NUMBER + 1,
	ASM_NAME_SIGNATURE_BLOB	= ASM_NAME_RETARGET + 1,
	ASM_NAME_CONFIG_MASK	= ASM_NAME_SIGNATURE_BLOB + 1,
	ASM_NAME_ARCHITECTURE	= ASM_NAME_CONFIG_MASK + 1,
	ASM_NAME_MAX_PARAMS	= ASM_NAME_ARCHITECTURE + 1
    } 	ASM_NAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0003
    {	ASM_DISPLAYF_VERSION	= 0x1,
	ASM_DISPLAYF_CULTURE	= 0x2,
	ASM_DISPLAYF_PUBLIC_KEY_TOKEN	= 0x4,
	ASM_DISPLAYF_PUBLIC_KEY	= 0x8,
	ASM_DISPLAYF_CUSTOM	= 0x10,
	ASM_DISPLAYF_PROCESSORARCHITECTURE	= 0x20,
	ASM_DISPLAYF_LANGUAGEID	= 0x40,
	ASM_DISPLAYF_RETARGET	= 0x80,
	ASM_DISPLAYF_CONFIG_MASK	= 0x100,
	ASM_DISPLAYF_MVID	= 0x200,
	ASM_DISPLAYF_FULL	= ASM_DISPLAYF_VERSION | ASM_DISPLAYF_CULTURE | ASM_DISPLAYF_PUBLIC_KEY_TOKEN | ASM_DISPLAYF_RETARGET | ASM_DISPLAYF_PROCESSORARCHITECTURE
    } 	ASM_DISPLAY_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0004
    {	ASM_CMPF_NAME	= 0x1,
	ASM_CMPF_MAJOR_VERSION	= 0x2,
	ASM_CMPF_MINOR_VERSION	= 0x4,
	ASM_CMPF_BUILD_NUMBER	= 0x8,
	ASM_CMPF_REVISION_NUMBER	= 0x10,
	ASM_CMPF_VERSION	= ASM_CMPF_MAJOR_VERSION | ASM_CMPF_MINOR_VERSION | ASM_CMPF_BUILD_NUMBER | ASM_CMPF_REVISION_NUMBER,
	ASM_CMPF_PUBLIC_KEY_TOKEN	= 0x20,
	ASM_CMPF_CULTURE	= 0x40,
	ASM_CMPF_CUSTOM	= 0x80,
	ASM_CMPF_DEFAULT	= 0x100,
	ASM_CMPF_RETARGET	= 0x200,
	ASM_CMPF_ARCHITECTURE	= 0x400,
	ASM_CMPF_CONFIG_MASK	= 0x800,
	ASM_CMPF_MVID	= 0x1000,
	ASM_CMPF_SIGNATURE	= 0x2000,
	ASM_CMPF_IL_ALL	= ASM_CMPF_NAME | ASM_CMPF_VERSION | ASM_CMPF_PUBLIC_KEY_TOKEN | ASM_CMPF_CULTURE,
	ASM_CMPF_IL_NO_VERSION	= ASM_CMPF_NAME | ASM_CMPF_PUBLIC_KEY_TOKEN | ASM_CMPF_CULTURE
    } 	ASM_CMP_FLAGS;


EXTERN_C const IID IID_IAssemblyName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")
    IAssemblyName : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finalize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reserved( 
            /* [in] */ REFIID refIID,
            /* [in] */ IUnknown *pUnkReserved1,
            /* [in] */ IUnknown *pUnkReserved2,
            /* [in] */ LPCOLESTR szReserved,
            /* [in] */ LONGLONG llReserved,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyName **pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyName * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *Finalize )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IAssemblyName * This,
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Reserved )( 
            IAssemblyName * This,
            /* [in] */ REFIID refIID,
            /* [in] */ IUnknown *pUnkReserved1,
            /* [in] */ IUnknown *pUnkReserved2,
            /* [in] */ LPCOLESTR szReserved,
            /* [in] */ LONGLONG llReserved,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IAssemblyName * This,
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IAssemblyName * This,
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IAssemblyName * This,
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyName * This,
            /* [out] */ IAssemblyName **pName);
        
        END_INTERFACE
    } IAssemblyNameVtbl;

    interface IAssemblyName
    {
        CONST_VTBL struct IAssemblyNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyName_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyName_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyName_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyName_SetProperty(This,PropertyId,pvProperty,cbProperty)	\
    (This)->lpVtbl -> SetProperty(This,PropertyId,pvProperty,cbProperty)

#define IAssemblyName_GetProperty(This,PropertyId,pvProperty,pcbProperty)	\
    (This)->lpVtbl -> GetProperty(This,PropertyId,pvProperty,pcbProperty)

#define IAssemblyName_Finalize(This)	\
    (This)->lpVtbl -> Finalize(This)

#define IAssemblyName_GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)	\
    (This)->lpVtbl -> GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)

#define IAssemblyName_Reserved(This,refIID,pUnkReserved1,pUnkReserved2,szReserved,llReserved,pvReserved,cbReserved,ppReserved)	\
    (This)->lpVtbl -> Reserved(This,refIID,pUnkReserved1,pUnkReserved2,szReserved,llReserved,pvReserved,cbReserved,ppReserved)

#define IAssemblyName_GetName(This,lpcwBuffer,pwzName)	\
    (This)->lpVtbl -> GetName(This,lpcwBuffer,pwzName)

#define IAssemblyName_GetVersion(This,pdwVersionHi,pdwVersionLow)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersionHi,pdwVersionLow)

#define IAssemblyName_IsEqual(This,pName,dwCmpFlags)	\
    (This)->lpVtbl -> IsEqual(This,pName,dwCmpFlags)

#define IAssemblyName_Clone(This,pName)	\
    (This)->lpVtbl -> Clone(This,pName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyName_SetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [in] */ LPVOID pvProperty,
    /* [in] */ DWORD cbProperty);


void __RPC_STUB IAssemblyName_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [out] */ LPVOID pvProperty,
    /* [out][in] */ LPDWORD pcbProperty);


void __RPC_STUB IAssemblyName_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Finalize_Proxy( 
    IAssemblyName * This);


void __RPC_STUB IAssemblyName_Finalize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetDisplayName_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPOLESTR szDisplayName,
    /* [out][in] */ LPDWORD pccDisplayName,
    /* [in] */ DWORD dwDisplayFlags);


void __RPC_STUB IAssemblyName_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Reserved_Proxy( 
    IAssemblyName * This,
    /* [in] */ REFIID refIID,
    /* [in] */ IUnknown *pUnkReserved1,
    /* [in] */ IUnknown *pUnkReserved2,
    /* [in] */ LPCOLESTR szReserved,
    /* [in] */ LONGLONG llReserved,
    /* [in] */ LPVOID pvReserved,
    /* [in] */ DWORD cbReserved,
    /* [out] */ LPVOID *ppReserved);


void __RPC_STUB IAssemblyName_Reserved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetName_Proxy( 
    IAssemblyName * This,
    /* [out][in] */ LPDWORD lpcwBuffer,
    /* [out] */ WCHAR *pwzName);


void __RPC_STUB IAssemblyName_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetVersion_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPDWORD pdwVersionHi,
    /* [out] */ LPDWORD pdwVersionLow);


void __RPC_STUB IAssemblyName_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_IsEqual_Proxy( 
    IAssemblyName * This,
    /* [in] */ IAssemblyName *pName,
    /* [in] */ DWORD dwCmpFlags);


void __RPC_STUB IAssemblyName_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Clone_Proxy( 
    IAssemblyName * This,
    /* [out] */ IAssemblyName **pName);


void __RPC_STUB IAssemblyName_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyName_INTERFACE_DEFINED__ */


#ifndef __IAssemblyEnum_INTERFACE_DEFINED__
#define __IAssemblyEnum_INTERFACE_DEFINED__

/* interface IAssemblyEnum */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21b8916c-f28e-11d2-a473-00c04f8ef448")
    IAssemblyEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextAssembly( 
            /* [in] */ LPVOID pvReserved,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyEnum **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssembly )( 
            IAssemblyEnum * This,
            /* [in] */ LPVOID pvReserved,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyEnum * This,
            /* [out] */ IAssemblyEnum **ppEnum);
        
        END_INTERFACE
    } IAssemblyEnumVtbl;

    interface IAssemblyEnum
    {
        CONST_VTBL struct IAssemblyEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyEnum_GetNextAssembly(This,pvReserved,ppName,dwFlags)	\
    (This)->lpVtbl -> GetNextAssembly(This,pvReserved,ppName,dwFlags)

#define IAssemblyEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IAssemblyEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyEnum_GetNextAssembly_Proxy( 
    IAssemblyEnum * This,
    /* [in] */ LPVOID pvReserved,
    /* [out] */ IAssemblyName **ppName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyEnum_GetNextAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Reset_Proxy( 
    IAssemblyEnum * This);


void __RPC_STUB IAssemblyEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Clone_Proxy( 
    IAssemblyEnum * This,
    /* [out] */ IAssemblyEnum **ppEnum);


void __RPC_STUB IAssemblyEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyEnum_INTERFACE_DEFINED__ */


#ifndef __IInstallReferenceItem_INTERFACE_DEFINED__
#define __IInstallReferenceItem_INTERFACE_DEFINED__

/* interface IInstallReferenceItem */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInstallReferenceItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("582dac66-e678-449f-aba6-6faaec8a9394")
    IInstallReferenceItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReference( 
            /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallReferenceItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallReferenceItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallReferenceItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallReferenceItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReference )( 
            IInstallReferenceItem * This,
            /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved);
        
        END_INTERFACE
    } IInstallReferenceItemVtbl;

    interface IInstallReferenceItem
    {
        CONST_VTBL struct IInstallReferenceItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallReferenceItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstallReferenceItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstallReferenceItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstallReferenceItem_GetReference(This,ppRefData,dwFlags,pvReserved)	\
    (This)->lpVtbl -> GetReference(This,ppRefData,dwFlags,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstallReferenceItem_GetReference_Proxy( 
    IInstallReferenceItem * This,
    /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPVOID pvReserved);


void __RPC_STUB IInstallReferenceItem_GetReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstallReferenceItem_INTERFACE_DEFINED__ */


#ifndef __IInstallReferenceEnum_INTERFACE_DEFINED__
#define __IInstallReferenceEnum_INTERFACE_DEFINED__

/* interface IInstallReferenceEnum */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInstallReferenceEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56b1a988-7c0c-4aa2-8639-c3eb5a90226f")
    IInstallReferenceEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextInstallReferenceItem( 
            /* [out] */ IInstallReferenceItem **ppRefItem,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallReferenceEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallReferenceEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallReferenceEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallReferenceEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextInstallReferenceItem )( 
            IInstallReferenceEnum * This,
            /* [out] */ IInstallReferenceItem **ppRefItem,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved);
        
        END_INTERFACE
    } IInstallReferenceEnumVtbl;

    interface IInstallReferenceEnum
    {
        CONST_VTBL struct IInstallReferenceEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallReferenceEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstallReferenceEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstallReferenceEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstallReferenceEnum_GetNextInstallReferenceItem(This,ppRefItem,dwFlags,pvReserved)	\
    (This)->lpVtbl -> GetNextInstallReferenceItem(This,ppRefItem,dwFlags,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstallReferenceEnum_GetNextInstallReferenceItem_Proxy( 
    IInstallReferenceEnum * This,
    /* [out] */ IInstallReferenceItem **ppRefItem,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPVOID pvReserved);


void __RPC_STUB IInstallReferenceEnum_GetNextInstallReferenceItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstallReferenceEnum_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_fusion_0098 */
/* [local] */ 

typedef 
enum _tagAssemblyComparisonResult
    {	ACR_Unknown	= 0,
	ACR_EquivalentFullMatch	= ACR_Unknown + 1,
	ACR_EquivalentWeakNamed	= ACR_EquivalentFullMatch + 1,
	ACR_EquivalentFXUnified	= ACR_EquivalentWeakNamed + 1,
	ACR_EquivalentUnified	= ACR_EquivalentFXUnified + 1,
	ACR_NonEquivalentVersion	= ACR_EquivalentUnified + 1,
	ACR_NonEquivalent	= ACR_NonEquivalentVersion + 1,
	ACR_EquivalentPartialMatch	= ACR_NonEquivalent + 1,
	ACR_EquivalentPartialWeakNamed	= ACR_EquivalentPartialMatch + 1,
	ACR_EquivalentPartialUnified	= ACR_EquivalentPartialWeakNamed + 1,
	ACR_EquivalentPartialFXUnified	= ACR_EquivalentPartialUnified + 1,
	ACR_NonEquivalentPartialVersion	= ACR_EquivalentPartialFXUnified + 1
    } 	AssemblyComparisonResult;

STDAPI CompareAssemblyIdentity(LPCWSTR pwzAssemblyIdentity1, BOOL fUnified1, LPCWSTR pwzAssemblyIdentity2, BOOL fUnified2, BOOL *pfEquivalent, AssemblyComparisonResult *pResult); 
STDAPI CreateInstallReferenceEnum(IInstallReferenceEnum **ppRefEnum, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      
STDAPI CreateAssemblyEnum(IAssemblyEnum **pEnum, IUnknown *pUnkReserved, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      
STDAPI CreateAssemblyNameObject(LPASSEMBLYNAME *ppAssemblyNameObj, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved);             
STDAPI CreateAssemblyCache(IAssemblyCache **ppAsmCache, DWORD dwReserved); 
STDAPI GetCachePath(ASM_CACHE_FLAGS dwCacheFlags, LPWSTR pwzCachePath, PDWORD pcchPath); 
STDAPI GetAssemblyIdentityFromFile(LPCWSTR pwzFilePAth, REFIID riid, IUnknown **ppIdentity); 
STDAPI ClearDownloadCache();


extern RPC_IF_HANDLE __MIDL_itf_fusion_0098_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0098_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\fwpmu.h ===
/*
   Copyright (c) Microsoft Corporation

   SYNOPSIS

     Declares the management portion of the FWP API.
*/

#if (NTDDI_VERSION >= NTDDI_WIN6)

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in layers.
//
///////////////////////////////////////////////////////////////////////////////

// c86fd1bf-21cd-497e-a0bb-17425c885c58
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V4,
   0xc86fd1bf,
   0x21cd,
   0x497e,
   0xa0, 0xbb, 0x17, 0x42, 0x5c, 0x88, 0x5c, 0x58
);

// b5a230d0-a8c0-44f2-916e-991b53ded1f7
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V4_DISCARD,
   0xb5a230d0,
   0xa8c0,
   0x44f2,
   0x91, 0x6e, 0x99, 0x1b, 0x53, 0xde, 0xd1, 0xf7
);

// f52032cb-991c-46e7-971d-2601459a91ca
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V6,
   0xf52032cb,
   0x991c,
   0x46e7,
   0x97, 0x1d, 0x26, 0x01, 0x45, 0x9a, 0x91, 0xca
);

// bb24c279-93b4-47a2-83ad-ae1698b50885
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V6_DISCARD,
   0xbb24c279,
   0x93b4,
   0x47a2,
   0x83, 0xad, 0xae, 0x16, 0x98, 0xb5, 0x08, 0x85
);

// 1e5c9fae-8a84-4135-a331-950b54229ecd
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V4,
   0x1e5c9fae,
   0x8a84,
   0x4135,
   0xa3, 0x31, 0x95, 0x0b, 0x54, 0x22, 0x9e, 0xcd
);

// 08e4bcb5-b647-48f3-953c-e5ddbd03937e
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V4_DISCARD,
   0x08e4bcb5,
   0xb647,
   0x48f3,
   0x95, 0x3c, 0xe5, 0xdd, 0xbd, 0x03, 0x93, 0x7e
);

// a3b3ab6b-3564-488c-9117-f34e82142763
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V6,
   0xa3b3ab6b,
   0x3564,
   0x488c,
   0x91, 0x17, 0xf3, 0x4e, 0x82, 0x14, 0x27, 0x63
);

// 9513d7c4-a934-49dc-91a7-6ccb80cc02e3
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V6_DISCARD,
   0x9513d7c4,
   0xa934,
   0x49dc,
   0x91, 0xa7, 0x6c, 0xcb, 0x80, 0xcc, 0x02, 0xe3
);

// a82acc24-4ee1-4ee1-b465-fd1d25cb10a4
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V4,
   0xa82acc24,
   0x4ee1,
   0x4ee1,
   0xb4, 0x65, 0xfd, 0x1d, 0x25, 0xcb, 0x10, 0xa4
);

// 9e9ea773-2fae-4210-8f17-34129ef369eb
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V4_DISCARD,
   0x9e9ea773,
   0x2fae,
   0x4210,
   0x8f, 0x17, 0x34, 0x12, 0x9e, 0xf3, 0x69, 0xeb
);

// 7b964818-19c7-493a-b71f-832c3684d28c
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V6,
   0x7b964818,
   0x19c7,
   0x493a,
   0xb7, 0x1f, 0x83, 0x2c, 0x36, 0x84, 0xd2, 0x8c
);

// 31524a5d-1dfe-472f-bb93-518ee945d8a2
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V6_DISCARD,
   0x31524a5d,
   0x1dfe,
   0x472f,
   0xbb, 0x93, 0x51, 0x8e, 0xe9, 0x45, 0xd8, 0xa2
);

// 5926dfc8-e3cf-4426-a283-dc393f5d0f9d
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V4,
   0x5926dfc8,
   0xe3cf,
   0x4426,
   0xa2, 0x83, 0xdc, 0x39, 0x3f, 0x5d, 0x0f, 0x9d
);

// ac4a9833-f69d-4648-b261-6dc84835ef39
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V4_DISCARD,
   0xac4a9833,
   0xf69d,
   0x4648,
   0xb2, 0x61, 0x6d, 0xc8, 0x48, 0x35, 0xef, 0x39
);

// 634a869f-fc23-4b90-b0c1-bf620a36ae6f
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V6,
   0x634a869f,
   0xfc23,
   0x4b90,
   0xb0, 0xc1, 0xbf, 0x62, 0x0a, 0x36, 0xae, 0x6f
);

// 2a6ff955-3b2b-49d2-9848-ad9d72dcaab7
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V6_DISCARD,
   0x2a6ff955,
   0x3b2b,
   0x49d2,
   0x98, 0x48, 0xad, 0x9d, 0x72, 0xdc, 0xaa, 0xb7
);

// 09e61aea-d214-46e2-9b21-b26b0b2f28c8
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V4,
   0x09e61aea,
   0xd214,
   0x46e2,
   0x9b, 0x21, 0xb2, 0x6b, 0x0b, 0x2f, 0x28, 0xc8
);

// c5f10551-bdb0-43d7-a313-50e211f4d68a
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V4_DISCARD,
   0xc5f10551,
   0xbdb0,
   0x43d7,
   0xa3, 0x13, 0x50, 0xe2, 0x11, 0xf4, 0xd6, 0x8a
);

// e1735bde-013f-4655-b351-a49e15762df0
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V6,
   0xe1735bde,
   0x013f,
   0x4655,
   0xb3, 0x51, 0xa4, 0x9e, 0x15, 0x76, 0x2d, 0xf0
);

// f433df69-ccbd-482e-b9b2-57165658c3b3
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V6_DISCARD,
   0xf433df69,
   0xccbd,
   0x482e,
   0xb9, 0xb2, 0x57, 0x16, 0x56, 0x58, 0xc3, 0xb3
);

// 3b89653c-c170-49e4-b1cd-e0eeeee19a3e
DEFINE_GUID(
   FWPM_LAYER_STREAM_V4,
   0x3b89653c,
   0xc170,
   0x49e4,
   0xb1, 0xcd, 0xe0, 0xee, 0xee, 0xe1, 0x9a, 0x3e
);

// 25c4c2c2-25ff-4352-82f9-c54a4a4726dc
DEFINE_GUID(
   FWPM_LAYER_STREAM_V4_DISCARD,
   0x25c4c2c2,
   0x25ff,
   0x4352,
   0x82, 0xf9, 0xc5, 0x4a, 0x4a, 0x47, 0x26, 0xdc
);

// 47c9137a-7ec4-46b3-b6e4-48e926b1eda4
DEFINE_GUID(
   FWPM_LAYER_STREAM_V6,
   0x47c9137a,
   0x7ec4,
   0x46b3,
   0xb6, 0xe4, 0x48, 0xe9, 0x26, 0xb1, 0xed, 0xa4
);

// 10a59fc7-b628-4c41-9eb8-cf37d55103cf
DEFINE_GUID(
   FWPM_LAYER_STREAM_V6_DISCARD,
   0x10a59fc7,
   0xb628,
   0x4c41,
   0x9e, 0xb8, 0xcf, 0x37, 0xd5, 0x51, 0x03, 0xcf
);

// 3d08bf4e-45f6-4930-a922-417098e20027
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V4,
   0x3d08bf4e,
   0x45f6,
   0x4930,
   0xa9, 0x22, 0x41, 0x70, 0x98, 0xe2, 0x00, 0x27
);

// 18e330c6-7248-4e52-aaab-472ed67704fd
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V4_DISCARD,
   0x18e330c6,
   0x7248,
   0x4e52,
   0xaa, 0xab, 0x47, 0x2e, 0xd6, 0x77, 0x04, 0xfd
);

// fa45fe2f-3cba-4427-87fc-57b9a4b10d00
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V6,
   0xfa45fe2f,
   0x3cba,
   0x4427,
   0x87, 0xfc, 0x57, 0xb9, 0xa4, 0xb1, 0x0d, 0x00
);

// 09d1dfe1-9b86-4a42-be9d-8c315b92a5d0
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V6_DISCARD,
   0x09d1dfe1,
   0x9b86,
   0x4a42,
   0xbe, 0x9d, 0x8c, 0x31, 0x5b, 0x92, 0xa5, 0xd0
);

// 61499990-3cb6-4e84-b950-53b94b6964f3
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V4,
   0x61499990,
   0x3cb6,
   0x4e84,
   0xb9, 0x50, 0x53, 0xb9, 0x4b, 0x69, 0x64, 0xf3
);

// a6b17075-ebaf-4053-a4e7-213c8121ede5
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V4_DISCARD,
   0xa6b17075,
   0xebaf,
   0x4053,
   0xa4, 0xe7, 0x21, 0x3c, 0x81, 0x21, 0xed, 0xe5
);

// 65f9bdff-3b2d-4e5d-b8c6-c720651fe898
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V6,
   0x65f9bdff,
   0x3b2d,
   0x4e5d,
   0xb8, 0xc6, 0xc7, 0x20, 0x65, 0x1f, 0xe8, 0x98
);

// a6e7ccc0-08fb-468d-a472-9771d5595e09
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V6_DISCARD,
   0xa6e7ccc0,
   0x08fb,
   0x468d,
   0xa4, 0x72, 0x97, 0x71, 0xd5, 0x59, 0x5e, 0x09
);

// 41390100-564c-4b32-bc1d-718048354d7c
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V4,
   0x41390100,
   0x564c,
   0x4b32,
   0xbc, 0x1d, 0x71, 0x80, 0x48, 0x35, 0x4d, 0x7c
);

// b3598d36-0561-4588-a6bf-e955e3f6264b
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V4_DISCARD,
   0xb3598d36,
   0x0561,
   0x4588,
   0xa6, 0xbf, 0xe9, 0x55, 0xe3, 0xf6, 0x26, 0x4b
);

// 7fb03b60-7b8d-4dfa-badd-980176fc4e12
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V6,
   0x7fb03b60,
   0x7b8d,
   0x4dfa,
   0xba, 0xdd, 0x98, 0x01, 0x76, 0xfc, 0x4e, 0x12
);

// 65f2e647-8d0c-4f47-b19b-33a4d3f1357c
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V6_DISCARD,
   0x65f2e647,
   0x8d0c,
   0x4f47,
   0xb1, 0x9b, 0x33, 0xa4, 0xd3, 0xf1, 0x35, 0x7c
);

// 1247d66d-0b60-4a15-8d44-7155d0f53a0c
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4,
   0x1247d66d,
   0x0b60,
   0x4a15,
   0x8d, 0x44, 0x71, 0x55, 0xd0, 0xf5, 0x3a, 0x0c
);

// 0b5812a2-c3ff-4eca-b88d-c79e20ac6322
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4_DISCARD,
   0x0b5812a2,
   0xc3ff,
   0x4eca,
   0xb8, 0x8d, 0xc7, 0x9e, 0x20, 0xac, 0x63, 0x22
);

// 55a650e1-5f0a-4eca-a653-88f53b26aa8c
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V6,
   0x55a650e1,
   0x5f0a,
   0x4eca,
   0xa6, 0x53, 0x88, 0xf5, 0x3b, 0x26, 0xaa, 0x8c
);

// cbc998bb-c51f-4c1a-bb4f-9775fcacab2f
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V6_DISCARD,
   0xcbc998bb,
   0xc51f,
   0x4c1a,
   0xbb, 0x4f, 0x97, 0x75, 0xfc, 0xac, 0xab, 0x2f
);

// 88bb5dad-76d7-4227-9c71-df0a3ed7be7e
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V4,
   0x88bb5dad,
   0x76d7,
   0x4227,
   0x9c, 0x71, 0xdf, 0x0a, 0x3e, 0xd7, 0xbe, 0x7e
);

// 371dfada-9f26-45fd-b4eb-c29eb212893f
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V4_DISCARD,
   0x371dfada,
   0x9f26,
   0x45fd,
   0xb4, 0xeb, 0xc2, 0x9e, 0xb2, 0x12, 0x89, 0x3f
);

// 7ac9de24-17dd-4814-b4bd-a9fbc95a321b
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V6,
   0x7ac9de24,
   0x17dd,
   0x4814,
   0xb4, 0xbd, 0xa9, 0xfb, 0xc9, 0x5a, 0x32, 0x1b
);

// 60703b07-63c8-48e9-ada3-12b1af40a617
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V6_DISCARD,
   0x60703b07,
   0x63c8,
   0x48e9,
   0xad, 0xa3, 0x12, 0xb1, 0xaf, 0x40, 0xa6, 0x17
);

// e1cd9fe7-f4b5-4273-96c0-592e487b8650
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4,
   0xe1cd9fe7,
   0xf4b5,
   0x4273,
   0x96, 0xc0, 0x59, 0x2e, 0x48, 0x7b, 0x86, 0x50
);

// 9eeaa99b-bd22-4227-919f-0073c63357b1
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4_DISCARD,
   0x9eeaa99b,
   0xbd22,
   0x4227,
   0x91, 0x9f, 0x00, 0x73, 0xc6, 0x33, 0x57, 0xb1
);

// a3b42c97-9f04-4672-b87e-cee9c483257f
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6,
   0xa3b42c97,
   0x9f04,
   0x4672,
   0xb8, 0x7e, 0xce, 0xe9, 0xc4, 0x83, 0x25, 0x7f
);

// 89455b97-dbe1-453f-a224-13da895af396
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6_DISCARD,
   0x89455b97,
   0xdbe1,
   0x453f,
   0xa2, 0x24, 0x13, 0xda, 0x89, 0x5a, 0xf3, 0x96
);

// c38d57d1-05a7-4c33-904f-7fbceee60e82
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V4,
   0xc38d57d1,
   0x05a7,
   0x4c33,
   0x90, 0x4f, 0x7f, 0xbc, 0xee, 0xe6, 0x0e, 0x82
);

// d632a801-f5ba-4ad6-96e3-607017d9836a
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V4_DISCARD,
   0xd632a801,
   0xf5ba,
   0x4ad6,
   0x96, 0xe3, 0x60, 0x70, 0x17, 0xd9, 0x83, 0x6a
);

// 4a72393b-319f-44bc-84c3-ba54dcb3b6b4
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V6,
   0x4a72393b,
   0x319f,
   0x44bc,
   0x84, 0xc3, 0xba, 0x54, 0xdc, 0xb3, 0xb6, 0xb4
);

// c97bc3b8-c9a3-4e33-8695-8e17aad4de09
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V6_DISCARD,
   0xc97bc3b8,
   0xc9a3,
   0x4e33,
   0x86, 0x95, 0x8e, 0x17, 0xaa, 0xd4, 0xde, 0x09
);

// af80470a-5596-4c13-9992-539e6fe57967
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4,
   0xaf80470a,
   0x5596,
   0x4c13,
   0x99, 0x92, 0x53, 0x9e, 0x6f, 0xe5, 0x79, 0x67
);

// 146ae4a9-a1d2-4d43-a31a-4c42682b8e4f
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4_DISCARD,
   0x146ae4a9,
   0xa1d2,
   0x4d43,
   0xa3, 0x1a, 0x4c, 0x42, 0x68, 0x2b, 0x8e, 0x4f
);

// 7021d2b3-dfa4-406e-afeb-6afaf7e70efd
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V6,
   0x7021d2b3,
   0xdfa4,
   0x406e,
   0xaf, 0xeb, 0x6a, 0xfa, 0xf7, 0xe7, 0x0e, 0xfd
);

// 46928636-bbca-4b76-941d-0fa7f5d7d372
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V6_DISCARD,
   0x46928636,
   0xbbca,
   0x4b76,
   0x94, 0x1d, 0x0f, 0xa7, 0xf5, 0xd7, 0xd3, 0x72
);

// f02b1526-a459-4a51-b9e3-759de52b9d2c
DEFINE_GUID(
   FWPM_LAYER_IPSEC_KM_DEMUX_V4,
   0xf02b1526,
   0xa459,
   0x4a51,
   0xb9, 0xe3, 0x75, 0x9d, 0xe5, 0x2b, 0x9d, 0x2c
);

// 2f755cf6-2fd4-4e88-b3e4-a91bca495235
DEFINE_GUID(
   FWPM_LAYER_IPSEC_KM_DEMUX_V6,
   0x2f755cf6,
   0x2fd4,
   0x4e88,
   0xb3, 0xe4, 0xa9, 0x1b, 0xca, 0x49, 0x52, 0x35
);

// eda65c74-610d-4bc5-948f-3c4f89556867
DEFINE_GUID(
   FWPM_LAYER_IPSEC_V4,
   0xeda65c74,
   0x610d,
   0x4bc5,
   0x94, 0x8f, 0x3c, 0x4f, 0x89, 0x55, 0x68, 0x67
);

// 13c48442-8d87-4261-9a29-59d2abc348b4
DEFINE_GUID(
   FWPM_LAYER_IPSEC_V6,
   0x13c48442,
   0x8d87,
   0x4261,
   0x9a, 0x29, 0x59, 0xd2, 0xab, 0xc3, 0x48, 0xb4
);

// b14b7bdb-dbbd-473e-bed4-8b4708d4f270
DEFINE_GUID(
   FWPM_LAYER_IKEEXT_V4,
   0xb14b7bdb,
   0xdbbd,
   0x473e,
   0xbe, 0xd4, 0x8b, 0x47, 0x08, 0xd4, 0xf2, 0x70
);

// b64786b3-f687-4eb9-89d2-8ef32acdabe2
DEFINE_GUID(
   FWPM_LAYER_IKEEXT_V6,
   0xb64786b3,
   0xf687,
   0x4eb9,
   0x89, 0xd2, 0x8e, 0xf3, 0x2a, 0xcd, 0xab, 0xe2
);

// 75a89dda-95e4-40f3-adc7-7688a9c847e1
DEFINE_GUID(
   FWPM_LAYER_RPC_UM,
   0x75a89dda,
   0x95e4,
   0x40f3,
   0xad, 0xc7, 0x76, 0x88, 0xa9, 0xc8, 0x47, 0xe1
);

// 9247bc61-eb07-47ee-872c-bfd78bfd1616
DEFINE_GUID(
   FWPM_LAYER_RPC_EPMAP,
   0x9247bc61,
   0xeb07,
   0x47ee,
   0x87, 0x2c, 0xbf, 0xd7, 0x8b, 0xfd, 0x16, 0x16
);

// 618dffc7-c450-4943-95db-99b4c16a55d4
DEFINE_GUID(
   FWPM_LAYER_RPC_EP_ADD,
   0x618dffc7,
   0xc450,
   0x4943,
   0x95, 0xdb, 0x99, 0xb4, 0xc1, 0x6a, 0x55, 0xd4
);

// 94a4b50b-ba5c-4f27-907a-229fac0c2a7a
DEFINE_GUID(
   FWPM_LAYER_RPC_PROXY_CONN,
   0x94a4b50b,
   0xba5c,
   0x4f27,
   0x90, 0x7a, 0x22, 0x9f, 0xac, 0x0c, 0x2a, 0x7a
);

// f8a38615-e12c-41ac-98df-121ad981aade
DEFINE_GUID(
   FWPM_LAYER_RPC_PROXY_IF,
   0xf8a38615,
   0xe12c,
   0x41ac,
   0x98, 0xdf, 0x12, 0x1a, 0xd9, 0x81, 0xaa, 0xde
);

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in sublayers.
//
///////////////////////////////////////////////////////////////////////////////

// 758c84f4-fb48-4de9-9aeb-3ed9551ab1fd
DEFINE_GUID(
   FWPM_SUBLAYER_RPC_AUDIT,
   0x758c84f4,
   0xfb48,
   0x4de9,
   0x9a, 0xeb, 0x3e, 0xd9, 0x55, 0x1a, 0xb1, 0xfd
);

// 83f299ed-9ff4-4967-aff4-c309f4dab827
DEFINE_GUID(
   FWPM_SUBLAYER_IPSEC_TUNNEL,
   0x83f299ed,
   0x9ff4,
   0x4967,
   0xaf, 0xf4, 0xc3, 0x09, 0xf4, 0xda, 0xb8, 0x27
);

// eebecc03-ced4-4380-819a-2734397b2b74
DEFINE_GUID(
   FWPM_SUBLAYER_UNIVERSAL,
   0xeebecc03,
   0xced4,
   0x4380,
   0x81, 0x9a, 0x27, 0x34, 0x39, 0x7b, 0x2b, 0x74
);

// 1b75c0ce-ff60-4711-a70f-b4958cc3b2d0
DEFINE_GUID(
   FWPM_SUBLAYER_LIPS,
   0x1b75c0ce,
   0xff60,
   0x4711,
   0xa7, 0x0f, 0xb4, 0x95, 0x8c, 0xc3, 0xb2, 0xd0
);

// 15a66e17-3f3c-4f7b-aa6c-812aa613dd82
DEFINE_GUID(
   FWPM_SUBLAYER_SECURE_SOCKET,
   0x15a66e17,
   0x3f3c,
   0x4f7b,
   0xaa, 0x6c, 0x81, 0x2a, 0xa6, 0x13, 0xdd, 0x82
);

// 337608b9-b7d5-4d5f-82f9-3618618bc058
DEFINE_GUID(
   FWPM_SUBLAYER_TCP_CHIMNEY_OFFLOAD,
   0x337608b9,
   0xb7d5,
   0x4d5f,
   0x82, 0xf9, 0x36, 0x18, 0x61, 0x8b, 0xc0, 0x58
);

// 877519e1-e6a9-41a5-81b4-8c4f118e4a60
DEFINE_GUID(
   FWPM_SUBLAYER_INSPECTION,
   0x877519e1,
   0xe6a9,
   0x41a5,
   0x81, 0xb4, 0x8c, 0x4f, 0x11, 0x8e, 0x4a, 0x60
);

// ba69dc66-5176-4979-9c89-26a7b46a8327
DEFINE_GUID(
   FWPM_SUBLAYER_TEREDO,
   0xba69dc66,
   0x5176,
   0x4979,
   0x9c, 0x89, 0x26, 0xa7, 0xb4, 0x6a, 0x83, 0x27
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

// a5082e73-8f71-4559-8a9a-101cea04ef87
DEFINE_GUID(
   FWPM_SUBLAYER_IPSEC_FORWARD_OUTBOUND_TUNNEL,
   0xa5082e73,
   0x8f71,
   0x4559,
   0x8a, 0x9a, 0x10, 0x1c, 0xea, 0x04, 0xef, 0x87
);

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in conditions.
//
///////////////////////////////////////////////////////////////////////////////

// d9ee00de-c1ef-4617-bfe3-ffd8f5a08957
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS,
   0xd9ee00de,
   0xc1ef,
   0x4617,
   0xbf, 0xe3, 0xff, 0xd8, 0xf5, 0xa0, 0x89, 0x57
);

// b235ae9a-1d64-49b8-a44c-5ff3d9095045
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_ADDRESS,
   0xb235ae9a,
   0x1d64,
   0x49b8,
   0xa4, 0x4c, 0x5f, 0xf3, 0xd9, 0x09, 0x50, 0x45
);

// ae96897e-2e94-4bc9-b313-b27ee80e574d
DEFINE_GUID(
   FWPM_CONDITION_IP_SOURCE_ADDRESS,
   0xae96897e,
   0x2e94,
   0x4bc9,
   0xb3, 0x13, 0xb2, 0x7e, 0xe8, 0x0e, 0x57, 0x4d
);

// 2d79133b-b390-45c6-8699-acaceaafed33
DEFINE_GUID(
   FWPM_CONDITION_IP_DESTINATION_ADDRESS,
   0x2d79133b,
   0xb390,
   0x45c6,
   0x86, 0x99, 0xac, 0xac, 0xea, 0xaf, 0xed, 0x33
);

// 6ec7f6c4-376b-45d7-9e9c-d337cedcd237
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS_TYPE,
   0x6ec7f6c4,
   0x376b,
   0x45d7,
   0x9e, 0x9c, 0xd3, 0x37, 0xce, 0xdc, 0xd2, 0x37
);

// 1ec1b7c9-4eea-4f5e-b9ef-76beaaaf17ee
DEFINE_GUID(
   FWPM_CONDITION_IP_DESTINATION_ADDRESS_TYPE,
   0x1ec1b7c9,
   0x4eea,
   0x4f5e,
   0xb9, 0xef, 0x76, 0xbe, 0xaa, 0xaf, 0x17, 0xee
);

// 4cd62a49-59c3-4969-b7f3-bda5d32890a4
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_INTERFACE,
   0x4cd62a49,
   0x59c3,
   0x4969,
   0xb7, 0xf3, 0xbd, 0xa5, 0xd3, 0x28, 0x90, 0xa4
);


#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 618a9b6d-386b-4136-ad6e-b51587cfb1cd
DEFINE_GUID(
   FWPM_CONDITION_IP_ARRIVAL_INTERFACE,
   0x618a9b6d,
   0x386b,
   0x4136,
   0xad, 0x6e, 0xb5, 0x15, 0x87, 0xcf, 0xb1, 0xcd 
);

// 89f990de-e798-4e6d-ab76-7c9558292e6f
DEFINE_GUID(
   FWPM_CONDITION_ARRIVAL_INTERFACE_TYPE,
   0x89f990de,
   0xe798,
   0x4e6d,
   0xab, 0x76, 0x7c, 0x95, 0x58, 0x29, 0x2e, 0x6f
);

// 511166dc-7a8c-4aa7-b533-95ab59fb0340
DEFINE_GUID(
   FWPM_CONDITION_ARRIVAL_TUNNEL_TYPE,
   0x511166dc,
   0x7a8c,
   0x4aa7,
   0xb5, 0x33, 0x95, 0xab, 0x59, 0xfb, 0x03, 0x40
);

// cc088db3-1792-4a71-b0f9-037d21cd828b
DEFINE_GUID(
   FWPM_CONDITION_ARRIVAL_INTERFACE_INDEX,
   0xcc088db3,
   0x1792,
   0x4a71,
   0xb0, 0xf9, 0x03, 0x7d, 0x21, 0xcd, 0x82, 0x8b
);

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// daf8cd14-e09e-4c93-a5ae-c5c13b73ffca
DEFINE_GUID(
   FWPM_CONDITION_INTERFACE_TYPE,
   0xdaf8cd14,
   0xe09e,
   0x4c93,
   0xa5, 0xae, 0xc5, 0xc1, 0x3b, 0x73, 0xff, 0xca
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_LOCAL_INTERFACE_TYPE FWPM_CONDITION_INTERFACE_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 77a40437-8779-4868-a261-f5a902f1c0cd
DEFINE_GUID(
   FWPM_CONDITION_TUNNEL_TYPE,
   0x77a40437,
   0x8779,
   0x4868,
   0xa2, 0x61, 0xf5, 0xa9, 0x02, 0xf1, 0xc0, 0xcd
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_LOCAL_TUNNEL_TYPE FWPM_CONDITION_TUNNEL_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 1076b8a5-6323-4c5e-9810-e8d3fc9e6136
DEFINE_GUID(
   FWPM_CONDITION_IP_FORWARD_INTERFACE,
   0x1076b8a5,
   0x6323,
   0x4c5e,
   0x98, 0x10, 0xe8, 0xd3, 0xfc, 0x9e, 0x61, 0x36
);

// 3971ef2b-623e-4f9a-8cb1-6e79b806b9a7
DEFINE_GUID(
   FWPM_CONDITION_IP_PROTOCOL,
   0x3971ef2b,
   0x623e,
   0x4f9a,
   0x8c, 0xb1, 0x6e, 0x79, 0xb8, 0x06, 0xb9, 0xa7
);

// 0c1ba1af-5765-453f-af22-a8f791ac775b
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_PORT,
   0x0c1ba1af,
   0x5765,
   0x453f,
   0xaf, 0x22, 0xa8, 0xf7, 0x91, 0xac, 0x77, 0x5b
);

#define FWPM_CONDITION_ICMP_TYPE FWPM_CONDITION_IP_LOCAL_PORT

// c35a604d-d22b-4e1a-91b4-68f674ee674b
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_PORT,
   0xc35a604d,
   0xd22b,
   0x4e1a,
   0x91, 0xb4, 0x68, 0xf6, 0x74, 0xee, 0x67, 0x4b
);

#define FWPM_CONDITION_ICMP_CODE FWPM_CONDITION_IP_REMOTE_PORT

// 4672a468-8a0a-4202-abb4-849e92e66809
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_LOCAL_ADDRESS_TYPE,
   0x4672a468,
   0x8a0a,
   0x4202,
   0xab, 0xb4, 0x84, 0x9e, 0x92, 0xe6, 0x68, 0x09
);

// 77ee4b39-3273-4671-b63b-ab6feb66eeb6
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_REMOTE_ADDRESS,
   0x77ee4b39,
   0x3273,
   0x4671,
   0xb6, 0x3b, 0xab, 0x6f, 0xeb, 0x66, 0xee, 0xb6
);

// 07784107-a29e-4c7b-9ec7-29c44afafdbc
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_PROTOCOL,
   0x07784107,
   0xa29e,
   0x4c7b,
   0x9e, 0xc7, 0x29, 0xc4, 0x4a, 0xfa, 0xfd, 0xbc
);

// bfca394d-acdb-484e-b8e6-2aff79757345
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_LOCAL_PORT,
   0xbfca394d,
   0xacdb,
   0x484e,
   0xb8, 0xe6, 0x2a, 0xff, 0x79, 0x75, 0x73, 0x45
);

// cae4d6a1-2968-40ed-a4ce-547160dda88d
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_REMOTE_PORT,
   0xcae4d6a1,
   0x2968,
   0x40ed,
   0xa4, 0xce, 0x54, 0x71, 0x60, 0xdd, 0xa8, 0x8d
);

// 632ce23b-5167-435c-86d7-e903684aa80c
DEFINE_GUID(
   FWPM_CONDITION_FLAGS,
   0x632ce23b,
   0x5167,
   0x435c,
   0x86, 0xd7, 0xe9, 0x03, 0x68, 0x4a, 0xa8, 0x0c
);

// 8784c146-ca97-44d6-9fd1-19fb1840cbf7
DEFINE_GUID(
   FWPM_CONDITION_DIRECTION,
   0x8784c146,
   0xca97,
   0x44d6,
   0x9f, 0xd1, 0x19, 0xfb, 0x18, 0x40, 0xcb, 0xf7
);

// 667fd755-d695-434a-8af5-d3835a1259bc
DEFINE_GUID(
   FWPM_CONDITION_INTERFACE_INDEX,
   0x667fd755,
   0xd695,
   0x434a,
   0x8a, 0xf5, 0xd3, 0x83, 0x5a, 0x12, 0x59, 0xbc
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_LOCAL_INTERFACE_INDEX FWPM_CONDITION_INTERFACE_INDEX

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)


// 0cd42473-d621-4be3-ae8c-72a348d283e1
DEFINE_GUID(
   FWPM_CONDITION_SUB_INTERFACE_INDEX,
   0x0cd42473,
   0xd621,
   0x4be3,
   0xae, 0x8c, 0x72, 0xa3, 0x48, 0xd2, 0x83, 0xe1
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPM_CONDITION_SUB_INTERFACE_INDEX

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 2311334d-c92d-45bf-9496-edf447820e2d
DEFINE_GUID(
   FWPM_CONDITION_SOURCE_INTERFACE_INDEX,
   0x2311334d,
   0xc92d,
   0x45bf,
   0x94, 0x96, 0xed, 0xf4, 0x47, 0x82, 0x0e, 0x2d
);

// 055edd9d-acd2-4361-8dab-f9525d97662f
DEFINE_GUID(
   FWPM_CONDITION_SOURCE_SUB_INTERFACE_INDEX,
   0x055edd9d,
   0xacd2,
   0x4361,
   0x8d, 0xab, 0xf9, 0x52, 0x5d, 0x97, 0x66, 0x2f
);

// 35cf6522-4139-45ee-a0d5-67b80949d879
DEFINE_GUID(
   FWPM_CONDITION_DESTINATION_INTERFACE_INDEX,
   0x35cf6522,
   0x4139,
   0x45ee,
   0xa0, 0xd5, 0x67, 0xb8, 0x09, 0x49, 0xd8, 0x79
);

// 2b7d4399-d4c7-4738-a2f5-e994b43da388
DEFINE_GUID(
   FWPM_CONDITION_DESTINATION_SUB_INTERFACE_INDEX,
   0x2b7d4399,
   0xd4c7,
   0x4738,
   0xa2, 0xf5, 0xe9, 0x94, 0xb4, 0x3d, 0xa3, 0x88
);

// d78e1e87-8644-4ea5-9437-d809ecefc971
DEFINE_GUID(
   FWPM_CONDITION_ALE_APP_ID,
   0xd78e1e87,
   0x8644,
   0x4ea5,
   0x94, 0x37, 0xd8, 0x09, 0xec, 0xef, 0xc9, 0x71
);

// af043a0a-b34d-4f86-979c-c90371af6e66
DEFINE_GUID(
   FWPM_CONDITION_ALE_USER_ID,
   0xaf043a0a,
   0xb34d,
   0x4f86,
   0x97, 0x9c, 0xc9, 0x03, 0x71, 0xaf, 0x6e, 0x66
);

// f63073b7-0189-4ab0-95a4-6123cbfab862
DEFINE_GUID(
   FWPM_CONDITION_ALE_REMOTE_USER_ID,
   0xf63073b7,
   0x0189,
   0x4ab0,
   0x95, 0xa4, 0x61, 0x23, 0xcb, 0xfa, 0xb8, 0x62
);

// 1aa47f51-7f93-4508-a271-81abb00c9cab
DEFINE_GUID(
   FWPM_CONDITION_ALE_REMOTE_MACHINE_ID,
   0x1aa47f51,
   0x7f93,
   0x4508,
   0xa2, 0x71, 0x81, 0xab, 0xb0, 0x0c, 0x9c, 0xab
);

// 1c974776-7182-46e9-afd3-b02910e30334
DEFINE_GUID(
   FWPM_CONDITION_ALE_PROMISCUOUS_MODE,
   0x1c974776,
   0x7182,
   0x46e9,
   0xaf, 0xd3, 0xb0, 0x29, 0x10, 0xe3, 0x03, 0x34
);

// b9f4e088-cb98-4efb-a2c7-ad07332643db
DEFINE_GUID(
   FWPM_CONDITION_ALE_SIO_FIREWALL_SYSTEM_PORT,
   0xb9f4e088,
   0xcb98,
   0x4efb,
   0xa2, 0xc7, 0xad, 0x07, 0x33, 0x26, 0x43, 0xdb
);

// 46275a9d-c03f-4d77-b784-1c57f4d02753
DEFINE_GUID(
   FWPM_CONDITION_ALE_NAP_CONTEXT,
   0x46275a9d,
   0xc03f,
   0x4d77,
   0xb7, 0x84, 0x1c, 0x57, 0xf4, 0xd0, 0x27, 0x53
);

// 9bf0ee66-06c9-41b9-84da-288cb43af51f
DEFINE_GUID(
    FWPM_CONDITION_REMOTE_USER_TOKEN,
    0x9bf0ee66,
    0x06c9,
    0x41b9,
    0x84, 0xda, 0x28, 0x8c, 0xb4, 0x3a, 0xf5, 0x1f
);

// 7c9c7d9f-0075-4d35-a0d1-8311c4cf6af1
DEFINE_GUID(
   FWPM_CONDITION_RPC_IF_UUID,
   0x7c9c7d9f,
   0x0075,
   0x4d35,
   0xa0, 0xd1, 0x83, 0x11, 0xc4, 0xcf, 0x6a, 0xf1
);

// eabfd9b7-1262-4a2e-adaa-5f96f6fe326d
DEFINE_GUID(
   FWPM_CONDITION_RPC_IF_VERSION,
   0xeabfd9b7,
   0x1262,
   0x4a2e,
   0xad, 0xaa, 0x5f, 0x96, 0xf6, 0xfe, 0x32, 0x6d
);

// 238a8a32-3199-467d-871c-272621ab3896
DEFINE_GUID(
    FWPM_CONDITION_RPC_IF_FLAG,
    0x238a8a32,
    0x3199,
    0x467d,
    0x87, 0x1c, 0x27, 0x26, 0x21, 0xab, 0x38, 0x96
);

// ff2e7b4d-3112-4770-b636-4d24ae3a6af2
DEFINE_GUID(
    FWPM_CONDITION_DCOM_APP_ID,
    0xff2e7b4d,
    0x3112,
    0x4770,
    0xb6, 0x36, 0x4d, 0x24, 0xae, 0x3a, 0x6a, 0xf2
);

// d024de4d-deaa-4317-9c85-e40ef6e140c3
DEFINE_GUID(
    FWPM_CONDITION_IMAGE_NAME,
    0xd024de4d,
    0xdeaa,
    0x4317,
    0x9c, 0x85, 0xe4, 0x0e, 0xf6, 0xe1, 0x40, 0xc3
);

// 2717bc74-3a35-4ce7-b7ef-c838fabdec45
DEFINE_GUID(
    FWPM_CONDITION_RPC_PROTOCOL,
    0x2717bc74,
    0x3a35,
    0x4ce7,
    0xb7, 0xef, 0xc8, 0x38, 0xfa, 0xbd, 0xec, 0x45
);

// daba74ab-0d67-43e7-986e-75b84f82f594
DEFINE_GUID(
   FWPM_CONDITION_RPC_AUTH_TYPE,
   0xdaba74ab,
   0x0d67,
   0x43e7,
   0x98, 0x6e, 0x75, 0xb8, 0x4f, 0x82, 0xf5, 0x94
);

// e5a0aed5-59ac-46ea-be05-a5f05ecf446e
DEFINE_GUID(
   FWPM_CONDITION_RPC_AUTH_LEVEL,
   0xe5a0aed5,
   0x59ac,
   0x46ea,
   0xbe, 0x05, 0xa5, 0xf0, 0x5e, 0xcf, 0x44, 0x6e
);

// 0d306ef0-e974-4f74-b5c7-591b0da7d562
DEFINE_GUID(
   FWPM_CONDITION_SEC_ENCRYPT_ALGORITHM,
   0x0d306ef0,
   0xe974,
   0x4f74,
   0xb5, 0xc7, 0x59, 0x1b, 0x0d, 0xa7, 0xd5, 0x62
);

// 4772183b-ccf8-4aeb-bce1-c6c6161c8fe4
DEFINE_GUID(
    FWPM_CONDITION_SEC_KEY_SIZE,
    0x4772183b,
    0xccf8,
    0x4aeb,
    0xbc, 0xe1, 0xc6, 0xc6, 0x16, 0x1c, 0x8f, 0xe4
);

// 03a629cb-6e52-49f8-9c41-5709633c09cf
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS_V4,
   0x03a629cb,
   0x6e52,
   0x49f8,
   0x9c, 0x41, 0x57, 0x09, 0x63, 0x3c, 0x09, 0xcf
);

// 2381be84-7524-45b3-a05b-1e637d9c7a6a
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS_V6,
   0x2381be84,
   0x7524,
   0x45b3,
   0xa0, 0x5b, 0x1e, 0x63, 0x7d, 0x9c, 0x7a, 0x6a
);

// 1bd0741d-e3df-4e24-8634-762046eef6eb
DEFINE_GUID(
    FWPM_CONDITION_PIPE,
    0x1bd0741d,
    0xe3df,
    0x4e24,
    0x86, 0x34, 0x76, 0x20, 0x46, 0xee, 0xf6, 0xeb
);

// 1febb610-3bcc-45e1-bc36-2e067e2cb186
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_ADDRESS_V4,
   0x1febb610,
   0x3bcc,
   0x45e1,
   0xbc, 0x36, 0x2e, 0x06, 0x7e, 0x2c, 0xb1, 0x86
);

// 246e1d8c-8bee-4018-9b98-31d4582f3361
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_ADDRESS_V6,
   0x246e1d8c,
   0x8bee,
   0x4018,
   0x9b, 0x98, 0x31, 0xd4, 0x58, 0x2f, 0x33, 0x61
);

// e31180a8-bbbd-4d14-a65e-7157b06233bb
DEFINE_GUID(
    FWPM_CONDITION_PROCESS_WITH_RPC_IF_UUID,
    0xe31180a8,
    0xbbbd,
    0x4d14,
    0xa6, 0x5e, 0x71, 0x57, 0xb0, 0x62, 0x33, 0xbb
);

// dccea0b9-0886-4360-9c6a-ab043a24fba9
DEFINE_GUID(
    FWPM_CONDITION_RPC_EP_VALUE,
    0xdccea0b9,
    0x0886,
    0x4360,
    0x9c, 0x6a, 0xab, 0x04, 0x3a, 0x24, 0xfb, 0xa9
);

// 218b814a-0a39-49b8-8e71-c20c39c7dd2e
DEFINE_GUID(
    FWPM_CONDITION_RPC_EP_FLAGS,
    0x218b814a,
    0x0a39,
    0x49b8,
    0x8e, 0x71, 0xc2, 0x0c, 0x39, 0xc7, 0xdd, 0x2e
);

// c228fc1e-403a-4478-be05-c9baa4c05ace
DEFINE_GUID(
    FWPM_CONDITION_CLIENT_TOKEN,
    0xc228fc1e,
    0x403a,
    0x4478,
    0xbe, 0x05, 0xc9, 0xba, 0xa4, 0xc0, 0x5a, 0xce
);

// b605a225-c3b3-48c7-9833-7aefa9527546
DEFINE_GUID(
    FWPM_CONDITION_RPC_SERVER_NAME,
    0xb605a225,
    0xc3b3,
    0x48c7,
    0x98, 0x33, 0x7a, 0xef, 0xa9, 0x52, 0x75, 0x46
);

// 8090f645-9ad5-4e3b-9f9f-8023ca097909
DEFINE_GUID(
    FWPM_CONDITION_RPC_SERVER_PORT,
    0x8090f645,
    0x9ad5,
    0x4e3b,
    0x9f, 0x9f, 0x80, 0x23, 0xca, 0x09, 0x79, 0x09
);

// 40953fe2-8565-4759-8488-1771b4b4b5db
DEFINE_GUID(
    FWPM_CONDITION_RPC_PROXY_AUTH_TYPE,
    0x40953fe2,
    0x8565,
    0x4759,
    0x84, 0x88, 0x17, 0x71, 0xb4, 0xb4, 0xb5, 0xdb
);

// a3ec00c7-05f4-4df7-91f2-5f60d91ff443
DEFINE_GUID(
    FWPM_CONDITION_CLIENT_CERT_KEY_LENGTH,
    0xa3ec00c7,
    0x05f4,
    0x4df7,
    0x91, 0xf2, 0x5f, 0x60, 0xd9, 0x1f, 0xf4, 0x43
);

// c491ad5e-f882-4283-b916-436b103ff4ad
DEFINE_GUID(
    FWPM_CONDITION_CLIENT_CERT_OID,
    0xc491ad5e,
    0xf882,
    0x4283,
    0xb9, 0x16, 0x43, 0x6b, 0x10, 0x3f, 0xf4, 0xad
);

// 056d336d-ca55-489f-94b9-a4962f8246e2
DEFINE_GUID(
   FWPM_CONDITION_SCOPE_ID,
   0x056d336d,
   0xca55,
   0x489f,
   0x94, 0xb9, 0xa4, 0x96, 0x2f, 0x82, 0x46, 0xe2
);


///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in providers.
//
///////////////////////////////////////////////////////////////////////////////

// 10ad9216-ccde-456c-8b16-e9f04e60a90b
DEFINE_GUID(
   FWPM_PROVIDER_IKEEXT,
   0x10ad9216,
   0xccde,
   0x456c,
   0x8b, 0x16, 0xe9, 0xf0, 0x4e, 0x60, 0xa9, 0x0b
);

// 896aa19e-9a34-4bcb-ae79-beb9127c84b9
DEFINE_GUID(
   FWPM_PROVIDER_TCP_CHIMNEY_OFFLOAD,
   0x896aa19e,
   0x9a34,
   0x4bcb,
   0xae, 0x79, 0xbe, 0xb9, 0x12, 0x7c, 0x84, 0xb9
);


///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in callouts.
//
///////////////////////////////////////////////////////////////////////////////

// 5132900d-5e84-4b5f-80e4-01741e81ff10
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TRANSPORT_V4,
   0x5132900d,
   0x5e84,
   0x4b5f,
   0x80, 0xe4, 0x01, 0x74, 0x1e, 0x81, 0xff, 0x10
);

// 49d3ac92-2a6c-4dcf-955f-1c3be009dd99
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TRANSPORT_V6,
   0x49d3ac92,
   0x2a6c,
   0x4dcf,
   0x95, 0x5f, 0x1c, 0x3b, 0xe0, 0x09, 0xdd, 0x99
);

// 4b46bf0a-4523-4e57-aa38-a87987c910d9
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TRANSPORT_V4,
   0x4b46bf0a,
   0x4523,
   0x4e57,
   0xaa, 0x38, 0xa8, 0x79, 0x87, 0xc9, 0x10, 0xd9
);

// 38d87722-ad83-4f11-a91f-df0fb077225b
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TRANSPORT_V6,
   0x38d87722,
   0xad83,
   0x4f11,
   0xa9, 0x1f, 0xdf, 0x0f, 0xb0, 0x77, 0x22, 0x5b
);

// 191a8a46-0bf8-46cf-b045-4b45dfa6a324
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_V4,
   0x191a8a46,
   0x0bf8,
   0x46cf,
   0xb0, 0x45, 0x4b, 0x45, 0xdf, 0xa6, 0xa3, 0x24
);

// 80c342e3-1e53-4d6f-9b44-03df5aeee154
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_V6,
   0x80c342e3,
   0x1e53,
   0x4d6f,
   0x9b, 0x44, 0x03, 0xdf, 0x5a, 0xee, 0xe1, 0x54
);

// 70a4196c-835b-4fb0-98e8-075f4d977d46
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TUNNEL_V4,
   0x70a4196c,
   0x835b,
   0x4fb0,
   0x98, 0xe8, 0x07, 0x5f, 0x4d, 0x97, 0x7d, 0x46
);

// f1835363-a6a5-4e62-b180-23db789d8da6
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TUNNEL_V6,
   0xf1835363,
   0xa6a5,
   0x4e62,
   0xb1, 0x80, 0x23, 0xdb, 0x78, 0x9d, 0x8d, 0xa6
);

// 28829633-c4f0-4e66-873f-844db2a899c7
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_INBOUND_TUNNEL_V4,
   0x28829633,
   0xc4f0,
   0x4e66,
   0x87, 0x3f, 0x84, 0x4d, 0xb2, 0xa8, 0x99, 0xc7
);

// af50bec2-c686-429a-884d-b74443e7b0b4
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_INBOUND_TUNNEL_V6,
   0xaf50bec2,
   0xc686,
   0x429a,
   0x88, 0x4d, 0xb7, 0x44, 0x43, 0xe7, 0xb0, 0xb4
);

// fb532136-15cb-440b-937c-1717ca320c40
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_OUTBOUND_TUNNEL_V4,
   0xfb532136,
   0x15cb,
   0x440b,
   0x93, 0x7c, 0x17, 0x17, 0xca, 0x32, 0x0c, 0x40
);

// dae640cc-e021-4bee-9eb6-a48b275c8c1d
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_OUTBOUND_TUNNEL_V6,
   0xdae640cc,
   0xe021,
   0x4bee,
   0x9e, 0xb6, 0xa4, 0x8b, 0x27, 0x5c, 0x8c, 0x1d
);

// 7dff309b-ba7d-4aba-91aa-ae5c6640c944
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_INITIATE_SECURE_V4,
   0x7dff309b,
   0xba7d,
   0x4aba,
   0x91, 0xaa, 0xae, 0x5c, 0x66, 0x40, 0xc9, 0x44
);

// a9a0d6d9-c58c-474e-8aeb-3cfe99d6d53d
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_INITIATE_SECURE_V6,
   0xa9a0d6d9,
   0xc58c,
   0x474e,
   0x8a, 0xeb, 0x3c, 0xfe, 0x99, 0xd6, 0xd5, 0x3d
);

// 3df6e7de-fd20-48f2-9f26-f854444cba79
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_ALE_ACCEPT_V4,
   0x3df6e7de,
   0xfd20,
   0x48f2,
   0x9f, 0x26, 0xf8, 0x54, 0x44, 0x4c, 0xba, 0x79
);

// a1e392d3-72ac-47bb-87a7-0122c69434ab
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_ALE_ACCEPT_V6,
   0xa1e392d3,
   0x72ac,
   0x47bb,
   0x87, 0xa7, 0x01, 0x22, 0xc6, 0x94, 0x34, 0xab
);

// 6ac141fc-f75d-4203-b9c8-48e6149c2712
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_ALE_CONNECT_V4,
   0x6ac141fc,
   0xf75d,
   0x4203,
   0xb9,0xc8,0x48, 0xe6, 0x14, 0x9c, 0x27, 0x12
);

// 4c0dda05-e31f-4666-90b0-b3dfad34129a
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_ALE_CONNECT_V6,
   0x4c0dda05,
   0xe31f,
   0x4666,
   0x90, 0xb0, 0xb3, 0xdf, 0xad, 0x34, 0x12, 0x9a
);

// eda08606-2494-4d78-89bc-67837c03b969
DEFINE_GUID(
   FWPM_CALLOUT_WFP_TRANSPORT_LAYER_V4_SILENT_DROP,
   0xeda08606,
   0x2494,
   0x4d78,
   0x89, 0xbc, 0x67, 0x83, 0x7c, 0x03, 0xb9, 0x69
);

// 8693cc74-a075-4156-b476-9286eece814e
DEFINE_GUID(
   FWPM_CALLOUT_WFP_TRANSPORT_LAYER_V6_SILENT_DROP,
   0x8693cc74,
   0xa075,
   0x4156,
   0xb4, 0x76, 0x92, 0x86, 0xee, 0xce, 0x81, 0x4e
);

// f3e10ab3-2c25-4279-ac36-c30fc181bec4
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_CONNECT_LAYER_V4,
   0xf3e10ab3,
   0x2c25,
   0x4279,
   0xac, 0x36, 0xc3, 0x0f, 0xc1, 0x81, 0xbe, 0xc4
);

// 39e22085-a341-42fc-a279-aec94e689c56
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_CONNECT_LAYER_V6,
   0x39e22085,
   0xa341,
   0x42fc,
   0xa2, 0x79, 0xae, 0xc9, 0x4e, 0x68, 0x9c, 0x56
);

// e183ecb2-3a7f-4b54-8ad9-76050ed880ca
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_ACCEPT_LAYER_V4,
   0xe183ecb2,
   0x3a7f,
   0x4b54,
   0x8a, 0xd9, 0x76, 0x05, 0x0e, 0xd8, 0x80, 0xca
);

// 0378cf41-bf98-4603-81f2-7f12586079f6
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_ACCEPT_LAYER_V6,
   0x0378cf41,
   0xbf98,
   0x4603,
   0x81, 0xf2, 0x7f, 0x12, 0x58, 0x60, 0x79, 0xf6
);

// bc582280-1677-41e9-94ab-c2fcb15c2eeb
DEFINE_GUID(
   FWPM_CALLOUT_SET_OPTIONS_AUTH_CONNECT_LAYER_V4,
   0xbc582280,
   0x1677,
   0x41e9,
   0x94, 0xab, 0xc2, 0xfc, 0xb1, 0x5c, 0x2e, 0xeb
);

// 98e5373c-b884-490f-b65f-2f6a4a575195
DEFINE_GUID(
   FWPM_CALLOUT_SET_OPTIONS_AUTH_CONNECT_LAYER_V6,
   0x98e5373c,
   0xb884,
   0x490f,
   0xb6, 0x5f, 0x2f, 0x6a, 0x4a, 0x57, 0x51, 0x95
);

// 31b95392-066e-42a2-b7db-92f8acdd56f9
DEFINE_GUID(
   FWPM_CALLOUT_TEREDO_ALE_RESOURCE_ASSIGNMENT_V6,
   0x31b95392,
   0x066e,
   0x42a2,
   0xb7, 0xdb, 0x92, 0xf8, 0xac, 0xdd, 0x56, 0xf9
);

// 81a434e7-f60c-4378-bab8-c625a30f0197
DEFINE_GUID(
   FWPM_CALLOUT_TEREDO_ALE_LISTEN_V6,
   0x81a434e7,
   0xf60c,
   0x4378,
   0xba, 0xb8, 0xc6, 0x25, 0xa3, 0x0f, 0x01, 0x97
);

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in provider contexts.
//
///////////////////////////////////////////////////////////////////////////////

// b25ea800-0d02-46ed-92bd-7fa84bb73e9d
DEFINE_GUID(
   FWPM_PROVIDER_CONTEXT_SECURE_SOCKET_AUTHIP,
   0xb25ea800,
   0x0d02,
   0x46ed,
   0x92, 0xbd, 0x7f, 0xa8, 0x4b, 0xb7, 0x3e, 0x9d
);


// 8c2d4144-f8e0-42c0-94ce-7ccfc63b2f9b
DEFINE_GUID(
   FWPM_PROVIDER_CONTEXT_SECURE_SOCKET_IPSEC,
   0x8c2d4144,
   0xf8e0,
   0x42c0,
   0x94, 0xce, 0x7c, 0xcf, 0xc6, 0x3b, 0x2f, 0x9b
);


///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in keying modules.
//
///////////////////////////////////////////////////////////////////////////////

// a9bbf787-82a8-45bb-a400-5d7e5952c7a9
DEFINE_GUID(
   FWPM_KEYING_MODULE_IKE,
   0xa9bbf787,
   0x82a8,
   0x45bb,
   0xa4, 0x00, 0x5d, 0x7e, 0x59, 0x52, 0xc7, 0xa9
);

// 11e3dae0-dd26-4590-857d-ab4b28d1a095
DEFINE_GUID(
   FWPM_KEYING_MODULE_AUTHIP,
   0x11e3dae0,
   0xdd26,
   0x4590,
   0x85, 0x7d, 0xab, 0x4b, 0x28, 0xd1, 0xa0, 0x95
);

#ifndef GUID_DEFS_ONLY
#ifndef FWPMX_H
#define FWPMX_H

#include "fwpmtypes.h"

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Well-known filter weight ranges.
//
///////////////////////////////////////////////////////////////////////////////

// Number of bits used for auto-generated weights.
#define FWPM_AUTO_WEIGHT_BITS (60)
// Maximum auto-generated weight.
#define FWPM_AUTO_WEIGHT_MAX  (MAXUINT64 >> (64 - FWPM_AUTO_WEIGHT_BITS))
// Maximum allowed weight range.
#define FWPM_WEIGHT_RANGE_MAX (MAXUINT64 >> FWPM_AUTO_WEIGHT_BITS)

// IPsec policy
#define FWPM_WEIGHT_RANGE_IPSEC            (0x0)
// Filters to exempt IKE traffic from IPsec.
#define FWPM_WEIGHT_RANGE_IKE_EXEMPTIONS   (0xc)


///////////////////////////////////////////////////////////////////////////////
//
// IPsec transform constants.
//
///////////////////////////////////////////////////////////////////////////////

//////////
// Authentication transform constants
//////////

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_HMAC_MD5_96 =
{
   IPSEC_AUTH_MD5,
   IPSEC_AUTH_CONFIG_HMAC_MD5_96
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_HMAC_SHA_1_96 =
{
   IPSEC_AUTH_SHA_1,
   IPSEC_AUTH_CONFIG_HMAC_SHA_1_96
};

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_HMAC_SHA_256_128 =
{
   IPSEC_AUTH_SHA_256,
   IPSEC_AUTH_CONFIG_HMAC_SHA_256_128
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_GCM_AES_128 =
{
   IPSEC_AUTH_AES_128,
   IPSEC_AUTH_CONFIG_GCM_AES_128
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_GCM_AES_192 =
{
   IPSEC_AUTH_AES_192,
   IPSEC_AUTH_CONFIG_GCM_AES_192
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_GCM_AES_256 =
{
   IPSEC_AUTH_AES_256,
   IPSEC_AUTH_CONFIG_GCM_AES_256
};

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

//////////
// Cipher transform constants
//////////

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_CBC_DES =
{
   IPSEC_CIPHER_TYPE_DES,
   IPSEC_CIPHER_CONFIG_CBC_DES
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_CBC_3DES =
{
   IPSEC_CIPHER_TYPE_3DES,
   IPSEC_CIPHER_CONFIG_CBC_3DES
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_AES_128 =
{
   IPSEC_CIPHER_TYPE_AES_128,
   IPSEC_CIPHER_CONFIG_CBC_AES_128
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_AES_192 =
{
   IPSEC_CIPHER_TYPE_AES_192,
   IPSEC_CIPHER_CONFIG_CBC_AES_192
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_AES_256 =
{
   IPSEC_CIPHER_TYPE_AES_256,
   IPSEC_CIPHER_CONFIG_CBC_AES_256
};

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_GCM_AES_128 =
{
   IPSEC_CIPHER_TYPE_AES_128,
   IPSEC_CIPHER_CONFIG_GCM_AES_128
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_GCM_AES_192 =
{
   IPSEC_CIPHER_TYPE_AES_192,
   IPSEC_CIPHER_CONFIG_GCM_AES_192
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_GCM_AES_256 =
{
   IPSEC_CIPHER_TYPE_AES_256,
   IPSEC_CIPHER_CONFIG_GCM_AES_256
};

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

///////////////////////////////////////////////////////////////////////////////
//
// Well-known filter contexts.
//
///////////////////////////////////////////////////////////////////////////////

// IPSec transport filter contexts in inbound layer
#define FWPM_CONTEXT_IPSEC_INBOUND_PASSTHRU (0x1ui64)
#define FWPM_CONTEXT_IPSEC_INBOUND_PERSIST_CONNECTION_SECURITY (0x2ui64)
#define FWPM_CONTEXT_IPSEC_INBOUND_RESERVED (0xff00000000000000ui64)

// IPSec transport filter contexts in outbound layer
#define FWPM_CONTEXT_IPSEC_OUTBOUND_NEGOTIATE_DISCOVER (0x1ui64)

// Filter contexts used in the ALE connect layer
#define FWPM_CONTEXT_ALE_SET_CONNECTION_REQUIRE_IPSEC_SECURITY (0x2ui64)
#define FWPM_CONTEXT_ALE_SET_CONNECTION_LAZY_SD_EVALUATION (0x4ui64)

// Filter contexts used in the ALE connect or accept layer
#define FWPM_CONTEXT_ALE_SET_CONNECTION_REQUIRE_IPSEC_ENCRYPTION (0x8ui64)

// Contexts used by the TCP Chimney Offload callouts.
#define FWPM_CONTEXT_TCP_CHIMNEY_OFFLOAD_ENABLE (0x1ui64)
#define FWPM_CONTEXT_TCP_CHIMNEY_OFFLOAD_DISABLE (0x2ui64)

// Contexts used in the RPC audit sublayer
#define FWPM_CONTEXT_RPC_AUDIT_ENABLED (0x1ui64)

///////////////////////////////////////////////////////////////////////////////
//
// Access rights
//
///////////////////////////////////////////////////////////////////////////////

// Specific access rights.
#define FWPM_ACTRL_ADD               (0x00000001)
#define FWPM_ACTRL_ADD_LINK          (0x00000002)
#define FWPM_ACTRL_BEGIN_READ_TXN    (0x00000004)
#define FWPM_ACTRL_BEGIN_WRITE_TXN   (0x00000008)
#define FWPM_ACTRL_CLASSIFY          (0x00000010)
#define FWPM_ACTRL_ENUM              (0x00000020)
#define FWPM_ACTRL_OPEN              (0x00000040)
#define FWPM_ACTRL_READ              (0x00000080)
#define FWPM_ACTRL_READ_STATS        (0x00000100)
#define FWPM_ACTRL_SUBSCRIBE         (0x00000200)
#define FWPM_ACTRL_WRITE             (0x00000400)

// Generic access rights.
#define FWPM_GENERIC_READ \
      ( STANDARD_RIGHTS_READ       | \
        FWPM_ACTRL_BEGIN_READ_TXN  | \
        FWPM_ACTRL_CLASSIFY        | \
        FWPM_ACTRL_OPEN            | \
        FWPM_ACTRL_READ            | \
        FWPM_ACTRL_READ_STATS      )

#define FWPM_GENERIC_EXECUTE \
      ( STANDARD_RIGHTS_EXECUTE    | \
        FWPM_ACTRL_ENUM            | \
        FWPM_ACTRL_SUBSCRIBE       )

#define FWPM_GENERIC_WRITE \
      ( STANDARD_RIGHTS_WRITE      | \
        DELETE                     | \
        FWPM_ACTRL_ADD             | \
        FWPM_ACTRL_ADD_LINK        | \
        FWPM_ACTRL_BEGIN_WRITE_TXN | \
        FWPM_ACTRL_WRITE           )

#define FWPM_GENERIC_ALL \
      ( STANDARD_RIGHTS_REQUIRED   | \
        FWPM_ACTRL_ADD             | \
        FWPM_ACTRL_ADD_LINK        | \
        FWPM_ACTRL_BEGIN_READ_TXN  | \
        FWPM_ACTRL_BEGIN_WRITE_TXN | \
        FWPM_ACTRL_CLASSIFY        | \
        FWPM_ACTRL_ENUM            | \
        FWPM_ACTRL_OPEN            | \
        FWPM_ACTRL_READ            | \
        FWPM_ACTRL_READ_STATS      | \
        FWPM_ACTRL_SUBSCRIBE       | \
        FWPM_ACTRL_WRITE           )


///////////////////////////////////////////////////////////////////////////////
//
// Common utility functions.
//
///////////////////////////////////////////////////////////////////////////////

void WINAPI FwpmFreeMemory0(IN OUT void** p);


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing the engine.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmEngineOpen0(
   IN OPTIONAL const wchar_t* serverName,
   IN UINT32 authnService,
   IN OPTIONAL SEC_WINNT_AUTH_IDENTITY_W* authIdentity,
   IN OPTIONAL const FWPM_SESSION0* session,
   OUT HANDLE* engineHandle
   );

DWORD
WINAPI
FwpmEngineClose0(IN HANDLE engineHandle);

DWORD
WINAPI
FwpmEngineGetOption0(
   IN HANDLE engineHandle,
   IN FWPM_ENGINE_OPTION option,
   OUT FWP_VALUE0** value
   );

DWORD
WINAPI
FwpmEngineSetOption0(
   IN HANDLE engineHandle,
   IN FWPM_ENGINE_OPTION option,
   IN const FWP_VALUE0* newValue
   );

DWORD
WINAPI
FwpmEngineGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmEngineSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

DWORD
WINAPI
FwpmSessionCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_SESSION_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmSessionEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_SESSION0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmSessionDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for explicit transactions.
//
///////////////////////////////////////////////////////////////////////////////

#define FWPM_TXN_READ_ONLY (0x00000001)

DWORD
WINAPI
FwpmTransactionBegin0(
   IN HANDLE engineHandle,
   IN UINT32 flags
   );

DWORD
WINAPI
FwpmTransactionCommit0(IN HANDLE engineHandle);

DWORD
WINAPI
FwpmTransactionAbort0(IN HANDLE engineHandle);


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing providers.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmProviderAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_PROVIDER0* provider,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd
   );

DWORD
WINAPI
FwpmProviderDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

DWORD
WINAPI
FwpmProviderGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_PROVIDER0** provider
   );

DWORD
WINAPI
FwpmProviderCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_PROVIDER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmProviderEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_PROVIDER0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmProviderDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmProviderGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmProviderSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

typedef void (CALLBACK *FWPM_PROVIDER_CHANGE_CALLBACK0)(
                           IN void* context,
                           IN const FWPM_PROVIDER_CHANGE0* change
                           );

DWORD
WINAPI
FwpmProviderSubscribeChanges0(
   IN HANDLE engineHandle,
   IN const FWPM_PROVIDER_SUBSCRIPTION0* subscription,
   IN FWPM_PROVIDER_CHANGE_CALLBACK0 callback,
   IN OPTIONAL void* context,
   OUT HANDLE* changeHandle
   );

DWORD
WINAPI
FwpmProviderUnsubscribeChanges0(
   IN HANDLE engineHandle,
   IN HANDLE changeHandle
   );

DWORD
WINAPI
FwpmProviderSubscriptionsGet0(
   IN HANDLE engineHandle,
   OUT FWPM_PROVIDER_SUBSCRIPTION0*** entries,
   OUT UINT32* numEntries
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing provider contexts.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmProviderContextAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_PROVIDER_CONTEXT0* providerContext,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd,
   OUT OPTIONAL UINT64* id
   );

DWORD
WINAPI
FwpmProviderContextDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

DWORD
WINAPI
FwpmProviderContextDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

DWORD
WINAPI
FwpmProviderContextGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT FWPM_PROVIDER_CONTEXT0** providerContext
   );

DWORD
WINAPI
FwpmProviderContextGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_PROVIDER_CONTEXT0** providerContext
   );

DWORD
WINAPI
FwpmProviderContextCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_PROVIDER_CONTEXT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmProviderContextEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_PROVIDER_CONTEXT0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmProviderContextDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmProviderContextGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmProviderContextSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

typedef void (CALLBACK *FWPM_PROVIDER_CONTEXT_CHANGE_CALLBACK0)(
                           IN void* context,
                           IN const FWPM_PROVIDER_CONTEXT_CHANGE0* change
                           );

DWORD
WINAPI
FwpmProviderContextSubscribeChanges0(
   IN HANDLE engineHandle,
   IN const FWPM_PROVIDER_CONTEXT_SUBSCRIPTION0* subscription,
   IN FWPM_PROVIDER_CONTEXT_CHANGE_CALLBACK0 callback,
   IN OPTIONAL void* context,
   OUT HANDLE* changeHandle
   );

DWORD
WINAPI
FwpmProviderContextUnsubscribeChanges0(
   IN HANDLE engineHandle,
   IN HANDLE changeHandle
   );

DWORD
WINAPI
FwpmProviderContextSubscriptionsGet0(
   IN HANDLE engineHandle,
   OUT FWPM_PROVIDER_CONTEXT_SUBSCRIPTION0*** entries,
   OUT UINT32* numEntries
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing sub-layers.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmSubLayerAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_SUBLAYER0* subLayer,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd
   );

DWORD
WINAPI
FwpmSubLayerDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

DWORD
WINAPI
FwpmSubLayerGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_SUBLAYER0** subLayer
   );

DWORD
WINAPI
FwpmSubLayerCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_SUBLAYER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmSubLayerEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_SUBLAYER0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmSubLayerDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmSubLayerGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmSubLayerSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

typedef void (CALLBACK *FWPM_SUBLAYER_CHANGE_CALLBACK0)(
                           IN void* context,
                           IN const FWPM_SUBLAYER_CHANGE0* change
                           );

DWORD
WINAPI
FwpmSubLayerSubscribeChanges0(
   IN HANDLE engineHandle,
   IN const FWPM_SUBLAYER_SUBSCRIPTION0* subscription,
   IN FWPM_SUBLAYER_CHANGE_CALLBACK0 callback,
   IN OPTIONAL void* context,
   OUT HANDLE* changeHandle
   );

DWORD
WINAPI
FwpmSubLayerUnsubscribeChanges0(
   IN HANDLE engineHandle,
   IN HANDLE changeHandle
   );

DWORD
WINAPI
FwpmSubLayerSubscriptionsGet0(
   IN HANDLE engineHandle,
   OUT FWPM_SUBLAYER_SUBSCRIPTION0*** entries,
   OUT UINT32* numEntries
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing layers.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmLayerGetById0(
   HANDLE engineHandle,
   IN UINT16 id,
   OUT FWPM_LAYER0** layer
   );

DWORD
WINAPI
FwpmLayerGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_LAYER0** layer
   );

DWORD
WINAPI
FwpmLayerCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_LAYER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmLayerEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_LAYER0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmLayerDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmLayerGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmLayerSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing callouts.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmCalloutAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_CALLOUT0* callout,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd,
   OUT OPTIONAL UINT32* id
   );

DWORD
WINAPI
FwpmCalloutDeleteById0(
   IN HANDLE engineHandle,
   IN UINT32 id
   );

DWORD
WINAPI
FwpmCalloutDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

DWORD
WINAPI
FwpmCalloutGetById0(
   HANDLE engineHandle,
   IN UINT32 id,
   OUT FWPM_CALLOUT0** callout
   );

DWORD
WINAPI
FwpmCalloutGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_CALLOUT0** callout
   );

DWORD
WINAPI
FwpmCalloutCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_CALLOUT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmCalloutEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_CALLOUT0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmCalloutDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmCalloutGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmCalloutSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

typedef void (CALLBACK *FWPM_CALLOUT_CHANGE_CALLBACK0)(
                           IN void* context,
                           IN const FWPM_CALLOUT_CHANGE0* change
                           );

DWORD
WINAPI
FwpmCalloutSubscribeChanges0(
   IN HANDLE engineHandle,
   IN const FWPM_CALLOUT_SUBSCRIPTION0* subscription,
   IN FWPM_CALLOUT_CHANGE_CALLBACK0 callback,
   IN OPTIONAL void* context,
   OUT HANDLE* changeHandle
   );

DWORD
WINAPI
FwpmCalloutUnsubscribeChanges0(
   IN HANDLE engineHandle,
   IN HANDLE changeHandle
   );

DWORD
WINAPI
FwpmCalloutSubscriptionsGet0(
   IN HANDLE engineHandle,
   OUT FWPM_CALLOUT_SUBSCRIPTION0*** entries,
   OUT UINT32* numEntries
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing filters.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmFilterAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_FILTER0* filter,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd,
   OUT OPTIONAL UINT64* id
   );

DWORD
WINAPI
FwpmFilterDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

DWORD
WINAPI
FwpmFilterDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

DWORD
WINAPI
FwpmFilterGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT FWPM_FILTER0** filter
   );

DWORD
WINAPI
FwpmFilterGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_FILTER0** filter
   );

DWORD
WINAPI
FwpmFilterCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_FILTER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmFilterEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_FILTER0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmFilterDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmFilterGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmFilterSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

typedef void (CALLBACK *FWPM_FILTER_CHANGE_CALLBACK0)(
                           IN void* context,
                           IN const FWPM_FILTER_CHANGE0* change
                           );

DWORD
WINAPI
FwpmFilterSubscribeChanges0(
   IN HANDLE engineHandle,
   IN const FWPM_FILTER_SUBSCRIPTION0* subscription,
   IN FWPM_FILTER_CHANGE_CALLBACK0 callback,
   IN OPTIONAL void* context,
   OUT HANDLE* changeHandle
   );

DWORD
WINAPI
FwpmFilterUnsubscribeChanges0(
   IN HANDLE engineHandle,
   IN HANDLE changeHandle
   );

DWORD
WINAPI
FwpmFilterSubscriptionsGet0(
   IN HANDLE engineHandle,
   OUT FWPM_FILTER_SUBSCRIPTION0*** entries,
   OUT UINT32* numEntries
   );

DWORD
WINAPI
FwpmGetAppIdFromFileName0(
   IN const wchar_t* fileName,
   OUT FWP_BYTE_BLOB** appId
   );


///////////////////////////////////////////////////////////////////////////////
//
// Helper functions for configuring an IPsec tunnel.
//
///////////////////////////////////////////////////////////////////////////////

// Create a point-to-point tunnel.
#define FWPM_TUNNEL_FLAG_POINT_TO_POINT (0x00000001)

DWORD
WINAPI
FwpmIPsecTunnelAdd0(
   IN HANDLE engineHandle,
   IN UINT32 flags,
   IN OPTIONAL const FWPM_PROVIDER_CONTEXT0* mainModePolicy,
   IN const FWPM_PROVIDER_CONTEXT0* tunnelPolicy,
   IN UINT32 numFilterConditions,
   IN const FWPM_FILTER_CONDITION0* filterConditions,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd
   );

DWORD
WINAPI
FwpmIPsecTunnelDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing IPsec.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
IPsecGetStatistics0(
   IN HANDLE engineHandle,
   OUT IPSEC_STATISTICS0* ipsecStatistics
   );

DWORD
WINAPI
IPsecSaContextCreate0(
   IN HANDLE engineHandle,
   IN const IPSEC_TRAFFIC0* outboundTraffic,
   OUT OPTIONAL UINT64* inboundFilterId,
   OUT UINT64* id
   );

DWORD
WINAPI
IPsecSaContextDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

DWORD
WINAPI
IPsecSaContextGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT IPSEC_SA_CONTEXT0** saContext
   );

DWORD
WINAPI
IPsecSaContextGetSpi0(
   IN HANDLE engineHandle,
   IN UINT64 id,
   IN const IPSEC_GETSPI0* getSpi,
   OUT IPSEC_SA_SPI* inboundSpi
   );

DWORD
WINAPI
IPsecSaContextAddInbound0(
   IN HANDLE engineHandle,
   IN UINT64 id,
   IN const IPSEC_SA_BUNDLE0* inboundBundle
   );

DWORD
WINAPI
IPsecSaContextAddOutbound0(
   IN HANDLE engineHandle,
   IN UINT64 id,
   IN const IPSEC_SA_BUNDLE0* outboundBundle
   );

DWORD
WINAPI
IPsecSaContextExpire0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

DWORD
WINAPI
IPsecSaContextCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const IPSEC_SA_CONTEXT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
IPsecSaContextEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT IPSEC_SA_CONTEXT0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
IPsecSaContextDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
IPsecSaCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const IPSEC_SA_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
IPsecSaEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT IPSEC_SA_DETAILS0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
IPsecSaDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
IPsecSaDbGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
IPsecSaDbSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing IKE, Authip.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
IkeextGetStatistics0(
   IN HANDLE engineHandle,
   OUT IKEEXT_STATISTICS0* ikeextStatistics
   );

DWORD
WINAPI
IkeextSaDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

DWORD
WINAPI
IkeextSaGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT IKEEXT_SA_DETAILS0** sa
   );

DWORD
WINAPI
IkeextSaCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const IKEEXT_SA_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
IkeextSaEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT IKEEXT_SA_DETAILS0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
IkeextSaDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
IkeextSaDbGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
IkeextSaDbSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

///////////////////////////////////////////////////////////////////////////////
//
// Functions for diagnostics.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmNetEventCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_NET_EVENT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmNetEventEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_NET_EVENT0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmNetEventDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmNetEventsGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmNetEventsSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

#ifdef __cplusplus
}
#endif
#endif // FWPMX_H
#endif // GUID_DEFS_ONLY
#endif // (NTDDI_VERSION >= NTDDI_WIN6)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\gameux.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for gameux.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __gameux_h__
#define __gameux_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IGameExplorer_FWD_DEFINED__
#define __IGameExplorer_FWD_DEFINED__
typedef interface IGameExplorer IGameExplorer;
#endif 	/* __IGameExplorer_FWD_DEFINED__ */


#ifndef __GameExplorer_FWD_DEFINED__
#define __GameExplorer_FWD_DEFINED__

#ifdef __cplusplus
typedef class GameExplorer GameExplorer;
#else
typedef struct GameExplorer GameExplorer;
#endif /* __cplusplus */

#endif 	/* __GameExplorer_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "shobjidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_gameux_0000_0000 */
/* [local] */ 

#define ID_GDF_XML __GDF_XML
#define ID_GDF_THUMBNAIL __GDF_THUMBNAIL
#define ID_ICON_ICO __ICON_ICO
#define ID_GDF_XML_STR L"__GDF_XML"
#define ID_GDF_THUMBNAIL_STR L"__GDF_THUMBNAIL"
typedef /* [v1_enum] */ 
enum GAME_INSTALL_SCOPE
    {	GIS_NOT_INSTALLED	= 1,
	GIS_CURRENT_USER	= 2,
	GIS_ALL_USERS	= 3
    } 	GAME_INSTALL_SCOPE;



extern RPC_IF_HANDLE __MIDL_itf_gameux_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_gameux_0000_0000_v0_0_s_ifspec;

#ifndef __IGameExplorer_INTERFACE_DEFINED__
#define __IGameExplorer_INTERFACE_DEFINED__

/* interface IGameExplorer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGameExplorer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E7B2FB72-D728-49B3-A5F2-18EBF5F1349E")
    IGameExplorer : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddGame( 
            /* [in] */ __RPC__in BSTR bstrGDFBinaryPath,
            /* [in] */ __RPC__in BSTR bstrGameInstallDirectory,
            /* [in] */ GAME_INSTALL_SCOPE installScope,
            /* [out][in] */ __RPC__inout GUID *pguidInstanceID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveGame( 
            /* [in] */ GUID guidInstanceID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UpdateGame( 
            /* [in] */ GUID guidInstanceID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VerifyAccess( 
            /* [in] */ __RPC__in BSTR bstrGDFBinaryPath,
            /* [out] */ __RPC__out BOOL *pfHasAccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGameExplorerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGameExplorer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGameExplorer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGameExplorer * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddGame )( 
            IGameExplorer * This,
            /* [in] */ __RPC__in BSTR bstrGDFBinaryPath,
            /* [in] */ __RPC__in BSTR bstrGameInstallDirectory,
            /* [in] */ GAME_INSTALL_SCOPE installScope,
            /* [out][in] */ __RPC__inout GUID *pguidInstanceID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveGame )( 
            IGameExplorer * This,
            /* [in] */ GUID guidInstanceID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UpdateGame )( 
            IGameExplorer * This,
            /* [in] */ GUID guidInstanceID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VerifyAccess )( 
            IGameExplorer * This,
            /* [in] */ __RPC__in BSTR bstrGDFBinaryPath,
            /* [out] */ __RPC__out BOOL *pfHasAccess);
        
        END_INTERFACE
    } IGameExplorerVtbl;

    interface IGameExplorer
    {
        CONST_VTBL struct IGameExplorerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGameExplorer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGameExplorer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGameExplorer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGameExplorer_AddGame(This,bstrGDFBinaryPath,bstrGameInstallDirectory,installScope,pguidInstanceID)	\
    ( (This)->lpVtbl -> AddGame(This,bstrGDFBinaryPath,bstrGameInstallDirectory,installScope,pguidInstanceID) ) 

#define IGameExplorer_RemoveGame(This,guidInstanceID)	\
    ( (This)->lpVtbl -> RemoveGame(This,guidInstanceID) ) 

#define IGameExplorer_UpdateGame(This,guidInstanceID)	\
    ( (This)->lpVtbl -> UpdateGame(This,guidInstanceID) ) 

#define IGameExplorer_VerifyAccess(This,bstrGDFBinaryPath,pfHasAccess)	\
    ( (This)->lpVtbl -> VerifyAccess(This,bstrGDFBinaryPath,pfHasAccess) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGameExplorer_INTERFACE_DEFINED__ */



#ifndef __gameuxLib_LIBRARY_DEFINED__
#define __gameuxLib_LIBRARY_DEFINED__

/* library gameuxLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_gameuxLib;

EXTERN_C const CLSID CLSID_GameExplorer;

#ifdef __cplusplus

class DECLSPEC_UUID("9A5EA990-3034-4D6F-9128-01F3C61022BC")
GameExplorer;
#endif
#endif /* __gameuxLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\fwptypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for fwptypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __fwptypes_h__
#define __fwptypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_fwptypes_0000_0000 */
/* [local] */ 

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
#ifdef __midl
typedef struct _LUID
    {
    DWORD LowPart;
    LONG HighPart;
    } 	LUID;

typedef struct _LUID *PLUID;

#endif
typedef /* [v1_enum] */ 
enum FWP_DIRECTION_
    {	FWP_DIRECTION_OUTBOUND	= 0,
	FWP_DIRECTION_INBOUND	= ( FWP_DIRECTION_OUTBOUND + 1 ) ,
	FWP_DIRECTION_MAX	= ( FWP_DIRECTION_INBOUND + 1 ) 
    } 	FWP_DIRECTION;

typedef /* [v1_enum] */ 
enum FWP_IP_VERSION_
    {	FWP_IP_VERSION_V4	= 0,
	FWP_IP_VERSION_V6	= ( FWP_IP_VERSION_V4 + 1 ) ,
	FWP_IP_VERSION_MAX	= ( FWP_IP_VERSION_V6 + 1 ) 
    } 	FWP_IP_VERSION;

typedef /* [v1_enum] */ 
enum FWP_DATA_TYPE_
    {	FWP_EMPTY	= 0,
	FWP_UINT8	= ( FWP_EMPTY + 1 ) ,
	FWP_UINT16	= ( FWP_UINT8 + 1 ) ,
	FWP_UINT32	= ( FWP_UINT16 + 1 ) ,
	FWP_UINT64	= ( FWP_UINT32 + 1 ) ,
	FWP_INT8	= ( FWP_UINT64 + 1 ) ,
	FWP_INT16	= ( FWP_INT8 + 1 ) ,
	FWP_INT32	= ( FWP_INT16 + 1 ) ,
	FWP_INT64	= ( FWP_INT32 + 1 ) ,
	FWP_FLOAT	= ( FWP_INT64 + 1 ) ,
	FWP_DOUBLE	= ( FWP_FLOAT + 1 ) ,
	FWP_BYTE_ARRAY16_TYPE	= ( FWP_DOUBLE + 1 ) ,
	FWP_BYTE_BLOB_TYPE	= ( FWP_BYTE_ARRAY16_TYPE + 1 ) ,
	FWP_SID	= ( FWP_BYTE_BLOB_TYPE + 1 ) ,
	FWP_SECURITY_DESCRIPTOR_TYPE	= ( FWP_SID + 1 ) ,
	FWP_TOKEN_INFORMATION_TYPE	= ( FWP_SECURITY_DESCRIPTOR_TYPE + 1 ) ,
	FWP_TOKEN_ACCESS_INFORMATION_TYPE	= ( FWP_TOKEN_INFORMATION_TYPE + 1 ) ,
	FWP_UNICODE_STRING_TYPE	= ( FWP_TOKEN_ACCESS_INFORMATION_TYPE + 1 ) ,
	FWP_SINGLE_DATA_TYPE_MAX	= 0xff,
	FWP_V4_ADDR_MASK	= ( FWP_SINGLE_DATA_TYPE_MAX + 1 ) ,
	FWP_V6_ADDR_MASK	= ( FWP_V4_ADDR_MASK + 1 ) ,
	FWP_RANGE_TYPE	= ( FWP_V6_ADDR_MASK + 1 ) ,
	FWP_DATA_TYPE_MAX	= ( FWP_RANGE_TYPE + 1 ) 
    } 	FWP_DATA_TYPE;

typedef struct FWP_BYTE_ARRAY16_
    {
    UINT8 byteArray16[ 16 ];
    } 	FWP_BYTE_ARRAY16;

typedef struct FWP_BYTE_BLOB_
    {
    UINT32 size;
    UINT8 *data;
    } 	FWP_BYTE_BLOB;

typedef struct FWP_TOKEN_INFORMATION_
    {
    ULONG sidCount;
    PSID_AND_ATTRIBUTES sids;
    ULONG restrictedSidCount;
    PSID_AND_ATTRIBUTES restrictedSids;
    } 	FWP_TOKEN_INFORMATION;

typedef struct FWP_VALUE0_
    {
    FWP_DATA_TYPE type;
    union 
        {
         /* Empty union arm */ 
        UINT8 uint8;
        UINT16 uint16;
        UINT32 uint32;
        UINT64 *uint64;
        INT8 int8;
        INT16 int16;
        INT32 int32;
        INT64 *int64;
        float float32;
        double *double64;
        FWP_BYTE_ARRAY16 *byteArray16;
        FWP_BYTE_BLOB *byteBlob;
        SID *sid;
        FWP_BYTE_BLOB *sd;
        FWP_TOKEN_INFORMATION *tokenInformation;
        FWP_BYTE_BLOB *tokenAccessInformation;
        LPWSTR unicodeString;
        } 	;
    } 	FWP_VALUE0;

typedef /* [v1_enum] */ 
enum FWP_MATCH_TYPE_
    {	FWP_MATCH_EQUAL	= 0,
	FWP_MATCH_GREATER	= ( FWP_MATCH_EQUAL + 1 ) ,
	FWP_MATCH_LESS	= ( FWP_MATCH_GREATER + 1 ) ,
	FWP_MATCH_GREATER_OR_EQUAL	= ( FWP_MATCH_LESS + 1 ) ,
	FWP_MATCH_LESS_OR_EQUAL	= ( FWP_MATCH_GREATER_OR_EQUAL + 1 ) ,
	FWP_MATCH_RANGE	= ( FWP_MATCH_LESS_OR_EQUAL + 1 ) ,
	FWP_MATCH_FLAGS_ALL_SET	= ( FWP_MATCH_RANGE + 1 ) ,
	FWP_MATCH_FLAGS_ANY_SET	= ( FWP_MATCH_FLAGS_ALL_SET + 1 ) ,
	FWP_MATCH_FLAGS_NONE_SET	= ( FWP_MATCH_FLAGS_ANY_SET + 1 ) ,
	FWP_MATCH_EQUAL_CASE_INSENSITIVE	= ( FWP_MATCH_FLAGS_NONE_SET + 1 ) ,
	FWP_MATCH_TYPE_MAX	= ( FWP_MATCH_EQUAL_CASE_INSENSITIVE + 1 ) 
    } 	FWP_MATCH_TYPE;

typedef struct FWP_V4_ADDR_AND_MASK_
    {
    UINT32 addr;
    UINT32 mask;
    } 	FWP_V4_ADDR_AND_MASK;

#define FWP_V6_ADDR_SIZE (16)
typedef struct FWP_V6_ADDR_AND_MASK_
    {
    UINT8 addr[ 16 ];
    UINT8 prefixLength;
    } 	FWP_V6_ADDR_AND_MASK;

typedef struct FWP_RANGE0_
    {
    FWP_VALUE0 valueLow;
    FWP_VALUE0 valueHigh;
    } 	FWP_RANGE0;

#define FWP_ACTRL_MATCH_FILTER (0x00000001)

typedef struct FWP_CONDITION_VALUE0_
    {
    FWP_DATA_TYPE type;
    union 
        {
         /* Empty union arm */ 
        UINT8 uint8;
        UINT16 uint16;
        UINT32 uint32;
        UINT64 *uint64;
        INT8 int8;
        INT16 int16;
        INT32 int32;
        INT64 *int64;
        float float32;
        double *double64;
        FWP_BYTE_ARRAY16 *byteArray16;
        FWP_BYTE_BLOB *byteBlob;
        SID *sid;
        FWP_BYTE_BLOB *sd;
        FWP_TOKEN_INFORMATION *tokenInformation;
        FWP_BYTE_BLOB *tokenAccessInformation;
        LPWSTR unicodeString;
        FWP_V4_ADDR_AND_MASK *v4AddrMask;
        FWP_V6_ADDR_AND_MASK *v6AddrMask;
        FWP_RANGE0 *rangeValue;
        } 	;
    } 	FWP_CONDITION_VALUE0;

typedef /* [v1_enum] */ 
enum FWP_CLASSIFY_OPTION_TYPE_
    {	FWP_CLASSIFY_OPTION_MULTICAST_STATE	= 0,
	FWP_CLASSIFY_OPTION_LOOSE_SOURCE_MAPPING	= ( FWP_CLASSIFY_OPTION_MULTICAST_STATE + 1 ) ,
	FWP_CLASSIFY_OPTION_UNICAST_LIFETIME	= ( FWP_CLASSIFY_OPTION_LOOSE_SOURCE_MAPPING + 1 ) ,
	FWP_CLASSIFY_OPTION_MCAST_BCAST_LIFETIME	= ( FWP_CLASSIFY_OPTION_UNICAST_LIFETIME + 1 ) ,
	FWP_CLASSIFY_OPTION_MAX	= ( FWP_CLASSIFY_OPTION_MCAST_BCAST_LIFETIME + 1 ) 
    } 	FWP_CLASSIFY_OPTION_TYPE;

#define FWP_OPTION_VALUE_ALLOW_MULTICAST_STATE (0x00000000)
#define FWP_OPTION_VALUE_DENY_MULTICAST_STATE  (0x00000001)
#define FWP_OPTION_VALUE_ALLOW_GLOBAL_MULTICAST_STATE (0x00000002)
#define FWP_OPTION_VALUE_DISABLE_LOOSE_SOURCE (0x00000000)
#define FWP_OPTION_VALUE_ENABLE_LOOSE_SOURCE  (0x00000001)
#define FWP_ACTION_FLAG_TERMINATING     (0x00001000)
#define FWP_ACTION_FLAG_NON_TERMINATING (0x00002000)
#define FWP_ACTION_FLAG_CALLOUT         (0x00004000)
typedef UINT32 FWP_ACTION_TYPE;

#define FWP_ACTION_BLOCK \

   (0x00000001 | FWP_ACTION_FLAG_TERMINATING)
#define FWP_ACTION_PERMIT \

   (0x00000002 | FWP_ACTION_FLAG_TERMINATING)
#define FWP_ACTION_CALLOUT_TERMINATING \

   (0x00000003 | FWP_ACTION_FLAG_CALLOUT | FWP_ACTION_FLAG_TERMINATING)
#define FWP_ACTION_CALLOUT_INSPECTION \

   (0x00000004 | FWP_ACTION_FLAG_CALLOUT | FWP_ACTION_FLAG_NON_TERMINATING)
#define FWP_ACTION_CALLOUT_UNKNOWN \

   (0x00000005 | FWP_ACTION_FLAG_CALLOUT)
#define FWP_ACTION_CONTINUE \

   (0x00000006 | FWP_ACTION_FLAG_NON_TERMINATING)
#define FWP_ACTION_NONE \

   (0x00000007)
#define FWP_ACTION_NONE_NO_MATCH \

   (0x00000008)
#define FWP_CONDITION_FLAG_IS_LOOPBACK              (0x00000001)
#define FWP_CONDITION_FLAG_IS_IPSEC_SECURED         (0x00000002)
#define FWP_CONDITION_FLAG_IS_REAUTHORIZE           (0x00000004)
#define FWP_CONDITION_FLAG_IS_WILDCARD_BIND         (0x00000008)
#define FWP_CONDITION_FLAG_IS_RAW_ENDPOINT          (0x00000010)
#define FWP_CONDITION_FLAG_IS_FRAGMENT              (0x00000020)
#define FWP_CONDITION_FLAG_IS_FRAGMENT_GROUP        (0x00000040)
#define FWP_CONDITION_FLAG_IS_IPSEC_NATT_RECLASSIFY (0x00000080)
#define FWP_CONDITION_FLAG_REQUIRES_ALE_CLASSIFY    (0x00000100)
#define FWP_CONDITION_FLAG_IS_IMPLICIT_BIND         (0x00000200)
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
#define FWP_CONDITION_FLAG_IS_REASSEMBLED           (0x00000400)
#endif
typedef /* [v1_enum] */ 
enum FWP_FILTER_ENUM_TYPE_
    {	FWP_FILTER_ENUM_FULLY_CONTAINED	= 0,
	FWP_FILTER_ENUM_OVERLAPPING	= ( FWP_FILTER_ENUM_FULLY_CONTAINED + 1 ) ,
	FWP_FILTER_ENUM_TYPE_MAX	= ( FWP_FILTER_ENUM_OVERLAPPING + 1 ) 
    } 	FWP_FILTER_ENUM_TYPE;

#define FWP_FILTER_ENUM_FLAG_BEST_TERMINATING_MATCH (0x00000001)
#define FWP_FILTER_ENUM_FLAG_SORTED                 (0x00000002)
#define FWP_FILTER_ENUM_FLAG_BOOTTIME_ONLY          (0x00000004)
#define FWP_FILTER_ENUM_FLAG_INCLUDE_BOOTTIME       (0x00000008)
#define FWP_FILTER_ENUM_FLAG_INCLUDE_DISABLED       (0x00000010)
#define FWP_FILTER_ENUM_VALID_FLAGS \

   (FWP_FILTER_ENUM_FLAG_BEST_TERMINATING_MATCH | \

    FWP_FILTER_ENUM_FLAG_SORTED)
#define FWP_CALLOUT_FLAG_CONDITIONAL_ON_FLOW (0x00000001)
#define FWP_CALLOUT_FLAG_ALLOW_OFFLOAD       (0x00000002)
#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_fwptypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fwptypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\gb18030.h ===
#ifndef __GB18030_H
#define __GB18030_H

//
//  Flags for dwFlags in NlsDllCodePageTranslation.
//
#define NLS_CP_CPINFO             0x10000000
#define NLS_CP_MBTOWC             0x40000000
#define NLS_CP_WCTOMB             0x80000000

////////////////////////////////////////////////////////////////////////////
//
// gb18030.h
//
// This is the header for using the c_g18030.dll in the system.  
// This file lists all exported functions in c_g18030.dll.
// c_g18030.dll is a codpeage conversion DLL for the Chinese GB-18030 codepage 
// (Windows codepage 54936).
//
// The best way to use c_g18030.dll is to use the Windows API 
// MultiByteToWideChar() and WideCharToMultiByte(), and pass 54936 as the codepage
// number.  Internally, MultiByteToWideChar() and WideCharToMultiByte() call function
// in c_g18030.dll using these exported functions.
//
// You can also use this header and load these functions dynamically from c_g18030.dll.
// However, this is not recommended since MulitByteToWideChar() and WideCharToMultiByte()
// are much easier to use and these exports may change between windows versions.
//
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
//
//  NlsDllCodePageTranslation
//    This routine is the main exported procedure for the functionality in
//    c_g18030.dll.  It can be used to get code page information or do conversion
//    depending on the value of dwFlags.
//
//    Parameters:
//      CodePage     The value of the codepage.  The value should be 54936.  Otherwise,
//                    0 will be returned and GetLastError() will return ERROR_INVALID_PARAMETER.
//
//      dwFlags        It can be one of these values
//          NLS_CP_CPINFO    To return code page information in the buffer pointed by
//                           lpCPInfo. lpMultiByteStr/cchMultiByte/lpWideCharStr/cchWideChar are not used.
//
//          NLS_CP_MBTOWC    Convert GB-18030 bytes to Unicode characters.
//                           The source GB-18030 characters should be pointed by lpMultiByteStr, and cchMultiByte should
//                           contains the byte count of the buffer.
//                           The Unicode result will be stored in the buffer pointed by lpWideCharStr, and cchWideChar
//                           should contain the character count of the Unicode buffer.
//                           If lpWideCharStr or cchWideChar are zero, the expected character count of the Unicode result
//                           will be returned, and no real conversion will be done.
//                           lpCPInfo is not used in this case.
//                                    
//          NLS_CP_WCTOMB    Convert Unicode characters to GB-18030 bytes.
//                           The source Unicode string should be pointed by lpWideCharStr, and cchWideChar should
//                           contians the character count of the buffer.
//                           The GB-18030 result will be stored in the buffer pointed by lpMultiByteStr, and cchMultiByte
//                           should contain the byte count of the GB-18030 buffer.
//                           If lpMultiByteStr or cchMultiByte are zero, the byte count of the GB-18030 result
//                           will be returned, and no real conversion will be done.
//                           lpCPInfo is not used in this case.
//
//                      Additionally one of these values may also be passed by logically oring them together
//          WC_ERR_INVALID_CHARS
//                           Returns 0 and GetLastError returns ERROR_NO_UNICODE_TRANSLATION if illegal unicode characters are 
//                           encountered during NLS_CP_WCTOMB, instead of replacing them with ?
//
//          MB_ERR_INVALID_CHARS
//                           Returns 0 and GetLastError returns ERROR_NO_UNICODE_TRANSLATION if illegal gb18030 code points
//                           are encountered during NLS_CPMBTOWC conversion.  If this flag isn't set they would be replaced
//                           by ? instead.
//
//        lpMultiByteStr    Pointed to a buffer which contains multi-byte GB-18030 characters.  This can be a source buffer
//                          or target buffer, depending on the value of dwFlags.
//
//        cchMulitByte      The byte count of the multi-byte buffer.
//
//        lpWideCharStr     Pointed to a buffer which contains Unicode characters.  This can be a source buffer
//                          or target buffer, depending on the value of dwFlags.
//
//        cchWideChar       The character count of the Unicode buffer.
//
//        lpCPInfo          A pointer which points to a structure of CPINFO.  CPINFO is defined in Platform SDK.
//
//    Returns:
//        1 if the function succeeds.
//        0 if the function fails
//
////////////////////////////////////////////////////////////////////////////

STDAPI_(DWORD) NlsDllCodePageTranslation(
    DWORD CodePage,
    DWORD dwFlags,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar,
    LPCPINFO lpCPInfo);

////////////////////////////////////////////////////////////////////////////
//
//  BytesToUnicode
//
//  Deprecated, only available in Windows XP and Windows Server 2003.
//
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToBytes
//
//  Deprecated, only available in Windows XP and Windows Server 2003.
//
////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\gchost.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for gchost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __gchost_h__
#define __gchost_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IGCHost_FWD_DEFINED__
#define __IGCHost_FWD_DEFINED__
typedef interface IGCHost IGCHost;
#endif 	/* __IGCHost_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_gchost_0000 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_gchost_0000_0001
    {	COR_GC_COUNTS	= 0x1,
	COR_GC_MEMORYUSAGE	= 0x2
    } 	COR_GC_STAT_TYPES;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_gchost_0000_0002
    {	COR_GC_THREAD_HAS_PROMOTED_BYTES	= 0x1
    } 	COR_GC_THREAD_STATS_TYPES;

typedef struct _COR_GC_STATS
    {
    ULONG Flags;
    SIZE_T ExplicitGCCount;
    SIZE_T GenCollectionsTaken[ 3 ];
    SIZE_T CommittedKBytes;
    SIZE_T ReservedKBytes;
    SIZE_T Gen0HeapSizeKBytes;
    SIZE_T Gen1HeapSizeKBytes;
    SIZE_T Gen2HeapSizeKBytes;
    SIZE_T LargeObjectHeapSizeKBytes;
    SIZE_T KBytesPromotedFromGen0;
    SIZE_T KBytesPromotedFromGen1;
    } 	COR_GC_STATS;

typedef struct _COR_GC_THREAD_STATS
    {
    ULONGLONG PerThreadAllocation;
    ULONG Flags;
    } 	COR_GC_THREAD_STATS;



extern RPC_IF_HANDLE __MIDL_itf_gchost_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_gchost_0000_v0_0_s_ifspec;

#ifndef __IGCHost_INTERFACE_DEFINED__
#define __IGCHost_INTERFACE_DEFINED__

/* interface IGCHost */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IGCHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAC34F6E-0DCD-47b5-8021-531BC5ECCA63")
    IGCHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGCStartupLimits( 
            /* [in] */ DWORD SegmentSize,
            /* [in] */ DWORD MaxGen0Size) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Collect( 
            /* [in] */ LONG Generation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStats( 
            /* [out][in] */ COR_GC_STATS *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadStats( 
            /* [in] */ DWORD *pFiberCookie,
            /* [out][in] */ COR_GC_THREAD_STATS *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVirtualMemLimit( 
            /* [in] */ SIZE_T sztMaxVirtualMemMB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGCHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGCHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGCHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGCHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetGCStartupLimits )( 
            IGCHost * This,
            /* [in] */ DWORD SegmentSize,
            /* [in] */ DWORD MaxGen0Size);
        
        HRESULT ( STDMETHODCALLTYPE *Collect )( 
            IGCHost * This,
            /* [in] */ LONG Generation);
        
        HRESULT ( STDMETHODCALLTYPE *GetStats )( 
            IGCHost * This,
            /* [out][in] */ COR_GC_STATS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadStats )( 
            IGCHost * This,
            /* [in] */ DWORD *pFiberCookie,
            /* [out][in] */ COR_GC_THREAD_STATS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *SetVirtualMemLimit )( 
            IGCHost * This,
            /* [in] */ SIZE_T sztMaxVirtualMemMB);
        
        END_INTERFACE
    } IGCHostVtbl;

    interface IGCHost
    {
        CONST_VTBL struct IGCHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGCHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGCHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGCHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGCHost_SetGCStartupLimits(This,SegmentSize,MaxGen0Size)	\
    (This)->lpVtbl -> SetGCStartupLimits(This,SegmentSize,MaxGen0Size)

#define IGCHost_Collect(This,Generation)	\
    (This)->lpVtbl -> Collect(This,Generation)

#define IGCHost_GetStats(This,pStats)	\
    (This)->lpVtbl -> GetStats(This,pStats)

#define IGCHost_GetThreadStats(This,pFiberCookie,pStats)	\
    (This)->lpVtbl -> GetThreadStats(This,pFiberCookie,pStats)

#define IGCHost_SetVirtualMemLimit(This,sztMaxVirtualMemMB)	\
    (This)->lpVtbl -> SetVirtualMemLimit(This,sztMaxVirtualMemMB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGCHost_SetGCStartupLimits_Proxy( 
    IGCHost * This,
    /* [in] */ DWORD SegmentSize,
    /* [in] */ DWORD MaxGen0Size);


void __RPC_STUB IGCHost_SetGCStartupLimits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCHost_Collect_Proxy( 
    IGCHost * This,
    /* [in] */ LONG Generation);


void __RPC_STUB IGCHost_Collect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCHost_GetStats_Proxy( 
    IGCHost * This,
    /* [out][in] */ COR_GC_STATS *pStats);


void __RPC_STUB IGCHost_GetStats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCHost_GetThreadStats_Proxy( 
    IGCHost * This,
    /* [in] */ DWORD *pFiberCookie,
    /* [out][in] */ COR_GC_THREAD_STATS *pStats);


void __RPC_STUB IGCHost_GetThreadStats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCHost_SetVirtualMemLimit_Proxy( 
    IGCHost * This,
    /* [in] */ SIZE_T sztMaxVirtualMemMB);


void __RPC_STUB IGCHost_SetVirtualMemLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGCHost_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\fwpsk.h ===
/*
   Copyright (c) Microsoft Corporation

   SYNOPSIS

     Declares the system portion of the FWP API.
*/

#ifndef FWPSX_H
#define FWPSX_H
#if _MSC_VER >= 1020
#pragma once
#endif

#if (NTDDI_VERSION >= NTDDI_WIN6)

#ifndef _KRPCENV_
#define _KRPCENV_ 1
#endif

#include "fwpstypes.h"
#include "ws2def.h"
#include "ndis.h"

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// LUIDs for built-in layers.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum FWPS_BUILTIN_LAYERS_
{
   // Kernel-mode layers
   FWPS_LAYER_INBOUND_IPPACKET_V4,
   FWPS_LAYER_INBOUND_IPPACKET_V4_DISCARD,
   FWPS_LAYER_INBOUND_IPPACKET_V6,
   FWPS_LAYER_INBOUND_IPPACKET_V6_DISCARD,
   FWPS_LAYER_OUTBOUND_IPPACKET_V4,
   FWPS_LAYER_OUTBOUND_IPPACKET_V4_DISCARD,
   FWPS_LAYER_OUTBOUND_IPPACKET_V6,
   FWPS_LAYER_OUTBOUND_IPPACKET_V6_DISCARD,
   FWPS_LAYER_IPFORWARD_V4,
   FWPS_LAYER_IPFORWARD_V4_DISCARD,
   FWPS_LAYER_IPFORWARD_V6,
   FWPS_LAYER_IPFORWARD_V6_DISCARD,
   FWPS_LAYER_INBOUND_TRANSPORT_V4,
   FWPS_LAYER_INBOUND_TRANSPORT_V4_DISCARD,
   FWPS_LAYER_INBOUND_TRANSPORT_V6,
   FWPS_LAYER_INBOUND_TRANSPORT_V6_DISCARD,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V4,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V4_DISCARD,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V6,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V6_DISCARD,
   FWPS_LAYER_STREAM_V4,
   FWPS_LAYER_STREAM_V4_DISCARD,
   FWPS_LAYER_STREAM_V6,
   FWPS_LAYER_STREAM_V6_DISCARD,
   FWPS_LAYER_DATAGRAM_DATA_V4,
   FWPS_LAYER_DATAGRAM_DATA_V4_DISCARD,
   FWPS_LAYER_DATAGRAM_DATA_V6,
   FWPS_LAYER_DATAGRAM_DATA_V6_DISCARD,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V4,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V4_DISCARD,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V6,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V6_DISCARD,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V4,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V4_DISCARD,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V6,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V6_DISCARD,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V4,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V4_DISCARD,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V6,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V6_DISCARD,
   FWPS_LAYER_ALE_AUTH_LISTEN_V4,
   FWPS_LAYER_ALE_AUTH_LISTEN_V4_DISCARD,
   FWPS_LAYER_ALE_AUTH_LISTEN_V6,
   FWPS_LAYER_ALE_AUTH_LISTEN_V6_DISCARD,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V4,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V4_DISCARD,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V6,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V6_DISCARD,
   FWPS_LAYER_ALE_AUTH_CONNECT_V4,
   FWPS_LAYER_ALE_AUTH_CONNECT_V4_DISCARD,
   FWPS_LAYER_ALE_AUTH_CONNECT_V6,
   FWPS_LAYER_ALE_AUTH_CONNECT_V6_DISCARD,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V4,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V4_DISCARD,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V6,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V6_DISCARD,

   // User-mode layers
   FWPS_LAYER_IPSEC_KM_DEMUX_V4,
   FWPS_LAYER_IPSEC_KM_DEMUX_V6,
   FWPS_LAYER_IPSEC_V4,
   FWPS_LAYER_IPSEC_V6,
   FWPS_LAYER_IKEEXT_V4,
   FWPS_LAYER_IKEEXT_V6,
   FWPS_LAYER_RPC_UM,
   FWPS_LAYER_RPC_EPMAP,
   FWPS_LAYER_RPC_EP_ADD,
   FWPS_LAYER_RPC_PROXY_CONN,
   FWPS_LAYER_RPC_PROXY_IF,
   FWPS_BUILTIN_LAYER_MAX
} FWPS_BUILTIN_LAYERS;

#define FWPS_BUILTIN_KM_LAYER_MAX FWPS_LAYER_IPSEC_KM_DEMUX_V4

///////////////////////////////////////////////////////////////////////////////
//
// LUIDs for built-in fields.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum FWPS_FIELDS_INBOUND_IPPACKET_V4_
{
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V4_FLAGS,
   FWPS_FIELD_INBOUND_IPPACKET_V4_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_MAX
} FWPS_FIELDS_INBOUND_IPPACKET_V4;

typedef enum FWPS_FIELDS_INBOUND_IPPACKET_V6_
{
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V6_FLAGS,
   FWPS_FIELD_INBOUND_IPPACKET_V6_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_MAX
} FWPS_FIELDS_INBOUND_IPPACKET_V6;

typedef enum FWPS_FIELDS_OUTBOUND_IPPACKET_V4_
{
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_FLAGS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_MAX
} FWPS_FIELDS_OUTBOUND_IPPACKET_V4;

typedef enum FWPS_FIELDS_OUTBOUND_IPPACKET_V6_
{
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_FLAGS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_MAX
} FWPS_FIELDS_OUTBOUND_IPPACKET_V6;

typedef enum FWPS_FIELDS_IPFORWARD_V4_
{
   FWPS_FIELD_IPFORWARD_V4_IP_SOURCE_ADDRESS,
   FWPS_FIELD_IPFORWARD_V4_IP_DESTINATION_ADDRESS,
   FWPS_FIELD_IPFORWARD_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_IPFORWARD_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_IPFORWARD_V4_IP_FORWARD_INTERFACE,
   FWPS_FIELD_IPFORWARD_V4_SOURCE_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_SOURCE_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_DESTINATION_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_DESTINATION_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_FLAGS,
   FWPS_FIELD_IPFORWARD_V4_MAX
} FWPS_FIELDS_IPFORWARD_V4;

typedef enum FWPS_FIELDS_IPFORWARD_V6_
{
   FWPS_FIELD_IPFORWARD_V6_IP_SOURCE_ADDRESS,
   FWPS_FIELD_IPFORWARD_V6_IP_DESTINATION_ADDRESS,
   FWPS_FIELD_IPFORWARD_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_IPFORWARD_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_IPFORWARD_V6_IP_FORWARD_INTERFACE,
   FWPS_FIELD_IPFORWARD_V6_SOURCE_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_SOURCE_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_DESTINATION_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_DESTINATION_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_FLAGS,
   FWPS_FIELD_IPFORWARD_V6_MAX
} FWPS_FIELDS_IPFORWARD_V6;

typedef enum FWPS_FIELDS_INBOUND_TRANSPORT_V4_
{
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_PROTOCOL,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_FLAGS,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_MAX
} FWPS_FIELDS_INBOUND_TRANSPORT_V4;

#define FWPS_FIELD_INBOUND_TRANSPORT_V4_ICMP_TYPE \
        FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_INBOUND_TRANSPORT_V4_ICMP_CODE \
        FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_INBOUND_TRANSPORT_V6_
{
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_PROTOCOL,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_FLAGS,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_MAX
} FWPS_FIELDS_INBOUND_TRANSPORT_V6;

#define FWPS_FIELD_INBOUND_TRANSPORT_V6_ICMP_TYPE \
        FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_INBOUND_TRANSPORT_V6_ICMP_CODE \
        FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_OUTBOUND_TRANSPORT_V4_
{
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_PROTOCOL,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_FLAGS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_MAX
} FWPS_FIELDS_OUTBOUND_TRANSPORT_V4;

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V4_ICMP_TYPE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V4_ICMP_CODE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_OUTBOUND_TRANSPORT_V6_
{
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_PROTOCOL,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_FLAGS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_MAX
} FWPS_FIELDS_OUTBOUND_TRANSPORT_V6;

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V6_ICMP_TYPE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V6_ICMP_CODE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_STREAM_V4_
{
   FWPS_FIELD_STREAM_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_STREAM_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_STREAM_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_STREAM_V4_IP_LOCAL_PORT,
   FWPS_FIELD_STREAM_V4_IP_REMOTE_PORT,
   FWPS_FIELD_STREAM_V4_DIRECTION,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_STREAM_V4_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)         
   FWPS_FIELD_STREAM_V4_MAX
} FWPS_FIELDS_STREAM_V4;

typedef enum FWPS_FIELDS_STREAM_V6_
{
   FWPS_FIELD_STREAM_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_STREAM_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_STREAM_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_STREAM_V6_IP_LOCAL_PORT,
   FWPS_FIELD_STREAM_V6_IP_REMOTE_PORT,
   FWPS_FIELD_STREAM_V6_DIRECTION,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_STREAM_V6_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)    
   FWPS_FIELD_STREAM_V6_MAX
} FWPS_FIELDS_STREAM_V6;

typedef enum FWPS_FIELDS_DATAGRAM_DATA_V4_
{
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_PROTOCOL,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_REMOTE_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_DATAGRAM_DATA_V4_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V4_DIRECTION,
   FWPS_FIELD_DATAGRAM_DATA_V4_FLAGS,
   FWPS_FIELD_DATAGRAM_DATA_V4_INTERFACE_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V4_TUNNEL_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V4_MAX
} FWPS_FIELDS_DATAGRAM_DATA_V4;

#define FWPS_FIELD_DATAGRAM_DATA_V4_ICMP_TYPE \
        FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_PORT

#define FWPS_FIELD_DATAGRAM_DATA_V4_ICMP_CODE \
        FWPS_FIELD_DATAGRAM_DATA_V4_IP_REMOTE_PORT


typedef enum FWPS_FIELDS_DATAGRAM_DATA_V6_
{
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_PROTOCOL,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_REMOTE_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_DATAGRAM_DATA_V6_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V6_DIRECTION,
   FWPS_FIELD_DATAGRAM_DATA_V6_FLAGS,
   FWPS_FIELD_DATAGRAM_DATA_V6_INTERFACE_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V6_TUNNEL_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V6_MAX
} FWPS_FIELDS_DATAGRAM_DATA_V6;

#define FWPS_FIELD_DATAGRAM_DATA_V6_ICMP_TYPE \
        FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_PORT

#define FWPS_FIELD_DATAGRAM_DATA_V6_ICMP_CODE \
        FWPS_FIELD_DATAGRAM_DATA_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_INBOUND_ICMP_ERROR_V4_
{
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_PROTOCOL,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_LOCAL_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_REMOTE_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ICMP_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ICMP_CODE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_INDEX,      // of local/delivery interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_SUB_INTERFACE_INDEX,  // of arrival interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_TYPE,       // of local/delivery interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_TUNNEL_TYPE,          // of local/delivery interface
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_ARRIVAL_INTERFACE,   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ARRIVAL_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ARRIVAL_INTERFACE_TYPE,   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ARRIVAL_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_MAX
} FWPS_FIELDS_INBOUND_ICMP_ERROR_V4;

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V4_LOCAL_INTERFACE_INDEX \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_INDEX

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V4_SUB_INTERFACE_INDEX

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V4_LOCAL_INTERFACE_TYPE \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_TYPE

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V4_LOCAL_TUNNEL_TYPE \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V4_TUNNEL_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

typedef enum FWPS_FIELDS_INBOUND_ICMP_ERROR_V6_
{
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_PROTOCOL,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_LOCAL_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_REMOTE_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ICMP_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ICMP_CODE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_INDEX,      // of local/delivery interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_SUB_INTERFACE_INDEX,  // of arrival interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_TYPE,       // of local/delivery interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_TUNNEL_TYPE,          // of local/delivery interface
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_ARRIVAL_INTERFACE,   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ARRIVAL_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ARRIVAL_INTERFACE_TYPE,   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ARRIVAL_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_MAX
} FWPS_FIELDS_INBOUND_ICMP_ERROR_V6;

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)   

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V6_LOCAL_INTERFACE_INDEX \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_INDEX

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V6_SUB_INTERFACE_INDEX

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V6_LOCAL_INTERFACE_TYPE \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_TYPE

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V6_LOCAL_TUNNEL_TYPE \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V6_TUNNEL_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

typedef enum FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V4_
{
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_ICMP_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_ICMP_CODE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_MAX
} FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V4;

typedef enum FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V6_
{
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_PORT,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_REMOTE_PORT,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_MAX
} FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V6;

#define FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_ICMP_TYPE \
        FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_PORT

#define FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_ICMP_CODE \
        FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V4_
{
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_ALE_PROMISCUOUS_MODE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_FLAGS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_TUNNEL_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_MAX
} FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V4;

typedef enum FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V6_
{
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_ALE_PROMISCUOUS_MODE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_FLAGS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_TUNNEL_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_MAX
} FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V6;

typedef enum FWPS_FIELDS_ALE_AUTH_LISTEN_V4_
{
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_FLAGS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_MAX
} FWPS_FIELDS_ALE_AUTH_LISTEN_V4;

typedef enum FWPS_FIELDS_ALE_AUTH_LISTEN_V6_
{
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_FLAGS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_MAX
} FWPS_FIELDS_ALE_AUTH_LISTEN_V6;

typedef enum FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V4_
{
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_FLAGS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_SIO_FIREWALL_SYSTEM_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_NAP_CONTEXT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_TYPE,      // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_TUNNEL_TYPE,         // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_INDEX,     // of local/delivery interface   
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_SUB_INTERFACE_INDEX, // of arrival interface
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_ARRIVAL_INTERFACE,   
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ARRIVAL_INTERFACE_TYPE,   
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ARRIVAL_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ARRIVAL_INTERFACE_INDEX,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_MAX
} FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V4;

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_PORT
        
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_LOCAL_INTERFACE_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_TYPE
        
#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_LOCAL_TUNNEL_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_TUNNEL_TYPE
        
#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_LOCAL_INTERFACE_INDEX \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_INDEX        

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_SUB_INTERFACE_INDEX        

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

typedef enum FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V6_
{
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_FLAGS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_SIO_FIREWALL_SYSTEM_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_NAP_CONTEXT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_TYPE,      // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_TUNNEL_TYPE,         // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_INDEX,     // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_SUB_INTERFACE_INDEX, // of arrival interface
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_ARRIVAL_INTERFACE,    
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ARRIVAL_INTERFACE_TYPE,   
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ARRIVAL_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ARRIVAL_INTERFACE_INDEX,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_MAX
} FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V6;

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_PORT
        
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_LOCAL_INTERFACE_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_TYPE
        
#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_LOCAL_TUNNEL_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_TUNNEL_TYPE

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_LOCAL_INTERFACE_INDEX \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_INDEX
        
#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_SUB_INTERFACE_INDEX        

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

typedef enum FWPS_FIELDS_ALE_AUTH_CONNECT_V4_
{
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_FLAGS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_INTERFACE_INDEX,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_SUB_INTERFACE_INDEX,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_MAX
} FWPS_FIELDS_ALE_AUTH_CONNECT_V4;

#define FWPS_FIELD_ALE_AUTH_CONNECT_V4_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_CONNECT_V4_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_AUTH_CONNECT_V6_
{
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_FLAGS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_INTERFACE_INDEX,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_SUB_INTERFACE_INDEX,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_MAX
} FWPS_FIELDS_ALE_AUTH_CONNECT_V6;

#define FWPS_FIELD_ALE_AUTH_CONNECT_V6_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_CONNECT_V6_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V4_
{
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_DIRECTION,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)   
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_MAX
} FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V4;

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ICMP_TYPE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ICMP_CODE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V6_
{
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_DIRECTION,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)      
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_MAX
} FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V6;

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ICMP_TYPE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ICMP_CODE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_IPSEC_KM_DEMUX_V4_
{
   FWPS_FIELD_IPSEC_KM_DEMUX_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V4_MAX
} FWPS_FIELDS_IPSEC_KM_DEMUX_V4;

typedef enum FWPS_FIELDS_IPSEC_KM_DEMUX_V6_
{
   FWPS_FIELD_IPSEC_KM_DEMUX_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V6_MAX
} FWPS_FIELDS_IPSEC_KM_DEMUX_V6;

typedef enum FWPS_FIELDS_IPSEC_V4_
{
   FWPS_FIELD_IPSEC_V4_IP_PROTOCOL,
   FWPS_FIELD_IPSEC_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_V4_IP_LOCAL_PORT,
   FWPS_FIELD_IPSEC_V4_IP_REMOTE_PORT,
   FWPS_FIELD_IPSEC_V4_MAX
} FWPS_FIELDS_IPSEC_V4;

typedef enum FWPS_FIELDS_IPSEC_V6_
{
   FWPS_FIELD_IPSEC_V6_IP_PROTOCOL,
   FWPS_FIELD_IPSEC_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_V6_IP_LOCAL_PORT,
   FWPS_FIELD_IPSEC_V6_IP_REMOTE_PORT,
   FWPS_FIELD_IPSEC_V6_MAX
} FWPS_FIELDS_IPSEC_V6;

typedef enum FWPS_FIELDS_IKEEXT_V4_
{
   FWPS_FIELD_IKEEXT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IKEEXT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IKEEXT_V4_MAX
} FWPS_FIELDS_IKEEXT_V4;

typedef enum FWPS_FIELDS_IKEEXT_V6_
{
   FWPS_FIELD_IKEEXT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IKEEXT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IKEEXT_V6_MAX
} FWPS_FIELDS_IKEEXT_V6;

typedef enum FWPS_FIELDS_RPC_UM_
{
   FWPS_FIELD_RPC_UM_REMOTE_USER_TOKEN,
   FWPS_FIELD_RPC_UM_IF_UUID,
   FWPS_FIELD_RPC_UM_IF_VERSION,
   FWPS_FIELD_RPC_UM_IF_FLAG,
   FWPS_FIELD_RPC_UM_DCOM_APP_ID,
   FWPS_FIELD_RPC_UM_IMAGE_NAME,
   FWPS_FIELD_RPC_UM_PROTOCOL,
   FWPS_FIELD_RPC_UM_AUTH_TYPE,
   FWPS_FIELD_RPC_UM_AUTH_LEVEL,
   FWPS_FIELD_RPC_UM_SEC_ENCRYPT_ALGORITHM,
   FWPS_FIELD_RPC_UM_SEC_KEY_SIZE,
   FWPS_FIELD_RPC_UM_LOCAL_ADDR_V4,
   FWPS_FIELD_RPC_UM_LOCAL_ADDR_V6,
   FWPS_FIELD_RPC_UM_LOCAL_PORT,
   FWPS_FIELD_RPC_UM_PIPE,
   FWPS_FIELD_RPC_UM_REMOTE_ADDR_V4,
   FWPS_FIELD_RPC_UM_REMOTE_ADDR_V6,
   FWPS_FIELD_RPC_UM_MAX
} FWPS_FIELDS_RPC_UM;

typedef enum FWPS_FIELDS_RPC_EPMAP_
{
   FWPS_FIELD_RPC_EPMAP_REMOTE_USER_TOKEN,
   FWPS_FIELD_RPC_EPMAP_IF_UUID,
   FWPS_FIELD_RPC_EPMAP_IF_VERSION,
   FWPS_FIELD_RPC_EPMAP_PROTOCOL,
   FWPS_FIELD_RPC_EPMAP_AUTH_TYPE,
   FWPS_FIELD_RPC_EPMAP_AUTH_LEVEL,
   FWPS_FIELD_RPC_EPMAP_SEC_ENCRYPT_ALGORITHM,
   FWPS_FIELD_RPC_EPMAP_SEC_KEY_SIZE,
   FWPS_FIELD_RPC_EPMAP_LOCAL_ADDR_V4,
   FWPS_FIELD_RPC_EPMAP_LOCAL_ADDR_V6,
   FWPS_FIELD_RPC_EPMAP_LOCAL_PORT,
   FWPS_FIELD_RPC_EPMAP_PIPE,
   FWPS_FIELD_RPC_EPMAP_REMOTE_ADDR_V4,
   FWPS_FIELD_RPC_EPMAP_REMOTE_ADDR_V6,
   FWPS_FIELD_RPC_EPMAP_MAX
} FWPS_FIELDS_RPC_EPMAP;

typedef enum FWPS_FIELDS_RPC_EP_ADD_
{
   FWPS_FIELD_RPC_EP_ADD_PROCESS_WITH_RPC_IF_UUID,
   FWPS_FIELD_RPC_EP_ADD_PROTOCOL,
   FWPS_FIELD_RPC_EP_ADD_EP_VALUE,
   FWPS_FIELD_RPC_EP_ADD_EP_FLAGS,
   FWPS_FIELD_RPC_EP_ADD_MAX
} FWPS_FIELDS_RPC_EP_ADD;

typedef enum FWPS_FIELDS_RPC_PROXY_CONN_
{
   FWPS_FIELD_RPC_PROXY_CONN_CLIENT_TOKEN,
   FWPS_FIELD_RPC_PROXY_CONN_SERVER_NAME,
   FWPS_FIELD_RPC_PROXY_CONN_SERVER_PORT,
   FWPS_FIELD_RPC_PROXY_CONN_PROXY_AUTH_TYPE,
   FWPS_FIELD_RPC_PROXY_CONN_CLIENT_CERT_KEY_LENGTH,
   FWPS_FIELD_RPC_PROXY_CONN_CLIENT_CERT_OID,
   FWPS_FIELD_RPC_PROXY_CONN_MAX
} FWPS_FIELDS_RPC_PROXY_CONN;

typedef enum FWPS_FIELDS_RPC_PROXY_IF_
{
   FWPS_FIELD_RPC_PROXY_IF_CLIENT_TOKEN,
   FWPS_FIELD_RPC_PROXY_IF_IF_UUID,
   FWPS_FIELD_RPC_PROXY_IF_IF_VERSION,
   FWPS_FIELD_RPC_PROXY_IF_SERVER_NAME,
   FWPS_FIELD_RPC_PROXY_IF_SERVER_PORT,
   FWPS_FIELD_RPC_PROXY_IF_PROXY_AUTH_TYPE,
   FWPS_FIELD_RPC_PROXY_IF_CLIENT_CERT_KEY_LENGTH,
   FWPS_FIELD_RPC_PROXY_IF_CLIENT_CERT_OID,
   FWPS_FIELD_RPC_PROXY_IF_MAX
} FWPS_FIELDS_RPC_PROXY_IF_IF;

///////////////////////////////////////////////////////////////////////////////
//
// Network and transport discard reasons.
//
///////////////////////////////////////////////////////////////////////////////

//
// INET_DISCARD_REASON
//
// Define the reasons given by INET modules for discarding incoming datagrams.
//

#ifndef _INET_DISCARD_REASON_DEFINE_
#define _INET_DISCARD_REASON_DEFINE_

typedef enum {
    InetDiscardSourceUnspecified,
    InetDiscardDestinationMulticast,
    InetDiscardHeaderInvalid,
    InetDiscardChecksumInvalid,
    InetDiscardEndpointNotFound
} INET_DISCARD_REASON, *PINET_DISCARD_REASON;

#endif


#ifndef _IP_DISCARD_REASON_DEFINE_
#define _IP_DISCARD_REASON_DEFINE_

typedef enum {
    //
    // Receive path discard reasons.
    //
    IpDiscardBadSourceAddress = 1,
    IpDiscardNotLocallyDestined,
    IpDiscardProtocolUnreachable,
    IpDiscardPortUnreachable,
    IpDiscardBadLength,
    IpDiscardMalformedHeader,
    IpDiscardNoRoute,
    IpDiscardBeyondScope,
    IpDiscardInspectionDrop,  // Blocked by firewall, ICMP should not be sent.
    IpDiscardTooManyDecapsulations,
    IpDiscardAdministrativelyProhibited, // Blocked, ICMP should be sent.

    IpDiscardReceivePathMax = 127,

    //
    // Forward path discard reasons.
    //
    IpDiscardHopLimitExceeded,
    IpDiscardAddressUnreachable,
    IpDiscardForwardPathMax = 255,

    //
    // Internally used discard reasons.
    //
    IpDiscardArbitrationUnhandled,
    IpDiscardMax
} IP_DISCARD_REASON, *PIP_DISCARD_REASON;

#endif




///////////////////////////////////////////////////////////////////////////////
//
// API for implementing a callout.
//
///////////////////////////////////////////////////////////////////////////////

//////////
// Flags that can specified which entries are present
// in the FWPS_INCOMING_METADATA_VALUES0 structure.
//////////

#define FWPS_METADATA_FIELD_DISCARD_REASON                   0x00000001
#define FWPS_METADATA_FIELD_FLOW_HANDLE                      0x00000002
#define FWPS_METADATA_FIELD_IP_HEADER_SIZE                   0x00000004
#define FWPS_METADATA_FIELD_PROCESS_PATH                     0x00000008
#define FWPS_METADATA_FIELD_TOKEN                            0x00000010
#define FWPS_METADATA_FIELD_PROCESS_ID                       0x00000020
#define FWPS_METADATA_FIELD_SYSTEM_FLAGS                     0x00000040
#define FWPS_METADATA_FIELD_RESERVED                         0x00000080
#define FWPS_METADATA_FIELD_SOURCE_INTERFACE_INDEX           0x00000100
#define FWPS_METADATA_FIELD_DESTINATION_INTERFACE_INDEX      0x00000200
#define FWPS_METADATA_FIELD_TRANSPORT_HEADER_SIZE            0x00000400
#define FWPS_METADATA_FIELD_COMPARTMENT_ID                   0x00000800
#define FWPS_METADATA_FIELD_FRAGMENT_DATA                    0x00001000
#define FWPS_METADATA_FIELD_PATH_MTU                         0x00002000
#define FWPS_METADATA_FIELD_COMPLETION_HANDLE                0x00004000
#define FWPS_METADATA_FIELD_TRANSPORT_ENDPOINT_HANDLE        0x00008000
#define FWPS_METADATA_FIELD_TRANSPORT_CONTROL_DATA           0x00010000
#define FWPS_METADATA_FIELD_REMOTE_SCOPE_ID                  0x00020000
#define FWPS_METADATA_FIELD_PACKET_DIRECTION                 0x00040000
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
#define FWPS_METADATA_FIELD_PACKET_SYSTEM_CRITICAL           0x00080000
#define FWPS_METADATA_FIELD_FORWARD_LAYER_OUTBOUND_PASS_THRU 0x00100000
#define FWPS_METADATA_FIELD_FORWARD_LAYER_INBOUND_PASS_THRU  0x00200000
#define FWPS_METADATA_FIELD_ALE_CLASSIFY_REQUIRED            0x00400000
#define FWPS_METADATA_FIELD_TRANSPORT_HEADER_INCLUDE_HEADER  0x00800000
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// Provides additional meta-information to the filter engine. This information
// is not processed by the filter engine, but is supplied to the callouts.
// Unlike the FWPS_INCOMING_VALUES0, the schema of the meta-information is not
// fixed. Callouts should not assume that a given FWPS_METADATA_FIELD is
// present or that it is located at a given index in the array.

typedef struct FWPS_INCOMING_METADATA_VALUES0_
{
   // Bitmask representing which values are set.
   UINT32 currentMetadataValues;
   // Internal flags;
   UINT32 flags;
   // Reserved for system use.
   UINT64 reserved;
   // Discard module and reason.
   FWPS_DISCARD_METADATA0 discardMetadata;
   // Flow Handle.
   UINT64 flowHandle;
   // IP Header size.
   UINT32 ipHeaderSize;
   // Transport Header size
   UINT32 transportHeaderSize;
   // Process Path.
   FWP_BYTE_BLOB* processPath;
   // Token used for authorization.
   UINT64 token;
   // Process Id.
   UINT64 processId;
   // Source and Destination interface indices for discard indications.
   UINT32 sourceInterfaceIndex;
   UINT32 destinationInterfaceIndex;
   // Compartment Id for injection APIs.
   ULONG compartmentId;
   // Fragment data for inbound fragments.
   FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;
   // Path MTU for outbound packets (to enable calculation of fragments).
   ULONG pathMtu;
   // Completion handle (required in order to be able to pend at this layer).
   HANDLE completionHandle;
   // Endpoint handle for use in outbound transport layer injection.
   UINT64 transportEndpointHandle;
   // Remote scope id for use in outbound transport layer injection.
   SCOPE_ID remoteScopeId;
   // Socket control data (and length) for use in outbound transport layer injection.
   WSACMSGHDR* controlData;
   ULONG controlDataLength;
   // Direction for the current packet. Only specified for ALE re-authorization.
   FWP_DIRECTION packetDirection;
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   // Raw IP header (and length) if the packet is sent with IP header from a RAW socket.
   PVOID headerIncludeHeader;
   ULONG headerIncludeHeaderLength;
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
} FWPS_INCOMING_METADATA_VALUES0;

///////////////////////////////////////////////////////////////////////////////
//
// Macro for checking for metadata fields
//
///////////////////////////////////////////////////////////////////////////////

#define FWPS_IS_METADATA_FIELD_PRESENT(metadataValues, metadataField) \
   (((metadataValues)->currentMetadataValues & (metadataField)) == (metadataField))

// Invoked during classification when a callout filter matches.
typedef void (NTAPI *FWPS_CALLOUT_CLASSIFY_FN0)(
                        IN const FWPS_INCOMING_VALUES0* inFixedValues,
                        IN const FWPS_INCOMING_METADATA_VALUES0* inMetaValues,
                        IN OUT void* layerData,
                        IN const FWPS_FILTER0* filter,
                        IN UINT64 flowContext,
                        OUT FWPS_CLASSIFY_OUT0* classifyOut
                        );

// Notifies the callout that a filter invoking it has been added/deleted.
typedef NTSTATUS (NTAPI *FWPS_CALLOUT_NOTIFY_FN0)(
                            IN FWPS_CALLOUT_NOTIFY_TYPE notifyType,
                            IN const GUID* filterKey,
                            IN OUT FWPS_FILTER0* filter
                            );

// Notifies the callout that a flow has been deleted.
typedef void (NTAPI *FWPS_CALLOUT_FLOW_DELETE_NOTIFY_FN0)(
                        IN UINT16 layerId,
                        IN UINT32 calloutId,
                        IN UINT64 flowContext
                        );

// Notify callout that boottime callout has been removed
typedef void (NTAPI *FWPS_CALLOUT_BOOTTIME_CALLOUT_DELETE_NOTIFY_FN0)(
                        IN UINT32 calloutId
                        );



// Run-time state necessary to invoke a callout.
typedef struct FWPS_CALLOUT0_
{
   // Uniquely identifies the callout. This must be the same GUID supplied to
   // FwpmCalloutAdd0.
   GUID calloutKey;
   // Flags
   UINT32 flags;
   // Pointer to the classification function.
   FWPS_CALLOUT_CLASSIFY_FN0 classifyFn;
   // Pointer to the notification function.
   FWPS_CALLOUT_NOTIFY_FN0 notifyFn;
   // Pointer to the flow delete function.
   FWPS_CALLOUT_FLOW_DELETE_NOTIFY_FN0 flowDeleteFn;
} FWPS_CALLOUT0;

// Register the function pointers for a callout.  The callout driver must call
// FwpsCalloutUnregisterById0 before unloading.
NTSTATUS
NTAPI
FwpsCalloutRegister0(
   IN OUT void* deviceObject,
   IN const FWPS_CALLOUT0* callout,
   OUT OPTIONAL UINT32* calloutId
   );

NTSTATUS
NTAPI
FwpsCalloutUnregisterById0(IN const UINT32 calloutId);

NTSTATUS
NTAPI
FwpsCalloutUnregisterByKey0(IN const GUID* calloutKey);

// Allows a callout to associate an opaque flowContext with a flow.
NTSTATUS
NTAPI
FwpsFlowAssociateContext0(
   IN UINT64 flowId,
   IN UINT16 layerId,
   IN UINT32 calloutId,
   IN UINT64 flowContext
   );

// Remote a flow context added with FwpsFlowAssociateContext0.
NTSTATUS
NTAPI
FwpsFlowRemoveContext0(
   IN UINT64 flowId,
   IN UINT16 layerId,
   IN UINT32 calloutId
   );

///////////////////////////////////////////////////////////////////////////////
//
// Declarations for Packet List Information.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct FWPS_PACKET_LIST_INBOUND_IPSEC_INFORMATION0_
{
   unsigned isSecure:1;
   unsigned isTransportMode:1;
   unsigned isTunnelMode:1;
   unsigned isTransportModeVerified:1;
   unsigned isTunnelModeVerified:1;
   unsigned isDeTunneled:1;
}FWPS_PACKET_LIST_INBOUND_IPSEC_INFORMATION0;

typedef struct FWPS_PACKET_LIST_OUTBOUND_IPSEC_INFORMATION0_
{
   unsigned isIPsecPolicyMatch:1;
   unsigned isTransportPolicyMatch:1;
   unsigned isTunnelPolicyMatch:1;
   unsigned isTunnelIPinIP:1;
}FWPS_PACKET_LIST_OUTBOUND_IPSEC_INFORMATION0;

typedef struct FWPS_PACKET_LIST_IPSEC_INFORMATION0_
{
   union
   {
      FWPS_PACKET_LIST_INBOUND_IPSEC_INFORMATION0 inbound;
      FWPS_PACKET_LIST_OUTBOUND_IPSEC_INFORMATION0 outbound;
      UINT32 flags;
   };
} FWPS_PACKET_LIST_IPSEC_INFORMATION0;


typedef struct FWPS_PACKET_LIST_FWP_INFORMATION0_
{
   unsigned isReinjected:1;
} FWPS_PACKET_LIST_FWP_INFORMATION0;

#define FWPS_PACKET_LIST_INFORMATION_QUERY_INBOUND  0x00000001
#define FWPS_PACKET_LIST_INFORMATION_QUERY_OUTBOUND 0x00000002
#define FWPS_PACKET_LIST_INFORMATION_QUERY_IPSEC    0x00000004
#define FWPS_PACKET_LIST_INFORMATION_QUERY_FWP      0x00000008
#define FWPS_PACKET_LIST_INFORMATION_QUERY_ALL_INBOUND       0xfffffffd
#define FWPS_PACKET_LIST_INFORMATION_QUERY_ALL_OUTBOUND       0xfffffffe
#define FWPS_PACKET_LIST_INFORMATION_QUERY_INVALID_MASK     0x00000003


typedef struct FWPS_PACKET_LIST_INFORMATION0_
{
   FWPS_PACKET_LIST_IPSEC_INFORMATION0 ipsecInformation;
   FWPS_PACKET_LIST_FWP_INFORMATION0 fwpInformation;
} FWPS_PACKET_LIST_INFORMATION0;


NTSTATUS
NTAPI
FwpsGetPacketListSecurityInformation0(
   IN NET_BUFFER_LIST* packetList,
   IN UINT32 queryFlags,
   IN OUT FWPS_PACKET_LIST_INFORMATION0*  packetInformation
   );

///////////////////////////////////////////////////////////////////////////////
//
// Pend APIs for ALE layers.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpsPendOperation0(
   IN HANDLE completionHandle,
   OUT HANDLE* completionContext
   );

void
NTAPI
FwpsCompleteOperation0(
   IN HANDLE completionContext,
   IN PNET_BUFFER_LIST netBufferList
   );

///////////////////////////////////////////////////////////////////////////////
//
// Functions for setting Classify Options
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpsClassifyOptionSet0(
   IN const FWPS_INCOMING_METADATA_VALUES0* inMetadataValues,
   IN const FWP_CLASSIFY_OPTION_TYPE option,
   IN const FWP_VALUE0* newValue
   );

///////////////////////////////////////////////////////////////////////////////
//
// Packet injection API.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct FWPS_TRANSPORT_SEND_PARAMS0_
{
   UCHAR* remoteAddress;
   SCOPE_ID remoteScopeId;
   WSACMSGHDR* controlData OPTIONAL;
   ULONG controlDataLength OPTIONAL;
} FWPS_TRANSPORT_SEND_PARAMS0;

#define FWPS_INJECTION_TYPE_STREAM     0x00000001
#define FWPS_INJECTION_TYPE_TRANSPORT  0x00000002
#define FWPS_INJECTION_TYPE_NETWORK    0x00000004
#define FWPS_INJECTION_TYPE_FORWARD    0x00000008

NTSTATUS
NTAPI
FwpsInjectionHandleCreate0(
   IN OPTIONAL ADDRESS_FAMILY addressFamily,
   IN UINT32 flags,
   OUT HANDLE* injectionHandle
   );

NTSTATUS
NTAPI
FwpsInjectionHandleDestroy0(IN HANDLE injectionHandle);

typedef void (NTAPI *FWPS_INJECT_COMPLETE0)(
                        IN void* context,
                        IN OUT NET_BUFFER_LIST* netBufferList,
                        IN BOOLEAN dispatchLevel
                        );

NTSTATUS
NTAPI
FwpsAllocateNetBufferAndNetBufferList0(
   IN NDIS_HANDLE poolHandle,
   IN USHORT contextSize,
   IN USHORT contextBackFill,
   IN OPTIONAL MDL* mdlChain,
   IN ULONG dataOffset,
   IN SIZE_T dataLength,
   OUT NET_BUFFER_LIST** netBufferList
   );

void
NTAPI
FwpsFreeNetBufferList0(
   IN OUT NET_BUFFER_LIST* netBufferList
   );

NTSTATUS
NTAPI
FwpsAllocateCloneNetBufferList0(
   IN OUT NET_BUFFER_LIST* originalNetBufferList,
   IN OPTIONAL NDIS_HANDLE netBufferListPoolHandle,
   IN OPTIONAL NDIS_HANDLE netBufferPoolHandle,
   IN ULONG allocateCloneFlags,
   OUT NET_BUFFER_LIST** netBufferList
   );

void
NTAPI
FwpsFreeCloneNetBufferList0(
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN ULONG freeCloneFlags
   );

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

NTSTATUS
NTAPI
FwpsReassembleForwardFragmentGroup0(
   IN ADDRESS_FAMILY addressFamily,
   IN OUT NET_BUFFER_LIST* fragmentGroupNblChain,
   IN NDIS_HANDLE netBufferAndNetBufferListPoolHandle OPTIONAL,
   IN ULONG dataBackFill,
   IN ULONG flags,
   OUT NET_BUFFER_LIST** reassembledNbl
   );

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

NTSTATUS
NTAPI
FwpsInjectNetworkSendAsync0(
   IN HANDLE injectionHandle,
   IN OPTIONAL HANDLE injectionContext,
   IN UINT32 flags,
   IN COMPARTMENT_ID compartmentId,
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN FWPS_INJECT_COMPLETE0 completionFn,
   IN OPTIONAL HANDLE completionContext
   );

NTSTATUS
NTAPI
FwpsInjectForwardAsync0(
   IN HANDLE injectionHandle,
   IN OPTIONAL HANDLE injectionContext,
   IN UINT32 flags,
   IN ADDRESS_FAMILY addressFamily,
   IN COMPARTMENT_ID compartmentId,
   IN IF_INDEX interfaceIndex,
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN FWPS_INJECT_COMPLETE0 completionFn,
   IN OPTIONAL HANDLE completionContext
   );

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

NTSTATUS
NTAPI
FwpsConstructIpHeaderForTransportPacket0(
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN ULONG headerIncludeHeaderLength,
   IN ADDRESS_FAMILY addressFamily,
   IN const UCHAR* sourceAddress,
   IN const UCHAR* remoteAddress,
   IN IPPROTO nextProtocol,
   IN UINT64 endpointHandle OPTIONAL,
   IN const WSACMSGHDR* controlData OPTIONAL,
   IN ULONG controlDataLength,
   IN UINT32 flags,
   IN PVOID reserved,
   IN IF_INDEX interfaceIndex OPTIONAL,
   IN IF_INDEX subInterfaceIndex  OPTIONAL
   );

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

NTSTATUS
NTAPI
FwpsInjectTransportSendAsync0(
   IN HANDLE injectionHandle,
   IN OPTIONAL HANDLE injectionContext,
   IN UINT64 endpointHandle,
   IN UINT32 flags,
   IN OPTIONAL FWPS_TRANSPORT_SEND_PARAMS0* sendArgs,
   IN ADDRESS_FAMILY addressFamily,
   IN COMPARTMENT_ID compartmentId,
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN FWPS_INJECT_COMPLETE0 completionFn,
   IN OPTIONAL HANDLE completionContext
   );

NTSTATUS
NTAPI
FwpsInjectTransportReceiveAsync0(
   IN HANDLE injectionHandle,
   IN OPTIONAL HANDLE injectionContext,
   IN PVOID reserved,
   IN UINT32 flags,
   IN ADDRESS_FAMILY addressFamily,
   IN COMPARTMENT_ID compartmentId,
   IN IF_INDEX interfaceIndex,
   IN IF_INDEX subInterfaceIndex,
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN FWPS_INJECT_COMPLETE0 completionFn,
   IN OPTIONAL HANDLE completionContext
   );

NTSTATUS
NTAPI
FwpsInjectNetworkReceiveAsync0(
   IN HANDLE injectionHandle,
   IN OPTIONAL HANDLE injectionContext,
   IN UINT32 flags,
   IN COMPARTMENT_ID compartmentId,
   IN IF_INDEX interfaceIndex,
   IN IF_INDEX subInterfaceIndex,
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN FWPS_INJECT_COMPLETE0 completionFn,
   IN OPTIONAL HANDLE completionContext
   );

void
NTAPI
FwpsReferenceNetBufferList0(
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN BOOLEAN intendToModify
   );

void
NTAPI
FwpsDereferenceNetBufferList0(
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN BOOLEAN dispatchLevel
   );

///////////////////////////////////////////////////////////////////////////////
//
// Packet injection state tracking API.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum FWPS_PACKET_INJECTION_STATE_
{
   // Packet was not injected by the FwpsInject* APIs.
   FWPS_PACKET_NOT_INJECTED,
   // Packet was injected by the calling injection handle.
   FWPS_PACKET_INJECTED_BY_SELF,
   // Packet was injected by a different injection handle.
   FWPS_PACKET_INJECTED_BY_OTHER,
   // Packet was injected by the calling injection handle but later
   // cloned and re-injected by other injector(s).
   FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF,
   FWPS_PACKET_INJECTION_STATE_MAX
} FWPS_PACKET_INJECTION_STATE;

FWPS_PACKET_INJECTION_STATE
NTAPI
FwpsQueryPacketInjectionState0(
   IN HANDLE injectionHandle,
   IN const NET_BUFFER_LIST* netBufferList,
   OUT OPTIONAL HANDLE* injectionContext
   );

///////////////////////////////////////////////////////////////////////////////
//
// API for stream processing.
//
///////////////////////////////////////////////////////////////////////////////


// The FWPS_STREAM_DATA_OFFSET0 specifies an offset into a data stream defined in
// an FWPS_STREAM_DATA0.  Generally, it is only necessary to know the byte
// offset, however this means searching for the NET_BUFFER_LIST, NET_BUFFER, MDL
// and offset into the MDL to find the byte of interest. FWPS_STREAM_DATA_OFFSET0
// helps by keeping track of this information.  The netBufferList, netBuffer, mdl,
// and mdlOffset and offset combined give the location of the byte of interest.
// netBufferOffset and streamBufferOffset are used internally to optimize
// computations.

typedef struct FWPS_STREAM_DATA_OFFSET0_
{
   // NET_BUFFER_LIST in which offset lies.
   NET_BUFFER_LIST* netBufferList;
   // NET_BUFFER in which offset lies.
   NET_BUFFER* netBuffer;
   // MDL in which offset lies.
   MDL* mdl;
   // Byte offset from the beginning of the MDL in which data lies.
   UINT32 mdlOffset;
   // Offset relative to the DataOffset of the NET_BUFFER.
   UINT32 netBufferOffset;
   // Offset from the beginning of the entire stream buffer.
   SIZE_T streamDataOffset;
}  FWPS_STREAM_DATA_OFFSET0;

// Flags set on receives (inbound stream layer).
#define FWPS_STREAM_FLAG_RECEIVE                (0x00000001)
// Received TCP urgent data.
#define FWPS_STREAM_FLAG_RECEIVE_EXPEDITED      (0x00000002)
#define FWPS_STREAM_FLAG_RECEIVE_DISCONNECT     (0x00000004)
#define FWPS_STREAM_FLAG_RECEIVE_ABORT          (0x00000008)
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
#define FWPS_STREAM_FLAG_RECEIVE_PUSH           (0x00000010)
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// Flags set on sends (outbound stream layer).
#define FWPS_STREAM_FLAG_SEND                   (0x00010000)
#define FWPS_STREAM_FLAG_SEND_EXPEDITED         (0x00020000)
#define FWPS_STREAM_FLAG_SEND_NODELAY           (0x00040000)
#define FWPS_STREAM_FLAG_SEND_DISCONNECT        (0x00080000)
#define FWPS_STREAM_FLAG_SEND_ABORT             (0x00100000)

// FWPS_STREAM_DATA0 is used to store a section of the stream and provide it
// to a callout for processing.
typedef struct FWPS_STREAM_DATA0_
{
   UINT32 flags;
   FWPS_STREAM_DATA_OFFSET0 dataOffset;
   SIZE_T dataLength;

   NET_BUFFER_LIST* netBufferListChain;
}FWPS_STREAM_DATA0;

typedef enum FWPS_STREAM_ACTION_TYPE_
{
   FWPS_STREAM_ACTION_NONE,
   FWPS_STREAM_ACTION_NEED_MORE_DATA,
   FWPS_STREAM_ACTION_DROP_CONNECTION,
   FWPS_STREAM_ACTION_DEFER,
   FWPS_STREAM_ACTION_TYPE_MAX
} FWPS_STREAM_ACTION_TYPE;

typedef struct FWPS_STREAM_CALLOUT_IO_PACKET0_
{
   IN FWPS_STREAM_DATA0* streamData;
   IN SIZE_T missedBytes;
   OUT UINT32 countBytesRequired;
   OUT SIZE_T countBytesEnforced;
   OUT FWPS_STREAM_ACTION_TYPE streamAction;
} FWPS_STREAM_CALLOUT_IO_PACKET0;

NTSTATUS
NTAPI
FwpsStreamInjectAsync0(
   IN HANDLE injectionHandle,
   IN OPTIONAL HANDLE injectionContext,
   IN UINT32 flags,
   IN UINT64 flowId,
   IN UINT32 calloutId,
   IN UINT16 layerId,
   IN UINT32 streamFlags,
   IN OUT OPTIONAL NET_BUFFER_LIST* netBufferList,
   IN SIZE_T dataLength,
   IN FWPS_INJECT_COMPLETE0 completionFn,
   IN OPTIONAL HANDLE completionContext
   );

NTSTATUS
NTAPI
FwpsStreamContinue0(
    IN UINT64 flowId,
    IN UINT32 calloutId,
    IN UINT16 layerId,
    IN UINT32 streamFlags
    );

void
NTAPI
FwpsCopyStreamDataToBuffer0(
         IN const FWPS_STREAM_DATA0* calloutStreamData,
         IN OUT PVOID buffer,
         IN SIZE_T bytesToCopy,
         OUT SIZE_T* bytesCopied
         );

NTSTATUS
NTAPI
FwpsCloneStreamData0(
   IN OUT FWPS_STREAM_DATA0* calloutStreamData,
   IN OPTIONAL NDIS_HANDLE netBufferListPoolHandle,
   IN OPTIONAL NDIS_HANDLE netBufferPoolHandle,
   IN ULONG allocateCloneFlags,
   OUT NET_BUFFER_LIST** netBufferListChain
   );

void
NTAPI
FwpsDiscardClonedStreamData0(
   IN OUT NET_BUFFER_LIST* netBufferListChain,
   IN UINT32 allocateCloneFlags,
   IN BOOLEAN dispatchLevel
   );

#ifdef __cplusplus
}
#endif
#endif // (NTDDI_VERSION >= NTDDI_WIN6)
#endif // FWPSX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\fxsutility.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

Module Name:

    FxsSnd.h

Abstract:

    This header file contains prototypes for "Send to Fax Recipient" functionality.

--*/

#ifndef _FXS_UTILITY_H_
#define _FXS_UTILITY_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
	  SEND_TO_FAX_RECIPIENT_ATTACHMENT
} SendToMode;

BOOL WINAPI CanSendToFaxRecipient();
DWORD WINAPI SendToFaxRecipient(SendToMode sndMode, LPCWSTR lpFileName);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\fwpmk.h ===
/*
   Copyright (c) Microsoft Corporation

   SYNOPSIS

     Declares the management portion of the FWP API.
*/

#if (NTDDI_VERSION >= NTDDI_WIN6)

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in layers.
//
///////////////////////////////////////////////////////////////////////////////

// c86fd1bf-21cd-497e-a0bb-17425c885c58
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V4,
   0xc86fd1bf,
   0x21cd,
   0x497e,
   0xa0, 0xbb, 0x17, 0x42, 0x5c, 0x88, 0x5c, 0x58
);

// b5a230d0-a8c0-44f2-916e-991b53ded1f7
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V4_DISCARD,
   0xb5a230d0,
   0xa8c0,
   0x44f2,
   0x91, 0x6e, 0x99, 0x1b, 0x53, 0xde, 0xd1, 0xf7
);

// f52032cb-991c-46e7-971d-2601459a91ca
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V6,
   0xf52032cb,
   0x991c,
   0x46e7,
   0x97, 0x1d, 0x26, 0x01, 0x45, 0x9a, 0x91, 0xca
);

// bb24c279-93b4-47a2-83ad-ae1698b50885
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V6_DISCARD,
   0xbb24c279,
   0x93b4,
   0x47a2,
   0x83, 0xad, 0xae, 0x16, 0x98, 0xb5, 0x08, 0x85
);

// 1e5c9fae-8a84-4135-a331-950b54229ecd
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V4,
   0x1e5c9fae,
   0x8a84,
   0x4135,
   0xa3, 0x31, 0x95, 0x0b, 0x54, 0x22, 0x9e, 0xcd
);

// 08e4bcb5-b647-48f3-953c-e5ddbd03937e
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V4_DISCARD,
   0x08e4bcb5,
   0xb647,
   0x48f3,
   0x95, 0x3c, 0xe5, 0xdd, 0xbd, 0x03, 0x93, 0x7e
);

// a3b3ab6b-3564-488c-9117-f34e82142763
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V6,
   0xa3b3ab6b,
   0x3564,
   0x488c,
   0x91, 0x17, 0xf3, 0x4e, 0x82, 0x14, 0x27, 0x63
);

// 9513d7c4-a934-49dc-91a7-6ccb80cc02e3
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V6_DISCARD,
   0x9513d7c4,
   0xa934,
   0x49dc,
   0x91, 0xa7, 0x6c, 0xcb, 0x80, 0xcc, 0x02, 0xe3
);

// a82acc24-4ee1-4ee1-b465-fd1d25cb10a4
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V4,
   0xa82acc24,
   0x4ee1,
   0x4ee1,
   0xb4, 0x65, 0xfd, 0x1d, 0x25, 0xcb, 0x10, 0xa4
);

// 9e9ea773-2fae-4210-8f17-34129ef369eb
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V4_DISCARD,
   0x9e9ea773,
   0x2fae,
   0x4210,
   0x8f, 0x17, 0x34, 0x12, 0x9e, 0xf3, 0x69, 0xeb
);

// 7b964818-19c7-493a-b71f-832c3684d28c
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V6,
   0x7b964818,
   0x19c7,
   0x493a,
   0xb7, 0x1f, 0x83, 0x2c, 0x36, 0x84, 0xd2, 0x8c
);

// 31524a5d-1dfe-472f-bb93-518ee945d8a2
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V6_DISCARD,
   0x31524a5d,
   0x1dfe,
   0x472f,
   0xbb, 0x93, 0x51, 0x8e, 0xe9, 0x45, 0xd8, 0xa2
);

// 5926dfc8-e3cf-4426-a283-dc393f5d0f9d
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V4,
   0x5926dfc8,
   0xe3cf,
   0x4426,
   0xa2, 0x83, 0xdc, 0x39, 0x3f, 0x5d, 0x0f, 0x9d
);

// ac4a9833-f69d-4648-b261-6dc84835ef39
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V4_DISCARD,
   0xac4a9833,
   0xf69d,
   0x4648,
   0xb2, 0x61, 0x6d, 0xc8, 0x48, 0x35, 0xef, 0x39
);

// 634a869f-fc23-4b90-b0c1-bf620a36ae6f
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V6,
   0x634a869f,
   0xfc23,
   0x4b90,
   0xb0, 0xc1, 0xbf, 0x62, 0x0a, 0x36, 0xae, 0x6f
);

// 2a6ff955-3b2b-49d2-9848-ad9d72dcaab7
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V6_DISCARD,
   0x2a6ff955,
   0x3b2b,
   0x49d2,
   0x98, 0x48, 0xad, 0x9d, 0x72, 0xdc, 0xaa, 0xb7
);

// 09e61aea-d214-46e2-9b21-b26b0b2f28c8
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V4,
   0x09e61aea,
   0xd214,
   0x46e2,
   0x9b, 0x21, 0xb2, 0x6b, 0x0b, 0x2f, 0x28, 0xc8
);

// c5f10551-bdb0-43d7-a313-50e211f4d68a
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V4_DISCARD,
   0xc5f10551,
   0xbdb0,
   0x43d7,
   0xa3, 0x13, 0x50, 0xe2, 0x11, 0xf4, 0xd6, 0x8a
);

// e1735bde-013f-4655-b351-a49e15762df0
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V6,
   0xe1735bde,
   0x013f,
   0x4655,
   0xb3, 0x51, 0xa4, 0x9e, 0x15, 0x76, 0x2d, 0xf0
);

// f433df69-ccbd-482e-b9b2-57165658c3b3
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V6_DISCARD,
   0xf433df69,
   0xccbd,
   0x482e,
   0xb9, 0xb2, 0x57, 0x16, 0x56, 0x58, 0xc3, 0xb3
);

// 3b89653c-c170-49e4-b1cd-e0eeeee19a3e
DEFINE_GUID(
   FWPM_LAYER_STREAM_V4,
   0x3b89653c,
   0xc170,
   0x49e4,
   0xb1, 0xcd, 0xe0, 0xee, 0xee, 0xe1, 0x9a, 0x3e
);

// 25c4c2c2-25ff-4352-82f9-c54a4a4726dc
DEFINE_GUID(
   FWPM_LAYER_STREAM_V4_DISCARD,
   0x25c4c2c2,
   0x25ff,
   0x4352,
   0x82, 0xf9, 0xc5, 0x4a, 0x4a, 0x47, 0x26, 0xdc
);

// 47c9137a-7ec4-46b3-b6e4-48e926b1eda4
DEFINE_GUID(
   FWPM_LAYER_STREAM_V6,
   0x47c9137a,
   0x7ec4,
   0x46b3,
   0xb6, 0xe4, 0x48, 0xe9, 0x26, 0xb1, 0xed, 0xa4
);

// 10a59fc7-b628-4c41-9eb8-cf37d55103cf
DEFINE_GUID(
   FWPM_LAYER_STREAM_V6_DISCARD,
   0x10a59fc7,
   0xb628,
   0x4c41,
   0x9e, 0xb8, 0xcf, 0x37, 0xd5, 0x51, 0x03, 0xcf
);

// 3d08bf4e-45f6-4930-a922-417098e20027
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V4,
   0x3d08bf4e,
   0x45f6,
   0x4930,
   0xa9, 0x22, 0x41, 0x70, 0x98, 0xe2, 0x00, 0x27
);

// 18e330c6-7248-4e52-aaab-472ed67704fd
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V4_DISCARD,
   0x18e330c6,
   0x7248,
   0x4e52,
   0xaa, 0xab, 0x47, 0x2e, 0xd6, 0x77, 0x04, 0xfd
);

// fa45fe2f-3cba-4427-87fc-57b9a4b10d00
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V6,
   0xfa45fe2f,
   0x3cba,
   0x4427,
   0x87, 0xfc, 0x57, 0xb9, 0xa4, 0xb1, 0x0d, 0x00
);

// 09d1dfe1-9b86-4a42-be9d-8c315b92a5d0
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V6_DISCARD,
   0x09d1dfe1,
   0x9b86,
   0x4a42,
   0xbe, 0x9d, 0x8c, 0x31, 0x5b, 0x92, 0xa5, 0xd0
);

// 61499990-3cb6-4e84-b950-53b94b6964f3
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V4,
   0x61499990,
   0x3cb6,
   0x4e84,
   0xb9, 0x50, 0x53, 0xb9, 0x4b, 0x69, 0x64, 0xf3
);

// a6b17075-ebaf-4053-a4e7-213c8121ede5
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V4_DISCARD,
   0xa6b17075,
   0xebaf,
   0x4053,
   0xa4, 0xe7, 0x21, 0x3c, 0x81, 0x21, 0xed, 0xe5
);

// 65f9bdff-3b2d-4e5d-b8c6-c720651fe898
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V6,
   0x65f9bdff,
   0x3b2d,
   0x4e5d,
   0xb8, 0xc6, 0xc7, 0x20, 0x65, 0x1f, 0xe8, 0x98
);

// a6e7ccc0-08fb-468d-a472-9771d5595e09
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V6_DISCARD,
   0xa6e7ccc0,
   0x08fb,
   0x468d,
   0xa4, 0x72, 0x97, 0x71, 0xd5, 0x59, 0x5e, 0x09
);

// 41390100-564c-4b32-bc1d-718048354d7c
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V4,
   0x41390100,
   0x564c,
   0x4b32,
   0xbc, 0x1d, 0x71, 0x80, 0x48, 0x35, 0x4d, 0x7c
);

// b3598d36-0561-4588-a6bf-e955e3f6264b
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V4_DISCARD,
   0xb3598d36,
   0x0561,
   0x4588,
   0xa6, 0xbf, 0xe9, 0x55, 0xe3, 0xf6, 0x26, 0x4b
);

// 7fb03b60-7b8d-4dfa-badd-980176fc4e12
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V6,
   0x7fb03b60,
   0x7b8d,
   0x4dfa,
   0xba, 0xdd, 0x98, 0x01, 0x76, 0xfc, 0x4e, 0x12
);

// 65f2e647-8d0c-4f47-b19b-33a4d3f1357c
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V6_DISCARD,
   0x65f2e647,
   0x8d0c,
   0x4f47,
   0xb1, 0x9b, 0x33, 0xa4, 0xd3, 0xf1, 0x35, 0x7c
);

// 1247d66d-0b60-4a15-8d44-7155d0f53a0c
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4,
   0x1247d66d,
   0x0b60,
   0x4a15,
   0x8d, 0x44, 0x71, 0x55, 0xd0, 0xf5, 0x3a, 0x0c
);

// 0b5812a2-c3ff-4eca-b88d-c79e20ac6322
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4_DISCARD,
   0x0b5812a2,
   0xc3ff,
   0x4eca,
   0xb8, 0x8d, 0xc7, 0x9e, 0x20, 0xac, 0x63, 0x22
);

// 55a650e1-5f0a-4eca-a653-88f53b26aa8c
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V6,
   0x55a650e1,
   0x5f0a,
   0x4eca,
   0xa6, 0x53, 0x88, 0xf5, 0x3b, 0x26, 0xaa, 0x8c
);

// cbc998bb-c51f-4c1a-bb4f-9775fcacab2f
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V6_DISCARD,
   0xcbc998bb,
   0xc51f,
   0x4c1a,
   0xbb, 0x4f, 0x97, 0x75, 0xfc, 0xac, 0xab, 0x2f
);

// 88bb5dad-76d7-4227-9c71-df0a3ed7be7e
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V4,
   0x88bb5dad,
   0x76d7,
   0x4227,
   0x9c, 0x71, 0xdf, 0x0a, 0x3e, 0xd7, 0xbe, 0x7e
);

// 371dfada-9f26-45fd-b4eb-c29eb212893f
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V4_DISCARD,
   0x371dfada,
   0x9f26,
   0x45fd,
   0xb4, 0xeb, 0xc2, 0x9e, 0xb2, 0x12, 0x89, 0x3f
);

// 7ac9de24-17dd-4814-b4bd-a9fbc95a321b
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V6,
   0x7ac9de24,
   0x17dd,
   0x4814,
   0xb4, 0xbd, 0xa9, 0xfb, 0xc9, 0x5a, 0x32, 0x1b
);

// 60703b07-63c8-48e9-ada3-12b1af40a617
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V6_DISCARD,
   0x60703b07,
   0x63c8,
   0x48e9,
   0xad, 0xa3, 0x12, 0xb1, 0xaf, 0x40, 0xa6, 0x17
);

// e1cd9fe7-f4b5-4273-96c0-592e487b8650
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4,
   0xe1cd9fe7,
   0xf4b5,
   0x4273,
   0x96, 0xc0, 0x59, 0x2e, 0x48, 0x7b, 0x86, 0x50
);

// 9eeaa99b-bd22-4227-919f-0073c63357b1
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4_DISCARD,
   0x9eeaa99b,
   0xbd22,
   0x4227,
   0x91, 0x9f, 0x00, 0x73, 0xc6, 0x33, 0x57, 0xb1
);

// a3b42c97-9f04-4672-b87e-cee9c483257f
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6,
   0xa3b42c97,
   0x9f04,
   0x4672,
   0xb8, 0x7e, 0xce, 0xe9, 0xc4, 0x83, 0x25, 0x7f
);

// 89455b97-dbe1-453f-a224-13da895af396
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6_DISCARD,
   0x89455b97,
   0xdbe1,
   0x453f,
   0xa2, 0x24, 0x13, 0xda, 0x89, 0x5a, 0xf3, 0x96
);

// c38d57d1-05a7-4c33-904f-7fbceee60e82
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V4,
   0xc38d57d1,
   0x05a7,
   0x4c33,
   0x90, 0x4f, 0x7f, 0xbc, 0xee, 0xe6, 0x0e, 0x82
);

// d632a801-f5ba-4ad6-96e3-607017d9836a
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V4_DISCARD,
   0xd632a801,
   0xf5ba,
   0x4ad6,
   0x96, 0xe3, 0x60, 0x70, 0x17, 0xd9, 0x83, 0x6a
);

// 4a72393b-319f-44bc-84c3-ba54dcb3b6b4
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V6,
   0x4a72393b,
   0x319f,
   0x44bc,
   0x84, 0xc3, 0xba, 0x54, 0xdc, 0xb3, 0xb6, 0xb4
);

// c97bc3b8-c9a3-4e33-8695-8e17aad4de09
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V6_DISCARD,
   0xc97bc3b8,
   0xc9a3,
   0x4e33,
   0x86, 0x95, 0x8e, 0x17, 0xaa, 0xd4, 0xde, 0x09
);

// af80470a-5596-4c13-9992-539e6fe57967
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4,
   0xaf80470a,
   0x5596,
   0x4c13,
   0x99, 0x92, 0x53, 0x9e, 0x6f, 0xe5, 0x79, 0x67
);

// 146ae4a9-a1d2-4d43-a31a-4c42682b8e4f
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4_DISCARD,
   0x146ae4a9,
   0xa1d2,
   0x4d43,
   0xa3, 0x1a, 0x4c, 0x42, 0x68, 0x2b, 0x8e, 0x4f
);

// 7021d2b3-dfa4-406e-afeb-6afaf7e70efd
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V6,
   0x7021d2b3,
   0xdfa4,
   0x406e,
   0xaf, 0xeb, 0x6a, 0xfa, 0xf7, 0xe7, 0x0e, 0xfd
);

// 46928636-bbca-4b76-941d-0fa7f5d7d372
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V6_DISCARD,
   0x46928636,
   0xbbca,
   0x4b76,
   0x94, 0x1d, 0x0f, 0xa7, 0xf5, 0xd7, 0xd3, 0x72
);

// f02b1526-a459-4a51-b9e3-759de52b9d2c
DEFINE_GUID(
   FWPM_LAYER_IPSEC_KM_DEMUX_V4,
   0xf02b1526,
   0xa459,
   0x4a51,
   0xb9, 0xe3, 0x75, 0x9d, 0xe5, 0x2b, 0x9d, 0x2c
);

// 2f755cf6-2fd4-4e88-b3e4-a91bca495235
DEFINE_GUID(
   FWPM_LAYER_IPSEC_KM_DEMUX_V6,
   0x2f755cf6,
   0x2fd4,
   0x4e88,
   0xb3, 0xe4, 0xa9, 0x1b, 0xca, 0x49, 0x52, 0x35
);

// eda65c74-610d-4bc5-948f-3c4f89556867
DEFINE_GUID(
   FWPM_LAYER_IPSEC_V4,
   0xeda65c74,
   0x610d,
   0x4bc5,
   0x94, 0x8f, 0x3c, 0x4f, 0x89, 0x55, 0x68, 0x67
);

// 13c48442-8d87-4261-9a29-59d2abc348b4
DEFINE_GUID(
   FWPM_LAYER_IPSEC_V6,
   0x13c48442,
   0x8d87,
   0x4261,
   0x9a, 0x29, 0x59, 0xd2, 0xab, 0xc3, 0x48, 0xb4
);

// b14b7bdb-dbbd-473e-bed4-8b4708d4f270
DEFINE_GUID(
   FWPM_LAYER_IKEEXT_V4,
   0xb14b7bdb,
   0xdbbd,
   0x473e,
   0xbe, 0xd4, 0x8b, 0x47, 0x08, 0xd4, 0xf2, 0x70
);

// b64786b3-f687-4eb9-89d2-8ef32acdabe2
DEFINE_GUID(
   FWPM_LAYER_IKEEXT_V6,
   0xb64786b3,
   0xf687,
   0x4eb9,
   0x89, 0xd2, 0x8e, 0xf3, 0x2a, 0xcd, 0xab, 0xe2
);

// 75a89dda-95e4-40f3-adc7-7688a9c847e1
DEFINE_GUID(
   FWPM_LAYER_RPC_UM,
   0x75a89dda,
   0x95e4,
   0x40f3,
   0xad, 0xc7, 0x76, 0x88, 0xa9, 0xc8, 0x47, 0xe1
);

// 9247bc61-eb07-47ee-872c-bfd78bfd1616
DEFINE_GUID(
   FWPM_LAYER_RPC_EPMAP,
   0x9247bc61,
   0xeb07,
   0x47ee,
   0x87, 0x2c, 0xbf, 0xd7, 0x8b, 0xfd, 0x16, 0x16
);

// 618dffc7-c450-4943-95db-99b4c16a55d4
DEFINE_GUID(
   FWPM_LAYER_RPC_EP_ADD,
   0x618dffc7,
   0xc450,
   0x4943,
   0x95, 0xdb, 0x99, 0xb4, 0xc1, 0x6a, 0x55, 0xd4
);

// 94a4b50b-ba5c-4f27-907a-229fac0c2a7a
DEFINE_GUID(
   FWPM_LAYER_RPC_PROXY_CONN,
   0x94a4b50b,
   0xba5c,
   0x4f27,
   0x90, 0x7a, 0x22, 0x9f, 0xac, 0x0c, 0x2a, 0x7a
);

// f8a38615-e12c-41ac-98df-121ad981aade
DEFINE_GUID(
   FWPM_LAYER_RPC_PROXY_IF,
   0xf8a38615,
   0xe12c,
   0x41ac,
   0x98, 0xdf, 0x12, 0x1a, 0xd9, 0x81, 0xaa, 0xde
);

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in sublayers.
//
///////////////////////////////////////////////////////////////////////////////

// 758c84f4-fb48-4de9-9aeb-3ed9551ab1fd
DEFINE_GUID(
   FWPM_SUBLAYER_RPC_AUDIT,
   0x758c84f4,
   0xfb48,
   0x4de9,
   0x9a, 0xeb, 0x3e, 0xd9, 0x55, 0x1a, 0xb1, 0xfd
);

// 83f299ed-9ff4-4967-aff4-c309f4dab827
DEFINE_GUID(
   FWPM_SUBLAYER_IPSEC_TUNNEL,
   0x83f299ed,
   0x9ff4,
   0x4967,
   0xaf, 0xf4, 0xc3, 0x09, 0xf4, 0xda, 0xb8, 0x27
);

// eebecc03-ced4-4380-819a-2734397b2b74
DEFINE_GUID(
   FWPM_SUBLAYER_UNIVERSAL,
   0xeebecc03,
   0xced4,
   0x4380,
   0x81, 0x9a, 0x27, 0x34, 0x39, 0x7b, 0x2b, 0x74
);

// 1b75c0ce-ff60-4711-a70f-b4958cc3b2d0
DEFINE_GUID(
   FWPM_SUBLAYER_LIPS,
   0x1b75c0ce,
   0xff60,
   0x4711,
   0xa7, 0x0f, 0xb4, 0x95, 0x8c, 0xc3, 0xb2, 0xd0
);

// 15a66e17-3f3c-4f7b-aa6c-812aa613dd82
DEFINE_GUID(
   FWPM_SUBLAYER_SECURE_SOCKET,
   0x15a66e17,
   0x3f3c,
   0x4f7b,
   0xaa, 0x6c, 0x81, 0x2a, 0xa6, 0x13, 0xdd, 0x82
);

// 337608b9-b7d5-4d5f-82f9-3618618bc058
DEFINE_GUID(
   FWPM_SUBLAYER_TCP_CHIMNEY_OFFLOAD,
   0x337608b9,
   0xb7d5,
   0x4d5f,
   0x82, 0xf9, 0x36, 0x18, 0x61, 0x8b, 0xc0, 0x58
);

// 877519e1-e6a9-41a5-81b4-8c4f118e4a60
DEFINE_GUID(
   FWPM_SUBLAYER_INSPECTION,
   0x877519e1,
   0xe6a9,
   0x41a5,
   0x81, 0xb4, 0x8c, 0x4f, 0x11, 0x8e, 0x4a, 0x60
);

// ba69dc66-5176-4979-9c89-26a7b46a8327
DEFINE_GUID(
   FWPM_SUBLAYER_TEREDO,
   0xba69dc66,
   0x5176,
   0x4979,
   0x9c, 0x89, 0x26, 0xa7, 0xb4, 0x6a, 0x83, 0x27
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

// a5082e73-8f71-4559-8a9a-101cea04ef87
DEFINE_GUID(
   FWPM_SUBLAYER_IPSEC_FORWARD_OUTBOUND_TUNNEL,
   0xa5082e73,
   0x8f71,
   0x4559,
   0x8a, 0x9a, 0x10, 0x1c, 0xea, 0x04, 0xef, 0x87
);

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in conditions.
//
///////////////////////////////////////////////////////////////////////////////

// d9ee00de-c1ef-4617-bfe3-ffd8f5a08957
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS,
   0xd9ee00de,
   0xc1ef,
   0x4617,
   0xbf, 0xe3, 0xff, 0xd8, 0xf5, 0xa0, 0x89, 0x57
);

// b235ae9a-1d64-49b8-a44c-5ff3d9095045
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_ADDRESS,
   0xb235ae9a,
   0x1d64,
   0x49b8,
   0xa4, 0x4c, 0x5f, 0xf3, 0xd9, 0x09, 0x50, 0x45
);

// ae96897e-2e94-4bc9-b313-b27ee80e574d
DEFINE_GUID(
   FWPM_CONDITION_IP_SOURCE_ADDRESS,
   0xae96897e,
   0x2e94,
   0x4bc9,
   0xb3, 0x13, 0xb2, 0x7e, 0xe8, 0x0e, 0x57, 0x4d
);

// 2d79133b-b390-45c6-8699-acaceaafed33
DEFINE_GUID(
   FWPM_CONDITION_IP_DESTINATION_ADDRESS,
   0x2d79133b,
   0xb390,
   0x45c6,
   0x86, 0x99, 0xac, 0xac, 0xea, 0xaf, 0xed, 0x33
);

// 6ec7f6c4-376b-45d7-9e9c-d337cedcd237
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS_TYPE,
   0x6ec7f6c4,
   0x376b,
   0x45d7,
   0x9e, 0x9c, 0xd3, 0x37, 0xce, 0xdc, 0xd2, 0x37
);

// 1ec1b7c9-4eea-4f5e-b9ef-76beaaaf17ee
DEFINE_GUID(
   FWPM_CONDITION_IP_DESTINATION_ADDRESS_TYPE,
   0x1ec1b7c9,
   0x4eea,
   0x4f5e,
   0xb9, 0xef, 0x76, 0xbe, 0xaa, 0xaf, 0x17, 0xee
);

// 4cd62a49-59c3-4969-b7f3-bda5d32890a4
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_INTERFACE,
   0x4cd62a49,
   0x59c3,
   0x4969,
   0xb7, 0xf3, 0xbd, 0xa5, 0xd3, 0x28, 0x90, 0xa4
);


#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 618a9b6d-386b-4136-ad6e-b51587cfb1cd
DEFINE_GUID(
   FWPM_CONDITION_IP_ARRIVAL_INTERFACE,
   0x618a9b6d,
   0x386b,
   0x4136,
   0xad, 0x6e, 0xb5, 0x15, 0x87, 0xcf, 0xb1, 0xcd 
);

// 89f990de-e798-4e6d-ab76-7c9558292e6f
DEFINE_GUID(
   FWPM_CONDITION_ARRIVAL_INTERFACE_TYPE,
   0x89f990de,
   0xe798,
   0x4e6d,
   0xab, 0x76, 0x7c, 0x95, 0x58, 0x29, 0x2e, 0x6f
);

// 511166dc-7a8c-4aa7-b533-95ab59fb0340
DEFINE_GUID(
   FWPM_CONDITION_ARRIVAL_TUNNEL_TYPE,
   0x511166dc,
   0x7a8c,
   0x4aa7,
   0xb5, 0x33, 0x95, 0xab, 0x59, 0xfb, 0x03, 0x40
);

// cc088db3-1792-4a71-b0f9-037d21cd828b
DEFINE_GUID(
   FWPM_CONDITION_ARRIVAL_INTERFACE_INDEX,
   0xcc088db3,
   0x1792,
   0x4a71,
   0xb0, 0xf9, 0x03, 0x7d, 0x21, 0xcd, 0x82, 0x8b
);

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// daf8cd14-e09e-4c93-a5ae-c5c13b73ffca
DEFINE_GUID(
   FWPM_CONDITION_INTERFACE_TYPE,
   0xdaf8cd14,
   0xe09e,
   0x4c93,
   0xa5, 0xae, 0xc5, 0xc1, 0x3b, 0x73, 0xff, 0xca
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_LOCAL_INTERFACE_TYPE FWPM_CONDITION_INTERFACE_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 77a40437-8779-4868-a261-f5a902f1c0cd
DEFINE_GUID(
   FWPM_CONDITION_TUNNEL_TYPE,
   0x77a40437,
   0x8779,
   0x4868,
   0xa2, 0x61, 0xf5, 0xa9, 0x02, 0xf1, 0xc0, 0xcd
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_LOCAL_TUNNEL_TYPE FWPM_CONDITION_TUNNEL_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 1076b8a5-6323-4c5e-9810-e8d3fc9e6136
DEFINE_GUID(
   FWPM_CONDITION_IP_FORWARD_INTERFACE,
   0x1076b8a5,
   0x6323,
   0x4c5e,
   0x98, 0x10, 0xe8, 0xd3, 0xfc, 0x9e, 0x61, 0x36
);

// 3971ef2b-623e-4f9a-8cb1-6e79b806b9a7
DEFINE_GUID(
   FWPM_CONDITION_IP_PROTOCOL,
   0x3971ef2b,
   0x623e,
   0x4f9a,
   0x8c, 0xb1, 0x6e, 0x79, 0xb8, 0x06, 0xb9, 0xa7
);

// 0c1ba1af-5765-453f-af22-a8f791ac775b
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_PORT,
   0x0c1ba1af,
   0x5765,
   0x453f,
   0xaf, 0x22, 0xa8, 0xf7, 0x91, 0xac, 0x77, 0x5b
);

#define FWPM_CONDITION_ICMP_TYPE FWPM_CONDITION_IP_LOCAL_PORT

// c35a604d-d22b-4e1a-91b4-68f674ee674b
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_PORT,
   0xc35a604d,
   0xd22b,
   0x4e1a,
   0x91, 0xb4, 0x68, 0xf6, 0x74, 0xee, 0x67, 0x4b
);

#define FWPM_CONDITION_ICMP_CODE FWPM_CONDITION_IP_REMOTE_PORT

// 4672a468-8a0a-4202-abb4-849e92e66809
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_LOCAL_ADDRESS_TYPE,
   0x4672a468,
   0x8a0a,
   0x4202,
   0xab, 0xb4, 0x84, 0x9e, 0x92, 0xe6, 0x68, 0x09
);

// 77ee4b39-3273-4671-b63b-ab6feb66eeb6
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_REMOTE_ADDRESS,
   0x77ee4b39,
   0x3273,
   0x4671,
   0xb6, 0x3b, 0xab, 0x6f, 0xeb, 0x66, 0xee, 0xb6
);

// 07784107-a29e-4c7b-9ec7-29c44afafdbc
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_PROTOCOL,
   0x07784107,
   0xa29e,
   0x4c7b,
   0x9e, 0xc7, 0x29, 0xc4, 0x4a, 0xfa, 0xfd, 0xbc
);

// bfca394d-acdb-484e-b8e6-2aff79757345
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_LOCAL_PORT,
   0xbfca394d,
   0xacdb,
   0x484e,
   0xb8, 0xe6, 0x2a, 0xff, 0x79, 0x75, 0x73, 0x45
);

// cae4d6a1-2968-40ed-a4ce-547160dda88d
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_REMOTE_PORT,
   0xcae4d6a1,
   0x2968,
   0x40ed,
   0xa4, 0xce, 0x54, 0x71, 0x60, 0xdd, 0xa8, 0x8d
);

// 632ce23b-5167-435c-86d7-e903684aa80c
DEFINE_GUID(
   FWPM_CONDITION_FLAGS,
   0x632ce23b,
   0x5167,
   0x435c,
   0x86, 0xd7, 0xe9, 0x03, 0x68, 0x4a, 0xa8, 0x0c
);

// 8784c146-ca97-44d6-9fd1-19fb1840cbf7
DEFINE_GUID(
   FWPM_CONDITION_DIRECTION,
   0x8784c146,
   0xca97,
   0x44d6,
   0x9f, 0xd1, 0x19, 0xfb, 0x18, 0x40, 0xcb, 0xf7
);

// 667fd755-d695-434a-8af5-d3835a1259bc
DEFINE_GUID(
   FWPM_CONDITION_INTERFACE_INDEX,
   0x667fd755,
   0xd695,
   0x434a,
   0x8a, 0xf5, 0xd3, 0x83, 0x5a, 0x12, 0x59, 0xbc
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_LOCAL_INTERFACE_INDEX FWPM_CONDITION_INTERFACE_INDEX

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)


// 0cd42473-d621-4be3-ae8c-72a348d283e1
DEFINE_GUID(
   FWPM_CONDITION_SUB_INTERFACE_INDEX,
   0x0cd42473,
   0xd621,
   0x4be3,
   0xae, 0x8c, 0x72, 0xa3, 0x48, 0xd2, 0x83, 0xe1
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPM_CONDITION_SUB_INTERFACE_INDEX

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 2311334d-c92d-45bf-9496-edf447820e2d
DEFINE_GUID(
   FWPM_CONDITION_SOURCE_INTERFACE_INDEX,
   0x2311334d,
   0xc92d,
   0x45bf,
   0x94, 0x96, 0xed, 0xf4, 0x47, 0x82, 0x0e, 0x2d
);

// 055edd9d-acd2-4361-8dab-f9525d97662f
DEFINE_GUID(
   FWPM_CONDITION_SOURCE_SUB_INTERFACE_INDEX,
   0x055edd9d,
   0xacd2,
   0x4361,
   0x8d, 0xab, 0xf9, 0x52, 0x5d, 0x97, 0x66, 0x2f
);

// 35cf6522-4139-45ee-a0d5-67b80949d879
DEFINE_GUID(
   FWPM_CONDITION_DESTINATION_INTERFACE_INDEX,
   0x35cf6522,
   0x4139,
   0x45ee,
   0xa0, 0xd5, 0x67, 0xb8, 0x09, 0x49, 0xd8, 0x79
);

// 2b7d4399-d4c7-4738-a2f5-e994b43da388
DEFINE_GUID(
   FWPM_CONDITION_DESTINATION_SUB_INTERFACE_INDEX,
   0x2b7d4399,
   0xd4c7,
   0x4738,
   0xa2, 0xf5, 0xe9, 0x94, 0xb4, 0x3d, 0xa3, 0x88
);

// d78e1e87-8644-4ea5-9437-d809ecefc971
DEFINE_GUID(
   FWPM_CONDITION_ALE_APP_ID,
   0xd78e1e87,
   0x8644,
   0x4ea5,
   0x94, 0x37, 0xd8, 0x09, 0xec, 0xef, 0xc9, 0x71
);

// af043a0a-b34d-4f86-979c-c90371af6e66
DEFINE_GUID(
   FWPM_CONDITION_ALE_USER_ID,
   0xaf043a0a,
   0xb34d,
   0x4f86,
   0x97, 0x9c, 0xc9, 0x03, 0x71, 0xaf, 0x6e, 0x66
);

// f63073b7-0189-4ab0-95a4-6123cbfab862
DEFINE_GUID(
   FWPM_CONDITION_ALE_REMOTE_USER_ID,
   0xf63073b7,
   0x0189,
   0x4ab0,
   0x95, 0xa4, 0x61, 0x23, 0xcb, 0xfa, 0xb8, 0x62
);

// 1aa47f51-7f93-4508-a271-81abb00c9cab
DEFINE_GUID(
   FWPM_CONDITION_ALE_REMOTE_MACHINE_ID,
   0x1aa47f51,
   0x7f93,
   0x4508,
   0xa2, 0x71, 0x81, 0xab, 0xb0, 0x0c, 0x9c, 0xab
);

// 1c974776-7182-46e9-afd3-b02910e30334
DEFINE_GUID(
   FWPM_CONDITION_ALE_PROMISCUOUS_MODE,
   0x1c974776,
   0x7182,
   0x46e9,
   0xaf, 0xd3, 0xb0, 0x29, 0x10, 0xe3, 0x03, 0x34
);

// b9f4e088-cb98-4efb-a2c7-ad07332643db
DEFINE_GUID(
   FWPM_CONDITION_ALE_SIO_FIREWALL_SYSTEM_PORT,
   0xb9f4e088,
   0xcb98,
   0x4efb,
   0xa2, 0xc7, 0xad, 0x07, 0x33, 0x26, 0x43, 0xdb
);

// 46275a9d-c03f-4d77-b784-1c57f4d02753
DEFINE_GUID(
   FWPM_CONDITION_ALE_NAP_CONTEXT,
   0x46275a9d,
   0xc03f,
   0x4d77,
   0xb7, 0x84, 0x1c, 0x57, 0xf4, 0xd0, 0x27, 0x53
);

// 9bf0ee66-06c9-41b9-84da-288cb43af51f
DEFINE_GUID(
    FWPM_CONDITION_REMOTE_USER_TOKEN,
    0x9bf0ee66,
    0x06c9,
    0x41b9,
    0x84, 0xda, 0x28, 0x8c, 0xb4, 0x3a, 0xf5, 0x1f
);

// 7c9c7d9f-0075-4d35-a0d1-8311c4cf6af1
DEFINE_GUID(
   FWPM_CONDITION_RPC_IF_UUID,
   0x7c9c7d9f,
   0x0075,
   0x4d35,
   0xa0, 0xd1, 0x83, 0x11, 0xc4, 0xcf, 0x6a, 0xf1
);

// eabfd9b7-1262-4a2e-adaa-5f96f6fe326d
DEFINE_GUID(
   FWPM_CONDITION_RPC_IF_VERSION,
   0xeabfd9b7,
   0x1262,
   0x4a2e,
   0xad, 0xaa, 0x5f, 0x96, 0xf6, 0xfe, 0x32, 0x6d
);

// 238a8a32-3199-467d-871c-272621ab3896
DEFINE_GUID(
    FWPM_CONDITION_RPC_IF_FLAG,
    0x238a8a32,
    0x3199,
    0x467d,
    0x87, 0x1c, 0x27, 0x26, 0x21, 0xab, 0x38, 0x96
);

// ff2e7b4d-3112-4770-b636-4d24ae3a6af2
DEFINE_GUID(
    FWPM_CONDITION_DCOM_APP_ID,
    0xff2e7b4d,
    0x3112,
    0x4770,
    0xb6, 0x36, 0x4d, 0x24, 0xae, 0x3a, 0x6a, 0xf2
);

// d024de4d-deaa-4317-9c85-e40ef6e140c3
DEFINE_GUID(
    FWPM_CONDITION_IMAGE_NAME,
    0xd024de4d,
    0xdeaa,
    0x4317,
    0x9c, 0x85, 0xe4, 0x0e, 0xf6, 0xe1, 0x40, 0xc3
);

// 2717bc74-3a35-4ce7-b7ef-c838fabdec45
DEFINE_GUID(
    FWPM_CONDITION_RPC_PROTOCOL,
    0x2717bc74,
    0x3a35,
    0x4ce7,
    0xb7, 0xef, 0xc8, 0x38, 0xfa, 0xbd, 0xec, 0x45
);

// daba74ab-0d67-43e7-986e-75b84f82f594
DEFINE_GUID(
   FWPM_CONDITION_RPC_AUTH_TYPE,
   0xdaba74ab,
   0x0d67,
   0x43e7,
   0x98, 0x6e, 0x75, 0xb8, 0x4f, 0x82, 0xf5, 0x94
);

// e5a0aed5-59ac-46ea-be05-a5f05ecf446e
DEFINE_GUID(
   FWPM_CONDITION_RPC_AUTH_LEVEL,
   0xe5a0aed5,
   0x59ac,
   0x46ea,
   0xbe, 0x05, 0xa5, 0xf0, 0x5e, 0xcf, 0x44, 0x6e
);

// 0d306ef0-e974-4f74-b5c7-591b0da7d562
DEFINE_GUID(
   FWPM_CONDITION_SEC_ENCRYPT_ALGORITHM,
   0x0d306ef0,
   0xe974,
   0x4f74,
   0xb5, 0xc7, 0x59, 0x1b, 0x0d, 0xa7, 0xd5, 0x62
);

// 4772183b-ccf8-4aeb-bce1-c6c6161c8fe4
DEFINE_GUID(
    FWPM_CONDITION_SEC_KEY_SIZE,
    0x4772183b,
    0xccf8,
    0x4aeb,
    0xbc, 0xe1, 0xc6, 0xc6, 0x16, 0x1c, 0x8f, 0xe4
);

// 03a629cb-6e52-49f8-9c41-5709633c09cf
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS_V4,
   0x03a629cb,
   0x6e52,
   0x49f8,
   0x9c, 0x41, 0x57, 0x09, 0x63, 0x3c, 0x09, 0xcf
);

// 2381be84-7524-45b3-a05b-1e637d9c7a6a
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS_V6,
   0x2381be84,
   0x7524,
   0x45b3,
   0xa0, 0x5b, 0x1e, 0x63, 0x7d, 0x9c, 0x7a, 0x6a
);

// 1bd0741d-e3df-4e24-8634-762046eef6eb
DEFINE_GUID(
    FWPM_CONDITION_PIPE,
    0x1bd0741d,
    0xe3df,
    0x4e24,
    0x86, 0x34, 0x76, 0x20, 0x46, 0xee, 0xf6, 0xeb
);

// 1febb610-3bcc-45e1-bc36-2e067e2cb186
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_ADDRESS_V4,
   0x1febb610,
   0x3bcc,
   0x45e1,
   0xbc, 0x36, 0x2e, 0x06, 0x7e, 0x2c, 0xb1, 0x86
);

// 246e1d8c-8bee-4018-9b98-31d4582f3361
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_ADDRESS_V6,
   0x246e1d8c,
   0x8bee,
   0x4018,
   0x9b, 0x98, 0x31, 0xd4, 0x58, 0x2f, 0x33, 0x61
);

// e31180a8-bbbd-4d14-a65e-7157b06233bb
DEFINE_GUID(
    FWPM_CONDITION_PROCESS_WITH_RPC_IF_UUID,
    0xe31180a8,
    0xbbbd,
    0x4d14,
    0xa6, 0x5e, 0x71, 0x57, 0xb0, 0x62, 0x33, 0xbb
);

// dccea0b9-0886-4360-9c6a-ab043a24fba9
DEFINE_GUID(
    FWPM_CONDITION_RPC_EP_VALUE,
    0xdccea0b9,
    0x0886,
    0x4360,
    0x9c, 0x6a, 0xab, 0x04, 0x3a, 0x24, 0xfb, 0xa9
);

// 218b814a-0a39-49b8-8e71-c20c39c7dd2e
DEFINE_GUID(
    FWPM_CONDITION_RPC_EP_FLAGS,
    0x218b814a,
    0x0a39,
    0x49b8,
    0x8e, 0x71, 0xc2, 0x0c, 0x39, 0xc7, 0xdd, 0x2e
);

// c228fc1e-403a-4478-be05-c9baa4c05ace
DEFINE_GUID(
    FWPM_CONDITION_CLIENT_TOKEN,
    0xc228fc1e,
    0x403a,
    0x4478,
    0xbe, 0x05, 0xc9, 0xba, 0xa4, 0xc0, 0x5a, 0xce
);

// b605a225-c3b3-48c7-9833-7aefa9527546
DEFINE_GUID(
    FWPM_CONDITION_RPC_SERVER_NAME,
    0xb605a225,
    0xc3b3,
    0x48c7,
    0x98, 0x33, 0x7a, 0xef, 0xa9, 0x52, 0x75, 0x46
);

// 8090f645-9ad5-4e3b-9f9f-8023ca097909
DEFINE_GUID(
    FWPM_CONDITION_RPC_SERVER_PORT,
    0x8090f645,
    0x9ad5,
    0x4e3b,
    0x9f, 0x9f, 0x80, 0x23, 0xca, 0x09, 0x79, 0x09
);

// 40953fe2-8565-4759-8488-1771b4b4b5db
DEFINE_GUID(
    FWPM_CONDITION_RPC_PROXY_AUTH_TYPE,
    0x40953fe2,
    0x8565,
    0x4759,
    0x84, 0x88, 0x17, 0x71, 0xb4, 0xb4, 0xb5, 0xdb
);

// a3ec00c7-05f4-4df7-91f2-5f60d91ff443
DEFINE_GUID(
    FWPM_CONDITION_CLIENT_CERT_KEY_LENGTH,
    0xa3ec00c7,
    0x05f4,
    0x4df7,
    0x91, 0xf2, 0x5f, 0x60, 0xd9, 0x1f, 0xf4, 0x43
);

// c491ad5e-f882-4283-b916-436b103ff4ad
DEFINE_GUID(
    FWPM_CONDITION_CLIENT_CERT_OID,
    0xc491ad5e,
    0xf882,
    0x4283,
    0xb9, 0x16, 0x43, 0x6b, 0x10, 0x3f, 0xf4, 0xad
);

// 056d336d-ca55-489f-94b9-a4962f8246e2
DEFINE_GUID(
   FWPM_CONDITION_SCOPE_ID,
   0x056d336d,
   0xca55,
   0x489f,
   0x94, 0xb9, 0xa4, 0x96, 0x2f, 0x82, 0x46, 0xe2
);


///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in providers.
//
///////////////////////////////////////////////////////////////////////////////

// 10ad9216-ccde-456c-8b16-e9f04e60a90b
DEFINE_GUID(
   FWPM_PROVIDER_IKEEXT,
   0x10ad9216,
   0xccde,
   0x456c,
   0x8b, 0x16, 0xe9, 0xf0, 0x4e, 0x60, 0xa9, 0x0b
);

// 896aa19e-9a34-4bcb-ae79-beb9127c84b9
DEFINE_GUID(
   FWPM_PROVIDER_TCP_CHIMNEY_OFFLOAD,
   0x896aa19e,
   0x9a34,
   0x4bcb,
   0xae, 0x79, 0xbe, 0xb9, 0x12, 0x7c, 0x84, 0xb9
);


///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in callouts.
//
///////////////////////////////////////////////////////////////////////////////

// 5132900d-5e84-4b5f-80e4-01741e81ff10
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TRANSPORT_V4,
   0x5132900d,
   0x5e84,
   0x4b5f,
   0x80, 0xe4, 0x01, 0x74, 0x1e, 0x81, 0xff, 0x10
);

// 49d3ac92-2a6c-4dcf-955f-1c3be009dd99
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TRANSPORT_V6,
   0x49d3ac92,
   0x2a6c,
   0x4dcf,
   0x95, 0x5f, 0x1c, 0x3b, 0xe0, 0x09, 0xdd, 0x99
);

// 4b46bf0a-4523-4e57-aa38-a87987c910d9
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TRANSPORT_V4,
   0x4b46bf0a,
   0x4523,
   0x4e57,
   0xaa, 0x38, 0xa8, 0x79, 0x87, 0xc9, 0x10, 0xd9
);

// 38d87722-ad83-4f11-a91f-df0fb077225b
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TRANSPORT_V6,
   0x38d87722,
   0xad83,
   0x4f11,
   0xa9, 0x1f, 0xdf, 0x0f, 0xb0, 0x77, 0x22, 0x5b
);

// 191a8a46-0bf8-46cf-b045-4b45dfa6a324
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_V4,
   0x191a8a46,
   0x0bf8,
   0x46cf,
   0xb0, 0x45, 0x4b, 0x45, 0xdf, 0xa6, 0xa3, 0x24
);

// 80c342e3-1e53-4d6f-9b44-03df5aeee154
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_V6,
   0x80c342e3,
   0x1e53,
   0x4d6f,
   0x9b, 0x44, 0x03, 0xdf, 0x5a, 0xee, 0xe1, 0x54
);

// 70a4196c-835b-4fb0-98e8-075f4d977d46
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TUNNEL_V4,
   0x70a4196c,
   0x835b,
   0x4fb0,
   0x98, 0xe8, 0x07, 0x5f, 0x4d, 0x97, 0x7d, 0x46
);

// f1835363-a6a5-4e62-b180-23db789d8da6
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TUNNEL_V6,
   0xf1835363,
   0xa6a5,
   0x4e62,
   0xb1, 0x80, 0x23, 0xdb, 0x78, 0x9d, 0x8d, 0xa6
);

// 28829633-c4f0-4e66-873f-844db2a899c7
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_INBOUND_TUNNEL_V4,
   0x28829633,
   0xc4f0,
   0x4e66,
   0x87, 0x3f, 0x84, 0x4d, 0xb2, 0xa8, 0x99, 0xc7
);

// af50bec2-c686-429a-884d-b74443e7b0b4
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_INBOUND_TUNNEL_V6,
   0xaf50bec2,
   0xc686,
   0x429a,
   0x88, 0x4d, 0xb7, 0x44, 0x43, 0xe7, 0xb0, 0xb4
);

// fb532136-15cb-440b-937c-1717ca320c40
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_OUTBOUND_TUNNEL_V4,
   0xfb532136,
   0x15cb,
   0x440b,
   0x93, 0x7c, 0x17, 0x17, 0xca, 0x32, 0x0c, 0x40
);

// dae640cc-e021-4bee-9eb6-a48b275c8c1d
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_OUTBOUND_TUNNEL_V6,
   0xdae640cc,
   0xe021,
   0x4bee,
   0x9e, 0xb6, 0xa4, 0x8b, 0x27, 0x5c, 0x8c, 0x1d
);

// 7dff309b-ba7d-4aba-91aa-ae5c6640c944
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_INITIATE_SECURE_V4,
   0x7dff309b,
   0xba7d,
   0x4aba,
   0x91, 0xaa, 0xae, 0x5c, 0x66, 0x40, 0xc9, 0x44
);

// a9a0d6d9-c58c-474e-8aeb-3cfe99d6d53d
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_INITIATE_SECURE_V6,
   0xa9a0d6d9,
   0xc58c,
   0x474e,
   0x8a, 0xeb, 0x3c, 0xfe, 0x99, 0xd6, 0xd5, 0x3d
);

// 3df6e7de-fd20-48f2-9f26-f854444cba79
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_ALE_ACCEPT_V4,
   0x3df6e7de,
   0xfd20,
   0x48f2,
   0x9f, 0x26, 0xf8, 0x54, 0x44, 0x4c, 0xba, 0x79
);

// a1e392d3-72ac-47bb-87a7-0122c69434ab
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_ALE_ACCEPT_V6,
   0xa1e392d3,
   0x72ac,
   0x47bb,
   0x87, 0xa7, 0x01, 0x22, 0xc6, 0x94, 0x34, 0xab
);

// 6ac141fc-f75d-4203-b9c8-48e6149c2712
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_ALE_CONNECT_V4,
   0x6ac141fc,
   0xf75d,
   0x4203,
   0xb9,0xc8,0x48, 0xe6, 0x14, 0x9c, 0x27, 0x12
);

// 4c0dda05-e31f-4666-90b0-b3dfad34129a
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_ALE_CONNECT_V6,
   0x4c0dda05,
   0xe31f,
   0x4666,
   0x90, 0xb0, 0xb3, 0xdf, 0xad, 0x34, 0x12, 0x9a
);

// eda08606-2494-4d78-89bc-67837c03b969
DEFINE_GUID(
   FWPM_CALLOUT_WFP_TRANSPORT_LAYER_V4_SILENT_DROP,
   0xeda08606,
   0x2494,
   0x4d78,
   0x89, 0xbc, 0x67, 0x83, 0x7c, 0x03, 0xb9, 0x69
);

// 8693cc74-a075-4156-b476-9286eece814e
DEFINE_GUID(
   FWPM_CALLOUT_WFP_TRANSPORT_LAYER_V6_SILENT_DROP,
   0x8693cc74,
   0xa075,
   0x4156,
   0xb4, 0x76, 0x92, 0x86, 0xee, 0xce, 0x81, 0x4e
);

// f3e10ab3-2c25-4279-ac36-c30fc181bec4
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_CONNECT_LAYER_V4,
   0xf3e10ab3,
   0x2c25,
   0x4279,
   0xac, 0x36, 0xc3, 0x0f, 0xc1, 0x81, 0xbe, 0xc4
);

// 39e22085-a341-42fc-a279-aec94e689c56
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_CONNECT_LAYER_V6,
   0x39e22085,
   0xa341,
   0x42fc,
   0xa2, 0x79, 0xae, 0xc9, 0x4e, 0x68, 0x9c, 0x56
);

// e183ecb2-3a7f-4b54-8ad9-76050ed880ca
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_ACCEPT_LAYER_V4,
   0xe183ecb2,
   0x3a7f,
   0x4b54,
   0x8a, 0xd9, 0x76, 0x05, 0x0e, 0xd8, 0x80, 0xca
);

// 0378cf41-bf98-4603-81f2-7f12586079f6
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_ACCEPT_LAYER_V6,
   0x0378cf41,
   0xbf98,
   0x4603,
   0x81, 0xf2, 0x7f, 0x12, 0x58, 0x60, 0x79, 0xf6
);

// bc582280-1677-41e9-94ab-c2fcb15c2eeb
DEFINE_GUID(
   FWPM_CALLOUT_SET_OPTIONS_AUTH_CONNECT_LAYER_V4,
   0xbc582280,
   0x1677,
   0x41e9,
   0x94, 0xab, 0xc2, 0xfc, 0xb1, 0x5c, 0x2e, 0xeb
);

// 98e5373c-b884-490f-b65f-2f6a4a575195
DEFINE_GUID(
   FWPM_CALLOUT_SET_OPTIONS_AUTH_CONNECT_LAYER_V6,
   0x98e5373c,
   0xb884,
   0x490f,
   0xb6, 0x5f, 0x2f, 0x6a, 0x4a, 0x57, 0x51, 0x95
);

// 31b95392-066e-42a2-b7db-92f8acdd56f9
DEFINE_GUID(
   FWPM_CALLOUT_TEREDO_ALE_RESOURCE_ASSIGNMENT_V6,
   0x31b95392,
   0x066e,
   0x42a2,
   0xb7, 0xdb, 0x92, 0xf8, 0xac, 0xdd, 0x56, 0xf9
);

// 81a434e7-f60c-4378-bab8-c625a30f0197
DEFINE_GUID(
   FWPM_CALLOUT_TEREDO_ALE_LISTEN_V6,
   0x81a434e7,
   0xf60c,
   0x4378,
   0xba, 0xb8, 0xc6, 0x25, 0xa3, 0x0f, 0x01, 0x97
);

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in provider contexts.
//
///////////////////////////////////////////////////////////////////////////////

// b25ea800-0d02-46ed-92bd-7fa84bb73e9d
DEFINE_GUID(
   FWPM_PROVIDER_CONTEXT_SECURE_SOCKET_AUTHIP,
   0xb25ea800,
   0x0d02,
   0x46ed,
   0x92, 0xbd, 0x7f, 0xa8, 0x4b, 0xb7, 0x3e, 0x9d
);


// 8c2d4144-f8e0-42c0-94ce-7ccfc63b2f9b
DEFINE_GUID(
   FWPM_PROVIDER_CONTEXT_SECURE_SOCKET_IPSEC,
   0x8c2d4144,
   0xf8e0,
   0x42c0,
   0x94, 0xce, 0x7c, 0xcf, 0xc6, 0x3b, 0x2f, 0x9b
);


///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in keying modules.
//
///////////////////////////////////////////////////////////////////////////////

// a9bbf787-82a8-45bb-a400-5d7e5952c7a9
DEFINE_GUID(
   FWPM_KEYING_MODULE_IKE,
   0xa9bbf787,
   0x82a8,
   0x45bb,
   0xa4, 0x00, 0x5d, 0x7e, 0x59, 0x52, 0xc7, 0xa9
);

// 11e3dae0-dd26-4590-857d-ab4b28d1a095
DEFINE_GUID(
   FWPM_KEYING_MODULE_AUTHIP,
   0x11e3dae0,
   0xdd26,
   0x4590,
   0x85, 0x7d, 0xab, 0x4b, 0x28, 0xd1, 0xa0, 0x95
);

#ifndef GUID_DEFS_ONLY
#ifndef FWPMX_H
#define FWPMX_H

#ifndef _KRPCENV_
#define _KRPCENV_ 1
#endif

#include "fwpmtypes.h"

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Well-known filter weight ranges.
//
///////////////////////////////////////////////////////////////////////////////

// Number of bits used for auto-generated weights.
#define FWPM_AUTO_WEIGHT_BITS (60)
// Maximum auto-generated weight.
#define FWPM_AUTO_WEIGHT_MAX  (MAXUINT64 >> (64 - FWPM_AUTO_WEIGHT_BITS))
// Maximum allowed weight range.
#define FWPM_WEIGHT_RANGE_MAX (MAXUINT64 >> FWPM_AUTO_WEIGHT_BITS)

// IPsec policy
#define FWPM_WEIGHT_RANGE_IPSEC            (0x0)
// Filters to exempt IKE traffic from IPsec.
#define FWPM_WEIGHT_RANGE_IKE_EXEMPTIONS   (0xc)


///////////////////////////////////////////////////////////////////////////////
//
// IPsec transform constants.
//
///////////////////////////////////////////////////////////////////////////////

//////////
// Authentication transform constants
//////////

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_HMAC_MD5_96 =
{
   IPSEC_AUTH_MD5,
   IPSEC_AUTH_CONFIG_HMAC_MD5_96
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_HMAC_SHA_1_96 =
{
   IPSEC_AUTH_SHA_1,
   IPSEC_AUTH_CONFIG_HMAC_SHA_1_96
};

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_HMAC_SHA_256_128 =
{
   IPSEC_AUTH_SHA_256,
   IPSEC_AUTH_CONFIG_HMAC_SHA_256_128
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_GCM_AES_128 =
{
   IPSEC_AUTH_AES_128,
   IPSEC_AUTH_CONFIG_GCM_AES_128
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_GCM_AES_192 =
{
   IPSEC_AUTH_AES_192,
   IPSEC_AUTH_CONFIG_GCM_AES_192
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_GCM_AES_256 =
{
   IPSEC_AUTH_AES_256,
   IPSEC_AUTH_CONFIG_GCM_AES_256
};

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

//////////
// Cipher transform constants
//////////

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_CBC_DES =
{
   IPSEC_CIPHER_TYPE_DES,
   IPSEC_CIPHER_CONFIG_CBC_DES
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_CBC_3DES =
{
   IPSEC_CIPHER_TYPE_3DES,
   IPSEC_CIPHER_CONFIG_CBC_3DES
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_AES_128 =
{
   IPSEC_CIPHER_TYPE_AES_128,
   IPSEC_CIPHER_CONFIG_CBC_AES_128
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_AES_192 =
{
   IPSEC_CIPHER_TYPE_AES_192,
   IPSEC_CIPHER_CONFIG_CBC_AES_192
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_AES_256 =
{
   IPSEC_CIPHER_TYPE_AES_256,
   IPSEC_CIPHER_CONFIG_CBC_AES_256
};

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_GCM_AES_128 =
{
   IPSEC_CIPHER_TYPE_AES_128,
   IPSEC_CIPHER_CONFIG_GCM_AES_128
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_GCM_AES_192 =
{
   IPSEC_CIPHER_TYPE_AES_192,
   IPSEC_CIPHER_CONFIG_GCM_AES_192
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_GCM_AES_256 =
{
   IPSEC_CIPHER_TYPE_AES_256,
   IPSEC_CIPHER_CONFIG_GCM_AES_256
};

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

///////////////////////////////////////////////////////////////////////////////
//
// Well-known filter contexts.
//
///////////////////////////////////////////////////////////////////////////////

// IPSec transport filter contexts in inbound layer
#define FWPM_CONTEXT_IPSEC_INBOUND_PASSTHRU (0x1ui64)
#define FWPM_CONTEXT_IPSEC_INBOUND_PERSIST_CONNECTION_SECURITY (0x2ui64)
#define FWPM_CONTEXT_IPSEC_INBOUND_RESERVED (0xff00000000000000ui64)

// IPSec transport filter contexts in outbound layer
#define FWPM_CONTEXT_IPSEC_OUTBOUND_NEGOTIATE_DISCOVER (0x1ui64)

// Filter contexts used in the ALE connect layer
#define FWPM_CONTEXT_ALE_SET_CONNECTION_REQUIRE_IPSEC_SECURITY (0x2ui64)
#define FWPM_CONTEXT_ALE_SET_CONNECTION_LAZY_SD_EVALUATION (0x4ui64)

// Filter contexts used in the ALE connect or accept layer
#define FWPM_CONTEXT_ALE_SET_CONNECTION_REQUIRE_IPSEC_ENCRYPTION (0x8ui64)

// Contexts used by the TCP Chimney Offload callouts.
#define FWPM_CONTEXT_TCP_CHIMNEY_OFFLOAD_ENABLE (0x1ui64)
#define FWPM_CONTEXT_TCP_CHIMNEY_OFFLOAD_DISABLE (0x2ui64)

// Contexts used in the RPC audit sublayer
#define FWPM_CONTEXT_RPC_AUDIT_ENABLED (0x1ui64)

///////////////////////////////////////////////////////////////////////////////
//
// Access rights
//
///////////////////////////////////////////////////////////////////////////////

// Specific access rights.
#define FWPM_ACTRL_ADD               (0x00000001)
#define FWPM_ACTRL_ADD_LINK          (0x00000002)
#define FWPM_ACTRL_BEGIN_READ_TXN    (0x00000004)
#define FWPM_ACTRL_BEGIN_WRITE_TXN   (0x00000008)
#define FWPM_ACTRL_CLASSIFY          (0x00000010)
#define FWPM_ACTRL_ENUM              (0x00000020)
#define FWPM_ACTRL_OPEN              (0x00000040)
#define FWPM_ACTRL_READ              (0x00000080)
#define FWPM_ACTRL_READ_STATS        (0x00000100)
#define FWPM_ACTRL_SUBSCRIBE         (0x00000200)
#define FWPM_ACTRL_WRITE             (0x00000400)

// Generic access rights.
#define FWPM_GENERIC_READ \
      ( STANDARD_RIGHTS_READ       | \
        FWPM_ACTRL_BEGIN_READ_TXN  | \
        FWPM_ACTRL_CLASSIFY        | \
        FWPM_ACTRL_OPEN            | \
        FWPM_ACTRL_READ            | \
        FWPM_ACTRL_READ_STATS      )

#define FWPM_GENERIC_EXECUTE \
      ( STANDARD_RIGHTS_EXECUTE    | \
        FWPM_ACTRL_ENUM            | \
        FWPM_ACTRL_SUBSCRIBE       )

#define FWPM_GENERIC_WRITE \
      ( STANDARD_RIGHTS_WRITE      | \
        DELETE                     | \
        FWPM_ACTRL_ADD             | \
        FWPM_ACTRL_ADD_LINK        | \
        FWPM_ACTRL_BEGIN_WRITE_TXN | \
        FWPM_ACTRL_WRITE           )

#define FWPM_GENERIC_ALL \
      ( STANDARD_RIGHTS_REQUIRED   | \
        FWPM_ACTRL_ADD             | \
        FWPM_ACTRL_ADD_LINK        | \
        FWPM_ACTRL_BEGIN_READ_TXN  | \
        FWPM_ACTRL_BEGIN_WRITE_TXN | \
        FWPM_ACTRL_CLASSIFY        | \
        FWPM_ACTRL_ENUM            | \
        FWPM_ACTRL_OPEN            | \
        FWPM_ACTRL_READ            | \
        FWPM_ACTRL_READ_STATS      | \
        FWPM_ACTRL_SUBSCRIBE       | \
        FWPM_ACTRL_WRITE           )


///////////////////////////////////////////////////////////////////////////////
//
// Common utility functions.
//
///////////////////////////////////////////////////////////////////////////////

void NTAPI FwpmFreeMemory0(IN OUT void** p);


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing the engine.
//
///////////////////////////////////////////////////////////////////////////////

typedef void (CALLBACK *FWPM_SERVICE_STATE_CHANGE_CALLBACK0)(
                           IN OUT void* context,
                           IN FWPM_SERVICE_STATE newState
                           );

FWPM_SERVICE_STATE NTAPI FwpmBfeStateGet0(void);

NTSTATUS
NTAPI
FwpmBfeStateSubscribeChanges0(
   IN OUT void* deviceObject,
   IN FWPM_SERVICE_STATE_CHANGE_CALLBACK0 callback,
   IN OPTIONAL void* context,
   OUT HANDLE* changeHandle
   );

NTSTATUS
NTAPI
FwpmBfeStateUnsubscribeChanges0(
   IN HANDLE changeHandle
   );

NTSTATUS
NTAPI
FwpmEngineOpen0(
   IN OPTIONAL const wchar_t* serverName,
   IN UINT32 authnService,
   IN OPTIONAL SEC_WINNT_AUTH_IDENTITY_W* authIdentity,
   IN OPTIONAL const FWPM_SESSION0* session,
   OUT HANDLE* engineHandle
   );

NTSTATUS
NTAPI
FwpmEngineClose0(IN HANDLE engineHandle);

NTSTATUS
NTAPI
FwpmEngineGetOption0(
   IN HANDLE engineHandle,
   IN FWPM_ENGINE_OPTION option,
   OUT FWP_VALUE0** value
   );

NTSTATUS
NTAPI
FwpmEngineSetOption0(
   IN HANDLE engineHandle,
   IN FWPM_ENGINE_OPTION option,
   IN const FWP_VALUE0* newValue
   );

NTSTATUS
NTAPI
FwpmEngineGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmEngineSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

NTSTATUS
NTAPI
FwpmSessionCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_SESSION_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmSessionEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_SESSION0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmSessionDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for explicit transactions.
//
///////////////////////////////////////////////////////////////////////////////

#define FWPM_TXN_READ_ONLY (0x00000001)

NTSTATUS
NTAPI
FwpmTransactionBegin0(
   IN HANDLE engineHandle,
   IN UINT32 flags
   );

NTSTATUS
NTAPI
FwpmTransactionCommit0(IN HANDLE engineHandle);

NTSTATUS
NTAPI
FwpmTransactionAbort0(IN HANDLE engineHandle);


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing providers.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmProviderAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_PROVIDER0* provider,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd
   );

NTSTATUS
NTAPI
FwpmProviderDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

NTSTATUS
NTAPI
FwpmProviderGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_PROVIDER0** provider
   );

NTSTATUS
NTAPI
FwpmProviderCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_PROVIDER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmProviderEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_PROVIDER0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmProviderDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmProviderGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmProviderSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing provider contexts.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmProviderContextAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_PROVIDER_CONTEXT0* providerContext,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd,
   OUT OPTIONAL UINT64* id
   );

NTSTATUS
NTAPI
FwpmProviderContextDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

NTSTATUS
NTAPI
FwpmProviderContextDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

NTSTATUS
NTAPI
FwpmProviderContextGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT FWPM_PROVIDER_CONTEXT0** providerContext
   );

NTSTATUS
NTAPI
FwpmProviderContextGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_PROVIDER_CONTEXT0** providerContext
   );

NTSTATUS
NTAPI
FwpmProviderContextCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_PROVIDER_CONTEXT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmProviderContextEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_PROVIDER_CONTEXT0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmProviderContextDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmProviderContextGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmProviderContextSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing sub-layers.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmSubLayerAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_SUBLAYER0* subLayer,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd
   );

NTSTATUS
NTAPI
FwpmSubLayerDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

NTSTATUS
NTAPI
FwpmSubLayerGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_SUBLAYER0** subLayer
   );

NTSTATUS
NTAPI
FwpmSubLayerCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_SUBLAYER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmSubLayerEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_SUBLAYER0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmSubLayerDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmSubLayerGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmSubLayerSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing layers.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmLayerGetById0(
   HANDLE engineHandle,
   IN UINT16 id,
   OUT FWPM_LAYER0** layer
   );

NTSTATUS
NTAPI
FwpmLayerGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_LAYER0** layer
   );

NTSTATUS
NTAPI
FwpmLayerCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_LAYER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmLayerEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_LAYER0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmLayerDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmLayerGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmLayerSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing callouts.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmCalloutAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_CALLOUT0* callout,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd,
   OUT OPTIONAL UINT32* id
   );

NTSTATUS
NTAPI
FwpmCalloutDeleteById0(
   IN HANDLE engineHandle,
   IN UINT32 id
   );

NTSTATUS
NTAPI
FwpmCalloutDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

NTSTATUS
NTAPI
FwpmCalloutGetById0(
   HANDLE engineHandle,
   IN UINT32 id,
   OUT FWPM_CALLOUT0** callout
   );

NTSTATUS
NTAPI
FwpmCalloutGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_CALLOUT0** callout
   );

NTSTATUS
NTAPI
FwpmCalloutCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_CALLOUT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmCalloutEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_CALLOUT0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmCalloutDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmCalloutGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmCalloutSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing filters.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmFilterAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_FILTER0* filter,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd,
   OUT OPTIONAL UINT64* id
   );

NTSTATUS
NTAPI
FwpmFilterDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

NTSTATUS
NTAPI
FwpmFilterDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

NTSTATUS
NTAPI
FwpmFilterGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT FWPM_FILTER0** filter
   );

NTSTATUS
NTAPI
FwpmFilterGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_FILTER0** filter
   );

NTSTATUS
NTAPI
FwpmFilterCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_FILTER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmFilterEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_FILTER0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmFilterDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmFilterGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmFilterSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Helper functions for configuring an IPsec tunnel.
//
///////////////////////////////////////////////////////////////////////////////

// Create a point-to-point tunnel.
#define FWPM_TUNNEL_FLAG_POINT_TO_POINT (0x00000001)

NTSTATUS
NTAPI
FwpmIPsecTunnelAdd0(
   IN HANDLE engineHandle,
   IN UINT32 flags,
   IN OPTIONAL const FWPM_PROVIDER_CONTEXT0* mainModePolicy,
   IN const FWPM_PROVIDER_CONTEXT0* tunnelPolicy,
   IN UINT32 numFilterConditions,
   IN const FWPM_FILTER_CONDITION0* filterConditions,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd
   );

NTSTATUS
NTAPI
FwpmIPsecTunnelDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing IPsec.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
IPsecGetStatistics0(
   IN HANDLE engineHandle,
   OUT IPSEC_STATISTICS0* ipsecStatistics
   );

NTSTATUS
NTAPI
IPsecSaContextCreate0(
   IN HANDLE engineHandle,
   IN const IPSEC_TRAFFIC0* outboundTraffic,
   OUT OPTIONAL UINT64* inboundFilterId,
   OUT UINT64* id
   );

NTSTATUS
NTAPI
IPsecSaContextDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

NTSTATUS
NTAPI
IPsecSaContextGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT IPSEC_SA_CONTEXT0** saContext
   );

NTSTATUS
NTAPI
IPsecSaContextGetSpi0(
   IN HANDLE engineHandle,
   IN UINT64 id,
   IN const IPSEC_GETSPI0* getSpi,
   OUT IPSEC_SA_SPI* inboundSpi
   );

NTSTATUS
NTAPI
IPsecSaContextAddInbound0(
   IN HANDLE engineHandle,
   IN UINT64 id,
   IN const IPSEC_SA_BUNDLE0* inboundBundle
   );

NTSTATUS
NTAPI
IPsecSaContextAddOutbound0(
   IN HANDLE engineHandle,
   IN UINT64 id,
   IN const IPSEC_SA_BUNDLE0* outboundBundle
   );

NTSTATUS
NTAPI
IPsecSaContextExpire0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

NTSTATUS
NTAPI
IPsecSaContextCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const IPSEC_SA_CONTEXT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
IPsecSaContextEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT IPSEC_SA_CONTEXT0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
IPsecSaContextDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
IPsecSaCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const IPSEC_SA_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
IPsecSaEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT IPSEC_SA_DETAILS0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
IPsecSaDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
IPsecSaDbGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
IPsecSaDbSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing IKE, Authip.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
IkeextGetStatistics0(
   IN HANDLE engineHandle,
   OUT IKEEXT_STATISTICS0* ikeextStatistics
   );

NTSTATUS
NTAPI
IkeextSaDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

NTSTATUS
NTAPI
IkeextSaGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT IKEEXT_SA_DETAILS0** sa
   );

NTSTATUS
NTAPI
IkeextSaCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const IKEEXT_SA_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
IkeextSaEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT IKEEXT_SA_DETAILS0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
IkeextSaDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
IkeextSaDbGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
IkeextSaDbSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

///////////////////////////////////////////////////////////////////////////////
//
// Functions for diagnostics.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmNetEventCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_NET_EVENT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmNetEventEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_NET_EVENT0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmNetEventDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmNetEventsGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmNetEventsSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

#ifdef __cplusplus
}
#endif
#endif // FWPMX_H
#endif // GUID_DEFS_ONLY
#endif // (NTDDI_VERSION >= NTDDI_WIN6)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusCachedBitmap.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   CachedBitmap class definition
*
* Abstract:
*
*   GDI+ CachedBitmap is a representation of an accelerated drawing
*   that has restrictions on what operations are allowed in order
*   to accelerate the drawing to the destination.
*
*   Look for class definition in GdiplusHeaders.h
*
**************************************************************************/

#ifndef _GDIPLUSCACHEDBITMAP_H
#define _GDIPLUSCACHEDBITMAP_H

inline 
CachedBitmap::CachedBitmap(
    IN Bitmap *bitmap, 
    IN Graphics *graphics)
{
    nativeCachedBitmap = NULL;    

    lastResult = DllExports::GdipCreateCachedBitmap(
        (GpBitmap *)bitmap->nativeImage,
        graphics->nativeGraphics,
        &nativeCachedBitmap
    );
}

inline 
CachedBitmap::~CachedBitmap()
{
    DllExports::GdipDeleteCachedBitmap(nativeCachedBitmap);
}

inline Status 
CachedBitmap::GetLastStatus() const 
{
    Status lastStatus = lastResult;
    lastResult = Ok;    
    return (lastStatus);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusColorMatrix.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusColorMatrix.h
*
* Abstract:
*
*  GDI+ Color Matrix object, used with Graphics.DrawImage
*
\**************************************************************************/

#ifndef _GDIPLUSCOLORMATRIX_H
#define _GDIPLUSCOLORMATRIX_H

#if (GDIPVER >= 0x0110)
//----------------------------------------------------------------------------
// Color channel look up table (LUT)
//----------------------------------------------------------------------------

typedef BYTE ColorChannelLUT[256];

//----------------------------------------------------------------------------
// Per-channel Histogram for 8bpp images.
//----------------------------------------------------------------------------

enum HistogramFormat
{
    HistogramFormatARGB,
    HistogramFormatPARGB,
    HistogramFormatRGB,
    HistogramFormatGray,
    HistogramFormatB,
    HistogramFormatG,
    HistogramFormatR,
    HistogramFormatA    
};
#endif //(GDIPVER >= 0x0110)

//----------------------------------------------------------------------------
// Color matrix
//----------------------------------------------------------------------------

struct ColorMatrix
{
    REAL m[5][5];
};

//----------------------------------------------------------------------------
// Color Matrix flags
//----------------------------------------------------------------------------

enum ColorMatrixFlags
{
    ColorMatrixFlagsDefault   = 0,
    ColorMatrixFlagsSkipGrays = 1,
    ColorMatrixFlagsAltGray   = 2
};

//----------------------------------------------------------------------------
// Color Adjust Type
//----------------------------------------------------------------------------

enum ColorAdjustType
{
    ColorAdjustTypeDefault,
    ColorAdjustTypeBitmap,
    ColorAdjustTypeBrush,
    ColorAdjustTypePen,
    ColorAdjustTypeText,
    ColorAdjustTypeCount,
    ColorAdjustTypeAny      // Reserved
};

//----------------------------------------------------------------------------
// Color Map
//----------------------------------------------------------------------------

struct ColorMap
{
    Color oldColor;
    Color newColor;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\fwpsu.h ===
/*
   Copyright (c) Microsoft Corporation

   SYNOPSIS

     Declares the system portion of the FWP API.
*/

#ifndef FWPSX_H
#define FWPSX_H
#if _MSC_VER >= 1020
#pragma once
#endif

#if (NTDDI_VERSION >= NTDDI_WIN6)

#include "fwpstypes.h"
#include "ws2def.h"

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// LUIDs for built-in layers.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum FWPS_BUILTIN_LAYERS_
{
   // Kernel-mode layers
   FWPS_LAYER_INBOUND_IPPACKET_V4,
   FWPS_LAYER_INBOUND_IPPACKET_V4_DISCARD,
   FWPS_LAYER_INBOUND_IPPACKET_V6,
   FWPS_LAYER_INBOUND_IPPACKET_V6_DISCARD,
   FWPS_LAYER_OUTBOUND_IPPACKET_V4,
   FWPS_LAYER_OUTBOUND_IPPACKET_V4_DISCARD,
   FWPS_LAYER_OUTBOUND_IPPACKET_V6,
   FWPS_LAYER_OUTBOUND_IPPACKET_V6_DISCARD,
   FWPS_LAYER_IPFORWARD_V4,
   FWPS_LAYER_IPFORWARD_V4_DISCARD,
   FWPS_LAYER_IPFORWARD_V6,
   FWPS_LAYER_IPFORWARD_V6_DISCARD,
   FWPS_LAYER_INBOUND_TRANSPORT_V4,
   FWPS_LAYER_INBOUND_TRANSPORT_V4_DISCARD,
   FWPS_LAYER_INBOUND_TRANSPORT_V6,
   FWPS_LAYER_INBOUND_TRANSPORT_V6_DISCARD,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V4,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V4_DISCARD,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V6,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V6_DISCARD,
   FWPS_LAYER_STREAM_V4,
   FWPS_LAYER_STREAM_V4_DISCARD,
   FWPS_LAYER_STREAM_V6,
   FWPS_LAYER_STREAM_V6_DISCARD,
   FWPS_LAYER_DATAGRAM_DATA_V4,
   FWPS_LAYER_DATAGRAM_DATA_V4_DISCARD,
   FWPS_LAYER_DATAGRAM_DATA_V6,
   FWPS_LAYER_DATAGRAM_DATA_V6_DISCARD,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V4,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V4_DISCARD,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V6,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V6_DISCARD,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V4,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V4_DISCARD,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V6,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V6_DISCARD,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V4,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V4_DISCARD,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V6,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V6_DISCARD,
   FWPS_LAYER_ALE_AUTH_LISTEN_V4,
   FWPS_LAYER_ALE_AUTH_LISTEN_V4_DISCARD,
   FWPS_LAYER_ALE_AUTH_LISTEN_V6,
   FWPS_LAYER_ALE_AUTH_LISTEN_V6_DISCARD,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V4,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V4_DISCARD,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V6,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V6_DISCARD,
   FWPS_LAYER_ALE_AUTH_CONNECT_V4,
   FWPS_LAYER_ALE_AUTH_CONNECT_V4_DISCARD,
   FWPS_LAYER_ALE_AUTH_CONNECT_V6,
   FWPS_LAYER_ALE_AUTH_CONNECT_V6_DISCARD,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V4,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V4_DISCARD,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V6,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V6_DISCARD,

   // User-mode layers
   FWPS_LAYER_IPSEC_KM_DEMUX_V4,
   FWPS_LAYER_IPSEC_KM_DEMUX_V6,
   FWPS_LAYER_IPSEC_V4,
   FWPS_LAYER_IPSEC_V6,
   FWPS_LAYER_IKEEXT_V4,
   FWPS_LAYER_IKEEXT_V6,
   FWPS_LAYER_RPC_UM,
   FWPS_LAYER_RPC_EPMAP,
   FWPS_LAYER_RPC_EP_ADD,
   FWPS_LAYER_RPC_PROXY_CONN,
   FWPS_LAYER_RPC_PROXY_IF,
   FWPS_BUILTIN_LAYER_MAX
} FWPS_BUILTIN_LAYERS;

#define FWPS_BUILTIN_KM_LAYER_MAX FWPS_LAYER_IPSEC_KM_DEMUX_V4

///////////////////////////////////////////////////////////////////////////////
//
// LUIDs for built-in fields.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum FWPS_FIELDS_INBOUND_IPPACKET_V4_
{
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V4_FLAGS,
   FWPS_FIELD_INBOUND_IPPACKET_V4_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_MAX
} FWPS_FIELDS_INBOUND_IPPACKET_V4;

typedef enum FWPS_FIELDS_INBOUND_IPPACKET_V6_
{
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V6_FLAGS,
   FWPS_FIELD_INBOUND_IPPACKET_V6_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_MAX
} FWPS_FIELDS_INBOUND_IPPACKET_V6;

typedef enum FWPS_FIELDS_OUTBOUND_IPPACKET_V4_
{
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_FLAGS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_MAX
} FWPS_FIELDS_OUTBOUND_IPPACKET_V4;

typedef enum FWPS_FIELDS_OUTBOUND_IPPACKET_V6_
{
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_FLAGS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_MAX
} FWPS_FIELDS_OUTBOUND_IPPACKET_V6;

typedef enum FWPS_FIELDS_IPFORWARD_V4_
{
   FWPS_FIELD_IPFORWARD_V4_IP_SOURCE_ADDRESS,
   FWPS_FIELD_IPFORWARD_V4_IP_DESTINATION_ADDRESS,
   FWPS_FIELD_IPFORWARD_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_IPFORWARD_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_IPFORWARD_V4_IP_FORWARD_INTERFACE,
   FWPS_FIELD_IPFORWARD_V4_SOURCE_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_SOURCE_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_DESTINATION_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_DESTINATION_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_FLAGS,
   FWPS_FIELD_IPFORWARD_V4_MAX
} FWPS_FIELDS_IPFORWARD_V4;

typedef enum FWPS_FIELDS_IPFORWARD_V6_
{
   FWPS_FIELD_IPFORWARD_V6_IP_SOURCE_ADDRESS,
   FWPS_FIELD_IPFORWARD_V6_IP_DESTINATION_ADDRESS,
   FWPS_FIELD_IPFORWARD_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_IPFORWARD_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_IPFORWARD_V6_IP_FORWARD_INTERFACE,
   FWPS_FIELD_IPFORWARD_V6_SOURCE_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_SOURCE_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_DESTINATION_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_DESTINATION_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_FLAGS,
   FWPS_FIELD_IPFORWARD_V6_MAX
} FWPS_FIELDS_IPFORWARD_V6;

typedef enum FWPS_FIELDS_INBOUND_TRANSPORT_V4_
{
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_PROTOCOL,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_FLAGS,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_MAX
} FWPS_FIELDS_INBOUND_TRANSPORT_V4;

#define FWPS_FIELD_INBOUND_TRANSPORT_V4_ICMP_TYPE \
        FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_INBOUND_TRANSPORT_V4_ICMP_CODE \
        FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_INBOUND_TRANSPORT_V6_
{
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_PROTOCOL,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_FLAGS,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_MAX
} FWPS_FIELDS_INBOUND_TRANSPORT_V6;

#define FWPS_FIELD_INBOUND_TRANSPORT_V6_ICMP_TYPE \
        FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_INBOUND_TRANSPORT_V6_ICMP_CODE \
        FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_OUTBOUND_TRANSPORT_V4_
{
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_PROTOCOL,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_FLAGS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_MAX
} FWPS_FIELDS_OUTBOUND_TRANSPORT_V4;

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V4_ICMP_TYPE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V4_ICMP_CODE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_OUTBOUND_TRANSPORT_V6_
{
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_PROTOCOL,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_FLAGS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_MAX
} FWPS_FIELDS_OUTBOUND_TRANSPORT_V6;

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V6_ICMP_TYPE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V6_ICMP_CODE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_STREAM_V4_
{
   FWPS_FIELD_STREAM_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_STREAM_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_STREAM_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_STREAM_V4_IP_LOCAL_PORT,
   FWPS_FIELD_STREAM_V4_IP_REMOTE_PORT,
   FWPS_FIELD_STREAM_V4_DIRECTION,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_STREAM_V4_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)         
   FWPS_FIELD_STREAM_V4_MAX
} FWPS_FIELDS_STREAM_V4;

typedef enum FWPS_FIELDS_STREAM_V6_
{
   FWPS_FIELD_STREAM_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_STREAM_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_STREAM_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_STREAM_V6_IP_LOCAL_PORT,
   FWPS_FIELD_STREAM_V6_IP_REMOTE_PORT,
   FWPS_FIELD_STREAM_V6_DIRECTION,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_STREAM_V6_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)    
   FWPS_FIELD_STREAM_V6_MAX
} FWPS_FIELDS_STREAM_V6;

typedef enum FWPS_FIELDS_DATAGRAM_DATA_V4_
{
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_PROTOCOL,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_REMOTE_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_DATAGRAM_DATA_V4_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V4_DIRECTION,
   FWPS_FIELD_DATAGRAM_DATA_V4_FLAGS,
   FWPS_FIELD_DATAGRAM_DATA_V4_INTERFACE_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V4_TUNNEL_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V4_MAX
} FWPS_FIELDS_DATAGRAM_DATA_V4;

#define FWPS_FIELD_DATAGRAM_DATA_V4_ICMP_TYPE \
        FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_PORT

#define FWPS_FIELD_DATAGRAM_DATA_V4_ICMP_CODE \
        FWPS_FIELD_DATAGRAM_DATA_V4_IP_REMOTE_PORT


typedef enum FWPS_FIELDS_DATAGRAM_DATA_V6_
{
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_PROTOCOL,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_REMOTE_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_DATAGRAM_DATA_V6_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V6_DIRECTION,
   FWPS_FIELD_DATAGRAM_DATA_V6_FLAGS,
   FWPS_FIELD_DATAGRAM_DATA_V6_INTERFACE_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V6_TUNNEL_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V6_MAX
} FWPS_FIELDS_DATAGRAM_DATA_V6;

#define FWPS_FIELD_DATAGRAM_DATA_V6_ICMP_TYPE \
        FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_PORT

#define FWPS_FIELD_DATAGRAM_DATA_V6_ICMP_CODE \
        FWPS_FIELD_DATAGRAM_DATA_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_INBOUND_ICMP_ERROR_V4_
{
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_PROTOCOL,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_LOCAL_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_REMOTE_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ICMP_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ICMP_CODE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_INDEX,      // of local/delivery interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_SUB_INTERFACE_INDEX,  // of arrival interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_TYPE,       // of local/delivery interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_TUNNEL_TYPE,          // of local/delivery interface
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_ARRIVAL_INTERFACE,   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ARRIVAL_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ARRIVAL_INTERFACE_TYPE,   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ARRIVAL_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_MAX
} FWPS_FIELDS_INBOUND_ICMP_ERROR_V4;

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V4_LOCAL_INTERFACE_INDEX \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_INDEX

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V4_SUB_INTERFACE_INDEX

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V4_LOCAL_INTERFACE_TYPE \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_TYPE

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V4_LOCAL_TUNNEL_TYPE \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V4_TUNNEL_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

typedef enum FWPS_FIELDS_INBOUND_ICMP_ERROR_V6_
{
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_PROTOCOL,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_LOCAL_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_REMOTE_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ICMP_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ICMP_CODE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_INDEX,      // of local/delivery interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_SUB_INTERFACE_INDEX,  // of arrival interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_TYPE,       // of local/delivery interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_TUNNEL_TYPE,          // of local/delivery interface
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_ARRIVAL_INTERFACE,   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ARRIVAL_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ARRIVAL_INTERFACE_TYPE,   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ARRIVAL_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_MAX
} FWPS_FIELDS_INBOUND_ICMP_ERROR_V6;

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)   

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V6_LOCAL_INTERFACE_INDEX \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_INDEX

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V6_SUB_INTERFACE_INDEX

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V6_LOCAL_INTERFACE_TYPE \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_TYPE

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V6_LOCAL_TUNNEL_TYPE \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V6_TUNNEL_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

typedef enum FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V4_
{
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_ICMP_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_ICMP_CODE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_MAX
} FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V4;

typedef enum FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V6_
{
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_PORT,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_REMOTE_PORT,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_MAX
} FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V6;

#define FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_ICMP_TYPE \
        FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_PORT

#define FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_ICMP_CODE \
        FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V4_
{
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_ALE_PROMISCUOUS_MODE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_FLAGS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_TUNNEL_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_MAX
} FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V4;

typedef enum FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V6_
{
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_ALE_PROMISCUOUS_MODE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_FLAGS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_TUNNEL_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_MAX
} FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V6;

typedef enum FWPS_FIELDS_ALE_AUTH_LISTEN_V4_
{
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_FLAGS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_MAX
} FWPS_FIELDS_ALE_AUTH_LISTEN_V4;

typedef enum FWPS_FIELDS_ALE_AUTH_LISTEN_V6_
{
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_FLAGS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_MAX
} FWPS_FIELDS_ALE_AUTH_LISTEN_V6;

typedef enum FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V4_
{
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_FLAGS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_SIO_FIREWALL_SYSTEM_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_NAP_CONTEXT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_TYPE,      // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_TUNNEL_TYPE,         // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_INDEX,     // of local/delivery interface   
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_SUB_INTERFACE_INDEX, // of arrival interface
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_ARRIVAL_INTERFACE,   
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ARRIVAL_INTERFACE_TYPE,   
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ARRIVAL_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ARRIVAL_INTERFACE_INDEX,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_MAX
} FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V4;

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_PORT
        
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_LOCAL_INTERFACE_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_TYPE
        
#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_LOCAL_TUNNEL_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_TUNNEL_TYPE
        
#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_LOCAL_INTERFACE_INDEX \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_INDEX        

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_SUB_INTERFACE_INDEX        

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

typedef enum FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V6_
{
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_FLAGS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_SIO_FIREWALL_SYSTEM_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_NAP_CONTEXT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_TYPE,      // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_TUNNEL_TYPE,         // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_INDEX,     // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_SUB_INTERFACE_INDEX, // of arrival interface
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_ARRIVAL_INTERFACE,    
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ARRIVAL_INTERFACE_TYPE,   
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ARRIVAL_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ARRIVAL_INTERFACE_INDEX,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_MAX
} FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V6;

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_PORT
        
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_LOCAL_INTERFACE_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_TYPE
        
#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_LOCAL_TUNNEL_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_TUNNEL_TYPE

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_LOCAL_INTERFACE_INDEX \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_INDEX
        
#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_SUB_INTERFACE_INDEX        

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

typedef enum FWPS_FIELDS_ALE_AUTH_CONNECT_V4_
{
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_FLAGS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_INTERFACE_INDEX,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_SUB_INTERFACE_INDEX,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_MAX
} FWPS_FIELDS_ALE_AUTH_CONNECT_V4;

#define FWPS_FIELD_ALE_AUTH_CONNECT_V4_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_CONNECT_V4_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_AUTH_CONNECT_V6_
{
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_FLAGS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_INTERFACE_INDEX,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_SUB_INTERFACE_INDEX,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_MAX
} FWPS_FIELDS_ALE_AUTH_CONNECT_V6;

#define FWPS_FIELD_ALE_AUTH_CONNECT_V6_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_CONNECT_V6_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V4_
{
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_DIRECTION,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)   
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_MAX
} FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V4;

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ICMP_TYPE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ICMP_CODE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V6_
{
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_DIRECTION,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)      
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_MAX
} FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V6;

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ICMP_TYPE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ICMP_CODE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_IPSEC_KM_DEMUX_V4_
{
   FWPS_FIELD_IPSEC_KM_DEMUX_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V4_MAX
} FWPS_FIELDS_IPSEC_KM_DEMUX_V4;

typedef enum FWPS_FIELDS_IPSEC_KM_DEMUX_V6_
{
   FWPS_FIELD_IPSEC_KM_DEMUX_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V6_MAX
} FWPS_FIELDS_IPSEC_KM_DEMUX_V6;

typedef enum FWPS_FIELDS_IPSEC_V4_
{
   FWPS_FIELD_IPSEC_V4_IP_PROTOCOL,
   FWPS_FIELD_IPSEC_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_V4_IP_LOCAL_PORT,
   FWPS_FIELD_IPSEC_V4_IP_REMOTE_PORT,
   FWPS_FIELD_IPSEC_V4_MAX
} FWPS_FIELDS_IPSEC_V4;

typedef enum FWPS_FIELDS_IPSEC_V6_
{
   FWPS_FIELD_IPSEC_V6_IP_PROTOCOL,
   FWPS_FIELD_IPSEC_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_V6_IP_LOCAL_PORT,
   FWPS_FIELD_IPSEC_V6_IP_REMOTE_PORT,
   FWPS_FIELD_IPSEC_V6_MAX
} FWPS_FIELDS_IPSEC_V6;

typedef enum FWPS_FIELDS_IKEEXT_V4_
{
   FWPS_FIELD_IKEEXT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IKEEXT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IKEEXT_V4_MAX
} FWPS_FIELDS_IKEEXT_V4;

typedef enum FWPS_FIELDS_IKEEXT_V6_
{
   FWPS_FIELD_IKEEXT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IKEEXT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IKEEXT_V6_MAX
} FWPS_FIELDS_IKEEXT_V6;

typedef enum FWPS_FIELDS_RPC_UM_
{
   FWPS_FIELD_RPC_UM_REMOTE_USER_TOKEN,
   FWPS_FIELD_RPC_UM_IF_UUID,
   FWPS_FIELD_RPC_UM_IF_VERSION,
   FWPS_FIELD_RPC_UM_IF_FLAG,
   FWPS_FIELD_RPC_UM_DCOM_APP_ID,
   FWPS_FIELD_RPC_UM_IMAGE_NAME,
   FWPS_FIELD_RPC_UM_PROTOCOL,
   FWPS_FIELD_RPC_UM_AUTH_TYPE,
   FWPS_FIELD_RPC_UM_AUTH_LEVEL,
   FWPS_FIELD_RPC_UM_SEC_ENCRYPT_ALGORITHM,
   FWPS_FIELD_RPC_UM_SEC_KEY_SIZE,
   FWPS_FIELD_RPC_UM_LOCAL_ADDR_V4,
   FWPS_FIELD_RPC_UM_LOCAL_ADDR_V6,
   FWPS_FIELD_RPC_UM_LOCAL_PORT,
   FWPS_FIELD_RPC_UM_PIPE,
   FWPS_FIELD_RPC_UM_REMOTE_ADDR_V4,
   FWPS_FIELD_RPC_UM_REMOTE_ADDR_V6,
   FWPS_FIELD_RPC_UM_MAX
} FWPS_FIELDS_RPC_UM;

typedef enum FWPS_FIELDS_RPC_EPMAP_
{
   FWPS_FIELD_RPC_EPMAP_REMOTE_USER_TOKEN,
   FWPS_FIELD_RPC_EPMAP_IF_UUID,
   FWPS_FIELD_RPC_EPMAP_IF_VERSION,
   FWPS_FIELD_RPC_EPMAP_PROTOCOL,
   FWPS_FIELD_RPC_EPMAP_AUTH_TYPE,
   FWPS_FIELD_RPC_EPMAP_AUTH_LEVEL,
   FWPS_FIELD_RPC_EPMAP_SEC_ENCRYPT_ALGORITHM,
   FWPS_FIELD_RPC_EPMAP_SEC_KEY_SIZE,
   FWPS_FIELD_RPC_EPMAP_LOCAL_ADDR_V4,
   FWPS_FIELD_RPC_EPMAP_LOCAL_ADDR_V6,
   FWPS_FIELD_RPC_EPMAP_LOCAL_PORT,
   FWPS_FIELD_RPC_EPMAP_PIPE,
   FWPS_FIELD_RPC_EPMAP_REMOTE_ADDR_V4,
   FWPS_FIELD_RPC_EPMAP_REMOTE_ADDR_V6,
   FWPS_FIELD_RPC_EPMAP_MAX
} FWPS_FIELDS_RPC_EPMAP;

typedef enum FWPS_FIELDS_RPC_EP_ADD_
{
   FWPS_FIELD_RPC_EP_ADD_PROCESS_WITH_RPC_IF_UUID,
   FWPS_FIELD_RPC_EP_ADD_PROTOCOL,
   FWPS_FIELD_RPC_EP_ADD_EP_VALUE,
   FWPS_FIELD_RPC_EP_ADD_EP_FLAGS,
   FWPS_FIELD_RPC_EP_ADD_MAX
} FWPS_FIELDS_RPC_EP_ADD;

typedef enum FWPS_FIELDS_RPC_PROXY_CONN_
{
   FWPS_FIELD_RPC_PROXY_CONN_CLIENT_TOKEN,
   FWPS_FIELD_RPC_PROXY_CONN_SERVER_NAME,
   FWPS_FIELD_RPC_PROXY_CONN_SERVER_PORT,
   FWPS_FIELD_RPC_PROXY_CONN_PROXY_AUTH_TYPE,
   FWPS_FIELD_RPC_PROXY_CONN_CLIENT_CERT_KEY_LENGTH,
   FWPS_FIELD_RPC_PROXY_CONN_CLIENT_CERT_OID,
   FWPS_FIELD_RPC_PROXY_CONN_MAX
} FWPS_FIELDS_RPC_PROXY_CONN;

typedef enum FWPS_FIELDS_RPC_PROXY_IF_
{
   FWPS_FIELD_RPC_PROXY_IF_CLIENT_TOKEN,
   FWPS_FIELD_RPC_PROXY_IF_IF_UUID,
   FWPS_FIELD_RPC_PROXY_IF_IF_VERSION,
   FWPS_FIELD_RPC_PROXY_IF_SERVER_NAME,
   FWPS_FIELD_RPC_PROXY_IF_SERVER_PORT,
   FWPS_FIELD_RPC_PROXY_IF_PROXY_AUTH_TYPE,
   FWPS_FIELD_RPC_PROXY_IF_CLIENT_CERT_KEY_LENGTH,
   FWPS_FIELD_RPC_PROXY_IF_CLIENT_CERT_OID,
   FWPS_FIELD_RPC_PROXY_IF_MAX
} FWPS_FIELDS_RPC_PROXY_IF_IF;

///////////////////////////////////////////////////////////////////////////////
//
// Network and transport discard reasons.
//
///////////////////////////////////////////////////////////////////////////////

//
// INET_DISCARD_REASON
//
// Define the reasons given by INET modules for discarding incoming datagrams.
//

#ifndef _INET_DISCARD_REASON_DEFINE_
#define _INET_DISCARD_REASON_DEFINE_

typedef enum {
    InetDiscardSourceUnspecified,
    InetDiscardDestinationMulticast,
    InetDiscardHeaderInvalid,
    InetDiscardChecksumInvalid,
    InetDiscardEndpointNotFound
} INET_DISCARD_REASON, *PINET_DISCARD_REASON;

#endif


#ifndef _IP_DISCARD_REASON_DEFINE_
#define _IP_DISCARD_REASON_DEFINE_

typedef enum {
    //
    // Receive path discard reasons.
    //
    IpDiscardBadSourceAddress = 1,
    IpDiscardNotLocallyDestined,
    IpDiscardProtocolUnreachable,
    IpDiscardPortUnreachable,
    IpDiscardBadLength,
    IpDiscardMalformedHeader,
    IpDiscardNoRoute,
    IpDiscardBeyondScope,
    IpDiscardInspectionDrop,  // Blocked by firewall, ICMP should not be sent.
    IpDiscardTooManyDecapsulations,
    IpDiscardAdministrativelyProhibited, // Blocked, ICMP should be sent.

    IpDiscardReceivePathMax = 127,

    //
    // Forward path discard reasons.
    //
    IpDiscardHopLimitExceeded,
    IpDiscardAddressUnreachable,
    IpDiscardForwardPathMax = 255,

    //
    // Internally used discard reasons.
    //
    IpDiscardArbitrationUnhandled,
    IpDiscardMax
} IP_DISCARD_REASON, *PIP_DISCARD_REASON;

#endif




///////////////////////////////////////////////////////////////////////////////
//
// API for implementing a callout.
//
///////////////////////////////////////////////////////////////////////////////

//////////
// Flags that can specified which entries are present
// in the FWPS_INCOMING_METADATA_VALUES0 structure.
//////////

#define FWPS_METADATA_FIELD_DISCARD_REASON                   0x00000001
#define FWPS_METADATA_FIELD_FLOW_HANDLE                      0x00000002
#define FWPS_METADATA_FIELD_IP_HEADER_SIZE                   0x00000004
#define FWPS_METADATA_FIELD_PROCESS_PATH                     0x00000008
#define FWPS_METADATA_FIELD_TOKEN                            0x00000010
#define FWPS_METADATA_FIELD_PROCESS_ID                       0x00000020
#define FWPS_METADATA_FIELD_SYSTEM_FLAGS                     0x00000040
#define FWPS_METADATA_FIELD_RESERVED                         0x00000080
#define FWPS_METADATA_FIELD_SOURCE_INTERFACE_INDEX           0x00000100
#define FWPS_METADATA_FIELD_DESTINATION_INTERFACE_INDEX      0x00000200
#define FWPS_METADATA_FIELD_TRANSPORT_HEADER_SIZE            0x00000400
#define FWPS_METADATA_FIELD_COMPARTMENT_ID                   0x00000800
#define FWPS_METADATA_FIELD_FRAGMENT_DATA                    0x00001000
#define FWPS_METADATA_FIELD_PATH_MTU                         0x00002000
#define FWPS_METADATA_FIELD_COMPLETION_HANDLE                0x00004000
#define FWPS_METADATA_FIELD_TRANSPORT_ENDPOINT_HANDLE        0x00008000
#define FWPS_METADATA_FIELD_TRANSPORT_CONTROL_DATA           0x00010000
#define FWPS_METADATA_FIELD_REMOTE_SCOPE_ID                  0x00020000
#define FWPS_METADATA_FIELD_PACKET_DIRECTION                 0x00040000
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
#define FWPS_METADATA_FIELD_PACKET_SYSTEM_CRITICAL           0x00080000
#define FWPS_METADATA_FIELD_FORWARD_LAYER_OUTBOUND_PASS_THRU 0x00100000
#define FWPS_METADATA_FIELD_FORWARD_LAYER_INBOUND_PASS_THRU  0x00200000
#define FWPS_METADATA_FIELD_ALE_CLASSIFY_REQUIRED            0x00400000
#define FWPS_METADATA_FIELD_TRANSPORT_HEADER_INCLUDE_HEADER  0x00800000
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// Provides additional meta-information to the filter engine. This information
// is not processed by the filter engine, but is supplied to the callouts.
// Unlike the FWPS_INCOMING_VALUES0, the schema of the meta-information is not
// fixed. Callouts should not assume that a given FWPS_METADATA_FIELD is
// present or that it is located at a given index in the array.

typedef struct FWPS_INCOMING_METADATA_VALUES0_
{
   // Bitmask representing which values are set.
   UINT32 currentMetadataValues;
   // Internal flags;
   UINT32 flags;
   // Reserved for system use.
   UINT64 reserved;
   // Discard module and reason.
   FWPS_DISCARD_METADATA0 discardMetadata;
   // Flow Handle.
   UINT64 flowHandle;
   // IP Header size.
   UINT32 ipHeaderSize;
   // Transport Header size
   UINT32 transportHeaderSize;
   // Process Path.
   FWP_BYTE_BLOB* processPath;
   // Token used for authorization.
   UINT64 token;
   // Process Id.
   UINT64 processId;
   // Source and Destination interface indices for discard indications.
   UINT32 sourceInterfaceIndex;
   UINT32 destinationInterfaceIndex;
   // Compartment Id for injection APIs.
   ULONG compartmentId;
   // Fragment data for inbound fragments.
   FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;
   // Path MTU for outbound packets (to enable calculation of fragments).
   ULONG pathMtu;
   // Completion handle (required in order to be able to pend at this layer).
   HANDLE completionHandle;
   // Endpoint handle for use in outbound transport layer injection.
   UINT64 transportEndpointHandle;
   // Remote scope id for use in outbound transport layer injection.
   SCOPE_ID remoteScopeId;
   // Socket control data (and length) for use in outbound transport layer injection.
   WSACMSGHDR* controlData;
   ULONG controlDataLength;
   // Direction for the current packet. Only specified for ALE re-authorization.
   FWP_DIRECTION packetDirection;
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   // Raw IP header (and length) if the packet is sent with IP header from a RAW socket.
   PVOID headerIncludeHeader;
   ULONG headerIncludeHeaderLength;
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
} FWPS_INCOMING_METADATA_VALUES0;

///////////////////////////////////////////////////////////////////////////////
//
// Macro for checking for metadata fields
//
///////////////////////////////////////////////////////////////////////////////

#define FWPS_IS_METADATA_FIELD_PRESENT(metadataValues, metadataField) \
   (((metadataValues)->currentMetadataValues & (metadataField)) == (metadataField))

// Invoked during classification when a callout filter matches.
typedef void (NTAPI *FWPS_CALLOUT_CLASSIFY_FN0)(
                        IN const FWPS_INCOMING_VALUES0* inFixedValues,
                        IN const FWPS_INCOMING_METADATA_VALUES0* inMetaValues,
                        IN OUT void* layerData,
                        IN const FWPS_FILTER0* filter,
                        IN UINT64 flowContext,
                        OUT FWPS_CLASSIFY_OUT0* classifyOut
                        );

// Notifies the callout that a filter invoking it has been added/deleted.
typedef NTSTATUS (NTAPI *FWPS_CALLOUT_NOTIFY_FN0)(
                            IN FWPS_CALLOUT_NOTIFY_TYPE notifyType,
                            IN const GUID* filterKey,
                            IN OUT FWPS_FILTER0* filter
                            );

// Notifies the callout that a flow has been deleted.
typedef void (NTAPI *FWPS_CALLOUT_FLOW_DELETE_NOTIFY_FN0)(
                        IN UINT16 layerId,
                        IN UINT32 calloutId,
                        IN UINT64 flowContext
                        );

// Notify callout that boottime callout has been removed
typedef void (NTAPI *FWPS_CALLOUT_BOOTTIME_CALLOUT_DELETE_NOTIFY_FN0)(
                        IN UINT32 calloutId
                        );

#ifdef __cplusplus
}
#endif
#endif // (NTDDI_VERSION >= NTDDI_WIN6)
#endif // FWPSX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusBase.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusBase.h
*
* Abstract:
*
*   GDI+ base memory allocation class
*
\**************************************************************************/

#ifndef _GDIPLUSBASE_H
#define _GDIPLUSBASE_H

class GdiplusBase
{
public:
    void (operator delete)(void* in_pVoid)
    {
       DllExports::GdipFree(in_pVoid);
    }
    void* (operator new)(size_t in_size)
    {
       return DllExports::GdipAlloc(in_size);
    }
    void (operator delete[])(void* in_pVoid)
    {
       DllExports::GdipFree(in_pVoid);
    }
    void* (operator new[])(size_t in_size)
    {
       return DllExports::GdipAlloc(in_size);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusBrush.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusBrush.h
*
* Abstract:
*
*   GDI+ Brush class
*
\**************************************************************************/

#ifndef _GDIPLUSBRUSH_H
#define _GDIPLUSBRUSH_H

class GraphicsPath;

//--------------------------------------------------------------------------
// Abstract base class for various brush types
//--------------------------------------------------------------------------

class Brush : public GdiplusBase
{
public:
    friend class Pen;
    friend class Graphics;

    virtual ~Brush()
    {
        DllExports::GdipDeleteBrush(nativeBrush);
    }

    virtual Brush* Clone() const
    {
        GpBrush *brush = NULL;

        SetStatus(DllExports::GdipCloneBrush(nativeBrush, &brush));

        Brush *newBrush = new Brush(brush, lastResult);
        
        if (newBrush == NULL) 
        {
            DllExports::GdipDeleteBrush(brush);
        }

        return newBrush;
    }

    BrushType GetType() const
    {
        BrushType type = static_cast<BrushType>(-1);

        SetStatus(DllExports::GdipGetBrushType(nativeBrush, &type));

        return type;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:

    Brush()
    {
        SetStatus(NotImplemented);
    }

private:
    Brush(const Brush& brush);
    Brush& operator=(const Brush& brush);
protected:

    Brush(GpBrush* nativeBrush, Status status)
    {
        lastResult = status;
        SetNativeBrush(nativeBrush);
    }

    VOID SetNativeBrush(GpBrush* nativeBrush)
    {
        this->nativeBrush = nativeBrush;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpBrush* nativeBrush;
    mutable Status lastResult;
};

//--------------------------------------------------------------------------
// Solid Fill Brush Object
//--------------------------------------------------------------------------

class SolidBrush : public Brush
{
public:
    friend class Pen;

    SolidBrush(IN const Color& color)
    {
        GpSolidFill *brush = NULL;

        lastResult = DllExports::GdipCreateSolidFill(color.GetValue(), &brush);

        SetNativeBrush(brush);
    }

    Status GetColor(OUT Color* color) const
    {
        ARGB argb;

        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        SetStatus(DllExports::GdipGetSolidFillColor((GpSolidFill*)nativeBrush,
                                                    &argb));

        *color = Color(argb);

        return lastResult;
    }

    Status SetColor(IN const Color& color)
    {
        return SetStatus(DllExports::GdipSetSolidFillColor((GpSolidFill*)nativeBrush, 
                                                           color.GetValue()));
    }

private:
    SolidBrush(const SolidBrush &);
    SolidBrush& operator=(const SolidBrush &);

protected:

    SolidBrush()
    {
    }
};

//--------------------------------------------------------------------------
// Texture Brush Fill Object
//--------------------------------------------------------------------------

class TextureBrush : public Brush
{
public:
    friend class Pen;

    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode = WrapModeTile)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture(
                                                  image->nativeImage,
                                                  wrapMode, &texture);

        SetNativeBrush(texture);
    }

    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.
    
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode,
                 IN const RectF &dstRect)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2(
                                                   image->nativeImage,
                                                   wrapMode, 
                                                   dstRect.X, 
                                                   dstRect.Y, 
                                                   dstRect.Width, 
                                                   dstRect.Height,
                                                   &texture);

        SetNativeBrush(texture);
    }
    
    TextureBrush(IN Image *image, 
                 IN const RectF &dstRect,
                 IN const ImageAttributes *imageAttributes = NULL)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTextureIA(
            image->nativeImage,
            (imageAttributes)?imageAttributes->nativeImageAttr:NULL,
            dstRect.X, 
            dstRect.Y, 
            dstRect.Width, 
            dstRect.Height,
            &texture
        );

        SetNativeBrush(texture);
    }
    
    TextureBrush(IN Image *image, 
                 IN const Rect &dstRect,
                 IN const ImageAttributes *imageAttributes = NULL)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTextureIAI(
            image->nativeImage,
            (imageAttributes)?imageAttributes->nativeImageAttr:NULL,
            dstRect.X, 
            dstRect.Y, 
            dstRect.Width, 
            dstRect.Height,
            &texture
        );

        SetNativeBrush(texture);
    }

    TextureBrush(
        IN Image* image,
        IN WrapMode wrapMode,
        
        const IN Rect &dstRect
    )
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2I(
                                                    image->nativeImage,
                                                    wrapMode, 
                                                    dstRect.X, 
                                                    dstRect.Y, 
                                                    dstRect.Width, 
                                                    dstRect.Height,
                                                    &texture);

        SetNativeBrush(texture);
    }
    
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode, 
                 IN REAL dstX, 
                 IN REAL dstY, 
                 IN REAL dstWidth, 
                 IN REAL dstHeight)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2(
                                                   image->nativeImage,
                                                   wrapMode, 
                                                   dstX, 
                                                   dstY, 
                                                   dstWidth, 
                                                   dstHeight,
                                                   &texture);

        SetNativeBrush(texture);
    }
    
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode, 
                 IN INT dstX, 
                 IN INT dstY, 
                 IN INT dstWidth, 
                 IN INT dstHeight)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2I(
                                                    image->nativeImage,
                                                    wrapMode, 
                                                    dstX, 
                                                    dstY, 
                                                    dstWidth, 
                                                    dstHeight,
                                                    &texture);

        SetNativeBrush(texture);
    }

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetTextureTransform((GpTexture*)nativeBrush, 
                                                             matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetTextureTransform((GpTexture*)nativeBrush, 
                                                             matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetTextureTransform((GpTexture*)nativeBrush));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyTextureTransform((GpTexture*)nativeBrush,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx,
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateTextureTransform((GpTexture*)nativeBrush,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleTextureTransform((GpTexture*)nativeBrush,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateTextureTransform((GpTexture*)nativeBrush,
                                                              angle, order));
    }

    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetTextureWrapMode((GpTexture*)nativeBrush, 
                                                            wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetTextureWrapMode((GpTexture*)nativeBrush, 
                                                     &wrapMode));
        return wrapMode;
    }

    Image *GetImage() const
    {
        GpImage *image;

        SetStatus(DllExports::GdipGetTextureImage((GpTexture *)nativeBrush,
                                                  &image));

        Image *retimage = new Image(image, lastResult);

        if (retimage == NULL) 
        {
            DllExports::GdipDisposeImage(image);
        }

        return retimage;
    }

private:
    TextureBrush(const TextureBrush &);
    TextureBrush& operator=(const TextureBrush &);

protected:

    TextureBrush()
    {
    }
};

//--------------------------------------------------------------------------
// Linear Gradient Brush Object
//--------------------------------------------------------------------------

class LinearGradientBrush : public Brush
{
public:
    friend class Pen;

    LinearGradientBrush(IN const PointF& point1,
                        IN const PointF& point2,
                        IN const Color& color1,
                        IN const Color& color2)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrush(&point1,
                                                     &point2,
                                                     color1.GetValue(),
                                                     color2.GetValue(),
                                                     WrapModeTile,
                                                     &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Point& point1,
                        IN const Point& point2,
                        IN const Color& color1,
                        IN const Color& color2)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushI(&point1,
                                                      &point2,
                                                      color1.GetValue(),
                                                      color2.GetValue(),
                                                      WrapModeTile,
                                                      &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const RectF& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN LinearGradientMode mode)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRect(&rect,
                                                             color1.GetValue(),
                                                             color2.GetValue(),
                                                             mode,
                                                             WrapModeTile,
                                                             &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Rect& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN LinearGradientMode mode)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectI(&rect,
                                                              color1.GetValue(),
                                                              color2.GetValue(),
                                                              mode,
                                                              WrapModeTile,
                                                              &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const RectF& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN REAL angle,
                        IN BOOL isAngleScalable = FALSE)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectWithAngle(&rect,
                                                                      color1.GetValue(),
                                                                      color2.GetValue(),
                                                                      angle,
                                                                      isAngleScalable,
                                                                      WrapModeTile,
                                                                      &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Rect& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN REAL angle,
                        IN BOOL isAngleScalable = FALSE)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectWithAngleI(&rect,
                                                                       color1.GetValue(),
                                                                       color2.GetValue(),
                                                                       angle,
                                                                       isAngleScalable,
                                                                       WrapModeTile,
                                                                       &brush);

        SetNativeBrush(brush);
    }

    Status SetLinearColors(IN const Color& color1, 
                           IN const Color& color2)
    {
        return SetStatus(DllExports::GdipSetLineColors((GpLineGradient*)nativeBrush,
                                                       color1.GetValue(),
                                                       color2.GetValue()));
    }

    Status GetLinearColors(OUT Color* colors) const
    {
        ARGB argb[2];

        if (colors == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        Status status = SetStatus(DllExports::GdipGetLineColors((GpLineGradient*) nativeBrush, argb));

        if (status == Ok)
        {
            // use bitwise copy operator for Color copy
            colors[0] = Color(argb[0]);
            colors[1] = Color(argb[1]);
        }

        return status;
    }

    Status GetRectangle(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetLineRect((GpLineGradient*)nativeBrush, rect));
    }

    Status GetRectangle(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetLineRectI((GpLineGradient*)nativeBrush, rect));
    }

    Status SetGammaCorrection(IN BOOL useGammaCorrection)
    {
        return SetStatus(DllExports::GdipSetLineGammaCorrection((GpLineGradient*)nativeBrush,
                    useGammaCorrection));
    }
    
    BOOL GetGammaCorrection() const
    {
        BOOL useGammaCorrection;

        SetStatus(DllExports::GdipGetLineGammaCorrection((GpLineGradient*)nativeBrush,
                    &useGammaCorrection));

        return useGammaCorrection;
    }

    INT GetBlendCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetLineBlendCount((GpLineGradient*)
                                                    nativeBrush,
                                                    &count));

        return count;
    }

    Status SetBlend(IN const REAL* blendFactors, 
                    IN const REAL* blendPositions,
                    IN INT count)
    {
        return SetStatus(DllExports::GdipSetLineBlend((GpLineGradient*)
                                                      nativeBrush,
                                                      blendFactors,
                                                      blendPositions,
                                                      count));
    }

    Status GetBlend(OUT REAL* blendFactors, 
                    OUT REAL* blendPositions, 
                    IN INT count) const 
    {
        return SetStatus(DllExports::GdipGetLineBlend((GpLineGradient*)nativeBrush,
                                                      blendFactors,
                                                      blendPositions,
                                                      count));
    }

    INT GetInterpolationColorCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetLinePresetBlendCount((GpLineGradient*)
                                                          nativeBrush,
                                                          &count));

        return count;
    }

    Status SetInterpolationColors(IN const Color* presetColors,
                                  IN const REAL* blendPositions, 
                                  IN INT count)
    {
        if ((count <= 0) || !presetColors)
            return SetStatus(InvalidParameter);
         
        ARGB *argbs = (ARGB*) new BYTE[count*sizeof(ARGB)];
        
        if (argbs)
        {
            for (INT i = 0; i < count; i++)
            {
                argbs[i] = presetColors[i].GetValue();
            }

            Status status = SetStatus(DllExports::GdipSetLinePresetBlend(
                                                                        (GpLineGradient*) nativeBrush,
                                                                        argbs,
                                                                        blendPositions,
                                                                        count));
            delete [] argbs;
            return status;
        }
        else
        {
            return SetStatus(OutOfMemory);
        }
    }

    Status GetInterpolationColors(OUT Color* presetColors, 
                                  OUT REAL* blendPositions, 
                                  IN INT count) const 
    {
        if ((count <= 0) || !presetColors)
            return SetStatus(InvalidParameter);

        ARGB* argbs = (ARGB*) new BYTE[count*sizeof(ARGB)];
        
        if (!argbs)
        {
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetLinePresetBlend((GpLineGradient*)nativeBrush,
                                                                     argbs,
                                                                     blendPositions,
                                                                     count));
        if (status == Ok) 
        {
            for (INT i = 0; i < count; i++)
            { 
                presetColors[i] = Color(argbs[i]);
            }
        }
        
        delete [] argbs;
        
        return status;
    }

    Status SetBlendBellShape(IN REAL focus, 
                             IN REAL scale = 1.0f)
    {
        return SetStatus(DllExports::GdipSetLineSigmaBlend((GpLineGradient*)nativeBrush, focus, scale));
    }

    Status SetBlendTriangularShape(
        IN REAL focus,
        IN REAL scale = 1.0f
    )
    {
        return SetStatus(DllExports::GdipSetLineLinearBlend((GpLineGradient*)nativeBrush, focus, scale));
    }

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetLineTransform((GpLineGradient*)nativeBrush, 
                                                          matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetLineTransform((GpLineGradient*)nativeBrush, 
                                                          matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetLineTransform((GpLineGradient*)nativeBrush));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyLineTransform((GpLineGradient*)nativeBrush,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateLineTransform((GpLineGradient*)nativeBrush,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleLineTransform((GpLineGradient*)nativeBrush,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateLineTransform((GpLineGradient*)nativeBrush,
                                                              angle, order));
    }

    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetLineWrapMode((GpLineGradient*)nativeBrush, 
                                                         wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetLineWrapMode((GpLineGradient*)
                                                  nativeBrush, 
                                                  &wrapMode));

        return wrapMode;
    }

private:
    LinearGradientBrush(const LinearGradientBrush &);
    LinearGradientBrush& operator=(const LinearGradientBrush &);

protected:

    LinearGradientBrush()
    {
    }
};

//--------------------------------------------------------------------------
// PathGradientBrush object is defined
// in gdipluspath.h.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
// Hatch Brush Object
//--------------------------------------------------------------------------

class HatchBrush : public Brush
{
public:
    friend class Pen;

    HatchBrush(IN HatchStyle hatchStyle, 
               IN const Color& foreColor,
               IN const Color& backColor = Color())
    {
        GpHatch *brush = NULL;

        lastResult = DllExports::GdipCreateHatchBrush(hatchStyle, 
                                                      foreColor.GetValue(), 
                                                      backColor.GetValue(),
                                                      &brush);
        SetNativeBrush(brush);
    }

    HatchStyle GetHatchStyle() const
    {
        HatchStyle hatchStyle;

        SetStatus(DllExports::GdipGetHatchStyle((GpHatch*)nativeBrush, 
                                                &hatchStyle));

        return hatchStyle;
    }
    
    Status GetForegroundColor(OUT Color* color) const
    {
        ARGB argb;

        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        Status status = SetStatus(DllExports::GdipGetHatchForegroundColor(
                                                        (GpHatch*)nativeBrush, 
                                                        &argb));

        color->SetValue(argb);

        return status;
    }

    Status GetBackgroundColor(OUT Color *color) const
    {
        ARGB argb;
        
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        Status status = SetStatus(DllExports::GdipGetHatchBackgroundColor(
                                                        (GpHatch*)nativeBrush,
                                                        &argb));

        color->SetValue(argb);
        
        return status;
    }

private:
    HatchBrush(const HatchBrush &);
    HatchBrush& operator=(const HatchBrush &);

protected:

    HatchBrush()
    {
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusBitmap.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusBitmap.h
*
* Abstract:
*
*   GDI+ Bitmap class
*
\**************************************************************************/

#ifndef _GDIPLUSBITMAP_H
#define _GDIPLUSBITMAP_H

inline 
Image::Image(
    IN const WCHAR* filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    nativeImage = NULL;
    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipLoadImageFromFileICM(
            filename, 
            &nativeImage
        );
    }
    else
    {      
        lastResult = DllExports::GdipLoadImageFromFile(
            filename, 
            &nativeImage
        );
    }
}

inline 
Image::Image(
    IN IStream* stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    nativeImage = NULL;
    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipLoadImageFromStreamICM(
            stream, 
            &nativeImage
        );
    }
    else
    {
        lastResult = DllExports::GdipLoadImageFromStream(
            stream, 
            &nativeImage
        );
    }
}

inline Image* 
Image::FromFile(
    IN const WCHAR* filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Image(
        filename, 
        useEmbeddedColorManagement
    );
}

inline Image*
Image::FromStream(
    IN IStream* stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Image(
        stream,
        useEmbeddedColorManagement
    );
}

inline 
Image::~Image()
{
    DllExports::GdipDisposeImage(nativeImage);
}

inline Image* 
Image::Clone() 
{
    GpImage *cloneimage = NULL;

    SetStatus(DllExports::GdipCloneImage(nativeImage, &cloneimage));

    return new Image(cloneimage, lastResult);
}

inline UINT
Image::GetEncoderParameterListSize(
    IN const CLSID* clsidEncoder
    ) 
{
    UINT size = 0;

    SetStatus(DllExports::GdipGetEncoderParameterListSize(nativeImage,
                                                          clsidEncoder,
                                                          &size));
    return size;
}

inline Status
Image::GetEncoderParameterList(
    IN const CLSID* clsidEncoder,
    IN UINT size,
    OUT EncoderParameters* buffer
    )
{
    return SetStatus(DllExports::GdipGetEncoderParameterList(nativeImage,
                                                             clsidEncoder,
                                                             size,
                                                             buffer));
}

inline Status
Image::Save(
    IN const WCHAR* filename,
    IN const CLSID* clsidEncoder,
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveImageToFile(nativeImage,
                                                     filename,
                                                     clsidEncoder,
                                                     encoderParams));
}

inline Status
Image::Save(
    IN IStream* stream,
    IN const CLSID* clsidEncoder,
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveImageToStream(nativeImage,
                                                       stream,
                                                       clsidEncoder,
                                                       encoderParams));
}

inline Status
Image::SaveAdd(
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveAdd(nativeImage,
                                             encoderParams));
}

inline Status
Image::SaveAdd(
    IN Image* newImage,
    IN const EncoderParameters *encoderParams
    )
{
    if ( newImage == NULL )
    {
        return SetStatus(InvalidParameter);
    }

    return SetStatus(DllExports::GdipSaveAddImage(nativeImage,
                                                  newImage->nativeImage,
                                                  encoderParams));
}

inline ImageType 
Image::GetType() const
{
    ImageType type = ImageTypeUnknown;

    SetStatus(DllExports::GdipGetImageType(nativeImage, &type));

    return type;
}

inline Status 
Image::GetPhysicalDimension(
    OUT SizeF* size
    ) 
{
    if (size == NULL) 
    {
        return SetStatus(InvalidParameter);
    }
    
    REAL width, height;
    Status status;

    status = SetStatus(DllExports::GdipGetImageDimension(nativeImage,
                                                         &width, &height));

    size->Width  = width;
    size->Height = height;

    return status;
}

inline Status 
Image::GetBounds(
    OUT RectF *srcRect, 
    OUT Unit *srcUnit
    )
{
    return SetStatus(DllExports::GdipGetImageBounds(nativeImage,
                                                    srcRect, srcUnit));
}

inline UINT 
Image::GetWidth()
{
    UINT width = 0;

    SetStatus(DllExports::GdipGetImageWidth(nativeImage, &width));

    return width;
}

inline UINT 
Image::GetHeight()
{
    UINT height = 0;

    SetStatus(DllExports::GdipGetImageHeight(nativeImage, &height));

    return height;
}

inline REAL 
Image::GetHorizontalResolution()
{
    REAL resolution = 0.0f;

    SetStatus(DllExports::GdipGetImageHorizontalResolution(nativeImage, &resolution));

    return resolution;
}

inline REAL 
Image::GetVerticalResolution()
{
    REAL resolution = 0.0f;

    SetStatus(DllExports::GdipGetImageVerticalResolution(nativeImage, &resolution));

    return resolution;
}

inline UINT 
Image::GetFlags()
{
    UINT flags = 0;

    SetStatus(DllExports::GdipGetImageFlags(nativeImage, &flags));

    return flags;
}

inline Status 
Image::GetRawFormat(OUT GUID *format)
{
    return SetStatus(DllExports::GdipGetImageRawFormat(nativeImage, format));
}

inline PixelFormat 
Image::GetPixelFormat()
{
    PixelFormat format;

    SetStatus(DllExports::GdipGetImagePixelFormat(nativeImage, &format));

    return format;
}

inline INT 
Image::GetPaletteSize()
{
    INT size = 0;
    
    SetStatus(DllExports::GdipGetImagePaletteSize(nativeImage, &size));
    
    return size;
}

inline Status 
Image::GetPalette(
    OUT ColorPalette *palette,
    IN INT size
)
{
    return SetStatus(DllExports::GdipGetImagePalette(nativeImage, palette, size));
}

inline Status 
Image::SetPalette(
    IN const ColorPalette *palette
    )
{
    return SetStatus(DllExports::GdipSetImagePalette(nativeImage, palette));
}

inline Image* 
Image::GetThumbnailImage(
    IN UINT thumbWidth,
    IN UINT thumbHeight,
    IN GetThumbnailImageAbort callback,
    IN VOID* callbackData
    )
{
    GpImage *thumbimage = NULL;

    SetStatus(DllExports::GdipGetImageThumbnail(nativeImage,
                                                thumbWidth, thumbHeight,
                                                &thumbimage,
                                                callback, callbackData));

    Image *newImage = new Image(thumbimage, lastResult);

    if (newImage == NULL) 
    {
        DllExports::GdipDisposeImage(thumbimage);
    }

    return newImage;
}

inline UINT 
Image::GetFrameDimensionsCount()
{
    UINT count = 0;

    SetStatus(DllExports::GdipImageGetFrameDimensionsCount(nativeImage,
                                                                  &count));

    return count;
}

inline Status 
Image::GetFrameDimensionsList(
    OUT GUID* dimensionIDs, 
    IN UINT count
    )
{
    return SetStatus(DllExports::GdipImageGetFrameDimensionsList(nativeImage,
                                                                 dimensionIDs,
                                                                 count));
}

inline UINT 
Image::GetFrameCount(
    IN const GUID* dimensionID
    )
{
    UINT count = 0;

    SetStatus(DllExports::GdipImageGetFrameCount(nativeImage,
                                                        dimensionID,
                                                        &count));
    return count;
}

inline Status 
Image::SelectActiveFrame(
    IN const GUID *dimensionID, 
    IN UINT frameIndex
    )
{
    return SetStatus(DllExports::GdipImageSelectActiveFrame(nativeImage,
                                                            dimensionID,
                                                            frameIndex));
}

inline Status
Image::RotateFlip(
    IN RotateFlipType rotateFlipType
    )
{
    return SetStatus(DllExports::GdipImageRotateFlip(nativeImage,
                                                     rotateFlipType));
}

inline UINT 
Image::GetPropertyCount()
{
    UINT numProperty = 0;

    SetStatus(DllExports::GdipGetPropertyCount(nativeImage,
                                               &numProperty));

    return numProperty;
}

inline Status 
Image::GetPropertyIdList(
    IN UINT numOfProperty, 
    OUT PROPID* list
    )
{
    return SetStatus(DllExports::GdipGetPropertyIdList(nativeImage,
                                                       numOfProperty, list));
}
    
inline UINT 
Image::GetPropertyItemSize(
    IN PROPID propId
    )
{
    UINT size = 0;

    SetStatus(DllExports::GdipGetPropertyItemSize(nativeImage,
                                                  propId,
                                                  &size));

    return size;
}

inline Status 
Image::GetPropertyItem(
    IN PROPID propId, 
    IN UINT propSize,
    OUT PropertyItem* buffer
    )
{
    return SetStatus(DllExports::GdipGetPropertyItem(nativeImage,
                                                     propId, propSize, buffer));
}

inline Status 
Image::GetPropertySize(
    OUT UINT* totalBufferSize, 
    OUT UINT* numProperties
    )
{
    return SetStatus(DllExports::GdipGetPropertySize(nativeImage,
                                                     totalBufferSize,
                                                     numProperties));
}

inline Status 
Image::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    OUT PropertyItem* allItems
    )
{
    if (allItems == NULL) 
    {
        return SetStatus(InvalidParameter);
    }
    return SetStatus(DllExports::GdipGetAllPropertyItems(nativeImage,
                                                         totalBufferSize,
                                                         numProperties,
                                                         allItems));
}

inline Status 
Image::RemovePropertyItem(
    IN PROPID propId
    )
{
    return SetStatus(DllExports::GdipRemovePropertyItem(nativeImage, propId));
}

inline Status 
Image::SetPropertyItem(
    IN const PropertyItem* item
    )
{
    return SetStatus(DllExports::GdipSetPropertyItem(nativeImage, item));
}

#if (GDIPVER >= 0x0110)
inline Status 
Image::FindFirstItem(
    IN ImageItemData* item
    )
{
    return SetStatus(DllExports::GdipFindFirstImageItem(nativeImage, item));
}

inline Status 
Image::FindNextItem(
    IN ImageItemData* item
    )
{
    return SetStatus(DllExports::GdipFindNextImageItem(nativeImage, item));
}

inline Status 
Image::GetItemData(
    IN ImageItemData* item
    )
{
    return SetStatus(DllExports::GdipGetImageItemData(nativeImage, item));
}
#endif //(GDIPVER >= 0x0110)

inline Status
Image::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

inline 
Image::Image(GpImage *nativeImage, Status status)
{
    SetNativeImage(nativeImage);
    lastResult = status;
}

inline VOID 
Image::SetNativeImage(GpImage *nativeImage)
{
    this->nativeImage = nativeImage;
}

inline 
Bitmap::Bitmap(
    IN const WCHAR *filename, 
    IN BOOL useEmbeddedColorManagement
    )
{
    GpBitmap *bitmap = NULL;

    if(useEmbeddedColorManagement) 
    {
        lastResult = DllExports::GdipCreateBitmapFromFileICM(filename, &bitmap);
    }
    else
    {
        lastResult = DllExports::GdipCreateBitmapFromFile(filename, &bitmap);
    }

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN IStream *stream, 
    IN BOOL useEmbeddedColorManagement
    )
{
    GpBitmap *bitmap = NULL;

    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipCreateBitmapFromStreamICM(stream, &bitmap);
    }
    else
    {
        lastResult = DllExports::GdipCreateBitmapFromStream(stream, &bitmap);
    }

    SetNativeImage(bitmap);
}

inline
Bitmap::Bitmap(
    IN INT width,
    IN INT height,
    IN INT stride,
    IN PixelFormat format,
    IN BYTE *scan0
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromScan0(width,
                                                       height,
                                                       stride,
                                                       format,
                                                       scan0,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN INT width,
    IN INT height,
    IN PixelFormat format
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromScan0(width,
                                                       height,
                                                       0,
                                                       format,
                                                       NULL,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline
Bitmap::Bitmap(
    IN INT width, 
    IN INT height, 
    IN Graphics* target)
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromGraphics(width,
                                                          height,
                                                          target->nativeGraphics,
                                                          &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN IDirectDrawSurface7 * surface
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromDirectDrawSurface(surface,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN const BITMAPINFO* gdiBitmapInfo, 
    IN VOID* gdiBitmapData
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromGdiDib(gdiBitmapInfo,
                                                        gdiBitmapData,
                                                        &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HBITMAP hbm, 
    IN HPALETTE hpal
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromHBITMAP(hbm, hpal, &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HICON hicon
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromHICON(hicon, &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HINSTANCE hInstance, 
    IN const WCHAR *bitmapName
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromResource(hInstance,
                                                          bitmapName,
                                                          &bitmap);

    SetNativeImage(bitmap);
}


inline Bitmap* 
Bitmap::FromFile(
    IN const WCHAR *filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Bitmap(
        filename, 
        useEmbeddedColorManagement
    );
}

inline Bitmap* 
Bitmap::FromStream(
    IN IStream *stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Bitmap(
        stream, 
        useEmbeddedColorManagement
    );
}

inline Bitmap* 
Bitmap::FromDirectDrawSurface7(
    IN IDirectDrawSurface7* surface
    )
{
    return new Bitmap(surface);
}

inline Bitmap* 
Bitmap::FromBITMAPINFO(
    IN const BITMAPINFO* gdiBitmapInfo, 
    IN VOID* gdiBitmapData)
{
    return new Bitmap(gdiBitmapInfo, gdiBitmapData);
}

inline Bitmap* 
Bitmap::FromHBITMAP(
    IN HBITMAP hbm, 
    IN HPALETTE hpal
    )
{
    return new Bitmap(hbm, hpal);
}

inline Bitmap* 
Bitmap::FromHICON(
    IN HICON hicon
    )
{
    return new Bitmap(hicon);
}

inline Bitmap* 
Bitmap::FromResource(
    IN HINSTANCE hInstance, 
    IN const WCHAR *bitmapName)
{
    return new Bitmap(hInstance, bitmapName);
}

inline Status 
Bitmap::GetHBITMAP(
    IN const Color& colorBackground,
    OUT HBITMAP* hbmReturn
    )
{
    return SetStatus(DllExports::GdipCreateHBITMAPFromBitmap(
                                        static_cast<GpBitmap*>(nativeImage),
                                        hbmReturn,
                                        colorBackground.GetValue()));
}

inline Status 
Bitmap::GetHICON(
    OUT HICON* hiconReturn
    )
{
    return SetStatus(DllExports::GdipCreateHICONFromBitmap(
                                        static_cast<GpBitmap*>(nativeImage),
                                        hiconReturn));
}

inline Bitmap* 
Bitmap::Clone(
    IN const Rect& rect,
    IN PixelFormat format
    )
{
    return Clone(rect.X, rect.Y, rect.Width, rect.Height, format);
}

inline Bitmap* 
Bitmap::Clone(
    IN INT x,
    IN INT y,
    IN INT width,
    IN INT height,
    IN PixelFormat format
    )
{
   GpBitmap* gpdstBitmap = NULL;
   Bitmap* bitmap;

   if (SetStatus(DllExports::GdipCloneBitmapAreaI(
                               x,
                               y,
                               width,
                               height,
                               format,
                               (GpBitmap *)nativeImage,
                               &gpdstBitmap)) == Ok)
   {
       bitmap = new Bitmap(gpdstBitmap);

       if (bitmap == NULL) 
       {
           DllExports::GdipDisposeImage(gpdstBitmap);
       }

       return bitmap;
   }
   else
       return NULL;
}

inline Bitmap* 
Bitmap::Clone(
    IN const RectF& rect,
    IN PixelFormat format
    )
{
    return Clone(rect.X, rect.Y, rect.Width, rect.Height, format);
}

inline Bitmap*
Bitmap::Clone(
    IN REAL x,
    IN REAL y,
    IN REAL width,
    IN REAL height,
    IN PixelFormat format
    )
{
   GpBitmap* gpdstBitmap = NULL;
   Bitmap* bitmap;

   if (SetStatus(DllExports::GdipCloneBitmapArea(
                               x,
                               y,
                               width,
                               height,
                               format,
                               (GpBitmap *)nativeImage,
                               &gpdstBitmap)) == Ok)
   {
       bitmap = new Bitmap(gpdstBitmap);

       if (bitmap == NULL) 
       {
           DllExports::GdipDisposeImage(gpdstBitmap);
       }

       return bitmap;
   }
   else
       return NULL;
}

inline Bitmap::Bitmap(GpBitmap *nativeBitmap)
{
    lastResult = Ok;

    SetNativeImage(nativeBitmap);
}

inline Status
Bitmap::LockBits(
    IN const Rect* rect,
    IN UINT flags,
    IN PixelFormat format,
    OUT BitmapData* lockedBitmapData
)
{
    return SetStatus(DllExports::GdipBitmapLockBits(
                                    static_cast<GpBitmap*>(nativeImage),
                                    rect,
                                    flags,
                                    format,
                                    lockedBitmapData));
}

inline Status 
Bitmap::UnlockBits(
    IN BitmapData* lockedBitmapData
    )
{
    return SetStatus(DllExports::GdipBitmapUnlockBits(
                                    static_cast<GpBitmap*>(nativeImage),
                                    lockedBitmapData));
}

inline Status 
Bitmap::GetPixel(
    IN INT x, 
    IN INT y, 
    OUT Color *color) 
{
    ARGB argb;

    Status status = SetStatus(DllExports::GdipBitmapGetPixel(
        static_cast<GpBitmap *>(nativeImage),
        x, y,        
        &argb));

    if (status == Ok) 
    {
        color->SetValue(argb);
    }

    return  status;
}

inline Status 
Bitmap::SetPixel(
    IN INT x, 
    IN INT y, 
    IN const Color& color) 
{
    return SetStatus(DllExports::GdipBitmapSetPixel(
        static_cast<GpBitmap *>(nativeImage),
        x, y,
        color.GetValue()));
}

#if (GDIPVER >= 0x0110)
inline Status Image::SetAbort(GdiplusAbort *pIAbort)
{
    return SetStatus(DllExports::GdipImageSetAbort(
        nativeImage,
        pIAbort
        ));
}

inline Status
Bitmap::ConvertFormat(
    PixelFormat format,
    DitherType dithertype,
    PaletteType palettetype,
    ColorPalette *palette,
    REAL alphaThresholdPercent
    )
{
    return SetStatus(DllExports::GdipBitmapConvertFormat(
        static_cast<GpBitmap*>(nativeImage),
        format,
        dithertype,
        palettetype,
        palette,
        alphaThresholdPercent
        ));
}

inline Status 
Bitmap::InitializePalette(
    OUT ColorPalette *palette,   // output palette. must be allocated.
    PaletteType palettetype,     // palette enumeration type.
    INT optimalColors,           // how many optimal colors
    BOOL useTransparentColor,    // add a transparent color to the palette.
    Bitmap *bitmap               // optional bitmap for median cut.
    )
{
    return DllExports::GdipInitializePalette(
        palette,
        palettetype,
        optimalColors,
        useTransparentColor,
        bitmap ? static_cast<GpBitmap*>(bitmap->nativeImage) : NULL
        );
}


inline Status 
Bitmap::ApplyEffect(
    IN  Bitmap **inputs,
    IN  INT numInputs,
    IN  Effect *effect, 
    IN  RECT *ROI,                     // optional parameter.
    OUT RECT *outputRect,              // optional parameter.
    OUT Bitmap **output
)
{
    if (numInputs < 0)
    {
        return InvalidParameter;
    }
    
    GpBitmap *outputNative = NULL;
    GpBitmap **nativeInputs = new GpBitmap * [numInputs];
    
    if (NULL == nativeInputs)
    {
        return OutOfMemory;
    }
    
    for (int i = 0; i < numInputs; i++)
    {
        nativeInputs[i] = static_cast<GpBitmap*>(inputs[i]->nativeImage);
    }
    
    if (effect->auxData)
    {
        DllExports::GdipFree(effect->auxData);
        effect->auxData = NULL;
        effect->auxDataSize = 0;
    }
    
    Status status = DllExports::GdipBitmapCreateApplyEffect(
        nativeInputs,
        numInputs,
        effect->nativeEffect,
        ROI,
        outputRect,
        &outputNative,
        effect->useAuxData,
        &effect->auxData,
        &effect->auxDataSize
        );
    
    if ((Ok == status) && outputNative)
    {
        *output = new Bitmap(outputNative);
        
        if (NULL == *output)
        {
            status = OutOfMemory;
            DllExports::GdipDisposeImage(outputNative);
        }
    }
    else
    {
        *output = NULL;
    }
    
    delete [] nativeInputs;
    
    return status;
}


inline Status
Bitmap::ApplyEffect(
    Effect *effect,
    RECT *ROI
)
{
    if(effect->auxData)
    {
        DllExports::GdipFree(effect->auxData);
        effect->auxData = NULL;
        effect->auxDataSize = 0;
    }
    
    return DllExports::GdipBitmapApplyEffect(
        static_cast<GpBitmap *>(nativeImage),
        effect->nativeEffect,
        ROI,
        effect->useAuxData,
        &effect->auxData,
        &effect->auxDataSize
        );
}

inline Status
Bitmap::GetHistogram(
    IN HistogramFormat format,
    IN UINT NumberOfEntries,
    __out_bcount(sizeof(UINT)*256) UINT *channel0,
    __out_bcount(sizeof(UINT)*256) UINT *channel1,
    __out_bcount(sizeof(UINT)*256) UINT *channel2,
    __out_bcount(sizeof(UINT)*256) UINT *channel3
)
{
    return DllExports::GdipBitmapGetHistogram(
        static_cast<GpBitmap *>(nativeImage),
        format,
        NumberOfEntries,
        channel0,
        channel1,
        channel2,
        channel3
        );
}

inline Status 
Bitmap::GetHistogramSize(
    IN HistogramFormat format,
    OUT UINT *NumberOfEntries
)
{
    return DllExports::GdipBitmapGetHistogramSize(
        format,
        NumberOfEntries
        );
}

#endif // (GDIPVER >= 0x0110)


inline Status 
Bitmap::SetResolution(
    IN REAL xdpi, 
    IN REAL ydpi)
{
    return SetStatus(DllExports::GdipBitmapSetResolution(
        static_cast<GpBitmap *>(nativeImage),
        xdpi, ydpi));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusColor.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusColor.h
*
* Abstract:
*
*   GDI+ Color Object
*
\**************************************************************************/

#ifndef _GDIPLUSCOLOR_H
#define _GDIPLUSCOLOR_H

//----------------------------------------------------------------------------
// Color mode
//----------------------------------------------------------------------------

enum ColorMode
{
    ColorModeARGB32 = 0,
    ColorModeARGB64 = 1
};

//----------------------------------------------------------------------------
// Color Channel flags
//----------------------------------------------------------------------------

enum ColorChannelFlags
{
    ColorChannelFlagsC = 0,
    ColorChannelFlagsM,
    ColorChannelFlagsY,
    ColorChannelFlagsK,
    ColorChannelFlagsLast
};

//----------------------------------------------------------------------------
// Color
//----------------------------------------------------------------------------

class Color
{
public:

    Color()
    {
        Argb = (ARGB)Color::Black;
    }

    // Construct an opaque Color object with
    // the specified Red, Green, Blue values.
    //
    // Color values are not premultiplied.

    Color(IN BYTE r,
          IN BYTE g,
          IN BYTE b)
    {
        Argb = MakeARGB(255, r, g, b);
    }

    Color(IN BYTE a,
          IN BYTE r,
          IN BYTE g,
          IN BYTE b)
    {
        Argb = MakeARGB(a, r, g, b);
    }

    Color(IN ARGB argb)
    {
        Argb = argb;
    }

    BYTE GetAlpha() const
    {
        return (BYTE) (Argb >> AlphaShift);
    }

    BYTE GetA() const
    {
        return GetAlpha();
    }

    BYTE GetRed() const
    {
        return (BYTE) (Argb >> RedShift);
    }

    BYTE GetR() const
    {
        return GetRed();
    }

    BYTE GetGreen() const
    {
        return (BYTE) (Argb >> GreenShift);
    }

    BYTE GetG() const
    {
        return GetGreen();
    }

    BYTE GetBlue() const
    {
        return (BYTE) (Argb >> BlueShift);
    }

    BYTE GetB() const
    {
        return GetBlue();
    }

    ARGB GetValue() const
    {
        return Argb;
    }

    VOID SetValue(IN ARGB argb)
    {
        Argb = argb;
    }

    VOID SetFromCOLORREF(IN COLORREF rgb)
    {
        Argb = MakeARGB(255, GetRValue(rgb), GetGValue(rgb), GetBValue(rgb));
    }

    COLORREF ToCOLORREF() const
    {
        return RGB(GetRed(), GetGreen(), GetBlue());
    }

public:

    // Common color constants
    
    enum
    {
        AliceBlue            = 0xFFF0F8FF,
        AntiqueWhite         = 0xFFFAEBD7,
        Aqua                 = 0xFF00FFFF,
        Aquamarine           = 0xFF7FFFD4,
        Azure                = 0xFFF0FFFF,
        Beige                = 0xFFF5F5DC,
        Bisque               = 0xFFFFE4C4,
        Black                = 0xFF000000,
        BlanchedAlmond       = 0xFFFFEBCD,
        Blue                 = 0xFF0000FF,
        BlueViolet           = 0xFF8A2BE2,
        Brown                = 0xFFA52A2A,
        BurlyWood            = 0xFFDEB887,
        CadetBlue            = 0xFF5F9EA0,
        Chartreuse           = 0xFF7FFF00,
        Chocolate            = 0xFFD2691E,
        Coral                = 0xFFFF7F50,
        CornflowerBlue       = 0xFF6495ED,
        Cornsilk             = 0xFFFFF8DC,
        Crimson              = 0xFFDC143C,
        Cyan                 = 0xFF00FFFF,
        DarkBlue             = 0xFF00008B,
        DarkCyan             = 0xFF008B8B,
        DarkGoldenrod        = 0xFFB8860B,
        DarkGray             = 0xFFA9A9A9,
        DarkGreen            = 0xFF006400,
        DarkKhaki            = 0xFFBDB76B,
        DarkMagenta          = 0xFF8B008B,
        DarkOliveGreen       = 0xFF556B2F,
        DarkOrange           = 0xFFFF8C00,
        DarkOrchid           = 0xFF9932CC,
        DarkRed              = 0xFF8B0000,
        DarkSalmon           = 0xFFE9967A,
        DarkSeaGreen         = 0xFF8FBC8B,
        DarkSlateBlue        = 0xFF483D8B,
        DarkSlateGray        = 0xFF2F4F4F,
        DarkTurquoise        = 0xFF00CED1,
        DarkViolet           = 0xFF9400D3,
        DeepPink             = 0xFFFF1493,
        DeepSkyBlue          = 0xFF00BFFF,
        DimGray              = 0xFF696969,
        DodgerBlue           = 0xFF1E90FF,
        Firebrick            = 0xFFB22222,
        FloralWhite          = 0xFFFFFAF0,
        ForestGreen          = 0xFF228B22,
        Fuchsia              = 0xFFFF00FF,
        Gainsboro            = 0xFFDCDCDC,
        GhostWhite           = 0xFFF8F8FF,
        Gold                 = 0xFFFFD700,
        Goldenrod            = 0xFFDAA520,
        Gray                 = 0xFF808080,
        Green                = 0xFF008000,
        GreenYellow          = 0xFFADFF2F,
        Honeydew             = 0xFFF0FFF0,
        HotPink              = 0xFFFF69B4,
        IndianRed            = 0xFFCD5C5C,
        Indigo               = 0xFF4B0082,
        Ivory                = 0xFFFFFFF0,
        Khaki                = 0xFFF0E68C,
        Lavender             = 0xFFE6E6FA,
        LavenderBlush        = 0xFFFFF0F5,
        LawnGreen            = 0xFF7CFC00,
        LemonChiffon         = 0xFFFFFACD,
        LightBlue            = 0xFFADD8E6,
        LightCoral           = 0xFFF08080,
        LightCyan            = 0xFFE0FFFF,
        LightGoldenrodYellow = 0xFFFAFAD2,
        LightGray            = 0xFFD3D3D3,
        LightGreen           = 0xFF90EE90,
        LightPink            = 0xFFFFB6C1,
        LightSalmon          = 0xFFFFA07A,
        LightSeaGreen        = 0xFF20B2AA,
        LightSkyBlue         = 0xFF87CEFA,
        LightSlateGray       = 0xFF778899,
        LightSteelBlue       = 0xFFB0C4DE,
        LightYellow          = 0xFFFFFFE0,
        Lime                 = 0xFF00FF00,
        LimeGreen            = 0xFF32CD32,
        Linen                = 0xFFFAF0E6,
        Magenta              = 0xFFFF00FF,
        Maroon               = 0xFF800000,
        MediumAquamarine     = 0xFF66CDAA,
        MediumBlue           = 0xFF0000CD,
        MediumOrchid         = 0xFFBA55D3,
        MediumPurple         = 0xFF9370DB,
        MediumSeaGreen       = 0xFF3CB371,
        MediumSlateBlue      = 0xFF7B68EE,
        MediumSpringGreen    = 0xFF00FA9A,
        MediumTurquoise      = 0xFF48D1CC,
        MediumVioletRed      = 0xFFC71585,
        MidnightBlue         = 0xFF191970,
        MintCream            = 0xFFF5FFFA,
        MistyRose            = 0xFFFFE4E1,
        Moccasin             = 0xFFFFE4B5,
        NavajoWhite          = 0xFFFFDEAD,
        Navy                 = 0xFF000080,
        OldLace              = 0xFFFDF5E6,
        Olive                = 0xFF808000,
        OliveDrab            = 0xFF6B8E23,
        Orange               = 0xFFFFA500,
        OrangeRed            = 0xFFFF4500,
        Orchid               = 0xFFDA70D6,
        PaleGoldenrod        = 0xFFEEE8AA,
        PaleGreen            = 0xFF98FB98,
        PaleTurquoise        = 0xFFAFEEEE,
        PaleVioletRed        = 0xFFDB7093,
        PapayaWhip           = 0xFFFFEFD5,
        PeachPuff            = 0xFFFFDAB9,
        Peru                 = 0xFFCD853F,
        Pink                 = 0xFFFFC0CB,
        Plum                 = 0xFFDDA0DD,
        PowderBlue           = 0xFFB0E0E6,
        Purple               = 0xFF800080,
        Red                  = 0xFFFF0000,
        RosyBrown            = 0xFFBC8F8F,
        RoyalBlue            = 0xFF4169E1,
        SaddleBrown          = 0xFF8B4513,
        Salmon               = 0xFFFA8072,
        SandyBrown           = 0xFFF4A460,
        SeaGreen             = 0xFF2E8B57,
        SeaShell             = 0xFFFFF5EE,
        Sienna               = 0xFFA0522D,
        Silver               = 0xFFC0C0C0,
        SkyBlue              = 0xFF87CEEB,
        SlateBlue            = 0xFF6A5ACD,
        SlateGray            = 0xFF708090,
        Snow                 = 0xFFFFFAFA,
        SpringGreen          = 0xFF00FF7F,
        SteelBlue            = 0xFF4682B4,
        Tan                  = 0xFFD2B48C,
        Teal                 = 0xFF008080,
        Thistle              = 0xFFD8BFD8,
        Tomato               = 0xFFFF6347,
        Transparent          = 0x00FFFFFF,
        Turquoise            = 0xFF40E0D0,
        Violet               = 0xFFEE82EE,
        Wheat                = 0xFFF5DEB3,
        White                = 0xFFFFFFFF,
        WhiteSmoke           = 0xFFF5F5F5,
        Yellow               = 0xFFFFFF00,
        YellowGreen          = 0xFF9ACD32
    };

    // Shift count and bit mask for A, R, G, B components
    
    enum
    {
        AlphaShift  = 24,
        RedShift    = 16,
        GreenShift  = 8,
        BlueShift   = 0
    };

    enum
    {
        AlphaMask   = 0xff000000,
        RedMask     = 0x00ff0000,
        GreenMask   = 0x0000ff00,
        BlueMask    = 0x000000ff
    };

    // Assemble A, R, G, B values into a 32-bit integer
    
    static ARGB MakeARGB(IN BYTE a,
                         IN BYTE r,
                         IN BYTE g,
                         IN BYTE b)
    {
        return (((ARGB) (b) <<  BlueShift) |
                ((ARGB) (g) << GreenShift) |
                ((ARGB) (r) <<   RedShift) |
                ((ARGB) (a) << AlphaShift));
    }

protected:

    ARGB Argb;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlus.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus.h
*
* Abstract:
*
*   GDI+ public header file
*
\**************************************************************************/

#ifndef _GDIPLUS_H
#define _GDIPLUS_H

struct IDirectDrawSurface7;

typedef signed   short   INT16;
typedef unsigned short  UINT16;


// Define the Current GDIPlus Version
#ifndef GDIPVER
#define GDIPVER 0x0100
#endif

#include <pshpack8.h>   // set structure packing to 8

namespace Gdiplus
{
    namespace DllExports
    {
        #include "GdiplusMem.h"
    };

    #include "GdiplusBase.h"

    #include "GdiplusEnums.h"
    #include "GdiplusTypes.h"
    #include "GdiplusInit.h"
    #include "GdiplusPixelFormats.h"
    #include "GdiplusColor.h"
    #include "GdiplusMetaHeader.h"
    #include "GdiplusImaging.h"
    #include "GdiplusColorMatrix.h"
#if (GDIPVER >= 0x0110)    
    #include "GdiplusEffects.h"
#endif
    #include "GdiplusGpStubs.h"
    #include "GdiplusHeaders.h"

    namespace DllExports
    {
        #include "GdiplusFlat.h"
    };


    #include "GdiplusImageAttributes.h"
    #include "GdiplusMatrix.h"
    #include "GdiplusBrush.h"
    #include "GdiplusPen.h"
    #include "GdiplusStringFormat.h"
    #include "GdiplusPath.h"
    #include "GdiplusLineCaps.h"
    #include "GdiplusGraphics.h"
    #include "GdiplusMetafile.h"
    #include "GdiplusCachedBitmap.h"
    #include "GdiplusRegion.h"
    #include "GdiplusFontCollection.h"
    #include "GdiplusFontFamily.h"
    #include "GdiplusFont.h"
    #include "GdiplusBitmap.h"
    #include "GdiplusImageCodec.h"

}; // namespace Gdiplus

#include <poppack.h>    // pop structure packing back to previous state

#endif // !_GDIPLUS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusFontCollection.h ===
/**************************************************************************\
*
* Copyright (c) 2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
* 
*   GdiplusFontCollection.h
*
* Abstract:
*
*   Font collections (Installed and Private)
*
\**************************************************************************/

#ifndef _GDIPLUSFONTCOLL_H
#define _GDIPLUSFONTCOLL_H

inline
FontCollection::FontCollection()
{
    nativeFontCollection = NULL;
}

inline
FontCollection::~FontCollection()
{
}

inline INT
FontCollection::GetFamilyCount() const
{
    INT numFound = 0;

    lastResult = DllExports::GdipGetFontCollectionFamilyCount(
                             nativeFontCollection, &numFound);



    return numFound;
}

inline Status
FontCollection::GetFamilies(
    IN INT           numSought,
    OUT FontFamily * gpfamilies,
    OUT INT *        numFound
) const
{
    if (numSought <= 0 || gpfamilies == NULL || numFound == NULL)
    {
        return SetStatus(InvalidParameter);
    }
    *numFound = 0;
    GpFontFamily **nativeFamilyList = new GpFontFamily*[numSought];

    if (nativeFamilyList == NULL)
    {
        return SetStatus(OutOfMemory);
    }

    Status status = SetStatus(DllExports::GdipGetFontCollectionFamilyList(
        nativeFontCollection,
        numSought,
        nativeFamilyList,
        numFound
    ));
    if (status == Ok)
    {
        for (INT i = 0; i < *numFound; i++)
        {
            DllExports::GdipCloneFontFamily(nativeFamilyList[i],
                                            &gpfamilies[i].nativeFamily);
        }
    }

    delete [] nativeFamilyList;

    return status;
}

inline Status FontCollection::GetLastStatus () const
{
    return lastResult;
}

inline Status
FontCollection::SetStatus(IN Status status) const
{
    lastResult = status;
    return lastResult;
}

inline
InstalledFontCollection::InstalledFontCollection()
{
    nativeFontCollection = NULL;
    lastResult = DllExports::GdipNewInstalledFontCollection(&nativeFontCollection);
}

inline
InstalledFontCollection::~InstalledFontCollection()
{
}

inline
PrivateFontCollection::PrivateFontCollection()
{
    nativeFontCollection = NULL;
    lastResult = DllExports::GdipNewPrivateFontCollection(&nativeFontCollection);
}

inline
PrivateFontCollection::~PrivateFontCollection()
{
    DllExports::GdipDeletePrivateFontCollection(&nativeFontCollection);
}

inline Status
PrivateFontCollection::AddFontFile(IN const WCHAR* filename)
{
    return SetStatus(DllExports::GdipPrivateAddFontFile(nativeFontCollection, filename));
}

inline Status
PrivateFontCollection::AddMemoryFont(IN const void* memory,
                                     IN INT length)
{
    return SetStatus(DllExports::GdipPrivateAddMemoryFont(
        nativeFontCollection,
        memory,
        length));
}

#endif // _GDIPLUSFONTCOLL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusGpStubs.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusGpStubs.h
*
* Abstract:
*
*   Private GDI+ header file.
*
\**************************************************************************/

#ifndef _GDIPLUSGPSTUBS_H
#define _GDIPLUSGPSTUBS_H

//---------------------------------------------------------------------------
// GDI+ classes for forward reference
//---------------------------------------------------------------------------

class Graphics;
class Pen;
class Brush;
class Matrix;
class Bitmap;
class Metafile;
class GraphicsPath;
class PathIterator;
class Region;
class Image;
class TextureBrush;
class HatchBrush;
class SolidBrush;
class LinearGradientBrush;
class PathGradientBrush;
class Font;
class FontFamily;
class FontCollection;
class InstalledFontCollection;
class PrivateFontCollection;
class ImageAttributes;
class CachedBitmap;

//---------------------------------------------------------------------------
// Private GDI+ classes for internal type checking
//---------------------------------------------------------------------------
class GpGraphics {};

class GpBrush {};
class GpTexture : public GpBrush {};
class GpSolidFill : public GpBrush {};
class GpLineGradient : public GpBrush {};
class GpPathGradient : public GpBrush {};
class GpHatch : public GpBrush {};

class GpPen {};
class GpCustomLineCap {};
class GpAdjustableArrowCap : public GpCustomLineCap {};

class GpImage {};
class GpBitmap : public GpImage {};
class GpMetafile : public GpImage {};
class GpImageAttributes {};

class GpPath {};
class GpRegion {};
class GpPathIterator {};

class GpFontFamily {};
class GpFont {};
class GpStringFormat {};
class GpFontCollection {};
class GpInstalledFontCollection : public GpFontCollection {};
class GpPrivateFontCollection : public GpFontCollection {};

class GpCachedBitmap;

typedef Status GpStatus;
typedef FillMode GpFillMode;
typedef WrapMode GpWrapMode;
typedef Unit GpUnit;
typedef CoordinateSpace GpCoordinateSpace;
typedef PointF GpPointF;
typedef Point GpPoint;
typedef RectF GpRectF;
typedef Rect GpRect;
typedef SizeF GpSizeF;
typedef HatchStyle GpHatchStyle;
typedef DashStyle GpDashStyle;
typedef LineCap GpLineCap;
typedef DashCap GpDashCap;


typedef PenAlignment GpPenAlignment;

typedef LineJoin GpLineJoin;
typedef PenType GpPenType;

typedef Matrix GpMatrix;
typedef BrushType GpBrushType;
typedef MatrixOrder GpMatrixOrder;
typedef FlushIntention GpFlushIntention;
typedef PathData GpPathData;

#endif  // !_GDIPLUSGPSTUBS.HPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusFontFamily.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusFontFamily.h
*
* Abstract:
*
*   GDI+ Font Family class
*
\**************************************************************************/

#ifndef _GDIPLUS_FONT_FAMILY_H
#define _GDIPLUS_FONT_FAMILY_H

inline 
FontFamily::FontFamily() :
    nativeFamily (NULL),
    lastResult    (Ok)
{
}

inline 
FontFamily::FontFamily(
    IN const WCHAR*          name,
    IN const FontCollection* fontCollection
)
{
    nativeFamily = NULL;
    lastResult = DllExports::GdipCreateFontFamilyFromName(
        name,
        fontCollection ? fontCollection->nativeFontCollection : NULL,
        &nativeFamily
    );
}

inline
FontFamily::FontFamily(
    IN GpFontFamily *nativeOrig,
    IN Status status
)
{
    lastResult    = status;
    nativeFamily = nativeOrig;
}

inline const FontFamily *
FontFamily::GenericSansSerif() 
{
    if (GenericSansSerifFontFamily != NULL)
    {
        return GenericSansSerifFontFamily;
    }

    GenericSansSerifFontFamily =
        (FontFamily*) GenericSansSerifFontFamilyBuffer;

    GenericSansSerifFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilySansSerif(
            &(GenericSansSerifFontFamily->nativeFamily)
        );

    return GenericSansSerifFontFamily;
}

inline const FontFamily *
FontFamily::GenericSerif() 
{
    if (GenericSerifFontFamily != NULL)
    {
        return GenericSerifFontFamily;
    }

    GenericSerifFontFamily =
        (FontFamily*) GenericSerifFontFamilyBuffer;

    GenericSerifFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilySerif(
            &(GenericSerifFontFamily->nativeFamily)
        );

    return GenericSerifFontFamily;
}

inline const FontFamily *
FontFamily::GenericMonospace()
{
    if (GenericMonospaceFontFamily != NULL)
    {
        return GenericMonospaceFontFamily;
    }

    GenericMonospaceFontFamily =
        (FontFamily*) GenericMonospaceFontFamilyBuffer;

    GenericMonospaceFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilyMonospace(
            &(GenericMonospaceFontFamily->nativeFamily)
        );

    return GenericMonospaceFontFamily;
}

inline FontFamily::~FontFamily()
{
    DllExports::GdipDeleteFontFamily (nativeFamily);
}

inline FontFamily *
FontFamily::Clone() const
{
    GpFontFamily * clonedFamily = NULL;

    SetStatus(DllExports::GdipCloneFontFamily (nativeFamily, &clonedFamily));

    return new FontFamily(clonedFamily, lastResult);
}

inline Status 
FontFamily::GetFamilyName(
    __out_ecount(LF_FACESIZE) LPWSTR    name,
    IN LANGID                           language
) const
{
    return SetStatus(DllExports::GdipGetFamilyName(nativeFamily, 
                                                   name, 
                                                   language));
}

inline BOOL 
FontFamily::IsStyleAvailable(IN INT style) const
{
    BOOL    StyleAvailable;
    Status  status;

    status = SetStatus(DllExports::GdipIsStyleAvailable(nativeFamily, style, &StyleAvailable));

    if (status != Ok)
        StyleAvailable = FALSE;

    return StyleAvailable;
}


inline UINT16 
FontFamily::GetEmHeight(IN INT style) const
{
    UINT16  EmHeight;

    SetStatus(DllExports::GdipGetEmHeight(nativeFamily, style, &EmHeight));

    return EmHeight;
}

inline UINT16 
FontFamily::GetCellAscent(IN INT style) const
{
    UINT16  CellAscent;

    SetStatus(DllExports::GdipGetCellAscent(nativeFamily, style, &CellAscent));

    return CellAscent;
}

inline UINT16 
FontFamily::GetCellDescent(IN INT style) const
{
    UINT16  CellDescent;

    SetStatus(DllExports::GdipGetCellDescent(nativeFamily, style, &CellDescent));

    return CellDescent;
}


inline UINT16 
FontFamily::GetLineSpacing(IN INT style) const
{
    UINT16  LineSpacing;

    SetStatus(DllExports::GdipGetLineSpacing(nativeFamily, style, &LineSpacing));

    return LineSpacing;

}

inline Status 
FontFamily::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

inline Status
FontFamily::SetStatus(Status status) const 
{
    if (status != Ok)
        return (lastResult = status);
    else
        return status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusImageCodec.h ===
/**************************************************************************\
*
* Copyright (c) 2000-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusImageCodec.h
*
* Abstract:
*
*   GDI+ Codec Image APIs
*
\**************************************************************************/

#ifndef _GDIPLUSIMAGECODEC_H
#define _GDIPLUSIMAGECODEC_H

//--------------------------------------------------------------------------
// Codec Management APIs
//--------------------------------------------------------------------------

inline Status 
GetImageDecodersSize(
    OUT UINT *numDecoders,
    OUT UINT *size)
{
    return DllExports::GdipGetImageDecodersSize(numDecoders, size);
}


inline Status 
GetImageDecoders(
    IN UINT numDecoders,
    IN UINT size,
    OUT ImageCodecInfo *decoders)
{
    return DllExports::GdipGetImageDecoders(numDecoders, size, decoders);
}


inline Status 
GetImageEncodersSize(
    OUT UINT *numEncoders, 
    OUT UINT *size)
{
    return DllExports::GdipGetImageEncodersSize(numEncoders, size);
}


inline Status 
GetImageEncoders(
    IN UINT numEncoders,
    IN UINT size,
    OUT ImageCodecInfo *encoders)
{
    return DllExports::GdipGetImageEncoders(numEncoders, size, encoders);
}

#endif  // _GDIPLUSIMAGECODEC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusEnums.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusEnums.h
*
* Abstract:
*
*   GDI+ Enumeration Types
*
\**************************************************************************/

#ifndef _GDIPLUSENUMS_H
#define _GDIPLUSENUMS_H

//--------------------------------------------------------------------------
// Default bezier flattening tolerance in device pixels.
//--------------------------------------------------------------------------

const float FlatnessDefault = 1.0f/4.0f;

//--------------------------------------------------------------------------
// Graphics and Container State cookies
//--------------------------------------------------------------------------

typedef UINT     GraphicsState;
typedef UINT     GraphicsContainer;

//--------------------------------------------------------------------------
// Fill mode constants
//--------------------------------------------------------------------------

enum FillMode
{
    FillModeAlternate,        // 0
    FillModeWinding           // 1
};

//--------------------------------------------------------------------------
// Quality mode constants
//--------------------------------------------------------------------------

enum QualityMode
{
    QualityModeInvalid   = -1,
    QualityModeDefault   = 0,
    QualityModeLow       = 1, // Best performance
    QualityModeHigh      = 2  // Best rendering quality
};

//--------------------------------------------------------------------------
// Alpha Compositing mode constants
//--------------------------------------------------------------------------

enum CompositingMode
{
    CompositingModeSourceOver,    // 0
    CompositingModeSourceCopy     // 1
};

//--------------------------------------------------------------------------
// Alpha Compositing quality constants
//--------------------------------------------------------------------------

enum CompositingQuality
{
    CompositingQualityInvalid          = QualityModeInvalid,
    CompositingQualityDefault          = QualityModeDefault,
    CompositingQualityHighSpeed        = QualityModeLow,
    CompositingQualityHighQuality      = QualityModeHigh,
    CompositingQualityGammaCorrected,
    CompositingQualityAssumeLinear
};

//--------------------------------------------------------------------------
// Unit constants
//--------------------------------------------------------------------------

enum Unit
{
    UnitWorld,      // 0 -- World coordinate (non-physical unit)
    UnitDisplay,    // 1 -- Variable -- for PageTransform only
    UnitPixel,      // 2 -- Each unit is one device pixel.
    UnitPoint,      // 3 -- Each unit is a printer's point, or 1/72 inch.
    UnitInch,       // 4 -- Each unit is 1 inch.
    UnitDocument,   // 5 -- Each unit is 1/300 inch.
    UnitMillimeter  // 6 -- Each unit is 1 millimeter.
};

//--------------------------------------------------------------------------
// MetafileFrameUnit
//
// The frameRect for creating a metafile can be specified in any of these
// units.  There is an extra frame unit value (MetafileFrameUnitGdi) so
// that units can be supplied in the same units that GDI expects for
// frame rects -- these units are in .01 (1/100ths) millimeter units
// as defined by GDI.
//--------------------------------------------------------------------------

enum MetafileFrameUnit
{
    MetafileFrameUnitPixel      = UnitPixel,
    MetafileFrameUnitPoint      = UnitPoint,
    MetafileFrameUnitInch       = UnitInch,
    MetafileFrameUnitDocument   = UnitDocument,
    MetafileFrameUnitMillimeter = UnitMillimeter,
    MetafileFrameUnitGdi                        // GDI compatible .01 MM units
};

//--------------------------------------------------------------------------
// Coordinate space identifiers
//--------------------------------------------------------------------------

enum CoordinateSpace
{
    CoordinateSpaceWorld,     // 0
    CoordinateSpacePage,      // 1
    CoordinateSpaceDevice     // 2
};

//--------------------------------------------------------------------------
// Various wrap modes for brushes
//--------------------------------------------------------------------------

enum WrapMode
{
    WrapModeTile,        // 0
    WrapModeTileFlipX,   // 1
    WrapModeTileFlipY,   // 2
    WrapModeTileFlipXY,  // 3
    WrapModeClamp        // 4
};

//--------------------------------------------------------------------------
// Various hatch styles
//--------------------------------------------------------------------------

enum HatchStyle
{
    HatchStyleHorizontal,                   // 0
    HatchStyleVertical,                     // 1
    HatchStyleForwardDiagonal,              // 2
    HatchStyleBackwardDiagonal,             // 3
    HatchStyleCross,                        // 4
    HatchStyleDiagonalCross,                // 5
    HatchStyle05Percent,                    // 6
    HatchStyle10Percent,                    // 7
    HatchStyle20Percent,                    // 8
    HatchStyle25Percent,                    // 9
    HatchStyle30Percent,                    // 10
    HatchStyle40Percent,                    // 11
    HatchStyle50Percent,                    // 12
    HatchStyle60Percent,                    // 13
    HatchStyle70Percent,                    // 14
    HatchStyle75Percent,                    // 15
    HatchStyle80Percent,                    // 16
    HatchStyle90Percent,                    // 17
    HatchStyleLightDownwardDiagonal,        // 18
    HatchStyleLightUpwardDiagonal,          // 19
    HatchStyleDarkDownwardDiagonal,         // 20
    HatchStyleDarkUpwardDiagonal,           // 21
    HatchStyleWideDownwardDiagonal,         // 22
    HatchStyleWideUpwardDiagonal,           // 23
    HatchStyleLightVertical,                // 24
    HatchStyleLightHorizontal,              // 25
    HatchStyleNarrowVertical,               // 26
    HatchStyleNarrowHorizontal,             // 27
    HatchStyleDarkVertical,                 // 28
    HatchStyleDarkHorizontal,               // 29
    HatchStyleDashedDownwardDiagonal,       // 30
    HatchStyleDashedUpwardDiagonal,         // 31
    HatchStyleDashedHorizontal,             // 32
    HatchStyleDashedVertical,               // 33
    HatchStyleSmallConfetti,                // 34
    HatchStyleLargeConfetti,                // 35
    HatchStyleZigZag,                       // 36
    HatchStyleWave,                         // 37
    HatchStyleDiagonalBrick,                // 38
    HatchStyleHorizontalBrick,              // 39
    HatchStyleWeave,                        // 40
    HatchStylePlaid,                        // 41
    HatchStyleDivot,                        // 42
    HatchStyleDottedGrid,                   // 43
    HatchStyleDottedDiamond,                // 44
    HatchStyleShingle,                      // 45
    HatchStyleTrellis,                      // 46
    HatchStyleSphere,                       // 47
    HatchStyleSmallGrid,                    // 48
    HatchStyleSmallCheckerBoard,            // 49
    HatchStyleLargeCheckerBoard,            // 50
    HatchStyleOutlinedDiamond,              // 51
    HatchStyleSolidDiamond,                 // 52

    HatchStyleTotal,   
    HatchStyleLargeGrid = HatchStyleCross,  // 4

    HatchStyleMin       = HatchStyleHorizontal,
    HatchStyleMax       = HatchStyleTotal - 1,
};

//--------------------------------------------------------------------------
// Dash style constants
//--------------------------------------------------------------------------

enum DashStyle
{
    DashStyleSolid,          // 0
    DashStyleDash,           // 1
    DashStyleDot,            // 2
    DashStyleDashDot,        // 3
    DashStyleDashDotDot,     // 4
    DashStyleCustom          // 5
};

//--------------------------------------------------------------------------
// Dash cap constants
//--------------------------------------------------------------------------

enum DashCap
{
    DashCapFlat             = 0,
    DashCapRound            = 2,
    DashCapTriangle         = 3
};

//--------------------------------------------------------------------------
// Line cap constants (only the lowest 8 bits are used).
//--------------------------------------------------------------------------

enum LineCap
{
    LineCapFlat             = 0,
    LineCapSquare           = 1,
    LineCapRound            = 2,
    LineCapTriangle         = 3,

    LineCapNoAnchor         = 0x10, // corresponds to flat cap
    LineCapSquareAnchor     = 0x11, // corresponds to square cap
    LineCapRoundAnchor      = 0x12, // corresponds to round cap
    LineCapDiamondAnchor    = 0x13, // corresponds to triangle cap
    LineCapArrowAnchor      = 0x14, // no correspondence

    LineCapCustom           = 0xff, // custom cap

    LineCapAnchorMask       = 0xf0  // mask to check for anchor or not.
};

//--------------------------------------------------------------------------
// Custom Line cap type constants
//--------------------------------------------------------------------------

enum CustomLineCapType
{
    CustomLineCapTypeDefault         = 0,
    CustomLineCapTypeAdjustableArrow = 1
};

//--------------------------------------------------------------------------
// Line join constants
//--------------------------------------------------------------------------

enum LineJoin
{
    LineJoinMiter        = 0,
    LineJoinBevel        = 1,
    LineJoinRound        = 2,
    LineJoinMiterClipped = 3
};

//--------------------------------------------------------------------------
// Path point types (only the lowest 8 bits are used.)
//  The lowest 3 bits are interpreted as point type
//  The higher 5 bits are reserved for flags.
//--------------------------------------------------------------------------

enum PathPointType
{
    PathPointTypeStart           = 0,    // move
    PathPointTypeLine            = 1,    // line
    PathPointTypeBezier          = 3,    // default Bezier (= cubic Bezier)
    PathPointTypePathTypeMask    = 0x07, // type mask (lowest 3 bits).
    PathPointTypeDashMode        = 0x10, // currently in dash mode.
    PathPointTypePathMarker      = 0x20, // a marker for the path.
    PathPointTypeCloseSubpath    = 0x80, // closed flag

    // Path types used for advanced path.

    PathPointTypeBezier3    = 3,         // cubic Bezier
};


//--------------------------------------------------------------------------
// WarpMode constants
//--------------------------------------------------------------------------

enum WarpMode
{
    WarpModePerspective,    // 0
    WarpModeBilinear        // 1
};

//--------------------------------------------------------------------------
// LineGradient Mode
//--------------------------------------------------------------------------

enum LinearGradientMode
{
    LinearGradientModeHorizontal,         // 0
    LinearGradientModeVertical,           // 1
    LinearGradientModeForwardDiagonal,    // 2
    LinearGradientModeBackwardDiagonal    // 3
};

//--------------------------------------------------------------------------
// Region Comine Modes
//--------------------------------------------------------------------------

enum CombineMode
{
    CombineModeReplace,     // 0
    CombineModeIntersect,   // 1
    CombineModeUnion,       // 2
    CombineModeXor,         // 3
    CombineModeExclude,     // 4
    CombineModeComplement   // 5 (Exclude From)
};

//--------------------------------------------------------------------------
 // Image types
//--------------------------------------------------------------------------

enum ImageType
{
    ImageTypeUnknown,   // 0
    ImageTypeBitmap,    // 1
    ImageTypeMetafile   // 2
};

//--------------------------------------------------------------------------
// Interpolation modes
//--------------------------------------------------------------------------

enum InterpolationMode
{
    InterpolationModeInvalid          = QualityModeInvalid,
    InterpolationModeDefault          = QualityModeDefault,
    InterpolationModeLowQuality       = QualityModeLow,
    InterpolationModeHighQuality      = QualityModeHigh,
    InterpolationModeBilinear,
    InterpolationModeBicubic,
    InterpolationModeNearestNeighbor,
    InterpolationModeHighQualityBilinear,
    InterpolationModeHighQualityBicubic
};

//--------------------------------------------------------------------------
// Pen types
//--------------------------------------------------------------------------

enum PenAlignment
{
    PenAlignmentCenter       = 0,
    PenAlignmentInset        = 1
};

//--------------------------------------------------------------------------
// Brush types
//--------------------------------------------------------------------------

enum BrushType
{
   BrushTypeSolidColor       = 0,
   BrushTypeHatchFill        = 1,
   BrushTypeTextureFill      = 2,
   BrushTypePathGradient     = 3,
   BrushTypeLinearGradient   = 4
};

//--------------------------------------------------------------------------
// Pen's Fill types
//--------------------------------------------------------------------------

enum PenType
{
   PenTypeSolidColor       = BrushTypeSolidColor,
   PenTypeHatchFill        = BrushTypeHatchFill,
   PenTypeTextureFill      = BrushTypeTextureFill,
   PenTypePathGradient     = BrushTypePathGradient,
   PenTypeLinearGradient   = BrushTypeLinearGradient,
   PenTypeUnknown          = -1
};

//--------------------------------------------------------------------------
// Matrix Order
//--------------------------------------------------------------------------

enum MatrixOrder
{
    MatrixOrderPrepend    = 0,
    MatrixOrderAppend     = 1
};

//--------------------------------------------------------------------------
// Generic font families
//--------------------------------------------------------------------------

enum GenericFontFamily
{
    GenericFontFamilySerif,
    GenericFontFamilySansSerif,
    GenericFontFamilyMonospace

};

//--------------------------------------------------------------------------
// FontStyle: face types and common styles
//--------------------------------------------------------------------------

enum FontStyle
{
    FontStyleRegular    = 0,
    FontStyleBold       = 1,
    FontStyleItalic     = 2,
    FontStyleBoldItalic = 3,
    FontStyleUnderline  = 4,
    FontStyleStrikeout  = 8
};

//---------------------------------------------------------------------------
// Smoothing Mode
//---------------------------------------------------------------------------

enum SmoothingMode
{
    SmoothingModeInvalid     = QualityModeInvalid,
    SmoothingModeDefault     = QualityModeDefault,
    SmoothingModeHighSpeed   = QualityModeLow,
    SmoothingModeHighQuality = QualityModeHigh,
    SmoothingModeNone,
    SmoothingModeAntiAlias,
#if (GDIPVER >= 0x0110)
    SmoothingModeAntiAlias8x4 = SmoothingModeAntiAlias,
    SmoothingModeAntiAlias8x8
#endif //(GDIPVER >= 0x0110) 
};

//---------------------------------------------------------------------------
// Pixel Format Mode
//---------------------------------------------------------------------------

enum PixelOffsetMode
{
    PixelOffsetModeInvalid     = QualityModeInvalid,
    PixelOffsetModeDefault     = QualityModeDefault,
    PixelOffsetModeHighSpeed   = QualityModeLow,
    PixelOffsetModeHighQuality = QualityModeHigh,
    PixelOffsetModeNone,    // No pixel offset
    PixelOffsetModeHalf     // Offset by -0.5, -0.5 for fast anti-alias perf
};

//---------------------------------------------------------------------------
// Text Rendering Hint
//---------------------------------------------------------------------------

enum TextRenderingHint
{
    TextRenderingHintSystemDefault = 0,            // Glyph with system default rendering hint
    TextRenderingHintSingleBitPerPixelGridFit,     // Glyph bitmap with hinting
    TextRenderingHintSingleBitPerPixel,            // Glyph bitmap without hinting
    TextRenderingHintAntiAliasGridFit,             // Glyph anti-alias bitmap with hinting
    TextRenderingHintAntiAlias,                    // Glyph anti-alias bitmap without hinting
    TextRenderingHintClearTypeGridFit              // Glyph CT bitmap with hinting
};

//---------------------------------------------------------------------------
// Metafile Types
//---------------------------------------------------------------------------

enum MetafileType
{
    MetafileTypeInvalid,            // Invalid metafile
    MetafileTypeWmf,                // Standard WMF
    MetafileTypeWmfPlaceable,       // Placeable WMF
    MetafileTypeEmf,                // EMF (not EMF+)
    MetafileTypeEmfPlusOnly,        // EMF+ without dual, down-level records
    MetafileTypeEmfPlusDual         // EMF+ with dual, down-level records
};

//---------------------------------------------------------------------------
// Specifies the type of EMF to record
//---------------------------------------------------------------------------

enum EmfType
{
    EmfTypeEmfOnly     = MetafileTypeEmf,          // no EMF+, only EMF
    EmfTypeEmfPlusOnly = MetafileTypeEmfPlusOnly,  // no EMF, only EMF+
    EmfTypeEmfPlusDual = MetafileTypeEmfPlusDual   // both EMF+ and EMF
};

//---------------------------------------------------------------------------
// EMF+ Persistent object types
//---------------------------------------------------------------------------

enum ObjectType
{
    ObjectTypeInvalid,
    ObjectTypeBrush,
    ObjectTypePen,
    ObjectTypePath,
    ObjectTypeRegion,
    ObjectTypeImage,
    ObjectTypeFont,
    ObjectTypeStringFormat,
    ObjectTypeImageAttributes,
    ObjectTypeCustomLineCap,
#if (GDIPVER >= 0x0110)
    ObjectTypeGraphics,

    ObjectTypeMax = ObjectTypeGraphics,
#else
    ObjectTypeMax = ObjectTypeCustomLineCap,
#endif //(GDIPVER >= 0x0110)
    ObjectTypeMin = ObjectTypeBrush
};

inline BOOL
ObjectTypeIsValid(
    ObjectType      type
    )
{
    return ((type >= ObjectTypeMin) && (type <= ObjectTypeMax));
}

//---------------------------------------------------------------------------
// EMF+ Records
//---------------------------------------------------------------------------

// We have to change the WMF record numbers so that they don't conflict with
// the EMF and EMF+ record numbers.

#define GDIP_EMFPLUS_RECORD_BASE        0x00004000
#define GDIP_WMF_RECORD_BASE            0x00010000
#define GDIP_WMF_RECORD_TO_EMFPLUS(n)   ((EmfPlusRecordType)((n) | GDIP_WMF_RECORD_BASE))
#define GDIP_EMFPLUS_RECORD_TO_WMF(n)   ((n) & (~GDIP_WMF_RECORD_BASE))
#define GDIP_IS_WMF_RECORDTYPE(n)       (((n) & GDIP_WMF_RECORD_BASE) != 0)

enum EmfPlusRecordType
{
   // Since we have to enumerate GDI records right along with GDI+ records,
   // We list all the GDI records here so that they can be part of the
   // same enumeration type which is used in the enumeration callback.

    WmfRecordTypeSetBkColor              = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETBKCOLOR),
    WmfRecordTypeSetBkMode               = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETBKMODE),
    WmfRecordTypeSetMapMode              = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETMAPMODE),
    WmfRecordTypeSetROP2                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETROP2),
    WmfRecordTypeSetRelAbs               = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETRELABS),
    WmfRecordTypeSetPolyFillMode         = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPOLYFILLMODE),
    WmfRecordTypeSetStretchBltMode       = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETSTRETCHBLTMODE),
    WmfRecordTypeSetTextCharExtra        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTCHAREXTRA),
    WmfRecordTypeSetTextColor            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTCOLOR),
    WmfRecordTypeSetTextJustification    = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTJUSTIFICATION),
    WmfRecordTypeSetWindowOrg            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETWINDOWORG),
    WmfRecordTypeSetWindowExt            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETWINDOWEXT),
    WmfRecordTypeSetViewportOrg          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETVIEWPORTORG),
    WmfRecordTypeSetViewportExt          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETVIEWPORTEXT),
    WmfRecordTypeOffsetWindowOrg         = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETWINDOWORG),
    WmfRecordTypeScaleWindowExt          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SCALEWINDOWEXT),
    WmfRecordTypeOffsetViewportOrg       = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETVIEWPORTORG),
    WmfRecordTypeScaleViewportExt        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SCALEVIEWPORTEXT),
    WmfRecordTypeLineTo                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_LINETO),
    WmfRecordTypeMoveTo                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_MOVETO),
    WmfRecordTypeExcludeClipRect         = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXCLUDECLIPRECT),
    WmfRecordTypeIntersectClipRect       = GDIP_WMF_RECORD_TO_EMFPLUS(META_INTERSECTCLIPRECT),
    WmfRecordTypeArc                     = GDIP_WMF_RECORD_TO_EMFPLUS(META_ARC),
    WmfRecordTypeEllipse                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_ELLIPSE),
    WmfRecordTypeFloodFill               = GDIP_WMF_RECORD_TO_EMFPLUS(META_FLOODFILL),
    WmfRecordTypePie                     = GDIP_WMF_RECORD_TO_EMFPLUS(META_PIE),
    WmfRecordTypeRectangle               = GDIP_WMF_RECORD_TO_EMFPLUS(META_RECTANGLE),
    WmfRecordTypeRoundRect               = GDIP_WMF_RECORD_TO_EMFPLUS(META_ROUNDRECT),
    WmfRecordTypePatBlt                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_PATBLT),
    WmfRecordTypeSaveDC                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_SAVEDC),
    WmfRecordTypeSetPixel                = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPIXEL),
    WmfRecordTypeOffsetClipRgn           = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETCLIPRGN),
    WmfRecordTypeTextOut                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_TEXTOUT),
    WmfRecordTypeBitBlt                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_BITBLT),
    WmfRecordTypeStretchBlt              = GDIP_WMF_RECORD_TO_EMFPLUS(META_STRETCHBLT),
    WmfRecordTypePolygon                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYGON),
    WmfRecordTypePolyline                = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYLINE),
    WmfRecordTypeEscape                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_ESCAPE),
    WmfRecordTypeRestoreDC               = GDIP_WMF_RECORD_TO_EMFPLUS(META_RESTOREDC),
    WmfRecordTypeFillRegion              = GDIP_WMF_RECORD_TO_EMFPLUS(META_FILLREGION),
    WmfRecordTypeFrameRegion             = GDIP_WMF_RECORD_TO_EMFPLUS(META_FRAMEREGION),
    WmfRecordTypeInvertRegion            = GDIP_WMF_RECORD_TO_EMFPLUS(META_INVERTREGION),
    WmfRecordTypePaintRegion             = GDIP_WMF_RECORD_TO_EMFPLUS(META_PAINTREGION),
    WmfRecordTypeSelectClipRegion        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTCLIPREGION),
    WmfRecordTypeSelectObject            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTOBJECT),
    WmfRecordTypeSetTextAlign            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTALIGN),
    WmfRecordTypeDrawText                = GDIP_WMF_RECORD_TO_EMFPLUS(0x062F),  // META_DRAWTEXT
    WmfRecordTypeChord                   = GDIP_WMF_RECORD_TO_EMFPLUS(META_CHORD),
    WmfRecordTypeSetMapperFlags          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETMAPPERFLAGS),
    WmfRecordTypeExtTextOut              = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXTTEXTOUT),
    WmfRecordTypeSetDIBToDev             = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETDIBTODEV),
    WmfRecordTypeSelectPalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTPALETTE),
    WmfRecordTypeRealizePalette          = GDIP_WMF_RECORD_TO_EMFPLUS(META_REALIZEPALETTE),
    WmfRecordTypeAnimatePalette          = GDIP_WMF_RECORD_TO_EMFPLUS(META_ANIMATEPALETTE),
    WmfRecordTypeSetPalEntries           = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPALENTRIES),
    WmfRecordTypePolyPolygon             = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYPOLYGON),
    WmfRecordTypeResizePalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_RESIZEPALETTE),
    WmfRecordTypeDIBBitBlt               = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBBITBLT),
    WmfRecordTypeDIBStretchBlt           = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBSTRETCHBLT),
    WmfRecordTypeDIBCreatePatternBrush   = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBCREATEPATTERNBRUSH),
    WmfRecordTypeStretchDIB              = GDIP_WMF_RECORD_TO_EMFPLUS(META_STRETCHDIB),
    WmfRecordTypeExtFloodFill            = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXTFLOODFILL),
    WmfRecordTypeSetLayout               = GDIP_WMF_RECORD_TO_EMFPLUS(0x0149),  // META_SETLAYOUT
    WmfRecordTypeResetDC                 = GDIP_WMF_RECORD_TO_EMFPLUS(0x014C),  // META_RESETDC
    WmfRecordTypeStartDoc                = GDIP_WMF_RECORD_TO_EMFPLUS(0x014D),  // META_STARTDOC
    WmfRecordTypeStartPage               = GDIP_WMF_RECORD_TO_EMFPLUS(0x004F),  // META_STARTPAGE
    WmfRecordTypeEndPage                 = GDIP_WMF_RECORD_TO_EMFPLUS(0x0050),  // META_ENDPAGE
    WmfRecordTypeAbortDoc                = GDIP_WMF_RECORD_TO_EMFPLUS(0x0052),  // META_ABORTDOC
    WmfRecordTypeEndDoc                  = GDIP_WMF_RECORD_TO_EMFPLUS(0x005E),  // META_ENDDOC
    WmfRecordTypeDeleteObject            = GDIP_WMF_RECORD_TO_EMFPLUS(META_DELETEOBJECT),
    WmfRecordTypeCreatePalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPALETTE),
    WmfRecordTypeCreateBrush             = GDIP_WMF_RECORD_TO_EMFPLUS(0x00F8),  // META_CREATEBRUSH
    WmfRecordTypeCreatePatternBrush      = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPATTERNBRUSH),
    WmfRecordTypeCreatePenIndirect       = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPENINDIRECT),
    WmfRecordTypeCreateFontIndirect      = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEFONTINDIRECT),
    WmfRecordTypeCreateBrushIndirect     = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEBRUSHINDIRECT),
    WmfRecordTypeCreateBitmapIndirect    = GDIP_WMF_RECORD_TO_EMFPLUS(0x02FD),  // META_CREATEBITMAPINDIRECT
    WmfRecordTypeCreateBitmap            = GDIP_WMF_RECORD_TO_EMFPLUS(0x06FE),  // META_CREATEBITMAP
    WmfRecordTypeCreateRegion            = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEREGION),

    EmfRecordTypeHeader                  = EMR_HEADER,
    EmfRecordTypePolyBezier              = EMR_POLYBEZIER,
    EmfRecordTypePolygon                 = EMR_POLYGON,
    EmfRecordTypePolyline                = EMR_POLYLINE,
    EmfRecordTypePolyBezierTo            = EMR_POLYBEZIERTO,
    EmfRecordTypePolyLineTo              = EMR_POLYLINETO,
    EmfRecordTypePolyPolyline            = EMR_POLYPOLYLINE,
    EmfRecordTypePolyPolygon             = EMR_POLYPOLYGON,
    EmfRecordTypeSetWindowExtEx          = EMR_SETWINDOWEXTEX,
    EmfRecordTypeSetWindowOrgEx          = EMR_SETWINDOWORGEX,
    EmfRecordTypeSetViewportExtEx        = EMR_SETVIEWPORTEXTEX,
    EmfRecordTypeSetViewportOrgEx        = EMR_SETVIEWPORTORGEX,
    EmfRecordTypeSetBrushOrgEx           = EMR_SETBRUSHORGEX,
    EmfRecordTypeEOF                     = EMR_EOF,
    EmfRecordTypeSetPixelV               = EMR_SETPIXELV,
    EmfRecordTypeSetMapperFlags          = EMR_SETMAPPERFLAGS,
    EmfRecordTypeSetMapMode              = EMR_SETMAPMODE,
    EmfRecordTypeSetBkMode               = EMR_SETBKMODE,
    EmfRecordTypeSetPolyFillMode         = EMR_SETPOLYFILLMODE,
    EmfRecordTypeSetROP2                 = EMR_SETROP2,
    EmfRecordTypeSetStretchBltMode       = EMR_SETSTRETCHBLTMODE,
    EmfRecordTypeSetTextAlign            = EMR_SETTEXTALIGN,
    EmfRecordTypeSetColorAdjustment      = EMR_SETCOLORADJUSTMENT,
    EmfRecordTypeSetTextColor            = EMR_SETTEXTCOLOR,
    EmfRecordTypeSetBkColor              = EMR_SETBKCOLOR,
    EmfRecordTypeOffsetClipRgn           = EMR_OFFSETCLIPRGN,
    EmfRecordTypeMoveToEx                = EMR_MOVETOEX,
    EmfRecordTypeSetMetaRgn              = EMR_SETMETARGN,
    EmfRecordTypeExcludeClipRect         = EMR_EXCLUDECLIPRECT,
    EmfRecordTypeIntersectClipRect       = EMR_INTERSECTCLIPRECT,
    EmfRecordTypeScaleViewportExtEx      = EMR_SCALEVIEWPORTEXTEX,
    EmfRecordTypeScaleWindowExtEx        = EMR_SCALEWINDOWEXTEX,
    EmfRecordTypeSaveDC                  = EMR_SAVEDC,
    EmfRecordTypeRestoreDC               = EMR_RESTOREDC,
    EmfRecordTypeSetWorldTransform       = EMR_SETWORLDTRANSFORM,
    EmfRecordTypeModifyWorldTransform    = EMR_MODIFYWORLDTRANSFORM,
    EmfRecordTypeSelectObject            = EMR_SELECTOBJECT,
    EmfRecordTypeCreatePen               = EMR_CREATEPEN,
    EmfRecordTypeCreateBrushIndirect     = EMR_CREATEBRUSHINDIRECT,
    EmfRecordTypeDeleteObject            = EMR_DELETEOBJECT,
    EmfRecordTypeAngleArc                = EMR_ANGLEARC,
    EmfRecordTypeEllipse                 = EMR_ELLIPSE,
    EmfRecordTypeRectangle               = EMR_RECTANGLE,
    EmfRecordTypeRoundRect               = EMR_ROUNDRECT,
    EmfRecordTypeArc                     = EMR_ARC,
    EmfRecordTypeChord                   = EMR_CHORD,
    EmfRecordTypePie                     = EMR_PIE,
    EmfRecordTypeSelectPalette           = EMR_SELECTPALETTE,
    EmfRecordTypeCreatePalette           = EMR_CREATEPALETTE,
    EmfRecordTypeSetPaletteEntries       = EMR_SETPALETTEENTRIES,
    EmfRecordTypeResizePalette           = EMR_RESIZEPALETTE,
    EmfRecordTypeRealizePalette          = EMR_REALIZEPALETTE,
    EmfRecordTypeExtFloodFill            = EMR_EXTFLOODFILL,
    EmfRecordTypeLineTo                  = EMR_LINETO,
    EmfRecordTypeArcTo                   = EMR_ARCTO,
    EmfRecordTypePolyDraw                = EMR_POLYDRAW,
    EmfRecordTypeSetArcDirection         = EMR_SETARCDIRECTION,
    EmfRecordTypeSetMiterLimit           = EMR_SETMITERLIMIT,
    EmfRecordTypeBeginPath               = EMR_BEGINPATH,
    EmfRecordTypeEndPath                 = EMR_ENDPATH,
    EmfRecordTypeCloseFigure             = EMR_CLOSEFIGURE,
    EmfRecordTypeFillPath                = EMR_FILLPATH,
    EmfRecordTypeStrokeAndFillPath       = EMR_STROKEANDFILLPATH,
    EmfRecordTypeStrokePath              = EMR_STROKEPATH,
    EmfRecordTypeFlattenPath             = EMR_FLATTENPATH,
    EmfRecordTypeWidenPath               = EMR_WIDENPATH,
    EmfRecordTypeSelectClipPath          = EMR_SELECTCLIPPATH,
    EmfRecordTypeAbortPath               = EMR_ABORTPATH,
    EmfRecordTypeReserved_069            = 69,  // Not Used
    EmfRecordTypeGdiComment              = EMR_GDICOMMENT,
    EmfRecordTypeFillRgn                 = EMR_FILLRGN,
    EmfRecordTypeFrameRgn                = EMR_FRAMERGN,
    EmfRecordTypeInvertRgn               = EMR_INVERTRGN,
    EmfRecordTypePaintRgn                = EMR_PAINTRGN,
    EmfRecordTypeExtSelectClipRgn        = EMR_EXTSELECTCLIPRGN,
    EmfRecordTypeBitBlt                  = EMR_BITBLT,
    EmfRecordTypeStretchBlt              = EMR_STRETCHBLT,
    EmfRecordTypeMaskBlt                 = EMR_MASKBLT,
    EmfRecordTypePlgBlt                  = EMR_PLGBLT,
    EmfRecordTypeSetDIBitsToDevice       = EMR_SETDIBITSTODEVICE,
    EmfRecordTypeStretchDIBits           = EMR_STRETCHDIBITS,
    EmfRecordTypeExtCreateFontIndirect   = EMR_EXTCREATEFONTINDIRECTW,
    EmfRecordTypeExtTextOutA             = EMR_EXTTEXTOUTA,
    EmfRecordTypeExtTextOutW             = EMR_EXTTEXTOUTW,
    EmfRecordTypePolyBezier16            = EMR_POLYBEZIER16,
    EmfRecordTypePolygon16               = EMR_POLYGON16,
    EmfRecordTypePolyline16              = EMR_POLYLINE16,
    EmfRecordTypePolyBezierTo16          = EMR_POLYBEZIERTO16,
    EmfRecordTypePolylineTo16            = EMR_POLYLINETO16,
    EmfRecordTypePolyPolyline16          = EMR_POLYPOLYLINE16,
    EmfRecordTypePolyPolygon16           = EMR_POLYPOLYGON16,
    EmfRecordTypePolyDraw16              = EMR_POLYDRAW16,
    EmfRecordTypeCreateMonoBrush         = EMR_CREATEMONOBRUSH,
    EmfRecordTypeCreateDIBPatternBrushPt = EMR_CREATEDIBPATTERNBRUSHPT,
    EmfRecordTypeExtCreatePen            = EMR_EXTCREATEPEN,
    EmfRecordTypePolyTextOutA            = EMR_POLYTEXTOUTA,
    EmfRecordTypePolyTextOutW            = EMR_POLYTEXTOUTW,
    EmfRecordTypeSetICMMode              = 98,  // EMR_SETICMMODE,
    EmfRecordTypeCreateColorSpace        = 99,  // EMR_CREATECOLORSPACE,
    EmfRecordTypeSetColorSpace           = 100, // EMR_SETCOLORSPACE,
    EmfRecordTypeDeleteColorSpace        = 101, // EMR_DELETECOLORSPACE,
    EmfRecordTypeGLSRecord               = 102, // EMR_GLSRECORD,
    EmfRecordTypeGLSBoundedRecord        = 103, // EMR_GLSBOUNDEDRECORD,
    EmfRecordTypePixelFormat             = 104, // EMR_PIXELFORMAT,
    EmfRecordTypeDrawEscape              = 105, // EMR_RESERVED_105,
    EmfRecordTypeExtEscape               = 106, // EMR_RESERVED_106,
    EmfRecordTypeStartDoc                = 107, // EMR_RESERVED_107,
    EmfRecordTypeSmallTextOut            = 108, // EMR_RESERVED_108,
    EmfRecordTypeForceUFIMapping         = 109, // EMR_RESERVED_109,
    EmfRecordTypeNamedEscape             = 110, // EMR_RESERVED_110,
    EmfRecordTypeColorCorrectPalette     = 111, // EMR_COLORCORRECTPALETTE,
    EmfRecordTypeSetICMProfileA          = 112, // EMR_SETICMPROFILEA,
    EmfRecordTypeSetICMProfileW          = 113, // EMR_SETICMPROFILEW,
    EmfRecordTypeAlphaBlend              = 114, // EMR_ALPHABLEND,
    EmfRecordTypeSetLayout               = 115, // EMR_SETLAYOUT,
    EmfRecordTypeTransparentBlt          = 116, // EMR_TRANSPARENTBLT,
    EmfRecordTypeReserved_117            = 117, // Not Used
    EmfRecordTypeGradientFill            = 118, // EMR_GRADIENTFILL,
    EmfRecordTypeSetLinkedUFIs           = 119, // EMR_RESERVED_119,
    EmfRecordTypeSetTextJustification    = 120, // EMR_RESERVED_120,
    EmfRecordTypeColorMatchToTargetW     = 121, // EMR_COLORMATCHTOTARGETW,
    EmfRecordTypeCreateColorSpaceW       = 122, // EMR_CREATECOLORSPACEW,
    EmfRecordTypeMax                     = 122,
    EmfRecordTypeMin                     = 1,

    // That is the END of the GDI EMF records.

    // Now we start the list of EMF+ records.  We leave quite
    // a bit of room here for the addition of any new GDI
    // records that may be added later.

    EmfPlusRecordTypeInvalid = GDIP_EMFPLUS_RECORD_BASE,
    EmfPlusRecordTypeHeader,
    EmfPlusRecordTypeEndOfFile,

    EmfPlusRecordTypeComment,

    EmfPlusRecordTypeGetDC,

    EmfPlusRecordTypeMultiFormatStart,
    EmfPlusRecordTypeMultiFormatSection,
    EmfPlusRecordTypeMultiFormatEnd,

    // For all persistent objects
    
    EmfPlusRecordTypeObject,

    // Drawing Records
    
    EmfPlusRecordTypeClear,
    EmfPlusRecordTypeFillRects,
    EmfPlusRecordTypeDrawRects,
    EmfPlusRecordTypeFillPolygon,
    EmfPlusRecordTypeDrawLines,
    EmfPlusRecordTypeFillEllipse,
    EmfPlusRecordTypeDrawEllipse,
    EmfPlusRecordTypeFillPie,
    EmfPlusRecordTypeDrawPie,
    EmfPlusRecordTypeDrawArc,
    EmfPlusRecordTypeFillRegion,
    EmfPlusRecordTypeFillPath,
    EmfPlusRecordTypeDrawPath,
    EmfPlusRecordTypeFillClosedCurve,
    EmfPlusRecordTypeDrawClosedCurve,
    EmfPlusRecordTypeDrawCurve,
    EmfPlusRecordTypeDrawBeziers,
    EmfPlusRecordTypeDrawImage,
    EmfPlusRecordTypeDrawImagePoints,
    EmfPlusRecordTypeDrawString,

    // Graphics State Records
    
    EmfPlusRecordTypeSetRenderingOrigin,
    EmfPlusRecordTypeSetAntiAliasMode,
    EmfPlusRecordTypeSetTextRenderingHint,
    EmfPlusRecordTypeSetTextContrast,
    EmfPlusRecordTypeSetInterpolationMode,
    EmfPlusRecordTypeSetPixelOffsetMode,
    EmfPlusRecordTypeSetCompositingMode,
    EmfPlusRecordTypeSetCompositingQuality,
    EmfPlusRecordTypeSave,
    EmfPlusRecordTypeRestore,
    EmfPlusRecordTypeBeginContainer,
    EmfPlusRecordTypeBeginContainerNoParams,
    EmfPlusRecordTypeEndContainer,
    EmfPlusRecordTypeSetWorldTransform,
    EmfPlusRecordTypeResetWorldTransform,
    EmfPlusRecordTypeMultiplyWorldTransform,
    EmfPlusRecordTypeTranslateWorldTransform,
    EmfPlusRecordTypeScaleWorldTransform,
    EmfPlusRecordTypeRotateWorldTransform,
    EmfPlusRecordTypeSetPageTransform,
    EmfPlusRecordTypeResetClip,
    EmfPlusRecordTypeSetClipRect,
    EmfPlusRecordTypeSetClipPath,
    EmfPlusRecordTypeSetClipRegion,
    EmfPlusRecordTypeOffsetClip,

    EmfPlusRecordTypeDrawDriverString,
#if (GDIPVER >= 0x0110)
    EmfPlusRecordTypeStrokeFillPath,
    EmfPlusRecordTypeSerializableObject,

    EmfPlusRecordTypeSetTSGraphics,
    EmfPlusRecordTypeSetTSClip,
#endif
    // NOTE: New records *must* be added immediately before this line.

    EmfPlusRecordTotal,

    EmfPlusRecordTypeMax = EmfPlusRecordTotal-1,
    EmfPlusRecordTypeMin = EmfPlusRecordTypeHeader,
};

//---------------------------------------------------------------------------
// StringFormatFlags
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// String format flags
//
//  DirectionRightToLeft          - For horizontal text, the reading order is
//                                  right to left. This value is called
//                                  the base embedding level by the Unicode
//                                  bidirectional engine.
//                                  For vertical text, columns are read from
//                                  right to left.
//                                  By default, horizontal or vertical text is
//                                  read from left to right.
//
//  DirectionVertical             - Individual lines of text are vertical. In
//                                  each line, characters progress from top to
//                                  bottom.
//                                  By default, lines of text are horizontal,
//                                  each new line below the previous line.
//
//  NoFitBlackBox                 - Allows parts of glyphs to overhang the
//                                  bounding rectangle.
//                                  By default glyphs are first aligned
//                                  inside the margines, then any glyphs which
//                                  still overhang the bounding box are
//                                  repositioned to avoid any overhang.
//                                  For example when an italic
//                                  lower case letter f in a font such as
//                                  Garamond is aligned at the far left of a
//                                  rectangle, the lower part of the f will
//                                  reach slightly further left than the left
//                                  edge of the rectangle. Setting this flag
//                                  will ensure the character aligns visually
//                                  with the lines above and below, but may
//                                  cause some pixels outside the formatting
//                                  rectangle to be clipped or painted.
//
//  DisplayFormatControl          - Causes control characters such as the
//                                  left-to-right mark to be shown in the
//                                  output with a representative glyph.
//
//  NoFontFallback                - Disables fallback to alternate fonts for
//                                  characters not supported in the requested
//                                  font. Any missing characters will be
//                                  be displayed with the fonts missing glyph,
//                                  usually an open square.
//
//  NoWrap                        - Disables wrapping of text between lines
//                                  when formatting within a rectangle.
//                                  NoWrap is implied when a point is passed
//                                  instead of a rectangle, or when the
//                                  specified rectangle has a zero line length.
//
//  NoClip                        - By default text is clipped to the
//                                  formatting rectangle. Setting NoClip
//                                  allows overhanging pixels to affect the
//                                  device outside the formatting rectangle.
//                                  Pixels at the end of the line may be
//                                  affected if the glyphs overhang their
//                                  cells, and either the NoFitBlackBox flag
//                                  has been set, or the glyph extends to far
//                                  to be fitted.
//                                  Pixels above/before the first line or
//                                  below/after the last line may be affected
//                                  if the glyphs extend beyond their cell
//                                  ascent / descent. This can occur rarely
//                                  with unusual diacritic mark combinations.

//---------------------------------------------------------------------------

enum StringFormatFlags
{
    StringFormatFlagsDirectionRightToLeft        = 0x00000001,
    StringFormatFlagsDirectionVertical           = 0x00000002,
    StringFormatFlagsNoFitBlackBox               = 0x00000004,
    StringFormatFlagsDisplayFormatControl        = 0x00000020,
    StringFormatFlagsNoFontFallback              = 0x00000400,
    StringFormatFlagsMeasureTrailingSpaces       = 0x00000800,
    StringFormatFlagsNoWrap                      = 0x00001000,
    StringFormatFlagsLineLimit                   = 0x00002000,

    StringFormatFlagsNoClip                      = 0x00004000,
    StringFormatFlagsBypassGDI                   = 0x80000000
};

//---------------------------------------------------------------------------
// StringTrimming
//---------------------------------------------------------------------------

enum StringTrimming {
    StringTrimmingNone              = 0,
    StringTrimmingCharacter         = 1,
    StringTrimmingWord              = 2,
    StringTrimmingEllipsisCharacter = 3,
    StringTrimmingEllipsisWord      = 4,
    StringTrimmingEllipsisPath      = 5
};

//---------------------------------------------------------------------------
// National language digit substitution
//---------------------------------------------------------------------------

enum StringDigitSubstitute
{
    StringDigitSubstituteUser        = 0,  // As NLS setting
    StringDigitSubstituteNone        = 1,
    StringDigitSubstituteNational    = 2,
    StringDigitSubstituteTraditional = 3
};

//---------------------------------------------------------------------------
// Hotkey prefix interpretation
//---------------------------------------------------------------------------

enum HotkeyPrefix
{
    HotkeyPrefixNone        = 0,
    HotkeyPrefixShow        = 1,
    HotkeyPrefixHide        = 2
};

//---------------------------------------------------------------------------
// String alignment flags
//---------------------------------------------------------------------------

enum StringAlignment
{
    // Left edge for left-to-right text,
    // right for right-to-left text,
    // and top for vertical
    StringAlignmentNear   = 0,
    StringAlignmentCenter = 1,
    StringAlignmentFar    = 2
};

//---------------------------------------------------------------------------
// DriverStringOptions
//---------------------------------------------------------------------------

enum DriverStringOptions
{
    DriverStringOptionsCmapLookup             = 1,
    DriverStringOptionsVertical               = 2,
    DriverStringOptionsRealizedAdvance        = 4,
    DriverStringOptionsLimitSubpixel          = 8
};

//---------------------------------------------------------------------------
// Flush Intention flags
//---------------------------------------------------------------------------

enum FlushIntention
{
    FlushIntentionFlush = 0,        // Flush all batched rendering operations
    FlushIntentionSync = 1          // Flush all batched rendering operations
                                    // and wait for them to complete
};

//---------------------------------------------------------------------------
// Image encoder parameter related types
//---------------------------------------------------------------------------

enum EncoderParameterValueType
{
    EncoderParameterValueTypeByte           = 1,    // 8-bit unsigned int
    EncoderParameterValueTypeASCII          = 2,    // 8-bit byte containing one 7-bit ASCII
                                                    // code. NULL terminated.
    EncoderParameterValueTypeShort          = 3,    // 16-bit unsigned int
    EncoderParameterValueTypeLong           = 4,    // 32-bit unsigned int
    EncoderParameterValueTypeRational       = 5,    // Two Longs. The first Long is the
                                                    // numerator, the second Long expresses the
                                                    // denomintor.
    EncoderParameterValueTypeLongRange      = 6,    // Two longs which specify a range of
                                                    // integer values. The first Long specifies
                                                    // the lower end and the second one
                                                    // specifies the higher end. All values
                                                    // are inclusive at both ends
    EncoderParameterValueTypeUndefined      = 7,    // 8-bit byte that can take any value
                                                    // depending on field definition
    EncoderParameterValueTypeRationalRange  = 8,    // Two Rationals. The first Rational
                                                    // specifies the lower end and the second
                                                    // specifies the higher end. All values
                                                    // are inclusive at both ends
#if (GDIPVER >= 0x0110)
    EncoderParameterValueTypePointer        = 9     // a pointer to a parameter defined data.
#endif //(GDIPVER >= 0x0110)
};

//---------------------------------------------------------------------------
// Image encoder value types
//---------------------------------------------------------------------------

enum EncoderValue
{
    EncoderValueColorTypeCMYK,
    EncoderValueColorTypeYCCK,
    EncoderValueCompressionLZW,
    EncoderValueCompressionCCITT3,
    EncoderValueCompressionCCITT4,
    EncoderValueCompressionRle,
    EncoderValueCompressionNone,
    EncoderValueScanMethodInterlaced,
    EncoderValueScanMethodNonInterlaced,
    EncoderValueVersionGif87,
    EncoderValueVersionGif89,
    EncoderValueRenderProgressive,
    EncoderValueRenderNonProgressive,
    EncoderValueTransformRotate90,
    EncoderValueTransformRotate180,
    EncoderValueTransformRotate270,
    EncoderValueTransformFlipHorizontal,
    EncoderValueTransformFlipVertical,
    EncoderValueMultiFrame,
    EncoderValueLastFrame,
    EncoderValueFlush,
    EncoderValueFrameDimensionTime,
    EncoderValueFrameDimensionResolution,
    EncoderValueFrameDimensionPage,
#if (GDIPVER >= 0x0110)
    EncoderValueColorTypeGray,
    EncoderValueColorTypeRGB,
#endif
};

//---------------------------------------------------------------------------
// Conversion of Emf To WMF Bits flags
//---------------------------------------------------------------------------

enum EmfToWmfBitsFlags
{
    EmfToWmfBitsFlagsDefault          = 0x00000000,
    EmfToWmfBitsFlagsEmbedEmf         = 0x00000001,
    EmfToWmfBitsFlagsIncludePlaceable = 0x00000002,
    EmfToWmfBitsFlagsNoXORClip        = 0x00000004
};

#if (GDIPVER >= 0x0110)
//---------------------------------------------------------------------------
// Conversion of Emf To Emf+ Bits flags
//---------------------------------------------------------------------------

enum ConvertToEmfPlusFlags
{
    ConvertToEmfPlusFlagsDefault       = 0x00000000,
    ConvertToEmfPlusFlagsRopUsed       = 0x00000001,
    ConvertToEmfPlusFlagsText          = 0x00000002,
    ConvertToEmfPlusFlagsInvalidRecord = 0x00000004
};
#endif


//---------------------------------------------------------------------------
// Test Control flags
//---------------------------------------------------------------------------

enum GpTestControlEnum
{
    TestControlForceBilinear = 0,
    TestControlNoICM = 1,
    TestControlGetBuildNumber = 2
};



#endif // !_GDIPLUSENUMS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\gdipluseffects.h ===
/**************************************************************************
*
* Copyright (c) 2001 Microsoft Corporation
*
* Module Name:
*
*   Gdiplus effect objects.
*
* Created:
*
*   05/29/2001 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _GDIPLUSEFFECTS_HPP
#define _GDIPLUSEFFECTS_HPP

#if (GDIPVER >= 0x0110)

//-----------------------------------------------------------------------------
// GDI+ effect GUIDs
//-----------------------------------------------------------------------------

// {633C80A4-1843-482b-9EF2-BE2834C5FDD4}
static const GUID BlurEffectGuid = 
{ 0x633c80a4, 0x1843, 0x482b, { 0x9e, 0xf2, 0xbe, 0x28, 0x34, 0xc5, 0xfd, 0xd4 } };

// {63CBF3EE-C526-402c-8F71-62C540BF5142}
static const GUID SharpenEffectGuid = 
{ 0x63cbf3ee, 0xc526, 0x402c, { 0x8f, 0x71, 0x62, 0xc5, 0x40, 0xbf, 0x51, 0x42 } };

// {718F2615-7933-40e3-A511-5F68FE14DD74}
static const GUID ColorMatrixEffectGuid = 
{ 0x718f2615, 0x7933, 0x40e3, { 0xa5, 0x11, 0x5f, 0x68, 0xfe, 0x14, 0xdd, 0x74 } };

// {A7CE72A9-0F7F-40d7-B3CC-D0C02D5C3212}
static const GUID ColorLUTEffectGuid = 
{ 0xa7ce72a9, 0xf7f, 0x40d7, { 0xb3, 0xcc, 0xd0, 0xc0, 0x2d, 0x5c, 0x32, 0x12 } };

// {D3A1DBE1-8EC4-4c17-9F4C-EA97AD1C343D}
static const GUID BrightnessContrastEffectGuid = 
{ 0xd3a1dbe1, 0x8ec4, 0x4c17, { 0x9f, 0x4c, 0xea, 0x97, 0xad, 0x1c, 0x34, 0x3d } };

// {8B2DD6C3-EB07-4d87-A5F0-7108E26A9C5F}
static const GUID HueSaturationLightnessEffectGuid = 
{ 0x8b2dd6c3, 0xeb07, 0x4d87, { 0xa5, 0xf0, 0x71, 0x8, 0xe2, 0x6a, 0x9c, 0x5f } };

// {99C354EC-2A31-4f3a-8C34-17A803B33A25}
static const GUID LevelsEffectGuid = 
{ 0x99c354ec, 0x2a31, 0x4f3a, { 0x8c, 0x34, 0x17, 0xa8, 0x3, 0xb3, 0x3a, 0x25 } };

// {1077AF00-2848-4441-9489-44AD4C2D7A2C}
static const GUID TintEffectGuid = 
{ 0x1077af00, 0x2848, 0x4441, { 0x94, 0x89, 0x44, 0xad, 0x4c, 0x2d, 0x7a, 0x2c } };

// {537E597D-251E-48da-9664-29CA496B70F8}
static const GUID ColorBalanceEffectGuid = 
{ 0x537e597d, 0x251e, 0x48da, { 0x96, 0x64, 0x29, 0xca, 0x49, 0x6b, 0x70, 0xf8 } };

// {74D29D05-69A4-4266-9549-3CC52836B632}
static const GUID RedEyeCorrectionEffectGuid = 
{ 0x74d29d05, 0x69a4, 0x4266, { 0x95, 0x49, 0x3c, 0xc5, 0x28, 0x36, 0xb6, 0x32 } };

// {DD6A0022-58E4-4a67-9D9B-D48EB881A53D}
static const GUID ColorCurveEffectGuid =
{ 0xdd6a0022, 0x58e4, 0x4a67, { 0x9d, 0x9b, 0xd4, 0x8e, 0xb8, 0x81, 0xa5, 0x3d }
 };

//-----------------------------------------------------------------------------

struct SharpenParams
{
    float radius;
    float amount;
};

struct BlurParams
{
    float radius;
    BOOL expandEdge;
};

struct BrightnessContrastParams
{
    INT brightnessLevel;
    INT contrastLevel;
};

struct RedEyeCorrectionParams
{
    UINT numberOfAreas;
    RECT *areas;
};

struct HueSaturationLightnessParams
{
    INT hueLevel;
    INT saturationLevel;
    INT lightnessLevel;
};

struct TintParams
{
    INT hue;
    INT amount;
};

struct LevelsParams
{
    INT highlight;
    INT midtone;
    INT shadow;
};

struct ColorBalanceParams
{
    INT cyanRed;
    INT magentaGreen;
    INT yellowBlue;
};

struct ColorLUTParams
{
    // look up tables for each color channel.
    
    ColorChannelLUT lutB;
    ColorChannelLUT lutG;
    ColorChannelLUT lutR;
    ColorChannelLUT lutA;
};

enum CurveAdjustments
{
    AdjustExposure,
    AdjustDensity,
    AdjustContrast,
    AdjustHighlight,
    AdjustShadow,
    AdjustMidtone,
    AdjustWhiteSaturation,
    AdjustBlackSaturation
};

enum CurveChannel
{
    CurveChannelAll,
    CurveChannelRed,
    CurveChannelGreen,
    CurveChannelBlue
};

struct ColorCurveParams
{
    CurveAdjustments adjustment;
    CurveChannel channel;
    INT adjustValue;
};

class CGpEffect;

extern "C" {
Status __stdcall
GdipCreateEffect(const GUID guid, CGpEffect **effect);

Status __stdcall
GdipDeleteEffect(CGpEffect *effect);

Status __stdcall
GdipGetEffectParameterSize(CGpEffect *effect, UINT *size);

Status __stdcall
GdipSetEffectParameters(CGpEffect *effect, const VOID *params, const UINT size);

Status __stdcall
GdipGetEffectParameters(CGpEffect *effect, UINT *size, VOID *params);
}

#ifndef _GDIPLUSEFFECTS_EXCLUDEOBJECTS

class Effect
{
    friend class Bitmap;
    friend class Graphics;
    
public:

    Effect()
    {
        auxDataSize = 0;
        auxData = NULL;
        nativeEffect = NULL;
        useAuxData = FALSE;
    }
    
    virtual ~Effect()
    {
        // pvData is allocated by ApplyEffect. Return the pointer so that
        // it can be freed by the appropriate memory manager.
        
        DllExports::GdipFree(auxData);
        
        // Release the native Effect.
        
        GdipDeleteEffect(nativeEffect);
    }
    
    INT GetAuxDataSize() const
    {
        return auxDataSize;
    }
    
    VOID *GetAuxData() const
    {
        return auxData;
    }
    
    VOID UseAuxData(const BOOL useAuxDataFlag)
    {
        useAuxData = useAuxDataFlag;
    }

    Status GetParameterSize(UINT *size)
    {
        return GdipGetEffectParameterSize(nativeEffect, size);
    }
    
protected:
    
    Status SetParameters(const void *params, const UINT size)
    {
        return GdipSetEffectParameters(nativeEffect, params, size);
    }

    Status GetParameters(UINT *size, void *params)
    {
        return GdipGetEffectParameters(nativeEffect, size, params);
    }

    // protected data members.
    
    CGpEffect *nativeEffect;
    INT auxDataSize;
    VOID *auxData;
    BOOL useAuxData;
};

// Blur

class Blur : public Effect
{
    public:
    
    // constructors cannot return an error code.
    
    Blur()
    { 
        GdipCreateEffect(BlurEffectGuid, &nativeEffect);
    }

    Status SetParameters(const BlurParams *parameters)
    {
        UINT size = sizeof(BlurParams);
        return Effect::SetParameters(parameters, size);
    }

    Status GetParameters(UINT *size, BlurParams *parameters)
    {
        return Effect::GetParameters(size, (VOID*)parameters);
    }
};

// Sharpen

class Sharpen : public Effect
{
public:
    
    Sharpen()
    { 
        GdipCreateEffect(SharpenEffectGuid, &nativeEffect);
    }

    Status SetParameters(const SharpenParams *parameters)
    {
        UINT size = sizeof(SharpenParams);
        return Effect::SetParameters(parameters, size);
    }

    Status GetParameters(UINT *size, SharpenParams *parameters)
    {
        return Effect::GetParameters(size, (VOID*)parameters);
    }
};

// RedEye Correction

class RedEyeCorrection : public Effect
{
public:
    
    // constructors cannot return an error code.
    
    RedEyeCorrection()
    { 
        GdipCreateEffect(RedEyeCorrectionEffectGuid, &nativeEffect);
    }
    
    Status SetParameters(const RedEyeCorrectionParams *parameters)
    {
        Status status = InvalidParameter;

        if (parameters)
        {
            RedEyeCorrectionParams *inputParam =
                (RedEyeCorrectionParams*)parameters;

            UINT size = sizeof(RedEyeCorrectionParams) +
                inputParam->numberOfAreas * sizeof(RECT);

            status = Effect::SetParameters(parameters, size);
        }

        return status;
    }    
    
    Status GetParameters(UINT *size, RedEyeCorrectionParams *parameters)
    {
        return Effect::GetParameters(size,(VOID*)parameters);
    }
};

// Brightness/Contrast
class BrightnessContrast : public Effect
{
public:
    BrightnessContrast()
    {
        GdipCreateEffect(BrightnessContrastEffectGuid, &nativeEffect);
    }

    Status SetParameters(const BrightnessContrastParams *parameters)
    {
        UINT size = sizeof(BrightnessContrastParams);
        return Effect::SetParameters((VOID*)parameters, size);
    }
    
    Status GetParameters(UINT *size, BrightnessContrastParams *parameters)
    {
        return Effect::GetParameters(size, (VOID*)parameters);
    }
};

// Hue/Saturation/Lightness

class HueSaturationLightness : public Effect
{
public:
    HueSaturationLightness()
    {
        GdipCreateEffect(HueSaturationLightnessEffectGuid, &nativeEffect);
    }

    Status SetParameters(const HueSaturationLightnessParams *parameters)
    {
        UINT size = sizeof(HueSaturationLightnessParams);
        return Effect::SetParameters((VOID*)parameters, size);
    }

    Status GetParameters(UINT *size, HueSaturationLightnessParams *parameters)
    {
        return Effect::GetParameters(size, (VOID*)parameters);
    }
};

// Highlight/Midtone/Shadow curves

class Levels : public Effect
{
public:
    Levels()
    {
        GdipCreateEffect(LevelsEffectGuid, &nativeEffect);
    }
    
    Status SetParameters(const LevelsParams *parameters)
    {
        UINT size = sizeof(LevelsParams);
        return Effect::SetParameters((VOID*)parameters, size);
    }

    Status GetParameters(UINT *size, LevelsParams *parameters)
    {
        return Effect::GetParameters(size, (VOID*)parameters);
    }
};

// Tint

class Tint : public Effect
{
public:
    Tint()
    {
        GdipCreateEffect(TintEffectGuid, &nativeEffect);
    }
    
    Status SetParameters(const TintParams *parameters)
    {
        UINT size = sizeof(TintParams);
        return Effect::SetParameters((VOID*)parameters, size);
    }

    Status GetParameters(UINT *size, TintParams *parameters)
    {
        return Effect::GetParameters(size, (VOID*)parameters);
    }
};

// ColorBalance

class ColorBalance : public Effect
{
public:
    ColorBalance()
    {
        GdipCreateEffect(ColorBalanceEffectGuid, &nativeEffect);
    }
    
    Status SetParameters(const ColorBalanceParams *parameters)
    {
        UINT size = sizeof(ColorBalanceParams);
        return Effect::SetParameters((VOID*)parameters, size);
    }

    Status GetParameters(UINT *size, ColorBalanceParams *parameters)
    {
        return Effect::GetParameters(size, (VOID*)parameters);
    }
};

// ColorMatrix

class ColorMatrixEffect : public Effect
{
public:
    
    // constructors cannot return an error code.
    
    ColorMatrixEffect()
    { 
        GdipCreateEffect(ColorMatrixEffectGuid, &nativeEffect);
    }
    
    Status SetParameters(const ColorMatrix *matrix)
    {
        UINT size = sizeof(ColorMatrix);
        return Effect::SetParameters(matrix, size);
    }

    Status GetParameters(UINT *size, ColorMatrix *matrix)
    {
        return Effect::GetParameters(size, (VOID*)matrix);
    }
};


// ColorLUT

class ColorLUT : public Effect
{
    public:
    
    // constructors cannot return an error code.
    
    ColorLUT()
    { 
        GdipCreateEffect(ColorLUTEffectGuid, &nativeEffect);
    }

    Status SetParameters(const ColorLUTParams *lut)
    {
        UINT size = sizeof(ColorLUTParams);
        return Effect::SetParameters(lut, size);
    }

    Status GetParameters(UINT *size, ColorLUTParams *lut)
    {
        return Effect::GetParameters(size, (VOID*)lut);
    }
};

// Color Curve

class ColorCurve : public Effect
{
public:
    ColorCurve()
    {
        GdipCreateEffect(ColorCurveEffectGuid, &nativeEffect);
    }

    Status SetParameters(const ColorCurveParams *parameters)
    {
        UINT size = sizeof(ColorCurveParams);
        return Effect::SetParameters((VOID*)parameters, size);
    }

    Status GetParameters(UINT *size, ColorCurveParams *parameters)
    {
        return Effect::GetParameters(size, (VOID*)parameters);
    }
};

#endif // _GDIPLUSEFFECTS_EXCLUDEEOBJECTS

#endif //(GDIPVER >= 0x0110)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusInit.h ===
/**************************************************************************
*
* Copyright (c) 2000-2003 Microsoft Corporation
*
* Module Name:
*
*   Gdiplus initialization
*
* Abstract:
*
*   GDI+ Startup and Shutdown APIs
*
**************************************************************************/

#ifndef _GDIPLUSINIT_H
#define _GDIPLUSINIT_H

enum DebugEventLevel
{
    DebugEventLevelFatal,
    DebugEventLevelWarning
};

// Callback function that GDI+ can call, on debug builds, for assertions
// and warnings.

typedef VOID (WINAPI *DebugEventProc)(DebugEventLevel level, CHAR *message);

// Notification functions which the user must call appropriately if
// "SuppressBackgroundThread" (below) is set.

typedef Status (WINAPI *NotificationHookProc)(OUT ULONG_PTR *token);
typedef VOID (WINAPI *NotificationUnhookProc)(ULONG_PTR token);

// Input structure for GdiplusStartup()

struct GdiplusStartupInput
{
    UINT32 GdiplusVersion;             // Must be 1  (or 2 for the Ex version)
    DebugEventProc DebugEventCallback; // Ignored on free builds
    BOOL SuppressBackgroundThread;     // FALSE unless you're prepared to call 
                                       // the hook/unhook functions properly
    BOOL SuppressExternalCodecs;       // FALSE unless you want GDI+ only to use
                                       // its internal image codecs.
    
    GdiplusStartupInput(
        DebugEventProc debugEventCallback = NULL,
        BOOL suppressBackgroundThread = FALSE,
        BOOL suppressExternalCodecs = FALSE)
    {
        GdiplusVersion = 1;
        DebugEventCallback = debugEventCallback;
        SuppressBackgroundThread = suppressBackgroundThread;
        SuppressExternalCodecs = suppressExternalCodecs;
    }
};

#if (GDIPVER >= 0x0110)
struct GdiplusStartupInputEx : GdiplusStartupInput
{
    INT StartupParameters;  // Do we not set the FPU rounding mode

    GdiplusStartupInputEx(
        INT startupParameters = 0,
        DebugEventProc debugEventCallback = NULL,
        BOOL suppressBackgroundThread = FALSE,
        BOOL suppressExternalCodecs = FALSE)
    {
        GdiplusVersion = 2;
        DebugEventCallback = debugEventCallback;
        SuppressBackgroundThread = suppressBackgroundThread;
        SuppressExternalCodecs = suppressExternalCodecs;
        StartupParameters = startupParameters;
    }
};

enum GdiplusStartupParams
{
    GdiplusStartupDefault = 0,
    GdiplusStartupNoSetRound = 1,
    GdiplusStartupSetPSValue = 2,
    GdiplusStartupTransparencyMask = 0xFF000000
};

#endif


// Output structure for GdiplusStartup()

struct GdiplusStartupOutput
{
    // The following 2 fields are NULL if SuppressBackgroundThread is FALSE.
    // Otherwise, they are functions which must be called appropriately to
    // replace the background thread.
    //
    // These should be called on the application's main message loop - i.e.
    // a message loop which is active for the lifetime of GDI+.
    // "NotificationHook" should be called before starting the loop,
    // and "NotificationUnhook" should be called after the loop ends.
    
    NotificationHookProc NotificationHook;
    NotificationUnhookProc NotificationUnhook;
};

// GDI+ initialization. Must not be called from DllMain - can cause deadlock.
//
// Must be called before GDI+ API's or constructors are used.
//
// token  - may not be NULL - accepts a token to be passed in the corresponding
//          GdiplusShutdown call.
// input  - may not be NULL
// output - may be NULL only if input->SuppressBackgroundThread is FALSE.

extern "C" Status WINAPI GdiplusStartup(
    OUT ULONG_PTR *token,
    const GdiplusStartupInput *input,
    OUT GdiplusStartupOutput *output);

// GDI+ termination. Must be called before GDI+ is unloaded. 
// Must not be called from DllMain - can cause deadlock.
//
// GDI+ API's may not be called after GdiplusShutdown. Pay careful attention
// to GDI+ object destructors.

extern "C" VOID WINAPI GdiplusShutdown(ULONG_PTR token);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusFlat.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusFlat.h
*
* Abstract:
*
*   Private GDI+ header file.
*
\**************************************************************************/

#ifndef _FLATAPI_H
#define _FLATAPI_H

#define WINGDIPAPI __stdcall

#define GDIPCONST const

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
// GraphicsPath APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePath(GpFillMode brushMode, GpPath **path);

GpStatus WINGDIPAPI
GdipCreatePath2(GDIPCONST GpPointF*, GDIPCONST BYTE*, INT, GpFillMode,
                                    GpPath **path);

GpStatus WINGDIPAPI
GdipCreatePath2I(GDIPCONST GpPoint*, GDIPCONST BYTE*, INT, GpFillMode,
                                     GpPath **path);

GpStatus WINGDIPAPI
GdipClonePath(GpPath* path, GpPath **clonePath);

GpStatus WINGDIPAPI
GdipDeletePath(GpPath* path);

GpStatus WINGDIPAPI
GdipResetPath(GpPath* path);

GpStatus WINGDIPAPI
GdipGetPointCount(GpPath* path, INT* count);

GpStatus WINGDIPAPI
GdipGetPathTypes(GpPath* path, BYTE* types, INT count);

GpStatus WINGDIPAPI
GdipGetPathPoints(GpPath*, GpPointF* points, INT count);

GpStatus WINGDIPAPI
GdipGetPathPointsI(GpPath*, GpPoint* points, INT count);

GpStatus WINGDIPAPI
GdipGetPathFillMode(GpPath *path, GpFillMode *fillmode);

GpStatus WINGDIPAPI
GdipSetPathFillMode(GpPath *path, GpFillMode fillmode);

GpStatus WINGDIPAPI
GdipGetPathData(GpPath *path, GpPathData* pathData);

GpStatus WINGDIPAPI
GdipStartPathFigure(GpPath *path);

GpStatus WINGDIPAPI
GdipClosePathFigure(GpPath *path);

GpStatus WINGDIPAPI
GdipClosePathFigures(GpPath *path);

GpStatus WINGDIPAPI
GdipSetPathMarker(GpPath* path);

GpStatus WINGDIPAPI
GdipClearPathMarkers(GpPath* path);

GpStatus WINGDIPAPI
GdipReversePath(GpPath* path);

GpStatus WINGDIPAPI
GdipGetPathLastPoint(GpPath* path, GpPointF* lastPoint);

GpStatus WINGDIPAPI
GdipAddPathLine(GpPath *path, REAL x1, REAL y1, REAL x2, REAL y2);

GpStatus WINGDIPAPI
GdipAddPathLine2(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathArc(GpPath *path, REAL x, REAL y, REAL width, REAL height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathBezier(GpPath *path, REAL x1, REAL y1, REAL x2, REAL y2,
                           REAL x3, REAL y3, REAL x4, REAL y4);

GpStatus WINGDIPAPI
GdipAddPathBeziers(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve2(GpPath *path, GDIPCONST GpPointF *points, INT count,
                           REAL tension);

GpStatus WINGDIPAPI
GdipAddPathCurve3(GpPath *path, GDIPCONST GpPointF *points, INT count,
                           INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve2(GpPath *path, GDIPCONST GpPointF *points, INT count,
                                 REAL tension);

GpStatus WINGDIPAPI
GdipAddPathRectangle(GpPath *path, REAL x, REAL y, REAL width, REAL height);

GpStatus WINGDIPAPI
GdipAddPathRectangles(GpPath *path, GDIPCONST GpRectF *rects, INT count);

GpStatus WINGDIPAPI
GdipAddPathEllipse(GpPath *path, REAL x, REAL y, REAL width,
                            REAL height);

GpStatus WINGDIPAPI
GdipAddPathPie(GpPath *path, REAL x, REAL y, REAL width, REAL height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathPolygon(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathPath(GpPath *path, GDIPCONST GpPath* addingPath, BOOL connect);

GpStatus WINGDIPAPI
GdipAddPathString(GpPath *path, GDIPCONST WCHAR *string,
                        INT length, GDIPCONST GpFontFamily *family, INT style,
                        REAL emSize, GDIPCONST RectF *layoutRect,
                        GDIPCONST GpStringFormat *format);

GpStatus WINGDIPAPI
GdipAddPathStringI(GpPath *path, GDIPCONST WCHAR *string,
                        INT length, GDIPCONST GpFontFamily *family, INT style,
                        REAL emSize, GDIPCONST Rect *layoutRect,
                        GDIPCONST GpStringFormat *format);

GpStatus WINGDIPAPI
GdipAddPathLineI(GpPath *path, INT x1, INT y1, INT x2, INT y2);

GpStatus WINGDIPAPI
GdipAddPathLine2I(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathArcI(GpPath *path, INT x, INT y, INT width, INT height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathBezierI(GpPath *path, INT x1, INT y1, INT x2, INT y2,
                           INT x3, INT y3, INT x4, INT y4);

GpStatus WINGDIPAPI
GdipAddPathBeziersI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurveI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve2I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                           REAL tension);

GpStatus WINGDIPAPI
GdipAddPathCurve3I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                           INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipAddPathClosedCurveI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve2I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                                 REAL tension);

GpStatus WINGDIPAPI
GdipAddPathRectangleI(GpPath *path, INT x, INT y, INT width, INT height);

GpStatus WINGDIPAPI
GdipAddPathRectanglesI(GpPath *path, GDIPCONST GpRect *rects, INT count);

GpStatus WINGDIPAPI
GdipAddPathEllipseI(GpPath *path, INT x, INT y, INT width, INT height);

GpStatus WINGDIPAPI
GdipAddPathPieI(GpPath *path, INT x, INT y, INT width, INT height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathPolygonI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFlattenPath(GpPath *path, GpMatrix* matrix, REAL flatness);

GpStatus WINGDIPAPI
GdipWindingModeOutline(
    GpPath *path,
    GpMatrix *matrix,
    REAL flatness
);

GpStatus WINGDIPAPI
GdipWidenPath(
    GpPath *nativePath,
    GpPen *pen,
    GpMatrix *matrix,
    REAL flatness
);

GpStatus WINGDIPAPI
GdipWarpPath(GpPath *path, GpMatrix* matrix,
            GDIPCONST GpPointF *points, INT count,
            REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight,
            WarpMode warpMode, REAL flatness);

GpStatus WINGDIPAPI
GdipTransformPath(GpPath* path, GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetPathWorldBounds(GpPath* path, GpRectF* bounds, 
                       GDIPCONST GpMatrix *matrix, GDIPCONST GpPen *pen);

GpStatus WINGDIPAPI
GdipGetPathWorldBoundsI(GpPath* path, GpRect* bounds, 
                        GDIPCONST GpMatrix *matrix, GDIPCONST GpPen *pen);

GpStatus WINGDIPAPI
GdipIsVisiblePathPoint(GpPath* path, REAL x, REAL y,
                       GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePathPointI(GpPath* path, INT x, INT y,
                        GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsOutlineVisiblePathPoint(GpPath* path, REAL x, REAL y, GpPen *pen,
                              GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsOutlineVisiblePathPointI(GpPath* path, INT x, INT y, GpPen *pen,
                               GpGraphics *graphics, BOOL *result);


//----------------------------------------------------------------------------
// PathIterator APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePathIter(GpPathIterator **iterator, GpPath* path);

GpStatus WINGDIPAPI
GdipDeletePathIter(GpPathIterator *iterator);

GpStatus WINGDIPAPI
GdipPathIterNextSubpath(GpPathIterator* iterator, INT *resultCount,
        INT* startIndex, INT* endIndex, BOOL* isClosed);

GpStatus WINGDIPAPI
GdipPathIterNextSubpathPath(GpPathIterator* iterator, INT* resultCount,
        GpPath* path, BOOL* isClosed);

GpStatus WINGDIPAPI
GdipPathIterNextPathType(GpPathIterator* iterator, INT* resultCount,
        BYTE* pathType, INT* startIndex, INT* endIndex);

GpStatus WINGDIPAPI
GdipPathIterNextMarker(GpPathIterator* iterator, INT *resultCount,
        INT* startIndex, INT* endIndex);

GpStatus WINGDIPAPI
GdipPathIterNextMarkerPath(GpPathIterator* iterator, INT* resultCount,
        GpPath* path);

GpStatus WINGDIPAPI
GdipPathIterGetCount(GpPathIterator* iterator, INT* count);

GpStatus WINGDIPAPI
GdipPathIterGetSubpathCount(GpPathIterator* iterator, INT* count);

GpStatus WINGDIPAPI
GdipPathIterIsValid(GpPathIterator* iterator, BOOL* valid);

GpStatus WINGDIPAPI
GdipPathIterHasCurve(GpPathIterator* iterator, BOOL* hasCurve);

GpStatus WINGDIPAPI
GdipPathIterRewind(GpPathIterator* iterator);

GpStatus WINGDIPAPI
GdipPathIterEnumerate(GpPathIterator* iterator, INT* resultCount,
    GpPointF *points, BYTE *types, INT count);

GpStatus WINGDIPAPI
GdipPathIterCopyData(GpPathIterator* iterator, INT* resultCount,
    GpPointF* points, BYTE* types, INT startIndex, INT endIndex);

//----------------------------------------------------------------------------
// Matrix APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateMatrix(GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix2(REAL m11, REAL m12, REAL m21, REAL m22, REAL dx,
                                      REAL dy, GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix3(GDIPCONST GpRectF *rect, GDIPCONST GpPointF *dstplg,
                                      GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix3I(GDIPCONST GpRect *rect, GDIPCONST GpPoint *dstplg,
                                       GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCloneMatrix(GpMatrix *matrix, GpMatrix **cloneMatrix);

GpStatus WINGDIPAPI
GdipDeleteMatrix(GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetMatrixElements(GpMatrix *matrix, REAL m11, REAL m12, REAL m21, REAL m22,
                      REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipMultiplyMatrix(GpMatrix *matrix, GpMatrix* matrix2,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateMatrix(GpMatrix *matrix, REAL offsetX, REAL offsetY,
                    GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleMatrix(GpMatrix *matrix, REAL scaleX, REAL scaleY,
                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateMatrix(GpMatrix *matrix, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipShearMatrix(GpMatrix *matrix, REAL shearX, REAL shearY,
                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipInvertMatrix(GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipTransformMatrixPoints(GpMatrix *matrix, GpPointF *pts, INT count);

GpStatus WINGDIPAPI
GdipTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts, INT count);

GpStatus WINGDIPAPI
GdipVectorTransformMatrixPoints(GpMatrix *matrix, GpPointF *pts,
                                         INT count);

GpStatus WINGDIPAPI
GdipVectorTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts,
                                         INT count);

GpStatus WINGDIPAPI
GdipGetMatrixElements(GDIPCONST GpMatrix *matrix, REAL *matrixOut);

GpStatus WINGDIPAPI
GdipIsMatrixInvertible(GDIPCONST GpMatrix *matrix, BOOL *result);

GpStatus WINGDIPAPI
GdipIsMatrixIdentity(GDIPCONST GpMatrix *matrix, BOOL *result);

GpStatus WINGDIPAPI
GdipIsMatrixEqual(GDIPCONST GpMatrix *matrix, GDIPCONST GpMatrix *matrix2, 
                  BOOL *result);

//----------------------------------------------------------------------------
// Region APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateRegion(GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRect(GDIPCONST GpRectF *rect, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRectI(GDIPCONST GpRect *rect, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionPath(GpPath *path, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRgnData(GDIPCONST BYTE *regionData, INT size, 
                        GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionHrgn(HRGN hRgn, GpRegion **region);

GpStatus WINGDIPAPI
GdipCloneRegion(GpRegion *region, GpRegion **cloneRegion);

GpStatus WINGDIPAPI
GdipDeleteRegion(GpRegion *region);

GpStatus WINGDIPAPI
GdipSetInfinite(GpRegion *region);

GpStatus WINGDIPAPI
GdipSetEmpty(GpRegion *region);

GpStatus WINGDIPAPI
GdipCombineRegionRect(GpRegion *region, GDIPCONST GpRectF *rect,
                      CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionRectI(GpRegion *region, GDIPCONST GpRect *rect,
                       CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionPath(GpRegion *region, GpPath *path, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionRegion(GpRegion *region,  GpRegion *region2,
                        CombineMode combineMode);

GpStatus WINGDIPAPI
GdipTranslateRegion(GpRegion *region, REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipTranslateRegionI(GpRegion *region, INT dx, INT dy);

GpStatus WINGDIPAPI
GdipTransformRegion(GpRegion *region, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipGetRegionBounds(GpRegion *region, GpGraphics *graphics,
                             GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetRegionBoundsI(GpRegion *region, GpGraphics *graphics,
                             GpRect *rect);

GpStatus WINGDIPAPI
GdipGetRegionHRgn(GpRegion *region, GpGraphics *graphics, HRGN *hRgn);

GpStatus WINGDIPAPI
GdipIsEmptyRegion(GpRegion *region, GpGraphics *graphics,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsInfiniteRegion(GpRegion *region, GpGraphics *graphics,
                              BOOL *result);

GpStatus WINGDIPAPI
GdipIsEqualRegion(GpRegion *region, GpRegion *region2,
                           GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetRegionDataSize(GpRegion *region, UINT * bufferSize);

GpStatus WINGDIPAPI
GdipGetRegionData(GpRegion *region, BYTE * buffer, UINT bufferSize, 
                  UINT * sizeFilled);

GpStatus WINGDIPAPI
GdipIsVisibleRegionPoint(GpRegion *region, REAL x, REAL y,
                                  GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionPointI(GpRegion *region, INT x, INT y,
                                  GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionRect(GpRegion *region, REAL x, REAL y, REAL width,
                        REAL height, GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionRectI(GpRegion *region, INT x, INT y, INT width,
                         INT height, GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetRegionScansCount(GpRegion *region, UINT* count, GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetRegionScans(GpRegion *region, GpRectF* rects, INT* count, 
                   GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetRegionScansI(GpRegion *region, GpRect* rects, INT* count, 
                    GpMatrix* matrix);

//----------------------------------------------------------------------------
// Brush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCloneBrush(GpBrush *brush, GpBrush **cloneBrush);

GpStatus WINGDIPAPI
GdipDeleteBrush(GpBrush *brush);

GpStatus WINGDIPAPI
GdipGetBrushType(GpBrush *brush, GpBrushType *type);

//----------------------------------------------------------------------------
// HatchBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateHatchBrush(GpHatchStyle hatchstyle, ARGB forecol,
                              ARGB backcol, GpHatch **brush);

GpStatus WINGDIPAPI
GdipGetHatchStyle(GpHatch *brush, GpHatchStyle *hatchstyle);

GpStatus WINGDIPAPI
GdipGetHatchForegroundColor(GpHatch *brush, ARGB* forecol);

GpStatus WINGDIPAPI
GdipGetHatchBackgroundColor(GpHatch *brush, ARGB* backcol);

//----------------------------------------------------------------------------
// TextureBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateTexture(GpImage *image, GpWrapMode wrapmode,
                           GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTexture2(GpImage *image, GpWrapMode wrapmode, REAL x,
                   REAL y, REAL width, REAL height, GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTextureIA(GpImage *image, 
                    GDIPCONST GpImageAttributes *imageAttributes,
                    REAL x, REAL y, REAL width, REAL height,
                    GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTexture2I(GpImage *image, GpWrapMode wrapmode, INT x,
                    INT y, INT width, INT height, GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTextureIAI(GpImage *image, 
                     GDIPCONST GpImageAttributes *imageAttributes,
                     INT x, INT y, INT width, INT height,
                     GpTexture **texture);


GpStatus WINGDIPAPI
GdipGetTextureTransform(GpTexture *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetTextureTransform(GpTexture *brush, GDIPCONST GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetTextureTransform(GpTexture* brush);

GpStatus WINGDIPAPI
GdipMultiplyTextureTransform(GpTexture* brush, GDIPCONST GpMatrix *matrix,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateTextureTransform(GpTexture* brush, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleTextureTransform(GpTexture* brush, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateTextureTransform(GpTexture* brush, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipSetTextureWrapMode(GpTexture *brush, GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetTextureWrapMode(GpTexture *brush, GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipGetTextureImage(GpTexture *brush, GpImage **image);

//----------------------------------------------------------------------------
// SolidBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateSolidFill(ARGB color, GpSolidFill **brush);

GpStatus WINGDIPAPI
GdipSetSolidFillColor(GpSolidFill *brush, ARGB color);

GpStatus WINGDIPAPI
GdipGetSolidFillColor(GpSolidFill *brush, ARGB *color);

//----------------------------------------------------------------------------
// LineBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateLineBrush(GDIPCONST GpPointF* point1,
                    GDIPCONST GpPointF* point2,
                    ARGB color1, ARGB color2,
                    GpWrapMode wrapMode,
                    GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushI(GDIPCONST GpPoint* point1,
                     GDIPCONST GpPoint* point2,
                     ARGB color1, ARGB color2,
                     GpWrapMode wrapMode,
                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRect(GDIPCONST GpRectF* rect,
                            ARGB color1, ARGB color2,
                            LinearGradientMode mode,
                            GpWrapMode wrapMode,
                            GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectI(GDIPCONST GpRect* rect,
                             ARGB color1, ARGB color2,
                             LinearGradientMode mode,
                             GpWrapMode wrapMode,
                             GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectWithAngle(GDIPCONST GpRectF* rect,
                                     ARGB color1, ARGB color2,
                                     REAL angle,
                                     BOOL isAngleScalable,
                                     GpWrapMode wrapMode,
                                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectWithAngleI(GDIPCONST GpRect* rect,
                                     ARGB color1, ARGB color2,
                                     REAL angle,
                                     BOOL isAngleScalable,
                                     GpWrapMode wrapMode,
                                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipSetLineColors(GpLineGradient *brush, ARGB color1, ARGB color2);

GpStatus WINGDIPAPI
GdipGetLineColors(GpLineGradient *brush, ARGB* colors);

GpStatus WINGDIPAPI
GdipGetLineRect(GpLineGradient *brush, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetLineRectI(GpLineGradient *brush, GpRect *rect);

GpStatus WINGDIPAPI
GdipSetLineGammaCorrection(GpLineGradient *brush, BOOL useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetLineGammaCorrection(GpLineGradient *brush, BOOL *useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetLineBlendCount(GpLineGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetLineBlend(GpLineGradient *brush, REAL *blend, REAL* positions,
                 INT count);

GpStatus WINGDIPAPI
GdipSetLineBlend(GpLineGradient *brush, GDIPCONST REAL *blend,
                 GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipGetLinePresetBlendCount(GpLineGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetLinePresetBlend(GpLineGradient *brush, ARGB *blend,
                                           REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetLinePresetBlend(GpLineGradient *brush, GDIPCONST ARGB *blend,
                       GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetLineSigmaBlend(GpLineGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetLineLinearBlend(GpLineGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetLineWrapMode(GpLineGradient *brush, GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetLineWrapMode(GpLineGradient *brush, GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipGetLineTransform(GpLineGradient *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetLineTransform(GpLineGradient *brush, GDIPCONST GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetLineTransform(GpLineGradient* brush);

GpStatus WINGDIPAPI
GdipMultiplyLineTransform(GpLineGradient* brush, GDIPCONST GpMatrix *matrix,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateLineTransform(GpLineGradient* brush, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleLineTransform(GpLineGradient* brush, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateLineTransform(GpLineGradient* brush, REAL angle, 
                        GpMatrixOrder order);

//----------------------------------------------------------------------------
// PathGradientBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePathGradient(GDIPCONST GpPointF* points,
                                    INT count,
                                    GpWrapMode wrapMode,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipCreatePathGradientI(GDIPCONST GpPoint* points,
                                    INT count,
                                    GpWrapMode wrapMode,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipCreatePathGradientFromPath(GDIPCONST GpPath* path,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterColor(
                        GpPathGradient *brush, ARGB* colors);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterColor(
                        GpPathGradient *brush, ARGB colors);

GpStatus WINGDIPAPI
GdipGetPathGradientSurroundColorsWithCount(
                        GpPathGradient *brush, ARGB* color, INT* count);

GpStatus WINGDIPAPI
GdipSetPathGradientSurroundColorsWithCount(
                        GpPathGradient *brush,
                        GDIPCONST ARGB* color, INT* count);

GpStatus WINGDIPAPI
GdipGetPathGradientPath(GpPathGradient *brush, GpPath *path);

GpStatus WINGDIPAPI
GdipSetPathGradientPath(GpPathGradient *brush, GDIPCONST GpPath *path);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterPoint(
                        GpPathGradient *brush, GpPointF* points);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterPointI(
                        GpPathGradient *brush, GpPoint* points);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterPoint(
                        GpPathGradient *brush, GDIPCONST GpPointF* points);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterPointI(
                        GpPathGradient *brush, GDIPCONST GpPoint* points);

GpStatus WINGDIPAPI
GdipGetPathGradientRect(GpPathGradient *brush, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetPathGradientRectI(GpPathGradient *brush, GpRect *rect);

GpStatus WINGDIPAPI
GdipGetPathGradientPointCount(GpPathGradient *brush, INT* count);

GpStatus WINGDIPAPI
GdipGetPathGradientSurroundColorCount(GpPathGradient *brush, INT* count);

GpStatus WINGDIPAPI
GdipSetPathGradientGammaCorrection(GpPathGradient *brush, 
                                   BOOL useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetPathGradientGammaCorrection(GpPathGradient *brush, 
                                   BOOL *useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetPathGradientBlendCount(GpPathGradient *brush,
                                             INT *count);

GpStatus WINGDIPAPI
GdipGetPathGradientBlend(GpPathGradient *brush,
                                    REAL *blend, REAL *positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientBlend(GpPathGradient *brush,
                GDIPCONST REAL *blend, GDIPCONST REAL *positions, INT count);

GpStatus WINGDIPAPI
GdipGetPathGradientPresetBlendCount(GpPathGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetPathGradientPresetBlend(GpPathGradient *brush, ARGB *blend,
                                                REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientPresetBlend(GpPathGradient *brush, GDIPCONST ARGB *blend,
                                        GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientSigmaBlend(GpPathGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetPathGradientLinearBlend(GpPathGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipGetPathGradientWrapMode(GpPathGradient *brush,
                                         GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipSetPathGradientWrapMode(GpPathGradient *brush,
                                         GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetPathGradientTransform(GpPathGradient *brush,
                                          GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetPathGradientTransform(GpPathGradient *brush,
                                          GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPathGradientTransform(GpPathGradient* brush);

GpStatus WINGDIPAPI
GdipMultiplyPathGradientTransform(GpPathGradient* brush, 
                                  GDIPCONST GpMatrix *matrix,
                                  GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslatePathGradientTransform(GpPathGradient* brush, REAL dx, REAL dy,
                                   GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScalePathGradientTransform(GpPathGradient* brush, REAL sx, REAL sy,
                               GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotatePathGradientTransform(GpPathGradient* brush, REAL angle,
                                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipGetPathGradientFocusScales(GpPathGradient *brush, REAL* xScale, 
                               REAL* yScale);

GpStatus WINGDIPAPI
GdipSetPathGradientFocusScales(GpPathGradient *brush, REAL xScale, 
                               REAL yScale);

//----------------------------------------------------------------------------
// Pen APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePen1(ARGB color, REAL width, GpUnit unit, GpPen **pen);

GpStatus WINGDIPAPI
GdipCreatePen2(GpBrush *brush, REAL width, GpUnit unit,
                        GpPen **pen);

GpStatus WINGDIPAPI
GdipClonePen(GpPen *pen, GpPen **clonepen);

GpStatus WINGDIPAPI
GdipDeletePen(GpPen *pen);

GpStatus WINGDIPAPI
GdipSetPenWidth(GpPen *pen, REAL width);

GpStatus WINGDIPAPI
GdipGetPenWidth(GpPen *pen, REAL *width);

GpStatus WINGDIPAPI
GdipSetPenUnit(GpPen *pen, GpUnit unit);

GpStatus WINGDIPAPI
GdipGetPenUnit(GpPen *pen, GpUnit *unit);

GpStatus WINGDIPAPI
GdipSetPenLineCap197819(GpPen *pen, GpLineCap startCap, GpLineCap endCap,
                  GpDashCap dashCap);

GpStatus WINGDIPAPI
GdipSetPenStartCap(GpPen *pen, GpLineCap startCap);

GpStatus WINGDIPAPI
GdipSetPenEndCap(GpPen *pen, GpLineCap endCap);

GpStatus WINGDIPAPI
GdipSetPenDashCap197819(GpPen *pen, GpDashCap dashCap);

GpStatus WINGDIPAPI
GdipGetPenStartCap(GpPen *pen, GpLineCap *startCap);

GpStatus WINGDIPAPI
GdipGetPenEndCap(GpPen *pen, GpLineCap *endCap);

GpStatus WINGDIPAPI
GdipGetPenDashCap197819(GpPen *pen, GpDashCap *dashCap);

GpStatus WINGDIPAPI
GdipSetPenLineJoin(GpPen *pen, GpLineJoin lineJoin);

GpStatus WINGDIPAPI
GdipGetPenLineJoin(GpPen *pen, GpLineJoin *lineJoin);

GpStatus WINGDIPAPI
GdipSetPenCustomStartCap(GpPen *pen, GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipGetPenCustomStartCap(GpPen *pen, GpCustomLineCap** customCap);

GpStatus WINGDIPAPI
GdipSetPenCustomEndCap(GpPen *pen, GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipGetPenCustomEndCap(GpPen *pen, GpCustomLineCap** customCap);

GpStatus WINGDIPAPI
GdipSetPenMiterLimit(GpPen *pen, REAL miterLimit);

GpStatus WINGDIPAPI
GdipGetPenMiterLimit(GpPen *pen, REAL *miterLimit);

GpStatus WINGDIPAPI
GdipSetPenMode(GpPen *pen, GpPenAlignment penMode);

GpStatus WINGDIPAPI
GdipGetPenMode(GpPen *pen, GpPenAlignment *penMode);

GpStatus WINGDIPAPI
GdipSetPenTransform(GpPen *pen, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipGetPenTransform(GpPen *pen, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPenTransform(GpPen *pen);

GpStatus WINGDIPAPI
GdipMultiplyPenTransform(GpPen *pen, GDIPCONST GpMatrix *matrix,
                           GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslatePenTransform(GpPen *pen, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScalePenTransform(GpPen *pen, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotatePenTransform(GpPen *pen, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipSetPenColor(GpPen *pen, ARGB argb);

GpStatus WINGDIPAPI
GdipGetPenColor(GpPen *pen, ARGB *argb);

GpStatus WINGDIPAPI
GdipSetPenBrushFill(GpPen *pen, GpBrush *brush);

GpStatus WINGDIPAPI
GdipGetPenBrushFill(GpPen *pen, GpBrush **brush);

GpStatus WINGDIPAPI
GdipGetPenFillType(GpPen *pen, GpPenType* type);

GpStatus WINGDIPAPI
GdipGetPenDashStyle(GpPen *pen, GpDashStyle *dashstyle);

GpStatus WINGDIPAPI
GdipSetPenDashStyle(GpPen *pen, GpDashStyle dashstyle);

GpStatus WINGDIPAPI
GdipGetPenDashOffset(GpPen *pen, REAL *offset);

GpStatus WINGDIPAPI
GdipSetPenDashOffset(GpPen *pen, REAL offset);

GpStatus WINGDIPAPI
GdipGetPenDashCount(GpPen *pen, INT *count);

GpStatus WINGDIPAPI
GdipSetPenDashArray(GpPen *pen, GDIPCONST REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenDashArray(GpPen *pen, REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenCompoundCount(GpPen *pen, INT *count);

GpStatus WINGDIPAPI
GdipSetPenCompoundArray(GpPen *pen, GDIPCONST REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenCompoundArray(GpPen *pen, REAL *dash, INT count);

//----------------------------------------------------------------------------
// CustomLineCap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateCustomLineCap(GpPath* fillPath, GpPath* strokePath,
   GpLineCap baseCap, REAL baseInset, GpCustomLineCap **customCap);

GpStatus WINGDIPAPI
GdipDeleteCustomLineCap(GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipCloneCustomLineCap(GpCustomLineCap* customCap,
                       GpCustomLineCap** clonedCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapType(GpCustomLineCap* customCap,
                       CustomLineCapType* capType);

GpStatus WINGDIPAPI
GdipSetCustomLineCapStrokeCaps(GpCustomLineCap* customCap,
                               GpLineCap startCap, GpLineCap endCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapStrokeCaps(GpCustomLineCap* customCap,
                               GpLineCap* startCap, GpLineCap* endCap);

GpStatus WINGDIPAPI
GdipSetCustomLineCapStrokeJoin(GpCustomLineCap* customCap, 
                               GpLineJoin lineJoin);

GpStatus WINGDIPAPI
GdipGetCustomLineCapStrokeJoin(GpCustomLineCap* customCap, 
                               GpLineJoin* lineJoin);

GpStatus WINGDIPAPI
GdipSetCustomLineCapBaseCap(GpCustomLineCap* customCap, GpLineCap baseCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapBaseCap(GpCustomLineCap* customCap, GpLineCap* baseCap);

GpStatus WINGDIPAPI
GdipSetCustomLineCapBaseInset(GpCustomLineCap* customCap, REAL inset);

GpStatus WINGDIPAPI
GdipGetCustomLineCapBaseInset(GpCustomLineCap* customCap, REAL* inset);

GpStatus WINGDIPAPI
GdipSetCustomLineCapWidthScale(GpCustomLineCap* customCap, REAL widthScale);

GpStatus WINGDIPAPI
GdipGetCustomLineCapWidthScale(GpCustomLineCap* customCap, REAL* widthScale);

//----------------------------------------------------------------------------
// AdjustableArrowCap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateAdjustableArrowCap(REAL height, REAL width, BOOL isFilled,
                             GpAdjustableArrowCap **cap);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapHeight(GpAdjustableArrowCap* cap, REAL height);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapHeight(GpAdjustableArrowCap* cap, REAL* height);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapWidth(GpAdjustableArrowCap* cap, REAL width);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapWidth(GpAdjustableArrowCap* cap, REAL* width);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapMiddleInset(GpAdjustableArrowCap* cap, 
                                     REAL middleInset);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapMiddleInset(GpAdjustableArrowCap* cap, 
                                     REAL* middleInset);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapFillState(GpAdjustableArrowCap* cap, BOOL fillState);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapFillState(GpAdjustableArrowCap* cap, BOOL* fillState);

//----------------------------------------------------------------------------
// Image APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipLoadImageFromStream(IStream* stream, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromFile(GDIPCONST WCHAR* filename, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromStreamICM(IStream* stream, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromFileICM(GDIPCONST WCHAR* filename, GpImage **image);

GpStatus WINGDIPAPI
GdipCloneImage(GpImage *image, GpImage **cloneImage);

GpStatus WINGDIPAPI
GdipDisposeImage(GpImage *image);

GpStatus WINGDIPAPI
GdipSaveImageToFile(GpImage *image, GDIPCONST WCHAR* filename,
                    GDIPCONST CLSID* clsidEncoder, 
                    GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveImageToStream(GpImage *image, IStream* stream,
                      GDIPCONST CLSID* clsidEncoder, 
                      GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveAdd(GpImage *image, GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveAddImage(GpImage *image, GpImage* newImage,
                 GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipGetImageGraphicsContext(GpImage *image, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipGetImageBounds(GpImage *image, GpRectF *srcRect, GpUnit *srcUnit);

GpStatus WINGDIPAPI
GdipGetImageDimension(GpImage *image, REAL *width, REAL *height);

GpStatus WINGDIPAPI
GdipGetImageType(GpImage *image, ImageType *type);

GpStatus WINGDIPAPI
GdipGetImageWidth(GpImage *image, UINT *width);

GpStatus WINGDIPAPI
GdipGetImageHeight(GpImage *image, UINT *height);

GpStatus WINGDIPAPI
GdipGetImageHorizontalResolution(GpImage *image, REAL *resolution);

GpStatus WINGDIPAPI
GdipGetImageVerticalResolution(GpImage *image, REAL *resolution);

GpStatus WINGDIPAPI
GdipGetImageFlags(GpImage *image, UINT *flags);

GpStatus WINGDIPAPI
GdipGetImageRawFormat(GpImage *image, GUID *format);

GpStatus WINGDIPAPI
GdipGetImagePixelFormat(GpImage *image, PixelFormat *format);

GpStatus WINGDIPAPI
GdipGetImageThumbnail(GpImage *image, UINT thumbWidth, UINT thumbHeight,
                      GpImage **thumbImage,
                      GetThumbnailImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipGetEncoderParameterListSize(GpImage *image, GDIPCONST CLSID* clsidEncoder,
                                UINT* size);

GpStatus WINGDIPAPI
GdipGetEncoderParameterList(GpImage *image, GDIPCONST CLSID* clsidEncoder,
                            UINT size, EncoderParameters* buffer);

GpStatus WINGDIPAPI
GdipImageGetFrameDimensionsCount(GpImage* image, UINT* count);

GpStatus WINGDIPAPI
GdipImageGetFrameDimensionsList(GpImage* image, GUID* dimensionIDs, 
                                UINT count);

GpStatus WINGDIPAPI
GdipImageGetFrameCount(GpImage *image, GDIPCONST GUID* dimensionID, 
                       UINT* count);

GpStatus WINGDIPAPI
GdipImageSelectActiveFrame(GpImage *image, GDIPCONST GUID* dimensionID,
                           UINT frameIndex);

GpStatus WINGDIPAPI
GdipImageRotateFlip(GpImage *image, RotateFlipType rfType);

GpStatus WINGDIPAPI
GdipGetImagePalette(GpImage *image, ColorPalette *palette, INT size);

GpStatus WINGDIPAPI
GdipSetImagePalette(GpImage *image, GDIPCONST ColorPalette *palette);

GpStatus WINGDIPAPI
GdipGetImagePaletteSize(GpImage *image, INT *size);

GpStatus WINGDIPAPI
GdipGetPropertyCount(GpImage *image, UINT* numOfProperty);

GpStatus WINGDIPAPI
GdipGetPropertyIdList(GpImage *image, UINT numOfProperty, PROPID* list);

GpStatus WINGDIPAPI
GdipGetPropertyItemSize(GpImage *image, PROPID propId, UINT* size);

GpStatus WINGDIPAPI
GdipGetPropertyItem(GpImage *image, PROPID propId,UINT propSize,
                    PropertyItem* buffer);

GpStatus WINGDIPAPI
GdipGetPropertySize(GpImage *image, UINT* totalBufferSize, 
                    UINT* numProperties);

GpStatus WINGDIPAPI
GdipGetAllPropertyItems(GpImage *image, UINT totalBufferSize,
                        UINT numProperties, PropertyItem* allItems);

GpStatus WINGDIPAPI
GdipRemovePropertyItem(GpImage *image, PROPID propId);

GpStatus WINGDIPAPI
GdipSetPropertyItem(GpImage *image, GDIPCONST PropertyItem* item);

#if (GDIPVER >= 0x0110)
GpStatus WINGDIPAPI
GdipFindFirstImageItem(GpImage *image, ImageItemData* item);

GpStatus WINGDIPAPI
GdipFindNextImageItem(GpImage *image, ImageItemData* item);

GpStatus WINGDIPAPI
GdipGetImageItemData(GpImage *image, ImageItemData* item);
#endif //(GDIPVER >= 0x0110)

GpStatus WINGDIPAPI
GdipImageForceValidation(GpImage *image);

//----------------------------------------------------------------------------
// Bitmap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateBitmapFromStream(IStream* stream, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromFile(GDIPCONST WCHAR* filename, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromStreamICM(IStream* stream, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromFileICM(GDIPCONST WCHAR* filename, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromScan0(INT width,
                          INT height,
                          INT stride,
                          PixelFormat format,
                          BYTE* scan0,
                          GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromGraphics(INT width,
                             INT height,
                             GpGraphics* target,
                             GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromDirectDrawSurface(IDirectDrawSurface7* surface,
                                      GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromGdiDib(GDIPCONST BITMAPINFO* gdiBitmapInfo,
                           VOID* gdiBitmapData,
                           GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromHBITMAP(HBITMAP hbm,
                            HPALETTE hpal,
                            GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateHBITMAPFromBitmap(GpBitmap* bitmap,
                            HBITMAP* hbmReturn,
                            ARGB background);

GpStatus WINGDIPAPI
GdipCreateBitmapFromHICON(HICON hicon,
                          GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateHICONFromBitmap(GpBitmap* bitmap,
                          HICON* hbmReturn);

GpStatus WINGDIPAPI
GdipCreateBitmapFromResource(HINSTANCE hInstance,
                             GDIPCONST WCHAR* lpBitmapName,
                             GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCloneBitmapArea(REAL x, REAL y, REAL width, REAL height,
                            PixelFormat format,
                            GpBitmap *srcBitmap,
                            GpBitmap **dstBitmap);

GpStatus WINGDIPAPI
GdipCloneBitmapAreaI(INT x,
                     INT y,
                     INT width,
                     INT height,
                     PixelFormat format,
                     GpBitmap *srcBitmap,
                     GpBitmap **dstBitmap);

GpStatus WINGDIPAPI
GdipBitmapLockBits(GpBitmap* bitmap,
                   GDIPCONST GpRect* rect,
                   UINT flags,
                   PixelFormat format,
                   BitmapData* lockedBitmapData);

GpStatus WINGDIPAPI
GdipBitmapUnlockBits(GpBitmap* bitmap,
                     BitmapData* lockedBitmapData);

GpStatus WINGDIPAPI
GdipBitmapGetPixel(GpBitmap* bitmap, INT x, INT y, ARGB *color);

GpStatus WINGDIPAPI
GdipBitmapSetPixel(GpBitmap* bitmap, INT x, INT y, ARGB color);

#if (GDIPVER >= 0x0110)
GpStatus WINGDIPAPI GdipImageSetAbort(
    GpImage *pImage, 
    GdiplusAbort *pIAbort
    );

GpStatus WINGDIPAPI GdipGraphicsSetAbort(
    GpGraphics *pGraphics, 
    GdiplusAbort *pIAbort
    );

GpStatus WINGDIPAPI
GdipBitmapConvertFormat(
    IN GpBitmap *pInputBitmap,
    PixelFormat format,
    DitherType dithertype,
    PaletteType palettetype,
    ColorPalette *palette,
    REAL alphaThresholdPercent
    );

GpStatus WINGDIPAPI
GdipInitializePalette(
    OUT ColorPalette *palette,   // output palette. must be allocated.
    PaletteType palettetype,     // palette enumeration type.
    INT optimalColors,           // how many optimal colors
    BOOL useTransparentColor,    // add a transparent color to the palette.
    GpBitmap *bitmap             // optional bitmap for median cut.
    );
    
GpStatus WINGDIPAPI
GdipBitmapApplyEffect(
    GpBitmap* bitmap,
    CGpEffect *effect,
    RECT *roi,
    BOOL useAuxData,
    VOID **auxData,
    INT *auxDataSize
    );

GpStatus WINGDIPAPI
GdipBitmapCreateApplyEffect(
    GpBitmap **inputBitmaps,
    INT numInputs,
    CGpEffect *effect,
    RECT *roi,
    RECT *outputRect,
    GpBitmap **outputBitmap,
    BOOL useAuxData,
    VOID **auxData,
    INT *auxDataSize
);

GpStatus WINGDIPAPI
GdipBitmapGetHistogram(
    GpBitmap* bitmap, 
    IN HistogramFormat format,
    IN UINT NumberOfEntries,
    __out_bcount(sizeof(UINT)*256) UINT *channel0,
    __out_bcount(sizeof(UINT)*256) UINT *channel1,
    __out_bcount(sizeof(UINT)*256) UINT *channel2,
    __out_bcount(sizeof(UINT)*256) UINT *channel3
);

GpStatus WINGDIPAPI
GdipBitmapGetHistogramSize(
    IN HistogramFormat format,
    OUT UINT *NumberOfEntries
);
#endif

GpStatus WINGDIPAPI
GdipBitmapSetResolution(GpBitmap* bitmap, REAL xdpi, REAL ydpi);

//----------------------------------------------------------------------------
// ImageAttributes APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateImageAttributes(GpImageAttributes **imageattr);

GpStatus WINGDIPAPI
GdipCloneImageAttributes(GDIPCONST GpImageAttributes *imageattr,
                         GpImageAttributes **cloneImageattr);

GpStatus WINGDIPAPI
GdipDisposeImageAttributes(GpImageAttributes *imageattr);

GpStatus WINGDIPAPI
GdipSetImageAttributesToIdentity(GpImageAttributes *imageattr,
                                 ColorAdjustType type);
GpStatus WINGDIPAPI
GdipResetImageAttributes(GpImageAttributes *imageattr,
                         ColorAdjustType type);

GpStatus WINGDIPAPI
GdipSetImageAttributesColorMatrix(GpImageAttributes *imageattr,
                               ColorAdjustType type,
                               BOOL enableFlag,
                               GDIPCONST ColorMatrix* colorMatrix,
                               GDIPCONST ColorMatrix* grayMatrix,
                               ColorMatrixFlags flags);

GpStatus WINGDIPAPI
GdipSetImageAttributesThreshold(GpImageAttributes *imageattr,
                                ColorAdjustType type,
                                BOOL enableFlag,
                                REAL threshold);

GpStatus WINGDIPAPI
GdipSetImageAttributesGamma(GpImageAttributes *imageattr,
                            ColorAdjustType type,
                            BOOL enableFlag,
                            REAL gamma);

GpStatus WINGDIPAPI
GdipSetImageAttributesNoOp(GpImageAttributes *imageattr,
                           ColorAdjustType type,
                           BOOL enableFlag);

GpStatus WINGDIPAPI
GdipSetImageAttributesColorKeys(GpImageAttributes *imageattr,
                                ColorAdjustType type,
                                BOOL enableFlag,
                                ARGB colorLow,
                                ARGB colorHigh);

GpStatus WINGDIPAPI
GdipSetImageAttributesOutputChannel(GpImageAttributes *imageattr,
                                    ColorAdjustType type,
                                    BOOL enableFlag,
                                    ColorChannelFlags channelFlags);

GpStatus WINGDIPAPI
GdipSetImageAttributesOutputChannelColorProfile(GpImageAttributes *imageattr,
                                                ColorAdjustType type,
                                                BOOL enableFlag,
                                                GDIPCONST 
                                                  WCHAR *colorProfileFilename);

GpStatus WINGDIPAPI
GdipSetImageAttributesRemapTable(GpImageAttributes *imageattr,
                                 ColorAdjustType type,
                                 BOOL enableFlag,
                                 UINT mapSize,
                                 GDIPCONST ColorMap *map);
GpStatus WINGDIPAPI
GdipSetImageAttributesWrapMode(
    GpImageAttributes *imageAttr,
    WrapMode wrap,
    ARGB argb,
    BOOL clamp
);

GpStatus WINGDIPAPI
GdipSetImageAttributesICMMode(
    GpImageAttributes *imageAttr,
    BOOL on
);

GpStatus WINGDIPAPI
GdipGetImageAttributesAdjustedPalette(
    GpImageAttributes *imageAttr,
    ColorPalette * colorPalette,
    ColorAdjustType colorAdjustType
);

//----------------------------------------------------------------------------
// Graphics APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipFlush(GpGraphics *graphics, GpFlushIntention intention);

GpStatus WINGDIPAPI
GdipCreateFromHDC(HDC hdc, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHDC2(HDC hdc, HANDLE hDevice, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHWND(HWND hwnd, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHWNDICM(HWND hwnd, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipDeleteGraphics(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipGetDC(GpGraphics* graphics, HDC * hdc);

GpStatus WINGDIPAPI
GdipReleaseDC(GpGraphics* graphics, HDC hdc);

GpStatus WINGDIPAPI
GdipSetCompositingMode(GpGraphics *graphics, CompositingMode compositingMode);

GpStatus WINGDIPAPI
GdipGetCompositingMode(GpGraphics *graphics, CompositingMode *compositingMode);

GpStatus WINGDIPAPI
GdipSetRenderingOrigin(GpGraphics *graphics, INT x, INT y);

GpStatus WINGDIPAPI
GdipGetRenderingOrigin(GpGraphics *graphics, INT *x, INT *y);

GpStatus WINGDIPAPI
GdipSetCompositingQuality(GpGraphics *graphics, 
                          CompositingQuality compositingQuality);

GpStatus WINGDIPAPI
GdipGetCompositingQuality(GpGraphics *graphics, 
                          CompositingQuality *compositingQuality);
                          
GpStatus WINGDIPAPI
GdipSetSmoothingMode(GpGraphics *graphics, SmoothingMode smoothingMode);

GpStatus WINGDIPAPI
GdipGetSmoothingMode(GpGraphics *graphics, SmoothingMode *smoothingMode);

GpStatus WINGDIPAPI
GdipSetPixelOffsetMode(GpGraphics* graphics, PixelOffsetMode pixelOffsetMode);

GpStatus WINGDIPAPI
GdipGetPixelOffsetMode(GpGraphics *graphics, PixelOffsetMode *pixelOffsetMode);

GpStatus WINGDIPAPI
GdipSetTextRenderingHint(GpGraphics *graphics, TextRenderingHint mode);

GpStatus WINGDIPAPI
GdipGetTextRenderingHint(GpGraphics *graphics, TextRenderingHint *mode);

GpStatus  WINGDIPAPI
GdipSetTextContrast(GpGraphics *graphics, UINT contrast);

GpStatus  WINGDIPAPI
GdipGetTextContrast(GpGraphics *graphics, UINT * contrast);

GpStatus WINGDIPAPI
GdipSetInterpolationMode(GpGraphics *graphics, 
                         InterpolationMode interpolationMode);

GpStatus WINGDIPAPI
GdipGetInterpolationMode(GpGraphics *graphics, 
                         InterpolationMode *interpolationMode);

GpStatus WINGDIPAPI
GdipSetWorldTransform(GpGraphics *graphics, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetWorldTransform(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipMultiplyWorldTransform(GpGraphics *graphics, GDIPCONST GpMatrix *matrix,
                           GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateWorldTransform(GpGraphics *graphics, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleWorldTransform(GpGraphics *graphics, REAL sx, REAL sy,
                        GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateWorldTransform(GpGraphics *graphics, REAL angle, 
                         GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipGetWorldTransform(GpGraphics *graphics, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPageTransform(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipGetPageUnit(GpGraphics *graphics, GpUnit *unit);

GpStatus WINGDIPAPI
GdipGetPageScale(GpGraphics *graphics, REAL *scale);

GpStatus WINGDIPAPI
GdipSetPageUnit(GpGraphics *graphics, GpUnit unit);

GpStatus WINGDIPAPI
GdipSetPageScale(GpGraphics *graphics, REAL scale);

GpStatus WINGDIPAPI
GdipGetDpiX(GpGraphics *graphics, REAL* dpi);

GpStatus WINGDIPAPI
GdipGetDpiY(GpGraphics *graphics, REAL* dpi);

GpStatus WINGDIPAPI
GdipTransformPoints(GpGraphics *graphics, GpCoordinateSpace destSpace,
                             GpCoordinateSpace srcSpace, GpPointF *points,
                             INT count);

GpStatus WINGDIPAPI
GdipTransformPointsI(GpGraphics *graphics, GpCoordinateSpace destSpace,
                             GpCoordinateSpace srcSpace, GpPoint *points,
                             INT count);

GpStatus WINGDIPAPI
GdipGetNearestColor(GpGraphics *graphics, ARGB* argb);

// Creates the Win9x Halftone Palette (even on NT) with correct Desktop colors
HPALETTE WINGDIPAPI
GdipCreateHalftonePalette();

GpStatus WINGDIPAPI
GdipDrawLine(GpGraphics *graphics, GpPen *pen, REAL x1, REAL y1,
                      REAL x2, REAL y2);

GpStatus WINGDIPAPI
GdipDrawLineI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1,
                      INT x2, INT y2);

GpStatus WINGDIPAPI
GdipDrawLines(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawLinesI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawArc(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
            REAL width, REAL height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawArcI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                     INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawBezier(GpGraphics *graphics, GpPen *pen, REAL x1, REAL y1,
                        REAL x2, REAL y2, REAL x3, REAL y3, REAL x4, REAL y4);

GpStatus WINGDIPAPI
GdipDrawBezierI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1,
                        INT x2, INT y2, INT x3, INT y3, INT x4, INT y4);

GpStatus WINGDIPAPI
GdipDrawBeziers(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawBeziersI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawRectangle(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                      REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawRectangleI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                      INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawRectangles(GpGraphics *graphics, GpPen *pen, GDIPCONST GpRectF *rects,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawRectanglesI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpRect *rects,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawEllipse(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                         REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawEllipseI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                         INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawPie(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                     REAL width, REAL height, REAL startAngle, 
            REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawPieI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                     INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawPolygon(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawPolygonI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawPath(GpGraphics *graphics, GpPen *pen, GpPath *path);

GpStatus WINGDIPAPI
GdipDrawCurve(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawCurveI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawCurve2(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve2I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve3(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
               INT count, INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve3I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                INT count, INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipDrawClosedCurve(GpGraphics *graphics, GpPen *pen,
                    GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipDrawClosedCurveI(GpGraphics *graphics, GpPen *pen,
                     GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipDrawClosedCurve2(GpGraphics *graphics, GpPen *pen,
                     GDIPCONST GpPointF *points, INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawClosedCurve2I(GpGraphics *graphics, GpPen *pen,
                      GDIPCONST GpPoint *points, INT count, REAL tension);

GpStatus WINGDIPAPI
GdipGraphicsClear(GpGraphics *graphics, ARGB color);

GpStatus WINGDIPAPI
GdipFillRectangle(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
                  REAL width, REAL height);

GpStatus WINGDIPAPI
GdipFillRectangleI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
                   INT width, INT height);

GpStatus WINGDIPAPI
GdipFillRectangles(GpGraphics *graphics, GpBrush *brush,
                   GDIPCONST GpRectF *rects, INT count);

GpStatus WINGDIPAPI
GdipFillRectanglesI(GpGraphics *graphics, GpBrush *brush,
                    GDIPCONST GpRect *rects, INT count);

GpStatus WINGDIPAPI
GdipFillPolygon(GpGraphics *graphics, GpBrush *brush,
                GDIPCONST GpPointF *points, INT count, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillPolygonI(GpGraphics *graphics, GpBrush *brush,
                 GDIPCONST GpPoint *points, INT count, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillPolygon2(GpGraphics *graphics, GpBrush *brush,
                 GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipFillPolygon2I(GpGraphics *graphics, GpBrush *brush,
                  GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFillEllipse(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
                REAL width, REAL height);

GpStatus WINGDIPAPI
GdipFillEllipseI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
                 INT width, INT height);

GpStatus WINGDIPAPI
GdipFillPie(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
            REAL width, REAL height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipFillPieI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
             INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipFillPath(GpGraphics *graphics, GpBrush *brush, GpPath *path);

GpStatus WINGDIPAPI
GdipFillClosedCurve(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipFillClosedCurveI(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFillClosedCurve2(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPointF *points, INT count,
                              REAL tension, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillClosedCurve2I(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPoint *points, INT count,
                              REAL tension, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillRegion(GpGraphics *graphics, GpBrush *brush,
                        GpRegion *region);

#if (GDIPVER >= 0x0110)
GpStatus
WINGDIPAPI
GdipDrawImageFX(
    GpGraphics *graphics,
    GpImage *image,
    GpRectF *source,
    GpMatrix *xForm,
    CGpEffect *effect,
    GpImageAttributes *imageAttributes,
    GpUnit srcUnit
    );
#endif //(GDIPVER >= 0x0110)

GpStatus WINGDIPAPI
GdipDrawImage(GpGraphics *graphics, GpImage *image, REAL x, REAL y);

GpStatus WINGDIPAPI
GdipDrawImageI(GpGraphics *graphics, GpImage *image, INT x, INT y);

GpStatus WINGDIPAPI
GdipDrawImageRect(GpGraphics *graphics, GpImage *image, REAL x, REAL y,
                           REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawImageRectI(GpGraphics *graphics, GpImage *image, INT x, INT y,
                           INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawImagePoints(GpGraphics *graphics, GpImage *image,
                             GDIPCONST GpPointF *dstpoints, INT count);

GpStatus WINGDIPAPI
GdipDrawImagePointsI(GpGraphics *graphics, GpImage *image,
                             GDIPCONST GpPoint *dstpoints, INT count);

GpStatus WINGDIPAPI
GdipDrawImagePointRect(GpGraphics *graphics, GpImage *image, REAL x,
                                REAL y, REAL srcx, REAL srcy, REAL srcwidth,
                                REAL srcheight, GpUnit srcUnit);

GpStatus WINGDIPAPI
GdipDrawImagePointRectI(GpGraphics *graphics, GpImage *image, INT x,
                                INT y, INT srcx, INT srcy, INT srcwidth,
                                INT srcheight, GpUnit srcUnit);

GpStatus WINGDIPAPI
GdipDrawImageRectRect(GpGraphics *graphics, GpImage *image, REAL dstx,
                      REAL dsty, REAL dstwidth, REAL dstheight,
                      REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight,
                      GpUnit srcUnit,
                      GDIPCONST GpImageAttributes* imageAttributes,
                      DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImageRectRectI(GpGraphics *graphics, GpImage *image, INT dstx,
                       INT dsty, INT dstwidth, INT dstheight,
                       INT srcx, INT srcy, INT srcwidth, INT srcheight,
                       GpUnit srcUnit,
                       GDIPCONST GpImageAttributes* imageAttributes,
                       DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image,
                        GDIPCONST GpPointF *points, INT count, REAL srcx,
                        REAL srcy, REAL srcwidth, REAL srcheight,
                        GpUnit srcUnit,
                        GDIPCONST GpImageAttributes* imageAttributes,
                        DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImagePointsRectI(GpGraphics *graphics, GpImage *image,
                         GDIPCONST GpPoint *points, INT count, INT srcx,
                         INT srcy, INT srcwidth, INT srcheight,
                         GpUnit srcUnit,
                         GDIPCONST GpImageAttributes* imageAttributes,
                         DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point *       destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point *       destPoints,
    INT                     count,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipPlayMetafileRecord(
    GDIPCONST GpMetafile *  metafile,
    EmfPlusRecordType       recordType,
    UINT                    flags,
    UINT                    dataSize,
    GDIPCONST BYTE *        data
    );

GpStatus WINGDIPAPI
GdipSetClipGraphics(GpGraphics *graphics, GpGraphics *srcgraphics,
                    CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRect(GpGraphics *graphics, REAL x, REAL y,
                         REAL width, REAL height, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRectI(GpGraphics *graphics, INT x, INT y,
                         INT width, INT height, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipPath(GpGraphics *graphics, GpPath *path, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRegion(GpGraphics *graphics, GpRegion *region,
                  CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipHrgn(GpGraphics *graphics, HRGN hRgn, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipResetClip(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipTranslateClip(GpGraphics *graphics, REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipTranslateClipI(GpGraphics *graphics, INT dx, INT dy);

GpStatus WINGDIPAPI
GdipGetClip(GpGraphics *graphics, GpRegion *region);

GpStatus WINGDIPAPI
GdipGetClipBounds(GpGraphics *graphics, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetClipBoundsI(GpGraphics *graphics, GpRect *rect);

GpStatus WINGDIPAPI
GdipIsClipEmpty(GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetVisibleClipBounds(GpGraphics *graphics, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetVisibleClipBoundsI(GpGraphics *graphics, GpRect *rect);

GpStatus WINGDIPAPI
GdipIsVisibleClipEmpty(GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePoint(GpGraphics *graphics, REAL x, REAL y,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePointI(GpGraphics *graphics, INT x, INT y,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRect(GpGraphics *graphics, REAL x, REAL y,
                           REAL width, REAL height, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRectI(GpGraphics *graphics, INT x, INT y,
                           INT width, INT height, BOOL *result);

GpStatus WINGDIPAPI
GdipSaveGraphics(GpGraphics *graphics, GraphicsState *state);

GpStatus WINGDIPAPI
GdipRestoreGraphics(GpGraphics *graphics, GraphicsState state);

GpStatus WINGDIPAPI
GdipBeginContainer(GpGraphics *graphics, GDIPCONST GpRectF* dstrect,
                   GDIPCONST GpRectF *srcrect, GpUnit unit, 
                   GraphicsContainer *state);

GpStatus WINGDIPAPI
GdipBeginContainerI(GpGraphics *graphics, GDIPCONST GpRect* dstrect,
                    GDIPCONST GpRect *srcrect, GpUnit unit, 
                    GraphicsContainer *state);

GpStatus WINGDIPAPI
GdipBeginContainer2(GpGraphics *graphics, GraphicsContainer* state);

GpStatus WINGDIPAPI
GdipEndContainer(GpGraphics *graphics, GraphicsContainer state);

GpStatus
GdipGetMetafileHeaderFromWmf(
    HMETAFILE           hWmf,
    GDIPCONST WmfPlaceableFileHeader *     wmfPlaceableFileHeader,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromEmf(
    HENHMETAFILE        hEmf,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromFile(
    GDIPCONST WCHAR*        filename,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromStream(
    IStream *           stream,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromMetafile(
    GpMetafile *        metafile,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetHemfFromMetafile(
    GpMetafile *        metafile,
    HENHMETAFILE *      hEmf
    );

GpStatus WINGDIPAPI
GdipCreateStreamOnFile(GDIPCONST WCHAR * filename, UINT access, 
                       IStream **stream);

GpStatus WINGDIPAPI
GdipCreateMetafileFromWmf(HMETAFILE hWmf, BOOL deleteWmf,
                          GDIPCONST WmfPlaceableFileHeader * wmfPlaceableFileHeader, 
                          GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromEmf(HENHMETAFILE hEmf, BOOL deleteEmf,
                          GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromFile(GDIPCONST WCHAR* file, GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromWmfFile(GDIPCONST WCHAR* file, 
                              GDIPCONST WmfPlaceableFileHeader * wmfPlaceableFileHeader, 
                              GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromStream(IStream * stream, GpMetafile **metafile);


GpStatus WINGDIPAPI
GdipRecordMetafile(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileI(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileFileName(
    GDIPCONST WCHAR*    fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileFileNameI(
    GDIPCONST WCHAR*    fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileStream(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileStreamI(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipSetMetafileDownLevelRasterizationLimit(
    GpMetafile *            metafile,
    UINT                    metafileRasterizationLimitDpi
    );

GpStatus WINGDIPAPI
GdipGetMetafileDownLevelRasterizationLimit(
    GDIPCONST GpMetafile *  metafile,
    UINT *                  metafileRasterizationLimitDpi
    );

GpStatus WINGDIPAPI
GdipGetImageDecodersSize(UINT *numDecoders, UINT *size);

GpStatus WINGDIPAPI
GdipGetImageDecoders(UINT numDecoders,
                     UINT size,
                     __out_bcount(size) ImageCodecInfo *decoders);

GpStatus WINGDIPAPI
GdipGetImageEncodersSize(UINT *numEncoders, UINT *size);

GpStatus WINGDIPAPI
GdipGetImageEncoders(UINT numEncoders,
                     UINT size,
                     __out_bcount(size) ImageCodecInfo *encoders);

GpStatus WINGDIPAPI
GdipComment(GpGraphics* graphics, UINT sizeData, GDIPCONST BYTE * data);

//----------------------------------------------------------------------------
// FontFamily APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateFontFamilyFromName(GDIPCONST WCHAR *name,
                             GpFontCollection *fontCollection,
                             GpFontFamily **fontFamily);

GpStatus WINGDIPAPI
GdipDeleteFontFamily(GpFontFamily *fontFamily);

GpStatus WINGDIPAPI
GdipCloneFontFamily(GpFontFamily *fontFamily, GpFontFamily **clonedFontFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilySansSerif(GpFontFamily **nativeFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilySerif(GpFontFamily **nativeFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilyMonospace(GpFontFamily **nativeFamily);


GpStatus WINGDIPAPI
GdipGetFamilyName(
    GDIPCONST GpFontFamily              *family,
    __out_ecount(LF_FACESIZE) LPWSTR    name,
    LANGID                              language
);

GpStatus   WINGDIPAPI
GdipIsStyleAvailable(GDIPCONST GpFontFamily *family, INT style, 
                     BOOL * IsStyleAvailable);

GpStatus WINGDIPAPI
GdipFontCollectionEnumerable(
    GpFontCollection* fontCollection,
    GpGraphics* graphics,
    INT *       numFound
);

GpStatus WINGDIPAPI GdipFontCollectionEnumerate(
    GpFontCollection* fontCollection,
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound,
    GpGraphics*     graphics
);

GpStatus WINGDIPAPI
GdipGetEmHeight(GDIPCONST GpFontFamily *family, INT style, 
                UINT16 * EmHeight);

GpStatus WINGDIPAPI
GdipGetCellAscent(GDIPCONST GpFontFamily *family, INT style,
                  UINT16 * CellAscent);

GpStatus WINGDIPAPI
GdipGetCellDescent(GDIPCONST GpFontFamily *family, INT style, 
                   UINT16 * CellDescent);

GpStatus WINGDIPAPI
GdipGetLineSpacing(GDIPCONST GpFontFamily *family, INT style, 
                   UINT16 * LineSpacing);


//----------------------------------------------------------------------------
// Font APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateFontFromDC(
    HDC        hdc,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFontFromLogfontA(
    HDC        hdc,
    GDIPCONST LOGFONTA  *logfont,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFontFromLogfontW(
    HDC        hdc,
    GDIPCONST LOGFONTW  *logfont,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFont(
    GDIPCONST GpFontFamily  *fontFamily,
    REAL                 emSize,
    INT                  style,
    Unit                 unit,
    GpFont             **font
);

GpStatus WINGDIPAPI
GdipCloneFont(GpFont* font, GpFont** cloneFont);

GpStatus WINGDIPAPI
GdipDeleteFont(GpFont* font);

GpStatus WINGDIPAPI
GdipGetFamily(GpFont *font, GpFontFamily **family);

GpStatus WINGDIPAPI
GdipGetFontStyle(GpFont *font, INT *style);

GpStatus WINGDIPAPI
GdipGetFontSize(GpFont *font, REAL *size);

GpStatus WINGDIPAPI
GdipGetFontUnit(GpFont *font, Unit *unit);

GpStatus WINGDIPAPI
GdipGetFontHeight(GDIPCONST GpFont *font, GDIPCONST GpGraphics *graphics, 
                  REAL *height);

GpStatus WINGDIPAPI
GdipGetFontHeightGivenDPI(GDIPCONST GpFont *font, REAL dpi, REAL *height);

GpStatus WINGDIPAPI
GdipGetLogFontA(GpFont * font, GpGraphics *graphics, LOGFONTA * logfontA);

GpStatus WINGDIPAPI
GdipGetLogFontW(GpFont * font, GpGraphics *graphics, LOGFONTW * logfontW);

GpStatus WINGDIPAPI
GdipNewInstalledFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipNewPrivateFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipDeletePrivateFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipGetFontCollectionFamilyCount(
    GpFontCollection* fontCollection,
    INT *       numFound
);

GpStatus WINGDIPAPI
GdipGetFontCollectionFamilyList(
    GpFontCollection* fontCollection,
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound
);

GpStatus WINGDIPAPI
GdipPrivateAddFontFile(
    GpFontCollection* fontCollection,
    GDIPCONST WCHAR* filename
);

GpStatus WINGDIPAPI
GdipPrivateAddMemoryFont(
    GpFontCollection* fontCollection,
    GDIPCONST void* memory,
    INT length
);

//----------------------------------------------------------------------------
// Text APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipDrawString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    GDIPCONST GpBrush        *brush
);

GpStatus WINGDIPAPI
GdipMeasureString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    RectF                    *boundingBox,
    INT                      *codepointsFitted,
    INT                      *linesFilled
);

GpStatus
WINGDIPAPI
GdipMeasureCharacterRanges(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          &layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    INT                       regionCount,
    GpRegion                **regions
);

GpStatus WINGDIPAPI
GdipDrawDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST GpBrush *brush,
    GDIPCONST PointF *positions,
    INT flags,
    GDIPCONST GpMatrix *matrix
);

GpStatus WINGDIPAPI
GdipMeasureDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST PointF *positions,
    INT flags,
    GDIPCONST GpMatrix *matrix,
    RectF *boundingBox
);

//----------------------------------------------------------------------------
// String format APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateStringFormat(
    INT               formatAttributes,
    LANGID            language,
    GpStringFormat  **format
);

GpStatus WINGDIPAPI
GdipStringFormatGetGenericDefault(GpStringFormat **format);

GpStatus WINGDIPAPI
GdipStringFormatGetGenericTypographic(GpStringFormat **format);

GpStatus WINGDIPAPI
GdipDeleteStringFormat(GpStringFormat *format);

GpStatus WINGDIPAPI
GdipCloneStringFormat(GDIPCONST GpStringFormat *format, 
                      GpStringFormat **newFormat);

GpStatus WINGDIPAPI
GdipSetStringFormatFlags(GpStringFormat *format, INT flags);

GpStatus WINGDIPAPI GdipGetStringFormatFlags(GDIPCONST GpStringFormat *format, 
                                             INT *flags);

GpStatus WINGDIPAPI
GdipSetStringFormatAlign(GpStringFormat *format, StringAlignment align);

GpStatus WINGDIPAPI
GdipGetStringFormatAlign(GDIPCONST GpStringFormat *format, 
                         StringAlignment *align);

GpStatus WINGDIPAPI
GdipSetStringFormatLineAlign(GpStringFormat *format,
                             StringAlignment align);

GpStatus WINGDIPAPI
GdipGetStringFormatLineAlign(GDIPCONST GpStringFormat *format,
                             StringAlignment *align);

GpStatus WINGDIPAPI
GdipSetStringFormatTrimming(
    GpStringFormat  *format,
    StringTrimming   trimming
);

GpStatus WINGDIPAPI
GdipGetStringFormatTrimming(
    GDIPCONST GpStringFormat *format,
    StringTrimming       *trimming
);

GpStatus WINGDIPAPI
GdipSetStringFormatHotkeyPrefix(GpStringFormat *format, INT hotkeyPrefix);

GpStatus WINGDIPAPI
GdipGetStringFormatHotkeyPrefix(GDIPCONST GpStringFormat *format, 
                                INT *hotkeyPrefix);

GpStatus WINGDIPAPI
GdipSetStringFormatTabStops(GpStringFormat *format, REAL firstTabOffset, 
                            INT count, GDIPCONST REAL *tabStops);

GpStatus WINGDIPAPI
GdipGetStringFormatTabStops(GDIPCONST GpStringFormat *format, INT count, 
                            REAL *firstTabOffset, REAL *tabStops);

GpStatus WINGDIPAPI
GdipGetStringFormatTabStopCount(GDIPCONST GpStringFormat *format, INT * count);

GpStatus WINGDIPAPI
GdipSetStringFormatDigitSubstitution(GpStringFormat *format, LANGID language,
                                     StringDigitSubstitute substitute);

GpStatus WINGDIPAPI
GdipGetStringFormatDigitSubstitution(GDIPCONST GpStringFormat *format, 
                                     LANGID *language,
                                     StringDigitSubstitute *substitute);

GpStatus WINGDIPAPI
GdipGetStringFormatMeasurableCharacterRangeCount(
    GDIPCONST GpStringFormat    *format,
    INT                         *count
);

GpStatus WINGDIPAPI
GdipSetStringFormatMeasurableCharacterRanges(
    GpStringFormat              *format,
    INT                         rangeCount,
    GDIPCONST CharacterRange    *ranges
);

//----------------------------------------------------------------------------
// Cached Bitmap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateCachedBitmap(
    GpBitmap *bitmap,
    GpGraphics *graphics,
    GpCachedBitmap **cachedBitmap
);

GpStatus WINGDIPAPI
GdipDeleteCachedBitmap(GpCachedBitmap *cachedBitmap);

GpStatus WINGDIPAPI
GdipDrawCachedBitmap(
    GpGraphics *graphics,
    GpCachedBitmap *cachedBitmap,
    INT x,
    INT y
);

UINT WINGDIPAPI
GdipEmfToWmfBits(
    HENHMETAFILE hemf,
    UINT         cbData16,
    LPBYTE       pData16,
    INT          iMapMode,
    INT          eFlags
);

GpStatus WINGDIPAPI
GdipSetImageAttributesCachedBackground(
    GpImageAttributes *imageattr,
    BOOL enableFlag
);

GpStatus WINGDIPAPI
GdipTestControl(
    GpTestControlEnum control,
    void * param
);

GpStatus WINAPI
GdiplusNotificationHook(
    OUT ULONG_PTR *token
);

VOID WINAPI
GdiplusNotificationUnhook(
    ULONG_PTR token
);

#if (GDIPVER >= 0x0110)
GpStatus WINGDIPAPI
GdipConvertToEmfPlus(
   const GpGraphics* refGraphics,
   GpMetafile*  metafile,
   INT* conversionFailureFlag,
   EmfType      emfType,
   const WCHAR* description,
   GpMetafile** out_metafile
);

GpStatus WINGDIPAPI
GdipConvertToEmfPlusToFile(
   const GpGraphics* refGraphics,
   GpMetafile*  metafile,
   INT* conversionFailureFlag,
   const WCHAR* filename, 
   EmfType      emfType,
   const WCHAR* description,
   GpMetafile** out_metafile
);

GpStatus WINGDIPAPI
GdipConvertToEmfPlusToStream(
   const GpGraphics* refGraphics,
   GpMetafile*  metafile,
   INT* conversionFailureFlag,
   IStream* stream, 
   EmfType      emfType,
   const WCHAR* description,
   GpMetafile** out_metafile
);
#endif //(GDIPVER >= 0x0110)

#ifdef __cplusplus
}
#endif

#endif // !_FLATAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusLineCaps.h ===
/**************************************************************************\
* 
* Copyright (c) 2000-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
* 
*    GdiplusLineCaps.h
*
* Abstract:
*
*   GDI+ CustomLineCap APIs
*
\**************************************************************************/

#ifndef _GDIPLUSLINECAPS_H
#define _GDIPLUSLINECAPS_H

inline 
CustomLineCap::CustomLineCap(
    IN const GraphicsPath* fillPath,
    IN const GraphicsPath* strokePath,
    IN LineCap baseCap,
    IN REAL baseInset
    )
{
    nativeCap = NULL;
    GpPath* nativeFillPath = NULL;
    GpPath* nativeStrokePath = NULL;

    if(fillPath)
        nativeFillPath = fillPath->nativePath;
    if(strokePath)
        nativeStrokePath = strokePath->nativePath;

    lastResult = DllExports::GdipCreateCustomLineCap(
                    nativeFillPath, nativeStrokePath,
                    baseCap, baseInset, &nativeCap);
}

inline 
CustomLineCap::CustomLineCap()
{
    nativeCap = NULL;
    lastResult = Ok;
}

inline 
CustomLineCap::~CustomLineCap()
{
    DllExports::GdipDeleteCustomLineCap(nativeCap);
}

inline Status 
CustomLineCap::SetStrokeCaps(
    IN LineCap startCap, 
    IN LineCap endCap)
{
    return SetStatus(DllExports::GdipSetCustomLineCapStrokeCaps(nativeCap,
                startCap, endCap));
}

inline Status 
CustomLineCap::GetStrokeCaps(
    OUT LineCap* startCap, 
    OUT LineCap* endCap) const
{
    return SetStatus(DllExports::GdipGetCustomLineCapStrokeCaps(nativeCap,
                 startCap, endCap));
}

inline Status 
CustomLineCap::SetStrokeJoin(
    IN LineJoin lineJoin)
{
    return SetStatus(DllExports::GdipSetCustomLineCapStrokeJoin(nativeCap, 
                                                                lineJoin));
}

inline LineJoin 
CustomLineCap::GetStrokeJoin() const
{
    LineJoin lineJoin;

    SetStatus(DllExports::GdipGetCustomLineCapStrokeJoin(nativeCap, 
                                                         &lineJoin));

    return lineJoin;
}

inline Status 
CustomLineCap::SetBaseCap(IN LineCap baseCap)
{
    return SetStatus(DllExports::GdipSetCustomLineCapBaseCap(nativeCap, 
                                                             baseCap));
}

inline LineCap 
CustomLineCap::GetBaseCap() const
{
    LineCap baseCap;
    SetStatus(DllExports::GdipGetCustomLineCapBaseCap(nativeCap, &baseCap));

    return baseCap;
}

inline Status 
CustomLineCap::SetBaseInset(IN REAL inset)
{
    return SetStatus(DllExports::GdipSetCustomLineCapBaseInset(nativeCap, 
                                                               inset));
}

inline REAL 
CustomLineCap::GetBaseInset() const
{
    REAL inset;
    SetStatus(DllExports::GdipGetCustomLineCapBaseInset(nativeCap, &inset));

    return inset;
}


inline Status 
CustomLineCap::SetWidthScale(IN REAL widthScale)
{
    return SetStatus(DllExports::GdipSetCustomLineCapWidthScale(nativeCap, 
                                                                widthScale));
}

inline REAL 
CustomLineCap::GetWidthScale() const
{
    REAL widthScale;
    SetStatus(DllExports::GdipGetCustomLineCapWidthScale(nativeCap, 
                                                         &widthScale));

    return widthScale;
}

inline CustomLineCap* 
CustomLineCap::Clone() const
{
    GpCustomLineCap *newNativeLineCap = NULL;
    
    SetStatus(DllExports::GdipCloneCustomLineCap(nativeCap, 
                                                 &newNativeLineCap));

    if (lastResult == Ok) 
    {
        CustomLineCap *newLineCap = new CustomLineCap(newNativeLineCap, 
                                                      lastResult);
        if (newLineCap == NULL) 
        {
            SetStatus(DllExports::GdipDeleteCustomLineCap(newNativeLineCap));
        }

        return newLineCap;
    }

    return NULL;
}

inline Status 
CustomLineCap::GetLastStatus() const 
{
    Status lastStatus = lastResult;
    lastResult = Ok;    
    return (lastStatus);
}

class AdjustableArrowCap : public CustomLineCap
{
public:

    AdjustableArrowCap(
        IN REAL height,
        IN REAL width,
        IN BOOL isFilled = TRUE
        )
    {
        GpAdjustableArrowCap* cap = NULL;

        lastResult = DllExports::GdipCreateAdjustableArrowCap(
                        height, width, isFilled, &cap);
        SetNativeCap(cap);
    }

    Status SetHeight(IN REAL height)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapHeight(
                            cap, height));
    }

    REAL GetHeight() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL height;
        SetStatus(DllExports::GdipGetAdjustableArrowCapHeight(
                            cap, &height));

        return height;
    }

    Status SetWidth(IN REAL width)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapWidth(
                            cap, width));
    }

    REAL GetWidth() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL width;
        SetStatus(DllExports::GdipGetAdjustableArrowCapWidth(
                            cap, &width));

        return width;
    }

    Status SetMiddleInset(IN REAL middleInset)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapMiddleInset(
                            cap, middleInset));
    }

    REAL GetMiddleInset() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL middleInset;
        SetStatus(DllExports::GdipGetAdjustableArrowCapMiddleInset(
                            cap, &middleInset));

        return middleInset;
    }

    Status SetFillState(IN BOOL isFilled)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapFillState(
                            cap, isFilled));
    }

    BOOL IsFilled() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        BOOL isFilled;
        SetStatus(DllExports::GdipGetAdjustableArrowCapFillState(
                            cap, &isFilled));

        return isFilled;
    }

private:
    AdjustableArrowCap(const AdjustableArrowCap &);
    AdjustableArrowCap& operator=(const AdjustableArrowCap &);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusFont.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusFont.h
*
* Abstract:
*
*   GDI+ Font class
*
\**************************************************************************/

#ifndef _GDIPLUSFONT_H
#define _GDIPLUSFONT_H

inline
Font::Font(IN HDC hdc)
{
    GpFont *font = NULL;
    lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const HFONT hfont)
{
    GpFont *font = NULL;

    if (hfont)
    {
        LOGFONTA lf;

        if(GetObjectA(hfont, sizeof(LOGFONTA), &lf))
            lastResult = DllExports::GdipCreateFontFromLogfontA(hdc, &lf, &font);
        else
            lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const LOGFONTW* logfont)
{
    GpFont *font = NULL;
    if (logfont)
    {
        lastResult = DllExports::GdipCreateFontFromLogfontW(hdc, logfont, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const LOGFONTA* logfont)
{
    GpFont *font = NULL;

    if (logfont)
    {
        lastResult = DllExports::GdipCreateFontFromLogfontA(hdc, logfont, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

    SetNativeFont(font);
}

inline
Font::Font(
     IN const FontFamily * family,
     IN REAL         emSize,
     IN INT          style,
     IN Unit         unit
)
{
    GpFont *font = NULL;

    lastResult = DllExports::GdipCreateFont(family ? family->nativeFamily : NULL,
                    emSize,
                    style,
                    unit,
                    &font);

    SetNativeFont(font);
}

inline
Font::Font(
     IN const WCHAR *          familyName,
     IN REAL                   emSize,
     IN INT                    style,
     IN Unit                   unit,
     IN const FontCollection * fontCollection
)
{
    nativeFont = NULL;

    FontFamily family(familyName, fontCollection);
    GpFontFamily *nativeFamily = family.nativeFamily;

    lastResult = family.GetLastStatus();

    if (lastResult != Ok)
    {
        nativeFamily = FontFamily::GenericSansSerif()->nativeFamily;
        lastResult = FontFamily::GenericSansSerif()->lastResult;
        if (lastResult != Ok)
            return;
    }

    lastResult = DllExports::GdipCreateFont(nativeFamily,
                            emSize,
                            style,
                            unit,
                            &nativeFont);

    if (lastResult != Ok)
    {
        nativeFamily = FontFamily::GenericSansSerif()->nativeFamily;
        lastResult = FontFamily::GenericSansSerif()->lastResult;
        if (lastResult != Ok)
            return;

        lastResult = DllExports::GdipCreateFont(
            nativeFamily,
            emSize,
            style,
            unit,
            &nativeFont);
    }
}

inline Status
Font::GetLogFontA(IN const Graphics *g,
                  OUT LOGFONTA *logfontA) const
{
    return SetStatus(DllExports::GdipGetLogFontA(nativeFont, g ? g->nativeGraphics : NULL, logfontA));

}

inline Status
Font::GetLogFontW(IN const Graphics *g,
                  OUT LOGFONTW *logfontW) const
{
    return SetStatus(DllExports::GdipGetLogFontW(nativeFont, g ? g->nativeGraphics : NULL, logfontW));
}


inline Font*
Font::Clone() const
{
    GpFont *cloneFont = NULL;

    SetStatus(DllExports::GdipCloneFont(nativeFont, &cloneFont));

    return new Font(cloneFont, lastResult);
}

inline
Font::~Font()
{
    DllExports::GdipDeleteFont(nativeFont);
}

// Operations

inline BOOL
Font::IsAvailable() const
{
    return (nativeFont ? TRUE : FALSE);
}

inline Status
Font::GetFamily(OUT FontFamily *family) const
{
    if (family == NULL)
    {
        return SetStatus(InvalidParameter);
    }

    Status status = DllExports::GdipGetFamily(nativeFont, &(family->nativeFamily));
    family->SetStatus(status);

    return SetStatus(status);
}

inline INT
Font::GetStyle() const
{
    INT style;

    SetStatus(DllExports::GdipGetFontStyle(nativeFont, &style));

    return style;
}

inline REAL
Font::GetSize() const
{
    REAL size;
    SetStatus(DllExports::GdipGetFontSize(nativeFont, &size));
    return size;
}

inline Unit
Font::GetUnit() const
{
    Unit unit;
    SetStatus(DllExports::GdipGetFontUnit(nativeFont, &unit));
    return unit;
}

inline REAL
Font::GetHeight(IN const Graphics *graphics) const
{
    REAL height;
    SetStatus(DllExports::GdipGetFontHeight(
        nativeFont,
        graphics ? graphics->nativeGraphics : NULL,
        &height
    ));
    return height;
}


inline REAL
Font::GetHeight(IN REAL dpi) const
{
    REAL height;
    SetStatus(DllExports::GdipGetFontHeightGivenDPI(nativeFont, dpi, &height));
    return height;
}

inline
Font::Font(IN GpFont* font,
           IN Status status)
{
    lastResult = status;
    SetNativeFont(font);
}

inline VOID
Font::SetNativeFont(GpFont *Font)
{
    nativeFont = Font;
}

inline Status
Font::GetLastStatus(void) const
{
    return lastResult;
}

inline Status
Font::SetStatus(IN Status status) const
{
    if (status != Ok)
        return (lastResult = status);
    else
        return status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusMem.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusMem.h
*
* Abstract:
*
*   GDI+ Private Memory Management APIs
*
\**************************************************************************/

#ifndef _GDIPLUSMEM_H
#define _GDIPLUSMEM_H

#ifdef __cplusplus
extern "C" {
#endif

#define WINGDIPAPI __stdcall

//----------------------------------------------------------------------------
// Memory Allocation APIs
//----------------------------------------------------------------------------

void* WINGDIPAPI
GdipAlloc(size_t size);

void WINGDIPAPI
GdipFree(void* ptr);

#ifdef __cplusplus
}
#endif

#endif // !_GDIPLUSMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusGraphics.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusGraphics.h
*
* Abstract:
*
*   GDI+ Graphics Object
*
\**************************************************************************/

#ifndef _GDIPLUSGRAPHICS_H
#define _GDIPLUSGRAPHICS_H

class Graphics : public GdiplusBase
{
public:
    friend class Region;
    friend class GraphicsPath;
    friend class Image;
    friend class Bitmap;
    friend class Metafile;
    friend class Font;
    friend class FontFamily;
    friend class FontCollection;
    friend class CachedBitmap;

    static Graphics* FromHDC(IN HDC hdc)
    {
        return new Graphics(hdc);
    }

    static Graphics* FromHDC(IN HDC hdc,
                             IN HANDLE hdevice)
    {
        return new Graphics(hdc, hdevice);
    }

    static Graphics* FromHWND(IN HWND hwnd,
                              IN BOOL icm = FALSE)
    {
        return new Graphics(hwnd, icm);
    }

    static Graphics* FromImage(IN Image *image)
    {
        return new Graphics(image);
    }

    Graphics(IN HDC hdc)
    {
        GpGraphics *graphics = NULL;

        lastResult = DllExports::GdipCreateFromHDC(hdc, &graphics);

        SetNativeGraphics(graphics);
    }

    Graphics(IN HDC hdc,
             IN HANDLE hdevice)
    {
        GpGraphics *graphics = NULL;

        lastResult = DllExports::GdipCreateFromHDC2(hdc, hdevice, &graphics);

        SetNativeGraphics(graphics);
    }

    Graphics(IN HWND hwnd,
             IN BOOL icm = FALSE)
    {
        GpGraphics *graphics = NULL;

        if (icm)
        {
            lastResult = DllExports::GdipCreateFromHWNDICM(hwnd, &graphics);
        }
        else
        {
            lastResult = DllExports::GdipCreateFromHWND(hwnd, &graphics);
        }

        SetNativeGraphics(graphics);
    }

    Graphics(IN Image* image)
    {
        GpGraphics *graphics = NULL;

        if (image != NULL)
        {
            lastResult = DllExports::GdipGetImageGraphicsContext(
                                                                image->nativeImage, &graphics);
        }
        SetNativeGraphics(graphics);
    }

    ~Graphics()
    {
        DllExports::GdipDeleteGraphics(nativeGraphics);
    }

    VOID Flush(IN FlushIntention intention = FlushIntentionFlush)
    {
        DllExports::GdipFlush(nativeGraphics, intention);
    }

    //------------------------------------------------------------------------
    // GDI Interop methods
    //------------------------------------------------------------------------

    // Locks the graphics until ReleaseDC is called

    HDC GetHDC()
    {
        HDC     hdc = NULL;

        SetStatus(DllExports::GdipGetDC(nativeGraphics, &hdc));

        return hdc;
    }

    VOID ReleaseHDC(IN HDC hdc)
    {
        SetStatus(DllExports::GdipReleaseDC(nativeGraphics, hdc));
    }

    //------------------------------------------------------------------------
    // Rendering modes
    //------------------------------------------------------------------------

    Status SetRenderingOrigin(IN INT x, IN INT y)
    {
        return SetStatus(
            DllExports::GdipSetRenderingOrigin(
                nativeGraphics, x, y
            )
        );
    }

    Status GetRenderingOrigin(OUT INT *x, OUT INT *y) const
    {
        return SetStatus(
            DllExports::GdipGetRenderingOrigin(
                nativeGraphics, x, y
            )
        );
    }

    Status SetCompositingMode(IN CompositingMode compositingMode)
    {
        return SetStatus(DllExports::GdipSetCompositingMode(nativeGraphics,
                                                            compositingMode));
    }

    CompositingMode GetCompositingMode() const
    {
        CompositingMode mode;

        SetStatus(DllExports::GdipGetCompositingMode(nativeGraphics,
                                                     &mode));

        return mode;
    }

    Status SetCompositingQuality(IN CompositingQuality compositingQuality)
    {
        return SetStatus(DllExports::GdipSetCompositingQuality(
            nativeGraphics,
            compositingQuality));
    }

    CompositingQuality GetCompositingQuality() const
    {
        CompositingQuality quality;

        SetStatus(DllExports::GdipGetCompositingQuality(
            nativeGraphics,
            &quality));

        return quality;
    }

    Status SetTextRenderingHint(IN TextRenderingHint newMode)
    {
        return SetStatus(DllExports::GdipSetTextRenderingHint(nativeGraphics,
                                                          newMode));
    }

    TextRenderingHint GetTextRenderingHint() const
    {
        TextRenderingHint hint;

        SetStatus(DllExports::GdipGetTextRenderingHint(nativeGraphics,
                                                   &hint));

        return hint;
    }

    Status SetTextContrast(IN UINT contrast)
    {
        return SetStatus(DllExports::GdipSetTextContrast(nativeGraphics,
                                                          contrast));
    }

    UINT GetTextContrast() const
    {
        UINT contrast;

        SetStatus(DllExports::GdipGetTextContrast(nativeGraphics,
                                                    &contrast));

        return contrast;
    }

    InterpolationMode GetInterpolationMode() const
    {
        InterpolationMode mode = InterpolationModeInvalid;

        SetStatus(DllExports::GdipGetInterpolationMode(nativeGraphics,
                                                           &mode));

        return mode;
    }

    Status SetInterpolationMode(IN InterpolationMode interpolationMode)
    {
        return SetStatus(DllExports::GdipSetInterpolationMode(nativeGraphics,
                                                           interpolationMode));
    }

#if (GDIPVER >= 0x0110)
    Status SetAbort(GdiplusAbort *pIAbort)
    {
        return SetStatus(DllExports::GdipGraphicsSetAbort(
            nativeGraphics,
            pIAbort
        ));
    }
#endif //(GDIPVER >= 0x0110)

    SmoothingMode GetSmoothingMode() const
    {
        SmoothingMode smoothingMode = SmoothingModeInvalid;

        SetStatus(DllExports::GdipGetSmoothingMode(nativeGraphics,
                                                   &smoothingMode));

        return smoothingMode;
    }

    Status SetSmoothingMode(IN SmoothingMode smoothingMode)
    {
        return SetStatus(DllExports::GdipSetSmoothingMode(nativeGraphics,
                                                          smoothingMode));
    }

    PixelOffsetMode GetPixelOffsetMode() const
    {
        PixelOffsetMode pixelOffsetMode = PixelOffsetModeInvalid;

        SetStatus(DllExports::GdipGetPixelOffsetMode(nativeGraphics,
                                                     &pixelOffsetMode));

        return pixelOffsetMode;
    }

    Status SetPixelOffsetMode(IN PixelOffsetMode pixelOffsetMode)
    {
        return SetStatus(DllExports::GdipSetPixelOffsetMode(nativeGraphics,
                                                            pixelOffsetMode));
    }

    //------------------------------------------------------------------------
    // Manipulate current world transform
    //------------------------------------------------------------------------

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetWorldTransform(nativeGraphics,
                                                        matrix->nativeMatrix));
    }
    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetWorldTransform(nativeGraphics));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyWorldTransform(nativeGraphics,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx,
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateWorldTransform(nativeGraphics,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx,
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleWorldTransform(nativeGraphics,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle,
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateWorldTransform(nativeGraphics,
                                                              angle, order));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetWorldTransform(nativeGraphics,
                                                           matrix->nativeMatrix));
    }

    Status SetPageUnit(IN Unit unit)
    {
        return SetStatus(DllExports::GdipSetPageUnit(nativeGraphics,
                                                     unit));
    }

    Status SetPageScale(IN REAL scale)
    {
        return SetStatus(DllExports::GdipSetPageScale(nativeGraphics,
                                                      scale));
    }

    Unit GetPageUnit() const
    {
        Unit unit;

        SetStatus(DllExports::GdipGetPageUnit(nativeGraphics, &unit));

        return unit;
    }

    REAL GetPageScale() const
    {
        REAL scale;

        SetStatus(DllExports::GdipGetPageScale(nativeGraphics, &scale));

        return scale;
    }

    REAL GetDpiX() const
    {
        REAL dpi;

        SetStatus(DllExports::GdipGetDpiX(nativeGraphics, &dpi));

        return dpi;
    }

    REAL GetDpiY() const
    {
        REAL dpi;

        SetStatus(DllExports::GdipGetDpiY(nativeGraphics, &dpi));

        return dpi;
    }

    Status TransformPoints(IN CoordinateSpace destSpace,
                           IN CoordinateSpace srcSpace,
                           IN OUT PointF* pts,
                           IN INT count) const
    {
        return SetStatus(DllExports::GdipTransformPoints(nativeGraphics,
                                                         destSpace,
                                                         srcSpace,
                                                         pts,
                                                         count));
    }

    Status TransformPoints(IN CoordinateSpace destSpace,
                           IN CoordinateSpace srcSpace,
                           IN OUT Point* pts,
                           IN INT count) const
    {

        return SetStatus(DllExports::GdipTransformPointsI(nativeGraphics,
                                                          destSpace,
                                                          srcSpace,
                                                          pts,
                                                          count));
    }

    //------------------------------------------------------------------------
    // GetNearestColor (for <= 8bpp surfaces).  Note: Alpha is ignored.
    //------------------------------------------------------------------------
    
    Status GetNearestColor(IN OUT Color* color) const
    {
        if (color == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        ARGB argb = color->GetValue();

        Status status = SetStatus(DllExports::GdipGetNearestColor(nativeGraphics, &argb));

        color->SetValue(argb);

        return status;
    }

    Status DrawLine(IN const Pen* pen,
                    IN REAL x1,
                    IN REAL y1,
                    IN REAL x2,
                    IN REAL y2)
    {
        return SetStatus(DllExports::GdipDrawLine(nativeGraphics,
                                                  pen->nativePen, x1, y1, x2,
                                                  y2));
    }

    Status DrawLine(IN const Pen* pen,
                    IN const PointF& pt1,
                    IN const PointF& pt2)
    {
        return DrawLine(pen, pt1.X, pt1.Y, pt2.X, pt2.Y);
    }

    Status DrawLines(IN const Pen* pen,
                     IN const PointF* points,
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawLines(nativeGraphics,
                                                   pen->nativePen,
                                                   points, count));
    }

    Status DrawLine(IN const Pen* pen,
                    IN INT x1,
                    IN INT y1,
                    IN INT x2,
                    IN INT y2)
    {
        return SetStatus(DllExports::GdipDrawLineI(nativeGraphics,
                                                   pen->nativePen,
                                                   x1,
                                                   y1,
                                                   x2,
                                                   y2));
    }

    Status DrawLine(IN const Pen* pen,
                    IN const Point& pt1,
                    IN const Point& pt2)
    {
        return DrawLine(pen,
                        pt1.X,
                        pt1.Y,
                        pt2.X,
                        pt2.Y);
    }

    Status DrawLines(IN const Pen* pen,
                     IN const Point* points,
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawLinesI(nativeGraphics,
                                                    pen->nativePen,
                                                    points,
                                                    count));
    }

    Status DrawArc(IN const Pen* pen,
                   IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawArc(nativeGraphics,
                                                 pen->nativePen,
                                                 x,
                                                 y,
                                                 width,
                                                 height,
                                                 startAngle,
                                                 sweepAngle));
    }

    Status DrawArc(IN const Pen* pen,
                   IN const RectF& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status DrawArc(IN const Pen* pen,
                   IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawArcI(nativeGraphics,
                                                  pen->nativePen,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }


    Status DrawArc(IN const Pen* pen,
                   IN const Rect& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawArc(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawBezier(IN const Pen* pen,
                      IN REAL x1,
                      IN REAL y1,
                      IN REAL x2,
                      IN REAL y2,
                      IN REAL x3,
                      IN REAL y3,
                      IN REAL x4,
                      IN REAL y4)
    {
        return SetStatus(DllExports::GdipDrawBezier(nativeGraphics,
                                                    pen->nativePen, x1, y1,
                                                    x2, y2, x3, y3, x4, y4));
    }

    Status DrawBezier(IN const Pen* pen,
                      IN const PointF& pt1,
                      IN const PointF& pt2,
                      IN const PointF& pt3,
                      IN const PointF& pt4)
    {
        return DrawBezier(pen,
                          pt1.X,
                          pt1.Y,
                          pt2.X,
                          pt2.Y,
                          pt3.X,
                          pt3.Y,
                          pt4.X,
                          pt4.Y);
    }

    Status DrawBeziers(IN const Pen* pen,
                       IN const PointF* points,
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawBeziers(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count));
    }

    Status DrawBezier(IN const Pen* pen,
                      IN INT x1,
                      IN INT y1,
                      IN INT x2,
                      IN INT y2,
                      IN INT x3,
                      IN INT y3,
                      IN INT x4,
                      IN INT y4)
    {
        return SetStatus(DllExports::GdipDrawBezierI(nativeGraphics,
                                                     pen->nativePen,
                                                     x1,
                                                     y1,
                                                     x2,
                                                     y2,
                                                     x3,
                                                     y3,
                                                     x4,
                                                     y4));
    }

    Status DrawBezier(IN const Pen* pen,
                      IN const Point& pt1,
                      IN const Point& pt2,
                      IN const Point& pt3,
                      IN const Point& pt4)
    {
        return DrawBezier(pen,
                          pt1.X,
                          pt1.Y,
                          pt2.X,
                          pt2.Y,
                          pt3.X,
                          pt3.Y,
                          pt4.X,
                          pt4.Y);
    }

    Status DrawBeziers(IN const Pen* pen,
                       IN const Point* points,
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawBeziersI(nativeGraphics,
                                                      pen->nativePen,
                                                      points,
                                                      count));
    }

    Status DrawRectangle(IN const Pen* pen,
                         IN const RectF& rect)
    {
        return DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawRectangle(IN const Pen* pen,
                         IN REAL x,
                         IN REAL y,
                         IN REAL width,
                         IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawRectangle(nativeGraphics,
                                                       pen->nativePen, x, y,
                                                       width, height));
    }

    Status DrawRectangles(IN const Pen* pen,
                          IN const RectF* rects,
                          IN INT count)
    {
        return SetStatus(DllExports::GdipDrawRectangles(nativeGraphics,
                                                        pen->nativePen,
                                                        rects, count));
    }

    Status DrawRectangle(IN const Pen* pen,
                         IN const Rect& rect)
    {
        return DrawRectangle(pen,
                             rect.X,
                             rect.Y,
                             rect.Width,
                             rect.Height);
    }

    Status DrawRectangle(IN const Pen* pen,
                         IN INT x,
                         IN INT y,
                         IN INT width,
                         IN INT height)
    {
        return SetStatus(DllExports::GdipDrawRectangleI(nativeGraphics,
                                                        pen->nativePen,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status DrawRectangles(IN const Pen* pen,
                          IN const Rect* rects,
                          IN INT count)
    {
        return SetStatus(DllExports::GdipDrawRectanglesI(nativeGraphics,
                                                         pen->nativePen,
                                                         rects,
                                                         count));
    }

    Status DrawEllipse(IN const Pen* pen,
                       IN const RectF& rect)
    {
        return DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawEllipse(IN const Pen* pen,
                       IN REAL x,
                       IN REAL y,
                       IN REAL width,
                       IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawEllipse(nativeGraphics,
                                                     pen->nativePen,
                                                     x,
                                                     y,
                                                     width,
                                                     height));
    }

    Status DrawEllipse(IN const Pen* pen,
                       IN const Rect& rect)
    {
        return DrawEllipse(pen,
                           rect.X,
                           rect.Y,
                           rect.Width,
                           rect.Height);
    }

    Status DrawEllipse(IN const Pen* pen,
                       IN INT x,
                       IN INT y,
                       IN INT width,
                       IN INT height)
    {
        return SetStatus(DllExports::GdipDrawEllipseI(nativeGraphics,
                                                      pen->nativePen,
                                                      x,
                                                      y,
                                                      width,
                                                      height));
    }

    Status DrawPie(IN const Pen* pen,
                   IN const RectF& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawPie(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawPie(IN const Pen* pen,
                   IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawPie(nativeGraphics,
                                                 pen->nativePen,
                                                 x,
                                                 y,
                                                 width,
                                                 height,
                                                 startAngle,
                                                 sweepAngle));
    }

    Status DrawPie(IN const Pen* pen,
                   IN const Rect& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawPie(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawPie(IN const Pen* pen,
                   IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawPieI(nativeGraphics,
                                                  pen->nativePen,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }

    Status DrawPolygon(IN const Pen* pen,
                       IN const PointF* points,
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawPolygon(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count));
    }

    Status DrawPolygon(IN const Pen* pen,
                       IN const Point* points,
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawPolygonI(nativeGraphics,
                                                      pen->nativePen,
                                                      points,
                                                      count));
    }

    Status DrawPath(IN const Pen* pen,
                    IN const GraphicsPath* path)
    {
        return SetStatus(DllExports::GdipDrawPath(nativeGraphics,
                                                  pen ? pen->nativePen : NULL,
                                                  path ? path->nativePath : NULL));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const PointF* points,
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawCurve(nativeGraphics,
                                                   pen->nativePen, points,
                                                   count));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const PointF* points,
                     IN INT count,
                     IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawCurve2(nativeGraphics,
                                                    pen->nativePen, points,
                                                    count, tension));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const PointF* points,
                     IN INT count,
                     IN INT offset,
                     IN INT numberOfSegments,
                     IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipDrawCurve3(nativeGraphics,
                                                    pen->nativePen, points,
                                                    count, offset,
                                                    numberOfSegments, tension));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const Point* points,
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawCurveI(nativeGraphics,
                                                    pen->nativePen,
                                                    points,
                                                    count));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const Point* points,
                     IN INT count,
                     IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawCurve2I(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count,
                                                     tension));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const Point* points,
                     IN INT count,
                     IN INT offset,
                     IN INT numberOfSegments,
                     IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipDrawCurve3I(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count,
                                                     offset,
                                                     numberOfSegments,
                                                     tension));
    }

    Status DrawClosedCurve(IN const Pen* pen,
                           IN const PointF* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve(nativeGraphics,
                                                         pen->nativePen,
                                                         points, count));
    }

    Status DrawClosedCurve(IN const Pen *pen,
                           IN const PointF* points,
                           IN INT count,
                           IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve2(nativeGraphics,
                                                          pen->nativePen,
                                                          points, count,
                                                          tension));
    }

    Status DrawClosedCurve(IN const Pen* pen,
                           IN const Point* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipDrawClosedCurveI(nativeGraphics,
                                                          pen->nativePen,
                                                          points,
                                                          count));
    }

    Status DrawClosedCurve(IN const Pen *pen,
                           IN const Point* points,
                           IN INT count,
                           IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve2I(nativeGraphics,
                                                           pen->nativePen,
                                                           points,
                                                           count,
                                                           tension));
    }

    Status Clear(IN const Color &color)
    {
        return SetStatus(DllExports::GdipGraphicsClear(
            nativeGraphics,
            color.GetValue()));
    }

    Status FillRectangle(IN const Brush* brush,
                         IN const RectF& rect)
    {
        return FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillRectangle(IN const Brush* brush,
                         IN REAL x,
                         IN REAL y,
                         IN REAL width,
                         IN REAL height)
    {
        return SetStatus(DllExports::GdipFillRectangle(nativeGraphics,
                                                       brush->nativeBrush, x, y,
                                                       width, height));
    }

    Status FillRectangles(IN const Brush* brush,
                          IN const RectF* rects,
                          IN INT count)
    {
        return SetStatus(DllExports::GdipFillRectangles(nativeGraphics,
                                                        brush->nativeBrush,
                                                        rects, count));
    }

    Status FillRectangle(IN const Brush* brush,
                         IN const Rect& rect)
    {
        return FillRectangle(brush,
                             rect.X,
                             rect.Y,
                             rect.Width,
                             rect.Height);
    }

    Status FillRectangle(IN const Brush* brush,
                         IN INT x,
                         IN INT y,
                         IN INT width,
                         IN INT height)
    {
        return SetStatus(DllExports::GdipFillRectangleI(nativeGraphics,
                                                        brush->nativeBrush,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status FillRectangles(IN const Brush* brush,
                          IN const Rect* rects,
                          IN INT count)
    {
        return SetStatus(DllExports::GdipFillRectanglesI(nativeGraphics,
                                                         brush->nativeBrush,
                                                         rects,
                                                         count));
    }

    Status FillPolygon(IN const Brush* brush,
                       IN const PointF* points,
                       IN INT count)
    {
        return FillPolygon(brush, points, count, FillModeAlternate);
    }

    Status FillPolygon(IN const Brush* brush,
                       IN const PointF* points,
                       IN INT count,
                       IN FillMode fillMode)
    {
        return SetStatus(DllExports::GdipFillPolygon(nativeGraphics,
                                                     brush->nativeBrush,
                                                     points, count, fillMode));
    }

    Status FillPolygon(IN const Brush* brush,
                       IN const Point* points,
                       IN INT count)
    {
        return FillPolygon(brush, points, count, FillModeAlternate);
    }

    Status FillPolygon(IN const Brush* brush,
                       IN const Point* points,
                       IN INT count,
                       IN FillMode fillMode)
    {
        return SetStatus(DllExports::GdipFillPolygonI(nativeGraphics,
                                                      brush->nativeBrush,
                                                      points, count,
                                                      fillMode));
    }

    Status FillEllipse(IN const Brush* brush,
                       IN const RectF& rect)
    {
        return FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillEllipse(IN const Brush* brush,
                       IN REAL x,
                       IN REAL y,
                       IN REAL width,
                       IN REAL height)
    {
        return SetStatus(DllExports::GdipFillEllipse(nativeGraphics,
                                                     brush->nativeBrush, x, y,
                                                     width, height));
    }

    Status FillEllipse(IN const Brush* brush,
                       IN const Rect& rect)
    {
        return FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillEllipse(IN const Brush* brush,
                       IN INT x,
                       IN INT y,
                       IN INT width,
                       IN INT height)
    {
        return SetStatus(DllExports::GdipFillEllipseI(nativeGraphics,
                                                      brush->nativeBrush,
                                                      x,
                                                      y,
                                                      width,
                                                      height));
    }

    Status FillPie(IN const Brush* brush,
                   IN const RectF& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status FillPie(IN const Brush* brush,
                   IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipFillPie(nativeGraphics,
                                                 brush->nativeBrush, x, y,
                                                 width, height, startAngle,
                                                 sweepAngle));
    }

    Status FillPie(IN const Brush* brush,
                   IN const Rect& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status FillPie(IN const Brush* brush,
                   IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipFillPieI(nativeGraphics,
                                                  brush->nativeBrush,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }

    Status FillPath(IN const Brush* brush,
                    IN const GraphicsPath* path)
    {
        return SetStatus(DllExports::GdipFillPath(nativeGraphics,
                                                  brush->nativeBrush,
                                                  path->nativePath));
    }

    Status FillClosedCurve(IN const Brush* brush,
                           IN const PointF* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipFillClosedCurve(nativeGraphics,
                                                         brush->nativeBrush,
                                                         points, count));

    }

    Status FillClosedCurve(IN const Brush* brush,
                           IN const PointF* points,
                           IN INT count,
                           IN FillMode fillMode,
                           IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipFillClosedCurve2(nativeGraphics,
                                                          brush->nativeBrush,
                                                          points, count,
                                                          tension, fillMode));
    }

    Status FillClosedCurve(IN const Brush* brush,
                           IN const Point* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipFillClosedCurveI(nativeGraphics,
                                                          brush->nativeBrush,
                                                          points,
                                                          count));
    }

    Status FillClosedCurve(IN const Brush* brush,
                           IN const Point* points,
                           IN INT count,
                           IN FillMode fillMode,
                           IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipFillClosedCurve2I(nativeGraphics,
                                                           brush->nativeBrush,
                                                           points, count,
                                                           tension, fillMode));
    }

    Status FillRegion(IN const Brush* brush,
                      IN const Region* region)
    {
        return SetStatus(DllExports::GdipFillRegion(nativeGraphics,
                                                    brush->nativeBrush,
                                                    region->nativeRegion));
    }

    Status
    DrawString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        IN const Brush        *brush
    )
    {
        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            brush ? brush->nativeBrush : NULL
        ));
    }

    Status
    DrawString(
        const WCHAR        *string,
        INT                 length,
        const Font         *font,
        const PointF       &origin,
        const Brush        *brush
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &rect,
            NULL,
            brush ? brush->nativeBrush : NULL
        ));
    }

    Status
    DrawString(
        const WCHAR        *string,
        INT                 length,
        const Font         *font,
        const PointF       &origin,
        const StringFormat *stringFormat,
        const Brush        *brush
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &rect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            brush ? brush->nativeBrush : NULL
        ));
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        OUT RectF             *boundingBox,
        OUT INT               *codepointsFitted = 0,
        OUT INT               *linesFilled      = 0
    ) const
    {
        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            boundingBox,
            codepointsFitted,
            linesFilled
        ));
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const SizeF        &layoutRectSize,
        IN const StringFormat *stringFormat,
        OUT SizeF             *size,
        OUT INT               *codepointsFitted = 0,
        OUT INT               *linesFilled      = 0
    ) const
    {
        RectF   layoutRect(0, 0, layoutRectSize.Width, layoutRectSize.Height);
        RectF   boundingBox;
        Status  status;

        if (size == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        status = SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            size ? &boundingBox : NULL,
            codepointsFitted,
            linesFilled
        ));

        if (size && status == Ok)
        {
            size->Width  = boundingBox.Width;
            size->Height = boundingBox.Height;
        }

        return status;
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const PointF       &origin,
        IN const StringFormat *stringFormat,
        OUT RectF             *boundingBox
    ) const
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &rect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }

    Status
    MeasureString(
        IN const WCHAR  *string,
        IN INT           length,
        IN const Font   *font,
        IN const RectF  &layoutRect,
        OUT RectF       *boundingBox
    ) const
    {
        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &layoutRect,
            NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }

    Status
    MeasureString(
        IN const WCHAR  *string,
        IN INT           length,
        IN const Font   *font,
        IN const PointF &origin,
        OUT RectF       *boundingBox
    ) const
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &rect,
            NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }


    Status
    MeasureCharacterRanges(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        IN INT                 regionCount,
        OUT Region            *regions
    ) const
    {
        if (!regions || regionCount <= 0)
        {
            return InvalidParameter;
        }

        GpRegion **nativeRegions = new GpRegion* [regionCount];

        if (!nativeRegions)
        {
            return OutOfMemory;
        }

        for (INT i = 0; i < regionCount; i++)
        {
            nativeRegions[i] = regions[i].nativeRegion;
        }

        Status status = SetStatus(DllExports::GdipMeasureCharacterRanges(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            regionCount,
            nativeRegions
        ));

        delete [] nativeRegions;

        return status;
    }

    Status DrawDriverString(
        IN const UINT16  *text,
        IN INT            length,
        IN const Font    *font,
        IN const Brush   *brush,
        IN const PointF  *positions,
        IN INT            flags,
        IN const Matrix        *matrix
    )
    {
        return SetStatus(DllExports::GdipDrawDriverString(
            nativeGraphics,
            text,
            length,
            font ? font->nativeFont : NULL,
            brush ? brush->nativeBrush : NULL,
            positions,
            flags,
            matrix ? matrix->nativeMatrix : NULL
        ));
    }

    Status MeasureDriverString(
        IN const UINT16  *text,
        IN INT            length,
        IN const Font    *font,
        IN const PointF  *positions,
        IN INT            flags,
        IN const Matrix        *matrix,
        OUT RectF        *boundingBox
    ) const
    {
        return SetStatus(DllExports::GdipMeasureDriverString(
            nativeGraphics,
            text,
            length,
            font ? font->nativeFont : NULL,
            positions,
            flags,
            matrix ? matrix->nativeMatrix : NULL,
            boundingBox
        ));
    }

    // Draw a cached bitmap on this graphics destination offset by
    // x, y. Note this will fail with WrongState if the CachedBitmap
    // native format differs from this Graphics.

    Status DrawCachedBitmap(IN CachedBitmap *cb,
                            IN INT x,
                            IN INT y)
    {
        return SetStatus(DllExports::GdipDrawCachedBitmap(
            nativeGraphics,
            cb->nativeCachedBitmap,
            x, y
        ));
    }

    Status DrawImage(IN Image* image,
                     IN const PointF& point)
    {
        return DrawImage(image, point.X, point.Y);
    }

    Status DrawImage(IN Image* image,
                     IN REAL x,
                     IN REAL y)
    {
        return SetStatus(DllExports::GdipDrawImage(nativeGraphics,
                                                   image ? image->nativeImage
                                                         : NULL,
                                                   x,
                                                   y));
    }

    Status DrawImage(IN Image* image, 
                     IN const RectF& rect)
    {
        return DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawImage(IN Image* image,
                     IN REAL x,
                     IN REAL y,
                     IN REAL width,
                     IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawImageRect(nativeGraphics,
                                                       image ? image->nativeImage
                                                             : NULL,
                                                       x,
                                                       y,
                                                       width,
                                                       height));
    }

    Status DrawImage(IN Image* image,
                     IN const Point& point)
    {
        return DrawImage(image, point.X, point.Y);
    }

    Status DrawImage(IN Image* image,
                     IN INT x,
                     IN INT y)
    {
        return SetStatus(DllExports::GdipDrawImageI(nativeGraphics,
                                                    image ? image->nativeImage
                                                          : NULL,
                                                    x,
                                                    y));
    }

    Status DrawImage(IN Image* image,
                     IN const Rect& rect)
    {
        return DrawImage(image,
                         rect.X,
                         rect.Y,
                         rect.Width,
                         rect.Height);
    }

    Status DrawImage(IN Image* image,
                     IN INT x,
                     IN INT y,
                     IN INT width,
                     IN INT height) {
        return SetStatus(DllExports::GdipDrawImageRectI(nativeGraphics,
                                                        image ? image->nativeImage
                                                              : NULL,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    
    Status DrawImage(IN Image* image,
                     IN const PointF* destPoints,
                     IN INT count)
    {
        if (count != 3 && count != 4)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipDrawImagePoints(nativeGraphics,
                                                         image ? image->nativeImage
                                                               : NULL,
                                                         destPoints, count));
    }

    Status DrawImage(IN Image* image,
                     IN const Point* destPoints,
                     IN INT count)
    {
        if (count != 3 && count != 4)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipDrawImagePointsI(nativeGraphics,
                                                          image ? image->nativeImage
                                                                : NULL,
                                                          destPoints,
                                                          count));
    }

    Status DrawImage(IN Image* image,
                     IN REAL x,
                     IN REAL y,
                     IN REAL srcx,
                     IN REAL srcy,
                     IN REAL srcwidth,
                     IN REAL srcheight,
                     IN Unit srcUnit)
    {
        return SetStatus(DllExports::GdipDrawImagePointRect(nativeGraphics,
                                                            image ? image->nativeImage
                                                                  : NULL,
                                                            x, y,
                                                            srcx, srcy,
                                                            srcwidth, srcheight, srcUnit));
    }

    Status DrawImage(IN Image* image,
                     IN const RectF& destRect,
                     IN REAL srcx,
                     IN REAL srcy,
                     IN REAL srcwidth,
                     IN REAL srcheight,
                     IN Unit srcUnit,
                     IN const ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImageRectRect(nativeGraphics,
                                                           image ? image->nativeImage
                                                                 : NULL,
                                                           destRect.X,
                                                           destRect.Y,
                                                           destRect.Width,
                                                           destRect.Height,
                                                           srcx, srcy,
                                                           srcwidth, srcheight,
                                                           srcUnit,
                                                           imageAttributes
                                                            ? imageAttributes->nativeImageAttr
                                                            : NULL,
                                                           callback,
                                                           callbackData));
    }

    Status DrawImage(IN Image* image,
                     IN const PointF* destPoints,
                     IN INT count,
                     IN REAL srcx,
                     IN REAL srcy,
                     IN REAL srcwidth,
                     IN REAL srcheight,
                     IN Unit srcUnit,
                     IN const ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImagePointsRect(nativeGraphics,
                                                             image ? image->nativeImage
                                                                   : NULL,
                                                             destPoints, count,
                                                             srcx, srcy,
                                                             srcwidth,
                                                             srcheight,
                                                             srcUnit,
                                                             imageAttributes
                                                              ? imageAttributes->nativeImageAttr
                                                              : NULL,
                                                             callback,
                                                             callbackData));
    }

    Status DrawImage(IN Image* image,
                     IN INT x,
                     IN INT y,
                     IN INT srcx,
                     IN INT srcy,
                     IN INT srcwidth,
                     IN INT srcheight,
                     IN Unit srcUnit)
    {
        return SetStatus(DllExports::GdipDrawImagePointRectI(nativeGraphics,
                                                             image ? image->nativeImage
                                                                   : NULL,
                                                             x,
                                                             y,
                                                             srcx,
                                                             srcy,
                                                             srcwidth,
                                                             srcheight,
                                                             srcUnit));
    }

    Status DrawImage(IN Image* image,
                     IN const Rect& destRect,
                     IN INT srcx,
                     IN INT srcy,
                     IN INT srcwidth,
                     IN INT srcheight,
                     IN Unit srcUnit,
                     IN const ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImageRectRectI(nativeGraphics,
                                                            image ? image->nativeImage
                                                                  : NULL,
                                                            destRect.X,
                                                            destRect.Y,
                                                            destRect.Width,
                                                            destRect.Height,
                                                            srcx,
                                                            srcy,
                                                            srcwidth,
                                                            srcheight,
                                                            srcUnit,
                                                            imageAttributes
                                                            ? imageAttributes->nativeImageAttr
                                                            : NULL,
                                                            callback,
                                                            callbackData));
    }

    Status DrawImage(IN Image* image,
                     IN const Point* destPoints,
                     IN INT count,
                     IN INT srcx,
                     IN INT srcy,
                     IN INT srcwidth,
                     IN INT srcheight,
                     IN Unit srcUnit,
                     IN const ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImagePointsRectI(nativeGraphics,
                                                              image ? image->nativeImage
                                                                    : NULL,
                                                              destPoints,
                                                              count,
                                                              srcx,
                                                              srcy,
                                                              srcwidth,
                                                              srcheight,
                                                              srcUnit,
                                                              imageAttributes
                                                               ? imageAttributes->nativeImageAttr
                                                               : NULL,
                                                              callback,
                                                              callbackData));
    }
    
#if (GDIPVER >= 0x0110)
    Status DrawImage(
        IN Image *image,
        IN const RectF &destRect,
        IN const RectF &sourceRect,
        IN Unit srcUnit,
        IN const ImageAttributes *imageAttributes = NULL
    )
    {
        return SetStatus(DllExports::GdipDrawImageRectRect(
            nativeGraphics,
            image->nativeImage,
            destRect.X,
            destRect.Y,
            destRect.Width,
            destRect.Height,
            sourceRect.X,
            sourceRect.Y,
            sourceRect.Width,
            sourceRect.Height,
            srcUnit,
            imageAttributes ? imageAttributes->nativeImageAttr : NULL,
            NULL,
            NULL
        ));
    }

    Status DrawImage(
        IN Image *image,
        IN RectF *sourceRect,
        IN Matrix *xForm,
        IN Effect *effect,
        IN ImageAttributes *imageAttributes,
        IN Unit srcUnit
    )
    {
        return SetStatus(DllExports::GdipDrawImageFX(
            nativeGraphics,
            image->nativeImage,
            sourceRect,
            xForm ? xForm->nativeMatrix : NULL,
            effect ? effect->nativeEffect : NULL,
            imageAttributes ? imageAttributes->nativeImageAttr : NULL,
            srcUnit
        ));
    }
#endif //(GDIPVER >= 0x0110)

    // The following methods are for playing an EMF+ to a graphics
    // via the enumeration interface.  Each record of the EMF+ is
    // sent to the callback (along with the callbackData).  Then
    // the callback can invoke the Metafile::PlayRecord method
    // to play the particular record.

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF &          destPoint,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPoint(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point &           destPoint,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPointI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const RectF &           destRect,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestRect(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Rect &            destRect,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestRectI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF *          destPoints,
        IN INT                     count,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPoints(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point *           destPoints,
        IN INT                     count,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPointsI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF &          destPoint,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPoint(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point &           destPoint,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPointI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const RectF &           destRect,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestRect(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Rect &            destRect,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestRectI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF *          destPoints,
        IN INT                     count,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPoints(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point *           destPoints,
        IN INT                     count,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPointsI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }
    
    Status SetClip(IN const Graphics* g,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipGraphics(nativeGraphics,
                                                         g->nativeGraphics,
                                                         combineMode));
    }

    Status SetClip(IN const RectF& rect,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     combineMode));
    }

    Status SetClip(IN const Rect& rect,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      combineMode));
    }

    Status SetClip(IN const GraphicsPath* path,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipPath(nativeGraphics,
                                                     path->nativePath,
                                                     combineMode));
    }

    Status SetClip(IN const Region* region,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       combineMode));
    }

    // This is different than the other SetClip methods because it assumes
    // that the HRGN is already in device units, so it doesn't transform
    // the coordinates in the HRGN.
    
    Status SetClip(IN HRGN hRgn,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipHrgn(nativeGraphics, hRgn,
                                                     combineMode));
    }

    Status IntersectClip(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     CombineModeIntersect));
    }

    Status IntersectClip(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      CombineModeIntersect));
    }

    Status IntersectClip(IN const Region* region)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       CombineModeIntersect));
    }

    Status ExcludeClip(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     CombineModeExclude));
    }

    Status ExcludeClip(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      CombineModeExclude));
    }

    Status ExcludeClip(IN const Region* region)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       CombineModeExclude));
    }

    Status ResetClip()
    {
        return SetStatus(DllExports::GdipResetClip(nativeGraphics));
    }

    Status TranslateClip(IN REAL dx,
                         IN REAL dy)
    {
        return SetStatus(DllExports::GdipTranslateClip(nativeGraphics, dx, dy));
    }

    Status TranslateClip(IN INT dx,
                         IN INT dy)
    {
        return SetStatus(DllExports::GdipTranslateClipI(nativeGraphics,
                                                        dx, dy));
    }

    Status GetClip(OUT Region* region) const
    {
        return SetStatus(DllExports::GdipGetClip(nativeGraphics,
                                                 region->nativeRegion));
    }

    Status GetClipBounds(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetClipBounds(nativeGraphics, rect));
    }

    Status GetClipBounds(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetClipBoundsI(nativeGraphics, rect));
    }

    BOOL IsClipEmpty() const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsClipEmpty(nativeGraphics, &booln));

        return booln;
    }

    Status GetVisibleClipBounds(OUT RectF *rect) const
    {

        return SetStatus(DllExports::GdipGetVisibleClipBounds(nativeGraphics,
                                                              rect));
    }

    Status GetVisibleClipBounds(OUT Rect *rect) const
    {
       return SetStatus(DllExports::GdipGetVisibleClipBoundsI(nativeGraphics,
                                                              rect));
    }

    BOOL IsVisibleClipEmpty() const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisibleClipEmpty(nativeGraphics, &booln));

        return booln;
    }

    BOOL IsVisible(IN INT x,
                   IN INT y) const
    {
        return IsVisible(Point(x,y));
    }

    BOOL IsVisible(IN const Point& point) const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisiblePointI(nativeGraphics,
                                                  point.X,
                                                  point.Y,
                                                  &booln));

        return booln;
    }

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height) const
    {
        return IsVisible(Rect(x, y, width, height));
    }

    BOOL IsVisible(IN const Rect& rect) const
    {

        BOOL booln = TRUE;

        SetStatus(DllExports::GdipIsVisibleRectI(nativeGraphics,
                                                 rect.X,
                                                 rect.Y,
                                                 rect.Width,
                                                 rect.Height,
                                                 &booln));
        return booln;
    }

    BOOL IsVisible(IN REAL x,
                   IN REAL y) const
    {
        return IsVisible(PointF(x, y));
    }

    BOOL IsVisible(IN const PointF& point) const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisiblePoint(nativeGraphics,
                                                 point.X,
                                                 point.Y,
                                                 &booln));

        return booln;
    }

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height) const
    {
        return IsVisible(RectF(x, y, width, height));
    }

    BOOL IsVisible(IN const RectF& rect) const
    {
        BOOL booln = TRUE;

        SetStatus(DllExports::GdipIsVisibleRect(nativeGraphics,
                                                rect.X,
                                                rect.Y,
                                                rect.Width,
                                                rect.Height,
                                                &booln));
        return booln;
    }

    GraphicsState Save() const
    {
        GraphicsState gstate;

        SetStatus(DllExports::GdipSaveGraphics(nativeGraphics, &gstate));

        return gstate;
    }

    Status Restore(IN GraphicsState gstate)
    {
        return SetStatus(DllExports::GdipRestoreGraphics(nativeGraphics,
                                                         gstate));
    }

    GraphicsContainer BeginContainer(IN const RectF &dstrect,
                                     IN const RectF &srcrect,
                                     IN Unit         unit)
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainer(nativeGraphics, &dstrect,
                                                 &srcrect, unit, &state));

        return state;
    }

    GraphicsContainer BeginContainer(IN const Rect    &dstrect,
                                     IN const Rect    &srcrect,
                                     IN Unit           unit)
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainerI(nativeGraphics, &dstrect,
                                                  &srcrect, unit, &state));

        return state;
    }

    GraphicsContainer BeginContainer()
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainer2(nativeGraphics, &state));

        return state;
    }

    Status EndContainer(IN GraphicsContainer state)
    {
        return SetStatus(DllExports::GdipEndContainer(nativeGraphics, state));
    }

    // Only valid when recording metafiles.

    Status AddMetafileComment(IN const BYTE * data,
                              IN UINT sizeData)
    {
        return SetStatus(DllExports::GdipComment(nativeGraphics, sizeData, data));
    }

    static HPALETTE GetHalftonePalette()
    {
        return DllExports::GdipCreateHalftonePalette();
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

private:
    Graphics(const Graphics &);
    Graphics& operator=(const Graphics &);

protected:
    Graphics(GpGraphics* graphics)
    {
        lastResult = Ok;
        SetNativeGraphics(graphics);
    }

    VOID SetNativeGraphics(GpGraphics *graphics)
    {
        this->nativeGraphics = graphics;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpGraphics* GetNativeGraphics() const
    {
        return this->nativeGraphics;
    }

    GpPen* GetNativePen(const Pen* pen)
    {
        return pen->nativePen;
    }

protected:
    GpGraphics* nativeGraphics;
    mutable Status lastResult;

};

//----------------------------------------------------------------------------
// Implementation of GraphicsPath methods that use Graphics
//----------------------------------------------------------------------------

// The GetBounds rectangle may not be the tightest bounds.

inline Status
GraphicsPath::GetBounds(
    OUT RectF* bounds,
    IN const Matrix* matrix,
    IN const Pen* pen) const
{
    GpMatrix* nativeMatrix = NULL;
    GpPen* nativePen = NULL;

    if (matrix)
        nativeMatrix = matrix->nativeMatrix;

    if (pen)
        nativePen = pen->nativePen;

    return SetStatus(DllExports::GdipGetPathWorldBounds(nativePath, bounds,
                                                   nativeMatrix, nativePen));
}

inline Status
GraphicsPath::GetBounds(
    OUT Rect* bounds,
    IN const Matrix* matrix,
    IN const Pen* pen
) const
{
    GpMatrix* nativeMatrix = NULL;
    GpPen* nativePen = NULL;

    if (matrix)
        nativeMatrix = matrix->nativeMatrix;

    if (pen)
        nativePen = pen->nativePen;

    return SetStatus(DllExports::GdipGetPathWorldBoundsI(nativePath, bounds,
                                                    nativeMatrix, nativePen));
}

inline BOOL
GraphicsPath::IsVisible(
    IN REAL x,
    IN REAL y,
    IN const Graphics* g) const
{
   BOOL booln = FALSE;

   GpGraphics* nativeGraphics = NULL;

   if (g)
       nativeGraphics = g->nativeGraphics;

   SetStatus(DllExports::GdipIsVisiblePathPoint(nativePath,
                                                x, y, nativeGraphics,
                                                &booln));
   return booln;
}

inline BOOL
GraphicsPath::IsVisible(
    IN INT x,
    IN INT y,
    IN const Graphics* g) const
{
   BOOL booln = FALSE;

   GpGraphics* nativeGraphics = NULL;

   if (g)
       nativeGraphics = g->nativeGraphics;

   SetStatus(DllExports::GdipIsVisiblePathPointI(nativePath,
                                                 x, y, nativeGraphics,
                                                 &booln));
   return booln;
}

inline BOOL
GraphicsPath::IsOutlineVisible(
    IN REAL x,
    IN REAL y,
    IN const Pen* pen,
    IN const Graphics* g) const
{
    BOOL booln = FALSE;

    GpGraphics* nativeGraphics = NULL;
    GpPen* nativePen = NULL;

    if(g)
        nativeGraphics = g->nativeGraphics;
    if(pen)
        nativePen = pen->nativePen;

    SetStatus(DllExports::GdipIsOutlineVisiblePathPoint(nativePath,
                                                        x, y, nativePen, nativeGraphics,
                                                        &booln));
    return booln;
}

inline BOOL
GraphicsPath::IsOutlineVisible(
    IN INT x,
    IN INT y,
    IN const Pen* pen,
    IN const Graphics* g) const
{
    BOOL booln = FALSE;

    GpGraphics* nativeGraphics = NULL;
    GpPen* nativePen = NULL;

    if(g)
        nativeGraphics = g->nativeGraphics;
    if(pen)
        nativePen = pen->nativePen;

    SetStatus(DllExports::GdipIsOutlineVisiblePathPointI(nativePath,
                                                         x, y, nativePen, nativeGraphics,
                                                         &booln));
    return booln;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusimageAttributes.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Image Attributes
*
* Abstract:
*
*   GDI+ Image Attributes used with Graphics.DrawImage
*
* There are 5 possible sets of color adjustments:
*          ColorAdjustDefault,
*          ColorAdjustBitmap,
*          ColorAdjustBrush,
*          ColorAdjustPen,
*          ColorAdjustText,
*
* Bitmaps, Brushes, Pens, and Text will all use any color adjustments
* that have been set into the default ImageAttributes until their own
* color adjustments have been set.  So as soon as any "Set" method is
* called for Bitmaps, Brushes, Pens, or Text, then they start from
* scratch with only the color adjustments that have been set for them.
* Calling Reset removes any individual color adjustments for a type
* and makes it revert back to using all the default color adjustments
* (if any).  The SetToIdentity method is a way to force a type to
* have no color adjustments at all, regardless of what previous adjustments
* have been set for the defaults or for that type.
*
\********************************************************************F******/

#ifndef _GDIPLUSIMAGEATTRIBUTES_H
#define _GDIPLUSIMAGEATTRIBUTES_H

class GpImageAttributes;

class ImageAttributes : public GdiplusBase
{
    friend class Graphics;
    friend class TextureBrush;

public:

    ImageAttributes()
    {
        nativeImageAttr = NULL;
        lastResult = DllExports::GdipCreateImageAttributes(&nativeImageAttr);
    }

    ~ImageAttributes()
    {
        DllExports::GdipDisposeImageAttributes(nativeImageAttr);
    }

    ImageAttributes* Clone() const
    {
        GpImageAttributes* clone;

        SetStatus(DllExports::GdipCloneImageAttributes(
                                            nativeImageAttr,
                                            &clone));

        return new ImageAttributes(clone, lastResult);
    }

    Status
    SetToIdentity(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesToIdentity(
                                            nativeImageAttr,
                                            type));
    }

    Status
    Reset(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipResetImageAttributes(
                                            nativeImageAttr,
                                            type));
    }

    Status
    SetColorMatrix(
        IN const ColorMatrix *colorMatrix,
        IN ColorMatrixFlags mode = ColorMatrixFlagsDefault,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorMatrix,
                                            NULL,
                                            mode));
    }

    Status ClearColorMatrix(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL,
                                            ColorMatrixFlagsDefault));
    }

    Status
    SetColorMatrices(
        IN const ColorMatrix *colorMatrix,
        IN const ColorMatrix *grayMatrix,
        IN ColorMatrixFlags mode = ColorMatrixFlagsDefault,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorMatrix,
                                            grayMatrix,
                                            mode));
    }

    Status ClearColorMatrices(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL,
                                            ColorMatrixFlagsDefault));
    }

    Status SetThreshold(
        IN REAL threshold,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesThreshold(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            threshold));
    }

    Status ClearThreshold(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesThreshold(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0.0));
    }

    Status SetGamma(
        IN REAL gamma,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesGamma(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            gamma));
    }

    Status ClearGamma(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesGamma(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0.0));
    }

    Status SetNoOp(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesNoOp(
                                            nativeImageAttr,
                                            type,
                                            TRUE));
    }

    Status ClearNoOp(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesNoOp(
                                            nativeImageAttr,
                                            type,
                                            FALSE));
    }

    Status SetColorKey(
        IN const Color& colorLow, 
        IN const Color& colorHigh,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorKeys(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorLow.GetValue(),
                                            colorHigh.GetValue()));
    }

    Status ClearColorKey(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorKeys(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL));
    }

    Status SetOutputChannel(
        IN ColorChannelFlags channelFlags,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannel(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            channelFlags));
    }
    
    Status ClearOutputChannel(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannel(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            ColorChannelFlagsLast));
    }

    Status SetOutputChannelColorProfile(
        IN const WCHAR *colorProfileFilename,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannelColorProfile(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorProfileFilename));
    }
    
    Status ClearOutputChannelColorProfile(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannelColorProfile(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL));
    }
    
    Status SetRemapTable(
        IN UINT mapSize, 
        IN const ColorMap *map,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesRemapTable(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            mapSize,
                                            map));
    }

    Status ClearRemapTable(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesRemapTable(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0,
                                            NULL));
    }

    Status SetBrushRemapTable(IN UINT mapSize, 
                              IN const ColorMap *map)
    {
        return this->SetRemapTable(mapSize, map, ColorAdjustTypeBrush);
    }

    Status ClearBrushRemapTable()
    {
        return this->ClearRemapTable(ColorAdjustTypeBrush);
    }

    Status SetWrapMode(IN WrapMode wrap, 
                       IN const Color& color = Color(), 
                       IN BOOL clamp = FALSE) 
    {
        ARGB argb = color.GetValue();

        return SetStatus(DllExports::GdipSetImageAttributesWrapMode(
                           nativeImageAttr, wrap, argb, clamp));
    }

    // The flags of the palette are ignored.

    Status GetAdjustedPalette(IN OUT ColorPalette* colorPalette,
                              IN ColorAdjustType colorAdjustType) const 
    {
        return SetStatus(DllExports::GdipGetImageAttributesAdjustedPalette(
                           nativeImageAttr, colorPalette, colorAdjustType));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;
    
        return lastStatus;
    }
    
private:
    ImageAttributes(const ImageAttributes &);
    ImageAttributes& operator=(const ImageAttributes &);

protected:
    ImageAttributes(GpImageAttributes* imageAttr, Status status)
    {
        SetNativeImageAttr(imageAttr);
        lastResult = status;
    }

    VOID SetNativeImageAttr(GpImageAttributes* nativeImageAttr)
    {
        this->nativeImageAttr = nativeImageAttr;
    }
    
    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else 
            return status;
    }

protected:
    GpImageAttributes* nativeImageAttr;
    mutable Status lastResult;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusImaging.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   GdiplusImaging.h
*
* Abstract:
*
*   GDI+ Imaging GUIDs
*
\**************************************************************************/

#ifndef _GDIPLUSIMAGING_H
#define _GDIPLUSIMAGING_H

//---------------------------------------------------------------------------
// Image file format identifiers
//---------------------------------------------------------------------------

DEFINE_GUID(ImageFormatUndefined, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatMemoryBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatBMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatEMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatWMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatJPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatPNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatGIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatTIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatEXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatIcon, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//---------------------------------------------------------------------------
// Predefined multi-frame dimension IDs
//---------------------------------------------------------------------------

DEFINE_GUID(FrameDimensionTime, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FrameDimensionResolution, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FrameDimensionPage, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//---------------------------------------------------------------------------
// Property sets
//---------------------------------------------------------------------------

DEFINE_GUID(FormatIDImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FormatIDJpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

//---------------------------------------------------------------------------
// Encoder parameter sets
//---------------------------------------------------------------------------

DEFINE_GUID(EncoderCompression, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(EncoderColorDepth, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(EncoderScanMethod, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(EncoderVersion, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(EncoderRenderMethod, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(EncoderQuality, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(EncoderTransformation,0x8d0eb2d1,0xa58e,0x4ea8,0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9);
DEFINE_GUID(EncoderLuminanceTable,0xedb33bce,0x0266,0x4a77,0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17);
DEFINE_GUID(EncoderChrominanceTable,0xf2e455dc,0x09b3,0x4316,0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c);
DEFINE_GUID(EncoderSaveFlag,0x292266fc,0xac40,0x47bf,0x8c, 0xfc, 0xa8, 0x5b, 0x89, 0xa6, 0x55, 0xde);

#if (GDIPVER >= 0x0110)
DEFINE_GUID(EncoderColorSpace,0xae7a62a0,0xee2c,0x49d8,0x9d,0x7,0x1b,0xa8,0xa9,0x27,0x59,0x6e);
DEFINE_GUID(EncoderImageItems,0x63875e13,0x1f1d,0x45ab,0x91, 0x95, 0xa2, 0x9b, 0x60, 0x66, 0xa6, 0x50);
DEFINE_GUID(EncoderSaveAsCMYK,0xa219bbc9, 0xa9d, 0x4005, 0xa3, 0xee, 0x3a, 0x42, 0x1b, 0x8b, 0xb0, 0x6c);
#endif //(GDIPVER >= 0x0110)

DEFINE_GUID(CodecIImageBytes,0x025d1823,0x6c7d,0x447b,0xbb, 0xdb, 0xa3, 0xcb, 0xc3, 0xdf, 0xa2, 0xfc);

MIDL_INTERFACE("025D1823-6C7D-447B-BBDB-A3CBC3DFA2FC")
IImageBytes : public IUnknown
{
public:
    // Return total number of bytes in the IStream

    STDMETHOD(CountBytes)(
        OUT UINT *pcb
        ) = 0;
    
    // Locks "cb" bytes, starting from "ulOffset" in the stream, and returns the
    // pointer to the beginning of the locked memory chunk in "ppvBytes"

    STDMETHOD(LockBytes)(
        IN UINT cb,
        IN ULONG ulOffset,
        OUT const VOID ** ppvBytes
        ) = 0;

    // Unlocks "cb" bytes, pointed by "pvBytes", starting from "ulOffset" in the
    // stream

    STDMETHOD(UnlockBytes)(
        IN const VOID *pvBytes,
        IN UINT cb,
        IN ULONG ulOffset
        ) = 0;
};

//--------------------------------------------------------------------------
// ImageCodecInfo structure
//--------------------------------------------------------------------------

class ImageCodecInfo
{
public:          
    CLSID Clsid;
    GUID  FormatID;
    const WCHAR* CodecName;
    const WCHAR* DllName;
    const WCHAR* FormatDescription;
    const WCHAR* FilenameExtension;
    const WCHAR* MimeType;
    DWORD Flags;
    DWORD Version;
    DWORD SigCount;
    DWORD SigSize;
    const BYTE* SigPattern;
    const BYTE* SigMask;
};

//--------------------------------------------------------------------------
// Information flags about image codecs
//--------------------------------------------------------------------------

enum ImageCodecFlags
{
    ImageCodecFlagsEncoder            = 0x00000001,
    ImageCodecFlagsDecoder            = 0x00000002,
    ImageCodecFlagsSupportBitmap      = 0x00000004,
    ImageCodecFlagsSupportVector      = 0x00000008,
    ImageCodecFlagsSeekableEncode     = 0x00000010,
    ImageCodecFlagsBlockingDecode     = 0x00000020,

    ImageCodecFlagsBuiltin            = 0x00010000,
    ImageCodecFlagsSystem             = 0x00020000,
    ImageCodecFlagsUser               = 0x00040000
};

//---------------------------------------------------------------------------
// Access modes used when calling Image::LockBits
//---------------------------------------------------------------------------

enum ImageLockMode
{
    ImageLockModeRead        = 0x0001,
    ImageLockModeWrite       = 0x0002,
    ImageLockModeUserInputBuf= 0x0004
};

//---------------------------------------------------------------------------
// Information about image pixel data
//---------------------------------------------------------------------------

class BitmapData
{
public:
    UINT Width;
    UINT Height;
    INT Stride;
    PixelFormat PixelFormat;
    VOID* Scan0;
    UINT_PTR Reserved;
};

//---------------------------------------------------------------------------
// Image flags
//---------------------------------------------------------------------------

enum ImageFlags
{
    ImageFlagsNone                = 0,

    // Low-word: shared with SINKFLAG_x

    ImageFlagsScalable            = 0x0001,
    ImageFlagsHasAlpha            = 0x0002,
    ImageFlagsHasTranslucent      = 0x0004,
    ImageFlagsPartiallyScalable   = 0x0008,

    // Low-word: color space definition

    ImageFlagsColorSpaceRGB       = 0x0010,
    ImageFlagsColorSpaceCMYK      = 0x0020,
    ImageFlagsColorSpaceGRAY      = 0x0040,
    ImageFlagsColorSpaceYCBCR     = 0x0080,
    ImageFlagsColorSpaceYCCK      = 0x0100,
 
    // Low-word: image size info

    ImageFlagsHasRealDPI          = 0x1000,
    ImageFlagsHasRealPixelSize    = 0x2000,

    // High-word

    ImageFlagsReadOnly            = 0x00010000,
    ImageFlagsCaching             = 0x00020000
};

enum RotateFlipType
{
    RotateNoneFlipNone = 0,
    Rotate90FlipNone   = 1,
    Rotate180FlipNone  = 2,
    Rotate270FlipNone  = 3,

    RotateNoneFlipX    = 4,
    Rotate90FlipX      = 5,
    Rotate180FlipX     = 6,
    Rotate270FlipX     = 7,

    RotateNoneFlipY    = Rotate180FlipX,
    Rotate90FlipY      = Rotate270FlipX,
    Rotate180FlipY     = RotateNoneFlipX,
    Rotate270FlipY     = Rotate90FlipX,

    RotateNoneFlipXY   = Rotate180FlipNone,
    Rotate90FlipXY     = Rotate270FlipNone,
    Rotate180FlipXY    = RotateNoneFlipNone,
    Rotate270FlipXY    = Rotate90FlipNone
};

//---------------------------------------------------------------------------
// Encoder Parameter structure
//---------------------------------------------------------------------------
class EncoderParameter
{
public:
    GUID    Guid;               // GUID of the parameter
    ULONG   NumberOfValues;     // Number of the parameter values
    ULONG   Type;               // Value type, like ValueTypeLONG  etc.
    VOID*   Value;              // A pointer to the parameter values
};

//---------------------------------------------------------------------------
// Encoder Parameters structure
//---------------------------------------------------------------------------
class EncoderParameters
{
public:
    UINT Count;                      // Number of parameters in this structure
    EncoderParameter Parameter[1];   // Parameter values
};

#if (GDIPVER >= 0x0110)
enum ItemDataPosition
{
    ItemDataPositionAfterHeader    = 0x0,
    ItemDataPositionAfterPalette   = 0x1,
    ItemDataPositionAfterBits      = 0x2,
};

//---------------------------------------------------------------------------
// External Data Item
//---------------------------------------------------------------------------
class ImageItemData
{
public:
    UINT  Size;           // size of the structure 
    UINT  Position;       // flags describing how the data is to be used.
    VOID *Desc;           // description on how the data is to be saved.
                          // it is different for every codec type.
    UINT  DescSize;       // size memory pointed by Desc
    VOID *Data;           // pointer to the data that is to be saved in the
                          // file, could be anything saved directly.
    UINT  DataSize;       // size memory pointed by Data
    UINT  Cookie;         // opaque for the apps data member used during
                          // enumeration of image data items.
};
#endif //(GDIPVER >= 0x0110)

//---------------------------------------------------------------------------
// Property Item
//---------------------------------------------------------------------------
class PropertyItem
{
public:
    PROPID  id;                 // ID of this property
    ULONG   length;             // Length of the property value, in bytes
    WORD    type;               // Type of the value, as one of TAG_TYPE_XXX
                                // defined above
    VOID*   value;              // property value
};

//---------------------------------------------------------------------------
// Image property types 
//---------------------------------------------------------------------------
#define PropertyTagTypeByte        1
#define PropertyTagTypeASCII       2
#define PropertyTagTypeShort       3
#define PropertyTagTypeLong        4
#define PropertyTagTypeRational    5
#define PropertyTagTypeUndefined   7
#define PropertyTagTypeSLONG       9
#define PropertyTagTypeSRational  10

//---------------------------------------------------------------------------
// Image property ID tags
//---------------------------------------------------------------------------

#define PropertyTagExifIFD             0x8769
#define PropertyTagGpsIFD              0x8825

#define PropertyTagNewSubfileType      0x00FE
#define PropertyTagSubfileType         0x00FF
#define PropertyTagImageWidth          0x0100
#define PropertyTagImageHeight         0x0101
#define PropertyTagBitsPerSample       0x0102
#define PropertyTagCompression         0x0103
#define PropertyTagPhotometricInterp   0x0106
#define PropertyTagThreshHolding       0x0107
#define PropertyTagCellWidth           0x0108
#define PropertyTagCellHeight          0x0109
#define PropertyTagFillOrder           0x010A
#define PropertyTagDocumentName        0x010D
#define PropertyTagImageDescription    0x010E
#define PropertyTagEquipMake           0x010F
#define PropertyTagEquipModel          0x0110
#define PropertyTagStripOffsets        0x0111
#define PropertyTagOrientation         0x0112
#define PropertyTagSamplesPerPixel     0x0115
#define PropertyTagRowsPerStrip        0x0116
#define PropertyTagStripBytesCount     0x0117
#define PropertyTagMinSampleValue      0x0118
#define PropertyTagMaxSampleValue      0x0119
#define PropertyTagXResolution         0x011A   // Image resolution in width direction
#define PropertyTagYResolution         0x011B   // Image resolution in height direction
#define PropertyTagPlanarConfig        0x011C   // Image data arrangement
#define PropertyTagPageName            0x011D
#define PropertyTagXPosition           0x011E
#define PropertyTagYPosition           0x011F
#define PropertyTagFreeOffset          0x0120
#define PropertyTagFreeByteCounts      0x0121
#define PropertyTagGrayResponseUnit    0x0122
#define PropertyTagGrayResponseCurve   0x0123
#define PropertyTagT4Option            0x0124
#define PropertyTagT6Option            0x0125
#define PropertyTagResolutionUnit      0x0128   // Unit of X and Y resolution
#define PropertyTagPageNumber          0x0129
#define PropertyTagTransferFuncition   0x012D
#define PropertyTagSoftwareUsed        0x0131
#define PropertyTagDateTime            0x0132
#define PropertyTagArtist              0x013B
#define PropertyTagHostComputer        0x013C
#define PropertyTagPredictor           0x013D
#define PropertyTagWhitePoint          0x013E
#define PropertyTagPrimaryChromaticities 0x013F
#define PropertyTagColorMap            0x0140
#define PropertyTagHalftoneHints       0x0141
#define PropertyTagTileWidth           0x0142
#define PropertyTagTileLength          0x0143
#define PropertyTagTileOffset          0x0144
#define PropertyTagTileByteCounts      0x0145
#define PropertyTagInkSet              0x014C
#define PropertyTagInkNames            0x014D
#define PropertyTagNumberOfInks        0x014E
#define PropertyTagDotRange            0x0150
#define PropertyTagTargetPrinter       0x0151
#define PropertyTagExtraSamples        0x0152
#define PropertyTagSampleFormat        0x0153
#define PropertyTagSMinSampleValue     0x0154
#define PropertyTagSMaxSampleValue     0x0155
#define PropertyTagTransferRange       0x0156

#define PropertyTagJPEGProc            0x0200
#define PropertyTagJPEGInterFormat     0x0201
#define PropertyTagJPEGInterLength     0x0202
#define PropertyTagJPEGRestartInterval 0x0203
#define PropertyTagJPEGLosslessPredictors  0x0205
#define PropertyTagJPEGPointTransforms     0x0206
#define PropertyTagJPEGQTables         0x0207
#define PropertyTagJPEGDCTables        0x0208
#define PropertyTagJPEGACTables        0x0209

#define PropertyTagYCbCrCoefficients   0x0211
#define PropertyTagYCbCrSubsampling    0x0212
#define PropertyTagYCbCrPositioning    0x0213
#define PropertyTagREFBlackWhite       0x0214

#define PropertyTagICCProfile          0x8773   // This TAG is defined by ICC
                                                // for embedded ICC in TIFF
#define PropertyTagGamma               0x0301
#define PropertyTagICCProfileDescriptor 0x0302
#define PropertyTagSRGBRenderingIntent 0x0303

#define PropertyTagImageTitle          0x0320
#define PropertyTagCopyright           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define PropertyTagResolutionXUnit           0x5001
#define PropertyTagResolutionYUnit           0x5002
#define PropertyTagResolutionXLengthUnit     0x5003
#define PropertyTagResolutionYLengthUnit     0x5004
#define PropertyTagPrintFlags                0x5005
#define PropertyTagPrintFlagsVersion         0x5006
#define PropertyTagPrintFlagsCrop            0x5007
#define PropertyTagPrintFlagsBleedWidth      0x5008
#define PropertyTagPrintFlagsBleedWidthScale 0x5009
#define PropertyTagHalftoneLPI               0x500A
#define PropertyTagHalftoneLPIUnit           0x500B
#define PropertyTagHalftoneDegree            0x500C
#define PropertyTagHalftoneShape             0x500D
#define PropertyTagHalftoneMisc              0x500E
#define PropertyTagHalftoneScreen            0x500F
#define PropertyTagJPEGQuality               0x5010
#define PropertyTagGridSize                  0x5011
#define PropertyTagThumbnailFormat           0x5012  // 1 = JPEG, 0 = RAW RGB
#define PropertyTagThumbnailWidth            0x5013
#define PropertyTagThumbnailHeight           0x5014
#define PropertyTagThumbnailColorDepth       0x5015
#define PropertyTagThumbnailPlanes           0x5016
#define PropertyTagThumbnailRawBytes         0x5017
#define PropertyTagThumbnailSize             0x5018
#define PropertyTagThumbnailCompressedSize   0x5019
#define PropertyTagColorTransferFunction     0x501A
#define PropertyTagThumbnailData             0x501B// RAW thumbnail bits in
                                                   // JPEG format or RGB format
                                                   // depends on
                                                   // PropertyTagThumbnailFormat

// Thumbnail related TAGs
                                                
#define PropertyTagThumbnailImageWidth       0x5020  // Thumbnail width
#define PropertyTagThumbnailImageHeight      0x5021  // Thumbnail height
#define PropertyTagThumbnailBitsPerSample    0x5022  // Number of bits per
                                                     // component
#define PropertyTagThumbnailCompression      0x5023  // Compression Scheme
#define PropertyTagThumbnailPhotometricInterp 0x5024 // Pixel composition
#define PropertyTagThumbnailImageDescription 0x5025  // Image Tile
#define PropertyTagThumbnailEquipMake        0x5026  // Manufacturer of Image
                                                     // Input equipment
#define PropertyTagThumbnailEquipModel       0x5027  // Model of Image input
                                                     // equipment
#define PropertyTagThumbnailStripOffsets     0x5028  // Image data location
#define PropertyTagThumbnailOrientation      0x5029  // Orientation of image
#define PropertyTagThumbnailSamplesPerPixel  0x502A  // Number of components
#define PropertyTagThumbnailRowsPerStrip     0x502B  // Number of rows per strip
#define PropertyTagThumbnailStripBytesCount  0x502C  // Bytes per compressed
                                                     // strip
#define PropertyTagThumbnailResolutionX      0x502D  // Resolution in width
                                                     // direction
#define PropertyTagThumbnailResolutionY      0x502E  // Resolution in height
                                                     // direction
#define PropertyTagThumbnailPlanarConfig     0x502F  // Image data arrangement
#define PropertyTagThumbnailResolutionUnit   0x5030  // Unit of X and Y
                                                     // Resolution
#define PropertyTagThumbnailTransferFunction 0x5031  // Transfer function
#define PropertyTagThumbnailSoftwareUsed     0x5032  // Software used
#define PropertyTagThumbnailDateTime         0x5033  // File change date and
                                                     // time
#define PropertyTagThumbnailArtist           0x5034  // Person who created the
                                                     // image
#define PropertyTagThumbnailWhitePoint       0x5035  // White point chromaticity
#define PropertyTagThumbnailPrimaryChromaticities 0x5036 
                                                     // Chromaticities of
                                                     // primaries
#define PropertyTagThumbnailYCbCrCoefficients 0x5037 // Color space transforma-
                                                     // tion coefficients
#define PropertyTagThumbnailYCbCrSubsampling 0x5038  // Subsampling ratio of Y
                                                     // to C
#define PropertyTagThumbnailYCbCrPositioning 0x5039  // Y and C position
#define PropertyTagThumbnailRefBlackWhite    0x503A  // Pair of black and white
                                                     // reference values
#define PropertyTagThumbnailCopyRight        0x503B  // CopyRight holder

#define PropertyTagLuminanceTable            0x5090
#define PropertyTagChrominanceTable          0x5091

#define PropertyTagFrameDelay                0x5100
#define PropertyTagLoopCount                 0x5101

#if (GDIPVER >= 0x0110)
#define PropertyTagGlobalPalette             0x5102
#define PropertyTagIndexBackground           0x5103
#define PropertyTagIndexTransparent          0x5104
#endif //(GDIPVER >= 0x0110)

#define PropertyTagPixelUnit         0x5110  // Unit specifier for pixel/unit
#define PropertyTagPixelPerUnitX     0x5111  // Pixels per unit in X
#define PropertyTagPixelPerUnitY     0x5112  // Pixels per unit in Y
#define PropertyTagPaletteHistogram  0x5113  // Palette histogram

// EXIF specific tag

#define PropertyTagExifExposureTime  0x829A
#define PropertyTagExifFNumber       0x829D

#define PropertyTagExifExposureProg  0x8822
#define PropertyTagExifSpectralSense 0x8824
#define PropertyTagExifISOSpeed      0x8827
#define PropertyTagExifOECF          0x8828

#define PropertyTagExifVer            0x9000
#define PropertyTagExifDTOrig         0x9003 // Date & time of original
#define PropertyTagExifDTDigitized    0x9004 // Date & time of digital data generation

#define PropertyTagExifCompConfig     0x9101
#define PropertyTagExifCompBPP        0x9102

#define PropertyTagExifShutterSpeed   0x9201
#define PropertyTagExifAperture       0x9202
#define PropertyTagExifBrightness     0x9203
#define PropertyTagExifExposureBias   0x9204
#define PropertyTagExifMaxAperture    0x9205
#define PropertyTagExifSubjectDist    0x9206
#define PropertyTagExifMeteringMode   0x9207
#define PropertyTagExifLightSource    0x9208
#define PropertyTagExifFlash          0x9209
#define PropertyTagExifFocalLength    0x920A
#define PropertyTagExifSubjectArea    0x9214  // exif 2.2 Subject Area
#define PropertyTagExifMakerNote      0x927C
#define PropertyTagExifUserComment    0x9286
#define PropertyTagExifDTSubsec       0x9290  // Date & Time subseconds
#define PropertyTagExifDTOrigSS       0x9291  // Date & Time original subseconds
#define PropertyTagExifDTDigSS        0x9292  // Date & TIme digitized subseconds

#define PropertyTagExifFPXVer         0xA000
#define PropertyTagExifColorSpace     0xA001
#define PropertyTagExifPixXDim        0xA002
#define PropertyTagExifPixYDim        0xA003
#define PropertyTagExifRelatedWav     0xA004  // related sound file
#define PropertyTagExifInterop        0xA005
#define PropertyTagExifFlashEnergy    0xA20B
#define PropertyTagExifSpatialFR      0xA20C  // Spatial Frequency Response
#define PropertyTagExifFocalXRes      0xA20E  // Focal Plane X Resolution
#define PropertyTagExifFocalYRes      0xA20F  // Focal Plane Y Resolution
#define PropertyTagExifFocalResUnit   0xA210  // Focal Plane Resolution Unit
#define PropertyTagExifSubjectLoc     0xA214
#define PropertyTagExifExposureIndex  0xA215
#define PropertyTagExifSensingMethod  0xA217
#define PropertyTagExifFileSource     0xA300
#define PropertyTagExifSceneType      0xA301
#define PropertyTagExifCfaPattern     0xA302

// New EXIF 2.2 properties

#define PropertyTagExifCustomRendered           0xA401
#define PropertyTagExifExposureMode             0xA402
#define PropertyTagExifWhiteBalance             0xA403
#define PropertyTagExifDigitalZoomRatio         0xA404
#define PropertyTagExifFocalLengthIn35mmFilm    0xA405
#define PropertyTagExifSceneCaptureType         0xA406
#define PropertyTagExifGainControl              0xA407
#define PropertyTagExifContrast                 0xA408
#define PropertyTagExifSaturation               0xA409
#define PropertyTagExifSharpness                0xA40A
#define PropertyTagExifDeviceSettingDesc        0xA40B
#define PropertyTagExifSubjectDistanceRange     0xA40C
#define PropertyTagExifUniqueImageID            0xA420


#define PropertyTagGpsVer             0x0000
#define PropertyTagGpsLatitudeRef     0x0001
#define PropertyTagGpsLatitude        0x0002
#define PropertyTagGpsLongitudeRef    0x0003
#define PropertyTagGpsLongitude       0x0004
#define PropertyTagGpsAltitudeRef     0x0005
#define PropertyTagGpsAltitude        0x0006
#define PropertyTagGpsGpsTime         0x0007
#define PropertyTagGpsGpsSatellites   0x0008
#define PropertyTagGpsGpsStatus       0x0009
#define PropertyTagGpsGpsMeasureMode  0x00A
#define PropertyTagGpsGpsDop          0x000B  // Measurement precision
#define PropertyTagGpsSpeedRef        0x000C
#define PropertyTagGpsSpeed           0x000D
#define PropertyTagGpsTrackRef        0x000E
#define PropertyTagGpsTrack           0x000F
#define PropertyTagGpsImgDirRef       0x0010
#define PropertyTagGpsImgDir          0x0011
#define PropertyTagGpsMapDatum        0x0012
#define PropertyTagGpsDestLatRef      0x0013
#define PropertyTagGpsDestLat         0x0014
#define PropertyTagGpsDestLongRef     0x0015
#define PropertyTagGpsDestLong        0x0016
#define PropertyTagGpsDestBearRef     0x0017
#define PropertyTagGpsDestBear        0x0018
#define PropertyTagGpsDestDistRef     0x0019
#define PropertyTagGpsDestDist        0x001A
#define PropertyTagGpsProcessingMethod 0x001B
#define PropertyTagGpsAreaInformation 0x001C
#define PropertyTagGpsDate            0x001D
#define PropertyTagGpsDifferential    0x001E

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusPixelFormats.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus Pixel Formats
*
* Abstract:
*
*   GDI+ Pixel Formats
*
\**************************************************************************/

#ifndef _GDIPLUSPIXELFORMATS_H
#define _GDIPLUSPIXELFORMATS_H

typedef DWORD ARGB;
typedef DWORDLONG ARGB64;

#define ALPHA_SHIFT 24
#define RED_SHIFT   16
#define GREEN_SHIFT 8
#define BLUE_SHIFT  0
#define ALPHA_MASK  ((ARGB) 0xff << ALPHA_SHIFT)

// In-memory pixel data formats:
// bits 0-7 = format index
// bits 8-15 = pixel size (in bits)
// bits 16-23 = flags
// bits 24-31 = reserved

typedef INT PixelFormat;

#define    PixelFormatIndexed      0x00010000 // Indexes into a palette
#define    PixelFormatGDI          0x00020000 // Is a GDI-supported format
#define    PixelFormatAlpha        0x00040000 // Has an alpha component
#define    PixelFormatPAlpha       0x00080000 // Pre-multiplied alpha
#define    PixelFormatExtended     0x00100000 // Extended color 16 bits/channel
#define    PixelFormatCanonical    0x00200000 

#define    PixelFormatUndefined       0
#define    PixelFormatDontCare        0

#define    PixelFormat1bppIndexed     (1 | ( 1 << 8) | PixelFormatIndexed | PixelFormatGDI)
#define    PixelFormat4bppIndexed     (2 | ( 4 << 8) | PixelFormatIndexed | PixelFormatGDI)
#define    PixelFormat8bppIndexed     (3 | ( 8 << 8) | PixelFormatIndexed | PixelFormatGDI)
#define    PixelFormat16bppGrayScale  (4 | (16 << 8) | PixelFormatExtended)
#define    PixelFormat16bppRGB555     (5 | (16 << 8) | PixelFormatGDI)
#define    PixelFormat16bppRGB565     (6 | (16 << 8) | PixelFormatGDI)
#define    PixelFormat16bppARGB1555   (7 | (16 << 8) | PixelFormatAlpha | PixelFormatGDI)
#define    PixelFormat24bppRGB        (8 | (24 << 8) | PixelFormatGDI)
#define    PixelFormat32bppRGB        (9 | (32 << 8) | PixelFormatGDI)
#define    PixelFormat32bppARGB       (10 | (32 << 8) | PixelFormatAlpha | PixelFormatGDI | PixelFormatCanonical)
#define    PixelFormat32bppPARGB      (11 | (32 << 8) | PixelFormatAlpha | PixelFormatPAlpha | PixelFormatGDI)
#define    PixelFormat48bppRGB        (12 | (48 << 8) | PixelFormatExtended)
#define    PixelFormat64bppARGB       (13 | (64 << 8) | PixelFormatAlpha  | PixelFormatCanonical | PixelFormatExtended)
#define    PixelFormat64bppPARGB      (14 | (64 << 8) | PixelFormatAlpha  | PixelFormatPAlpha | PixelFormatExtended)
#define    PixelFormat32bppCMYK       (15 | (32 << 8))
#define    PixelFormatMax             16

inline UINT
GetPixelFormatSize(PixelFormat pixfmt)
{
    return (pixfmt >> 8) & 0xff;
}

inline BOOL
IsIndexedPixelFormat(PixelFormat pixfmt)
{
    return (pixfmt & PixelFormatIndexed) != 0;
}

inline BOOL
IsAlphaPixelFormat(PixelFormat pixfmt)
{
   return (pixfmt & PixelFormatAlpha) != 0;
}

inline BOOL
IsExtendedPixelFormat(PixelFormat pixfmt)
{
   return (pixfmt & PixelFormatExtended) != 0;
}

//--------------------------------------------------------------------------
// Determine if the Pixel Format is Canonical format:
//   PixelFormat32bppARGB
//   PixelFormat32bppPARGB
//   PixelFormat64bppARGB
//   PixelFormat64bppPARGB
//--------------------------------------------------------------------------

inline BOOL
IsCanonicalPixelFormat(PixelFormat pixfmt)
{
   return (pixfmt & PixelFormatCanonical) != 0;
}

#if (GDIPVER >= 0x0110)
//----------------------------------------------------------------------------
// Color format conversion parameters
//----------------------------------------------------------------------------

enum PaletteType
{
    // Arbitrary custom palette provided by caller.
    
    PaletteTypeCustom           = 0,
    
    // Optimal palette generated using a median-cut algorithm.
    
    PaletteTypeOptimal        = 1,
    
    // Black and white palette.
    
    PaletteTypeFixedBW          = 2,
    
    // Symmetric halftone palettes.
    // Each of these halftone palettes will be a superset of the system palette.
    // E.g. Halftone8 will have it's 8-color on-off primaries and the 16 system
    // colors added. With duplicates removed, that leaves 16 colors.
    
    PaletteTypeFixedHalftone8   = 3, // 8-color, on-off primaries
    PaletteTypeFixedHalftone27  = 4, // 3 intensity levels of each color
    PaletteTypeFixedHalftone64  = 5, // 4 intensity levels of each color
    PaletteTypeFixedHalftone125 = 6, // 5 intensity levels of each color
    PaletteTypeFixedHalftone216 = 7, // 6 intensity levels of each color

    // Assymetric halftone palettes.
    // These are somewhat less useful than the symmetric ones, but are 
    // included for completeness. These do not include all of the system
    // colors.
    
    PaletteTypeFixedHalftone252 = 8, // 6-red, 7-green, 6-blue intensities
    PaletteTypeFixedHalftone256 = 9, // 8-red, 8-green, 4-blue intensities
};

enum DitherType
{
    DitherTypeNone          = 0,
    
    // Solid color - picks the nearest matching color with no attempt to 
    // halftone or dither. May be used on an arbitrary palette.
    
    DitherTypeSolid         = 1,
    
    // Ordered dithers and spiral dithers must be used with a fixed palette.
    
    // NOTE: DitherOrdered4x4 is unique in that it may apply to 16bpp 
    // conversions also.
    
    DitherTypeOrdered4x4    = 2,
    
    DitherTypeOrdered8x8    = 3,
    DitherTypeOrdered16x16  = 4,
    DitherTypeSpiral4x4     = 5,
    DitherTypeSpiral8x8     = 6,
    DitherTypeDualSpiral4x4 = 7,
    DitherTypeDualSpiral8x8 = 8,
    
    // Error diffusion. May be used with any palette.
    
    DitherTypeErrorDiffusion   = 9,

    DitherTypeMax              = 10
};
#endif //(GDIPVER >= 0x0110)

enum PaletteFlags
{
    PaletteFlagsHasAlpha    = 0x0001,
    PaletteFlagsGrayScale   = 0x0002,
    PaletteFlagsHalftone    = 0x0004
};

struct ColorPalette
{

public:

    UINT Flags;             // Palette flags
    UINT Count;             // Number of color entries
    ARGB Entries[1];        // Palette color entries
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusHeaders.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusHeaders.h
*
* Abstract:
*
*   GDI+ Region, Font, Image, CustomLineCap class definitions.
*
*
* Class definition and inline class implementation are separated into
* different files to avoid circular dependencies.
*
\**************************************************************************/

#ifndef _GDIPLUSHEADERS_H
#define _GDIPLUSHEADERS_H

class Region : public GdiplusBase
{
public:
    friend class Graphics;

    Region();
    Region(IN const RectF& rect);
    Region(IN const Rect& rect);
    Region(IN const GraphicsPath* path);
    Region(IN const BYTE* regionData, IN INT size);
    Region(IN HRGN hRgn);
    static Region* FromHRGN(IN HRGN hRgn);

    ~Region();
    Region* Clone() const;

    Status MakeInfinite();
    Status MakeEmpty();

    UINT GetDataSize() const;

    // buffer     - where to put the data
    // bufferSize - how big the buffer is (should be at least as big as GetDataSize())
    // sizeFilled - if not NULL, this is an OUT param that says how many bytes
    //              of data were written to the buffer.

    Status GetData(OUT BYTE* buffer,
                   IN UINT bufferSize,
                   OUT UINT* sizeFilled = NULL) const;

    Status Intersect(IN const Rect& rect);
    Status Intersect(IN const RectF& rect);
    Status Intersect(IN const GraphicsPath* path);
    Status Intersect(IN const Region* region);
    Status Union(IN const Rect& rect);
    Status Union(IN const RectF& rect);
    Status Union(IN const GraphicsPath* path);
    Status Union(IN const Region* region);
    Status Xor(IN const Rect& rect);
    Status Xor(IN const RectF& rect);
    Status Xor(IN const GraphicsPath* path);
    Status Xor(IN const Region* region);
    Status Exclude(IN const Rect& rect);
    Status Exclude(IN const RectF& rect);
    Status Exclude(IN const GraphicsPath* path);
    Status Exclude(IN const Region* region);
    Status Complement(IN const Rect& rect);
    Status Complement(IN const RectF& rect);
    Status Complement(IN const GraphicsPath* path);
    Status Complement(IN const Region* region);
    Status Translate(IN REAL dx,
                     IN REAL dy);
    Status Translate(IN INT dx,
                     IN INT dy);
    Status Transform(IN const Matrix* matrix);

    Status GetBounds(OUT Rect* rect,
                     IN const Graphics* g) const;

    Status GetBounds(OUT RectF* rect,
                     IN const Graphics* g) const;

    HRGN   GetHRGN  (IN const Graphics * g) const;

    BOOL IsEmpty(IN const Graphics *g) const;
    BOOL IsInfinite(IN const Graphics *g) const;

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(Point(x, y), g);
    }

    BOOL IsVisible(IN const Point& point,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(PointF(x, y), g);
    }

    BOOL IsVisible(IN const PointF& point,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN const Graphics* g) const
    {
        return IsVisible(Rect(x, y, width, height), g);
    }

    BOOL IsVisible(IN const Rect& rect,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(RectF(x, y, width, height), g);
    }

    BOOL IsVisible(IN const RectF& rect,
                   IN const Graphics* g = NULL) const;

    BOOL Equals(IN const Region* region,
                IN const Graphics* g) const;

    UINT GetRegionScansCount(IN const Matrix* matrix) const;
    Status GetRegionScans(IN const Matrix* matrix,
                          OUT RectF* rects,
                          OUT INT* count) const;
    Status GetRegionScans(IN const Matrix* matrix,
                          OUT Rect*  rects,
                          OUT INT* count) const;
    Status GetLastStatus() const;

protected:

private:
    Region(const Region &region);
    Region& operator=(const Region &region);
protected:

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    Region(GpRegion* nativeRegion);

    VOID SetNativeRegion(GpRegion* nativeRegion);

protected:
    GpRegion* nativeRegion;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// FontFamily
//--------------------------------------------------------------------------

class FontFamily : public GdiplusBase
{
public:
    friend class Font;
    friend class Graphics;
    friend class GraphicsPath;
    friend class FontCollection;

    FontFamily();

    FontFamily(
        IN const WCHAR          *name,
        IN const FontCollection *fontCollection = NULL
    );

    ~FontFamily();

    static const FontFamily *GenericSansSerif();
    static const FontFamily *GenericSerif();
    static const FontFamily *GenericMonospace();

    Status GetFamilyName(
        __out_ecount(LF_FACESIZE) LPWSTR    name,
        IN LANGID                           language = 0
    ) const;

    FontFamily * Clone() const;

    BOOL    IsAvailable() const
    {
        return (nativeFamily != NULL);
    };

    BOOL    IsStyleAvailable(IN INT style) const;

    UINT16  GetEmHeight     (IN INT style) const;
    UINT16  GetCellAscent   (IN INT style) const;
    UINT16  GetCellDescent  (IN INT style) const;
    UINT16  GetLineSpacing  (IN INT style) const;
    
    Status GetLastStatus() const;

private:
    FontFamily(const FontFamily &);
    FontFamily& operator=(const FontFamily &);

protected:
    Status SetStatus(Status status) const;

    FontFamily(GpFontFamily * nativeFamily, Status status);

protected:

    GpFontFamily    *nativeFamily;
    mutable Status   lastResult;
};

static FontFamily *GenericSansSerifFontFamily = NULL;
static FontFamily *GenericSerifFontFamily     = NULL;
static FontFamily *GenericMonospaceFontFamily = NULL;

static BYTE GenericSansSerifFontFamilyBuffer[sizeof(FontFamily)] = {0};
static BYTE GenericSerifFontFamilyBuffer    [sizeof(FontFamily)] = {0};
static BYTE GenericMonospaceFontFamilyBuffer[sizeof(FontFamily)] = {0};


//--------------------------------------------------------------------------
// Font
//--------------------------------------------------------------------------

class Font : public GdiplusBase
{
public:
    friend class Graphics;

    Font(IN HDC hdc);
    Font(IN HDC hdc,
         IN const LOGFONTA* logfont);
    Font(IN HDC hdc,
         IN const LOGFONTW* logfont);
    Font(IN HDC hdc,
         IN const HFONT hfont);
    Font(
        IN const FontFamily * family,
        IN REAL         emSize,
        IN INT          style   = FontStyleRegular,
        IN Unit         unit    = UnitPoint
    );

    Font(
        IN const WCHAR *           familyName,
        IN REAL                    emSize,
        IN INT                     style   = FontStyleRegular,
        IN Unit                    unit    = UnitPoint,
        IN const FontCollection *  fontCollection = NULL
    );

    Status GetLogFontA(IN const Graphics* g,
                       OUT  LOGFONTA * logfontA) const;
    Status GetLogFontW(IN const Graphics* g,
                       OUT LOGFONTW * logfontW) const;

    Font* Clone() const;
    ~Font();
    BOOL        IsAvailable()   const;
    INT         GetStyle()      const;
    REAL        GetSize()       const;
    Unit        GetUnit()       const;
    Status      GetLastStatus() const;
    REAL        GetHeight(IN const Graphics *graphics) const;
    REAL        GetHeight(IN REAL dpi) const;

    Status GetFamily(OUT FontFamily *family) const;

private:
    Font(const Font &);
    Font& operator=(const Font &);

protected:
    Font(GpFont* font, Status status);
    VOID SetNativeFont(GpFont *Font);
    Status SetStatus(Status status) const;

protected:

    GpFont* nativeFont;
    mutable Status lastResult;
};

//--------------------------------------------------------------------------
// Font Collection
//--------------------------------------------------------------------------

class FontCollection : public GdiplusBase
{
public:
    friend class FontFamily;

    FontCollection();
    virtual ~FontCollection();

    INT GetFamilyCount() const;

    Status GetFamilies(
        IN INT           numSought,
        OUT FontFamily * gpfamilies,
        OUT INT        * numFound
    ) const;

    Status GetLastStatus() const;

private:
    FontCollection(const FontCollection &);
    FontCollection& operator=(const FontCollection &);

protected:
    Status SetStatus(Status status) const ;

    GpFontCollection *nativeFontCollection;
    mutable Status    lastResult;
};


class InstalledFontCollection : public FontCollection
{
public:
    InstalledFontCollection();
    ~InstalledFontCollection();

private:
    InstalledFontCollection(const InstalledFontCollection &);
    InstalledFontCollection& operator=(const InstalledFontCollection &);

protected:
    Status SetStatus(Status status) const ;
};


class PrivateFontCollection : public FontCollection
{
public:
    PrivateFontCollection();
    ~PrivateFontCollection();

    Status AddFontFile(IN const WCHAR* filename);
    Status AddMemoryFont(IN const VOID* memory,
                         IN INT length);

private:
    PrivateFontCollection(const PrivateFontCollection &);
    PrivateFontCollection& operator=(const PrivateFontCollection &);
};


//--------------------------------------------------------------------------
// Abstract base class for Image and Metafile
//--------------------------------------------------------------------------

class Image : public GdiplusBase
{
public:
    friend class Brush;
    friend class TextureBrush;
    friend class Graphics;

    Image(
        IN const WCHAR* filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    Image(
        IN IStream* stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    static Image* FromFile(
        IN const WCHAR* filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    static Image* FromStream(
        IN IStream* stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    virtual ~Image();
    virtual Image* Clone();

    Status Save(IN const WCHAR* filename,
                IN const CLSID* clsidEncoder,
                IN const EncoderParameters *encoderParams = NULL);
    Status Save(IN IStream* stream,
                IN const CLSID* clsidEncoder,
                IN const EncoderParameters *encoderParams = NULL);
    Status SaveAdd(IN const EncoderParameters* encoderParams);
    Status SaveAdd(IN Image* newImage,
                   IN const EncoderParameters* encoderParams);

    ImageType GetType() const;
    Status GetPhysicalDimension(OUT SizeF* size);
    Status GetBounds(OUT RectF* srcRect,
                     OUT Unit* srcUnit);

    UINT GetWidth();
    UINT GetHeight();
    REAL GetHorizontalResolution();
    REAL GetVerticalResolution();
    UINT GetFlags();
    Status GetRawFormat(OUT GUID *format);
    PixelFormat GetPixelFormat();

    INT GetPaletteSize();
    Status GetPalette(OUT ColorPalette* palette,
                      IN INT size);
    Status SetPalette(IN const ColorPalette* palette);

    Image* GetThumbnailImage(IN UINT thumbWidth,
                             IN UINT thumbHeight,
                             IN GetThumbnailImageAbort callback = NULL,
                             IN VOID* callbackData = NULL);
    UINT GetFrameDimensionsCount();
    Status GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                  IN UINT count);
    UINT GetFrameCount(IN const GUID* dimensionID);
    Status SelectActiveFrame(IN const GUID* dimensionID,
                             IN UINT frameIndex);
    Status RotateFlip(IN RotateFlipType rotateFlipType);
    UINT GetPropertyCount();
    Status GetPropertyIdList(IN UINT numOfProperty,
                             OUT PROPID* list);
    UINT GetPropertyItemSize(IN PROPID propId);
    Status GetPropertyItem(IN PROPID propId,
                           IN UINT propSize,
                           OUT PropertyItem* buffer);
    Status GetPropertySize(OUT UINT* totalBufferSize,
                           OUT UINT* numProperties);
    Status GetAllPropertyItems(IN UINT totalBufferSize,
                               IN UINT numProperties,
                               OUT PropertyItem* allItems);
    Status RemovePropertyItem(IN PROPID propId);
    Status SetPropertyItem(IN const PropertyItem* item);

    UINT  GetEncoderParameterListSize(IN const CLSID* clsidEncoder);
    Status GetEncoderParameterList(IN const CLSID* clsidEncoder,
                                   IN UINT size,
                                   OUT EncoderParameters* buffer);
#if (GDIPVER >= 0x0110)
    Status FindFirstItem(IN ImageItemData *item);
    Status FindNextItem(IN ImageItemData *item);
    Status GetItemData(IN ImageItemData *item);
    Status SetAbort(GdiplusAbort *pIAbort);
#endif //(GDIPVER >= 0x0110)

    Status GetLastStatus() const;

protected:

    Image() {}

    Image(GpImage *nativeImage, Status status);

    VOID SetNativeImage(GpImage* nativeImage);

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpImage* nativeImage;
    mutable Status lastResult;
    mutable Status loadStatus;

private:
    Image(IN const Image& C);
    Image& operator=(IN const Image& C);
};

class Bitmap : public Image
{
public:
    friend class Image;
    friend class CachedBitmap;

    Bitmap(
        IN const WCHAR *filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    Bitmap(
        IN IStream *stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    static Bitmap* FromFile(
        IN const WCHAR *filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    static Bitmap* FromStream(
        IN IStream *stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    Bitmap(IN INT width,
           IN INT height,
           IN INT stride, PixelFormat format,
           IN BYTE* scan0);
    Bitmap(IN INT width,
           IN INT height,
           IN PixelFormat format = PixelFormat32bppARGB);
    Bitmap(IN INT width,
           IN INT height,
           IN  Graphics* target);

    Bitmap* Clone(IN const Rect& rect,
                  IN PixelFormat format);
    Bitmap* Clone(IN INT x,
                  IN INT y,
                  IN INT width,
                  IN INT height,
                  IN PixelFormat format);
    Bitmap* Clone(IN const RectF& rect,
                  IN PixelFormat format);
    Bitmap* Clone(IN REAL x,
                  IN REAL y,
                  IN REAL width,
                  IN REAL height,
                  IN PixelFormat format);

    Status LockBits(IN const Rect* rect,
                    IN UINT flags,
                    IN PixelFormat format,
                    OUT BitmapData* lockedBitmapData);
    Status UnlockBits(IN BitmapData* lockedBitmapData);
    Status GetPixel(IN INT x,
                    IN INT y,
                    OUT Color *color);
    Status SetPixel(IN INT x,
                    IN INT y,
                    IN const Color &color);
    
#if (GDIPVER >= 0x0110)
    Status ConvertFormat(
        PixelFormat format,
        DitherType dithertype,
        PaletteType palettetype,
        ColorPalette *palette,
        REAL alphaThresholdPercent
        );
    
    // The palette must be allocated and count must be set to the number of
    // entries in the palette. If there are not enough, the API will fail.
    
    static Status InitializePalette(
        IN OUT ColorPalette *palette,  // Palette to initialize.
        PaletteType palettetype,       // palette enumeration type.
        INT optimalColors,             // how many optimal colors
        BOOL useTransparentColor,      // add a transparent color to the palette.
        Bitmap *bitmap                 // optional bitmap for median cut.
        );
        
    Status ApplyEffect(Effect *effect, RECT *ROI);
    
    static Status 
    ApplyEffect(
        IN  Bitmap **inputs,
        IN  INT numInputs,
        IN  Effect *effect, 
        IN  RECT *ROI,           // optional parameter.
        OUT RECT *outputRect,    // optional parameter.
        OUT Bitmap **output
    );
    
    Status GetHistogram(
        IN HistogramFormat format,
        IN UINT NumberOfEntries,
        __out_bcount(sizeof(UINT)*256) UINT *channel0,
        __out_bcount(sizeof(UINT)*256) UINT *channel1,
        __out_bcount(sizeof(UINT)*256) UINT *channel2,
        __out_bcount(sizeof(UINT)*256) UINT *channel3
    );
    
    static Status GetHistogramSize(
        IN HistogramFormat format,
        OUT UINT *NumberOfEntries
    );
#endif //(GDIPVER >= 0x0110)
    
    Status SetResolution(IN REAL xdpi,
                         IN REAL ydpi);

    Bitmap(IN IDirectDrawSurface7* surface);
    Bitmap(IN const BITMAPINFO* gdiBitmapInfo,
           IN VOID* gdiBitmapData);
    Bitmap(IN HBITMAP hbm,
           IN HPALETTE hpal);
    Bitmap(IN HICON hicon);
    Bitmap(IN HINSTANCE hInstance,
           IN const WCHAR * bitmapName);
    static Bitmap* FromDirectDrawSurface7(IN IDirectDrawSurface7* surface);
    static Bitmap* FromBITMAPINFO(IN const BITMAPINFO* gdiBitmapInfo,
                                  IN VOID* gdiBitmapData);
    static Bitmap* FromHBITMAP(IN HBITMAP hbm,
                               IN HPALETTE hpal);
    static Bitmap* FromHICON(IN HICON hicon);
    static Bitmap* FromResource(IN HINSTANCE hInstance,
                                IN const WCHAR * bitmapName);

    Status GetHBITMAP(IN const Color& colorBackground,
                      OUT HBITMAP *hbmReturn);
    Status GetHICON(HICON *hicon);

private:
    Bitmap(const Bitmap &);
    Bitmap& operator=(const Bitmap &);

protected:
    Bitmap(GpBitmap *nativeBitmap);
};

class CustomLineCap : public GdiplusBase
{
public:
    friend class Pen;

    CustomLineCap(
        IN const GraphicsPath* fillPath,
        IN const GraphicsPath* strokePath,
        IN LineCap baseCap = LineCapFlat,
        IN REAL baseInset = 0
        );
    virtual ~CustomLineCap();

    CustomLineCap* Clone() const;

    // This changes both the start and end cap.

    Status SetStrokeCap(IN LineCap strokeCap)
    {
        return SetStrokeCaps(strokeCap, strokeCap);
    }

    Status SetStrokeCaps(IN LineCap startCap,
                         IN LineCap endCap);
    Status GetStrokeCaps(OUT LineCap* startCap,
                         OUT LineCap* endCap) const;
    Status SetStrokeJoin(IN LineJoin lineJoin);
    LineJoin GetStrokeJoin() const;
    Status SetBaseCap(IN LineCap baseCap);
    LineCap GetBaseCap() const;
    Status SetBaseInset(IN REAL inset);
    REAL GetBaseInset() const;
    Status SetWidthScale(IN REAL widthScale);
    REAL GetWidthScale() const;
    Status GetLastStatus() const;

protected:
    CustomLineCap();

private:
    CustomLineCap(const CustomLineCap &);
    CustomLineCap& operator=(const CustomLineCap &);

protected:
    CustomLineCap(GpCustomLineCap* nativeCap, Status status)
    {
        lastResult = status;
        SetNativeCap(nativeCap);
    }

    VOID SetNativeCap(GpCustomLineCap* nativeCap)
    {
        this->nativeCap = nativeCap;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpCustomLineCap* nativeCap;
    mutable Status lastResult;
};

class CachedBitmap : public GdiplusBase
{
    friend Graphics;

public:
    CachedBitmap(IN Bitmap *bitmap,
                 IN Graphics *graphics);
    virtual ~CachedBitmap();

    Status GetLastStatus() const;

private:
    CachedBitmap(const CachedBitmap &);
    CachedBitmap& operator=(const CachedBitmap &);

protected:
    GpCachedBitmap *nativeCachedBitmap;
    mutable Status lastResult;
};

class Metafile : public Image
{
public:
    friend class Image;

    // Playback a metafile from a HMETAFILE
    // If deleteWmf is TRUE, then when the metafile is deleted,
    // the hWmf will also be deleted.  Otherwise, it won't be.
    
    Metafile(
        IN HMETAFILE                      hWmf,
        IN const WmfPlaceableFileHeader * wmfPlaceableFileHeader,
        IN BOOL                           deleteWmf = FALSE
        );

    // Playback a metafile from a HENHMETAFILE
    // If deleteEmf is TRUE, then when the metafile is deleted,
    // the hEmf will also be deleted.  Otherwise, it won't be.
    
    Metafile(
        IN HENHMETAFILE hEmf,
        IN BOOL deleteEmf = FALSE
        );
    
    Metafile(IN const WCHAR* filename);

    // Playback a WMF metafile from a file.

    Metafile(
        IN const WCHAR*                   filename,
        IN const WmfPlaceableFileHeader * wmfPlaceableFileHeader
        );

    Metafile(IN IStream* stream);

    // Record a metafile to memory.

    Metafile(
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        );

    // Record a metafile to memory.

    Metafile(
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        );

    // Record a metafile to memory.

    Metafile(
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        );

    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        );

    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        );

    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        );

    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        );

    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        );

    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        );

    static Status GetMetafileHeader(
        IN HMETAFILE                       hWmf,
        IN const WmfPlaceableFileHeader *  wmfPlaceableFileHeader,
        OUT MetafileHeader *               header
        );

    static Status GetMetafileHeader(
        IN HENHMETAFILE        hEmf,
        OUT MetafileHeader *   header
        );

    static Status GetMetafileHeader(
        IN const WCHAR*        filename,
        OUT MetafileHeader *   header
        );

    static Status GetMetafileHeader(
        IN IStream *           stream,
        OUT MetafileHeader *   header
        );

    Status GetMetafileHeader(
        OUT MetafileHeader *    header
        ) const;

    // Once this method is called, the Metafile object is in an invalid state
    // and can no longer be used.  It is the responsiblity of the caller to
    // invoke DeleteEnhMetaFile to delete this hEmf.

    HENHMETAFILE GetHENHMETAFILE();

    // Used in conjuction with Graphics::EnumerateMetafile to play an EMF+
    // The data must be DWORD aligned if it's an EMF or EMF+.  It must be
    // WORD aligned if it's a WMF.
    
    Status PlayRecord(
        IN EmfPlusRecordType   recordType,
        IN UINT                flags,
        IN UINT                dataSize,
        IN const BYTE *        data
        ) const;

    // If you're using a printer HDC for the metafile, but you want the
    // metafile rasterized at screen resolution, then use this API to set
    // the rasterization dpi of the metafile to the screen resolution,
    // e.g. 96 dpi or 120 dpi.
    
    Status SetDownLevelRasterizationLimit(
        IN UINT     metafileRasterizationLimitDpi
        );

    UINT GetDownLevelRasterizationLimit() const;

    static UINT Metafile::EmfToWmfBits(
        IN HENHMETAFILE       hemf,
        IN UINT               cbData16,     
        OUT LPBYTE            pData16,
        IN INT                iMapMode = MM_ANISOTROPIC,
        IN INT                eFlags = EmfToWmfBitsFlagsDefault
    );

#if (GDIPVER >= 0x0110)
    Status ConvertToEmfPlus(
        IN const Graphics* refGraphics,
        IN OUT INT* conversionFailureFlag = NULL,
        IN EmfType emfType = EmfTypeEmfPlusOnly,
        IN const WCHAR* description = NULL
    );
    Status ConvertToEmfPlus(
        IN const Graphics* refGraphics,
        IN const WCHAR* filename, 
        IN OUT INT* conversionFailureFlag = NULL,
        IN EmfType emfType = EmfTypeEmfPlusOnly,
        IN const WCHAR* description = NULL
    );
    Status ConvertToEmfPlus(
        IN const Graphics* refGraphics,
        IN IStream* stream, 
        IN OUT INT* conversionFailureFlag = NULL,
        IN EmfType emfType = EmfTypeEmfPlusOnly,
        IN const WCHAR* description = NULL
    );
#endif

protected:
    Metafile()
    {
        SetNativeImage(NULL);
        lastResult = Ok;
    }

private:
    Metafile(const Metafile &);
    Metafile& operator=(const Metafile &);
};


#endif  // !_GDIPLUSHEADERS.HPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusPath.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusPath.h
*
* Abstract:
*
*   GDI+ Graphics Path class
*
\**************************************************************************/

#ifndef _GDIPLUSPATH_H
#define _GDIPLUSPATH_H

class GraphicsPath : public GdiplusBase
{
public:
    friend class Graphics;
    friend class Region;
    friend class PathGradientBrush;
    friend class GraphicsPathIterator;
    friend class CustomLineCap;

    GraphicsPath(IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath(fillMode, &nativePath);
    }

    GraphicsPath(IN const PointF* points,
                 IN const BYTE* types,
                 IN INT count,
                 IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath2(points,
                                                 types,
                                                 count,
                                                 fillMode,
                                                 &nativePath);
    }

    GraphicsPath(IN const Point* points,
                 IN const BYTE* types,
                 IN INT count,
                 IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath2I(points,
                                                  types,
                                                  count,
                                                  fillMode,
                                                  &nativePath);
    }

    ~GraphicsPath()
    {
        DllExports::GdipDeletePath(nativePath);
    }

    GraphicsPath* Clone() const
    {
        GpPath *clonepath = NULL;

        SetStatus(DllExports::GdipClonePath(nativePath, &clonepath));

        return new GraphicsPath(clonepath);
    }

    // Reset the path object to empty (and fill mode to FillModeAlternate)

    Status Reset()
    {
        return SetStatus(DllExports::GdipResetPath(nativePath));
    }

    FillMode GetFillMode() const
    {
        FillMode fillmode = FillModeAlternate;

        SetStatus(DllExports::GdipGetPathFillMode(nativePath, &fillmode));

        return fillmode;
    }

    Status SetFillMode(IN FillMode fillmode)
    {
        return SetStatus(DllExports::GdipSetPathFillMode(nativePath, 
                                                         fillmode));
    }

    Status GetPathData(OUT PathData* pathData) const
    {
        if (pathData == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        INT count = GetPointCount();
        
        if ((count <= 0) || (pathData->Count>0 && pathData->Count<count))
        {
            pathData->Count = 0;
            if (pathData->Points)
            {
                delete [] pathData->Points;
                pathData->Points = NULL;
            }

            if (pathData->Types) 
            {
                delete [] pathData->Types;
                pathData->Types = NULL;
            }

            if (count <= 0)
            {
                return Ok;
            }
        }

        if (pathData->Count == 0) 
        {
            pathData->Points = new PointF[count];
            if (pathData->Points == NULL) 
            {
                return SetStatus(OutOfMemory);
            
            }
            pathData->Types = new byte[count];
            if (pathData->Types == NULL) 
            {
                delete [] pathData->Points;
                pathData->Points = NULL;

                return SetStatus(OutOfMemory);
            }
            pathData->Count = count;
        }

        return SetStatus(DllExports::GdipGetPathData(nativePath, pathData));
    }

    Status StartFigure()
    {
        return SetStatus(DllExports::GdipStartPathFigure(nativePath));
    }

    Status CloseFigure()
    {
        return SetStatus(DllExports::GdipClosePathFigure(nativePath));
    }

    Status CloseAllFigures()
    {
        return SetStatus(DllExports::GdipClosePathFigures(nativePath));
    }

    Status SetMarker()
    {
        return SetStatus(DllExports::GdipSetPathMarker(nativePath));
    }

    Status ClearMarkers()
    {
        return SetStatus(DllExports::GdipClearPathMarkers(nativePath));
    }

    Status Reverse()
    {
        return SetStatus(DllExports::GdipReversePath(nativePath));
    }

    Status GetLastPoint(OUT PointF* lastPoint) const
    {
        return SetStatus(DllExports::GdipGetPathLastPoint(nativePath, 
                                                          lastPoint));
    }

    Status AddLine(IN const PointF& pt1, 
                   IN const PointF& pt2)
    {
        return AddLine(pt1.X, pt1.Y, pt2.X, pt2.Y);
    }

    Status AddLine(IN REAL x1,
                   IN REAL y1, 
                   IN REAL x2, 
                   IN REAL y2)
    {
        return SetStatus(DllExports::GdipAddPathLine(nativePath, x1, y1, 
                                                     x2, y2));
    }

    Status AddLines(IN const PointF* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathLine2(nativePath, points, 
                                                      count));
    }

    Status AddLine(IN const Point& pt1, 
                   IN const Point& pt2)
    {
        return AddLine(pt1.X,
                       pt1.Y,
                       pt2.X,
                       pt2.Y);
    }

    Status AddLine(IN INT x1, 
                   IN INT y1, 
                   IN INT x2, 
                   IN INT y2)
    {
        return SetStatus(DllExports::GdipAddPathLineI(nativePath,
                                                     x1,
                                                     y1,
                                                     x2,
                                                     y2));
    }

    Status AddLines(IN const Point* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathLine2I(nativePath,
                                                       points,
                                                       count));
    }

    Status AddArc(IN const RectF& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddArc(rect.X, rect.Y, rect.Width, rect.Height,
                      startAngle, sweepAngle);
    }

    Status AddArc(IN REAL x, 
                  IN REAL y, 
                  IN REAL width, 
                  IN REAL height,
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathArc(nativePath, x, y, width, 
                                                    height, startAngle, 
                                                    sweepAngle));
    }

    Status AddArc(IN const Rect& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddArc(rect.X, rect.Y, rect.Width, rect.Height,
                      startAngle, sweepAngle);
    }

    Status AddArc(IN INT x, 
                  IN INT y, 
                  IN INT width, 
                  IN INT height,
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathArcI(nativePath,
                                                    x,
                                                    y,
                                                    width,
                                                    height,
                                                    startAngle,
                                                    sweepAngle));
    }

    Status AddBezier(IN const PointF& pt1, 
                     IN const PointF& pt2,
                     IN const PointF& pt3, 
                     IN const PointF& pt4)
    {
        return AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X,
                         pt4.Y);
    }

    Status AddBezier(IN REAL x1, 
                     IN REAL y1, 
                     IN REAL x2, 
                     IN REAL y2,
                     IN REAL x3, 
                     IN REAL y3, 
                     IN REAL x4, 
                     IN REAL y4)
    {
        return SetStatus(DllExports::GdipAddPathBezier(nativePath, x1, y1, x2, 
                                                       y2, x3, y3, x4, y4));
    }

    Status AddBeziers(IN const PointF* points, 
                      IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathBeziers(nativePath, points, 
                                                        count));
    }

    Status AddBezier(IN const Point& pt1, 
                     IN const Point& pt2,
                     IN const Point& pt3, 
                     IN const Point& pt4)
    {
       return AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X,
                        pt4.Y);
    }

    Status AddBezier(IN INT x1, 
                     IN INT y1, 
                     IN INT x2, 
                     IN INT y2,
                     IN INT x3,
                     IN INT y3, 
                     IN INT x4, 
                     IN INT y4)
    {
       return SetStatus(DllExports::GdipAddPathBezierI(nativePath,
                                                      x1,
                                                      y1,
                                                      x2,
                                                      y2,
                                                      x3,
                                                      y3,
                                                      x4,
                                                      y4));
    }

    Status AddBeziers(IN const Point* points,
                      IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathBeziersI(nativePath,
                                                        points,
                                                        count));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathCurve(nativePath,
                                                      points,
                                                      count));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count,
                    IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathCurve2(nativePath,
                                                       points,
                                                       count,
                                                       tension));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count, 
                    IN INT offset,
                    IN INT numberOfSegments, 
                    IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathCurve3(nativePath,
                                                       points,
                                                       count,
                                                       offset,
                                                       numberOfSegments,
                                                       tension));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathCurveI(nativePath,
                                                     points,
                                                     count));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count, 
                    IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathCurve2I(nativePath,
                                                      points,
                                                      count,
                                                      tension));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count, 
                    IN INT offset,
                    IN INT numberOfSegments, 
                    IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathCurve3I(nativePath,
                                                      points,
                                                      count,
                                                      offset,
                                                      numberOfSegments,
                                                      tension));
    }

    Status AddClosedCurve(IN const PointF* points, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathClosedCurve(nativePath,
                                                            points,
                                                            count));
    }

    Status AddClosedCurve(IN const PointF* points, 
                          IN INT count, 
                          IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathClosedCurve2(nativePath,
                                                             points,
                                                             count,
                                                             tension));
    }

    Status AddClosedCurve(IN const Point* points, 
                          IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathClosedCurveI(nativePath,
                                                            points,
                                                            count));
    }


    Status AddClosedCurve(IN const Point* points, 
                          IN INT count,
                          IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathClosedCurve2I(nativePath,
                                                             points,
                                                             count,
                                                             tension));
    }

    Status AddRectangle(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipAddPathRectangle(nativePath,
                                                          rect.X,
                                                          rect.Y,
                                                          rect.Width,
                                                          rect.Height));
    }

    Status AddRectangles(IN const RectF* rects, 
                         IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathRectangles(nativePath,
                                                           rects,
                                                           count));
    }

    Status AddRectangle(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipAddPathRectangleI(nativePath,
                                                          rect.X,
                                                          rect.Y,
                                                          rect.Width,
                                                          rect.Height));
    }

    Status AddRectangles(IN const Rect* rects, INT count)
    {
        return SetStatus(DllExports::GdipAddPathRectanglesI(nativePath,
                                                           rects,
                                                           count));
    }

    Status AddEllipse(IN const RectF& rect)
    {
        return AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status AddEllipse(IN REAL x, 
                      IN REAL y, 
                      IN REAL width, 
                      IN REAL height)
    {
        return SetStatus(DllExports::GdipAddPathEllipse(nativePath,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status AddEllipse(IN const Rect& rect)
    {
        return AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status AddEllipse(IN INT x, 
                      IN INT y, 
                      IN INT width, 
                      IN INT height)
    {
        return SetStatus(DllExports::GdipAddPathEllipseI(nativePath,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status AddPie(IN const RectF& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddPie(rect.X, rect.Y, rect.Width, rect.Height, startAngle,
                      sweepAngle);
    }

    Status AddPie(IN REAL x, 
                  IN REAL y, 
                  IN REAL width, 
                  IN REAL height, 
                  IN REAL startAngle,
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathPie(nativePath, x, y, width,
                                                    height, startAngle, 
                                                    sweepAngle));
    }

    Status AddPie(IN const Rect& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddPie(rect.X,
                      rect.Y,
                      rect.Width,
                      rect.Height,
                      startAngle,
                      sweepAngle);
    }

    Status AddPie(IN INT x, 
                  IN INT y, 
                  IN INT width, 
                  IN INT height, 
                  IN REAL startAngle,
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathPieI(nativePath,
                                                    x,
                                                    y,
                                                    width,
                                                    height,
                                                    startAngle,
                                                    sweepAngle));
    }

    Status AddPolygon(IN const PointF* points, 
                      IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathPolygon(nativePath, points, 
                                                        count));
    }

    Status AddPolygon(IN const Point* points, 
                      IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathPolygonI(nativePath, points, 
                                                        count));
    }

    Status AddPath(IN const GraphicsPath* addingPath, 
                   IN BOOL connect)
    {
        GpPath* nativePath2 = NULL;
        if(addingPath)
            nativePath2 = addingPath->nativePath;

        return SetStatus(DllExports::GdipAddPathPath(nativePath, nativePath2, 
                                                     connect));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // World units
        IN const PointF        &origin,
        IN const StringFormat  *format
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipAddPathString(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &rect,
            format ? format->nativeFormat : NULL
        ));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // World units
        IN const RectF         &layoutRect,
        IN const StringFormat  *format
    )
    {
        return SetStatus(DllExports::GdipAddPathString(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &layoutRect,
            format ? format->nativeFormat : NULL
        ));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // World units
        IN const Point         &origin,
        IN const StringFormat  *format
    )
    {
        Rect rect(origin.X, origin.Y, 0, 0);

        return SetStatus(DllExports::GdipAddPathStringI(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &rect,
            format ? format->nativeFormat : NULL
        ));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // World units
        IN const Rect          &layoutRect,
        IN const StringFormat  *format
    )
    {
        return SetStatus(DllExports::GdipAddPathStringI(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &layoutRect,
            format ? format->nativeFormat : NULL
        ));
    }
    
    Status Transform(IN const Matrix* matrix)
    {
        if(matrix)
            return SetStatus(DllExports::GdipTransformPath(nativePath, 
                                                      matrix->nativeMatrix));
        else
            return Ok;
    }

    // This is not always the tightest bounds.

    Status GetBounds(OUT RectF* bounds, 
                     IN const Matrix* matrix = NULL, 
                     IN const Pen* pen = NULL) const;

    Status GetBounds(OUT Rect* bounds,
                     IN const Matrix* matrix = NULL, 
                     IN const Pen* pen = NULL) const;

    // Once flattened, the resultant path is made of line segments and
    // the original path information is lost.  When matrix is NULL the
    // identity matrix is assumed.
        
    Status Flatten(IN const Matrix* matrix = NULL, 
                   IN REAL flatness = FlatnessDefault)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
        {
            nativeMatrix = matrix->nativeMatrix;
        }

        return SetStatus(DllExports::GdipFlattenPath(
            nativePath, 
            nativeMatrix, 
            flatness
        ));
    }

    Status Widen(
        IN const Pen* pen, 
        IN const Matrix* matrix = NULL,
        IN REAL flatness = FlatnessDefault
    )
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipWidenPath(
            nativePath, 
            pen->nativePen,
            nativeMatrix, 
            flatness
        ));
    }

    Status Outline(
        IN const Matrix *matrix = NULL,
        IN REAL flatness = FlatnessDefault
    )
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
        {
            nativeMatrix = matrix->nativeMatrix;
        }

        return SetStatus(DllExports::GdipWindingModeOutline(
            nativePath, nativeMatrix, flatness
        ));
    }
    
    // Once this is called, the resultant path is made of line segments and
    // the original path information is lost.  When matrix is NULL, the 
    // identity matrix is assumed.
    
    Status Warp(IN const PointF* destPoints, 
                IN INT count,
                IN const RectF& srcRect, 
                IN const Matrix* matrix = NULL,
                IN WarpMode warpMode = WarpModePerspective,
                IN REAL flatness = FlatnessDefault)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipWarpPath(
                                        nativePath,
                                        nativeMatrix,
                                        destPoints,
                                        count,
                                        srcRect.X,
                                        srcRect.Y,
                                        srcRect.Width,
                                        srcRect.Height,
                                        warpMode,
                                        flatness));
    }

    INT GetPointCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetPointCount(nativePath, &count));

        return count;
    }

    Status GetPathTypes(OUT BYTE* types, 
                        IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathTypes(nativePath, types,
                                                      count));
    }

    Status GetPathPoints(OUT PointF* points, 
                         IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathPoints(nativePath, points, 
                                                       count));
    }

    Status GetPathPoints(OUT Point* points, 
                         IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathPointsI(nativePath, points, 
                                                        count));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

    BOOL IsVisible(IN const PointF& point, 
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(point.X, point.Y, g);
    }
    
    BOOL IsVisible(IN REAL x, 
                   IN REAL y, 
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN const Point& point,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(point.X, point.Y, g);
    }

    BOOL IsVisible(IN INT x, 
                   IN INT y, 
                   IN const Graphics* g = NULL) const;
    
    BOOL IsOutlineVisible(IN const PointF& point,
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const
    {
        return IsOutlineVisible(point.X, point.Y, pen, g);
    }

    BOOL IsOutlineVisible(IN REAL x, 
                          IN REAL y, 
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const;

    BOOL IsOutlineVisible(IN const Point& point,
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const
    {
        return IsOutlineVisible(point.X, point.Y, pen, g);
    }
    
    BOOL IsOutlineVisible(IN INT x, 
                          IN INT y, 
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const;

protected:

    GraphicsPath(const GraphicsPath& path)
    {
        GpPath *clonepath = NULL;
        SetStatus(DllExports::GdipClonePath(path.nativePath, &clonepath));
        SetNativePath(clonepath);
    }

private:
    GraphicsPath& operator=(const GraphicsPath &);

protected:
    GraphicsPath(GpPath* nativePath)
    {
        lastResult = Ok;
        SetNativePath(nativePath);
    }

    VOID SetNativePath(GpPath *nativePath)
    {
        this->nativePath = nativePath;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpPath* nativePath;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// GraphisPathIterator class
//--------------------------------------------------------------------------

class GraphicsPathIterator : public GdiplusBase
{
public:

    GraphicsPathIterator(IN const GraphicsPath* path)
    {
        GpPath* nativePath = NULL;
        if(path)
            nativePath = path->nativePath;

        GpPathIterator *iter = NULL;
        lastResult = DllExports::GdipCreatePathIter(&iter, nativePath);
        SetNativeIterator(iter);
    }

    ~GraphicsPathIterator()
    {
        DllExports::GdipDeletePathIter(nativeIterator);
    }


    INT NextSubpath(OUT INT* startIndex,
                    OUT INT* endIndex,
                    OUT BOOL* isClosed)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextSubpath(nativeIterator,
            &resultCount, startIndex, endIndex, isClosed));

        return resultCount;
    }


    INT NextSubpath(OUT const GraphicsPath* path, 
                    OUT BOOL* isClosed)
    {
        GpPath* nativePath = NULL;

        INT resultCount;

        if(path)
            nativePath= path->nativePath;

        SetStatus(DllExports::GdipPathIterNextSubpathPath(nativeIterator,
            &resultCount, nativePath, isClosed));

        return resultCount;
    }

    INT NextPathType(OUT BYTE* pathType, 
                     OUT INT* startIndex, 
                     OUT INT* endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextPathType(nativeIterator,
            &resultCount, pathType, startIndex, endIndex));

        return resultCount;
    }

    INT NextMarker(OUT INT* startIndex, 
                   OUT INT* endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextMarker(nativeIterator,
            &resultCount, startIndex, endIndex));

        return resultCount;
    }


    INT NextMarker(OUT const GraphicsPath* path)
    {
        GpPath* nativePath = NULL;

        INT resultCount;

        if(path)
            nativePath= path->nativePath;

        SetStatus(DllExports::GdipPathIterNextMarkerPath(nativeIterator,
            &resultCount, nativePath));

        return resultCount;
    }

    INT GetCount() const
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterGetCount(nativeIterator, 
                                                   &resultCount));

        return resultCount;
    }

    INT GetSubpathCount() const
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterGetSubpathCount(nativeIterator, 
                                                          &resultCount));

        return resultCount;
    }

    BOOL HasCurve() const
    {
        BOOL hasCurve;

        SetStatus(DllExports::GdipPathIterHasCurve(nativeIterator, &hasCurve));

        return hasCurve;
    }

    VOID Rewind()
    {
        SetStatus(DllExports::GdipPathIterRewind(nativeIterator));
    }

    INT Enumerate(OUT PointF *points,
                  OUT BYTE *types, 
                  IN INT count)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterEnumerate(nativeIterator,
            &resultCount, points, types, count));

        return resultCount;
    }

    INT CopyData(OUT PointF* points, 
                 OUT BYTE* types,
                 IN INT startIndex, 
                 IN INT endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterCopyData(nativeIterator,
            &resultCount, points, types, startIndex, endIndex));

        return resultCount;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

private:
    GraphicsPathIterator(const GraphicsPathIterator &);
    GraphicsPathIterator& operator=(const GraphicsPathIterator &);

protected:
    VOID SetNativeIterator(GpPathIterator *nativeIterator)
    {
        this->nativeIterator = nativeIterator;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpPathIterator* nativeIterator;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// Path Gradient Brush
//--------------------------------------------------------------------------

class PathGradientBrush : public Brush
{
public:
    friend class Pen;

    PathGradientBrush(
        IN const PointF* points,
        IN INT count,
        IN WrapMode wrapMode = WrapModeClamp)
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradient(
                                        points, count,
                                        wrapMode, &brush);
        SetNativeBrush(brush);
    }

    PathGradientBrush(
        IN const Point* points,
        IN INT count,
        IN WrapMode wrapMode = WrapModeClamp)
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradientI(
                                        points, count,
                                        wrapMode, &brush);

        SetNativeBrush(brush);
    }

    PathGradientBrush(
        IN const GraphicsPath* path
        )
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradientFromPath(
                                        path->nativePath, &brush);
        SetNativeBrush(brush);
    }

    Status GetCenterColor(OUT Color* color) const
    {
        ARGB argb;
        
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        SetStatus(DllExports::GdipGetPathGradientCenterColor(
                       (GpPathGradient*) nativeBrush, &argb));

        color->SetValue(argb);

        return lastResult;
    }

    Status SetCenterColor(IN const Color& color)
    {
        SetStatus(DllExports::GdipSetPathGradientCenterColor(
                       (GpPathGradient*) nativeBrush,
                       color.GetValue()));

        return lastResult;
    }

    INT GetPointCount() const
    {
        INT count;

        SetStatus(DllExports::GdipGetPathGradientPointCount(
                       (GpPathGradient*) nativeBrush, &count));

        return count;
    }

    INT GetSurroundColorCount() const
    {
        INT count;

        SetStatus(DllExports::GdipGetPathGradientSurroundColorCount(
                       (GpPathGradient*) nativeBrush, &count));

        return count;
    }

    Status GetSurroundColors(OUT Color* colors, 
                             IN OUT INT* count) const
    {
        if(colors == NULL || count == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        INT count1;
        
        SetStatus(DllExports::GdipGetPathGradientSurroundColorCount(
                        (GpPathGradient*) nativeBrush, &count1));

        if(lastResult != Ok)
            return lastResult;

        if((*count < count1) || (count1 <= 0))
            return SetStatus(InsufficientBuffer);

        ARGB* argbs = (ARGB*) new ARGB[count1];
        if(argbs == NULL)
            return SetStatus(OutOfMemory);

        SetStatus(DllExports::GdipGetPathGradientSurroundColorsWithCount(
                    (GpPathGradient*)nativeBrush, argbs, &count1));

        if(lastResult == Ok)
        {
            for(INT i = 0; i < count1; i++)
            {
                colors[i].SetValue(argbs[i]);
            }        
            *count = count1;
        }

        delete [] argbs;
        return lastResult;
    }

    Status SetSurroundColors(IN const Color* colors, 
                             IN OUT INT* count)
    {
        if(colors == NULL || count == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        INT count1 = GetPointCount();

        if((*count > count1) || (count1 <= 0))
            return SetStatus(InvalidParameter);

        count1 = *count;

        ARGB* argbs = (ARGB*) new ARGB[count1];
        if(argbs == NULL)
            return SetStatus(OutOfMemory);

        for(INT i = 0; i < count1; i++)
        {
            argbs[i] = colors[i].GetValue();
        }

        SetStatus(DllExports::GdipSetPathGradientSurroundColorsWithCount(
                    (GpPathGradient*)nativeBrush, argbs, &count1));

        if(lastResult == Ok)
            *count = count1;

        delete [] argbs;

        return lastResult;
    }

    Status GetGraphicsPath(OUT GraphicsPath* path) const
    {
        if(path == NULL)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPathGradientPath(
                    (GpPathGradient*)nativeBrush, path->nativePath));
    }

    Status SetGraphicsPath(IN const GraphicsPath* path)
    {
        if(path == NULL)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipSetPathGradientPath(
                    (GpPathGradient*)nativeBrush, path->nativePath));
    }

    Status GetCenterPoint(OUT PointF* point) const
    {
        return SetStatus(DllExports::GdipGetPathGradientCenterPoint(
                                (GpPathGradient*)nativeBrush,
                                point));
    }

    Status GetCenterPoint(OUT Point* point) const
    {
        return SetStatus(DllExports::GdipGetPathGradientCenterPointI(
                                (GpPathGradient*)nativeBrush,
                                point));
    }

    Status SetCenterPoint(IN const PointF& point)
    {
        return SetStatus(DllExports::GdipSetPathGradientCenterPoint(
                                (GpPathGradient*)nativeBrush,
                                &point));
    }

    Status SetCenterPoint(IN const Point& point)
    {
        return SetStatus(DllExports::GdipSetPathGradientCenterPointI(
                                (GpPathGradient*)nativeBrush,
                                &point));
    }

    Status GetRectangle(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetPathGradientRect(
                            (GpPathGradient*)nativeBrush, rect));
    }

    Status GetRectangle(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetPathGradientRectI(
                            (GpPathGradient*)nativeBrush, rect));
    }

    Status SetGammaCorrection(IN BOOL useGammaCorrection)
    {
        return SetStatus(DllExports::GdipSetPathGradientGammaCorrection(
            (GpPathGradient*)nativeBrush, useGammaCorrection));
    }

    BOOL GetGammaCorrection() const
    {
        BOOL useGammaCorrection;

        SetStatus(DllExports::GdipGetPathGradientGammaCorrection(
            (GpPathGradient*)nativeBrush, &useGammaCorrection));

        return useGammaCorrection;
    }

    INT GetBlendCount() const
    {
       INT count = 0;

       SetStatus(DllExports::GdipGetPathGradientBlendCount(
                           (GpPathGradient*) nativeBrush, &count));

       return count;
    }

    Status GetBlend(OUT REAL* blendFactors,
                    OUT REAL* blendPositions,
                    IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathGradientBlend(
                            (GpPathGradient*)nativeBrush,
                            blendFactors, blendPositions, count));
    }

    Status SetBlend(IN const REAL* blendFactors, 
                    IN const REAL* blendPositions, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipSetPathGradientBlend(
                            (GpPathGradient*)nativeBrush,
                            blendFactors, blendPositions, count));
    }

    INT GetInterpolationColorCount() const
    {
       INT count = 0;

       SetStatus(DllExports::GdipGetPathGradientPresetBlendCount(
                        (GpPathGradient*) nativeBrush, &count));

       return count;
    }

    Status SetInterpolationColors(IN const Color* presetColors,
                                  IN const REAL* blendPositions, 
                                  IN INT count)
    {
        if ((count <= 0) || !presetColors) 
        {
            return SetStatus(InvalidParameter);
        }

        ARGB* argbs = (ARGB*) new ARGB[count];
        if(argbs)
        {
            for(INT i = 0; i < count; i++)
            {
                argbs[i] = presetColors[i].GetValue();
            }

            Status status = SetStatus(DllExports::
                               GdipSetPathGradientPresetBlend(
                                    (GpPathGradient*) nativeBrush,
                                    argbs,
                                    blendPositions,
                                    count));
            delete[] argbs;
            return status;
        }
        else
        {
            return SetStatus(OutOfMemory);
        }
    }

    Status GetInterpolationColors(OUT Color* presetColors,
                                  OUT REAL* blendPositions, 
                                  IN INT count) const
    {
        if ((count <= 0) || !presetColors) 
        {
            return SetStatus(InvalidParameter);
        }

        ARGB* argbs = (ARGB*) new ARGB[count];
        
        if (!argbs)
        {
            return SetStatus(OutOfMemory);
        }

        GpStatus status = SetStatus(DllExports::GdipGetPathGradientPresetBlend(
                                (GpPathGradient*)nativeBrush,
                                argbs,
                                blendPositions,
                                count));
        
        for(INT i = 0; i < count; i++)
        {
            presetColors[i] = Color(argbs[i]);
        }
        delete [] argbs;
        
        return status;
    }

    Status SetBlendBellShape(IN REAL focus, 
                             IN REAL scale = 1.0)
    {
        return SetStatus(DllExports::GdipSetPathGradientSigmaBlend(
                            (GpPathGradient*)nativeBrush, focus, scale));
    }

    Status SetBlendTriangularShape(
        IN REAL focus,
        IN REAL scale = 1.0
    )
    {
        return SetStatus(DllExports::GdipSetPathGradientLinearBlend(
                            (GpPathGradient*)nativeBrush, focus, scale));
    }

    Status GetTransform(OUT Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetPathGradientTransform(
                            (GpPathGradient*) nativeBrush, 
                            matrix->nativeMatrix));
    }

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetPathGradientTransform(
                            (GpPathGradient*) nativeBrush, 
                            matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetPathGradientTransform(
                            (GpPathGradient*)nativeBrush));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyPathGradientTransform(
                            (GpPathGradient*)nativeBrush,
                            matrix->nativeMatrix,
                            order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslatePathGradientTransform(
                            (GpPathGradient*)nativeBrush,
                            dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScalePathGradientTransform(
                            (GpPathGradient*)nativeBrush,
                            sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotatePathGradientTransform(
                            (GpPathGradient*)nativeBrush,
                            angle, order));
    }

    Status GetFocusScales(OUT REAL* xScale, 
                          OUT REAL* yScale) const
    {
        return SetStatus(DllExports::GdipGetPathGradientFocusScales(
                            (GpPathGradient*) nativeBrush, xScale, yScale));
    }

    Status SetFocusScales(IN REAL xScale,
                          IN REAL yScale)
    {
        return SetStatus(DllExports::GdipSetPathGradientFocusScales(
                            (GpPathGradient*) nativeBrush, xScale, yScale));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetPathGradientWrapMode(
                     (GpPathGradient*) nativeBrush, &wrapMode));

        return wrapMode;
    }

    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetPathGradientWrapMode(
                            (GpPathGradient*) nativeBrush, wrapMode));
    }

private:
    PathGradientBrush(const PathGradientBrush &);
    PathGradientBrush& operator=(const PathGradientBrush &);

protected:

    PathGradientBrush()
    {
    }
};

#endif // !_GRAPHICSPATH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusPen.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusPen.h
*
* Abstract:
*
*   GDI+ Pen class
*
\**************************************************************************/
#ifndef _GDIPLUSPEN_H
#define _GDIPLUSPEN_H

//--------------------------------------------------------------------------
// Pen class
//--------------------------------------------------------------------------

class Pen : public GdiplusBase
{
public:
    friend class GraphicsPath;
    friend class Graphics;

    Pen(IN const Color& color, 
        IN REAL width = 1.0f)
    {
        Unit unit = UnitWorld;
        nativePen = NULL;
        lastResult = DllExports::GdipCreatePen1(color.GetValue(),
                                    width, unit, &nativePen);
    }

    Pen(IN const Brush* brush, 
        IN REAL width = 1.0f)
    {
        Unit unit = UnitWorld;
        nativePen = NULL;
        lastResult = DllExports::GdipCreatePen2(brush->nativeBrush,
                                    width, unit, &nativePen);
    }

    ~Pen()
    {
        DllExports::GdipDeletePen(nativePen);
    }

    Pen* Clone() const
    {
        GpPen *clonePen = NULL;

        lastResult = DllExports::GdipClonePen(nativePen, &clonePen);
   
        return new Pen(clonePen, lastResult);
    }

    Status SetWidth(IN REAL width)
    {
        return SetStatus(DllExports::GdipSetPenWidth(nativePen, width));
    }

    REAL GetWidth() const
    {
        REAL width;

        SetStatus(DllExports::GdipGetPenWidth(nativePen, &width));
        
        return width;
    }
    
    // Set/get line caps: start, end, and dash

    // Line cap and join APIs by using LineCap and LineJoin enums.

    Status SetLineCap(IN LineCap startCap, 
                      IN LineCap endCap, 
                      IN DashCap dashCap)
    {
        return SetStatus(DllExports::GdipSetPenLineCap197819(nativePen, 
                                   startCap, endCap, dashCap));
    }

    Status SetStartCap(IN LineCap startCap)
    {
        return SetStatus(DllExports::GdipSetPenStartCap(nativePen, startCap));
    }

    Status SetEndCap(IN LineCap endCap)
    {
        return SetStatus(DllExports::GdipSetPenEndCap(nativePen, endCap));
    }

    Status SetDashCap(IN DashCap dashCap)
    {
        return SetStatus(DllExports::GdipSetPenDashCap197819(nativePen,
                                   dashCap));
    }

    LineCap GetStartCap() const
    {
        LineCap startCap;

        SetStatus(DllExports::GdipGetPenStartCap(nativePen, &startCap));
        
        return startCap;
    }

    LineCap GetEndCap() const
    {
        LineCap endCap;

        SetStatus(DllExports::GdipGetPenEndCap(nativePen, &endCap));

        return endCap;
    }

    DashCap GetDashCap() const
    {
        DashCap dashCap;

        SetStatus(DllExports::GdipGetPenDashCap197819(nativePen,
                            &dashCap));

        return dashCap;
    }

    Status SetLineJoin(IN LineJoin lineJoin)
    {
        return SetStatus(DllExports::GdipSetPenLineJoin(nativePen, lineJoin));
    }

    LineJoin GetLineJoin() const
    {
        LineJoin lineJoin;
        
        SetStatus(DllExports::GdipGetPenLineJoin(nativePen, &lineJoin));
        
        return lineJoin;
    }

    Status SetCustomStartCap(IN const CustomLineCap* customCap)
    {
        GpCustomLineCap* nativeCap = NULL;
        if(customCap)
            nativeCap = customCap->nativeCap;

        return SetStatus(DllExports::GdipSetPenCustomStartCap(nativePen, 
                                                              nativeCap));
    }

    Status GetCustomStartCap(OUT CustomLineCap* customCap) const
    {
        if(!customCap)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPenCustomStartCap(nativePen, 
                                                    &(customCap->nativeCap)));
    }

    Status SetCustomEndCap(IN const CustomLineCap* customCap)
    {
        GpCustomLineCap* nativeCap = NULL;
        if(customCap)
            nativeCap = customCap->nativeCap;

        return SetStatus(DllExports::GdipSetPenCustomEndCap(nativePen, 
                                                            nativeCap));
    }

    Status GetCustomEndCap(OUT CustomLineCap* customCap) const
    {
        if(!customCap)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPenCustomEndCap(nativePen, 
                                                    &(customCap->nativeCap)));
    }

    Status SetMiterLimit(IN REAL miterLimit)
    {
        return SetStatus(DllExports::GdipSetPenMiterLimit(nativePen, 
                                                    miterLimit));
    }

    REAL GetMiterLimit() const
    {
        REAL miterLimit;

        SetStatus(DllExports::GdipGetPenMiterLimit(nativePen, &miterLimit));

        return miterLimit;
    }

    Status SetAlignment(IN PenAlignment penAlignment)
    {
        return SetStatus(DllExports::GdipSetPenMode(nativePen, penAlignment));
    }

    PenAlignment GetAlignment() const
    {
        PenAlignment penAlignment;
        
        SetStatus(DllExports::GdipGetPenMode(nativePen, &penAlignment));
        
        return penAlignment;
    }
    
    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetPenTransform(nativePen, 
                                                       matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetPenTransform(nativePen, 
                                                         matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetPenTransform(nativePen));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyPenTransform(nativePen,
                                                         matrix->nativeMatrix,
                                                         order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslatePenTransform(nativePen,
                                                               dx, 
                                                               dy, 
                                                               order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScalePenTransform(nativePen,
                                                           sx, 
                                                           sy, 
                                                           order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotatePenTransform(nativePen,
                                                            angle, 
                                                            order));
    }

    PenType GetPenType() const
    {
       PenType type;
       SetStatus(DllExports::GdipGetPenFillType(nativePen, &type));

       return type;
    }

    Status SetColor(IN const Color& color)
    {
        return SetStatus(DllExports::GdipSetPenColor(nativePen,
                                                     color.GetValue()));
    }

    Status SetBrush(IN const Brush* brush)
    {
        return SetStatus(DllExports::GdipSetPenBrushFill(nativePen, 
                                       brush->nativeBrush));
    }

    Status GetColor(OUT Color* color) const
    {
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        PenType type = GetPenType();

        if (type != PenTypeSolidColor) 
        {
            return WrongState;
        }
        
        ARGB argb;
        
        SetStatus(DllExports::GdipGetPenColor(nativePen,
                                              &argb));
        if (lastResult == Ok)
        {
            color->SetValue(argb);
        }
        
        return lastResult;
    }

    Brush* GetBrush() const
    {
       PenType type = GetPenType();

       Brush* brush = NULL;

       switch(type)
       {
       case PenTypeSolidColor:
           brush = new SolidBrush();
           break;

       case PenTypeHatchFill:
           brush = new HatchBrush();
           break;

       case PenTypeTextureFill:
           brush = new TextureBrush();
           break;

       case PenTypePathGradient:
           brush = new Brush();
           break;

       case PenTypeLinearGradient:
           brush = new LinearGradientBrush();
           break;

       default:
           break;
       }

       if(brush)
       {
           GpBrush* nativeBrush;

           SetStatus(DllExports::GdipGetPenBrushFill(nativePen, 
                                                     &nativeBrush));
           brush->SetNativeBrush(nativeBrush);
       }

       return brush;
    }

    DashStyle GetDashStyle() const
    {
        DashStyle dashStyle;

        SetStatus(DllExports::GdipGetPenDashStyle(nativePen, &dashStyle));

        return dashStyle;
    }

    Status SetDashStyle(IN DashStyle dashStyle)
    {
        return SetStatus(DllExports::GdipSetPenDashStyle(nativePen, 
                                                         dashStyle));
    }

    REAL GetDashOffset() const
    {
        REAL dashOffset;

        SetStatus(DllExports::GdipGetPenDashOffset(nativePen, &dashOffset));

        return dashOffset;
    }

    Status SetDashOffset(IN REAL dashOffset)
    {
        return SetStatus(DllExports::GdipSetPenDashOffset(nativePen, 
                                                          dashOffset));
    }
    
    Status SetDashPattern(IN const REAL* dashArray, IN INT count)
    {
        return SetStatus(DllExports::GdipSetPenDashArray(nativePen,
                                                         dashArray, 
                                                         count));
    }
    
    INT GetDashPatternCount() const
    {
        INT count = 0;
        
        SetStatus(DllExports::GdipGetPenDashCount(nativePen, &count));
        
        return count;
    }

    Status GetDashPattern(OUT REAL* dashArray, 
                          IN INT count) const
    {
        if (dashArray == NULL || count <= 0)
            return SetStatus(InvalidParameter); 
        
        return SetStatus(DllExports::GdipGetPenDashArray(nativePen, 
                                                         dashArray, 
                                                         count));
    }

    Status SetCompoundArray(IN const REAL* compoundArray,
                            IN INT count)
    {
        return SetStatus(DllExports::GdipSetPenCompoundArray(nativePen, 
                                                             compoundArray,
                                                             count));
    }

    INT GetCompoundArrayCount() const
    {
        INT count = 0;
        
        SetStatus(DllExports::GdipGetPenCompoundCount(nativePen, &count));
        
        return count;
    }

    Status GetCompoundArray(OUT REAL* compoundArray, 
                            IN INT count) const
    {
        if (compoundArray == NULL || count <= 0)
            return SetStatus(InvalidParameter); 
        
        return SetStatus(DllExports::GdipGetPenCompoundArray(nativePen, 
                                                             compoundArray, 
                                                             count));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

private:
    Pen(const Pen &);
    Pen& operator=(const Pen &);

protected:
    Pen(GpPen* nativePen, Status status)
    {
        lastResult = status;
        SetNativePen(nativePen);
    }

    VOID SetNativePen(GpPen* nativePen)
    {
        this->nativePen = nativePen;
    }
    
    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else 
            return status;
    }

protected:
    GpPen* nativePen;
    mutable Status lastResult;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusMatrix.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusMatrix.h
*
* Abstract:
*
*   GDI+ Matrix class
*
\**************************************************************************/

class Matrix : public GdiplusBase
{
public:
    friend class Graphics;
    friend class GraphicsPath;
    friend class TextureBrush;
    friend class LinearGradientBrush;
    friend class PathGradientBrush;
    friend class Pen;
    friend class Region;
    
    // Default constructor is set to identity matrix.

    Matrix()
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix(&matrix);
    
        SetNativeMatrix(matrix);
    }

    Matrix(IN REAL m11, 
           IN REAL m12,
           IN REAL m21, 
           IN REAL m22,
           IN REAL dx, 
           IN REAL dy)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix2(m11, m12, m21, m22, 
                                                      dx, dy, &matrix);
    
        SetNativeMatrix(matrix);
    }
    
    Matrix(IN const RectF& rect, 
           IN const PointF* dstplg)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix3(&rect, 
                                                   dstplg,
                                                   &matrix);

        SetNativeMatrix(matrix);
    }

    Matrix(IN const Rect& rect, 
           IN const Point* dstplg)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix3I(&rect, 
                                                    dstplg,
                                                    &matrix);

        SetNativeMatrix(matrix);
    }

    ~Matrix()
    {
        DllExports::GdipDeleteMatrix(nativeMatrix);
    }

    Matrix *Clone() const
    {
        GpMatrix *cloneMatrix = NULL;

        SetStatus(DllExports::GdipCloneMatrix(nativeMatrix,
                                                  &cloneMatrix));

        if (lastResult != Ok)
            return NULL;

        return new Matrix(cloneMatrix);
    }

    Status GetElements(OUT REAL *m) const 
    {
        return SetStatus(DllExports::GdipGetMatrixElements(nativeMatrix, m));
    }
    
    Status SetElements(IN REAL m11, 
                       IN REAL m12, 
                       IN REAL m21, 
                       IN REAL m22, 
                       IN REAL dx, 
                       IN REAL dy)
    {
        return SetStatus(DllExports::GdipSetMatrixElements(nativeMatrix,
                            m11, m12, m21, m22, dx, dy));
    }

    REAL OffsetX() const
    {
        REAL elements[6];

        if (GetElements(&elements[0]) == Ok)
            return elements[4];
        else 
            return 0.0f;
    }

    REAL OffsetY() const
    {
       REAL elements[6];

       if (GetElements(&elements[0]) == Ok)
           return elements[5];
       else 
           return 0.0f;
    }

    Status Reset()
    {
        // set identity matrix elements 
        return SetStatus(DllExports::GdipSetMatrixElements(nativeMatrix,
                                             1.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    }

    Status Multiply(IN const Matrix *matrix, 
                    IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyMatrix(nativeMatrix, 
                                          matrix->nativeMatrix,
                                          order));
    }

    Status Translate(IN REAL offsetX, 
                     IN REAL offsetY, 
                     IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, offsetX,
                                                         offsetY, order));
    }

    Status Scale(IN REAL scaleX, 
                 IN REAL scaleY, 
                 IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleMatrix(nativeMatrix, scaleX, 
                                                     scaleY, order));
    }

    Status Rotate(IN REAL angle, 
                  IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, 
                                                      order));
    }
    
    Status RotateAt(IN REAL angle, 
                    IN const PointF& center, 
                    IN MatrixOrder order = MatrixOrderPrepend)
    {
        if(order == MatrixOrderPrepend)
        {
            SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, center.X,
                                                      center.Y, order));
            SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, 
                                                   order));
            return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix,
                                                             -center.X, 
                                                             -center.Y, 
                                                             order));
        }
        else
        {
            SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, 
                                                      - center.X, 
                                                      - center.Y, 
                                                      order));
            SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, 
                                                   order));
            return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, 
                                                             center.X, 
                                                             center.Y, 
                                                             order));
        }
    }

    Status Shear(IN REAL shearX, 
                 IN REAL shearY,
                 IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipShearMatrix(nativeMatrix, shearX, 
                                                     shearY, order));
    }

    Status Invert()
    {
        return SetStatus(DllExports::GdipInvertMatrix(nativeMatrix));
    }

    // float version
    Status TransformPoints(IN OUT PointF* pts, 
                           IN INT count = 1) const
    {
        return SetStatus(DllExports::GdipTransformMatrixPoints(nativeMatrix, 
                                                               pts, count));
    }
    
    Status TransformPoints(IN OUT Point* pts, 
                           IN INT count = 1) const
    {
        return SetStatus(DllExports::GdipTransformMatrixPointsI(nativeMatrix, 
                                                                pts, 
                                                                count));
    }

    Status TransformVectors(IN OUT PointF* pts, 
                            IN INT count = 1) const
    { 
        return SetStatus(DllExports::GdipVectorTransformMatrixPoints(
                                        nativeMatrix, pts, count));
    }

    Status TransformVectors(IN OUT Point* pts, 
                            IN INT count = 1) const
    { 
       return SetStatus(DllExports::GdipVectorTransformMatrixPointsI(
                                        nativeMatrix, 
                                        pts, 
                                        count));
    }
    
    BOOL IsInvertible() const
    {
        BOOL result = FALSE;

        SetStatus(DllExports::GdipIsMatrixInvertible(nativeMatrix, &result));
    
        return result;
    }

    BOOL IsIdentity() const
    {
       BOOL result = FALSE;

       SetStatus(DllExports::GdipIsMatrixIdentity(nativeMatrix, &result));
    
       return result;
    }

    BOOL Equals(IN const Matrix *matrix) const
    {
       BOOL result = FALSE;

       SetStatus(DllExports::GdipIsMatrixEqual(nativeMatrix,
                                               matrix->nativeMatrix, 
                                               &result));
   
       return result;
    }
    
    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;
 
        return lastStatus;
    }

private:
    Matrix(const Matrix &);
    Matrix& operator=(const Matrix &);

protected:
    Matrix(GpMatrix *nativeMatrix)
    {
        lastResult = Ok;
        SetNativeMatrix(nativeMatrix);
    }
    
    VOID SetNativeMatrix(GpMatrix *nativeMatrix)
    {
        this->nativeMatrix = nativeMatrix;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpMatrix *nativeMatrix;
    mutable Status lastResult;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusRegion.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusRegion.h
*
* Abstract:
*
*   GDI+ Region class implementation
*
\**************************************************************************/

#ifndef _GDIPLUSREGION_H
#define _GDIPLUSREGION_H

inline 
Region::Region()
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegion(&region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const RectF& rect)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRect(&rect, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const Rect& rect)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRectI(&rect, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const GraphicsPath* path)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionPath(path->nativePath, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const BYTE* regionData, IN INT size)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRgnData(regionData, size, 
                                                     &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN HRGN hRgn)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionHrgn(hRgn, &region);

    SetNativeRegion(region);
}

inline 
Region* Region::FromHRGN(IN HRGN hRgn)
{
    GpRegion *region = NULL;

    if (DllExports::GdipCreateRegionHrgn(hRgn, &region) == Ok)
    {
        Region* newRegion = new Region(region);

        if (newRegion == NULL) 
        {
            DllExports::GdipDeleteRegion(region);
        }

        return newRegion;
    }
    else
        return NULL;
}

inline 
Region::~Region()
{
    DllExports::GdipDeleteRegion(nativeRegion);
}

inline Region* 
Region::Clone() const
{
    GpRegion *region = NULL;

    SetStatus(DllExports::GdipCloneRegion(nativeRegion, &region));

    return new Region(region);
}

inline Status 
Region::MakeInfinite()
{
    return SetStatus(DllExports::GdipSetInfinite(nativeRegion));
}

inline Status 
Region::MakeEmpty()
{
    return SetStatus(DllExports::GdipSetEmpty(nativeRegion));
}

inline Status 
Region::Intersect(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                        CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, 
                                                       path->nativePath, 
                                                       CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, 
                                                         region->nativeRegion, 
                                                         CombineModeIntersect));
}

inline Status 
Region::Union(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeUnion));
}

inline Status 
Region::Union(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                        CombineModeUnion));
}

inline Status 
Region::Union(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, 
                                                       path->nativePath, 
                                                       CombineModeUnion));
}

inline Status 
Region::Union(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, 
                                                         region->nativeRegion, 
                                                         CombineModeUnion));
}

inline Status 
Region::Xor(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeXor));
}

inline Status 
Region::Xor(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                        CombineModeXor));
}

inline Status 
Region::Xor(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, 
                                                       path->nativePath, 
                                                       CombineModeXor));
}

inline Status 
Region::Xor(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, 
                                                         region->nativeRegion, 
                                                         CombineModeXor));
}

inline Status 
Region::Exclude(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeExclude));
}

inline Status 
Region::Exclude(IN const Rect& rect)
{
     return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                         CombineModeExclude));
}

inline Status 
Region::Exclude(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, 
                                                       path->nativePath, 
                                                       CombineModeExclude));
}

inline Status
Region::Exclude(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion,
                                               region->nativeRegion, 
                                                         CombineModeExclude));
}

inline Status 
Region::Complement(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeComplement));
}

inline Status 
Region::Complement(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                        CombineModeComplement));
}

inline Status 
Region::Complement(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion,
                                                path->nativePath, 
                                                CombineModeComplement));
}

inline Status 
Region::Complement(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion,
                                                  region->nativeRegion, 
                                                         CombineModeComplement));
}

inline Status 
Region::Translate(IN REAL dx, 
                  IN REAL dy)
{
    return SetStatus(DllExports::GdipTranslateRegion(nativeRegion, dx, dy));
}

inline Status 
Region::Translate(IN INT dx, 
                  IN INT dy)
{
    return SetStatus(DllExports::GdipTranslateRegionI(nativeRegion, dx, dy));
}

inline Status 
Region::Transform(IN const Matrix* matrix)
{
    return SetStatus(DllExports::GdipTransformRegion(nativeRegion, 
                                                     matrix->nativeMatrix));
}

inline Status 
Region::GetBounds(OUT RectF* rect,
                  IN const Graphics* g) const
{
    return SetStatus(DllExports::GdipGetRegionBounds(nativeRegion,
                                                g->nativeGraphics,
                                                rect));
}

inline Status 
Region::GetBounds(OUT Rect* rect,
                  IN const Graphics* g) const
{
    return SetStatus(DllExports::GdipGetRegionBoundsI(nativeRegion,
                                                g->nativeGraphics,
                                                rect));
}

inline HRGN
Region::GetHRGN(IN const Graphics* g) const
{
    HRGN hrgn;

    SetStatus(DllExports::GdipGetRegionHRgn(nativeRegion,
                                            g->nativeGraphics,
                                            &hrgn));

    return hrgn;
}

inline BOOL 
Region::IsEmpty(IN const Graphics *g) const
{
    BOOL booln = FALSE;
   
    SetStatus(DllExports::GdipIsEmptyRegion(nativeRegion,
                                            g->nativeGraphics,
                                            &booln));

    return booln;
}

inline BOOL 
Region::IsInfinite(IN const Graphics *g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsInfiniteRegion(nativeRegion,
                                                 g->nativeGraphics,
                                                 &booln));

    return booln;
}

inline BOOL 
Region::Equals(IN const Region* region, 
               IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsEqualRegion(nativeRegion,
                                              region->nativeRegion,
                                              g->nativeGraphics,
                                              &booln));
    return booln;
}

// Get the size of the buffer needed for the GetData method
inline UINT 
Region::GetDataSize() const
{
    UINT     bufferSize = 0;
    
    SetStatus(DllExports::GdipGetRegionDataSize(nativeRegion, &bufferSize));
    
    return bufferSize;
}

// buffer     - where to put the data
// bufferSize - how big the buffer is (should be at least as big as GetDataSize())
// sizeFilled - if not NULL, this is an OUT param that says how many bytes
//              of data were written to the buffer.
inline Status 
Region::GetData(OUT BYTE* buffer, 
                IN UINT bufferSize, 
                OUT UINT* sizeFilled) const
{
    return SetStatus(DllExports::GdipGetRegionData(nativeRegion, buffer, 
                                                   bufferSize, sizeFilled));
}

/**
 * Hit testing operations
 */
inline BOOL 
Region::IsVisible(IN const PointF& point, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionPoint(nativeRegion,
                                     point.X, point.Y, 
                                     (g == NULL) ? NULL : g->nativeGraphics,
                                     &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const RectF& rect, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionRect(nativeRegion, rect.X,
                                                    rect.Y, rect.Width,
                                                    rect.Height,
                                                    (g == NULL) ?
                                                      NULL : g->nativeGraphics,
                                                    &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const Point& point, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;


    SetStatus(DllExports::GdipIsVisibleRegionPointI(nativeRegion,
                                                   point.X,
                                                   point.Y,
                                                   (g == NULL) 
                                                    ? NULL : g->nativeGraphics,
                                                   &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const Rect& rect, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionRectI(nativeRegion,
                                                  rect.X,
                                                  rect.Y,
                                                  rect.Width,
                                                  rect.Height,
                                                  (g == NULL) 
                                                    ? NULL : g->nativeGraphics,
                                                  &booln));
    return booln;
}

inline UINT 
Region::GetRegionScansCount(IN const Matrix* matrix) const
{
    UINT count = 0;

    SetStatus(DllExports::GdipGetRegionScansCount(nativeRegion,
                                                  &count,
                                                  matrix->nativeMatrix));
    return count;
}

// If rects is NULL, return the count of rects in the region.
// Otherwise, assume rects is big enough to hold all the region rects
// and fill them in and return the number of rects filled in.
// The rects are returned in the units specified by the matrix
// (which is typically a world-to-device transform).
// Note that the number of rects returned can vary, depending on the
// matrix that is used.

inline Status 
Region::GetRegionScans(
    IN const Matrix* matrix,
    OUT RectF* rects,
    IN OUT INT* count) const
{
    return SetStatus(DllExports::GdipGetRegionScans(nativeRegion,
                                          rects,
                                          count,
                                          matrix->nativeMatrix));
}

inline Status
Region::GetRegionScans(
    IN const Matrix* matrix,
    OUT Rect* rects,
    IN OUT INT* count) const
{
    return SetStatus(DllExports::GdipGetRegionScansI(nativeRegion,
                                          rects,
                                          count,
                                          matrix->nativeMatrix));
}

inline Region::Region(GpRegion* nativeRegion)
{
    SetNativeRegion(nativeRegion);
}

inline VOID Region::SetNativeRegion(GpRegion* nativeRegion)
{
    this->nativeRegion = nativeRegion;
}

inline Status Region::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

#endif // !_GDIPLUSREGION_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusMetaFile.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusMetafile.h
*
* Abstract:
*
*   GDI+ Metafile class
*
\**************************************************************************/

#ifndef _GDIPLUSMETAFILE_H
#define _GDIPLUSMETAFILE_H

inline
Metafile::Metafile(
    IN HMETAFILE                      hWmf,
    IN const WmfPlaceableFileHeader * wmfPlaceableFileHeader,
    IN BOOL                           deleteWmf
    )
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipCreateMetafileFromWmf(hWmf, deleteWmf, 
                                                       wmfPlaceableFileHeader, 
                                                       &metafile);

    SetNativeImage(metafile);
};

inline    
Metafile::Metafile(
    IN HENHMETAFILE hEmf,
    IN BOOL deleteEmf
    )
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipCreateMetafileFromEmf(hEmf, deleteEmf, 
                                                       &metafile);

    SetNativeImage(metafile);
};

inline
Metafile::Metafile(IN const WCHAR* filename)
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipCreateMetafileFromFile(filename, 
                                                        &metafile);

    SetNativeImage(metafile);
};

inline
Metafile::Metafile(
    IN const WCHAR*                   filename,
    IN const WmfPlaceableFileHeader * wmfPlaceableFileHeader
    )
{
    GpMetafile *    metafile = NULL;
    
    lastResult = DllExports::GdipCreateMetafileFromWmfFile(filename, 
                                                           wmfPlaceableFileHeader, 
                                                           &metafile);
    
    SetNativeImage(metafile);
};

inline
Metafile::Metafile(IN IStream* stream)
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipCreateMetafileFromStream(stream, 
                                                          &metafile);

    SetNativeImage(metafile);
};

inline
Metafile::Metafile(
    IN HDC                 referenceHdc,
    IN EmfType             type,
    IN const WCHAR *       description
    )
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipRecordMetafile(
                    referenceHdc, type, NULL, MetafileFrameUnitGdi,
                    description, &metafile);

    SetNativeImage(metafile);
};

inline
Metafile::Metafile(
    IN HDC                 referenceHdc,
    IN const RectF &       frameRect,
    IN MetafileFrameUnit   frameUnit,
    IN EmfType             type,       
    IN const WCHAR *       description
    )
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipRecordMetafile(
                    referenceHdc, type, &frameRect, frameUnit,
                    description, &metafile);

    SetNativeImage(metafile);
};

inline
Metafile::Metafile(
    IN HDC                 referenceHdc,
    IN const Rect &        frameRect,
    IN MetafileFrameUnit   frameUnit,
    IN EmfType             type,
    IN const WCHAR *       description
    )
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipRecordMetafileI(
                    referenceHdc, type, &frameRect, frameUnit,
                    description, &metafile);

    SetNativeImage(metafile);
};

inline
Metafile::Metafile(
    IN const WCHAR*        fileName,
    IN HDC                 referenceHdc,
    IN EmfType             type,
    IN const WCHAR *       description
    )
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipRecordMetafileFileName(fileName,
                    referenceHdc, type, NULL, MetafileFrameUnitGdi,
                    description, &metafile);

    SetNativeImage(metafile);
};

inline
Metafile::Metafile(
    IN const WCHAR*        fileName,
    IN HDC                 referenceHdc,
    IN const RectF &       frameRect,
    IN MetafileFrameUnit   frameUnit,
    IN EmfType             type,
    IN const WCHAR *       description
    )
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipRecordMetafileFileName(fileName,
                    referenceHdc, type, &frameRect, frameUnit,
                    description, &metafile);

    SetNativeImage(metafile);
};

inline
Metafile::Metafile(
    IN const WCHAR*        fileName,
    IN HDC                 referenceHdc,
    IN const Rect &        frameRect,
    IN MetafileFrameUnit   frameUnit,
    IN EmfType             type,
    IN const WCHAR *       description
    )
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipRecordMetafileFileNameI(fileName,
                    referenceHdc, type, &frameRect, frameUnit,
                    description, &metafile);

    SetNativeImage(metafile);
};

inline
Metafile::Metafile(
    IN IStream *           stream,
    IN HDC                 referenceHdc,
    IN EmfType             type,
    IN const WCHAR *       description
    )
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipRecordMetafileStream(stream,
                    referenceHdc, type, NULL, MetafileFrameUnitGdi,
                    description, &metafile);

    SetNativeImage(metafile);
};

inline
Metafile::Metafile(
    IN IStream *           stream,
    IN HDC                 referenceHdc,
    IN const RectF &       frameRect,
    IN MetafileFrameUnit   frameUnit,
    IN EmfType             type,
    IN const WCHAR *       description
    )
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipRecordMetafileStream(stream,
                    referenceHdc, type, &frameRect, frameUnit,
                    description, &metafile);

    SetNativeImage(metafile);
};

inline
Metafile::Metafile(
    IN IStream *           stream,
    IN HDC                 referenceHdc,
    IN const Rect &        frameRect,
    IN MetafileFrameUnit   frameUnit,
    IN EmfType             type,
    IN const WCHAR *       description
    )
{
    GpMetafile *    metafile = NULL;

    lastResult = DllExports::GdipRecordMetafileStreamI(stream,
                    referenceHdc, type, &frameRect, frameUnit,
                    description, &metafile);

    SetNativeImage(metafile);
};

inline Status
Metafile::GetMetafileHeader(
    IN HMETAFILE                       hWmf,
    IN const WmfPlaceableFileHeader *  wmfPlaceableFileHeader,
    OUT MetafileHeader *               header
    )
{
    return DllExports::GdipGetMetafileHeaderFromWmf(hWmf,
                                                    wmfPlaceableFileHeader, 
                                                    header);
};

inline Status
Metafile::GetMetafileHeader(
    IN HENHMETAFILE        hEmf,
    OUT MetafileHeader *   header
    )
{
    return DllExports::GdipGetMetafileHeaderFromEmf(hEmf, header);
};

inline Status
Metafile::GetMetafileHeader(
    IN const WCHAR*        filename,
    OUT MetafileHeader *   header
    )
{
    return DllExports::GdipGetMetafileHeaderFromFile(filename, header);
};

inline Status
Metafile::GetMetafileHeader(
    IN IStream *           stream,
    OUT MetafileHeader *   header
    )
{
    return DllExports::GdipGetMetafileHeaderFromStream(stream, header);
};

inline Status
Metafile::GetMetafileHeader(
    OUT MetafileHeader *    header
    ) const
{
    return SetStatus(DllExports::GdipGetMetafileHeaderFromMetafile(
                                          (GpMetafile *)nativeImage,
                                          header));
};

// Once this method is called, the Metafile object is in an invalid state
// and can no longer be used.  It is the responsiblity of the caller to
// invoke DeleteEnhMetaFile to delete this hEmf.

inline HENHMETAFILE
Metafile::GetHENHMETAFILE()
{
    HENHMETAFILE hEmf;

    SetStatus(DllExports::GdipGetHemfFromMetafile(
                              (GpMetafile *)nativeImage, 
                              &hEmf));

    return hEmf;
};

// Used in conjuction with Graphics::EnumerateMetafile to play an EMF+
// The data must be DWORD aligned if it's an EMF or EMF+.  It must be
// WORD aligned if it's a WMF.

inline Status
Metafile::PlayRecord(
    IN EmfPlusRecordType   recordType,
    IN UINT                flags,
    IN UINT                dataSize,
    IN const BYTE *        data
    ) const
{
    return SetStatus(DllExports::GdipPlayMetafileRecord(
                            (GpMetafile *)nativeImage,
                            recordType,
                            flags,
                            dataSize,
                            data));
};

// If you're using a printer HDC for the metafile, but you want the
// metafile rasterized at screen resolution, then use this API to set
// the rasterization dpi of the metafile to the screen resolution,
// e.g. 96 dpi or 120 dpi.

inline Status
Metafile::SetDownLevelRasterizationLimit(
    IN UINT     metafileRasterizationLimitDpi
    )
{
    return SetStatus(DllExports::
                     GdipSetMetafileDownLevelRasterizationLimit(
                            (GpMetafile *)nativeImage,
                            metafileRasterizationLimitDpi));
};

inline UINT
Metafile::GetDownLevelRasterizationLimit() const
{
    UINT    metafileRasterizationLimitDpi = 0;

    SetStatus(DllExports::GdipGetMetafileDownLevelRasterizationLimit(
                            (GpMetafile *)nativeImage,
                            &metafileRasterizationLimitDpi));

    return metafileRasterizationLimitDpi;
};

inline UINT
Metafile::EmfToWmfBits(
    IN HENHMETAFILE       hemf,
    IN UINT               cbData16,
    OUT LPBYTE            pData16,
    IN INT                iMapMode,
    IN INT                eFlags
    )
{
    return DllExports::GdipEmfToWmfBits(
        hemf,
        cbData16,
        pData16,
        iMapMode,
        eFlags);
};

#if (GDIPVER >= 0x0110)
inline Status
Metafile::ConvertToEmfPlus(
    IN const Graphics* refGraphics,
    IN OUT INT* conversionFailureFlag,
    IN EmfType emfType,
    IN const WCHAR* description
    )
{
    GpMetafile * metafile = NULL;
    GpStatus status = DllExports::GdipConvertToEmfPlus(
        (GpGraphics*)refGraphics->nativeGraphics,
        (GpMetafile *)nativeImage,
        conversionFailureFlag,
        emfType, description, &metafile);

    if (metafile != NULL)
    {
        if (status == Ok)
        {
            DllExports::GdipDisposeImage(nativeImage);
            SetNativeImage(metafile);
        }
        else
        {
            DllExports::GdipDisposeImage(metafile);
        }
    }
    return status;
};

inline Status
Metafile::ConvertToEmfPlus(
    IN const Graphics* refGraphics,
    IN const WCHAR* filename, 
    IN OUT INT* conversionFailureFlag,
    IN EmfType emfType,
    IN const WCHAR* description
    )
{
    GpMetafile * metafile = NULL;
    GpStatus status = DllExports::GdipConvertToEmfPlusToFile(
        (GpGraphics*)refGraphics->nativeGraphics,
        (GpMetafile *)nativeImage,
        conversionFailureFlag,
        filename, emfType, description, &metafile);

    if (metafile != NULL)
    {
        if (status == Ok)
        {
            DllExports::GdipDisposeImage(nativeImage);
            SetNativeImage(metafile);
        }
        else
        {
            DllExports::GdipDisposeImage(metafile);
        }
    }
    return status;
};

inline Status
Metafile::ConvertToEmfPlus(
    IN const Graphics* refGraphics,
    IN IStream* stream, 
    IN OUT INT* conversionFailureFlag,
    IN EmfType emfType,
    IN const WCHAR* description
    )
{
    GpMetafile * metafile = NULL;
    GpStatus status = DllExports::GdipConvertToEmfPlusToStream(
        (GpGraphics*)refGraphics->nativeGraphics,
        (GpMetafile *)nativeImage,
        conversionFailureFlag,
        stream, emfType, description, &metafile);

    if (metafile != NULL)
    {
        if (status == Ok)
        {
            DllExports::GdipDisposeImage(nativeImage);
            SetNativeImage(metafile);
        }
        else
        {
            DllExports::GdipDisposeImage(metafile);
        }
    }
    return status;
};
#endif //(GDIPVER >= 0x0110)


#endif // !_METAFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusMetaHeader.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Metafile headers
*
* Abstract:
*
*   GDI+ Metafile Related Structures
*
\**************************************************************************/

#ifndef _GDIPLUSMETAHEADER_H
#define _GDIPLUSMETAHEADER_H

typedef struct
{
    DWORD   iType;              // Record type EMR_HEADER
    DWORD   nSize;              // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    RECTL   rclFrame;           // Inclusive-inclusive Picture Frame .01mm unit
    DWORD   dSignature;         // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Version number
    DWORD   nBytes;             // Size of the metafile in bytes
    DWORD   nRecords;           // Number of records in the metafile
    WORD    nHandles;           // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD    sReserved;          // Reserved.  Must be zero.
    DWORD   nDescription;       // Number of chars in the unicode desc string
                                // This is 0 if there is no description string
    DWORD   offDescription;     // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD   nPalEntries;        // Number of entries in the metafile palette.
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters
} ENHMETAHEADER3;

// Placeable WMFs

// Placeable Metafiles were created as a non-standard way of specifying how 
// a metafile is mapped and scaled on an output device.
// Placeable metafiles are quite wide-spread, but not directly supported by
// the Windows API. To playback a placeable metafile using the Windows API,
// you will first need to strip the placeable metafile header from the file.
// This is typically performed by copying the metafile to a temporary file
// starting at file offset 22 (0x16). The contents of the temporary file may
// then be used as input to the Windows GetMetaFile(), PlayMetaFile(),
// CopyMetaFile(), etc. GDI functions.

// Each placeable metafile begins with a 22-byte header,
//  followed by a standard metafile:

#include <pshpack2.h>   // set structure packing to 2

typedef struct
{
    INT16           Left;
    INT16           Top;
    INT16           Right;
    INT16           Bottom;
} PWMFRect16;

typedef struct
{
    UINT32          Key;            // GDIP_WMF_PLACEABLEKEY
    INT16           Hmf;            // Metafile HANDLE number (always 0)
    PWMFRect16      BoundingBox;    // Coordinates in metafile units
    INT16           Inch;           // Number of metafile units per inch
    UINT32          Reserved;       // Reserved (always 0)
    INT16           Checksum;       // Checksum value for previous 10 WORDs
} WmfPlaceableFileHeader;

#include <poppack.h>

// Key contains a special identification value that indicates the presence
// of a placeable metafile header and is always 0x9AC6CDD7.

// Handle is used to stored the handle of the metafile in memory. When written
// to disk, this field is not used and will always contains the value 0.

// Left, Top, Right, and Bottom contain the coordinates of the upper-left
// and lower-right corners of the image on the output device. These are
// measured in twips.

// A twip (meaning "twentieth of a point") is the logical unit of measurement
// used in Windows Metafiles. A twip is equal to 1/1440 of an inch. Thus 720
// twips equal 1/2 inch, while 32,768 twips is 22.75 inches.

// Inch contains the number of twips per inch used to represent the image.
// Normally, there are 1440 twips per inch; however, this number may be
// changed to scale the image. A value of 720 indicates that the image is
// double its normal size, or scaled to a factor of 2:1. A value of 360
// indicates a scale of 4:1, while a value of 2880 indicates that the image
// is scaled down in size by a factor of two. A value of 1440 indicates
// a 1:1 scale ratio.

// Reserved is not used and is always set to 0.

// Checksum contains a checksum value for the previous 10 WORDs in the header.
// This value can be used in an attempt to detect if the metafile has become
// corrupted. The checksum is calculated by XORing each WORD value to an
// initial value of 0.

// If the metafile was recorded with a reference Hdc that was a display.

#define GDIP_EMFPLUSFLAGS_DISPLAY       0x00000001

class MetafileHeader
{
public:
    MetafileType        Type;
    UINT                Size;               // Size of the metafile (in bytes)
    UINT                Version;            // EMF+, EMF, or WMF version
    UINT                EmfPlusFlags;
    REAL                DpiX;
    REAL                DpiY;
    INT                 X;                  // Bounds in device units
    INT                 Y;
    INT                 Width;
    INT                 Height;
    union
    {
        METAHEADER      WmfHeader;
        ENHMETAHEADER3  EmfHeader;
    };
    INT                 EmfPlusHeaderSize;  // size of the EMF+ header in file
    INT                 LogicalDpiX;        // Logical Dpi of reference Hdc
    INT                 LogicalDpiY;        // usually valid only for EMF+

public:
    MetafileType GetType() const { return Type; }

    UINT GetMetafileSize() const { return Size; }

    // If IsEmfPlus, this is the EMF+ version; else it is the WMF or EMF ver
    
    UINT GetVersion() const { return Version; }

    // Get the EMF+ flags associated with the metafile
    
    UINT GetEmfPlusFlags() const { return EmfPlusFlags; }

    REAL GetDpiX() const { return DpiX; }

    REAL GetDpiY() const { return DpiY; }

    VOID GetBounds (OUT Rect *rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }
    
    // Is it any type of WMF (standard or Placeable Metafile)?
    
    BOOL IsWmf() const
    {
       return ((Type == MetafileTypeWmf) || (Type == MetafileTypeWmfPlaceable));
    }

    // Is this an Placeable Metafile?

    BOOL IsWmfPlaceable() const { return (Type == MetafileTypeWmfPlaceable); }

    // Is this an EMF (not an EMF+)?
    
    BOOL IsEmf() const { return (Type == MetafileTypeEmf); }

    // Is this an EMF or EMF+ file?
    
    BOOL IsEmfOrEmfPlus() const { return (Type >= MetafileTypeEmf); }

    // Is this an EMF+ file?
    
    BOOL IsEmfPlus() const { return (Type >= MetafileTypeEmfPlusOnly); }

    // Is this an EMF+ dual (has dual, down-level records) file?
    
    BOOL IsEmfPlusDual() const { return (Type == MetafileTypeEmfPlusDual); }

    // Is this an EMF+ only (no dual records) file?
    
    BOOL IsEmfPlusOnly() const { return (Type == MetafileTypeEmfPlusOnly); }

    // If it's an EMF+ file, was it recorded against a display Hdc?
    
    BOOL IsDisplay() const
    {
        return (IsEmfPlus() &&
                ((EmfPlusFlags & GDIP_EMFPLUSFLAGS_DISPLAY) != 0));
    }

    // Get the WMF header of the metafile (if it is a WMF)
    
    const METAHEADER * GetWmfHeader() const
    {
        if (IsWmf())
        {
            return &WmfHeader;
        }
        return NULL;
    }

    // Get the EMF header of the metafile (if it is an EMF)
    
    const ENHMETAHEADER3 * GetEmfHeader() const
    {
        if (IsEmfOrEmfPlus())
        {
            return &EmfHeader;
        }
        return NULL;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GenLex.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    GENLEX.H

Abstract:

    Generic lexer framework classes.

History:

--*/

#ifndef _GENLEX_H_
#define _GENLEX_H_

#include <Polarity.h>

class CGenLexSource
{
public:
    virtual wchar_t NextChar() = 0;
        // Return 0 on end-of-input
    virtual void Pushback(wchar_t) = 0;
    virtual void Reset() = 0;
};

class CTextLexSource : public CGenLexSource
{
    const wchar_t *m_pSrcBuf;
    const wchar_t *m_pStart;

public:
    CTextLexSource(const wchar_t *pSrc) { SetString(pSrc); }
        // Binds directly to <pSrc> buffer, but doesn't delete it.

    wchar_t NextChar()
    {
        if (!m_pSrcBuf)
            return 0;
        else
            return *m_pSrcBuf++ ? m_pSrcBuf[-1] : 0;
    }

    void Pushback(wchar_t)
    {
        if (m_pSrcBuf)
            --m_pSrcBuf;
    }

    void Reset() { m_pSrcBuf = m_pStart; }
    void SetString (const wchar_t *pSrc) { m_pSrcBuf = m_pStart = pSrc; }
};


#pragma pack(2)
struct LexEl
{
    wchar_t cFirst, cLast;
    WORD wGotoState;
    WORD wReturnTok;
    WORD wInstructions;
};
#pragma pack()


// Lexer driver instructions

#define GLEX_ACCEPT      0x1            // Add the char to the token
#define GLEX_CONSUME     0x2            // Consume the char without adding to token
#define GLEX_PUSHBACK    0x4            // Place the char back in the source buffer for next token
#define GLEX_NOT         0x8            // A match occurs if the char is NOT the one specified
#define GLEX_LINEFEED    0x10               // Increase the source linecount
#define GLEX_RETURN      0x20               // Return the indicated token to caller
#define GLEX_ANY         wchar_t(0xFFFF)    // Any character
#define GLEX_EMPTY       wchar_t(0xFFFE)    // When subrange is not specified

class CGenLexer
{
    __field_ecount(m_nCurBufSize) wchar_t    *m_pTokenBuf;
    int         m_nCurrentLine;
    int         m_nCurBufSize;
    CGenLexSource   *m_pSrc;
    LexEl           *m_pTable;
    
public:
    CGenLexer(LexEl *pTbl, CGenLexSource *pSrc);
    
   ~CGenLexer(); 
    int NextToken();
        // Returns 0 on end of input.

    wchar_t* GetTokenText() { return m_pTokenBuf; }
    int GetLineNum() { return m_nCurrentLine; }
    void Reset();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusStringFormat.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusStringFormat.h
*
* Abstract:
*
*   GDI+ StringFormat class
*
\**************************************************************************/

#ifndef _GDIPLUSSTRINGFORMAT_H
#define _GDIPLUSSTRINGFORMAT_H

class StringFormat : public GdiplusBase
{
public:
    friend class Graphics;
    friend class GraphicsPath;


    StringFormat(
        IN INT     formatFlags = 0,
        IN LANGID  language = LANG_NEUTRAL
    )
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCreateStringFormat(
            formatFlags,
            language,
            &nativeFormat
        );
    }

    static const StringFormat *GenericDefault();
    static const StringFormat *GenericTypographic();

    StringFormat(
        IN const StringFormat *format
    )
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCloneStringFormat(
            format ? format->nativeFormat : NULL,
            &nativeFormat
        );
    }

    StringFormat *Clone() const
    {
        GpStringFormat *clonedStringFormat = NULL;

        lastError = DllExports::GdipCloneStringFormat(
            nativeFormat,
            &clonedStringFormat
        );

        if (lastError == Ok)
            return new StringFormat(clonedStringFormat, lastError);
        else
            return NULL;
    }

    ~StringFormat()
    {
        DllExports::GdipDeleteStringFormat(nativeFormat);
    }

    Status SetFormatFlags(IN INT flags)
    {
        return SetStatus(DllExports::GdipSetStringFormatFlags(
            nativeFormat,
            flags
        ));
    }

    INT GetFormatFlags() const
    {
        INT flags;
        SetStatus(DllExports::GdipGetStringFormatFlags(nativeFormat, &flags));
        return flags;
    }

    Status SetAlignment(IN StringAlignment align)
    {
        return SetStatus(DllExports::GdipSetStringFormatAlign(
            nativeFormat,
            align
        ));
    }

    StringAlignment GetAlignment() const
    {
        StringAlignment alignment;
        SetStatus(DllExports::GdipGetStringFormatAlign(
            nativeFormat,
            &alignment
        ));
        return alignment;
    }

    Status SetLineAlignment(IN StringAlignment align)
    {
        return SetStatus(DllExports::GdipSetStringFormatLineAlign(
            nativeFormat,
            align
        ));
    }

    StringAlignment GetLineAlignment() const
    {
        StringAlignment alignment;
        SetStatus(DllExports::GdipGetStringFormatLineAlign(
            nativeFormat,
            &alignment
        ));
        return alignment;
    }

    Status SetHotkeyPrefix(IN HotkeyPrefix hotkeyPrefix)
    {
        return SetStatus(DllExports::GdipSetStringFormatHotkeyPrefix(
            nativeFormat,
            (INT)hotkeyPrefix
        ));
    }

    HotkeyPrefix GetHotkeyPrefix() const
    {
        HotkeyPrefix hotkeyPrefix;
        SetStatus(DllExports::GdipGetStringFormatHotkeyPrefix(
            nativeFormat,
            (INT*)&hotkeyPrefix
        ));
        return hotkeyPrefix;
    }

    Status SetTabStops(
        IN REAL    firstTabOffset,
        IN INT     count,
        IN const REAL    *tabStops
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatTabStops(
            nativeFormat,
            firstTabOffset,
            count,
            tabStops
        ));
    }

    INT GetTabStopCount() const
    {
        INT count;
        SetStatus(DllExports::GdipGetStringFormatTabStopCount(nativeFormat, &count));
        return count;
    }

    Status GetTabStops(
        IN INT     count,
        OUT REAL   *firstTabOffset,
        OUT REAL   *tabStops
    ) const
    {
        return SetStatus(DllExports::GdipGetStringFormatTabStops(
            nativeFormat,
            count,
            firstTabOffset,
            tabStops
        ));
    }

    Status SetDigitSubstitution(
        IN LANGID                language,
        IN StringDigitSubstitute substitute
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatDigitSubstitution(
            nativeFormat,
            language,
            substitute
        ));
    }

    LANGID GetDigitSubstitutionLanguage(
    ) const
    {
        LANGID language;
        SetStatus(DllExports::GdipGetStringFormatDigitSubstitution(
            nativeFormat,
            &language,
            NULL
        ));
        return language;
    }

    StringDigitSubstitute GetDigitSubstitutionMethod(
    ) const
    {
        StringDigitSubstitute substitute;
        SetStatus(DllExports::GdipGetStringFormatDigitSubstitution(
            nativeFormat,
            NULL,
            &substitute
        ));
        return substitute;
    }

    Status SetTrimming(IN StringTrimming trimming)
    {
        return SetStatus(DllExports::GdipSetStringFormatTrimming(
            nativeFormat,
            trimming
        ));
    }

    StringTrimming StringFormat::GetTrimming() const
    {
        StringTrimming trimming;
        SetStatus(DllExports::GdipGetStringFormatTrimming(
            nativeFormat,
            &trimming
        ));
        return trimming;
    }

    Status SetMeasurableCharacterRanges(
        IN INT                  rangeCount,
        IN const CharacterRange *ranges
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatMeasurableCharacterRanges(
            nativeFormat,
            rangeCount,
            ranges
        ));
    }

    INT GetMeasurableCharacterRangeCount()
    {
        INT count;
        SetStatus(DllExports::GdipGetStringFormatMeasurableCharacterRangeCount(
            nativeFormat,
            &count
        ));
        return count;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastError;
        lastError = Ok;

        return lastStatus;
    }

protected:

    Status SetStatus(GpStatus newStatus) const
    {
        if (newStatus == Ok)
        {
            return Ok;
        }
        else
        {
            return lastError = newStatus;
        }
    }

    StringFormat(const StringFormat &source)
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCloneStringFormat(
            source.nativeFormat,
            &nativeFormat
        );
    }

    StringFormat& operator=(const StringFormat &source)
    {
        DllExports::GdipDeleteStringFormat(nativeFormat);
        lastError = DllExports::GdipCloneStringFormat(
            source.nativeFormat,
            &nativeFormat
        );
        return *this;
    }

    StringFormat(GpStringFormat * clonedStringFormat, Status status)
    {
        lastError = status;
        nativeFormat = clonedStringFormat;

    }

    GpStringFormat *nativeFormat;
    mutable Status  lastError;
};

static BYTE GenericTypographicStringFormatBuffer[sizeof(StringFormat)] = {0};
static BYTE GenericDefaultStringFormatBuffer[sizeof(StringFormat)] = {0};

inline const StringFormat *StringFormat::GenericDefault()
{
    StringFormat * genericDefaultStringFormat =
        (StringFormat*)GenericDefaultStringFormatBuffer;

    genericDefaultStringFormat->lastError =
        DllExports::GdipStringFormatGetGenericDefault(
            &(genericDefaultStringFormat->nativeFormat)
        );

    return genericDefaultStringFormat;
}

inline const StringFormat *StringFormat::GenericTypographic()
{
    StringFormat * genericTypographicStringFormat =
        (StringFormat*)GenericTypographicStringFormatBuffer;

    genericTypographicStringFormat->lastError =
        DllExports::GdipStringFormatGetGenericTypographic(
            &genericTypographicStringFormat->nativeFormat
        );

    return genericTypographicStringFormat;
}

#endif // !_GDIPLUSSTRINGFORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Guiddef.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       guiddef.h
//
//  Contents:   GUID definition
//
//----------------------------------------------------------------------------

#ifndef GUID_DEFINED
#define GUID_DEFINED
#if defined(__midl)
typedef struct {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    byte           Data4[ 8 ];
} GUID;
#else
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
} GUID;
#endif
#endif

#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
#define EXTERN_C    extern "C"
#else
#define EXTERN_C    extern
#endif
#endif

#ifdef DEFINE_GUID
#undef DEFINE_GUID
#endif

#ifdef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#endif // INITGUID

#define DEFINE_OLEGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

#ifndef _GUIDDEF_H_
#define _GUIDDEF_H_

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef GUID IID;
typedef IID *LPIID;
#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
typedef GUID CLSID;
typedef CLSID *LPCLSID;
#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)
typedef GUID FMTID;
typedef FMTID *LPFMTID;
#define FMTID_NULL          GUID_NULL
#define IsEqualFMTID(rfmtid1, rfmtid2) IsEqualGUID(rfmtid1, rfmtid2)

#ifdef __midl_proxy
#define __MIDL_CONST
#else
#define __MIDL_CONST const
#endif

#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#ifdef __cplusplus
#define REFGUID const GUID &
#else
#define REFGUID const GUID * __MIDL_CONST
#endif
#endif

#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#ifdef __cplusplus
#define REFIID const IID &
#else
#define REFIID const IID * __MIDL_CONST
#endif
#endif

#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#ifdef __cplusplus
#define REFCLSID const IID &
#else
#define REFCLSID const IID * __MIDL_CONST
#endif
#endif

#ifndef _REFFMTID_DEFINED
#define _REFFMTID_DEFINED
#ifdef __cplusplus
#define REFFMTID const IID &
#else
#define REFFMTID const IID * __MIDL_CONST
#endif
#endif

#endif // !__IID_DEFINED__

#if !defined (__midl)
#if !defined (_SYS_GUID_OPERATORS_)
#define _SYS_GUID_OPERATORS_
#include <string.h>

// Faster (but makes code fatter) inline version...use sparingly
#ifdef __cplusplus
__inline int InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}

__inline int IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}

#else   // ! __cplusplus

#define InlineIsEqualGUID(rguid1, rguid2)  \
        (((unsigned long *) rguid1)[0] == ((unsigned long *) rguid2)[0] &&   \
        ((unsigned long *) rguid1)[1] == ((unsigned long *) rguid2)[1] &&    \
        ((unsigned long *) rguid1)[2] == ((unsigned long *) rguid2)[2] &&    \
        ((unsigned long *) rguid1)[3] == ((unsigned long *) rguid2)[3])

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

#endif  // __cplusplus

#ifdef __INLINE_ISEQUAL_GUID
#undef IsEqualGUID
#define IsEqualGUID(rguid1, rguid2) InlineIsEqualGUID(rguid1, rguid2)
#endif

// Same type, different name

#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


#if !defined _SYS_GUID_OPERATOR_EQ_ && !defined _NO_SYS_GUID_OPERATOR_EQ_
#define _SYS_GUID_OPERATOR_EQ_
// A couple of C++ helpers

#ifdef __cplusplus
__inline int operator==(REFGUID guidOne, REFGUID guidOther)
{
    return IsEqualGUID(guidOne,guidOther);
}

__inline int operator!=(REFGUID guidOne, REFGUID guidOther)
{
    return !(guidOne == guidOther);
}
#endif
#endif  // _SYS_GUID_OPERATOR_EQ_
#endif  // _SYS_GUID_OPERATORS_
#endif  // __midl
#endif  // _GUIDDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\highlevelmonitorconfigurationapi.h ===
#ifndef HighLevelMonitorConfigurationAPI_h
#define HighLevelMonitorConfigurationAPI_h

#include <windows.h>
#include <PhysicalMonitorEnumerationAPI.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus 

#pragma pack( push, 1  )

/******************************************************************************
    Flags
******************************************************************************/
#define MC_CAPS_NONE                                            0x00000000
#define MC_CAPS_MONITOR_TECHNOLOGY_TYPE                         0x00000001
#define MC_CAPS_BRIGHTNESS                                      0x00000002  
#define MC_CAPS_CONTRAST                                        0x00000004
#define MC_CAPS_COLOR_TEMPERATURE                               0x00000008
#define MC_CAPS_RED_GREEN_BLUE_GAIN                             0x00000010
#define MC_CAPS_RED_GREEN_BLUE_DRIVE                            0x00000020
#define MC_CAPS_DEGAUSS                                         0x00000040
#define MC_CAPS_DISPLAY_AREA_POSITION                           0x00000080
#define MC_CAPS_DISPLAY_AREA_SIZE                               0x00000100
#define MC_CAPS_RESTORE_FACTORY_DEFAULTS                        0x00000400
#define MC_CAPS_RESTORE_FACTORY_COLOR_DEFAULTS                  0x00000800
#define MC_RESTORE_FACTORY_DEFAULTS_ENABLES_MONITOR_SETTINGS    0x00001000          

#define MC_SUPPORTED_COLOR_TEMPERATURE_NONE                     0x00000000
#define MC_SUPPORTED_COLOR_TEMPERATURE_4000K                    0x00000001
#define MC_SUPPORTED_COLOR_TEMPERATURE_5000K                    0x00000002
#define MC_SUPPORTED_COLOR_TEMPERATURE_6500K                    0x00000004
#define MC_SUPPORTED_COLOR_TEMPERATURE_7500K                    0x00000008
#define MC_SUPPORTED_COLOR_TEMPERATURE_8200K                    0x00000010
#define MC_SUPPORTED_COLOR_TEMPERATURE_9300K                    0x00000020
#define MC_SUPPORTED_COLOR_TEMPERATURE_10000K                   0x00000040
#define MC_SUPPORTED_COLOR_TEMPERATURE_11500K                   0x00000080

/******************************************************************************
    Enumerations
******************************************************************************/
typedef enum _MC_DISPLAY_TECHNOLOGY_TYPE
{
    MC_SHADOW_MASK_CATHODE_RAY_TUBE,
    MC_APERTURE_GRILL_CATHODE_RAY_TUBE,
    MC_THIN_FILM_TRANSISTOR,
    MC_LIQUID_CRYSTAL_ON_SILICON,
    MC_PLASMA,
    MC_ORGANIC_LIGHT_EMITTING_DIODE,
    MC_ELECTROLUMINESCENT,
    MC_MICROELECTROMECHANICAL,
    MC_FIELD_EMISSION_DEVICE

} MC_DISPLAY_TECHNOLOGY_TYPE, *LPMC_DISPLAY_TECHNOLOGY_TYPE;

typedef enum _MC_DRIVE_TYPE
{
    MC_RED_DRIVE,
    MC_GREEN_DRIVE,
    MC_BLUE_DRIVE

} MC_DRIVE_TYPE;

typedef enum _MC_GAIN_TYPE
{
    MC_RED_GAIN,
    MC_GREEN_GAIN,
    MC_BLUE_GAIN

} MC_GAIN_TYPE;

typedef enum _MC_POSITION_TYPE
{
    MC_HORIZONTAL_POSITION,
    MC_VERTICAL_POSITION 

} MC_POSITION_TYPE;

typedef enum _MC_SIZE_TYPE
{
    MC_WIDTH,
    MC_HEIGHT

} MC_SIZE_TYPE;

typedef enum _MC_COLOR_TEMPERATURE
{
    MC_COLOR_TEMPERATURE_UNKNOWN,
    MC_COLOR_TEMPERATURE_4000K, 
    MC_COLOR_TEMPERATURE_5000K, 
    MC_COLOR_TEMPERATURE_6500K, 
    MC_COLOR_TEMPERATURE_7500K, 
    MC_COLOR_TEMPERATURE_8200K, 
    MC_COLOR_TEMPERATURE_9300K, 
    MC_COLOR_TEMPERATURE_10000K,
    MC_COLOR_TEMPERATURE_11500K
    
} MC_COLOR_TEMPERATURE, *LPMC_COLOR_TEMPERATURE;

/******************************************************************************
    Monitor capability functions 
******************************************************************************/
_BOOL WINAPI GetMonitorCapabilities
    ( 
    HANDLE hMonitor, 
    __out LPDWORD pdwMonitorCapabilities, 
    __out LPDWORD pdwSupportedColorTemperatures 
    );

/******************************************************************************
    Monitor setting persistence functions 
******************************************************************************/
_BOOL WINAPI SaveCurrentMonitorSettings( HANDLE hMonitor );

/******************************************************************************
    Monitor meta-data functions
******************************************************************************/
_BOOL WINAPI GetMonitorTechnologyType( HANDLE hMonitor, LPMC_DISPLAY_TECHNOLOGY_TYPE pdtyDisplayTechnologyType );

/******************************************************************************
    Monitor image calibration functions 
******************************************************************************/
_BOOL WINAPI GetMonitorBrightness
    ( 
    HANDLE hMonitor, 
    __out LPDWORD pdwMinimumBrightness, 
    __out LPDWORD pdwCurrentBrightness, 
    __out LPDWORD pdwMaximumBrightness 
    );
_BOOL WINAPI GetMonitorContrast
    ( 
    HANDLE hMonitor, 
    __out LPDWORD pdwMinimumContrast, 
    __out LPDWORD pdwCurrentContrast, 
    __out LPDWORD pdwMaximumContrast 
    );
_BOOL WINAPI GetMonitorColorTemperature( HANDLE hMonitor, __out LPMC_COLOR_TEMPERATURE pctCurrentColorTemperature );
_BOOL WINAPI GetMonitorRedGreenOrBlueDrive
    ( 
    HANDLE hMonitor, 
    MC_DRIVE_TYPE dtDriveType, 
    __out LPDWORD pdwMinimumDrive,
    __out LPDWORD pdwCurrentDrive,
    __out LPDWORD pdwMaximumDrive
    );
_BOOL WINAPI GetMonitorRedGreenOrBlueGain
    ( 
    HANDLE hMonitor, 
    MC_GAIN_TYPE gtGainType, 
    __out LPDWORD pdwMinimumGain,
    __out LPDWORD pdwCurrentGain,
    __out LPDWORD pdwMaximumGain
    );

_BOOL WINAPI SetMonitorBrightness( HANDLE hMonitor, DWORD dwNewBrightness );
_BOOL WINAPI SetMonitorContrast( HANDLE hMonitor, DWORD dwNewContrast );
_BOOL WINAPI SetMonitorColorTemperature( HANDLE hMonitor, MC_COLOR_TEMPERATURE ctCurrentColorTemperature );
_BOOL WINAPI SetMonitorRedGreenOrBlueDrive( HANDLE hMonitor, MC_DRIVE_TYPE dtDriveType, DWORD dwNewDrive );
_BOOL WINAPI SetMonitorRedGreenOrBlueGain( HANDLE hMonitor, MC_GAIN_TYPE gtGainType, DWORD dwNewGain );
_BOOL WINAPI DegaussMonitor( HANDLE hMonitor );

/******************************************************************************
    Monitor image size and position calibration functions 
******************************************************************************/
_BOOL WINAPI GetMonitorDisplayAreaSize
    ( 
    HANDLE hMonitor, 
    MC_SIZE_TYPE stSizeType,
    __out LPDWORD pdwMinimumWidthOrHeight,
    __out LPDWORD pdwCurrentWidthOrHeight,
    __out LPDWORD pdwMaximumWidthOrHeight
    );
_BOOL WINAPI GetMonitorDisplayAreaPosition
    ( 
    HANDLE hMonitor, 
    MC_POSITION_TYPE ptPositionType, 
    __out LPDWORD pdwMinimumPosition,
    __out LPDWORD pdwCurrentPosition,
    __out LPDWORD pdwMaximumPosition
    );
_BOOL WINAPI SetMonitorDisplayAreaSize
    (
    HANDLE hMonitor,
    MC_SIZE_TYPE stSizeType,
    DWORD dwNewDisplayAreaWidthOrHeight
    );
_BOOL WINAPI SetMonitorDisplayAreaPosition
    (
    HANDLE hMonitor,
    MC_POSITION_TYPE ptPositionType, 
    DWORD dwNewPosition
    );

/******************************************************************************
    Restore to defaults functions
******************************************************************************/
_BOOL WINAPI RestoreMonitorFactoryColorDefaults( HANDLE hMonitor );
_BOOL WINAPI RestoreMonitorFactoryDefaults( HANDLE hMonitor );

#pragma pack( pop )

#ifdef __cplusplus
}
#endif // __cplusplus 
 
#endif // HighLevelMonitorConfigurationAPI_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\HlGuids.h ===
/****************************************************************************
    hlguids.h

    Copyright (c) 1995-1998 Microsoft Corporation

    This file defines or declares (according to standard DEFINE_GUID protocol)
    the GUIDs used to interact with hyperlinks.

    NOTE: This header file is used by non-Office as well as Office parties to
    access functionality provided by hlink dll and hlinkprx dll.
****************************************************************************/

#ifndef HLGUIDS_H
#define HLGUIDS_H

/****************************************************************************
    hlink GUIDs
****************************************************************************/

// On Windows, we get these from uuid3.lib
#if MAC

/* 79eac9c0-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IBinding,
    0x79eac9c0,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c1-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IBindStatusCallback,
    0x79eac9c1,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c9-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IPersistMoniker,
    0x79eac9c9,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

#endif /* MAC */

/* 79eac9c2-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlinkSite,
    0x79eac9c2,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c3-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlink,
    0x79eac9c3,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c4-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlinkTarget,
    0x79eac9c4,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c5-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlinkFrame,
    0x79eac9c5,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c6-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IEnumHLITEM,
    0x79eac9c6,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c7-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlinkBrowseContext,
    0x79eac9c7,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9cb-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IExtensionServices,
    0x79eac9cb,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9d0-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(CLSID_StdHlink,
    0x79eac9d0,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9d1-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(CLSID_StdHlinkBrowseContext,
    0x79eac9d1,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* The GUID of the service SID_SHlinkFrame is the same as IID_IHlinkFrame */
/* 79eac9c5-baf9-11ce-8c82-00aa004ba90b */
#ifndef SID_SHlinkFrame                   /* Usually #defined in hlink.h */
DEFINE_GUID(SID_SHlinkFrame,
    0x79eac9c5,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);
#endif /* ! SID_SHlinkFrame */

/* The GUID of the service SID_SContainer */
/* 79eac9c4-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(SID_SContainer,
    0x79eac9c4,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);
#endif // HLGUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GdiPlusTypes.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusTypes.h
*
* Abstract:
*
*   GDI+ Types
*
\**************************************************************************/

#ifndef _GDIPLUSTYPES_H
#define _GDIPLUSTYPES_H

//--------------------------------------------------------------------------
// Callback functions
//--------------------------------------------------------------------------

extern "C" {
typedef BOOL (CALLBACK * ImageAbort)(VOID *);
typedef ImageAbort DrawImageAbort;
typedef ImageAbort GetThumbnailImageAbort;
}

// Callback for EnumerateMetafile methods.  The parameters are:

//      recordType      WMF, EMF, or EMF+ record type
//      flags           (always 0 for WMF/EMF records)
//      dataSize        size of the record data (in bytes), or 0 if no data
//      data            pointer to the record data, or NULL if no data
//      callbackData    pointer to callbackData, if any

// This method can then call Metafile::PlayRecord to play the
// record that was just enumerated.  If this method  returns
// FALSE, the enumeration process is aborted.  Otherwise, it continues.

extern "C" {
typedef BOOL (CALLBACK * EnumerateMetafileProc)(EmfPlusRecordType,UINT,UINT,const BYTE*,VOID*);
}

#if (GDIPVER >= 0x0110)
// This is the main GDI+ Abort interface

struct __declspec(novtable) GdiplusAbort
{
    virtual HRESULT __stdcall Abort(void) = 0;
};
#endif //(GDIPVER >= 0x0110)

//--------------------------------------------------------------------------
// Primitive data types
//
// NOTE:
//  Types already defined in standard header files:
//      INT8
//      UINT8
//      INT16
//      UINT16
//      INT32
//      UINT32
//      INT64
//      UINT64
//
//  Avoid using the following types:
//      LONG - use INT
//      ULONG - use UINT
//      DWORD - use UINT32
//--------------------------------------------------------------------------

typedef float REAL;

#define REAL_MAX            FLT_MAX
#define REAL_MIN            FLT_MIN
#define REAL_TOLERANCE     (FLT_MIN * 100)
#define REAL_EPSILON        1.192092896e-07F        /* FLT_EPSILON */

//--------------------------------------------------------------------------
// Forward declarations of common classes
//--------------------------------------------------------------------------

class Size;
class SizeF;
class Point;
class PointF;
class Rect;
class RectF;
class CharacterRange;

//--------------------------------------------------------------------------
// Status return values from GDI+ methods
//--------------------------------------------------------------------------

enum Status
{
    Ok = 0,
    GenericError = 1,
    InvalidParameter = 2,
    OutOfMemory = 3,
    ObjectBusy = 4,
    InsufficientBuffer = 5,
    NotImplemented = 6,
    Win32Error = 7,
    WrongState = 8,
    Aborted = 9,
    FileNotFound = 10,
    ValueOverflow = 11,
    AccessDenied = 12,
    UnknownImageFormat = 13,
    FontFamilyNotFound = 14,
    FontStyleNotFound = 15,
    NotTrueTypeFont = 16,
    UnsupportedGdiplusVersion = 17,
    GdiplusNotInitialized = 18,
    PropertyNotFound = 19,
    PropertyNotSupported = 20,
#if (GDIPVER >= 0x0110)
    ProfileNotFound = 21,
#endif //(GDIPVER >= 0x0110)
};

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system (floating-point coordinates)
//--------------------------------------------------------------------------

class SizeF
{
public:
    SizeF()
    {
        Width = Height = 0.0f;
    }

    SizeF(IN const SizeF& size)
    {
        Width = size.Width;
        Height = size.Height;
    }

    SizeF(IN REAL width,
          IN REAL height)
    {
        Width = width;
        Height = height;
    }

    SizeF operator+(IN const SizeF& sz) const
    {
        return SizeF(Width + sz.Width,
                     Height + sz.Height);
    }

    SizeF operator-(IN const SizeF& sz) const
    {
        return SizeF(Width - sz.Width,
                     Height - sz.Height);
    }

    BOOL Equals(IN const SizeF& sz) const
    {
        return (Width == sz.Width) && (Height == sz.Height);
    }

    BOOL Empty() const
    {
        return (Width == 0.0f && Height == 0.0f);
    }

public:

    REAL Width;
    REAL Height;
};

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system (integer coordinates)
//--------------------------------------------------------------------------

class Size
{
public:
    Size()
    {
        Width = Height = 0;
    }

    Size(IN const Size& size)
    {
        Width = size.Width;
        Height = size.Height;
    }

    Size(IN INT width,
         IN INT height)
    {
        Width = width;
        Height = height;
    }

    Size operator+(IN const Size& sz) const
    {
        return Size(Width + sz.Width,
                    Height + sz.Height);
    }

    Size operator-(IN const Size& sz) const
    {
        return Size(Width - sz.Width,
                    Height - sz.Height);
    }

    BOOL Equals(IN const Size& sz) const
    {
        return (Width == sz.Width) && (Height == sz.Height);
    }

    BOOL Empty() const
    {
        return (Width == 0 && Height == 0);
    }

public:

    INT Width;
    INT Height;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system (floating-point coordinates)
//--------------------------------------------------------------------------

class PointF
{
public:
   PointF()
   {
       X = Y = 0.0f;
   }

   PointF(IN const PointF &point)
   {
       X = point.X;
       Y = point.Y;
   }

   PointF(IN const SizeF &size)
   {
       X = size.Width;
       Y = size.Height;
   }

   PointF(IN REAL x,
          IN REAL y)
   {
       X = x;
       Y = y;
   }

   PointF operator+(IN const PointF& point) const
   {
       return PointF(X + point.X,
                     Y + point.Y);
   }

   PointF operator-(IN const PointF& point) const
   {
       return PointF(X - point.X,
                     Y - point.Y);
   }

   BOOL Equals(IN const PointF& point)
   {
       return (X == point.X) && (Y == point.Y);
   }

public:

    REAL X;
    REAL Y;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system (integer coordinates)
//--------------------------------------------------------------------------

class Point
{
public:
   Point()
   {
       X = Y = 0;
   }

   Point(IN const Point &point)
   {
       X = point.X;
       Y = point.Y;
   }

   Point(IN const Size &size)
   {
       X = size.Width;
       Y = size.Height;
   }

   Point(IN INT x,
         IN INT y)
   {
       X = x;
       Y = y;
   }

   Point operator+(IN const Point& point) const
   {
       return Point(X + point.X,
                    Y + point.Y);
   }

   Point operator-(IN const Point& point) const
   {
       return Point(X - point.X,
                    Y - point.Y);
   }

   BOOL Equals(IN const Point& point)
   {
       return (X == point.X) && (Y == point.Y);
   }

public:

    INT X;
    INT Y;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system (floating-point coordinates)
//--------------------------------------------------------------------------

class RectF
{
public:

    RectF()
    {
        X = Y = Width = Height = 0.0f;
    }

    RectF(IN REAL x,
          IN REAL y,
          IN REAL width,
          IN REAL height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    RectF(IN const PointF& location,
          IN const SizeF& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    RectF* Clone() const
    {
        return new RectF(X, Y, Width, Height);
    }

    VOID GetLocation(OUT PointF* point) const
    {
        point->X = X;
        point->Y = Y;
    }

    VOID GetSize(OUT SizeF* size) const
    {
        size->Width = Width;
        size->Height = Height;
    }

    VOID GetBounds(OUT RectF* rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }

    REAL GetLeft() const
    {
        return X;
    }

    REAL GetTop() const
    {
        return Y;
    }

    REAL GetRight() const
    {
        return X+Width;
    }

    REAL GetBottom() const
    {
        return Y+Height;
    }

    BOOL IsEmptyArea() const
    {
        return (Width <= REAL_EPSILON) || (Height <= REAL_EPSILON);
    }

    BOOL Equals(IN const RectF & rect) const
    {
        return X == rect.X &&
               Y == rect.Y &&
               Width == rect.Width &&
               Height == rect.Height;
    }

    BOOL Contains(IN REAL x,
                  IN REAL y) const
    {
        return x >= X && x < X+Width &&
               y >= Y && y < Y+Height;
    }

    BOOL Contains(IN const PointF& pt) const
    {
        return Contains(pt.X, pt.Y);
    }

    BOOL Contains(IN const RectF& rect) const
    {
        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&
               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom());
    }

    VOID Inflate(IN REAL dx,
                 IN REAL dy)
    {
        X -= dx;
        Y -= dy;
        Width += 2*dx;
        Height += 2*dy;
    }

    VOID Inflate(IN const PointF& point)
    {
        Inflate(point.X, point.Y);
    }

    BOOL Intersect(IN const RectF& rect)
    {
        return Intersect(*this, *this, rect);
    }

    static BOOL Intersect(OUT RectF& c,
                          IN const RectF& a,
                          IN const RectF& b)
    {
        REAL right = min(a.GetRight(), b.GetRight());
        REAL bottom = min(a.GetBottom(), b.GetBottom());
        REAL left = max(a.GetLeft(), b.GetLeft());
        REAL top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    BOOL IntersectsWith(IN const RectF& rect) const
    {
        return (GetLeft() < rect.GetRight() &&
                GetTop() < rect.GetBottom() &&
                GetRight() > rect.GetLeft() &&
                GetBottom() > rect.GetTop());
    }

    static BOOL Union(OUT RectF& c,
                      IN const RectF& a,
                      IN const RectF& b)
    {
        REAL right = max(a.GetRight(), b.GetRight());
        REAL bottom = max(a.GetBottom(), b.GetBottom());
        REAL left = min(a.GetLeft(), b.GetLeft());
        REAL top = min(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    VOID Offset(IN const PointF& point)
    {
        Offset(point.X, point.Y);
    }

    VOID Offset(IN REAL dx,
                IN REAL dy)
    {
        X += dx;
        Y += dy;
    }

public:

    REAL X;
    REAL Y;
    REAL Width;
    REAL Height;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system (integer coordinates)
//--------------------------------------------------------------------------

class Rect
{
public:

    Rect()
    {
        X = Y = Width = Height = 0;
    }

    Rect(IN INT x,
         IN INT y,
         IN INT width,
         IN INT height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    Rect(IN const Point& location,
         IN const Size& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    Rect* Clone() const
    {
        return new Rect(X, Y, Width, Height);
    }

    VOID GetLocation(OUT Point* point) const
    {
        point->X = X;
        point->Y = Y;
    }

    VOID GetSize(OUT Size* size) const
    {
        size->Width = Width;
        size->Height = Height;
    }

    VOID GetBounds(OUT Rect* rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }

    INT GetLeft() const
    {
        return X;
    }

    INT GetTop() const
    {
        return Y;
    }

    INT GetRight() const
    {
        return X+Width;
    }

    INT GetBottom() const
    {
        return Y+Height;
    }

    BOOL IsEmptyArea() const
    {
        return (Width <= 0) || (Height <= 0);
    }

    BOOL Equals(IN const Rect & rect) const
    {
        return X == rect.X &&
               Y == rect.Y &&
               Width == rect.Width &&
               Height == rect.Height;
    }

    BOOL Contains(IN INT x,
                  IN INT y) const
    {
        return x >= X && x < X+Width &&
               y >= Y && y < Y+Height;
    }

    BOOL Contains(IN const Point& pt) const
    {
        return Contains(pt.X, pt.Y);
    }

    BOOL Contains(IN Rect& rect) const
    {
        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&
               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom());
    }

    VOID Inflate(IN INT dx,
                 IN INT dy)
    {
        X -= dx;
        Y -= dy;
        Width += 2*dx;
        Height += 2*dy;
    }

    VOID Inflate(IN const Point& point)
    {
        Inflate(point.X, point.Y);
    }

    BOOL Intersect(IN const Rect& rect)
    {
        return Intersect(*this, *this, rect);
    }

    static BOOL Intersect(OUT Rect& c,
                          IN const Rect& a,
                          IN const Rect& b)
    {
        INT right = min(a.GetRight(), b.GetRight());
        INT bottom = min(a.GetBottom(), b.GetBottom());
        INT left = max(a.GetLeft(), b.GetLeft());
        INT top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    BOOL IntersectsWith(IN const Rect& rect) const
    {
        return (GetLeft() < rect.GetRight() &&
                GetTop() < rect.GetBottom() &&
                GetRight() > rect.GetLeft() &&
                GetBottom() > rect.GetTop());
    }

    static BOOL Union(OUT Rect& c,
                      IN const Rect& a,
                      IN const Rect& b)
    {
        INT right = max(a.GetRight(), b.GetRight());
        INT bottom = max(a.GetBottom(), b.GetBottom());
        INT left = min(a.GetLeft(), b.GetLeft());
        INT top = min(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    VOID Offset(IN const Point& point)
    {
        Offset(point.X, point.Y);
    }

    VOID Offset(IN INT dx,
                IN INT dy)
    {
        X += dx;
        Y += dy;
    }

public:

    INT X;
    INT Y;
    INT Width;
    INT Height;
};

class PathData
{
public:
    PathData()
    {
        Count = 0;
        Points = NULL;
        Types = NULL;
    }

    ~PathData()
    {
        if (Points != NULL)
        {
            delete [] Points;
        }

        if (Types != NULL)
        {
            delete [] Types;
        }
    }

private:
    PathData(const PathData &);
    PathData& operator=(const PathData &);

public:
    INT Count;
    PointF* Points;
    __field_ecount_opt(Count) BYTE* Types;
};

class CharacterRange
{
public:
    CharacterRange(
        INT first,
        INT length
    ) :
        First   (first),
        Length  (length)
    {}

    CharacterRange() : First(0), Length(0)
    {}

    CharacterRange & operator = (const CharacterRange &rhs)
    {
        First  = rhs.First;
        Length = rhs.Length;
        return *this;
    }

    INT First;
    INT Length;
};

#endif // !_GDIPLUSTYPES_HPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\GPEdit.h ===
//-----------------------------------------------------------------------------
//
// GPEDIT.H - Definitions and prototypes for Group Policy
//
// Copyright 1997-2000, Microsoft Corporation
//
//-----------------------------------------------------------------------------

//
// Terminology
//
// Group Policy Editor  -  The tool to view a Group Policy Object.
//
// Group Policy Object  -  A collection of administrator defined policies.
//                         Each Group Policy Object (GPO) has both file system
//                         and Active Directory storage available to it.
//
// IGPEInformation      -  The interface MMC Snapin Extensions use to
//                         talk to the Group Policy Editor.
//
// IGroupPolicyObject   -  The interface used to create/edit a GPO directly
//                         without going through the Group Policy Editor
//


//
// Group Policy Editor MMC SnapIn GUID
//
// {8FC0B734-A0E1-11d1-A7D3-0000F87571E3}

DEFINE_GUID(CLSID_GPESnapIn, 0x8fc0b734, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Group Policy Editor node ids
//

//
// Computer Configuration\Windows Settings
// {8FC0B737-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_Machine, 0x8fc0b737, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Computer Configuration\Software Settings
// {8FC0B73A-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_MachineSWSettings, 0x8fc0b73a, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// User Configuration\Windows Settings
// {8FC0B738-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_User, 0x8fc0b738, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// User Configuration\Software Settings
// {8FC0B73C-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_UserSWSettings, 0x8fc0b73c, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// IGPEInformation interface id
//
// {8FC0B735-A0E1-11d1-A7D3-0000F87571E3}

DEFINE_GUID(IID_IGPEInformation, 0x8fc0b735, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Group Policy Object class id
//
// {EA502722-A23D-11d1-A7D3-0000F87571E3}

DEFINE_GUID(CLSID_GroupPolicyObject, 0xea502722, 0xa23d, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Group Policy Object interface id
//
// {EA502723-A23D-11d1-A7D3-0000F87571E3}

DEFINE_GUID(IID_IGroupPolicyObject, 0xea502723, 0xa23d, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// GUID that identifies the registry extension
//

#define REGISTRY_EXTENSION_GUID  { 0x35378EAC, 0x683F, 0x11D2, 0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2 }



//========================================================================================
//
// Resultant Set of Policy node ids
//
//========================================================================================

//
// Resultant Set of Policy MMC SnapIn GUID
//
// {6DC3804B-7212-458D-ADB0-9A07E2AE1FA2}

DEFINE_GUID(CLSID_RSOPSnapIn, 0x6dc3804b, 0x7212, 0x458d, 0xad, 0xb0, 0x9a, 0x07, 0xe2, 0xae, 0x1f, 0xa2);


//
// Computer Configuration\Windows Settings
// {BD4C1A2E-0B7A-4A62-A6B0-C0577539C97E}
//

DEFINE_GUID(NODEID_RSOPMachine, 0xbd4c1a2e, 0x0b7a, 0x4a62, 0xa6, 0xb0, 0xc0, 0x57, 0x75, 0x39, 0xc9, 0x7e);


//
// Computer Configuration\Software Settings
// {6A76273E-EB8E-45DB-94C5-25663A5f2C1A}
//

DEFINE_GUID(NODEID_RSOPMachineSWSettings, 0x6a76273e, 0xeb8e, 0x45db, 0x94, 0xc5, 0x25, 0x66, 0x3a, 0x5f, 0x2c, 0x1a);


//
// User Configuration\Windows Settings
// {AB87364F-0CEC-4CD8-9BF8-898F34628FB8}
//

DEFINE_GUID(NODEID_RSOPUser, 0xab87364f, 0x0cec, 0x4cd8, 0x9b, 0xf8, 0x89, 0x8f, 0x34, 0x62, 0x8f, 0xb8);


//
// User Configuration\Software Settings
// {E52C5CE3-FD27-4402-84DE-D9A5F2858910}
//

DEFINE_GUID(NODEID_RSOPUserSWSettings, 0xe52c5ce3, 0xfd27, 0x4402, 0x84, 0xde, 0xd9, 0xa5, 0xf2, 0x85, 0x89, 0x10);


//
// IRSOPInformation interface id
//
// {9A5A81B5-D9C7-49EF-9D11-DDF50968C48D}

DEFINE_GUID(IID_IRSOPInformation, 0x9a5a81b5, 0xd9c7, 0x49ef, 0x9d, 0x11, 0xdd, 0xf5, 0x09, 0x68, 0xc4, 0x8d);


#ifndef _GPEDIT_H_
#define _GPEDIT_H_


//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_GPEDIT_)
#define GPEDITAPI DECLSPEC_IMPORT
#else
#define GPEDITAPI
#endif


#ifdef __cplusplus
extern "C" {
#endif


#include <objbase.h>


//
// Group Policy Object Section flags
//

#define GPO_SECTION_ROOT                 0  // Root
#define GPO_SECTION_USER                 1  // User
#define GPO_SECTION_MACHINE              2  // Machine


//
// Group Policy Object types
//

#ifndef GROUP_POLICY_OBJECT_TYPE_ENUM_DEFINED
#define GROUP_POLICY_OBJECT_TYPE_ENUM_DEFINED

typedef enum _GROUP_POLICY_OBJECT_TYPE {
    GPOTypeLocal = 0,                       // Default GPO on the local machine
    GPOTypeRemote,                          // GPO on a remote machine
    GPOTypeDS,                              // GPO in the Active Directory
    GPOTypeLocalUser,                       // User-specific GPO on the local machine 
    GPOTypeLocalGroup                       // Group-specific GPO on the local machine 
} GROUP_POLICY_OBJECT_TYPE, *PGROUP_POLICY_OBJECT_TYPE;

#endif // GROUP_POLICY_OBJECT_TYPE_ENUM_DEFINED

//
// Group Policy Hint types
//

typedef enum _GROUP_POLICY_HINT_TYPE {
    GPHintUnknown = 0,                      // No link information available
    GPHintMachine,                          // GPO linked to a machine (local or remote)
    GPHintSite,                             // GPO linked to a site
    GPHintDomain,                           // GPO linked to a domain
    GPHintOrganizationalUnit,               // GPO linked to a organizational unit
} GROUP_POLICY_HINT_TYPE, *PGROUP_POLICY_HINT_TYPE;


#undef INTERFACE
#define INTERFACE   IGPEInformation
DECLARE_INTERFACE_(IGPEInformation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGPEInformation methods ***

    //
    // Returns the unique Group Policy Object name (a GUID)
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetName) (THIS_ __out_ecount(cchMaxLength) LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns the friendly display name for this Group Policy Object
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetDisplayName) (THIS_ __out_ecount(cchMaxLength) LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns a registry key handle for the requested section.  The returned
    // key is the root of the registry, not the Policies subkey.  To set / read
    // a value in the Policies subkey, you will need to call RegOpenKeyEx to
    // open Software\Policies subkey first.
    //
    // The handle has been opened with ALL ACCESS rights.  Call RegCloseKey
    // on the handle when finished.
    //
    // dwSection is either GPO_SECTION_USER or GPO_SECTION_MACHINE
    // hKey contains the registry key on return
    //

    STDMETHOD(GetRegistryKey) (THIS_ DWORD dwSection, HKEY *hKey) PURE;


    //
    // Returns the Active Directory path to the root of the request section.
    // The path is in ADSI name format.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the max number of characters that can be stored in pszPath
    //

    STDMETHOD(GetDSPath) (THIS_ DWORD dwSection, __out_ecount(cchMaxPath) LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the UNC path to the root of the requested section.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the number of characters that can be stored in pszPath.
    //

    STDMETHOD(GetFileSysPath) (THIS_ DWORD dwSection, __out_ecount(cchMaxPath) LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the user preferences (options)
    //
    // Currently, there are no options defined.  This is reserved for future use.
    //
    // dwOptions receives a bitmask value
    //

    STDMETHOD(GetOptions) (THIS_ DWORD *dwOptions) PURE;


    //
    // Returns the type of GPO being edited.
    //
    // The three types are:  a GPO in the Active Directory, the GPO on the local machine,
    // and the GPO on a remote machine.
    //
    // Machine GPOs only have file system storage (no Active Directory storage available).
    // If GetDSPath is called for a machine GPO, the function will succeed
    // and the returned buffer will be the empty string ""
    //
    // Active Directory GPOs have both file system and Active Directory storage available to them.
    //
    // gpoType receives one of the type flags listed above.
    //

    STDMETHOD(GetType) (THIS_ GROUP_POLICY_OBJECT_TYPE *gpoType) PURE;


    //
    // Returns the type of Active Directory object (or machine) that could be linked to
    // this GPO
    //
    // This is a hint api only.  The GPE does not know which Active Directory objects are
    // linked to a particular GPO, but it can offer a hint based upon how the
    // user started the GPE.
    //
    // Use this method with great caution.  Some extensions might want to
    // customize their user interface based upon the scoping for this GPO,
    // but it is easy to offer the wrong namespace.  Best advice is to
    // always offer your full user interface, but if you choose to use this
    // method, always offer your full user interface if you recieve the
    // unknown hint back.
    //
    // gpHint receives one of the hint flags listed above.
    //

    STDMETHOD(GetHint) (THIS_ GROUP_POLICY_HINT_TYPE *gpHint) PURE;


    //
    // Informs the Group Policy Editor that policy settings have changed.
    // Extensions MUST call this methold every time a change is made
    // to a Group Policy Object.
    //
    // bMachine specifies if machine or user policy has changed.
    // bAdd specifies whether this is an add or delete.
    // pGuidExtension is the guid or unique name of extension that
    //    will process this GPO.
    // pGuidSnapin is the guid or unique name of snapin that is making
    //    this call
    //

    STDMETHOD(PolicyChanged) (THIS_ BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin ) PURE;
};
typedef IGPEInformation *LPGPEINFORMATION;


//
// Group Policy Object open / creation flags
//

#define GPO_OPEN_LOAD_REGISTRY      0x00000001  // Load the registry files
#define GPO_OPEN_READ_ONLY          0x00000002  // Open the GPO as read only



//
// Group Policy Object option flags
//

#define GPO_OPTION_DISABLE_USER     0x00000001  // The user portion of this GPO is disabled
#define GPO_OPTION_DISABLE_MACHINE  0x00000002  // The machine portion of this GPO is disabled


#undef INTERFACE
#define INTERFACE   IGroupPolicyObject
DECLARE_INTERFACE_(IGroupPolicyObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGroupPolicyObject methods ***

    //
    // Creates a new GPO in the Active Directory with the given friendly name
    // and opens it via OpenDSGPO().  If pszDomainName contains a domain
    // controller name, the GPO will be created on that DC.  If it does not
    // specify a domain controller name, the method will select a DC on
    // the callers behalf.
    //
    // pszDomainName contains the ADSI path of the domain root
    // pszDisplayName contains the friendly display name
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(New) (THIS_ __in LPOLESTR pszDomainName, __in_opt LPOLESTR pszDisplayName,
                    DWORD dwFlags) PURE;


    //
    // Opens the specified Group Policy Object in the Active Directory
    // based upon the passed in flags.  If pszPath contains a domain
    // controller name, the GPO will be opened on that DC.  If it does
    // not contain a domain controller name, the method will select a
    // DC on the callers behalf.  If the registry is not loaded,
    // GetRegistryKey() will return E_FAIL.
    //
    // pszPath contains the ADSI path to the GPO to open
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(OpenDSGPO) (THIS_ __in LPOLESTR pszPath, DWORD dwFlags) PURE;


    //
    // Opens the default Group Policy Object on this machine with the
    // dwFlags options listed above.  If the registry is not loaded,
    // GetRegistryKey() will return E_FAIL.
    //
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(OpenLocalMachineGPO) (THIS_ DWORD dwFlags) PURE;


    //
    // Opens the default Group Policy Object on a remote machine with the
    // dwFlags options listed above.  If the registry is not loaded,
    // GetRegistryKey() will return E_FAIL.
    //
    // pszComputerName contains the machine name in \\machine format
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(OpenRemoteMachineGPO) (THIS_ __in LPOLESTR pszComputerName, DWORD dwFlags) PURE;


    //
    // Flushes the registry settings to disk and updates the revision
    // number of the GPO.
    //
    // bMachine specifies if machine or user should be saved.
    // bAdd specifies whether this is an add or delete.
    // pGuidExtension is the guid or unique name of extension that
    //    will process this GPO.
    // pGuid is a guid
    //

    STDMETHOD(Save) (THIS_ BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuid ) PURE;


    //
    // Deletes this Group Policy Object.
    //
    // After calling this method, no other methods are valid to call
    // since the data will have been deleted.
    //

    STDMETHOD(Delete) (THIS) PURE;


    //
    // Returns the unique Group Policy Object name
    //
    // For Active Directory policy objects, this is a GUID
    // For the local policy object, it is the string "Local"
    // For remote policy objects, it is the computername
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetName) (THIS_ __out_ecount(cchMaxLength) LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns the friendly display name for this Group Policy Object
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetDisplayName) (THIS_ __out_ecount(cchMaxLength) LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Sets the friendly display name for this Group Policy Object
    //
    // pszName is the new display name
    //

    STDMETHOD(SetDisplayName) (THIS_ __in LPOLESTR pszName) PURE;


    //
    // Returns the path to the Group Policy Object
    //
    //
    // If the GPO is an Active Directory object, the path is in ADSI name format.
    // If the GPO is a machine object, it is a file system path
    //
    // pszPath contains the path on return
    // cchMaxPath is the max number of characters that can be stored in pszPath
    //

    STDMETHOD(GetPath) (THIS_ __out_ecount(cchMaxLength) LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the Active Directory path to the root of the request section.
    // The path is in DN name format.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the max number of characters that can be stored in pszPath
    //

    STDMETHOD(GetDSPath) (THIS_ DWORD dwSection, __out_ecount(cchMaxPath) LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the UNC path to the root of the requested section.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the number of characters that can be stored in pszPath.
    //

    STDMETHOD(GetFileSysPath) (THIS_ DWORD dwSection, __out_ecount(cchMaxPath) LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns a registry key handle for the requested section.  The returned
    // key is the root of the registry, not the Policies subkey.  To set / read
    // a value in the Policies subkey, you will need to call RegOpenKeyEx to
    // open Software\Policies subkey first.
    //
    // The handle has been opened with ALL ACCESS rights.  Call RegCloseKey
    // on the handle when finished.
    //
    // If the GPO was loaded / created without the registry being loaded
    // this method will return E_FAIL.
    //
    // dwSection is either GPO_SECTION_USER or GPO_SECTION_MACHINE
    // hKey contains the registry key on return
    //

    STDMETHOD(GetRegistryKey) (THIS_ DWORD dwSection, HKEY *hKey) PURE;


    //
    // Returns any options for this Group Policy Object
    //
    // dwOptions receives the GPO_OPTION_* flags
    //

    STDMETHOD(GetOptions) (THIS_ DWORD *dwOptions) PURE;


    //
    // Sets any options for this Group Policy Object
    //
    // This method sets any options for this GPO.  To change
    // an option, that flag must be set in the mask field.
    // If the flag is in the mask field, then the dwOptions
    // field is read for the current state.
    //
    // For example:  to disable the GPO, make this call
    //
    //    SetOptions (GPO_OPTION_DISABLED, GPO_OPTION_DISABLED);
    //
    // dwOptions specifies one or more GPO_OPTION_* flags
    // dwMask specificies which of the dwOptions to change
    //

    STDMETHOD(SetOptions) (THIS_ DWORD dwOptions, DWORD dwMask) PURE;


    //
    // Returns the type of GPO being edited.
    //
    // The three types are:  a GPO in the Active Directory, the GPO on the local machine,
    // and the GPO on a remote machine.
    //
    // Machine GPOs only have file system storage (no Active Directory storage available).
    // If GetDSPath is called for a machine GPO, the function will succeed
    // and the returned buffer will be the empty string ""
    //
    // Active Directory GPOs have both file system and Active Directory storage available to them.
    //
    // gpoType receives one of the type flags
    //

    STDMETHOD(GetType) (THIS_ GROUP_POLICY_OBJECT_TYPE *gpoType) PURE;


    //
    // Returns the machine name of the remote GPO
    //
    // This method returns the name passed to OpenRemoteMachineGPO.
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetMachineName) (THIS_ __out_ecount(cchMaxLength) LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns an array of property sheet pages and the number of pages
    // in the array
    //
    // Note, this method will allocate memory for the array with
    // LocalAlloc.  When finished, the caller should free the array
    // with LocalFree
    //
    // hPages address of the pointer for the array of property sheet pages
    // uPageCount receives the number of pages in the array
    //

    STDMETHOD(GetPropertySheetPages) (THIS_ HPROPSHEETPAGE **hPages, UINT *uPageCount) PURE;
};
typedef IGroupPolicyObject *LPGROUPPOLICYOBJECT;


//
// RSOP flags
//

#define RSOP_INFO_FLAG_DIAGNOSTIC_MODE  0x00000001      // Running in diagnostic mode vs planning mode

#undef INTERFACE
#define INTERFACE   IRSOPInformation
DECLARE_INTERFACE_(IRSOPInformation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IRSOPInformation methods ***

    //
    // Returns the namespace for the RSOP data
    //
    // dwSection is either GPO_SECTION_USER or GPO_SECTION_MACHINE
    // pszName contains the namespace on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetNamespace) (THIS_ DWORD dwSection, __out_ecount(cchMaxLength) LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns information about the RSOP session
    //
    // pdwFlags points to a DWORD which contains the flags on return
    //

    STDMETHOD(GetFlags) (THIS_ DWORD * pdwFlags) PURE;


    //
    // Returns the event log text for a specific entry
    //
    // lpEventSource - event log source name
    // lpEventLogName - event log name
    // lpEventTime - event log time in WMI datetime format
    // dwEventID - event ID
    // lpText - Receives a pointer to a buffer containing the text.
    //          The caller should free this buffer with CoTaskMemFree.
    //

    STDMETHOD(GetEventLogEntryText) (THIS_ __in LPOLESTR pszEventSource, __in LPOLESTR pszEventLogName,
                                           __in LPOLESTR pszEventTime, DWORD dwEventID,  __deref_out LPOLESTR *ppszText) PURE;

};
typedef IRSOPInformation *LPRSOPINFORMATION;


//=============================================================================
//
// CreateGPOLink
//
// Creates a link to a GPO for the specified Site, Domain, or Organizational Unit
//
// lpGPO         - ADSI path to the GPO
// lpContainer   - ADSI path to the Site, Domain, or Organizational Unit
// fHighPriority - Create the link as the highest or lowest priority
//
// Returns:  S_OK if successful
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
CreateGPOLink(
    __in LPOLESTR lpGPO,
    __in LPOLESTR lpContainer,
         BOOL fHighPriority);


//=============================================================================
//
// DeleteGPOLink
//
// Deletes a link to a GPO for the specified Site, Domain, or Organizational Unit
//
// lpGPO         - ADSI path to the GPO
// lpContainer   - ADSI path to the Site, Domain, or Organizational Unit
//
// Returns:  S_OK if successful
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
DeleteGPOLink(
    __in LPOLESTR lpGPO,
    __in LPOLESTR lpContainer);


//=============================================================================
//
// DeleteAllGPOLinks
//
// Deletes all GPO links for the specified Site, Domain, or Organizational Unit
//
// lpContainer   - ADSI path to the Site, Domain, or Organizational Unit
//
// Returns:  S_OK if successful
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
DeleteAllGPOLinks(
    __in LPOLESTR lpContainer);


//=============================================================================
//
// BrowseForGPO
//
// Displays the GPO browser dialog
//
// lpBrowseInfo   - Address of a GPOBROWSEINFO structure
//
// Returns:  S_OK if successful
//
//=============================================================================

//
// Flags passed in the dwFlags field of the GPOBROWSEINFO structure
//

#define GPO_BROWSE_DISABLENEW           0x00000001   // Disables the New GPO functionality on all pages except "All"
#define GPO_BROWSE_NOCOMPUTERS          0x00000002   // Removes the Computers tab
#define GPO_BROWSE_NODSGPOS             0x00000004   // Removes the Domain/OU and Sites tabs
#define GPO_BROWSE_OPENBUTTON           0x00000008   // Change the Ok button to say Open
#define GPO_BROWSE_INITTOALL            0x00000010   // Initialize the dialog focused on the All pane
#define GPO_BROWSE_NOUSERGPOS           0x00000020   // Removes the Users tab

typedef struct tag_GPOBROWSEINFO
{
    DWORD       dwSize;                   // [in] Initialized to the size of this structure
    DWORD       dwFlags;                  // [in] Flags defined above
    HWND        hwndOwner;                // [in] Parent window handle (can be NULL)
    LPOLESTR    lpTitle;                  // [in] Title bar text.  If NULL, "Browse for a Group Policy Object" will be the default text
    LPOLESTR    lpInitialOU;              // [in] Initial Domain/Organizational Unit to open focus on
    __field_ecount(dwDSPathSize) LPOLESTR    lpDSPath;                 // [in/out] Pointer to the buffer that receives the Active Directory GPO path
    DWORD       dwDSPathSize;             // [in] Size in characters of buffer given in lpDSPath
    __field_bcount( dwNameSize) LPOLESTR    lpName;                   // [in/out] Pointer to a buffer that receives either the computer name or
                                          //      the friendly name of the GPO (can be NULL)
    DWORD       dwNameSize;               // [in] Size in characters of buffer given in lpName
    GROUP_POLICY_OBJECT_TYPE    gpoType;  // [out] Specifies the type of GPO
    GROUP_POLICY_HINT_TYPE      gpoHint;  // [out] Specifies a hint of the GPO association
} GPOBROWSEINFO, *LPGPOBROWSEINFO;


GPEDITAPI
HRESULT
WINAPI
BrowseForGPO(
    LPGPOBROWSEINFO lpBrowseInfo);


//=============================================================================
//
// ImportRSoPData
//
// Imports a data file generated by ExportRSoPData
//
// lpNameSpace   - Namespace to place the data in
// lpFileName    - Filename containing the data
//
// Returns:  S_OK if successful
//
// Notes:    The namespace specified in lpNameSpace must exist prior to calling
//           this function.
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
ImportRSoPData(
    __in LPOLESTR lpNameSpace,
    __in LPOLESTR lpFileName);


//=============================================================================
//
// ExportRSoPData
//
// Exports a WBEM namespace containing RSoP information to a data file.
// This data file can be imported to a WBEM namespace using ImportRSoPData.
//
// lpNameSpace   - Namespace to read the data from
// lpFileName    - Filename to receive the data
//
// Returns:  S_OK if successful
//
// Notes:    This function should be called twice.  Once for the user data
//           and once for the computer data.
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
ExportRSoPData(
    __in LPOLESTR lpNameSpace,
    __in LPOLESTR lpFileName);

#ifdef __cplusplus
}
#endif


#endif  /* _GPEDIT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\hidpi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

        HIDPI.H

Abstract:

   Public Interface to the HID parsing library.

Environment:

    Kernel & user mode

--*/

#ifndef   __HIDPI_H__
#define   __HIDPI_H__

#include <pshpack4.h>

// Please include "hidsdi.h" to use the user space (dll / parser)
// Please include "hidpddi.h" to use the kernel space parser

//
// Special Link collection values for using the query functions
//
// Root collection references the collection at the base of the link
// collection tree.
// Unspecifies, references all collections in the link collection tree.
//
#define HIDP_LINK_COLLECTION_ROOT ((USHORT) -1)
#define HIDP_LINK_COLLECTION_UNSPECIFIED ((USHORT) 0)


typedef enum _HIDP_REPORT_TYPE
{
    HidP_Input,
    HidP_Output,
    HidP_Feature
} HIDP_REPORT_TYPE;

typedef struct _USAGE_AND_PAGE
{
    USAGE Usage;
    USAGE UsagePage;
} USAGE_AND_PAGE, *PUSAGE_AND_PAGE;

#define HidP_IsSameUsageAndPage(u1, u2) ((* (PULONG) &u1) == (* (PULONG) &u2))

typedef struct _HIDP_BUTTON_CAPS
{
    USAGE    UsagePage;
    UCHAR    ReportID;
    BOOLEAN  IsAlias;

    USHORT   BitField;
    USHORT   LinkCollection;   // A unique internal index pointer

    USAGE    LinkUsage;
    USAGE    LinkUsagePage;

    BOOLEAN  IsRange;
    BOOLEAN  IsStringRange;
    BOOLEAN  IsDesignatorRange;
    BOOLEAN  IsAbsolute;

    ULONG    Reserved[10];
    union {
        struct {
            USAGE    UsageMin,         UsageMax;
            USHORT   StringMin,        StringMax;
            USHORT   DesignatorMin,    DesignatorMax;
            USHORT   DataIndexMin,     DataIndexMax;
        } Range;
        struct  {
            USAGE    Usage,            Reserved1;
            USHORT   StringIndex,      Reserved2;
            USHORT   DesignatorIndex,  Reserved3;
            USHORT   DataIndex,        Reserved4;
        } NotRange;
    };

} HIDP_BUTTON_CAPS, *PHIDP_BUTTON_CAPS;


typedef struct _HIDP_VALUE_CAPS
{
    USAGE    UsagePage;
    UCHAR    ReportID;
    BOOLEAN  IsAlias;

    USHORT   BitField;
    USHORT   LinkCollection;   // A unique internal index pointer

    USAGE    LinkUsage;
    USAGE    LinkUsagePage;

    BOOLEAN  IsRange;
    BOOLEAN  IsStringRange;
    BOOLEAN  IsDesignatorRange;
    BOOLEAN  IsAbsolute;

    BOOLEAN  HasNull;        // Does this channel have a null report   union
    UCHAR    Reserved;
    USHORT   BitSize;        // How many bits are devoted to this value?

    USHORT   ReportCount;    // See Note below.  Usually set to 1.
    USHORT   Reserved2[5];

    ULONG    UnitsExp;
    ULONG    Units;

    LONG     LogicalMin,       LogicalMax;
    LONG     PhysicalMin,      PhysicalMax;

    union {
        struct {
            USAGE    UsageMin,         UsageMax;
            USHORT   StringMin,        StringMax;
            USHORT   DesignatorMin,    DesignatorMax;
            USHORT   DataIndexMin,     DataIndexMax;
        } Range;

        struct {
            USAGE    Usage,            Reserved1;
            USHORT   StringIndex,      Reserved2;
            USHORT   DesignatorIndex,  Reserved3;
            USHORT   DataIndex,        Reserved4;
        } NotRange;
    };
} HIDP_VALUE_CAPS, *PHIDP_VALUE_CAPS;

//
// Notes:
//
// ReportCount:  When a report descriptor declares an Input, Output, or
// Feature main item with fewer usage declarations than the report count, then
// the last usage applies to all remaining unspecified count in that main item.
// (As an example you might have data that required many fields to describe,
// possibly buffered bytes.)  In this case, only one value cap structure is
// allocated for these associtated fields, all with the same usage, and Report
// Count reflects the number of fields involved.  Normally ReportCount is 1.
// To access all of the fields in such a value structure would require using
// HidP_GetUsageValueArray and HidP_SetUsageValueArray.   HidP_GetUsageValue/
// HidP_SetScaledUsageValue will also work, however, these functions will only
// work with the first field of the structure.
//

//
// The link collection tree consists of an array of LINK_COLLECTION_NODES
// where the index into this array is the same as the collection number.
//
// Given a collection A which contains a subcollection B, A is defined to be
// the parent B, and B is defined to be the child.
//
// Given collections A, B, and C where B and C are children of A, and B was
// encountered before C in the report descriptor, B is defined as a sibling of
// C.  (This implies, of course, that if B is a sibling of C, then C is NOT a
// sibling of B).
//
// B is defined as the NextSibling of C if and only if there exists NO
// child collection of A, call it D, such that B is a sibling of D and D
// is a sibling of C.
//
// E is defined to be the FirstChild of A if and only if for all children of A,
// F, that are not equivalent to E, F is a sibling of E.
// (This implies, of course, that the does not exist a child of A, call it G,
// where E is a sibling of G).  In other words the first sibling is the last
// link collection found in the list.
//
// In other words, if a collection B is defined within the definition of another
// collection A, B becomes a child of A.  All collections with the same parent
// are considered siblings.  The FirstChild of the parent collection, A, will be
// last collection defined that has A as a parent.  The order of sibling pointers
// is similarly determined.  When a collection B is defined, it becomes the
// FirstChild of it's parent collection.  The previously defined FirstChild of the
// parent collection becomes the NextSibling of the new collection.  As new
// collections with the same parent are discovered, the chain of sibling is built.
//
// With that in mind, the following describes conclusively a data structure
// that provides direct traversal up, down, and accross the link collection
// tree.
//
//
typedef struct _HIDP_LINK_COLLECTION_NODE
{
    USAGE    LinkUsage;
    USAGE    LinkUsagePage;
    USHORT   Parent;
    USHORT   NumberOfChildren;
    USHORT   NextSibling;
    USHORT   FirstChild;
    ULONG    CollectionType: 8;  // As defined in 6.2.2.6 of HID spec
    ULONG    IsAlias : 1; // This link node is an allias of the next link node.
    ULONG    Reserved: 23;
    PVOID    UserContext; // The user can hang his coat here.
} HIDP_LINK_COLLECTION_NODE, *PHIDP_LINK_COLLECTION_NODE;

//
// When a link collection is described by a delimiter, alias link collection
// nodes are created.  (One for each usage within the delimiter).
// The parser assigns each capability description listed above only one
// link collection.
//
// If a control is defined within a collection defined by
// delimited usages, then that control is said to be within multiple link
// collections, one for each usage within the open and close delimiter tokens.
// Such multiple link collecions are said to be aliases.  The first N-1 such
// collections, listed in the link collection node array, have their IsAlias
// bit set.  The last such link collection is the link collection index used
// in the capabilities described above.
// Clients wishing to set a control in an aliased collection, should walk the
// collection array once for each time they see the IsAlias flag set, and use
// the last link collection as the index for the below accessor functions.
//
// NB: if IsAlias is set, then NextSibling should be one more than the current
// link collection node index.
//

typedef PUCHAR  PHIDP_REPORT_DESCRIPTOR;
typedef struct _HIDP_PREPARSED_DATA * PHIDP_PREPARSED_DATA;

typedef struct _HIDP_CAPS
{
    USAGE    Usage;
    USAGE    UsagePage;
    USHORT   InputReportByteLength;
    USHORT   OutputReportByteLength;
    USHORT   FeatureReportByteLength;
    USHORT   Reserved[17];

    USHORT   NumberLinkCollectionNodes;

    USHORT   NumberInputButtonCaps;
    USHORT   NumberInputValueCaps;
    USHORT   NumberInputDataIndices;

    USHORT   NumberOutputButtonCaps;
    USHORT   NumberOutputValueCaps;
    USHORT   NumberOutputDataIndices;

    USHORT   NumberFeatureButtonCaps;
    USHORT   NumberFeatureValueCaps;
    USHORT   NumberFeatureDataIndices;
} HIDP_CAPS, *PHIDP_CAPS;

typedef struct _HIDP_DATA
{
    USHORT  DataIndex;
    USHORT  Reserved;
    union {
        ULONG   RawValue; // for values
        BOOLEAN On; // for buttons MUST BE TRUE for buttons.
    };
} HIDP_DATA, *PHIDP_DATA;
//
// The HIDP_DATA structure is used with HidP_GetData and HidP_SetData
// functions.
//
// The parser contiguously assigns every control (button or value) in a hid
// device a unique data index from zero to NumberXXXDataIndices -1 , inclusive.
// This value is found in the HIDP_BUTTON_CAPS and HIDP_VALUE_CAPS structures.
//
// Most clients will find the Get/Set Buttons / Value accessor functions
// sufficient to their needs, as they will allow the clients to access the
// data known to them while ignoring the other controls.
//
// More complex clients, which actually read the Button / Value Caps, and which
// do a value add service to these routines (EG Direct Input), will need to
// access all the data in the device without interest in the individual usage
// or link collection location.  These are the clients that will find
// HidP_Data useful.
//

typedef struct _HIDP_UNKNOWN_TOKEN
{
    UCHAR  Token;
    UCHAR  Reserved[3];
    ULONG  BitField;
} HIDP_UNKNOWN_TOKEN, *PHIDP_UNKNOWN_TOKEN;

typedef struct _HIDP_EXTENDED_ATTRIBUTES
{
    UCHAR   NumGlobalUnknowns;
    UCHAR   Reserved [3];
    PHIDP_UNKNOWN_TOKEN  GlobalUnknowns;
    // ... Additional attributes
    ULONG   Data [1]; // variableLength  DO NOT ACCESS THIS FIELD
} HIDP_EXTENDED_ATTRIBUTES, *PHIDP_EXTENDED_ATTRIBUTES;

NTSTATUS __stdcall
HidP_GetCaps (
   IN      PHIDP_PREPARSED_DATA      PreparsedData,
   OUT     PHIDP_CAPS                Capabilities
   );
/*++
Routine Description:
   Returns a list of capabilities of a given hid device as described by its
   preparsed data.

Arguments:
   PreparsedData    The preparsed data returned from HIDCLASS.
   Capabilities     a HIDP_CAPS structure

Return Value:
   HIDP_STATUS_SUCCESS
   HIDP_STATUS_INVALID_PREPARSED_DATA
--*/

NTSTATUS __stdcall
HidP_GetLinkCollectionNodes (
   OUT      PHIDP_LINK_COLLECTION_NODE LinkCollectionNodes,
   IN OUT   PULONG                     LinkCollectionNodesLength,
   IN       PHIDP_PREPARSED_DATA       PreparsedData
   );
/*++
Routine Description:
   Return a list of PHIDP_LINK_COLLECTION_NODEs used to describe the link
   collection tree of this hid device.  See the above description of
   struct _HIDP_LINK_COLLECTION_NODE.

Arguments:
   LinkCollectionNodes - a caller allocated array into which
                 HidP_GetLinkCollectionNodes will store the information

   LinKCollectionNodesLength - the caller sets this value to the length of the
                 the array in terms of number of elements.
                 HidP_GetLinkCollectionNodes sets this value to the actual
                 number of elements set. The total number of nodes required to
                 describe this HID device can be found in the
                 NumberLinkCollectionNodes field in the HIDP_CAPS structure.

--*/

NTSTATUS __stdcall
HidP_GetButtonCaps (
   IN       HIDP_REPORT_TYPE     ReportType,
   OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
   IN OUT   PUSHORT              ButtonCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
);
#define HidP_GetButtonCaps(_Type_, _Caps_, _Len_, _Data_) \
        HidP_GetSpecificButtonCaps (_Type_, 0, 0, 0, _Caps_, _Len_, _Data_)
NTSTATUS __stdcall
HidP_GetSpecificButtonCaps (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,      // Optional (0 => ignore)
   IN       USHORT               LinkCollection, // Optional (0 => ignore)
   IN       USAGE                Usage,          // Optional (0 => ignore)
   OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
   IN OUT   PUSHORT              ButtonCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
   );
/*++
Description:
   HidP_GetButtonCaps returns all the buttons (binary values) that are a part
   of the given report type for the Hid device represented by the given
   preparsed data.

Parameters:
   ReportType  One of HidP_Input, HidP_Output, or HidP_Feature.

   UsagePage   A usage page value used to limit the button caps returned to
                those on a given usage page.  If set to 0, this parameter is
                ignored.  Can be used with LinkCollection and Usage parameters
                to further limit the number of button caps structures returned.

   LinkCollection HIDP_LINK_COLLECTION node array index used to limit the
                  button caps returned to those buttons in a given link
                  collection.  If set to 0, this parameter is
                  ignored.  Can be used with UsagePage and Usage parameters
                  to further limit the number of button caps structures
                  returned.

   Usage      A usage value used to limit the button caps returned to those
               with the specified usage value.  If set to 0, this parameter
               is ignored.  Can be used with LinkCollection and UsagePage
               parameters to further limit the number of button caps
               structures returned.

   ButtonCaps A _HIDP_BUTTON_CAPS array containing information about all the
               binary values in the given report.  This buffer is provided by
               the caller.

   ButtonLength   As input, this parameter specifies the length of the
                  ButtonCaps parameter (array) in number of array elements.
                  As output, this value is set to indicate how many of those
                  array elements were filled in by the function.  The maximum number of
                  button caps that can be returned is found in the HIDP_CAPS
                  structure.  If HIDP_STATUS_BUFFER_TOO_SMALL is returned,
                  this value contains the number of array elements needed to
                  successfully complete the request.

   PreparsedData  The preparsed data returned from HIDCLASS.


Return Value
HidP_GetSpecificButtonCaps returns the following error codes:
  HIDP_STATUS_SUCCESS.
  HIDP_STATUS_INVALID_REPORT_TYPE
  HIDP_STATUS_INVALID_PREPARSED_DATA
  HIDP_STATUS_BUFFER_TOO_SMALL (all given entries however have been filled in)
  HIDP_STATUS_USAGE_NOT_FOUND
--*/

NTSTATUS __stdcall
HidP_GetValueCaps (
   IN       HIDP_REPORT_TYPE     ReportType,
   OUT      PHIDP_VALUE_CAPS     ValueCaps,
   IN OUT   PUSHORT              ValueCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
);
#define HidP_GetValueCaps(_Type_, _Caps_, _Len_, _Data_) \
        HidP_GetSpecificValueCaps (_Type_, 0, 0, 0, _Caps_, _Len_, _Data_)
NTSTATUS __stdcall
HidP_GetSpecificValueCaps (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,      // Optional (0 => ignore)
   IN       USHORT               LinkCollection, // Optional (0 => ignore)
   IN       USAGE                Usage,          // Optional (0 => ignore)
   OUT      PHIDP_VALUE_CAPS     ValueCaps,
   IN OUT   PUSHORT              ValueCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
   );
/*++
Description:
   HidP_GetValueCaps returns all the values (non-binary) that are a part
   of the given report type for the Hid device represented by the given
   preparsed data.

Parameters:
   ReportType  One of HidP_Input, HidP_Output, or HidP_Feature.

   UsagePage   A usage page value used to limit the value caps returned to
                those on a given usage page.  If set to 0, this parameter is
                ignored.  Can be used with LinkCollection and Usage parameters
                to further limit the number of value caps structures returned.

   LinkCollection HIDP_LINK_COLLECTION node array index used to limit the
                  value caps returned to those buttons in a given link
                  collection.  If set to 0, this parameter is
                  ignored.  Can be used with UsagePage and Usage parameters
                  to further limit the number of value caps structures
                  returned.

   Usage      A usage value used to limit the value caps returned to those
               with the specified usage value.  If set to 0, this parameter
               is ignored.  Can be used with LinkCollection and UsagePage
               parameters to further limit the number of value caps
               structures returned.

   ValueCaps  A _HIDP_VALUE_CAPS array containing information about all the
               non-binary values in the given report.  This buffer is provided
               by the caller.

   ValueLength   As input, this parameter specifies the length of the ValueCaps
                  parameter (array) in number of array elements.  As output,
                  this value is set to indicate how many of those array elements
                  were filled in by the function.  The maximum number of
                  value caps that can be returned is found in the HIDP_CAPS
                  structure.  If HIDP_STATUS_BUFFER_TOO_SMALL is returned,
                  this value contains the number of array elements needed to
                  successfully complete the request.

   PreparsedData  The preparsed data returned from HIDCLASS.


Return Value
HidP_GetValueCaps returns the following error codes:
  HIDP_STATUS_SUCCESS.
  HIDP_STATUS_INVALID_REPORT_TYPE
  HIDP_STATUS_INVALID_PREPARSED_DATA
  HIDP_STATUS_BUFFER_TOO_SMALL (all given entries however have been filled in)
  HIDP_STATUS_USAGE_NOT_FOUND

--*/

NTSTATUS __stdcall
HidP_GetExtendedAttributes (
    IN      HIDP_REPORT_TYPE            ReportType,
    IN      USHORT                      DataIndex,
    IN      PHIDP_PREPARSED_DATA        PreparsedData,
    OUT     PHIDP_EXTENDED_ATTRIBUTES   Attributes,
    IN OUT  PULONG                      LengthAttributes
    );
/*++
Description:
    Given a data index from the value or button capabilities of a given control
    return any extended attributes for the control if any exist.

Parameters:
    ReportType  One of HidP_Input, HidP_Output, or HidP_Feature.

    DataIndex   The data index for the given control, found in the capabilities
                structure for that control

    PreparsedData   The preparsed data returned from HIDCLASS.

    Attributes  Pointer to a buffer into which the extended attribute data will
                be copied.

    LengthAttributes    Length of the given buffer in bytes.

Return Value
    HIDP_STATUS_SUCCESS
    HIDP_STATUS_DATA_INDEX_NOT_FOUND
--*/

NTSTATUS __stdcall
HidP_InitializeReportForID (
   __in HIDP_REPORT_TYPE ReportType,
   __in UCHAR ReportID,
   IN PHIDP_PREPARSED_DATA PreparsedData,
   __out_bcount(ReportLength) PCHAR Report,
   __in ULONG ReportLength
   );
/*++

Routine Description:

    Initialize a report based on the given report ID.

Parameters:

    ReportType  One of HidP_Input, HidP_Output, or HidP_Feature.

    PreparasedData  Preparsed data structure returned by HIDCLASS

    Report      Buffer which to set the data into.

    ReportLength Length of Report...Report should be at least as long as the
                value indicated in the HIDP_CAPS structure for the device and
                the corresponding ReportType

Return Value

  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not equal
                                        to the length specified in HIDP_CAPS
                                        structure for the given ReportType
  HIDP_STATUS_REPORT_DOES_NOT_EXIST  -- if there are no reports on this device
                                        for the given ReportType

--*/

NTSTATUS __stdcall
HidP_SetData (
    __in HIDP_REPORT_TYPE ReportType,
    __in_ecount(*DataLength) PHIDP_DATA DataList,
    __inout PULONG DataLength,
    IN PHIDP_PREPARSED_DATA PreparsedData,
    __inout_bcount(ReportLength) PCHAR Report,
    __in ULONG ReportLength
    );
/*++

Routine Description:

    Please Note: Since usage value arrays deal with multiple fields for
                 for one usage value, they cannot be used with HidP_SetData
                 and HidP_GetData.  In this case,
                 HIDP_STATUS_IS_USAGE_VALUE_ARRAY will be returned.

Parameters:

    ReportType  One of HidP_Input, HidP_Output, or HidP_Feature.

    DataList    Array of HIDP_DATA structures that contains the data values
                that are to be set into the given report

    DataLength  As input, length in array elements of DataList.  As output,
                contains the number of data elements set on successful
                completion or an index into the DataList array to identify
                the faulting HIDP_DATA value if an error code is returned.

    PreparasedData  Preparsed data structure returned by HIDCLASS

    Report      Buffer which to set the data into.

    ReportLength Length of Report...Report should be at least as long as the
                value indicated in the HIDP_CAPS structure for the device and
                the corresponding ReportType

Return Value
    HidP_SetData returns the following error codes.  The report packet will
        have all the data set up until the HIDP_DATA structure that caused the
        error.  DataLength, in the error case, will return this problem index.

  HIDP_STATUS_SUCCESS                -- upon successful insertion of all data
                                        into the report packet.
  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_DATA_INDEX_NOT_FOUND   -- if a HIDP_DATA structure referenced a
                                        data index that does not exist for this
                                        device's ReportType
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not equal
                                        to the length specified in HIDP_CAPS
                                        structure for the given ReportType
  HIDP_STATUS_REPORT_DOES_NOT_EXIST  -- if there are no reports on this device
                                        for the given ReportType
  HIDP_STATUS_IS_USAGE_VALUE_ARRAY   -- if one of the HIDP_DATA structures
                                        references a usage value array.
                                        DataLength will contain the index into
                                        the array that was invalid
  HIDP_STATUS_BUTTON_NOT_PRESSED     -- if a HIDP_DATA structure attempted
                                        to unset a button that was not already
                                        set in the Report
  HIDP_STATUS_INCOMPATIBLE_REPORT_ID -- a HIDP_DATA structure was found with
                                        a valid index value but is contained
                                        in a different report than the one
                                        currently being processed
  HIDP_STATUS_BUFFER_TOO_SMALL       -- if there are not enough entries in
                                        a given Main Array Item to report all
                                        buttons that have been requested to be
                                        set
--*/

NTSTATUS __stdcall
HidP_GetData (
    __in HIDP_REPORT_TYPE ReportType,
    __out_ecount_part(*DataLength,*DataLength) PHIDP_DATA DataList,
    __inout PULONG DataLength,
    IN PHIDP_PREPARSED_DATA PreparsedData,
    __in_bcount(ReportLength) PCHAR Report,
    __in ULONG ReportLength
    );
/*++

Routine Description:

    Please Note: For obvious reasons HidP_SetData and HidP_GetData will not
    access UsageValueArrays.

Parameters:
    ReportType  One of HidP_Input, HidP_Output, or HidP_Feature.

    DataList    Array of HIDP_DATA structures that will receive the data
                values that are set in the given report

    DataLength  As input, length in array elements of DataList.  As output,
                contains the number of data elements that were successfully
                set by HidP_GetData.  The maximum size necessary for DataList
                can be determined by calling HidP_MaxDataListLength

    PreparasedData  Preparsed data structure returned by HIDCLASS

    Report      Buffer which to set the data into.

    ReportLength Length of Report...Report should be at least as long as the
                value indicated in the HIDP_CAPS structure for the device and
                the corresponding ReportType

Return Value
    HidP_GetData returns the following error codes.

  HIDP_STATUS_SUCCESS                -- upon successful retrieval of all data
                                        from the report packet.
  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not equal
                                        to the length specified in HIDP_CAPS
                                        structure for the given ReportType
  HIDP_STATUS_REPORT_DOES_NOT_EXIST  -- if there are no reports on this device
                                        for the given ReportType
  HIDP_STATUS_BUFFER_TOO_SMALL       -- if there are not enough array entries in
                                        DataList to store all the indice values
                                        in the given report.  DataLength will
                                        contain the number of array entries
                                        required to hold all data
--*/

ULONG __stdcall
HidP_MaxDataListLength (
   IN HIDP_REPORT_TYPE      ReportType,
   IN PHIDP_PREPARSED_DATA  PreparsedData
   );
/*++
Routine Description:

    This function returns the maximum length of HIDP_DATA elements that
    HidP_GetData could return for the given report type.

Parameters:

    ReportType  One of HidP_Input, HidP_Output or HidP_Feature.

    PreparsedData    Preparsed data structure returned by HIDCLASS

Return Value:

    The length of the data list array required for the HidP_GetData function
    call.  If an error occurs (either HIDP_STATUS_INVALID_REPORT_TYPE or
    HIDP_STATUS_INVALID_PREPARSED_DATA), this function returns 0.

--*/

#define HidP_SetButtons(Rty, Up, Lco, ULi, ULe, Ppd, Rep, Rle) \
        HidP_SetUsages(Rty, Up, Lco, ULi, ULe, Ppd, Rep, Rle)

NTSTATUS __stdcall
HidP_SetUsages (
   __in HIDP_REPORT_TYPE    ReportType,
   __in USAGE   UsagePage,
   __in USHORT  LinkCollection,
   __inout_ecount(*UsageLength) PUSAGE  UsageList,
   __inout  PULONG  UsageLength,
   IN PHIDP_PREPARSED_DATA  PreparsedData,
   __inout_bcount(ReportLength) PCHAR   Report,
   __in ULONG   ReportLength 
   );
/*++

Routine Description:
    This function sets binary values (buttons) in a report.  Given an
    initialized packet of correct length, it modifies the report packet so that
    each element in the given list of usages has been set in the report packet.
    For example, in an output report with 5 LED's, each with a given usage,
    an application could turn on any subset of these lights by placing their
    usages in any order into the usage array (UsageList).  HidP_SetUsages would,
    in turn, set the appropriate bit or add the corresponding byte into the
    HID Main Array Item.

    A properly initialized Report packet is one of the correct byte length,
    and all zeros.

    NOTE: A packet that has already been set with a call to a HidP_Set routine
          can also be passed in.  This routine then sets processes the UsageList
          in the same fashion but verifies that the ReportID already set in
          Report matches the report ID for the given usages.

Parameters:
    ReportType  One of HidP_Input, HidP_Output or HidP_Feature.

    UsagePage   All of the usages in the usage array, which HidP_SetUsages will
                set in the report, refer to this same usage page.
                If a client wishes to set usages in a report for multiple
                usage pages then that client needs to make multiple calls to
                HidP_SetUsages for each of the usage pages.

    UsageList   A usage array containing the usages that HidP_SetUsages will set in
                the report packet.

    UsageLength The length of the given usage array in array elements.
                The parser will set this value to the position in the usage
                array where it stopped processing.  If successful, UsageLength
                will be unchanged.  In any error condition, this parameter
                reflects how many of the usages in the usage list have
                actually been set by the parser.  This is useful for finding
                the usage in the list which caused the error.

    PreparsedData The preparsed data recevied from HIDCLASS

    Report      The report packet.

    ReportLength   Length of the given report packet...Must be equal to the
                   value reported in the HIDP_CAPS structure for the device
                   and corresponding report type.

Return Value
    HidP_SetUsages returns the following error codes.  On error, the report packet
    will be correct up until the usage element that caused the error.

  HIDP_STATUS_SUCCESS                -- upon successful insertion of all usages
                                        into the report packet.
  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not
                                        equal to the length specified in
                                        the HIDP_CAPS structure for the given
                                        ReportType
  HIDP_STATUS_REPORT_DOES_NOT_EXIST  -- if there are no reports on this device
                                        for the given ReportType
  HIDP_STATUS_INCOMPATIBLE_REPORT_ID -- if a usage was found that exists in a
                                        different report.  If the report is
                                        zero-initialized on entry the first
                                        usage in the list will determine which
                                        report ID is used.  Otherwise, the
                                        parser will verify that usage matches
                                        the passed in report's ID
  HIDP_STATUS_USAGE_NOT_FOUND        -- if the usage does not exist for any
                                        report (no matter what the report ID)
                                        for the given report type.
  HIDP_STATUS_BUFFER_TOO_SMALL       -- if there are not enough entries in a
                                        given Main Array Item to list all of
                                        the given usages.  The caller needs
                                        to split his request into more than
                                        one call
--*/

#define HidP_UnsetButtons(Rty, Up, Lco, ULi, ULe, Ppd, Rep, Rle) \
        HidP_UnsetUsages(Rty, Up, Lco, ULi, ULe, Ppd, Rep, Rle)

NTSTATUS __stdcall
HidP_UnsetUsages (
   __in HIDP_REPORT_TYPE      ReportType,
   __in USAGE   UsagePage,
   __in_opt USHORT  LinkCollection,
   __inout_ecount_part(*UsageLength,*UsageLength) PUSAGE  UsageList,
   __inout  PULONG  UsageLength,
   IN PHIDP_PREPARSED_DATA  PreparsedData,
   __inout_bcount(ReportLength) PCHAR   Report,
   __in ULONG   ReportLength
   );
/*++

Routine Description:
    This function unsets (turns off) binary values (buttons) in the report.  Given
    an initialized packet of correct length, it modifies the report packet so
    that each element in the given list of usages has been unset in the
    report packet.

    This function is the "undo" operation for SetUsages.  If the given usage
    is not already set in the Report, it will return an error code of
    HIDP_STATUS_BUTTON_NOT_PRESSED.  If the button is pressed, HidP_UnsetUsages
    will unset the appropriate bit or remove the corresponding index value from
    the HID Main Array Item.

    A properly initialized Report packet is one of the correct byte length,
    and all zeros..

    NOTE: A packet that has already been set with a call to a HidP_Set routine
          can also be passed in.  This routine then processes the UsageList
          in the same fashion but verifies that the ReportID already set in
          Report matches the report ID for the given usages.

Parameters:
    ReportType  One of HidP_Input, HidP_Output or HidP_Feature.

    UsagePage   All of the usages in the usage array, which HidP_UnsetUsages will
                unset in the report, refer to this same usage page.
                If a client wishes to unset usages in a report for multiple
                usage pages then that client needs to make multiple calls to
                HidP_UnsetUsages for each of the usage pages.

    UsageList   A usage array containing the usages that HidP_UnsetUsages will
                unset in the report packet.

    UsageLength The length of the given usage array in array elements.
                The parser will set this value to the position in the usage
                array where it stopped processing.  If successful, UsageLength
                will be unchanged.  In any error condition, this parameter
                reflects how many of the usages in the usage list have
                actually been unset by the parser.  This is useful for finding
                the usage in the list which caused the error.

    PreparsedData The preparsed data recevied from HIDCLASS

    Report      The report packet.

    ReportLength   Length of the given report packet...Must be equal to the
                   value reported in the HIDP_CAPS structure for the device
                   and corresponding report type.

Return Value
    HidP_UnsetUsages returns the following error codes.  On error, the report
    packet will be correct up until the usage element that caused the error.

  HIDP_STATUS_SUCCESS                -- upon successful "unsetting" of all usages
                                        in the report packet.
  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not
                                        equal to the length specified in
                                        the HIDP_CAPS structure for the given
                                        ReportType
  HIDP_STATUS_REPORT_DOES_NOT_EXIST  -- if there are no reports on this device
                                        for the given ReportType
  HIDP_STATUS_INCOMPATIBLE_REPORT_ID -- if a usage was found that exists in a
                                        different report.  If the report is
                                        zero-initialized on entry the first
                                        usage in the list will determine which
                                        report ID is used.  Otherwise, the
                                        parser will verify that usage matches
                                        the passed in report's ID
  HIDP_STATUS_USAGE_NOT_FOUND        -- if the usage does not exist for any
                                        report (no matter what the report ID)
                                        for the given report type.
  HIDP_STATUS_BUTTON_NOT_PRESSED     -- if a usage corresponds to a button that
                                        is not already set in the given report
--*/

#define HidP_GetButtons(Rty, UPa, LCo, ULi, ULe, Ppd, Rep, RLe) \
        HidP_GetUsages(Rty, UPa, LCo, ULi, ULe, Ppd, Rep, RLe)

NTSTATUS __stdcall
HidP_GetUsages (
   __in HIDP_REPORT_TYPE    ReportType,
   __in USAGE   UsagePage,
   __in USHORT  LinkCollection,
   IN OUT PUSAGE UsageList,
   __inout    PULONG UsageLength,
   IN PHIDP_PREPARSED_DATA PreparsedData,
   __in_bcount(ReportLength)    PCHAR Report,
   __in ULONG   ReportLength
   );
/*++

Routine Description:
    This function returns the binary values (buttons) that are set in a HID
    report.  Given a report packet of correct length, it searches the report
    packet for each usage for the given usage page and returns them in the
    usage list.

Parameters:
    ReportType One of HidP_Input, HidP_Output or HidP_Feature.

    UsagePage  All of the usages in the usage list, which HidP_GetUsages will
               retrieve in the report, refer to this same usage page.
               If the client wishes to get usages in a packet for multiple
               usage pages then that client needs to make multiple calls
               to HidP_GetUsages.

    LinkCollection  An optional value which can limit which usages are returned
                    in the UsageList to those usages that exist in a specific
                    LinkCollection.  A non-zero value indicates the index into
                    the HIDP_LINK_COLLECITON_NODE list returned by
                    HidP_GetLinkCollectionNodes of the link collection the
                    usage should belong to.  A value of 0 indicates this
                    should value be ignored.

    UsageList  The usage array that will contain all the usages found in
               the report packet.

    UsageLength The length of the given usage array in array elements.
                On input, this value describes the length of the usage list.
                On output, HidP_GetUsages sets this value to the number of
                usages that was found.  Use HidP_MaxUsageListLength to
                determine the maximum length needed to return all the usages
                that a given report packet may contain.

    PreparsedData Preparsed data structure returned by HIDCLASS

    Report       The report packet.

    ReportLength  Length (in bytes) of the given report packet


Return Value
    HidP_GetUsages returns the following error codes:

  HIDP_STATUS_SUCCESS                -- upon successfully retrieving all the
                                        usages from the report packet
  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not
                                        equal to the length specified in
                                        the HIDP_CAPS structure for the given
                                        ReportType
  HIDP_STATUS_REPORT_DOES_NOT_EXIST  -- if there are no reports on this device
                                        for the given ReportType
  HIDP_STATUS_BUFFER_TOO_SMALL       -- if the UsageList is not big enough to
                                        hold all the usages found in the report
                                        packet.  If this is returned, the buffer
                                        will contain UsageLength number of
                                        usages.  Use HidP_MaxUsageListLength to
                                        find the maximum length needed
  HIDP_STATUS_INCOMPATIBLE_REPORT_ID -- if no usages were found but usages
                                        that match the UsagePage and
                                        LinkCollection specified could be found
                                        in a report with a different report ID
  HIDP_STATUS_USAGE_NOT_FOUND        -- if there are no usages in a reports for
                                        the device and ReportType that match the
                                        UsagePage and LinkCollection that were
                                        specified
--*/

#define HidP_GetButtonsEx(Rty, LCo, BLi, ULe, Ppd, Rep, RLe)  \
        HidP_GetUsagesEx(Rty, LCo, BLi, ULe, Ppd, Rep, RLe)

NTSTATUS __stdcall
HidP_GetUsagesEx (
    __in    HIDP_REPORT_TYPE    ReportType,
    __in    USHORT  LinkCollection, // Optional
    IN OUT PUSAGE_AND_PAGE  ButtonList,
    __inout   ULONG * UsageLength,
    IN PHIDP_PREPARSED_DATA PreparsedData,
    __in_bcount(ReportLength)   PCHAR   Report,
    __in ULONG  ReportLength
   );

/*++

Routine Description:
    This function returns the binary values (buttons) in a HID report.
    Given a report packet of correct length, it searches the report packet
    for all buttons and returns the UsagePage and Usage for each of the buttons
    it finds.

Parameters:
    ReportType  One of HidP_Input, HidP_Output or HidP_Feature.

    LinkCollection  An optional value which can limit which usages are returned
                    in the ButtonList to those usages that exist in a specific
                    LinkCollection.  A non-zero value indicates the index into
                    the HIDP_LINK_COLLECITON_NODE list returned by
                    HidP_GetLinkCollectionNodes of the link collection the
                    usage should belong to.  A value of 0 indicates this
                    should value be ignored.

    ButtonList  An array of USAGE_AND_PAGE structures describing all the
                buttons currently ``down'' in the device.

    UsageLength The length of the given array in terms of elements.
                On input, this value describes the length of the list.  On
                output, HidP_GetUsagesEx sets this value to the number of
                usages that were found.  Use HidP_MaxUsageListLength to
                determine the maximum length needed to return all the usages
                that a given report packet may contain.

    PreparsedData Preparsed data returned by HIDCLASS

    Report       The report packet.

    ReportLength Length (in bytes) of the given report packet.


Return Value
    HidP_GetUsagesEx returns the following error codes:

  HIDP_STATUS_SUCCESS                -- upon successfully retrieving all the
                                        usages from the report packet
  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not
                                        equal to the length specified in
                                        the HIDP_CAPS structure for the given
                                        ReportType
  HIDP_STATUS_REPORT_DOES_NOT_EXIST  -- if there are no reports on this device
                                        for the given ReportType
  HIDP_STATUS_BUFFER_TOO_SMALL       -- if ButtonList is not big enough to
                                        hold all the usages found in the report
                                        packet.  If this is returned, the buffer
                                        will contain UsageLength number of
                                        usages.  Use HidP_MaxUsageListLength to
                                        find the maximum length needed
  HIDP_STATUS_INCOMPATIBLE_REPORT_ID -- if no usages were found but usages
                                        that match the specified LinkCollection
                                        exist in report with a different report
                                        ID.
  HIDP_STATUS_USAGE_NOT_FOUND        -- if there are no usages in any reports that
                                        match the LinkCollection parameter
--*/

#define HidP_GetButtonListLength(RTy, UPa, Ppd) \
        HidP_GetUsageListLength(Rty, UPa, Ppd)

ULONG __stdcall
HidP_MaxUsageListLength (
   IN HIDP_REPORT_TYPE      ReportType,
   IN USAGE                 UsagePage, // Optional
   IN PHIDP_PREPARSED_DATA  PreparsedData
   );
/*++
Routine Description:
    This function returns the maximum number of usages that a call to
    HidP_GetUsages or HidP_GetUsagesEx could return for a given HID report.
    If calling for number of usages returned by HidP_GetUsagesEx, use 0 as
    the UsagePage value.

Parameters:
    ReportType  One of HidP_Input, HidP_Output or HidP_Feature.

    UsagePage   Specifies the optional UsagePage to query for.  If 0, will
                return all the maximum number of usage values that could be
                returned for a given ReportType.   If non-zero, will return
                the maximum number of usages that would be returned for the
                ReportType with the given UsagePage.

    PreparsedData Preparsed data returned from HIDCLASS

Return Value:
    The length of the usage list array required for the HidP_GetUsages or
    HidP_GetUsagesEx function call.  If an error occurs (such as
    HIDP_STATUS_INVALID_REPORT_TYPE or HIDP_INVALID_PREPARSED_DATA, this
    returns 0.
--*/

NTSTATUS __stdcall
HidP_SetUsageValue (
    __in HIDP_REPORT_TYPE ReportType,
    __in USAGE UsagePage,
    __in USHORT LinkCollection,
    __in USAGE Usage,
    __in ULONG UsageValue,
    IN PHIDP_PREPARSED_DATA PreparsedData,
    __inout_bcount(ReportLength) PCHAR Report,
    __in ULONG ReportLength
    );
/*++
Description:
    HidP_SetUsageValue inserts a value into the HID Report Packet in the field
    corresponding to the given usage page and usage.  HidP_SetUsageValue
    casts this value to the appropriate bit length.  If a report packet
    contains two different fields with the same Usage and UsagePage,
    they can be distinguished with the optional LinkCollection field value.
    Using this function sets the raw value into the report packet with
    no checking done as to whether it actually falls within the logical
    minimum/logical maximum range.  Use HidP_SetScaledUsageValue for this...

    NOTE: Although the UsageValue parameter is a ULONG, any casting that is
          done will preserve or sign-extend the value.  The value being set
          should be considered a LONG value and will be treated as such by
          this function.

Parameters:

    ReportType  One of HidP_Output or HidP_Feature.

    UsagePage   The usage page to which the given usage refers.

    LinkCollection  (Optional)  This value can be used to differentiate
                                between two fields that may have the same
                                UsagePage and Usage but exist in different
                                collections.  If the link collection value
                                is zero, this function will set the first field
                                it finds that matches the usage page and
                                usage.

    Usage       The usage whose value HidP_SetUsageValue will set.

    UsageValue  The raw value to set in the report buffer.  This value must be within
                the logical range or if a NULL value this value should be the
                most negative value that can be represented by the number of bits
                for this field.

    PreparsedData The preparsed data returned for HIDCLASS

    Report      The report packet.

    ReportLength Length (in bytes) of the given report packet.


Return Value:
    HidP_SetUsageValue returns the following error codes:

  HIDP_STATUS_SUCCESS                -- upon successfully setting the value
                                        in the report packet
  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not
                                        equal to the length specified in
                                        the HIDP_CAPS structure for the given
                                        ReportType
  HIDP_STATUS_REPORT_DOES_NOT_EXIST  -- if there are no reports on this device
                                        for the given ReportType
  HIDP_STATUS_INCOMPATIBLE_REPORT_ID -- the specified usage page, usage and
                                        link collection exist but exists in
                                        a report with a different report ID
                                        than the report being passed in.  To
                                        set this value, call HidP_SetUsageValue
                                        again with a zero-initizialed report
                                        packet
  HIDP_STATUS_USAGE_NOT_FOUND        -- if the usage page, usage, and link
                                        collection combination does not exist
                                        in any reports for this ReportType
--*/

NTSTATUS __stdcall
HidP_SetScaledUsageValue (
    __in HIDP_REPORT_TYPE ReportType,
    __in USAGE UsagePage,
    __in USHORT LinkCollection,
    __in USAGE Usage,
    __in LONG UsageValue,
    IN PHIDP_PREPARSED_DATA PreparsedData,
    __inout_bcount(ReportLength) PCHAR Report,
    __in ULONG ReportLength
    );

/*++
Description:
    HidP_SetScaledUsageValue inserts the UsageValue into the HID report packet
    in the field corresponding to the given usage page and usage.  If a report
    packet contains two different fields with the same Usage and UsagePage,
    they can be distinguished with the optional LinkCollection field value.

    If the specified field has a defined physical range, this function converts
    the physical value specified to the corresponding logical value for the
    report.  If a physical value does not exist, the function will verify that
    the value specified falls within the logical range and set according.

    If the range checking fails but the field has NULL values, the function will
    set the field to the defined NULL value (most negative number possible) and
    return HIDP_STATUS_NULL.  In other words, use this function to set NULL
    values for a given field by passing in a value that falls outside the
    physical range if it is defined or the logical range otherwise.

    If the field does not support NULL values, an out of range error will be
    returned instead.

Parameters:

    ReportType  One of HidP_Output or HidP_Feature.

    UsagePage   The usage page to which the given usage refers.

    LinkCollection  (Optional)  This value can be used to differentiate
                                between two fields that may have the same
                                UsagePage and Usage but exist in different
                                collections.  If the link collection value
                                is zero, this function will set the first field
                                it finds that matches the usage page and
                                usage.

    Usage       The usage whose value HidP_SetScaledUsageValue will set.

    UsageValue  The value to set in the report buffer.  See the routine
                description above for the different interpretations of this
                value

    PreparsedData The preparsed data returned from HIDCLASS

    Report      The report packet.

    ReportLength Length (in bytes) of the given report packet.


Return Value:
   HidP_SetScaledUsageValue returns the following error codes:

  HIDP_STATUS_SUCCESS                -- upon successfully setting the value
                                        in the report packet
  HIDP_STATUS_NULL                   -- upon successfully setting the value
                                        in the report packet as a NULL value
  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not
                                        equal to the length specified in
                                        the HIDP_CAPS structure for the given
                                        ReportType
  HIDP_STATUS_VALUE_OUT_OF_RANGE     -- if the value specified failed to fall
                                        within the physical range if it exists
                                        or within the logical range otherwise
                                        and the field specified by the usage
                                        does not allow NULL values
  HIDP_STATUS_BAD_LOG_PHY_VALUES     -- if the field has a physical range but
                                        either the logical range is invalid
                                        (max <= min) or the physical range is
                                        invalid
  HIDP_STATUS_INCOMPATIBLE_REPORT_ID -- the specified usage page, usage and
                                        link collection exist but exists in
                                        a report with a different report ID
                                        than the report being passed in.  To
                                        set this value, call
                                        HidP_SetScaledUsageValue again with
                                        a zero-initialized report packet
  HIDP_STATUS_USAGE_NOT_FOUND        -- if the usage page, usage, and link
                                        collection combination does not exist
                                        in any reports for this ReportType
--*/

NTSTATUS __stdcall
HidP_SetUsageValueArray (
    __in HIDP_REPORT_TYPE ReportType,
    __in USAGE UsagePage,
    __in USHORT LinkCollection,
    __in USAGE Usage,
    __in_bcount(UsageValueByteLength) PCHAR UsageValue,
    __in USHORT UsageValueByteLength,
    IN PHIDP_PREPARSED_DATA PreparsedData,
    __inout_bcount(ReportLength) PCHAR Report,
    __in ULONG ReportLength
    );

/*++
Routine Descripton:
    A usage value array occurs when the last usage in the list of usages
    describing a main item must be repeated because there are less usages defined
    than there are report counts declared for the given main item.  In this case
    a single value cap is allocated for that usage and the report count of that
    value cap is set to reflect the number of fields to which that usage refers.

    HidP_SetUsageValueArray sets the raw bits for that usage which spans
    more than one field in a report.

    NOTE: This function currently does not support value arrays where the
          ReportSize for each of the fields in the array is not a multiple
          of 8 bits.

          The UsageValue buffer should have the values set as they would appear
          in the report buffer.  If this function supported non 8-bit multiples
          for the ReportSize then caller should format the input buffer so that
          each new value begins at the bit immediately following the last bit
          of the previous value

Parameters:

    ReportType  One of HidP_Output or HidP_Feature.

    UsagePage   The usage page to which the given usage refers.

    LinkCollection  (Optional)  This value can be used to differentiate
                                between two fields that may have the same
                                UsagePage and Usage but exist in different
                                collections.  If the link collection value
                                is zero, this function will set the first field
                                it finds that matches the usage page and
                                usage.

    Usage       The usage whose value array HidP_SetUsageValueArray will set.

    UsageValue  The buffer with the values to set into the value array.
                The number of BITS required is found by multiplying the
                BitSize and ReportCount fields of the Value Cap for this
                control.  The least significant bit of this control found in the
                given report will be placed in the least significan bit location
                of the array given (little-endian format), regardless of whether
                or not the field is byte alligned or if the BitSize is a multiple
                of sizeof (CHAR).

                See the above note for current implementation limitations.

    UsageValueByteLength  Length of the UsageValue buffer (in bytes)

    PreparsedData The preparsed data returned from HIDCLASS

    Report      The report packet.

    ReportLength Length (in bytes) of the given report packet.


Return Value:
  HIDP_STATUS_SUCCESS                -- upon successfully setting the value
                                        array in the report packet
  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not
                                        equal to the length specified in
                                        the HIDP_CAPS structure for the given
                                        ReportType
  HIDP_STATUS_REPORT_DOES_NOT_EXIST  -- if there are no reports on this device
                                        for the given ReportType
  HIDP_STATUS_NOT_VALUE_ARRAY        -- if the control specified is not a
                                        value array -- a value array will have
                                        a ReportCount field in the
                                        HIDP_VALUE_CAPS structure that is > 1
                                        Use HidP_SetUsageValue instead
  HIDP_STATUS_BUFFER_TOO_SMALL       -- if the size of the passed in buffer with
                                        the values to set is too small (ie. has
                                        fewer values than the number of fields in
                                        the array
  HIDP_STATUS_NOT_IMPLEMENTED        -- if the usage value array has field sizes
                                        that are not multiples of 8 bits, this
                                        error code is returned since the function
                                        currently does not handle setting into
                                        such arrays.
  HIDP_STATUS_INCOMPATIBLE_REPORT_ID -- the specified usage page, usage and
                                        link collection exist but exists in
                                        a report with a different report ID
                                        than the report being passed in.  To
                                        set this value, call
                                        HidP_SetUsageValueArray again with
                                        a zero-initialized report packet
  HIDP_STATUS_USAGE_NOT_FOUND        -- if the usage page, usage, and link
                                        collection combination does not exist
                                        in any reports for this ReportType
--*/


NTSTATUS __stdcall
HidP_GetUsageValue (
    __in HIDP_REPORT_TYPE ReportType,
    __in USAGE UsagePage,
    __in USHORT LinkCollection,
    __in USAGE Usage,
    __out PULONG UsageValue,
    IN PHIDP_PREPARSED_DATA PreparsedData,
    __in_bcount(ReportLength) PCHAR Report,
    __in ULONG ReportLength
    );

/*
Description
    HidP_GetUsageValue retrieves the value from the HID Report for the usage
    specified by the combination of usage page, usage and link collection.
    If a report packet contains two different fields with the same
    Usage and UsagePage, they can be distinguished with the optional
    LinkCollection field value.

Parameters:

    ReportType  One of HidP_Input or HidP_Feature.

    UsagePage   The usage page to which the given usage refers.

    LinkCollection  (Optional)  This value can be used to differentiate
                                between two fields that may have the same
                                UsagePage and Usage but exist in different
                                collections.  If the link collection value
                                is zero, this function will set the first field
                                it finds that matches the usage page and
                                usage.

    Usage       The usage whose value HidP_GetUsageValue will retrieve

    UsageValue  The raw value that is set for the specified field in the report
                buffer. This value will either fall within the logical range
                or if NULL values are allowed, a number outside the range to
                indicate a NULL

    PreparsedData The preparsed data returned for HIDCLASS

    Report      The report packet.

    ReportLength Length (in bytes) of the given report packet.


Return Value:
    HidP_GetUsageValue returns the following error codes:

  HIDP_STATUS_SUCCESS                -- upon successfully retrieving the value
                                        from the report packet
  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not
                                        equal to the length specified in
                                        the HIDP_CAPS structure for the given
                                        ReportType
  HIDP_STATUS_REPORT_DOES_NOT_EXIST  -- if there are no reports on this device
                                        for the given ReportType
  HIDP_STATUS_INCOMPATIBLE_REPORT_ID -- the specified usage page, usage and
                                        link collection exist but exists in
                                        a report with a different report ID
                                        than the report being passed in.  To
                                        set this value, call HidP_GetUsageValue
                                        again with a different report packet
  HIDP_STATUS_USAGE_NOT_FOUND        -- if the usage page, usage, and link
                                        collection combination does not exist
                                        in any reports for this ReportType
--*/


NTSTATUS __stdcall
HidP_GetScaledUsageValue (
    __in HIDP_REPORT_TYPE ReportType,
    __in USAGE UsagePage,
    __in USHORT LinkCollection,
    __in USAGE Usage,
    __out PLONG UsageValue,
    IN PHIDP_PREPARSED_DATA PreparsedData,
    __in_bcount(ReportLength) PCHAR Report,
    __in ULONG ReportLength
    );

/*++
Description
    HidP_GetScaledUsageValue retrieves a UsageValue from the HID report packet
    in the field corresponding to the given usage page and usage.  If a report
    packet contains two different fields with the same Usage and UsagePage,
    they can be distinguished with the optional LinkCollection field value.

    If the specified field has a defined physical range, this function converts
    the logical value that exists in the report packet to the corresponding
    physical value.  If a physical range does not exist, the function will
    return the logical value.  This function will check to verify that the
    logical value in the report falls within the declared logical range.

    When doing the conversion between logical and physical values, this
    function assumes a linear extrapolation between the physical max/min and
    the logical max/min. (Where logical is the values reported by the device
    and physical is the value returned by this function).  If the data field
    size is less than 32 bits, then HidP_GetScaledUsageValue will sign extend
    the value to 32 bits.

    If the range checking fails but the field has NULL values, the function
    will set UsageValue to 0 and return HIDP_STATUS_NULL.  Otherwise, it
    returns a HIDP_STATUS_OUT_OF_RANGE error.

Parameters:

    ReportType  One of HidP_Output or HidP_Feature.

    UsagePage   The usage page to which the given usage refers.

    LinkCollection  (Optional)  This value can be used to differentiate
                                between two fields that may have the same
                                UsagePage and Usage but exist in different
                                collections.  If the link collection value
                                is zero, this function will retrieve the first
                                field it finds that matches the usage page
                                and usage.

    Usage       The usage whose value HidP_GetScaledUsageValue will retrieve

    UsageValue  The value retrieved from the report buffer.  See the routine
                description above for the different interpretations of this
                value

    PreparsedData The preparsed data returned from HIDCLASS

    Report      The report packet.

    ReportLength Length (in bytes) of the given report packet.


Return Value:
   HidP_GetScaledUsageValue returns the following error codes:

  HIDP_STATUS_SUCCESS                -- upon successfully retrieving the value
                                        from the report packet
  HIDP_STATUS_NULL                   -- if the report packet had a NULL value
                                        set
  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not
                                        equal to the length specified in
                                        the HIDP_CAPS structure for the given
                                        ReportType
  HIDP_STATUS_VALUE_OUT_OF_RANGE     -- if the value retrieved from the packet
                                        falls outside the logical range and
                                        the field does not support NULL values
  HIDP_STATUS_BAD_LOG_PHY_VALUES     -- if the field has a physical range but
                                        either the logical range is invalid
                                        (max <= min) or the physical range is
                                        invalid
  HIDP_STATUS_INCOMPATIBLE_REPORT_ID -- the specified usage page, usage and
                                        link collection exist but exists in
                                        a report with a different report ID
                                        than the report being passed in.  To
                                        set this value, call
                                        HidP_GetScaledUsageValue with a
                                        different report packet
  HIDP_STATUS_USAGE_NOT_FOUND        -- if the usage page, usage, and link
                                        collection combination does not exist
                                        in any reports for this ReportType
--*/

NTSTATUS __stdcall
HidP_GetUsageValueArray (
    __in HIDP_REPORT_TYPE ReportType,
    __in USAGE UsagePage,
    __in USHORT LinkCollection,
    __in USAGE Usage,
    __inout_bcount(UsageValueByteLength) PCHAR UsageValue,
    __in USHORT UsageValueByteLength,
    IN PHIDP_PREPARSED_DATA PreparsedData,
    __in_bcount(ReportLength) PCHAR Report,
    __in ULONG ReportLength
    );

/*++
Routine Descripton:
    A usage value array occurs when the last usage in the list of usages
    describing a main item must be repeated because there are less usages defined
    than there are report counts declared for the given main item.  In this case
    a single value cap is allocated for that usage and the report count of that
    value cap is set to reflect the number of fields to which that usage refers.

    HidP_GetUsageValueArray returns the raw bits for that usage which spans
    more than one field in a report.

    NOTE: This function currently does not support value arrays where the
          ReportSize for each of the fields in the array is not a multiple
          of 8 bits.

          The UsageValue buffer will have the raw values as they are set
          in the report packet.

Parameters:

    ReportType  One of HidP_Input, HidP_Output or HidP_Feature.

    UsagePage   The usage page to which the given usage refers.

    LinkCollection  (Optional)  This value can be used to differentiate
                                between two fields that may have the same
                                UsagePage and Usage but exist in different
                                collections.  If the link collection value
                                is zero, this function will set the first field
                                it finds that matches the usage page and
                                usage.

   Usage       The usage whose value HidP_GetUsageValueArray will retreive.

   UsageValue  A pointer to an array of characters where the value will be
               placed.  The number of BITS required is found by multiplying the
               BitSize and ReportCount fields of the Value Cap for this
               control.  The least significant bit of this control found in the
               given report will be placed in the least significant bit location
               of the buffer (little-endian format), regardless of whether
               or not the field is byte aligned or if the BitSize is a multiple
               of sizeof (CHAR).

               See note above about current implementation limitations

   UsageValueByteLength
               the length of the given UsageValue buffer.

   PreparsedData The preparsed data returned by the HIDCLASS

   Report      The report packet.

   ReportLength   Length of the given report packet.

Return Value:

  HIDP_STATUS_SUCCESS                -- upon successfully retrieving the value
                                        from the report packet
  HIDP_STATUS_INVALID_REPORT_TYPE    -- if ReportType is not valid.
  HIDP_STATUS_INVALID_PREPARSED_DATA -- if PreparsedData is not valid
  HIDP_STATUS_INVALID_REPORT_LENGTH  -- the length of the report packet is not
                                        equal to the length specified in
                                        the HIDP_CAPS structure for the given
                                        ReportType
  HIDP_STATUS_NOT_VALUE_ARRAY        -- if the control specified is not a
                                        value array -- a value array will have
                                        a ReportCount field in the
                                        HIDP_VALUE_CAPS structure that is > 1
                                        Use HidP_GetUsageValue instead
  HIDP_STATUS_BUFFER_TOO_SMALL       -- if the size of the passed in buffer in
                                        which to return the array is too small
                                        (ie. has fewer values than the number of
                                        fields in the array
  HIDP_STATUS_NOT_IMPLEMENTED        -- if the usage value array has field sizes
                                        that are not multiples of 8 bits, this
                                        error code is returned since the function
                                        currently does not handle getting values
                                        from such arrays.
  HIDP_STATUS_INCOMPATIBLE_REPORT_ID -- the specified usage page, usage and
                                        link collection exist but exists in
                                        a report with a different report ID
                                        than the report being passed in.  To
                                        set this value, call
                                        HidP_GetUsageValueArray with a
                                        different report packet
  HIDP_STATUS_USAGE_NOT_FOUND        -- if the usage page, usage, and link
                                        collection combination does not exist
                                        in any reports for this ReportType
--*/

NTSTATUS __stdcall
HidP_UsageListDifference (
   __in_ecount(UsageListLength) PUSAGE  PreviousUsageList,
   __in_ecount(UsageListLength) PUSAGE  CurrentUsageList,
   __out_ecount(UsageListLength) PUSAGE  BreakUsageList,
   __out_ecount(UsageListLength) PUSAGE  MakeUsageList,
   __in ULONG    UsageListLength
    );
/*++
Routine Description:
    This function will return the difference between a two lists of usages
    (as might be returned from HidP_GetUsages),  In other words, it will return
    return a list of usages that are in the current list but not the previous
    list as well as a list of usages that are in the previous list but not
    the current list.

Parameters:

    PreviousUsageList   The list of usages before.
    CurrentUsageList    The list of usages now.
    BreakUsageList      Previous - Current.
    MakeUsageList       Current - Previous.
    UsageListLength     Represents the length of the usage lists in array
                        elements.  If comparing two lists with a differing
                        number of array elements, this value should be
                        the size of the larger of the two lists.  Any
                        zero found with a list indicates an early termination
                        of the list and any usages found after the first zero
                        will be ignored.
--*/

NTSTATUS __stdcall
HidP_UsageAndPageListDifference (
   __in_ecount(UsageListLength) PUSAGE_AND_PAGE PreviousUsageList,
   __in_ecount(UsageListLength) PUSAGE_AND_PAGE CurrentUsageList,
   __out_ecount(UsageListLength) PUSAGE_AND_PAGE BreakUsageList,
   __out_ecount(UsageListLength) PUSAGE_AND_PAGE MakeUsageList,
   __in ULONG           UsageListLength
   );

//
// Produce Make or Break Codes
//
typedef enum _HIDP_KEYBOARD_DIRECTION {
    HidP_Keyboard_Break,
    HidP_Keyboard_Make
} HIDP_KEYBOARD_DIRECTION;

//
// A bitmap of the current shift state of the keyboard when using the
// below keyboard usages to i8042 translation function.
//
typedef struct _HIDP_KEYBOARD_MODIFIER_STATE {
   union {
      struct {
         ULONG LeftControl: 1;
         ULONG LeftShift: 1;
         ULONG LeftAlt: 1;
         ULONG LeftGUI: 1;
         ULONG RightControl: 1;
         ULONG RightShift: 1;
         ULONG RightAlt: 1;
         ULONG RigthGUI: 1;
         ULONG CapsLock: 1;
         ULONG ScollLock: 1;
         ULONG NumLock: 1;
         ULONG Reserved: 21;
      };
      ULONG ul;
   };

} HIDP_KEYBOARD_MODIFIER_STATE, * PHIDP_KEYBOARD_MODIFIER_STATE;

//
// A call back function to give the i8042 scan codes to the caller of
// the below translation function.
//
typedef BOOLEAN (* PHIDP_INSERT_SCANCODES) (
                  IN PVOID Context,  // Some caller supplied context.
                  IN PCHAR NewScanCodes, // A list of i8042 scan codes.
                  IN ULONG Length // the length of the scan codes.
                  );

NTSTATUS __stdcall
HidP_TranslateUsageAndPagesToI8042ScanCodes (
    IN     PUSAGE_AND_PAGE               ChangedUsageList,
    IN     ULONG                         UsageListLength,
    IN     HIDP_KEYBOARD_DIRECTION       KeyAction,
    IN OUT PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
    IN     PHIDP_INSERT_SCANCODES        InsertCodesProcedure,
    IN     PVOID                         InsertCodesContext
    );
/*++
Routine Description:
Parameters:
--*/

NTSTATUS __stdcall
HidP_TranslateUsagesToI8042ScanCodes (
    IN     PUSAGE                        ChangedUsageList,
    IN     ULONG                         UsageListLength,
    IN     HIDP_KEYBOARD_DIRECTION       KeyAction,
    IN OUT PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
    IN     PHIDP_INSERT_SCANCODES        InsertCodesProcedure,
    IN     PVOID                         InsertCodesContext
    );
/*++
Routine Description:
Parameters:
--*/



//
// Define NT Status codes with Facility Code of FACILITY_HID_ERROR_CODE
//

// FACILITY_HID_ERROR_CODE defined in ntstatus.h
#ifndef FACILITY_HID_ERROR_CODE
#define FACILITY_HID_ERROR_CODE 0x11
#endif

#define HIDP_ERROR_CODES(SEV, CODE) \
        ((NTSTATUS) (((SEV) << 28) | (FACILITY_HID_ERROR_CODE << 16) | (CODE)))

#define HIDP_STATUS_SUCCESS                  (HIDP_ERROR_CODES(0x0,0))
#define HIDP_STATUS_NULL                     (HIDP_ERROR_CODES(0x8,1))
#define HIDP_STATUS_INVALID_PREPARSED_DATA   (HIDP_ERROR_CODES(0xC,1))
#define HIDP_STATUS_INVALID_REPORT_TYPE      (HIDP_ERROR_CODES(0xC,2))
#define HIDP_STATUS_INVALID_REPORT_LENGTH    (HIDP_ERROR_CODES(0xC,3))
#define HIDP_STATUS_USAGE_NOT_FOUND          (HIDP_ERROR_CODES(0xC,4))
#define HIDP_STATUS_VALUE_OUT_OF_RANGE       (HIDP_ERROR_CODES(0xC,5))
#define HIDP_STATUS_BAD_LOG_PHY_VALUES       (HIDP_ERROR_CODES(0xC,6))
#define HIDP_STATUS_BUFFER_TOO_SMALL         (HIDP_ERROR_CODES(0xC,7))
#define HIDP_STATUS_INTERNAL_ERROR           (HIDP_ERROR_CODES(0xC,8))
#define HIDP_STATUS_I8042_TRANS_UNKNOWN      (HIDP_ERROR_CODES(0xC,9))
#define HIDP_STATUS_INCOMPATIBLE_REPORT_ID   (HIDP_ERROR_CODES(0xC,0xA))
#define HIDP_STATUS_NOT_VALUE_ARRAY          (HIDP_ERROR_CODES(0xC,0xB))
#define HIDP_STATUS_IS_VALUE_ARRAY           (HIDP_ERROR_CODES(0xC,0xC))
#define HIDP_STATUS_DATA_INDEX_NOT_FOUND     (HIDP_ERROR_CODES(0xC,0xD))
#define HIDP_STATUS_DATA_INDEX_OUT_OF_RANGE  (HIDP_ERROR_CODES(0xC,0xE))
#define HIDP_STATUS_BUTTON_NOT_PRESSED       (HIDP_ERROR_CODES(0xC,0xF))
#define HIDP_STATUS_REPORT_DOES_NOT_EXIST    (HIDP_ERROR_CODES(0xC,0x10))
#define HIDP_STATUS_NOT_IMPLEMENTED          (HIDP_ERROR_CODES(0xC,0x20))

//
// We blundered this status code.
//
#define HIDP_STATUS_I8242_TRANS_UNKNOWN HIDP_STATUS_I8042_TRANS_UNKNOWN

#include <poppack.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\HostInfo.h ===
/******************************************************************************
*
*  File: HostInfo.h
*
*  Author:  Joel Alley
*
*  Date: June 4, 1998
*
*  Description:   This file contains the declaration of two interfaces 
*                 necessary for an ActiveX Script Host to change the LCID that 
*                 VBScript.dll uses for error messages.
*
*  Modifications:
******************************************************************************/
#ifndef HOST_INFO_H_INCLUDED
#define HOST_INFO_H_INCLUDED

// {1D044690-8923-11d0-ABD2-00A0C911E8B2}
const GUID IID_IHostInfoUpdate =
{ 0x1d044690, 0x8923, 0x11d0, { 0xab, 0xd2, 0x0, 0xa0, 0xc9, 0x11, 0xe8, 0xb2 } };

enum hostinfo
{
	hostinfoLocale = 0,
	hostinfoCodePage = 1,
	hostinfoErrorLocale = 2
};

class IHostInfoUpdate : public IUnknown
{
	public:
	// *** IUnknown Methods ***
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) = 0;
	STDMETHOD_(ULONG,AddRef)(void) = 0;
	STDMETHOD_(ULONG,Release)(void) = 0;

	// *** IHostInfoUpdate Methods ***
	STDMETHOD(UpdateInfo)(hostinfo hostinfoNew) = 0;
};

// {F8418AE0-9A5D-11d0-ABD4-00A0C911E8B2}
const GUID IID_IHostInfoProvider =
{ 0xf8418ae0, 0x9a5d, 0x11d0, { 0xab, 0xd4, 0x0, 0xa0, 0xc9, 0x11, 0xe8, 0xb2 } };

class IHostInfoProvider : public IUnknown
{

	public:

	// *** IUnknown Methods ***
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) = 0;
	STDMETHOD_(ULONG,AddRef)(void) = 0;
	STDMETHOD_(ULONG,Release)(void) = 0;

	// *** IHostInfoProvider Methods ***
	STDMETHOD(GetHostInfo)(hostinfo hostinfoRequest, void * * ppvInfo) = 0;
};

#endif // HOST_INFO_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\hidsdi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    HIDSDI.H

Abstract:

    This module contains the PUBLIC definitions for the
    code that implements the HID dll.

Environment:

    Kernel & user mode

--*/


#ifndef _HIDSDI_H
#define _HIDSDI_H

#include <pshpack4.h>

//#include "wtypes.h"

//#include <windef.h>
//#include <win32.h>
//#include <basetyps.h>

typedef LONG NTSTATUS;
#include "hidusage.h"
#include "hidpi.h"

typedef struct _HIDD_CONFIGURATION {
    PVOID    cookie;
    ULONG    size;
    ULONG    RingBufferSize;
} HIDD_CONFIGURATION, *PHIDD_CONFIGURATION;

typedef struct _HIDD_ATTRIBUTES {
    ULONG   Size; // = sizeof (struct _HIDD_ATTRIBUTES)

    //
    // Vendor ids of this hid device
    //
    USHORT  VendorID;
    USHORT  ProductID;
    USHORT  VersionNumber;

    //
    // Additional fields will be added to the end of this structure.
    //
} HIDD_ATTRIBUTES, *PHIDD_ATTRIBUTES;


BOOLEAN __stdcall
HidD_GetAttributes (
    IN  HANDLE              HidDeviceObject,
    OUT PHIDD_ATTRIBUTES    Attributes
    );
/*++
Routine Description:
    Fill in the given HIDD_ATTRIBUTES structure with the attributes of the
    given hid device.

--*/


void __stdcall
HidD_GetHidGuid (
   OUT   LPGUID   HidGuid
   );

BOOLEAN __stdcall
HidD_GetPreparsedData (
   IN    HANDLE                  HidDeviceObject,
   OUT   PHIDP_PREPARSED_DATA  * PreparsedData
   );
/*++
Routine Description:
    Given a handle to a valid Hid Class Device Object, retrieve the preparsed
    data for the device.  This routine will allocate the appropriately 
    sized buffer to hold this preparsed data.  It is up to client to call
    HidP_FreePreparsedData to free the memory allocated to this structure when
    it is no longer needed.

Arguments:
   HidDeviceObject A handle to a Hid Device that the client obtains using 
                   a call to CreateFile on a valid Hid device string name.
                   The string name can be obtained using standard PnP calls.

   PreparsedData   An opaque data structure used by other functions in this 
                   library to retrieve information about a given device.

Return Value:
   TRUE if successful.
   FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

BOOLEAN __stdcall
HidD_FreePreparsedData (
   IN    PHIDP_PREPARSED_DATA PreparsedData
   );

BOOLEAN __stdcall
HidD_FlushQueue (
   IN    HANDLE                HidDeviceObject
   );
/*++
Routine Description:
    Flush the input queue for the given HID device.

Arguments:
   HidDeviceObject A handle to a Hid Device that the client obtains using 
                   a call to CreateFile on a valid Hid device string name.
                   The string name can be obtained using standard PnP calls.

Return Value:
   TRUE if successful
   FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

BOOLEAN __stdcall
HidD_GetConfiguration (
   IN   HANDLE               HidDeviceObject,
   OUT  PHIDD_CONFIGURATION  Configuration,
   IN   ULONG                ConfigurationLength
   );
/*++
Routine Description:
    Get the configuration information for this Hid device

Arguments:
   HidDeviceObject      A handle to a Hid Device Object.

   Configuration        A configuration structure.  HidD_GetConfiguration MUST
                        be called before the configuration can be modified and
                        set using HidD_SetConfiguration

   ConfigurationLength  That is ``sizeof (HIDD_CONFIGURATION)''. Using this
                        parameter, we can later increase the length of the 
                        configuration array and not break older apps.

Return Value:
   TRUE if successful
   FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

BOOLEAN __stdcall
HidD_SetConfiguration (
   IN   HANDLE               HidDeviceObject,
   IN   PHIDD_CONFIGURATION  Configuration,
   IN   ULONG                ConfigurationLength
   );
/*++
Routine Description:
   Set the configuration information for this Hid device...
   
   NOTE: HidD_GetConfiguration must be called to retrieve the current 
         configuration information before this information can be modified 
         and set.

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    Configuration        A configuration structure.  HidD_GetConfiguration MUST
                         be called before the configuration can be modified and
                         set using HidD_SetConfiguration
 
    ConfigurationLength  That is ``sizeof (HIDD_CONFIGURATION)''. Using this
                         parameter, we can later increase the length of the 
                         configuration array and not break older apps.

Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

BOOLEAN __stdcall
HidD_GetFeature (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   );
/*++
Routine Description:
    Retrieve a feature report from a HID device.

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    ReportBuffer         The buffer that the feature report should be placed 
                         into.  The first byte of the buffer should be set to
                         the report ID of the desired report
 
    ReportBufferLength   The size (in bytes) of ReportBuffer.  This value 
                         should be greater than or equal to the 
                         FeatureReportByteLength field as specified in the 
                         HIDP_CAPS structure for the device
Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

BOOLEAN __stdcall
HidD_SetFeature (
   IN    HANDLE   HidDeviceObject,
   IN    PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   );
/*++
Routine Description:
    Send a feature report to a HID device.

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    ReportBuffer         The buffer of the feature report to send to the device
 
    ReportBufferLength   The size (in bytes) of ReportBuffer.  This value 
                         should be greater than or equal to the 
                         FeatureReportByteLength field as specified in the 
                         HIDP_CAPS structure for the device
Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

#if (NTDDI_VERSION >= NTDDI_WINXP) 
BOOLEAN __stdcall
HidD_GetInputReport (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   );
/*++
Routine Description:
    Retrieve an input report from a HID device.

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    ReportBuffer         The buffer that the input report should be placed 
                         into.  The first byte of the buffer should be set to
                         the report ID of the desired report
 
    ReportBufferLength   The size (in bytes) of ReportBuffer.  This value 
                         should be greater than or equal to the 
                         InputReportByteLength field as specified in the 
                         HIDP_CAPS structure for the device
Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

BOOLEAN __stdcall
HidD_SetOutputReport (
   IN    HANDLE   HidDeviceObject,
   IN    PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   );
/*++
Routine Description:
    Send an output report to a HID device.

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    ReportBuffer         The buffer of the output report to send to the device
 
    ReportBufferLength   The size (in bytes) of ReportBuffer.  This value 
                         should be greater than or equal to the 
                         OutputReportByteLength field as specified in the 
                         HIDP_CAPS structure for the device
Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

#endif

BOOLEAN __stdcall
HidD_GetNumInputBuffers (
    IN  HANDLE  HidDeviceObject,
    OUT PULONG  NumberBuffers
    );
/*++
Routine Description:
    This function returns the number of input buffers used by the specified
    file handle to the Hid device.  Each file object has a number of buffers
    associated with it to queue reports read from the device but which have
    not yet been read by the user-mode app with a handle to that device.

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    NumberBuffers        Number of buffers currently being used for this file
                         handle to the Hid device

Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

BOOLEAN __stdcall
HidD_SetNumInputBuffers (
    IN  HANDLE HidDeviceObject,
    OUT ULONG  NumberBuffers
    );
/*++

Routine Description:
    This function sets the number of input buffers used by the specified
    file handle to the Hid device.  Each file object has a number of buffers
    associated with it to queue reports read from the device but which have
    not yet been read by the user-mode app with a handle to that device.

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    NumberBuffers        New number of buffers to use for this file handle to
                         the Hid device

Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

BOOLEAN __stdcall
HidD_GetPhysicalDescriptor (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    Buffer,
   IN    ULONG    BufferLength
   );
/*++
Routine Description:
    This function retrieves the raw physical descriptor for the specified
    Hid device.  

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    Buffer               Buffer which on return will contain the physical
                         descriptor if one exists for the specified device
                         handle

    BufferLength         Length of buffer (in bytes)


Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

BOOLEAN __stdcall
HidD_GetManufacturerString (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    Buffer,
   IN    ULONG    BufferLength
   );
/*++
Routine Description:
    This function retrieves the manufacturer string from the specified 
    Hid device.  

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    Buffer               Buffer which on return will contain the manufacturer
                         string returned from the device.  This string is a 
                         wide-character string

    BufferLength         Length of Buffer (in bytes)


Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

BOOLEAN __stdcall
HidD_GetProductString (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    Buffer,
   IN    ULONG    BufferLength
   );
/*++
Routine Description:
    This function retrieves the product string from the specified 
    Hid device.  

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    Buffer               Buffer which on return will contain the product
                         string returned from the device.  This string is a 
                         wide-character string

    BufferLength         Length of Buffer (in bytes)


Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

BOOLEAN __stdcall
HidD_GetIndexedString (
   IN    HANDLE   HidDeviceObject,
   IN    ULONG    StringIndex,
   OUT   PVOID    Buffer,
   IN    ULONG    BufferLength
   );
/*++
Routine Description:
    This function retrieves a string from the specified Hid device that is
    specified with a certain string index.

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    StringIndex          Index of the string to retrieve

    Buffer               Buffer which on return will contain the product
                         string returned from the device.  This string is a 
                         wide-character string

    BufferLength         Length of Buffer (in bytes)

Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

BOOLEAN __stdcall
HidD_GetSerialNumberString (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    Buffer,
   IN    ULONG    BufferLength
   );
/*++
Routine Description:
    This function retrieves the serial number string from the specified 
    Hid device.  

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    Buffer               Buffer which on return will contain the serial number
                         string returned from the device.  This string is a 
                         wide-character string

    BufferLength         Length of Buffer (in bytes)

Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/

#if (NTDDI_VERSION >= NTDDI_WINXP) 
BOOLEAN __stdcall
HidD_GetMsGenreDescriptor (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    Buffer,
   IN    ULONG    BufferLength
   );
/*++
Routine Description:
    This function retrieves the Microsoft Genre descriptor from the specified 
    Hid device.  

Arguments:
    HidDeviceObject      A handle to a Hid Device Object.
 
    Buffer               Buffer which on return will contain the descriptor
                         returned from the device.
                         
    BufferLength         Length of Buffer (in bytes)

Return Value:
    TRUE if successful
    FALSE otherwise  -- Use GetLastError() to get extended error information
--*/
#endif


#include <poppack.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\gpmgmt.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for gpmgmt.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __gpmgmt_h__
#define __gpmgmt_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IGPM_FWD_DEFINED__
#define __IGPM_FWD_DEFINED__
typedef interface IGPM IGPM;
#endif 	/* __IGPM_FWD_DEFINED__ */


#ifndef __IGPMDomain_FWD_DEFINED__
#define __IGPMDomain_FWD_DEFINED__
typedef interface IGPMDomain IGPMDomain;
#endif 	/* __IGPMDomain_FWD_DEFINED__ */


#ifndef __IGPMBackupDir_FWD_DEFINED__
#define __IGPMBackupDir_FWD_DEFINED__
typedef interface IGPMBackupDir IGPMBackupDir;
#endif 	/* __IGPMBackupDir_FWD_DEFINED__ */


#ifndef __IGPMSitesContainer_FWD_DEFINED__
#define __IGPMSitesContainer_FWD_DEFINED__
typedef interface IGPMSitesContainer IGPMSitesContainer;
#endif 	/* __IGPMSitesContainer_FWD_DEFINED__ */


#ifndef __IGPMSearchCriteria_FWD_DEFINED__
#define __IGPMSearchCriteria_FWD_DEFINED__
typedef interface IGPMSearchCriteria IGPMSearchCriteria;
#endif 	/* __IGPMSearchCriteria_FWD_DEFINED__ */


#ifndef __IGPMTrustee_FWD_DEFINED__
#define __IGPMTrustee_FWD_DEFINED__
typedef interface IGPMTrustee IGPMTrustee;
#endif 	/* __IGPMTrustee_FWD_DEFINED__ */


#ifndef __IGPMPermission_FWD_DEFINED__
#define __IGPMPermission_FWD_DEFINED__
typedef interface IGPMPermission IGPMPermission;
#endif 	/* __IGPMPermission_FWD_DEFINED__ */


#ifndef __IGPMSecurityInfo_FWD_DEFINED__
#define __IGPMSecurityInfo_FWD_DEFINED__
typedef interface IGPMSecurityInfo IGPMSecurityInfo;
#endif 	/* __IGPMSecurityInfo_FWD_DEFINED__ */


#ifndef __IGPMBackup_FWD_DEFINED__
#define __IGPMBackup_FWD_DEFINED__
typedef interface IGPMBackup IGPMBackup;
#endif 	/* __IGPMBackup_FWD_DEFINED__ */


#ifndef __IGPMBackupCollection_FWD_DEFINED__
#define __IGPMBackupCollection_FWD_DEFINED__
typedef interface IGPMBackupCollection IGPMBackupCollection;
#endif 	/* __IGPMBackupCollection_FWD_DEFINED__ */


#ifndef __IGPMSOM_FWD_DEFINED__
#define __IGPMSOM_FWD_DEFINED__
typedef interface IGPMSOM IGPMSOM;
#endif 	/* __IGPMSOM_FWD_DEFINED__ */


#ifndef __IGPMSOMCollection_FWD_DEFINED__
#define __IGPMSOMCollection_FWD_DEFINED__
typedef interface IGPMSOMCollection IGPMSOMCollection;
#endif 	/* __IGPMSOMCollection_FWD_DEFINED__ */


#ifndef __IGPMWMIFilter_FWD_DEFINED__
#define __IGPMWMIFilter_FWD_DEFINED__
typedef interface IGPMWMIFilter IGPMWMIFilter;
#endif 	/* __IGPMWMIFilter_FWD_DEFINED__ */


#ifndef __IGPMWMIFilterCollection_FWD_DEFINED__
#define __IGPMWMIFilterCollection_FWD_DEFINED__
typedef interface IGPMWMIFilterCollection IGPMWMIFilterCollection;
#endif 	/* __IGPMWMIFilterCollection_FWD_DEFINED__ */


#ifndef __IGPMRSOP_FWD_DEFINED__
#define __IGPMRSOP_FWD_DEFINED__
typedef interface IGPMRSOP IGPMRSOP;
#endif 	/* __IGPMRSOP_FWD_DEFINED__ */


#ifndef __IGPMGPO_FWD_DEFINED__
#define __IGPMGPO_FWD_DEFINED__
typedef interface IGPMGPO IGPMGPO;
#endif 	/* __IGPMGPO_FWD_DEFINED__ */


#ifndef __IGPMGPOCollection_FWD_DEFINED__
#define __IGPMGPOCollection_FWD_DEFINED__
typedef interface IGPMGPOCollection IGPMGPOCollection;
#endif 	/* __IGPMGPOCollection_FWD_DEFINED__ */


#ifndef __IGPMGPOLink_FWD_DEFINED__
#define __IGPMGPOLink_FWD_DEFINED__
typedef interface IGPMGPOLink IGPMGPOLink;
#endif 	/* __IGPMGPOLink_FWD_DEFINED__ */


#ifndef __IGPMGPOLinksCollection_FWD_DEFINED__
#define __IGPMGPOLinksCollection_FWD_DEFINED__
typedef interface IGPMGPOLinksCollection IGPMGPOLinksCollection;
#endif 	/* __IGPMGPOLinksCollection_FWD_DEFINED__ */


#ifndef __IGPMCSECollection_FWD_DEFINED__
#define __IGPMCSECollection_FWD_DEFINED__
typedef interface IGPMCSECollection IGPMCSECollection;
#endif 	/* __IGPMCSECollection_FWD_DEFINED__ */


#ifndef __IGPMClientSideExtension_FWD_DEFINED__
#define __IGPMClientSideExtension_FWD_DEFINED__
typedef interface IGPMClientSideExtension IGPMClientSideExtension;
#endif 	/* __IGPMClientSideExtension_FWD_DEFINED__ */


#ifndef __IGPMAsyncCancel_FWD_DEFINED__
#define __IGPMAsyncCancel_FWD_DEFINED__
typedef interface IGPMAsyncCancel IGPMAsyncCancel;
#endif 	/* __IGPMAsyncCancel_FWD_DEFINED__ */


#ifndef __IGPMAsyncProgress_FWD_DEFINED__
#define __IGPMAsyncProgress_FWD_DEFINED__
typedef interface IGPMAsyncProgress IGPMAsyncProgress;
#endif 	/* __IGPMAsyncProgress_FWD_DEFINED__ */


#ifndef __IGPMStatusMsgCollection_FWD_DEFINED__
#define __IGPMStatusMsgCollection_FWD_DEFINED__
typedef interface IGPMStatusMsgCollection IGPMStatusMsgCollection;
#endif 	/* __IGPMStatusMsgCollection_FWD_DEFINED__ */


#ifndef __IGPMStatusMessage_FWD_DEFINED__
#define __IGPMStatusMessage_FWD_DEFINED__
typedef interface IGPMStatusMessage IGPMStatusMessage;
#endif 	/* __IGPMStatusMessage_FWD_DEFINED__ */


#ifndef __IGPMConstants_FWD_DEFINED__
#define __IGPMConstants_FWD_DEFINED__
typedef interface IGPMConstants IGPMConstants;
#endif 	/* __IGPMConstants_FWD_DEFINED__ */


#ifndef __IGPMResult_FWD_DEFINED__
#define __IGPMResult_FWD_DEFINED__
typedef interface IGPMResult IGPMResult;
#endif 	/* __IGPMResult_FWD_DEFINED__ */


#ifndef __IGPMMapEntryCollection_FWD_DEFINED__
#define __IGPMMapEntryCollection_FWD_DEFINED__
typedef interface IGPMMapEntryCollection IGPMMapEntryCollection;
#endif 	/* __IGPMMapEntryCollection_FWD_DEFINED__ */


#ifndef __IGPMMapEntry_FWD_DEFINED__
#define __IGPMMapEntry_FWD_DEFINED__
typedef interface IGPMMapEntry IGPMMapEntry;
#endif 	/* __IGPMMapEntry_FWD_DEFINED__ */


#ifndef __IGPMMigrationTable_FWD_DEFINED__
#define __IGPMMigrationTable_FWD_DEFINED__
typedef interface IGPMMigrationTable IGPMMigrationTable;
#endif 	/* __IGPMMigrationTable_FWD_DEFINED__ */


#ifndef __GPM_FWD_DEFINED__
#define __GPM_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPM GPM;
#else
typedef struct GPM GPM;
#endif /* __cplusplus */

#endif 	/* __GPM_FWD_DEFINED__ */


#ifndef __GPMDomain_FWD_DEFINED__
#define __GPMDomain_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMDomain GPMDomain;
#else
typedef struct GPMDomain GPMDomain;
#endif /* __cplusplus */

#endif 	/* __GPMDomain_FWD_DEFINED__ */


#ifndef __GPMSitesContainer_FWD_DEFINED__
#define __GPMSitesContainer_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMSitesContainer GPMSitesContainer;
#else
typedef struct GPMSitesContainer GPMSitesContainer;
#endif /* __cplusplus */

#endif 	/* __GPMSitesContainer_FWD_DEFINED__ */


#ifndef __GPMBackupDir_FWD_DEFINED__
#define __GPMBackupDir_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMBackupDir GPMBackupDir;
#else
typedef struct GPMBackupDir GPMBackupDir;
#endif /* __cplusplus */

#endif 	/* __GPMBackupDir_FWD_DEFINED__ */


#ifndef __GPMSOM_FWD_DEFINED__
#define __GPMSOM_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMSOM GPMSOM;
#else
typedef struct GPMSOM GPMSOM;
#endif /* __cplusplus */

#endif 	/* __GPMSOM_FWD_DEFINED__ */


#ifndef __GPMSearchCriteria_FWD_DEFINED__
#define __GPMSearchCriteria_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMSearchCriteria GPMSearchCriteria;
#else
typedef struct GPMSearchCriteria GPMSearchCriteria;
#endif /* __cplusplus */

#endif 	/* __GPMSearchCriteria_FWD_DEFINED__ */


#ifndef __GPMPermission_FWD_DEFINED__
#define __GPMPermission_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMPermission GPMPermission;
#else
typedef struct GPMPermission GPMPermission;
#endif /* __cplusplus */

#endif 	/* __GPMPermission_FWD_DEFINED__ */


#ifndef __GPMSecurityInfo_FWD_DEFINED__
#define __GPMSecurityInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMSecurityInfo GPMSecurityInfo;
#else
typedef struct GPMSecurityInfo GPMSecurityInfo;
#endif /* __cplusplus */

#endif 	/* __GPMSecurityInfo_FWD_DEFINED__ */


#ifndef __GPMBackup_FWD_DEFINED__
#define __GPMBackup_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMBackup GPMBackup;
#else
typedef struct GPMBackup GPMBackup;
#endif /* __cplusplus */

#endif 	/* __GPMBackup_FWD_DEFINED__ */


#ifndef __GPMBackupCollection_FWD_DEFINED__
#define __GPMBackupCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMBackupCollection GPMBackupCollection;
#else
typedef struct GPMBackupCollection GPMBackupCollection;
#endif /* __cplusplus */

#endif 	/* __GPMBackupCollection_FWD_DEFINED__ */


#ifndef __GPMSOMCollection_FWD_DEFINED__
#define __GPMSOMCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMSOMCollection GPMSOMCollection;
#else
typedef struct GPMSOMCollection GPMSOMCollection;
#endif /* __cplusplus */

#endif 	/* __GPMSOMCollection_FWD_DEFINED__ */


#ifndef __GPMWMIFilter_FWD_DEFINED__
#define __GPMWMIFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMWMIFilter GPMWMIFilter;
#else
typedef struct GPMWMIFilter GPMWMIFilter;
#endif /* __cplusplus */

#endif 	/* __GPMWMIFilter_FWD_DEFINED__ */


#ifndef __GPMWMIFilterCollection_FWD_DEFINED__
#define __GPMWMIFilterCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMWMIFilterCollection GPMWMIFilterCollection;
#else
typedef struct GPMWMIFilterCollection GPMWMIFilterCollection;
#endif /* __cplusplus */

#endif 	/* __GPMWMIFilterCollection_FWD_DEFINED__ */


#ifndef __GPMRSOP_FWD_DEFINED__
#define __GPMRSOP_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMRSOP GPMRSOP;
#else
typedef struct GPMRSOP GPMRSOP;
#endif /* __cplusplus */

#endif 	/* __GPMRSOP_FWD_DEFINED__ */


#ifndef __GPMGPO_FWD_DEFINED__
#define __GPMGPO_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMGPO GPMGPO;
#else
typedef struct GPMGPO GPMGPO;
#endif /* __cplusplus */

#endif 	/* __GPMGPO_FWD_DEFINED__ */


#ifndef __GPMGPOCollection_FWD_DEFINED__
#define __GPMGPOCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMGPOCollection GPMGPOCollection;
#else
typedef struct GPMGPOCollection GPMGPOCollection;
#endif /* __cplusplus */

#endif 	/* __GPMGPOCollection_FWD_DEFINED__ */


#ifndef __GPMGPOLink_FWD_DEFINED__
#define __GPMGPOLink_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMGPOLink GPMGPOLink;
#else
typedef struct GPMGPOLink GPMGPOLink;
#endif /* __cplusplus */

#endif 	/* __GPMGPOLink_FWD_DEFINED__ */


#ifndef __GPMGPOLinksCollection_FWD_DEFINED__
#define __GPMGPOLinksCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMGPOLinksCollection GPMGPOLinksCollection;
#else
typedef struct GPMGPOLinksCollection GPMGPOLinksCollection;
#endif /* __cplusplus */

#endif 	/* __GPMGPOLinksCollection_FWD_DEFINED__ */


#ifndef __GPMAsyncCancel_FWD_DEFINED__
#define __GPMAsyncCancel_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMAsyncCancel GPMAsyncCancel;
#else
typedef struct GPMAsyncCancel GPMAsyncCancel;
#endif /* __cplusplus */

#endif 	/* __GPMAsyncCancel_FWD_DEFINED__ */


#ifndef __GPMStatusMsgCollection_FWD_DEFINED__
#define __GPMStatusMsgCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMStatusMsgCollection GPMStatusMsgCollection;
#else
typedef struct GPMStatusMsgCollection GPMStatusMsgCollection;
#endif /* __cplusplus */

#endif 	/* __GPMStatusMsgCollection_FWD_DEFINED__ */


#ifndef __GPMStatusMessage_FWD_DEFINED__
#define __GPMStatusMessage_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMStatusMessage GPMStatusMessage;
#else
typedef struct GPMStatusMessage GPMStatusMessage;
#endif /* __cplusplus */

#endif 	/* __GPMStatusMessage_FWD_DEFINED__ */


#ifndef __GPMEnum_FWD_DEFINED__
#define __GPMEnum_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMEnum GPMEnum;
#else
typedef struct GPMEnum GPMEnum;
#endif /* __cplusplus */

#endif 	/* __GPMEnum_FWD_DEFINED__ */


#ifndef __GPMTrustee_FWD_DEFINED__
#define __GPMTrustee_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMTrustee GPMTrustee;
#else
typedef struct GPMTrustee GPMTrustee;
#endif /* __cplusplus */

#endif 	/* __GPMTrustee_FWD_DEFINED__ */


#ifndef __GPMClientSideExtension_FWD_DEFINED__
#define __GPMClientSideExtension_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMClientSideExtension GPMClientSideExtension;
#else
typedef struct GPMClientSideExtension GPMClientSideExtension;
#endif /* __cplusplus */

#endif 	/* __GPMClientSideExtension_FWD_DEFINED__ */


#ifndef __GPMCSECollection_FWD_DEFINED__
#define __GPMCSECollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMCSECollection GPMCSECollection;
#else
typedef struct GPMCSECollection GPMCSECollection;
#endif /* __cplusplus */

#endif 	/* __GPMCSECollection_FWD_DEFINED__ */


#ifndef __GPMConstants_FWD_DEFINED__
#define __GPMConstants_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMConstants GPMConstants;
#else
typedef struct GPMConstants GPMConstants;
#endif /* __cplusplus */

#endif 	/* __GPMConstants_FWD_DEFINED__ */


#ifndef __GPMResult_FWD_DEFINED__
#define __GPMResult_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMResult GPMResult;
#else
typedef struct GPMResult GPMResult;
#endif /* __cplusplus */

#endif 	/* __GPMResult_FWD_DEFINED__ */


#ifndef __GPMMapEntryCollection_FWD_DEFINED__
#define __GPMMapEntryCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMMapEntryCollection GPMMapEntryCollection;
#else
typedef struct GPMMapEntryCollection GPMMapEntryCollection;
#endif /* __cplusplus */

#endif 	/* __GPMMapEntryCollection_FWD_DEFINED__ */


#ifndef __GPMMapEntry_FWD_DEFINED__
#define __GPMMapEntry_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMMapEntry GPMMapEntry;
#else
typedef struct GPMMapEntry GPMMapEntry;
#endif /* __cplusplus */

#endif 	/* __GPMMapEntry_FWD_DEFINED__ */


#ifndef __GPMMigrationTable_FWD_DEFINED__
#define __GPMMigrationTable_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMMigrationTable GPMMigrationTable;
#else
typedef struct GPMMigrationTable GPMMigrationTable;
#endif /* __cplusplus */

#endif 	/* __GPMMigrationTable_FWD_DEFINED__ */


#ifndef __GPOReportProvider_FWD_DEFINED__
#define __GPOReportProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPOReportProvider GPOReportProvider;
#else
typedef struct GPOReportProvider GPOReportProvider;
#endif /* __cplusplus */

#endif 	/* __GPOReportProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_gpmgmt_0000 */
/* [local] */ 

typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0001
    {	rsopUnknown	= 0,
	rsopPlanning	= rsopUnknown + 1,
	rsopLogging	= rsopPlanning + 1
    } 	GPMRSOPMode;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0002
    {	permGPOApply	= 0x10000,
	permGPORead	= 0x10100,
	permGPOEdit	= 0x10101,
	permGPOEditSecurityAndDelete	= 0x10102,
	permGPOCustom	= 0x10103,
	permWMIFilterEdit	= 0x20000,
	permWMIFilterFullControl	= 0x20001,
	permWMIFilterCustom	= 0x20002,
	permSOMLink	= 0x1c0000,
	permSOMLogging	= 0x180100,
	permSOMPlanning	= 0x180200,
	permSOMWMICreate	= 0x100300,
	permSOMWMIFullControl	= 0x100301,
	permSOMGPOCreate	= 0x100400
    } 	GPMPermissionType;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0003
    {	gpoPermissions	= 0,
	gpoEffectivePermissions	= gpoPermissions + 1,
	gpoDisplayName	= gpoEffectivePermissions + 1,
	gpoWMIFilter	= gpoDisplayName + 1,
	gpoID	= gpoWMIFilter + 1,
	gpoComputerExtensions	= gpoID + 1,
	gpoUserExtensions	= gpoComputerExtensions + 1,
	somLinks	= gpoUserExtensions + 1,
	gpoDomain	= somLinks + 1,
	backupMostRecent	= gpoDomain + 1
    } 	GPMSearchProperty;

typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0004
    {	opEquals	= 0,
	opContains	= opEquals + 1,
	opNotContains	= opContains + 1,
	opNotEquals	= opNotContains + 1
    } 	GPMSearchOperation;

typedef /* [public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0005
    {	repXML	= 0,
	repHTML	= repXML + 1
    } 	GPMReportType;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0006
    {	typeUser	= 0,
	typeComputer	= typeUser + 1,
	typeLocalGroup	= typeComputer + 1,
	typeGlobalGroup	= typeLocalGroup + 1,
	typeUniversalGroup	= typeGlobalGroup + 1,
	typeUNCPath	= typeUniversalGroup + 1,
	typeUnknown	= typeUNCPath + 1
    } 	GPMEntryType;

typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0007
    {	opDestinationSameAsSource	= 0,
	opDestinationNone	= opDestinationSameAsSource + 1,
	opDestinationByRelativeName	= opDestinationNone + 1,
	opDestinationSet	= opDestinationByRelativeName + 1
    } 	GPMDestinationOption;

#define	GPM_USE_PDC	( 0 )

#define	GPM_USE_ANYDC	( 1 )

#define	GPM_DONOTUSE_W2KDC	( 2 )

#define	GPM_DONOT_VALIDATEDC	( 1 )

#define	GPM_MIGRATIONTABLE_ONLY	( 0x1 )

#define	GPM_PROCESS_SECURITY	( 0x2 )

#define	RSOP_NO_COMPUTER	( 0x10000 )

#define	RSOP_NO_USER	( 0x20000 )

#define	RSOP_PLANNING_ASSUME_SLOW_LINK	( 0x1 )

#define	RSOP_PLANNING_ASSUME_LOOPBACK_MERGE	( 0x2 )

#define	RSOP_PLANNING_ASSUME_LOOPBACK_REPLACE	( 0x4 )

#define	RSOP_PLANNING_ASSUME_USER_WQLFILTER_TRUE	( 0x8 )

#define	RSOP_PLANNING_ASSUME_COMP_WQLFILTER_TRUE	( 0x10 )

































extern RPC_IF_HANDLE __MIDL_itf_gpmgmt_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_gpmgmt_0000_v0_0_s_ifspec;

#ifndef __IGPM_INTERFACE_DEFINED__
#define __IGPM_INTERFACE_DEFINED__

/* interface IGPM */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPM;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F5FAE809-3BD6-4DA9-A65E-17665B41D763")
    IGPM : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDomain( 
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrDomainController,
            /* [in] */ long lDCFlags,
            /* [retval][out] */ IGPMDomain **pIGPMDomain) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetBackupDir( 
            /* [in] */ BSTR bstrBackupDir,
            /* [retval][out] */ IGPMBackupDir **pIGPMBackupDir) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSitesContainer( 
            /* [in] */ BSTR bstrForest,
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrDomainController,
            /* [in] */ long lDCFlags,
            /* [retval][out] */ IGPMSitesContainer **ppIGPMSitesContainer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRSOP( 
            /* [in] */ GPMRSOPMode gpmRSoPMode,
            /* [in] */ BSTR bstrNamespace,
            /* [in] */ long lFlags,
            /* [retval][out] */ IGPMRSOP **ppIGPMRSOP) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreatePermission( 
            /* [in] */ BSTR bstrTrustee,
            /* [in] */ GPMPermissionType perm,
            /* [in] */ VARIANT_BOOL bInheritable,
            /* [retval][out] */ IGPMPermission **ppPerm) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSearchCriteria( 
            /* [retval][out] */ IGPMSearchCriteria **ppIGPMSearchCriteria) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateTrustee( 
            /* [in] */ BSTR bstrTrustee,
            /* [retval][out] */ IGPMTrustee **ppIGPMTrustee) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetClientSideExtensions( 
            /* [retval][out] */ IGPMCSECollection **ppIGPMCSECollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConstants( 
            /* [retval][out] */ IGPMConstants **ppIGPMConstants) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMigrationTable( 
            /* [in] */ BSTR bstrMigrationTablePath,
            /* [retval][out] */ IGPMMigrationTable **ppMigrationTable) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateMigrationTable( 
            /* [retval][out] */ IGPMMigrationTable **ppMigrationTable) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitializeReporting( 
            /* [in] */ BSTR bstrAdmPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPM * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPM * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPM * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPM * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPM * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPM * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPM * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDomain )( 
            IGPM * This,
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrDomainController,
            /* [in] */ long lDCFlags,
            /* [retval][out] */ IGPMDomain **pIGPMDomain);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetBackupDir )( 
            IGPM * This,
            /* [in] */ BSTR bstrBackupDir,
            /* [retval][out] */ IGPMBackupDir **pIGPMBackupDir);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSitesContainer )( 
            IGPM * This,
            /* [in] */ BSTR bstrForest,
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrDomainController,
            /* [in] */ long lDCFlags,
            /* [retval][out] */ IGPMSitesContainer **ppIGPMSitesContainer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRSOP )( 
            IGPM * This,
            /* [in] */ GPMRSOPMode gpmRSoPMode,
            /* [in] */ BSTR bstrNamespace,
            /* [in] */ long lFlags,
            /* [retval][out] */ IGPMRSOP **ppIGPMRSOP);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreatePermission )( 
            IGPM * This,
            /* [in] */ BSTR bstrTrustee,
            /* [in] */ GPMPermissionType perm,
            /* [in] */ VARIANT_BOOL bInheritable,
            /* [retval][out] */ IGPMPermission **ppPerm);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateSearchCriteria )( 
            IGPM * This,
            /* [retval][out] */ IGPMSearchCriteria **ppIGPMSearchCriteria);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateTrustee )( 
            IGPM * This,
            /* [in] */ BSTR bstrTrustee,
            /* [retval][out] */ IGPMTrustee **ppIGPMTrustee);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetClientSideExtensions )( 
            IGPM * This,
            /* [retval][out] */ IGPMCSECollection **ppIGPMCSECollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConstants )( 
            IGPM * This,
            /* [retval][out] */ IGPMConstants **ppIGPMConstants);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMigrationTable )( 
            IGPM * This,
            /* [in] */ BSTR bstrMigrationTablePath,
            /* [retval][out] */ IGPMMigrationTable **ppMigrationTable);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateMigrationTable )( 
            IGPM * This,
            /* [retval][out] */ IGPMMigrationTable **ppMigrationTable);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InitializeReporting )( 
            IGPM * This,
            /* [in] */ BSTR bstrAdmPath);
        
        END_INTERFACE
    } IGPMVtbl;

    interface IGPM
    {
        CONST_VTBL struct IGPMVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPM_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPM_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPM_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPM_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPM_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPM_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPM_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPM_GetDomain(This,bstrDomain,bstrDomainController,lDCFlags,pIGPMDomain)	\
    (This)->lpVtbl -> GetDomain(This,bstrDomain,bstrDomainController,lDCFlags,pIGPMDomain)

#define IGPM_GetBackupDir(This,bstrBackupDir,pIGPMBackupDir)	\
    (This)->lpVtbl -> GetBackupDir(This,bstrBackupDir,pIGPMBackupDir)

#define IGPM_GetSitesContainer(This,bstrForest,bstrDomain,bstrDomainController,lDCFlags,ppIGPMSitesContainer)	\
    (This)->lpVtbl -> GetSitesContainer(This,bstrForest,bstrDomain,bstrDomainController,lDCFlags,ppIGPMSitesContainer)

#define IGPM_GetRSOP(This,gpmRSoPMode,bstrNamespace,lFlags,ppIGPMRSOP)	\
    (This)->lpVtbl -> GetRSOP(This,gpmRSoPMode,bstrNamespace,lFlags,ppIGPMRSOP)

#define IGPM_CreatePermission(This,bstrTrustee,perm,bInheritable,ppPerm)	\
    (This)->lpVtbl -> CreatePermission(This,bstrTrustee,perm,bInheritable,ppPerm)

#define IGPM_CreateSearchCriteria(This,ppIGPMSearchCriteria)	\
    (This)->lpVtbl -> CreateSearchCriteria(This,ppIGPMSearchCriteria)

#define IGPM_CreateTrustee(This,bstrTrustee,ppIGPMTrustee)	\
    (This)->lpVtbl -> CreateTrustee(This,bstrTrustee,ppIGPMTrustee)

#define IGPM_GetClientSideExtensions(This,ppIGPMCSECollection)	\
    (This)->lpVtbl -> GetClientSideExtensions(This,ppIGPMCSECollection)

#define IGPM_GetConstants(This,ppIGPMConstants)	\
    (This)->lpVtbl -> GetConstants(This,ppIGPMConstants)

#define IGPM_GetMigrationTable(This,bstrMigrationTablePath,ppMigrationTable)	\
    (This)->lpVtbl -> GetMigrationTable(This,bstrMigrationTablePath,ppMigrationTable)

#define IGPM_CreateMigrationTable(This,ppMigrationTable)	\
    (This)->lpVtbl -> CreateMigrationTable(This,ppMigrationTable)

#define IGPM_InitializeReporting(This,bstrAdmPath)	\
    (This)->lpVtbl -> InitializeReporting(This,bstrAdmPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetDomain_Proxy( 
    IGPM * This,
    /* [in] */ BSTR bstrDomain,
    /* [in] */ BSTR bstrDomainController,
    /* [in] */ long lDCFlags,
    /* [retval][out] */ IGPMDomain **pIGPMDomain);


void __RPC_STUB IGPM_GetDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetBackupDir_Proxy( 
    IGPM * This,
    /* [in] */ BSTR bstrBackupDir,
    /* [retval][out] */ IGPMBackupDir **pIGPMBackupDir);


void __RPC_STUB IGPM_GetBackupDir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetSitesContainer_Proxy( 
    IGPM * This,
    /* [in] */ BSTR bstrForest,
    /* [in] */ BSTR bstrDomain,
    /* [in] */ BSTR bstrDomainController,
    /* [in] */ long lDCFlags,
    /* [retval][out] */ IGPMSitesContainer **ppIGPMSitesContainer);


void __RPC_STUB IGPM_GetSitesContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetRSOP_Proxy( 
    IGPM * This,
    /* [in] */ GPMRSOPMode gpmRSoPMode,
    /* [in] */ BSTR bstrNamespace,
    /* [in] */ long lFlags,
    /* [retval][out] */ IGPMRSOP **ppIGPMRSOP);


void __RPC_STUB IGPM_GetRSOP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_CreatePermission_Proxy( 
    IGPM * This,
    /* [in] */ BSTR bstrTrustee,
    /* [in] */ GPMPermissionType perm,
    /* [in] */ VARIANT_BOOL bInheritable,
    /* [retval][out] */ IGPMPermission **ppPerm);


void __RPC_STUB IGPM_CreatePermission_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_CreateSearchCriteria_Proxy( 
    IGPM * This,
    /* [retval][out] */ IGPMSearchCriteria **ppIGPMSearchCriteria);


void __RPC_STUB IGPM_CreateSearchCriteria_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_CreateTrustee_Proxy( 
    IGPM * This,
    /* [in] */ BSTR bstrTrustee,
    /* [retval][out] */ IGPMTrustee **ppIGPMTrustee);


void __RPC_STUB IGPM_CreateTrustee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetClientSideExtensions_Proxy( 
    IGPM * This,
    /* [retval][out] */ IGPMCSECollection **ppIGPMCSECollection);


void __RPC_STUB IGPM_GetClientSideExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetConstants_Proxy( 
    IGPM * This,
    /* [retval][out] */ IGPMConstants **ppIGPMConstants);


void __RPC_STUB IGPM_GetConstants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetMigrationTable_Proxy( 
    IGPM * This,
    /* [in] */ BSTR bstrMigrationTablePath,
    /* [retval][out] */ IGPMMigrationTable **ppMigrationTable);


void __RPC_STUB IGPM_GetMigrationTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_CreateMigrationTable_Proxy( 
    IGPM * This,
    /* [retval][out] */ IGPMMigrationTable **ppMigrationTable);


void __RPC_STUB IGPM_CreateMigrationTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_InitializeReporting_Proxy( 
    IGPM * This,
    /* [in] */ BSTR bstrAdmPath);


void __RPC_STUB IGPM_InitializeReporting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPM_INTERFACE_DEFINED__ */


#ifndef __IGPMDomain_INTERFACE_DEFINED__
#define __IGPMDomain_INTERFACE_DEFINED__

/* interface IGPMDomain */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6B21CC14-5A00-4F44-A738-FEEC8A94C7E3")
    IGPMDomain : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainController( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Domain( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateGPO( 
            /* [retval][out] */ IGPMGPO **ppNewGPO) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGPO( 
            /* [in] */ BSTR bstrGuid,
            /* [retval][out] */ IGPMGPO **ppGPO) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchGPOs( 
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMGPOCollection **ppIGPMGPOCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RestoreGPO( 
            /* [in] */ IGPMBackup *pIGPMBackup,
            /* [in] */ long lDCFlags,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSOM( 
            /* [in] */ BSTR bstrPath,
            /* [retval][out] */ IGPMSOM **ppSOM) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchSOMs( 
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMSOMCollection **ppIGPMSOMCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWMIFilter( 
            /* [in] */ BSTR bstrPath,
            /* [retval][out] */ IGPMWMIFilter **ppWMIFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchWMIFilters( 
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMWMIFilterCollection **ppIGPMWMIFilterCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMDomain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMDomain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMDomain * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMDomain * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMDomain * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMDomain * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DomainController )( 
            IGPMDomain * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Domain )( 
            IGPMDomain * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateGPO )( 
            IGPMDomain * This,
            /* [retval][out] */ IGPMGPO **ppNewGPO);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetGPO )( 
            IGPMDomain * This,
            /* [in] */ BSTR bstrGuid,
            /* [retval][out] */ IGPMGPO **ppGPO);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SearchGPOs )( 
            IGPMDomain * This,
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMGPOCollection **ppIGPMGPOCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RestoreGPO )( 
            IGPMDomain * This,
            /* [in] */ IGPMBackup *pIGPMBackup,
            /* [in] */ long lDCFlags,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSOM )( 
            IGPMDomain * This,
            /* [in] */ BSTR bstrPath,
            /* [retval][out] */ IGPMSOM **ppSOM);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SearchSOMs )( 
            IGPMDomain * This,
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMSOMCollection **ppIGPMSOMCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetWMIFilter )( 
            IGPMDomain * This,
            /* [in] */ BSTR bstrPath,
            /* [retval][out] */ IGPMWMIFilter **ppWMIFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SearchWMIFilters )( 
            IGPMDomain * This,
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMWMIFilterCollection **ppIGPMWMIFilterCollection);
        
        END_INTERFACE
    } IGPMDomainVtbl;

    interface IGPMDomain
    {
        CONST_VTBL struct IGPMDomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMDomain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMDomain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMDomain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMDomain_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMDomain_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMDomain_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMDomain_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMDomain_get_DomainController(This,pVal)	\
    (This)->lpVtbl -> get_DomainController(This,pVal)

#define IGPMDomain_get_Domain(This,pVal)	\
    (This)->lpVtbl -> get_Domain(This,pVal)

#define IGPMDomain_CreateGPO(This,ppNewGPO)	\
    (This)->lpVtbl -> CreateGPO(This,ppNewGPO)

#define IGPMDomain_GetGPO(This,bstrGuid,ppGPO)	\
    (This)->lpVtbl -> GetGPO(This,bstrGuid,ppGPO)

#define IGPMDomain_SearchGPOs(This,pIGPMSearchCriteria,ppIGPMGPOCollection)	\
    (This)->lpVtbl -> SearchGPOs(This,pIGPMSearchCriteria,ppIGPMGPOCollection)

#define IGPMDomain_RestoreGPO(This,pIGPMBackup,lDCFlags,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> RestoreGPO(This,pIGPMBackup,lDCFlags,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMDomain_GetSOM(This,bstrPath,ppSOM)	\
    (This)->lpVtbl -> GetSOM(This,bstrPath,ppSOM)

#define IGPMDomain_SearchSOMs(This,pIGPMSearchCriteria,ppIGPMSOMCollection)	\
    (This)->lpVtbl -> SearchSOMs(This,pIGPMSearchCriteria,ppIGPMSOMCollection)

#define IGPMDomain_GetWMIFilter(This,bstrPath,ppWMIFilter)	\
    (This)->lpVtbl -> GetWMIFilter(This,bstrPath,ppWMIFilter)

#define IGPMDomain_SearchWMIFilters(This,pIGPMSearchCriteria,ppIGPMWMIFilterCollection)	\
    (This)->lpVtbl -> SearchWMIFilters(This,pIGPMSearchCriteria,ppIGPMWMIFilterCollection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMDomain_get_DomainController_Proxy( 
    IGPMDomain * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMDomain_get_DomainController_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMDomain_get_Domain_Proxy( 
    IGPMDomain * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMDomain_get_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_CreateGPO_Proxy( 
    IGPMDomain * This,
    /* [retval][out] */ IGPMGPO **ppNewGPO);


void __RPC_STUB IGPMDomain_CreateGPO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_GetGPO_Proxy( 
    IGPMDomain * This,
    /* [in] */ BSTR bstrGuid,
    /* [retval][out] */ IGPMGPO **ppGPO);


void __RPC_STUB IGPMDomain_GetGPO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_SearchGPOs_Proxy( 
    IGPMDomain * This,
    /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
    /* [retval][out] */ IGPMGPOCollection **ppIGPMGPOCollection);


void __RPC_STUB IGPMDomain_SearchGPOs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_RestoreGPO_Proxy( 
    IGPMDomain * This,
    /* [in] */ IGPMBackup *pIGPMBackup,
    /* [in] */ long lDCFlags,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMDomain_RestoreGPO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_GetSOM_Proxy( 
    IGPMDomain * This,
    /* [in] */ BSTR bstrPath,
    /* [retval][out] */ IGPMSOM **ppSOM);


void __RPC_STUB IGPMDomain_GetSOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_SearchSOMs_Proxy( 
    IGPMDomain * This,
    /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
    /* [retval][out] */ IGPMSOMCollection **ppIGPMSOMCollection);


void __RPC_STUB IGPMDomain_SearchSOMs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_GetWMIFilter_Proxy( 
    IGPMDomain * This,
    /* [in] */ BSTR bstrPath,
    /* [retval][out] */ IGPMWMIFilter **ppWMIFilter);


void __RPC_STUB IGPMDomain_GetWMIFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_SearchWMIFilters_Proxy( 
    IGPMDomain * This,
    /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
    /* [retval][out] */ IGPMWMIFilterCollection **ppIGPMWMIFilterCollection);


void __RPC_STUB IGPMDomain_SearchWMIFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMDomain_INTERFACE_DEFINED__ */


#ifndef __IGPMBackupDir_INTERFACE_DEFINED__
#define __IGPMBackupDir_INTERFACE_DEFINED__

/* interface IGPMBackupDir */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMBackupDir;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1568BED-0A93-4ACC-810F-AFE7081019B9")
    IGPMBackupDir : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BackupDirectory( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetBackup( 
            /* [in] */ BSTR bstrID,
            /* [retval][out] */ IGPMBackup **ppBackup) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchBackups( 
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMBackupCollection **ppIGPMBackupCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMBackupDirVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMBackupDir * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMBackupDir * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMBackupDir * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMBackupDir * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMBackupDir * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMBackupDir * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMBackupDir * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackupDirectory )( 
            IGPMBackupDir * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetBackup )( 
            IGPMBackupDir * This,
            /* [in] */ BSTR bstrID,
            /* [retval][out] */ IGPMBackup **ppBackup);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SearchBackups )( 
            IGPMBackupDir * This,
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMBackupCollection **ppIGPMBackupCollection);
        
        END_INTERFACE
    } IGPMBackupDirVtbl;

    interface IGPMBackupDir
    {
        CONST_VTBL struct IGPMBackupDirVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMBackupDir_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMBackupDir_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMBackupDir_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMBackupDir_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMBackupDir_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMBackupDir_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMBackupDir_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMBackupDir_get_BackupDirectory(This,pVal)	\
    (This)->lpVtbl -> get_BackupDirectory(This,pVal)

#define IGPMBackupDir_GetBackup(This,bstrID,ppBackup)	\
    (This)->lpVtbl -> GetBackup(This,bstrID,ppBackup)

#define IGPMBackupDir_SearchBackups(This,pIGPMSearchCriteria,ppIGPMBackupCollection)	\
    (This)->lpVtbl -> SearchBackups(This,pIGPMSearchCriteria,ppIGPMBackupCollection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackupDir_get_BackupDirectory_Proxy( 
    IGPMBackupDir * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackupDir_get_BackupDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMBackupDir_GetBackup_Proxy( 
    IGPMBackupDir * This,
    /* [in] */ BSTR bstrID,
    /* [retval][out] */ IGPMBackup **ppBackup);


void __RPC_STUB IGPMBackupDir_GetBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMBackupDir_SearchBackups_Proxy( 
    IGPMBackupDir * This,
    /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
    /* [retval][out] */ IGPMBackupCollection **ppIGPMBackupCollection);


void __RPC_STUB IGPMBackupDir_SearchBackups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMBackupDir_INTERFACE_DEFINED__ */


#ifndef __IGPMSitesContainer_INTERFACE_DEFINED__
#define __IGPMSitesContainer_INTERFACE_DEFINED__

/* interface IGPMSitesContainer */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMSitesContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4725A899-2782-4D27-A6BB-D499246FFD72")
    IGPMSitesContainer : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainController( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Domain( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Forest( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSite( 
            /* [in] */ BSTR bstrSiteName,
            /* [retval][out] */ IGPMSOM **ppSOM) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchSites( 
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMSOMCollection **ppIGPMSOMCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMSitesContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMSitesContainer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMSitesContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMSitesContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMSitesContainer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMSitesContainer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMSitesContainer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMSitesContainer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DomainController )( 
            IGPMSitesContainer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Domain )( 
            IGPMSitesContainer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Forest )( 
            IGPMSitesContainer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSite )( 
            IGPMSitesContainer * This,
            /* [in] */ BSTR bstrSiteName,
            /* [retval][out] */ IGPMSOM **ppSOM);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SearchSites )( 
            IGPMSitesContainer * This,
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMSOMCollection **ppIGPMSOMCollection);
        
        END_INTERFACE
    } IGPMSitesContainerVtbl;

    interface IGPMSitesContainer
    {
        CONST_VTBL struct IGPMSitesContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMSitesContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMSitesContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMSitesContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMSitesContainer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMSitesContainer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMSitesContainer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMSitesContainer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMSitesContainer_get_DomainController(This,pVal)	\
    (This)->lpVtbl -> get_DomainController(This,pVal)

#define IGPMSitesContainer_get_Domain(This,pVal)	\
    (This)->lpVtbl -> get_Domain(This,pVal)

#define IGPMSitesContainer_get_Forest(This,pVal)	\
    (This)->lpVtbl -> get_Forest(This,pVal)

#define IGPMSitesContainer_GetSite(This,bstrSiteName,ppSOM)	\
    (This)->lpVtbl -> GetSite(This,bstrSiteName,ppSOM)

#define IGPMSitesContainer_SearchSites(This,pIGPMSearchCriteria,ppIGPMSOMCollection)	\
    (This)->lpVtbl -> SearchSites(This,pIGPMSearchCriteria,ppIGPMSOMCollection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSitesContainer_get_DomainController_Proxy( 
    IGPMSitesContainer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMSitesContainer_get_DomainController_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSitesContainer_get_Domain_Proxy( 
    IGPMSitesContainer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMSitesContainer_get_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSitesContainer_get_Forest_Proxy( 
    IGPMSitesContainer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMSitesContainer_get_Forest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSitesContainer_GetSite_Proxy( 
    IGPMSitesContainer * This,
    /* [in] */ BSTR bstrSiteName,
    /* [retval][out] */ IGPMSOM **ppSOM);


void __RPC_STUB IGPMSitesContainer_GetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSitesContainer_SearchSites_Proxy( 
    IGPMSitesContainer * This,
    /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
    /* [retval][out] */ IGPMSOMCollection **ppIGPMSOMCollection);


void __RPC_STUB IGPMSitesContainer_SearchSites_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMSitesContainer_INTERFACE_DEFINED__ */


#ifndef __IGPMSearchCriteria_INTERFACE_DEFINED__
#define __IGPMSearchCriteria_INTERFACE_DEFINED__

/* interface IGPMSearchCriteria */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMSearchCriteria;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6F11C42-829B-48D4-83F5-3615B67DFC22")
    IGPMSearchCriteria : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ GPMSearchProperty searchProperty,
            /* [in] */ GPMSearchOperation searchOperation,
            /* [in] */ VARIANT varValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMSearchCriteriaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMSearchCriteria * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMSearchCriteria * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMSearchCriteria * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMSearchCriteria * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMSearchCriteria * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMSearchCriteria * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMSearchCriteria * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IGPMSearchCriteria * This,
            /* [in] */ GPMSearchProperty searchProperty,
            /* [in] */ GPMSearchOperation searchOperation,
            /* [in] */ VARIANT varValue);
        
        END_INTERFACE
    } IGPMSearchCriteriaVtbl;

    interface IGPMSearchCriteria
    {
        CONST_VTBL struct IGPMSearchCriteriaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMSearchCriteria_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMSearchCriteria_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMSearchCriteria_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMSearchCriteria_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMSearchCriteria_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMSearchCriteria_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMSearchCriteria_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMSearchCriteria_Add(This,searchProperty,searchOperation,varValue)	\
    (This)->lpVtbl -> Add(This,searchProperty,searchOperation,varValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSearchCriteria_Add_Proxy( 
    IGPMSearchCriteria * This,
    /* [in] */ GPMSearchProperty searchProperty,
    /* [in] */ GPMSearchOperation searchOperation,
    /* [in] */ VARIANT varValue);


void __RPC_STUB IGPMSearchCriteria_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMSearchCriteria_INTERFACE_DEFINED__ */


#ifndef __IGPMTrustee_INTERFACE_DEFINED__
#define __IGPMTrustee_INTERFACE_DEFINED__

/* interface IGPMTrustee */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMTrustee;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B466DA8-C1A4-4B2A-999A-BEFCDD56CEFB")
    IGPMTrustee : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeSid( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeName( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeDomain( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeDSPath( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeType( 
            /* [retval][out] */ long *lVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMTrusteeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMTrustee * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMTrustee * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMTrustee * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMTrustee * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMTrustee * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMTrustee * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMTrustee * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeSid )( 
            IGPMTrustee * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeName )( 
            IGPMTrustee * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeDomain )( 
            IGPMTrustee * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeDSPath )( 
            IGPMTrustee * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeType )( 
            IGPMTrustee * This,
            /* [retval][out] */ long *lVal);
        
        END_INTERFACE
    } IGPMTrusteeVtbl;

    interface IGPMTrustee
    {
        CONST_VTBL struct IGPMTrusteeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMTrustee_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMTrustee_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMTrustee_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMTrustee_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMTrustee_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMTrustee_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMTrustee_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMTrustee_get_TrusteeSid(This,bstrVal)	\
    (This)->lpVtbl -> get_TrusteeSid(This,bstrVal)

#define IGPMTrustee_get_TrusteeName(This,bstrVal)	\
    (This)->lpVtbl -> get_TrusteeName(This,bstrVal)

#define IGPMTrustee_get_TrusteeDomain(This,bstrVal)	\
    (This)->lpVtbl -> get_TrusteeDomain(This,bstrVal)

#define IGPMTrustee_get_TrusteeDSPath(This,pVal)	\
    (This)->lpVtbl -> get_TrusteeDSPath(This,pVal)

#define IGPMTrustee_get_TrusteeType(This,lVal)	\
    (This)->lpVtbl -> get_TrusteeType(This,lVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMTrustee_get_TrusteeSid_Proxy( 
    IGPMTrustee * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMTrustee_get_TrusteeSid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMTrustee_get_TrusteeName_Proxy( 
    IGPMTrustee * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMTrustee_get_TrusteeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMTrustee_get_TrusteeDomain_Proxy( 
    IGPMTrustee * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMTrustee_get_TrusteeDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMTrustee_get_TrusteeDSPath_Proxy( 
    IGPMTrustee * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMTrustee_get_TrusteeDSPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMTrustee_get_TrusteeType_Proxy( 
    IGPMTrustee * This,
    /* [retval][out] */ long *lVal);


void __RPC_STUB IGPMTrustee_get_TrusteeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMTrustee_INTERFACE_DEFINED__ */


#ifndef __IGPMPermission_INTERFACE_DEFINED__
#define __IGPMPermission_INTERFACE_DEFINED__

/* interface IGPMPermission */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMPermission;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("35EBCA40-E1A1-4A02-8905-D79416FB464A")
    IGPMPermission : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Inherited( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Inheritable( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Denied( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Permission( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Trustee( 
            /* [retval][out] */ IGPMTrustee **ppIGPMTrustee) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMPermissionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMPermission * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMPermission * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMPermission * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMPermission * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMPermission * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMPermission * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMPermission * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Inherited )( 
            IGPMPermission * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Inheritable )( 
            IGPMPermission * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Denied )( 
            IGPMPermission * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Permission )( 
            IGPMPermission * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Trustee )( 
            IGPMPermission * This,
            /* [retval][out] */ IGPMTrustee **ppIGPMTrustee);
        
        END_INTERFACE
    } IGPMPermissionVtbl;

    interface IGPMPermission
    {
        CONST_VTBL struct IGPMPermissionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMPermission_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMPermission_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMPermission_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMPermission_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMPermission_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMPermission_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMPermission_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMPermission_get_Inherited(This,pVal)	\
    (This)->lpVtbl -> get_Inherited(This,pVal)

#define IGPMPermission_get_Inheritable(This,pVal)	\
    (This)->lpVtbl -> get_Inheritable(This,pVal)

#define IGPMPermission_get_Denied(This,pVal)	\
    (This)->lpVtbl -> get_Denied(This,pVal)

#define IGPMPermission_get_Permission(This,pVal)	\
    (This)->lpVtbl -> get_Permission(This,pVal)

#define IGPMPermission_get_Trustee(This,ppIGPMTrustee)	\
    (This)->lpVtbl -> get_Trustee(This,ppIGPMTrustee)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_Inherited_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IGPMPermission_get_Inherited_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_Inheritable_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IGPMPermission_get_Inheritable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_Denied_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IGPMPermission_get_Denied_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_Permission_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMPermission_get_Permission_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_Trustee_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ IGPMTrustee **ppIGPMTrustee);


void __RPC_STUB IGPMPermission_get_Trustee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMPermission_INTERFACE_DEFINED__ */


#ifndef __IGPMSecurityInfo_INTERFACE_DEFINED__
#define __IGPMSecurityInfo_INTERFACE_DEFINED__

/* interface IGPMSecurityInfo */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMSecurityInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6C31ED4-1C93-4D3E-AE84-EB6D61161B60")
    IGPMSecurityInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppEnum) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IGPMPermission *pPerm) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ IGPMPermission *pPerm) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveTrustee( 
            /* [in] */ BSTR bstrTrustee) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMSecurityInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMSecurityInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMSecurityInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMSecurityInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMSecurityInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMSecurityInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMSecurityInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMSecurityInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMSecurityInfo * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMSecurityInfo * This,
            long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMSecurityInfo * This,
            /* [retval][out] */ IEnumVARIANT **ppEnum);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IGPMSecurityInfo * This,
            /* [in] */ IGPMPermission *pPerm);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IGPMSecurityInfo * This,
            /* [in] */ IGPMPermission *pPerm);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveTrustee )( 
            IGPMSecurityInfo * This,
            /* [in] */ BSTR bstrTrustee);
        
        END_INTERFACE
    } IGPMSecurityInfoVtbl;

    interface IGPMSecurityInfo
    {
        CONST_VTBL struct IGPMSecurityInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMSecurityInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMSecurityInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMSecurityInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMSecurityInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMSecurityInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMSecurityInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMSecurityInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMSecurityInfo_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMSecurityInfo_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMSecurityInfo_get__NewEnum(This,ppEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnum)

#define IGPMSecurityInfo_Add(This,pPerm)	\
    (This)->lpVtbl -> Add(This,pPerm)

#define IGPMSecurityInfo_Remove(This,pPerm)	\
    (This)->lpVtbl -> Remove(This,pPerm)

#define IGPMSecurityInfo_RemoveTrustee(This,bstrTrustee)	\
    (This)->lpVtbl -> RemoveTrustee(This,bstrTrustee)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSecurityInfo_get_Count_Proxy( 
    IGPMSecurityInfo * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMSecurityInfo_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSecurityInfo_get_Item_Proxy( 
    IGPMSecurityInfo * This,
    long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMSecurityInfo_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSecurityInfo_get__NewEnum_Proxy( 
    IGPMSecurityInfo * This,
    /* [retval][out] */ IEnumVARIANT **ppEnum);


void __RPC_STUB IGPMSecurityInfo_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSecurityInfo_Add_Proxy( 
    IGPMSecurityInfo * This,
    /* [in] */ IGPMPermission *pPerm);


void __RPC_STUB IGPMSecurityInfo_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSecurityInfo_Remove_Proxy( 
    IGPMSecurityInfo * This,
    /* [in] */ IGPMPermission *pPerm);


void __RPC_STUB IGPMSecurityInfo_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSecurityInfo_RemoveTrustee_Proxy( 
    IGPMSecurityInfo * This,
    /* [in] */ BSTR bstrTrustee);


void __RPC_STUB IGPMSecurityInfo_RemoveTrustee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMSecurityInfo_INTERFACE_DEFINED__ */


#ifndef __IGPMBackup_INTERFACE_DEFINED__
#define __IGPMBackup_INTERFACE_DEFINED__

/* interface IGPMBackup */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMBackup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D8A16A35-3B0D-416B-8D02-4DF6F95A7119")
    IGPMBackup : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPOID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPODomain( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPODisplayName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Timestamp( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Comment( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BackupDir( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateReport( 
            /* [in] */ GPMReportType gpmReportType,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateReportToFile( 
            /* [in] */ GPMReportType gpmReportType,
            /* [in] */ BSTR bstrTargetFilePath,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMBackupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMBackup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMBackup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMBackup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMBackup * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMBackup * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMBackup * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMBackup * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IGPMBackup * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPOID )( 
            IGPMBackup * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPODomain )( 
            IGPMBackup * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPODisplayName )( 
            IGPMBackup * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Timestamp )( 
            IGPMBackup * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Comment )( 
            IGPMBackup * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackupDir )( 
            IGPMBackup * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IGPMBackup * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateReport )( 
            IGPMBackup * This,
            /* [in] */ GPMReportType gpmReportType,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateReportToFile )( 
            IGPMBackup * This,
            /* [in] */ GPMReportType gpmReportType,
            /* [in] */ BSTR bstrTargetFilePath,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        END_INTERFACE
    } IGPMBackupVtbl;

    interface IGPMBackup
    {
        CONST_VTBL struct IGPMBackupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMBackup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMBackup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMBackup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMBackup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMBackup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMBackup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMBackup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMBackup_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IGPMBackup_get_GPOID(This,pVal)	\
    (This)->lpVtbl -> get_GPOID(This,pVal)

#define IGPMBackup_get_GPODomain(This,pVal)	\
    (This)->lpVtbl -> get_GPODomain(This,pVal)

#define IGPMBackup_get_GPODisplayName(This,pVal)	\
    (This)->lpVtbl -> get_GPODisplayName(This,pVal)

#define IGPMBackup_get_Timestamp(This,pVal)	\
    (This)->lpVtbl -> get_Timestamp(This,pVal)

#define IGPMBackup_get_Comment(This,pVal)	\
    (This)->lpVtbl -> get_Comment(This,pVal)

#define IGPMBackup_get_BackupDir(This,pVal)	\
    (This)->lpVtbl -> get_BackupDir(This,pVal)

#define IGPMBackup_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IGPMBackup_GenerateReport(This,gpmReportType,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> GenerateReport(This,gpmReportType,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMBackup_GenerateReportToFile(This,gpmReportType,bstrTargetFilePath,ppIGPMResult)	\
    (This)->lpVtbl -> GenerateReportToFile(This,gpmReportType,bstrTargetFilePath,ppIGPMResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_ID_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackup_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_GPOID_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackup_get_GPOID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_GPODomain_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackup_get_GPODomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_GPODisplayName_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackup_get_GPODisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_Timestamp_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IGPMBackup_get_Timestamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_Comment_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackup_get_Comment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_BackupDir_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackup_get_BackupDir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMBackup_Delete_Proxy( 
    IGPMBackup * This);


void __RPC_STUB IGPMBackup_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMBackup_GenerateReport_Proxy( 
    IGPMBackup * This,
    /* [in] */ GPMReportType gpmReportType,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMBackup_GenerateReport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMBackup_GenerateReportToFile_Proxy( 
    IGPMBackup * This,
    /* [in] */ GPMReportType gpmReportType,
    /* [in] */ BSTR bstrTargetFilePath,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMBackup_GenerateReportToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMBackup_INTERFACE_DEFINED__ */


#ifndef __IGPMBackupCollection_INTERFACE_DEFINED__
#define __IGPMBackupCollection_INTERFACE_DEFINED__

/* interface IGPMBackupCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMBackupCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C786FC0F-26D8-4BAB-A745-39CA7E800CAC")
    IGPMBackupCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppIGPMBackup) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMBackupCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMBackupCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMBackupCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMBackupCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMBackupCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMBackupCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMBackupCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMBackupCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMBackupCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMBackupCollection * This,
            long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMBackupCollection * This,
            /* [retval][out] */ IEnumVARIANT **ppIGPMBackup);
        
        END_INTERFACE
    } IGPMBackupCollectionVtbl;

    interface IGPMBackupCollection
    {
        CONST_VTBL struct IGPMBackupCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMBackupCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMBackupCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMBackupCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMBackupCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMBackupCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMBackupCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMBackupCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMBackupCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMBackupCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMBackupCollection_get__NewEnum(This,ppIGPMBackup)	\
    (This)->lpVtbl -> get__NewEnum(This,ppIGPMBackup)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackupCollection_get_Count_Proxy( 
    IGPMBackupCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMBackupCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackupCollection_get_Item_Proxy( 
    IGPMBackupCollection * This,
    long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMBackupCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackupCollection_get__NewEnum_Proxy( 
    IGPMBackupCollection * This,
    /* [retval][out] */ IEnumVARIANT **ppIGPMBackup);


void __RPC_STUB IGPMBackupCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMBackupCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMSOM_INTERFACE_DEFINED__
#define __IGPMSOM_INTERFACE_DEFINED__

/* interface IGPMSOM */
/* [unique][helpstring][dual][uuid][object] */ 

typedef /* [public][public][public][public][public] */ 
enum __MIDL_IGPMSOM_0001
    {	somSite	= 0,
	somDomain	= somSite + 1,
	somOU	= somDomain + 1
    } 	GPMSOMType;


EXTERN_C const IID IID_IGPMSOM;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0A7F09E-05A1-4F0C-8158-9E5C33684F6B")
    IGPMSOM : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPOInheritanceBlocked( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_GPOInheritanceBlocked( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateGPOLink( 
            /* [in] */ long lLinkPos,
            /* [in] */ IGPMGPO *pGPO,
            /* [retval][out] */ IGPMGPOLink **ppNewGPOLink) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ GPMSOMType *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGPOLinks( 
            /* [retval][out] */ IGPMGPOLinksCollection **ppGPOLinks) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInheritedGPOLinks( 
            /* [retval][out] */ IGPMGPOLinksCollection **ppGPOLinks) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSecurityInfo( 
            /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSecurityInfo( 
            /* [in] */ IGPMSecurityInfo *pSecurityInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMSOMVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMSOM * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMSOM * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMSOM * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMSOM * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMSOM * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMSOM * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMSOM * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPOInheritanceBlocked )( 
            IGPMSOM * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GPOInheritanceBlocked )( 
            IGPMSOM * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IGPMSOM * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IGPMSOM * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateGPOLink )( 
            IGPMSOM * This,
            /* [in] */ long lLinkPos,
            /* [in] */ IGPMGPO *pGPO,
            /* [retval][out] */ IGPMGPOLink **ppNewGPOLink);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IGPMSOM * This,
            /* [retval][out] */ GPMSOMType *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetGPOLinks )( 
            IGPMSOM * This,
            /* [retval][out] */ IGPMGPOLinksCollection **ppGPOLinks);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInheritedGPOLinks )( 
            IGPMSOM * This,
            /* [retval][out] */ IGPMGPOLinksCollection **ppGPOLinks);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSecurityInfo )( 
            IGPMSOM * This,
            /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSecurityInfo )( 
            IGPMSOM * This,
            /* [in] */ IGPMSecurityInfo *pSecurityInfo);
        
        END_INTERFACE
    } IGPMSOMVtbl;

    interface IGPMSOM
    {
        CONST_VTBL struct IGPMSOMVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMSOM_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMSOM_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMSOM_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMSOM_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMSOM_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMSOM_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMSOM_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMSOM_get_GPOInheritanceBlocked(This,pVal)	\
    (This)->lpVtbl -> get_GPOInheritanceBlocked(This,pVal)

#define IGPMSOM_put_GPOInheritanceBlocked(This,newVal)	\
    (This)->lpVtbl -> put_GPOInheritanceBlocked(This,newVal)

#define IGPMSOM_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IGPMSOM_get_Path(This,pVal)	\
    (This)->lpVtbl -> get_Path(This,pVal)

#define IGPMSOM_CreateGPOLink(This,lLinkPos,pGPO,ppNewGPOLink)	\
    (This)->lpVtbl -> CreateGPOLink(This,lLinkPos,pGPO,ppNewGPOLink)

#define IGPMSOM_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IGPMSOM_GetGPOLinks(This,ppGPOLinks)	\
    (This)->lpVtbl -> GetGPOLinks(This,ppGPOLinks)

#define IGPMSOM_GetInheritedGPOLinks(This,ppGPOLinks)	\
    (This)->lpVtbl -> GetInheritedGPOLinks(This,ppGPOLinks)

#define IGPMSOM_GetSecurityInfo(This,ppSecurityInfo)	\
    (This)->lpVtbl -> GetSecurityInfo(This,ppSecurityInfo)

#define IGPMSOM_SetSecurityInfo(This,pSecurityInfo)	\
    (This)->lpVtbl -> SetSecurityInfo(This,pSecurityInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOM_get_GPOInheritanceBlocked_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IGPMSOM_get_GPOInheritanceBlocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMSOM_put_GPOInheritanceBlocked_Proxy( 
    IGPMSOM * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IGPMSOM_put_GPOInheritanceBlocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOM_get_Name_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMSOM_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOM_get_Path_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMSOM_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSOM_CreateGPOLink_Proxy( 
    IGPMSOM * This,
    /* [in] */ long lLinkPos,
    /* [in] */ IGPMGPO *pGPO,
    /* [retval][out] */ IGPMGPOLink **ppNewGPOLink);


void __RPC_STUB IGPMSOM_CreateGPOLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOM_get_Type_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ GPMSOMType *pVal);


void __RPC_STUB IGPMSOM_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSOM_GetGPOLinks_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ IGPMGPOLinksCollection **ppGPOLinks);


void __RPC_STUB IGPMSOM_GetGPOLinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSOM_GetInheritedGPOLinks_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ IGPMGPOLinksCollection **ppGPOLinks);


void __RPC_STUB IGPMSOM_GetInheritedGPOLinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSOM_GetSecurityInfo_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo);


void __RPC_STUB IGPMSOM_GetSecurityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSOM_SetSecurityInfo_Proxy( 
    IGPMSOM * This,
    /* [in] */ IGPMSecurityInfo *pSecurityInfo);


void __RPC_STUB IGPMSOM_SetSecurityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMSOM_INTERFACE_DEFINED__ */


#ifndef __IGPMSOMCollection_INTERFACE_DEFINED__
#define __IGPMSOMCollection_INTERFACE_DEFINED__

/* interface IGPMSOMCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMSOMCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ADC1688E-00E4-4495-ABBA-BED200DF0CAB")
    IGPMSOMCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppIGPMSOM) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMSOMCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMSOMCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMSOMCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMSOMCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMSOMCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMSOMCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMSOMCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMSOMCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMSOMCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMSOMCollection * This,
            long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMSOMCollection * This,
            /* [retval][out] */ IEnumVARIANT **ppIGPMSOM);
        
        END_INTERFACE
    } IGPMSOMCollectionVtbl;

    interface IGPMSOMCollection
    {
        CONST_VTBL struct IGPMSOMCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMSOMCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMSOMCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMSOMCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMSOMCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMSOMCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMSOMCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMSOMCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMSOMCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMSOMCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMSOMCollection_get__NewEnum(This,ppIGPMSOM)	\
    (This)->lpVtbl -> get__NewEnum(This,ppIGPMSOM)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOMCollection_get_Count_Proxy( 
    IGPMSOMCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMSOMCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOMCollection_get_Item_Proxy( 
    IGPMSOMCollection * This,
    long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMSOMCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOMCollection_get__NewEnum_Proxy( 
    IGPMSOMCollection * This,
    /* [retval][out] */ IEnumVARIANT **ppIGPMSOM);


void __RPC_STUB IGPMSOMCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMSOMCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMWMIFilter_INTERFACE_DEFINED__
#define __IGPMWMIFilter_INTERFACE_DEFINED__

/* interface IGPMWMIFilter */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMWMIFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EF2FF9B4-3C27-459A-B979-038305CEC75D")
    IGPMWMIFilter : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetQueryList( 
            /* [retval][out] */ VARIANT *pQryList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSecurityInfo( 
            /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSecurityInfo( 
            /* [in] */ IGPMSecurityInfo *pSecurityInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMWMIFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMWMIFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMWMIFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMWMIFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMWMIFilter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMWMIFilter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMWMIFilter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMWMIFilter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IGPMWMIFilter * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IGPMWMIFilter * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IGPMWMIFilter * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IGPMWMIFilter * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IGPMWMIFilter * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetQueryList )( 
            IGPMWMIFilter * This,
            /* [retval][out] */ VARIANT *pQryList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSecurityInfo )( 
            IGPMWMIFilter * This,
            /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSecurityInfo )( 
            IGPMWMIFilter * This,
            /* [in] */ IGPMSecurityInfo *pSecurityInfo);
        
        END_INTERFACE
    } IGPMWMIFilterVtbl;

    interface IGPMWMIFilter
    {
        CONST_VTBL struct IGPMWMIFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMWMIFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMWMIFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMWMIFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMWMIFilter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMWMIFilter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMWMIFilter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMWMIFilter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMWMIFilter_get_Path(This,pVal)	\
    (This)->lpVtbl -> get_Path(This,pVal)

#define IGPMWMIFilter_put_Name(This,newVal)	\
    (This)->lpVtbl -> put_Name(This,newVal)

#define IGPMWMIFilter_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IGPMWMIFilter_put_Description(This,newVal)	\
    (This)->lpVtbl -> put_Description(This,newVal)

#define IGPMWMIFilter_get_Description(This,pVal)	\
    (This)->lpVtbl -> get_Description(This,pVal)

#define IGPMWMIFilter_GetQueryList(This,pQryList)	\
    (This)->lpVtbl -> GetQueryList(This,pQryList)

#define IGPMWMIFilter_GetSecurityInfo(This,ppSecurityInfo)	\
    (This)->lpVtbl -> GetSecurityInfo(This,ppSecurityInfo)

#define IGPMWMIFilter_SetSecurityInfo(This,pSecurityInfo)	\
    (This)->lpVtbl -> SetSecurityInfo(This,pSecurityInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_get_Path_Proxy( 
    IGPMWMIFilter * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMWMIFilter_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_put_Name_Proxy( 
    IGPMWMIFilter * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IGPMWMIFilter_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_get_Name_Proxy( 
    IGPMWMIFilter * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMWMIFilter_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_put_Description_Proxy( 
    IGPMWMIFilter * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IGPMWMIFilter_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_get_Description_Proxy( 
    IGPMWMIFilter * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMWMIFilter_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_GetQueryList_Proxy( 
    IGPMWMIFilter * This,
    /* [retval][out] */ VARIANT *pQryList);


void __RPC_STUB IGPMWMIFilter_GetQueryList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_GetSecurityInfo_Proxy( 
    IGPMWMIFilter * This,
    /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo);


void __RPC_STUB IGPMWMIFilter_GetSecurityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_SetSecurityInfo_Proxy( 
    IGPMWMIFilter * This,
    /* [in] */ IGPMSecurityInfo *pSecurityInfo);


void __RPC_STUB IGPMWMIFilter_SetSecurityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMWMIFilter_INTERFACE_DEFINED__ */


#ifndef __IGPMWMIFilterCollection_INTERFACE_DEFINED__
#define __IGPMWMIFilterCollection_INTERFACE_DEFINED__

/* interface IGPMWMIFilterCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMWMIFilterCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5782D582-1A36-4661-8A94-C3C32551945B")
    IGPMWMIFilterCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMWMIFilterCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMWMIFilterCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMWMIFilterCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMWMIFilterCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMWMIFilterCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMWMIFilterCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMWMIFilterCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMWMIFilterCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMWMIFilterCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMWMIFilterCollection * This,
            long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMWMIFilterCollection * This,
            /* [retval][out] */ IEnumVARIANT **pVal);
        
        END_INTERFACE
    } IGPMWMIFilterCollectionVtbl;

    interface IGPMWMIFilterCollection
    {
        CONST_VTBL struct IGPMWMIFilterCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMWMIFilterCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMWMIFilterCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMWMIFilterCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMWMIFilterCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMWMIFilterCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMWMIFilterCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMWMIFilterCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMWMIFilterCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMWMIFilterCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMWMIFilterCollection_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilterCollection_get_Count_Proxy( 
    IGPMWMIFilterCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMWMIFilterCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilterCollection_get_Item_Proxy( 
    IGPMWMIFilterCollection * This,
    long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMWMIFilterCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilterCollection_get__NewEnum_Proxy( 
    IGPMWMIFilterCollection * This,
    /* [retval][out] */ IEnumVARIANT **pVal);


void __RPC_STUB IGPMWMIFilterCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMWMIFilterCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMRSOP_INTERFACE_DEFINED__
#define __IGPMRSOP_INTERFACE_DEFINED__

/* interface IGPMRSOP */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMRSOP;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49ED785A-3237-4FF2-B1F0-FDF5A8D5A1EE")
    IGPMRSOP : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [retval][out] */ GPMRSOPMode *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Namespace( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LoggingComputer( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingComputer( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LoggingUser( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingUser( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LoggingFlags( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingFlags( 
            /* [retval][out] */ long *lVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningFlags( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningFlags( 
            /* [retval][out] */ long *lVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningDomainController( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningDomainController( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningSiteName( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningSiteName( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningUser( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningUser( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningUserSOM( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningUserSOM( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningUserWMIFilters( 
            /* [in] */ VARIANT varVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningUserWMIFilters( 
            /* [retval][out] */ VARIANT *varVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningUserSecurityGroups( 
            /* [in] */ VARIANT varVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningUserSecurityGroups( 
            /* [retval][out] */ VARIANT *varVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningComputer( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningComputer( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningComputerSOM( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningComputerSOM( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningComputerWMIFilters( 
            /* [in] */ VARIANT varVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningComputerWMIFilters( 
            /* [retval][out] */ VARIANT *varVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningComputerSecurityGroups( 
            /* [in] */ VARIANT varVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningComputerSecurityGroups( 
            /* [retval][out] */ VARIANT *varVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoggingEnumerateUsers( 
            /* [retval][out] */ VARIANT *varVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateQueryResults( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseQueryResults( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateReport( 
            /* [in] */ GPMReportType gpmReportType,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateReportToFile( 
            /* [in] */ GPMReportType gpmReportType,
            /* [in] */ BSTR bstrTargetFilePath,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMRSOPVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMRSOP * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMRSOP * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMRSOP * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMRSOP * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMRSOP * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMRSOP * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMRSOP * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IGPMRSOP * This,
            /* [retval][out] */ GPMRSOPMode *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Namespace )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoggingComputer )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoggingComputer )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoggingUser )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoggingUser )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoggingFlags )( 
            IGPMRSOP * This,
            /* [in] */ long lVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoggingFlags )( 
            IGPMRSOP * This,
            /* [retval][out] */ long *lVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningFlags )( 
            IGPMRSOP * This,
            /* [in] */ long lVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningFlags )( 
            IGPMRSOP * This,
            /* [retval][out] */ long *lVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningDomainController )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningDomainController )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningSiteName )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningSiteName )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningUser )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningUser )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningUserSOM )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningUserSOM )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningUserWMIFilters )( 
            IGPMRSOP * This,
            /* [in] */ VARIANT varVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningUserWMIFilters )( 
            IGPMRSOP * This,
            /* [retval][out] */ VARIANT *varVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningUserSecurityGroups )( 
            IGPMRSOP * This,
            /* [in] */ VARIANT varVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningUserSecurityGroups )( 
            IGPMRSOP * This,
            /* [retval][out] */ VARIANT *varVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningComputer )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningComputer )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningComputerSOM )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningComputerSOM )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningComputerWMIFilters )( 
            IGPMRSOP * This,
            /* [in] */ VARIANT varVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningComputerWMIFilters )( 
            IGPMRSOP * This,
            /* [retval][out] */ VARIANT *varVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningComputerSecurityGroups )( 
            IGPMRSOP * This,
            /* [in] */ VARIANT varVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningComputerSecurityGroups )( 
            IGPMRSOP * This,
            /* [retval][out] */ VARIANT *varVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoggingEnumerateUsers )( 
            IGPMRSOP * This,
            /* [retval][out] */ VARIANT *varVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateQueryResults )( 
            IGPMRSOP * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReleaseQueryResults )( 
            IGPMRSOP * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateReport )( 
            IGPMRSOP * This,
            /* [in] */ GPMReportType gpmReportType,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateReportToFile )( 
            IGPMRSOP * This,
            /* [in] */ GPMReportType gpmReportType,
            /* [in] */ BSTR bstrTargetFilePath,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        END_INTERFACE
    } IGPMRSOPVtbl;

    interface IGPMRSOP
    {
        CONST_VTBL struct IGPMRSOPVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMRSOP_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMRSOP_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMRSOP_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMRSOP_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMRSOP_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMRSOP_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMRSOP_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMRSOP_get_Mode(This,pVal)	\
    (This)->lpVtbl -> get_Mode(This,pVal)

#define IGPMRSOP_get_Namespace(This,bstrVal)	\
    (This)->lpVtbl -> get_Namespace(This,bstrVal)

#define IGPMRSOP_put_LoggingComputer(This,bstrVal)	\
    (This)->lpVtbl -> put_LoggingComputer(This,bstrVal)

#define IGPMRSOP_get_LoggingComputer(This,bstrVal)	\
    (This)->lpVtbl -> get_LoggingComputer(This,bstrVal)

#define IGPMRSOP_put_LoggingUser(This,bstrVal)	\
    (This)->lpVtbl -> put_LoggingUser(This,bstrVal)

#define IGPMRSOP_get_LoggingUser(This,bstrVal)	\
    (This)->lpVtbl -> get_LoggingUser(This,bstrVal)

#define IGPMRSOP_put_LoggingFlags(This,lVal)	\
    (This)->lpVtbl -> put_LoggingFlags(This,lVal)

#define IGPMRSOP_get_LoggingFlags(This,lVal)	\
    (This)->lpVtbl -> get_LoggingFlags(This,lVal)

#define IGPMRSOP_put_PlanningFlags(This,lVal)	\
    (This)->lpVtbl -> put_PlanningFlags(This,lVal)

#define IGPMRSOP_get_PlanningFlags(This,lVal)	\
    (This)->lpVtbl -> get_PlanningFlags(This,lVal)

#define IGPMRSOP_put_PlanningDomainController(This,bstrVal)	\
    (This)->lpVtbl -> put_PlanningDomainController(This,bstrVal)

#define IGPMRSOP_get_PlanningDomainController(This,bstrVal)	\
    (This)->lpVtbl -> get_PlanningDomainController(This,bstrVal)

#define IGPMRSOP_put_PlanningSiteName(This,bstrVal)	\
    (This)->lpVtbl -> put_PlanningSiteName(This,bstrVal)

#define IGPMRSOP_get_PlanningSiteName(This,bstrVal)	\
    (This)->lpVtbl -> get_PlanningSiteName(This,bstrVal)

#define IGPMRSOP_put_PlanningUser(This,bstrVal)	\
    (This)->lpVtbl -> put_PlanningUser(This,bstrVal)

#define IGPMRSOP_get_PlanningUser(This,bstrVal)	\
    (This)->lpVtbl -> get_PlanningUser(This,bstrVal)

#define IGPMRSOP_put_PlanningUserSOM(This,bstrVal)	\
    (This)->lpVtbl -> put_PlanningUserSOM(This,bstrVal)

#define IGPMRSOP_get_PlanningUserSOM(This,bstrVal)	\
    (This)->lpVtbl -> get_PlanningUserSOM(This,bstrVal)

#define IGPMRSOP_put_PlanningUserWMIFilters(This,varVal)	\
    (This)->lpVtbl -> put_PlanningUserWMIFilters(This,varVal)

#define IGPMRSOP_get_PlanningUserWMIFilters(This,varVal)	\
    (This)->lpVtbl -> get_PlanningUserWMIFilters(This,varVal)

#define IGPMRSOP_put_PlanningUserSecurityGroups(This,varVal)	\
    (This)->lpVtbl -> put_PlanningUserSecurityGroups(This,varVal)

#define IGPMRSOP_get_PlanningUserSecurityGroups(This,varVal)	\
    (This)->lpVtbl -> get_PlanningUserSecurityGroups(This,varVal)

#define IGPMRSOP_put_PlanningComputer(This,bstrVal)	\
    (This)->lpVtbl -> put_PlanningComputer(This,bstrVal)

#define IGPMRSOP_get_PlanningComputer(This,bstrVal)	\
    (This)->lpVtbl -> get_PlanningComputer(This,bstrVal)

#define IGPMRSOP_put_PlanningComputerSOM(This,bstrVal)	\
    (This)->lpVtbl -> put_PlanningComputerSOM(This,bstrVal)

#define IGPMRSOP_get_PlanningComputerSOM(This,bstrVal)	\
    (This)->lpVtbl -> get_PlanningComputerSOM(This,bstrVal)

#define IGPMRSOP_put_PlanningComputerWMIFilters(This,varVal)	\
    (This)->lpVtbl -> put_PlanningComputerWMIFilters(This,varVal)

#define IGPMRSOP_get_PlanningComputerWMIFilters(This,varVal)	\
    (This)->lpVtbl -> get_PlanningComputerWMIFilters(This,varVal)

#define IGPMRSOP_put_PlanningComputerSecurityGroups(This,varVal)	\
    (This)->lpVtbl -> put_PlanningComputerSecurityGroups(This,varVal)

#define IGPMRSOP_get_PlanningComputerSecurityGroups(This,varVal)	\
    (This)->lpVtbl -> get_PlanningComputerSecurityGroups(This,varVal)

#define IGPMRSOP_LoggingEnumerateUsers(This,varVal)	\
    (This)->lpVtbl -> LoggingEnumerateUsers(This,varVal)

#define IGPMRSOP_CreateQueryResults(This)	\
    (This)->lpVtbl -> CreateQueryResults(This)

#define IGPMRSOP_ReleaseQueryResults(This)	\
    (This)->lpVtbl -> ReleaseQueryResults(This)

#define IGPMRSOP_GenerateReport(This,gpmReportType,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> GenerateReport(This,gpmReportType,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMRSOP_GenerateReportToFile(This,gpmReportType,bstrTargetFilePath,ppIGPMResult)	\
    (This)->lpVtbl -> GenerateReportToFile(This,gpmReportType,bstrTargetFilePath,ppIGPMResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_Mode_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ GPMRSOPMode *pVal);


void __RPC_STUB IGPMRSOP_get_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_Namespace_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_Namespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_LoggingComputer_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_LoggingComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_LoggingComputer_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_LoggingComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_LoggingUser_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_LoggingUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_LoggingUser_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_LoggingUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_LoggingFlags_Proxy( 
    IGPMRSOP * This,
    /* [in] */ long lVal);


void __RPC_STUB IGPMRSOP_put_LoggingFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_LoggingFlags_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ long *lVal);


void __RPC_STUB IGPMRSOP_get_LoggingFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningFlags_Proxy( 
    IGPMRSOP * This,
    /* [in] */ long lVal);


void __RPC_STUB IGPMRSOP_put_PlanningFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningFlags_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ long *lVal);


void __RPC_STUB IGPMRSOP_get_PlanningFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningDomainController_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_PlanningDomainController_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningDomainController_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_PlanningDomainController_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningSiteName_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_PlanningSiteName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningSiteName_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_PlanningSiteName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningUser_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_PlanningUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningUser_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_PlanningUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningUserSOM_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_PlanningUserSOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningUserSOM_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_PlanningUserSOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningUserWMIFilters_Proxy( 
    IGPMRSOP * This,
    /* [in] */ VARIANT varVal);


void __RPC_STUB IGPMRSOP_put_PlanningUserWMIFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningUserWMIFilters_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ VARIANT *varVal);


void __RPC_STUB IGPMRSOP_get_PlanningUserWMIFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningUserSecurityGroups_Proxy( 
    IGPMRSOP * This,
    /* [in] */ VARIANT varVal);


void __RPC_STUB IGPMRSOP_put_PlanningUserSecurityGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningUserSecurityGroups_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ VARIANT *varVal);


void __RPC_STUB IGPMRSOP_get_PlanningUserSecurityGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningComputer_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_PlanningComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningComputer_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_PlanningComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningComputerSOM_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_PlanningComputerSOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningComputerSOM_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_PlanningComputerSOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningComputerWMIFilters_Proxy( 
    IGPMRSOP * This,
    /* [in] */ VARIANT varVal);


void __RPC_STUB IGPMRSOP_put_PlanningComputerWMIFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningComputerWMIFilters_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ VARIANT *varVal);


void __RPC_STUB IGPMRSOP_get_PlanningComputerWMIFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningComputerSecurityGroups_Proxy( 
    IGPMRSOP * This,
    /* [in] */ VARIANT varVal);


void __RPC_STUB IGPMRSOP_put_PlanningComputerSecurityGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningComputerSecurityGroups_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ VARIANT *varVal);


void __RPC_STUB IGPMRSOP_get_PlanningComputerSecurityGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_LoggingEnumerateUsers_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ VARIANT *varVal);


void __RPC_STUB IGPMRSOP_LoggingEnumerateUsers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_CreateQueryResults_Proxy( 
    IGPMRSOP * This);


void __RPC_STUB IGPMRSOP_CreateQueryResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_ReleaseQueryResults_Proxy( 
    IGPMRSOP * This);


void __RPC_STUB IGPMRSOP_ReleaseQueryResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_GenerateReport_Proxy( 
    IGPMRSOP * This,
    /* [in] */ GPMReportType gpmReportType,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMRSOP_GenerateReport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_GenerateReportToFile_Proxy( 
    IGPMRSOP * This,
    /* [in] */ GPMReportType gpmReportType,
    /* [in] */ BSTR bstrTargetFilePath,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMRSOP_GenerateReportToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMRSOP_INTERFACE_DEFINED__ */


#ifndef __IGPMGPO_INTERFACE_DEFINED__
#define __IGPMGPO_INTERFACE_DEFINED__

/* interface IGPMGPO */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMGPO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("58CC4352-1CA3-48E5-9864-1DA4D6E0D60F")
    IGPMGPO : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DisplayName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CreationTime( 
            /* [retval][out] */ DATE *pDate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModificationTime( 
            /* [retval][out] */ DATE *pDate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserDSVersionNumber( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerDSVersionNumber( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserSysvolVersionNumber( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerSysvolVersionNumber( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWMIFilter( 
            /* [retval][out] */ IGPMWMIFilter **ppIGPMWMIFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetWMIFilter( 
            /* [in] */ IGPMWMIFilter *pIGPMWMIFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetUserEnabled( 
            /* [in] */ VARIANT_BOOL vbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetComputerEnabled( 
            /* [in] */ VARIANT_BOOL vbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsUserEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsComputerEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSecurityInfo( 
            /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSecurityInfo( 
            /* [in] */ IGPMSecurityInfo *pSecurityInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Backup( 
            /* [in] */ BSTR bstrBackupDir,
            /* [in] */ BSTR bstrComment,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Import( 
            /* [in] */ long lFlags,
            /* [in] */ IGPMBackup *pIGPMBackup,
            /* [optional][in] */ VARIANT *pvarMigrationTable,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateReport( 
            /* [in] */ GPMReportType gpmReportType,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateReportToFile( 
            /* [in] */ GPMReportType gpmReportType,
            /* [in] */ BSTR bstrTargetFilePath,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyTo( 
            /* [in] */ long lFlags,
            /* [in] */ IGPMDomain *pIGPMDomain,
            /* [optional][in] */ VARIANT *pvarNewDisplayName,
            /* [optional][in] */ VARIANT *pvarMigrationTable,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSecurityDescriptor( 
            /* [in] */ long lFlags,
            /* [in] */ IDispatch *pSD) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSecurityDescriptor( 
            /* [in] */ long lFlags,
            /* [retval][out] */ IDispatch **ppSD) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsACLConsistent( 
            /* [retval][out] */ VARIANT_BOOL *pvbConsistent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MakeACLConsistent( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMGPOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMGPO * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMGPO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMGPO * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMGPO * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMGPO * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMGPO * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMGPO * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            IGPMGPO * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayName )( 
            IGPMGPO * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IGPMGPO * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IGPMGPO * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DomainName )( 
            IGPMGPO * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreationTime )( 
            IGPMGPO * This,
            /* [retval][out] */ DATE *pDate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModificationTime )( 
            IGPMGPO * This,
            /* [retval][out] */ DATE *pDate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserDSVersionNumber )( 
            IGPMGPO * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ComputerDSVersionNumber )( 
            IGPMGPO * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserSysvolVersionNumber )( 
            IGPMGPO * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ComputerSysvolVersionNumber )( 
            IGPMGPO * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetWMIFilter )( 
            IGPMGPO * This,
            /* [retval][out] */ IGPMWMIFilter **ppIGPMWMIFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetWMIFilter )( 
            IGPMGPO * This,
            /* [in] */ IGPMWMIFilter *pIGPMWMIFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetUserEnabled )( 
            IGPMGPO * This,
            /* [in] */ VARIANT_BOOL vbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetComputerEnabled )( 
            IGPMGPO * This,
            /* [in] */ VARIANT_BOOL vbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsUserEnabled )( 
            IGPMGPO * This,
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsComputerEnabled )( 
            IGPMGPO * This,
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSecurityInfo )( 
            IGPMGPO * This,
            /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSecurityInfo )( 
            IGPMGPO * This,
            /* [in] */ IGPMSecurityInfo *pSecurityInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IGPMGPO * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Backup )( 
            IGPMGPO * This,
            /* [in] */ BSTR bstrBackupDir,
            /* [in] */ BSTR bstrComment,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Import )( 
            IGPMGPO * This,
            /* [in] */ long lFlags,
            /* [in] */ IGPMBackup *pIGPMBackup,
            /* [optional][in] */ VARIANT *pvarMigrationTable,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateReport )( 
            IGPMGPO * This,
            /* [in] */ GPMReportType gpmReportType,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateReportToFile )( 
            IGPMGPO * This,
            /* [in] */ GPMReportType gpmReportType,
            /* [in] */ BSTR bstrTargetFilePath,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IGPMGPO * This,
            /* [in] */ long lFlags,
            /* [in] */ IGPMDomain *pIGPMDomain,
            /* [optional][in] */ VARIANT *pvarNewDisplayName,
            /* [optional][in] */ VARIANT *pvarMigrationTable,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSecurityDescriptor )( 
            IGPMGPO * This,
            /* [in] */ long lFlags,
            /* [in] */ IDispatch *pSD);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSecurityDescriptor )( 
            IGPMGPO * This,
            /* [in] */ long lFlags,
            /* [retval][out] */ IDispatch **ppSD);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsACLConsistent )( 
            IGPMGPO * This,
            /* [retval][out] */ VARIANT_BOOL *pvbConsistent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MakeACLConsistent )( 
            IGPMGPO * This);
        
        END_INTERFACE
    } IGPMGPOVtbl;

    interface IGPMGPO
    {
        CONST_VTBL struct IGPMGPOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMGPO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMGPO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMGPO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMGPO_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMGPO_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMGPO_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMGPO_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMGPO_get_DisplayName(This,pVal)	\
    (This)->lpVtbl -> get_DisplayName(This,pVal)

#define IGPMGPO_put_DisplayName(This,newVal)	\
    (This)->lpVtbl -> put_DisplayName(This,newVal)

#define IGPMGPO_get_Path(This,pVal)	\
    (This)->lpVtbl -> get_Path(This,pVal)

#define IGPMGPO_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IGPMGPO_get_DomainName(This,pVal)	\
    (This)->lpVtbl -> get_DomainName(This,pVal)

#define IGPMGPO_get_CreationTime(This,pDate)	\
    (This)->lpVtbl -> get_CreationTime(This,pDate)

#define IGPMGPO_get_ModificationTime(This,pDate)	\
    (This)->lpVtbl -> get_ModificationTime(This,pDate)

#define IGPMGPO_get_UserDSVersionNumber(This,pVal)	\
    (This)->lpVtbl -> get_UserDSVersionNumber(This,pVal)

#define IGPMGPO_get_ComputerDSVersionNumber(This,pVal)	\
    (This)->lpVtbl -> get_ComputerDSVersionNumber(This,pVal)

#define IGPMGPO_get_UserSysvolVersionNumber(This,pVal)	\
    (This)->lpVtbl -> get_UserSysvolVersionNumber(This,pVal)

#define IGPMGPO_get_ComputerSysvolVersionNumber(This,pVal)	\
    (This)->lpVtbl -> get_ComputerSysvolVersionNumber(This,pVal)

#define IGPMGPO_GetWMIFilter(This,ppIGPMWMIFilter)	\
    (This)->lpVtbl -> GetWMIFilter(This,ppIGPMWMIFilter)

#define IGPMGPO_SetWMIFilter(This,pIGPMWMIFilter)	\
    (This)->lpVtbl -> SetWMIFilter(This,pIGPMWMIFilter)

#define IGPMGPO_SetUserEnabled(This,vbEnabled)	\
    (This)->lpVtbl -> SetUserEnabled(This,vbEnabled)

#define IGPMGPO_SetComputerEnabled(This,vbEnabled)	\
    (This)->lpVtbl -> SetComputerEnabled(This,vbEnabled)

#define IGPMGPO_IsUserEnabled(This,pvbEnabled)	\
    (This)->lpVtbl -> IsUserEnabled(This,pvbEnabled)

#define IGPMGPO_IsComputerEnabled(This,pvbEnabled)	\
    (This)->lpVtbl -> IsComputerEnabled(This,pvbEnabled)

#define IGPMGPO_GetSecurityInfo(This,ppSecurityInfo)	\
    (This)->lpVtbl -> GetSecurityInfo(This,ppSecurityInfo)

#define IGPMGPO_SetSecurityInfo(This,pSecurityInfo)	\
    (This)->lpVtbl -> SetSecurityInfo(This,pSecurityInfo)

#define IGPMGPO_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IGPMGPO_Backup(This,bstrBackupDir,bstrComment,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> Backup(This,bstrBackupDir,bstrComment,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMGPO_Import(This,lFlags,pIGPMBackup,pvarMigrationTable,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> Import(This,lFlags,pIGPMBackup,pvarMigrationTable,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMGPO_GenerateReport(This,gpmReportType,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> GenerateReport(This,gpmReportType,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMGPO_GenerateReportToFile(This,gpmReportType,bstrTargetFilePath,ppIGPMResult)	\
    (This)->lpVtbl -> GenerateReportToFile(This,gpmReportType,bstrTargetFilePath,ppIGPMResult)

#define IGPMGPO_CopyTo(This,lFlags,pIGPMDomain,pvarNewDisplayName,pvarMigrationTable,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> CopyTo(This,lFlags,pIGPMDomain,pvarNewDisplayName,pvarMigrationTable,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMGPO_SetSecurityDescriptor(This,lFlags,pSD)	\
    (This)->lpVtbl -> SetSecurityDescriptor(This,lFlags,pSD)

#define IGPMGPO_GetSecurityDescriptor(This,lFlags,ppSD)	\
    (This)->lpVtbl -> GetSecurityDescriptor(This,lFlags,ppSD)

#define IGPMGPO_IsACLConsistent(This,pvbConsistent)	\
    (This)->lpVtbl -> IsACLConsistent(This,pvbConsistent)

#define IGPMGPO_MakeACLConsistent(This)	\
    (This)->lpVtbl -> MakeACLConsistent(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_DisplayName_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMGPO_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMGPO_put_DisplayName_Proxy( 
    IGPMGPO * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IGPMGPO_put_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_Path_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMGPO_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_ID_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMGPO_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_DomainName_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMGPO_get_DomainName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_CreationTime_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ DATE *pDate);


void __RPC_STUB IGPMGPO_get_CreationTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_ModificationTime_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ DATE *pDate);


void __RPC_STUB IGPMGPO_get_ModificationTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_UserDSVersionNumber_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMGPO_get_UserDSVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_ComputerDSVersionNumber_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMGPO_get_ComputerDSVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_UserSysvolVersionNumber_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMGPO_get_UserSysvolVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_ComputerSysvolVersionNumber_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMGPO_get_ComputerSysvolVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_GetWMIFilter_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ IGPMWMIFilter **ppIGPMWMIFilter);


void __RPC_STUB IGPMGPO_GetWMIFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_SetWMIFilter_Proxy( 
    IGPMGPO * This,
    /* [in] */ IGPMWMIFilter *pIGPMWMIFilter);


void __RPC_STUB IGPMGPO_SetWMIFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_SetUserEnabled_Proxy( 
    IGPMGPO * This,
    /* [in] */ VARIANT_BOOL vbEnabled);


void __RPC_STUB IGPMGPO_SetUserEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_SetComputerEnabled_Proxy( 
    IGPMGPO * This,
    /* [in] */ VARIANT_BOOL vbEnabled);


void __RPC_STUB IGPMGPO_SetComputerEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_IsUserEnabled_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ VARIANT_BOOL *pvbEnabled);


void __RPC_STUB IGPMGPO_IsUserEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_IsComputerEnabled_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ VARIANT_BOOL *pvbEnabled);


void __RPC_STUB IGPMGPO_IsComputerEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_GetSecurityInfo_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo);


void __RPC_STUB IGPMGPO_GetSecurityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_SetSecurityInfo_Proxy( 
    IGPMGPO * This,
    /* [in] */ IGPMSecurityInfo *pSecurityInfo);


void __RPC_STUB IGPMGPO_SetSecurityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_Delete_Proxy( 
    IGPMGPO * This);


void __RPC_STUB IGPMGPO_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_Backup_Proxy( 
    IGPMGPO * This,
    /* [in] */ BSTR bstrBackupDir,
    /* [in] */ BSTR bstrComment,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMGPO_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_Import_Proxy( 
    IGPMGPO * This,
    /* [in] */ long lFlags,
    /* [in] */ IGPMBackup *pIGPMBackup,
    /* [optional][in] */ VARIANT *pvarMigrationTable,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMGPO_Import_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_GenerateReport_Proxy( 
    IGPMGPO * This,
    /* [in] */ GPMReportType gpmReportType,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMGPO_GenerateReport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_GenerateReportToFile_Proxy( 
    IGPMGPO * This,
    /* [in] */ GPMReportType gpmReportType,
    /* [in] */ BSTR bstrTargetFilePath,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMGPO_GenerateReportToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_CopyTo_Proxy( 
    IGPMGPO * This,
    /* [in] */ long lFlags,
    /* [in] */ IGPMDomain *pIGPMDomain,
    /* [optional][in] */ VARIANT *pvarNewDisplayName,
    /* [optional][in] */ VARIANT *pvarMigrationTable,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMGPO_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_SetSecurityDescriptor_Proxy( 
    IGPMGPO * This,
    /* [in] */ long lFlags,
    /* [in] */ IDispatch *pSD);


void __RPC_STUB IGPMGPO_SetSecurityDescriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_GetSecurityDescriptor_Proxy( 
    IGPMGPO * This,
    /* [in] */ long lFlags,
    /* [retval][out] */ IDispatch **ppSD);


void __RPC_STUB IGPMGPO_GetSecurityDescriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_IsACLConsistent_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ VARIANT_BOOL *pvbConsistent);


void __RPC_STUB IGPMGPO_IsACLConsistent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_MakeACLConsistent_Proxy( 
    IGPMGPO * This);


void __RPC_STUB IGPMGPO_MakeACLConsistent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMGPO_INTERFACE_DEFINED__ */


#ifndef __IGPMGPOCollection_INTERFACE_DEFINED__
#define __IGPMGPOCollection_INTERFACE_DEFINED__

/* interface IGPMGPOCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMGPOCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0F0D5CF-70CA-4C39-9E29-B642F8726C01")
    IGPMGPOCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppIGPMGPOs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMGPOCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMGPOCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMGPOCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMGPOCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMGPOCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMGPOCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMGPOCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMGPOCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMGPOCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMGPOCollection * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMGPOCollection * This,
            /* [retval][out] */ IEnumVARIANT **ppIGPMGPOs);
        
        END_INTERFACE
    } IGPMGPOCollectionVtbl;

    interface IGPMGPOCollection
    {
        CONST_VTBL struct IGPMGPOCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMGPOCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMGPOCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMGPOCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMGPOCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMGPOCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMGPOCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMGPOCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMGPOCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMGPOCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMGPOCollection_get__NewEnum(This,ppIGPMGPOs)	\
    (This)->lpVtbl -> get__NewEnum(This,ppIGPMGPOs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOCollection_get_Count_Proxy( 
    IGPMGPOCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMGPOCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOCollection_get_Item_Proxy( 
    IGPMGPOCollection * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMGPOCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOCollection_get__NewEnum_Proxy( 
    IGPMGPOCollection * This,
    /* [retval][out] */ IEnumVARIANT **ppIGPMGPOs);


void __RPC_STUB IGPMGPOCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMGPOCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMGPOLink_INTERFACE_DEFINED__
#define __IGPMGPOLink_INTERFACE_DEFINED__

/* interface IGPMGPOLink */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMGPOLink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("434B99BD-5DE7-478A-809C-C251721DF70C")
    IGPMGPOLink : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPOID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPODomain( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enforced( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Enforced( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SOMLinkOrder( 
            /* [retval][out] */ long *lVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SOM( 
            /* [retval][out] */ IGPMSOM **ppIGPMSOM) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMGPOLinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMGPOLink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMGPOLink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMGPOLink * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMGPOLink * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMGPOLink * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMGPOLink * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMGPOLink * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPOID )( 
            IGPMGPOLink * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPODomain )( 
            IGPMGPOLink * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IGPMGPOLink * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IGPMGPOLink * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enforced )( 
            IGPMGPOLink * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enforced )( 
            IGPMGPOLink * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SOMLinkOrder )( 
            IGPMGPOLink * This,
            /* [retval][out] */ long *lVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SOM )( 
            IGPMGPOLink * This,
            /* [retval][out] */ IGPMSOM **ppIGPMSOM);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IGPMGPOLink * This);
        
        END_INTERFACE
    } IGPMGPOLinkVtbl;

    interface IGPMGPOLink
    {
        CONST_VTBL struct IGPMGPOLinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMGPOLink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMGPOLink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMGPOLink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMGPOLink_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMGPOLink_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMGPOLink_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMGPOLink_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMGPOLink_get_GPOID(This,pVal)	\
    (This)->lpVtbl -> get_GPOID(This,pVal)

#define IGPMGPOLink_get_GPODomain(This,pVal)	\
    (This)->lpVtbl -> get_GPODomain(This,pVal)

#define IGPMGPOLink_get_Enabled(This,pVal)	\
    (This)->lpVtbl -> get_Enabled(This,pVal)

#define IGPMGPOLink_put_Enabled(This,newVal)	\
    (This)->lpVtbl -> put_Enabled(This,newVal)

#define IGPMGPOLink_get_Enforced(This,pVal)	\
    (This)->lpVtbl -> get_Enforced(This,pVal)

#define IGPMGPOLink_put_Enforced(This,newVal)	\
    (This)->lpVtbl -> put_Enforced(This,newVal)

#define IGPMGPOLink_get_SOMLinkOrder(This,lVal)	\
    (This)->lpVtbl -> get_SOMLinkOrder(This,lVal)

#define IGPMGPOLink_get_SOM(This,ppIGPMSOM)	\
    (This)->lpVtbl -> get_SOM(This,ppIGPMSOM)

#define IGPMGPOLink_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_get_GPOID_Proxy( 
    IGPMGPOLink * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMGPOLink_get_GPOID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_get_GPODomain_Proxy( 
    IGPMGPOLink * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMGPOLink_get_GPODomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_get_Enabled_Proxy( 
    IGPMGPOLink * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IGPMGPOLink_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_put_Enabled_Proxy( 
    IGPMGPOLink * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IGPMGPOLink_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_get_Enforced_Proxy( 
    IGPMGPOLink * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IGPMGPOLink_get_Enforced_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_put_Enforced_Proxy( 
    IGPMGPOLink * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IGPMGPOLink_put_Enforced_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_get_SOMLinkOrder_Proxy( 
    IGPMGPOLink * This,
    /* [retval][out] */ long *lVal);


void __RPC_STUB IGPMGPOLink_get_SOMLinkOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_get_SOM_Proxy( 
    IGPMGPOLink * This,
    /* [retval][out] */ IGPMSOM **ppIGPMSOM);


void __RPC_STUB IGPMGPOLink_get_SOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_Delete_Proxy( 
    IGPMGPOLink * This);


void __RPC_STUB IGPMGPOLink_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMGPOLink_INTERFACE_DEFINED__ */


#ifndef __IGPMGPOLinksCollection_INTERFACE_DEFINED__
#define __IGPMGPOLinksCollection_INTERFACE_DEFINED__

/* interface IGPMGPOLinksCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMGPOLinksCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("189D7B68-16BD-4D0D-A2EC-2E6AA2288C7F")
    IGPMGPOLinksCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppIGPMLinks) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMGPOLinksCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMGPOLinksCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMGPOLinksCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMGPOLinksCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMGPOLinksCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMGPOLinksCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMGPOLinksCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMGPOLinksCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMGPOLinksCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMGPOLinksCollection * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMGPOLinksCollection * This,
            /* [retval][out] */ IEnumVARIANT **ppIGPMLinks);
        
        END_INTERFACE
    } IGPMGPOLinksCollectionVtbl;

    interface IGPMGPOLinksCollection
    {
        CONST_VTBL struct IGPMGPOLinksCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMGPOLinksCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMGPOLinksCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMGPOLinksCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMGPOLinksCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMGPOLinksCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMGPOLinksCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMGPOLinksCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMGPOLinksCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMGPOLinksCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMGPOLinksCollection_get__NewEnum(This,ppIGPMLinks)	\
    (This)->lpVtbl -> get__NewEnum(This,ppIGPMLinks)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLinksCollection_get_Count_Proxy( 
    IGPMGPOLinksCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMGPOLinksCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLinksCollection_get_Item_Proxy( 
    IGPMGPOLinksCollection * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMGPOLinksCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLinksCollection_get__NewEnum_Proxy( 
    IGPMGPOLinksCollection * This,
    /* [retval][out] */ IEnumVARIANT **ppIGPMLinks);


void __RPC_STUB IGPMGPOLinksCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMGPOLinksCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMCSECollection_INTERFACE_DEFINED__
#define __IGPMCSECollection_INTERFACE_DEFINED__

/* interface IGPMCSECollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMCSECollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2E52A97D-0A4A-4A6F-85DB-201622455DA0")
    IGPMCSECollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppIGPMCSEs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMCSECollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMCSECollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMCSECollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMCSECollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMCSECollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMCSECollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMCSECollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMCSECollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMCSECollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMCSECollection * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMCSECollection * This,
            /* [retval][out] */ IEnumVARIANT **ppIGPMCSEs);
        
        END_INTERFACE
    } IGPMCSECollectionVtbl;

    interface IGPMCSECollection
    {
        CONST_VTBL struct IGPMCSECollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMCSECollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMCSECollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMCSECollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMCSECollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMCSECollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMCSECollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMCSECollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMCSECollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMCSECollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMCSECollection_get__NewEnum(This,ppIGPMCSEs)	\
    (This)->lpVtbl -> get__NewEnum(This,ppIGPMCSEs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMCSECollection_get_Count_Proxy( 
    IGPMCSECollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMCSECollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMCSECollection_get_Item_Proxy( 
    IGPMCSECollection * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMCSECollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMCSECollection_get__NewEnum_Proxy( 
    IGPMCSECollection * This,
    /* [retval][out] */ IEnumVARIANT **ppIGPMCSEs);


void __RPC_STUB IGPMCSECollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMCSECollection_INTERFACE_DEFINED__ */


#ifndef __IGPMClientSideExtension_INTERFACE_DEFINED__
#define __IGPMClientSideExtension_INTERFACE_DEFINED__

/* interface IGPMClientSideExtension */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMClientSideExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69DA7488-B8DB-415E-9266-901BE4D49928")
    IGPMClientSideExtension : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsUserEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsComputerEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMClientSideExtensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMClientSideExtension * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMClientSideExtension * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMClientSideExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMClientSideExtension * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMClientSideExtension * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMClientSideExtension * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMClientSideExtension * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IGPMClientSideExtension * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            IGPMClientSideExtension * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsUserEnabled )( 
            IGPMClientSideExtension * This,
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsComputerEnabled )( 
            IGPMClientSideExtension * This,
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled);
        
        END_INTERFACE
    } IGPMClientSideExtensionVtbl;

    interface IGPMClientSideExtension
    {
        CONST_VTBL struct IGPMClientSideExtensionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMClientSideExtension_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMClientSideExtension_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMClientSideExtension_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMClientSideExtension_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMClientSideExtension_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMClientSideExtension_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMClientSideExtension_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMClientSideExtension_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IGPMClientSideExtension_get_DisplayName(This,pVal)	\
    (This)->lpVtbl -> get_DisplayName(This,pVal)

#define IGPMClientSideExtension_IsUserEnabled(This,pvbEnabled)	\
    (This)->lpVtbl -> IsUserEnabled(This,pvbEnabled)

#define IGPMClientSideExtension_IsComputerEnabled(This,pvbEnabled)	\
    (This)->lpVtbl -> IsComputerEnabled(This,pvbEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMClientSideExtension_get_ID_Proxy( 
    IGPMClientSideExtension * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMClientSideExtension_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMClientSideExtension_get_DisplayName_Proxy( 
    IGPMClientSideExtension * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMClientSideExtension_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMClientSideExtension_IsUserEnabled_Proxy( 
    IGPMClientSideExtension * This,
    /* [retval][out] */ VARIANT_BOOL *pvbEnabled);


void __RPC_STUB IGPMClientSideExtension_IsUserEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMClientSideExtension_IsComputerEnabled_Proxy( 
    IGPMClientSideExtension * This,
    /* [retval][out] */ VARIANT_BOOL *pvbEnabled);


void __RPC_STUB IGPMClientSideExtension_IsComputerEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMClientSideExtension_INTERFACE_DEFINED__ */


#ifndef __IGPMAsyncCancel_INTERFACE_DEFINED__
#define __IGPMAsyncCancel_INTERFACE_DEFINED__

/* interface IGPMAsyncCancel */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMAsyncCancel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DDC67754-BE67-4541-8166-F48166868C9C")
    IGPMAsyncCancel : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMAsyncCancelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMAsyncCancel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMAsyncCancel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMAsyncCancel * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMAsyncCancel * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMAsyncCancel * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMAsyncCancel * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMAsyncCancel * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IGPMAsyncCancel * This);
        
        END_INTERFACE
    } IGPMAsyncCancelVtbl;

    interface IGPMAsyncCancel
    {
        CONST_VTBL struct IGPMAsyncCancelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMAsyncCancel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMAsyncCancel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMAsyncCancel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMAsyncCancel_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMAsyncCancel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMAsyncCancel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMAsyncCancel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMAsyncCancel_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMAsyncCancel_Cancel_Proxy( 
    IGPMAsyncCancel * This);


void __RPC_STUB IGPMAsyncCancel_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMAsyncCancel_INTERFACE_DEFINED__ */


#ifndef __IGPMAsyncProgress_INTERFACE_DEFINED__
#define __IGPMAsyncProgress_INTERFACE_DEFINED__

/* interface IGPMAsyncProgress */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMAsyncProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6AAC29F8-5948-4324-BF70-423818942DBC")
    IGPMAsyncProgress : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Status( 
            /* [in] */ long lProgressNumerator,
            /* [in] */ long lProgressDenominator,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ VARIANT *pResult,
            /* [in] */ IGPMStatusMsgCollection *ppIGPMStatusMsgCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMAsyncProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMAsyncProgress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMAsyncProgress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMAsyncProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMAsyncProgress * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMAsyncProgress * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMAsyncProgress * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMAsyncProgress * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Status )( 
            IGPMAsyncProgress * This,
            /* [in] */ long lProgressNumerator,
            /* [in] */ long lProgressDenominator,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ VARIANT *pResult,
            /* [in] */ IGPMStatusMsgCollection *ppIGPMStatusMsgCollection);
        
        END_INTERFACE
    } IGPMAsyncProgressVtbl;

    interface IGPMAsyncProgress
    {
        CONST_VTBL struct IGPMAsyncProgressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMAsyncProgress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMAsyncProgress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMAsyncProgress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMAsyncProgress_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMAsyncProgress_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMAsyncProgress_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMAsyncProgress_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMAsyncProgress_Status(This,lProgressNumerator,lProgressDenominator,hrStatus,pResult,ppIGPMStatusMsgCollection)	\
    (This)->lpVtbl -> Status(This,lProgressNumerator,lProgressDenominator,hrStatus,pResult,ppIGPMStatusMsgCollection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMAsyncProgress_Status_Proxy( 
    IGPMAsyncProgress * This,
    /* [in] */ long lProgressNumerator,
    /* [in] */ long lProgressDenominator,
    /* [in] */ HRESULT hrStatus,
    /* [in] */ VARIANT *pResult,
    /* [in] */ IGPMStatusMsgCollection *ppIGPMStatusMsgCollection);


void __RPC_STUB IGPMAsyncProgress_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMAsyncProgress_INTERFACE_DEFINED__ */


#ifndef __IGPMStatusMsgCollection_INTERFACE_DEFINED__
#define __IGPMStatusMsgCollection_INTERFACE_DEFINED__

/* interface IGPMStatusMsgCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMStatusMsgCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B6E1AF0-1A92-40F3-A59D-F36AC1F728B7")
    IGPMStatusMsgCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMStatusMsgCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMStatusMsgCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMStatusMsgCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMStatusMsgCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMStatusMsgCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMStatusMsgCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMStatusMsgCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMStatusMsgCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMStatusMsgCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMStatusMsgCollection * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMStatusMsgCollection * This,
            /* [retval][out] */ IEnumVARIANT **pVal);
        
        END_INTERFACE
    } IGPMStatusMsgCollectionVtbl;

    interface IGPMStatusMsgCollection
    {
        CONST_VTBL struct IGPMStatusMsgCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMStatusMsgCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMStatusMsgCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMStatusMsgCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMStatusMsgCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMStatusMsgCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMStatusMsgCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMStatusMsgCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMStatusMsgCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMStatusMsgCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMStatusMsgCollection_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMsgCollection_get_Count_Proxy( 
    IGPMStatusMsgCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMStatusMsgCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMsgCollection_get_Item_Proxy( 
    IGPMStatusMsgCollection * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMStatusMsgCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMsgCollection_get__NewEnum_Proxy( 
    IGPMStatusMsgCollection * This,
    /* [retval][out] */ IEnumVARIANT **pVal);


void __RPC_STUB IGPMStatusMsgCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMStatusMsgCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMStatusMessage_INTERFACE_DEFINED__
#define __IGPMStatusMessage_INTERFACE_DEFINED__

/* interface IGPMStatusMessage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMStatusMessage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8496C22F-F3DE-4A1F-8F58-603CAAA93D7B")
    IGPMStatusMessage : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ObjectPath( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ErrorCode( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtensionName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SettingsName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OperationCode( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Message( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMStatusMessageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMStatusMessage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMStatusMessage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMStatusMessage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMStatusMessage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMStatusMessage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMStatusMessage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMStatusMessage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectPath )( 
            IGPMStatusMessage * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ErrorCode )( 
            IGPMStatusMessage * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtensionName )( 
            IGPMStatusMessage * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SettingsName )( 
            IGPMStatusMessage * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OperationCode )( 
            IGPMStatusMessage * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Message )( 
            IGPMStatusMessage * This,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IGPMStatusMessageVtbl;

    interface IGPMStatusMessage
    {
        CONST_VTBL struct IGPMStatusMessageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMStatusMessage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMStatusMessage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMStatusMessage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMStatusMessage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMStatusMessage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMStatusMessage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMStatusMessage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMStatusMessage_get_ObjectPath(This,pVal)	\
    (This)->lpVtbl -> get_ObjectPath(This,pVal)

#define IGPMStatusMessage_ErrorCode(This)	\
    (This)->lpVtbl -> ErrorCode(This)

#define IGPMStatusMessage_get_ExtensionName(This,pVal)	\
    (This)->lpVtbl -> get_ExtensionName(This,pVal)

#define IGPMStatusMessage_get_SettingsName(This,pVal)	\
    (This)->lpVtbl -> get_SettingsName(This,pVal)

#define IGPMStatusMessage_OperationCode(This)	\
    (This)->lpVtbl -> OperationCode(This)

#define IGPMStatusMessage_get_Message(This,pVal)	\
    (This)->lpVtbl -> get_Message(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMessage_get_ObjectPath_Proxy( 
    IGPMStatusMessage * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMStatusMessage_get_ObjectPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMStatusMessage_ErrorCode_Proxy( 
    IGPMStatusMessage * This);


void __RPC_STUB IGPMStatusMessage_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMessage_get_ExtensionName_Proxy( 
    IGPMStatusMessage * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMStatusMessage_get_ExtensionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMessage_get_SettingsName_Proxy( 
    IGPMStatusMessage * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMStatusMessage_get_SettingsName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMStatusMessage_OperationCode_Proxy( 
    IGPMStatusMessage * This);


void __RPC_STUB IGPMStatusMessage_OperationCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMessage_get_Message_Proxy( 
    IGPMStatusMessage * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMStatusMessage_get_Message_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMStatusMessage_INTERFACE_DEFINED__ */


#ifndef __IGPMConstants_INTERFACE_DEFINED__
#define __IGPMConstants_INTERFACE_DEFINED__

/* interface IGPMConstants */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMConstants;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50EF73E6-D35C-4C8D-BE63-7EA5D2AAC5C4")
    IGPMConstants : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermGPOApply( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermGPORead( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermGPOEdit( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermGPOEditSecurityAndDelete( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermGPOCustom( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermWMIFilterEdit( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermWMIFilterFullControl( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermWMIFilterCustom( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermSOMLink( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermSOMLogging( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermSOMPlanning( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermSOMGPOCreate( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermSOMWMICreate( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermSOMWMIFullControl( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPOPermissions( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPOEffectivePermissions( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPODisplayName( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPOWMIFilter( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPOID( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPOComputerExtensions( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPOUserExtensions( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertySOMLinks( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPODomain( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyBackupMostRecent( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchOpEquals( 
            /* [retval][out] */ GPMSearchOperation *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchOpContains( 
            /* [retval][out] */ GPMSearchOperation *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchOpNotContains( 
            /* [retval][out] */ GPMSearchOperation *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchOpNotEquals( 
            /* [retval][out] */ GPMSearchOperation *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UsePDC( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseAnyDC( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DoNotUseW2KDC( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SOMSite( 
            /* [retval][out] */ GPMSOMType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SOMDomain( 
            /* [retval][out] */ GPMSOMType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SOMOU( 
            /* [retval][out] */ GPMSOMType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SecurityFlags( 
            /* [in] */ VARIANT_BOOL vbOwner,
            /* [in] */ VARIANT_BOOL vbGroup,
            /* [in] */ VARIANT_BOOL vbDACL,
            /* [in] */ VARIANT_BOOL vbSACL,
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DoNotValidateDC( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReportHTML( 
            /* [retval][out] */ GPMReportType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReportXML( 
            /* [retval][out] */ GPMReportType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RSOPModeUnknown( 
            /* [retval][out] */ GPMRSOPMode *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RSOPModePlanning( 
            /* [retval][out] */ GPMRSOPMode *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RSOPModeLogging( 
            /* [retval][out] */ GPMRSOPMode *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryTypeUser( 
            /* [retval][out] */ GPMEntryType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryTypeComputer( 
            /* [retval][out] */ GPMEntryType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryTypeLocalGroup( 
            /* [retval][out] */ GPMEntryType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryTypeGlobalGroup( 
            /* [retval][out] */ GPMEntryType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryTypeUniversalGroup( 
            /* [retval][out] */ GPMEntryType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryTypeUNCPath( 
            /* [retval][out] */ GPMEntryType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryTypeUnknown( 
            /* [retval][out] */ GPMEntryType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DestinationOptionSameAsSource( 
            /* [retval][out] */ GPMDestinationOption *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DestinationOptionNone( 
            /* [retval][out] */ GPMDestinationOption *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DestinationOptionByRelativeName( 
            /* [retval][out] */ GPMDestinationOption *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DestinationOptionSet( 
            /* [retval][out] */ GPMDestinationOption *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MigrationTableOnly( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProcessSecurity( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RsopLoggingNoComputer( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RsopLoggingNoUser( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RsopPlanningAssumeSlowLink( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RsopPlanningLoopbackOption( 
            /* [in] */ VARIANT_BOOL vbMerge,
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RsopPlanningAssumeUserWQLFilterTrue( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RsopPlanningAssumeCompWQLFilterTrue( 
            /* [retval][out] */ long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMConstantsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMConstants * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMConstants * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMConstants * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMConstants * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMConstants * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMConstants * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMConstants * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermGPOApply )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermGPORead )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermGPOEdit )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermGPOEditSecurityAndDelete )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermGPOCustom )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermWMIFilterEdit )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermWMIFilterFullControl )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermWMIFilterCustom )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermSOMLink )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermSOMLogging )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermSOMPlanning )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermSOMGPOCreate )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermSOMWMICreate )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermSOMWMIFullControl )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPOPermissions )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPOEffectivePermissions )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPODisplayName )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPOWMIFilter )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPOID )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPOComputerExtensions )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPOUserExtensions )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertySOMLinks )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPODomain )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyBackupMostRecent )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchOpEquals )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchOperation *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchOpContains )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchOperation *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchOpNotContains )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchOperation *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchOpNotEquals )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchOperation *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsePDC )( 
            IGPMConstants * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseAnyDC )( 
            IGPMConstants * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DoNotUseW2KDC )( 
            IGPMConstants * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SOMSite )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSOMType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SOMDomain )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSOMType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SOMOU )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSOMType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SecurityFlags )( 
            IGPMConstants * This,
            /* [in] */ VARIANT_BOOL vbOwner,
            /* [in] */ VARIANT_BOOL vbGroup,
            /* [in] */ VARIANT_BOOL vbDACL,
            /* [in] */ VARIANT_BOOL vbSACL,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DoNotValidateDC )( 
            IGPMConstants * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReportHTML )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMReportType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReportXML )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMReportType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RSOPModeUnknown )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMRSOPMode *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RSOPModePlanning )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMRSOPMode *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RSOPModeLogging )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMRSOPMode *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EntryTypeUser )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMEntryType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EntryTypeComputer )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMEntryType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EntryTypeLocalGroup )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMEntryType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EntryTypeGlobalGroup )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMEntryType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EntryTypeUniversalGroup )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMEntryType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EntryTypeUNCPath )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMEntryType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EntryTypeUnknown )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMEntryType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationOptionSameAsSource )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMDestinationOption *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationOptionNone )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMDestinationOption *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationOptionByRelativeName )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMDestinationOption *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationOptionSet )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMDestinationOption *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MigrationTableOnly )( 
            IGPMConstants * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProcessSecurity )( 
            IGPMConstants * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RsopLoggingNoComputer )( 
            IGPMConstants * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RsopLoggingNoUser )( 
            IGPMConstants * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RsopPlanningAssumeSlowLink )( 
            IGPMConstants * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RsopPlanningLoopbackOption )( 
            IGPMConstants * This,
            /* [in] */ VARIANT_BOOL vbMerge,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RsopPlanningAssumeUserWQLFilterTrue )( 
            IGPMConstants * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RsopPlanningAssumeCompWQLFilterTrue )( 
            IGPMConstants * This,
            /* [retval][out] */ long *pVal);
        
        END_INTERFACE
    } IGPMConstantsVtbl;

    interface IGPMConstants
    {
        CONST_VTBL struct IGPMConstantsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMConstants_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMConstants_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMConstants_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMConstants_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMConstants_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMConstants_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMConstants_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMConstants_get_PermGPOApply(This,pVal)	\
    (This)->lpVtbl -> get_PermGPOApply(This,pVal)

#define IGPMConstants_get_PermGPORead(This,pVal)	\
    (This)->lpVtbl -> get_PermGPORead(This,pVal)

#define IGPMConstants_get_PermGPOEdit(This,pVal)	\
    (This)->lpVtbl -> get_PermGPOEdit(This,pVal)

#define IGPMConstants_get_PermGPOEditSecurityAndDelete(This,pVal)	\
    (This)->lpVtbl -> get_PermGPOEditSecurityAndDelete(This,pVal)

#define IGPMConstants_get_PermGPOCustom(This,pVal)	\
    (This)->lpVtbl -> get_PermGPOCustom(This,pVal)

#define IGPMConstants_get_PermWMIFilterEdit(This,pVal)	\
    (This)->lpVtbl -> get_PermWMIFilterEdit(This,pVal)

#define IGPMConstants_get_PermWMIFilterFullControl(This,pVal)	\
    (This)->lpVtbl -> get_PermWMIFilterFullControl(This,pVal)

#define IGPMConstants_get_PermWMIFilterCustom(This,pVal)	\
    (This)->lpVtbl -> get_PermWMIFilterCustom(This,pVal)

#define IGPMConstants_get_PermSOMLink(This,pVal)	\
    (This)->lpVtbl -> get_PermSOMLink(This,pVal)

#define IGPMConstants_get_PermSOMLogging(This,pVal)	\
    (This)->lpVtbl -> get_PermSOMLogging(This,pVal)

#define IGPMConstants_get_PermSOMPlanning(This,pVal)	\
    (This)->lpVtbl -> get_PermSOMPlanning(This,pVal)

#define IGPMConstants_get_PermSOMGPOCreate(This,pVal)	\
    (This)->lpVtbl -> get_PermSOMGPOCreate(This,pVal)

#define IGPMConstants_get_PermSOMWMICreate(This,pVal)	\
    (This)->lpVtbl -> get_PermSOMWMICreate(This,pVal)

#define IGPMConstants_get_PermSOMWMIFullControl(This,pVal)	\
    (This)->lpVtbl -> get_PermSOMWMIFullControl(This,pVal)

#define IGPMConstants_get_SearchPropertyGPOPermissions(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPOPermissions(This,pVal)

#define IGPMConstants_get_SearchPropertyGPOEffectivePermissions(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPOEffectivePermissions(This,pVal)

#define IGPMConstants_get_SearchPropertyGPODisplayName(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPODisplayName(This,pVal)

#define IGPMConstants_get_SearchPropertyGPOWMIFilter(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPOWMIFilter(This,pVal)

#define IGPMConstants_get_SearchPropertyGPOID(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPOID(This,pVal)

#define IGPMConstants_get_SearchPropertyGPOComputerExtensions(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPOComputerExtensions(This,pVal)

#define IGPMConstants_get_SearchPropertyGPOUserExtensions(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPOUserExtensions(This,pVal)

#define IGPMConstants_get_SearchPropertySOMLinks(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertySOMLinks(This,pVal)

#define IGPMConstants_get_SearchPropertyGPODomain(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPODomain(This,pVal)

#define IGPMConstants_get_SearchPropertyBackupMostRecent(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyBackupMostRecent(This,pVal)

#define IGPMConstants_get_SearchOpEquals(This,pVal)	\
    (This)->lpVtbl -> get_SearchOpEquals(This,pVal)

#define IGPMConstants_get_SearchOpContains(This,pVal)	\
    (This)->lpVtbl -> get_SearchOpContains(This,pVal)

#define IGPMConstants_get_SearchOpNotContains(This,pVal)	\
    (This)->lpVtbl -> get_SearchOpNotContains(This,pVal)

#define IGPMConstants_get_SearchOpNotEquals(This,pVal)	\
    (This)->lpVtbl -> get_SearchOpNotEquals(This,pVal)

#define IGPMConstants_get_UsePDC(This,pVal)	\
    (This)->lpVtbl -> get_UsePDC(This,pVal)

#define IGPMConstants_get_UseAnyDC(This,pVal)	\
    (This)->lpVtbl -> get_UseAnyDC(This,pVal)

#define IGPMConstants_get_DoNotUseW2KDC(This,pVal)	\
    (This)->lpVtbl -> get_DoNotUseW2KDC(This,pVal)

#define IGPMConstants_get_SOMSite(This,pVal)	\
    (This)->lpVtbl -> get_SOMSite(This,pVal)

#define IGPMConstants_get_SOMDomain(This,pVal)	\
    (This)->lpVtbl -> get_SOMDomain(This,pVal)

#define IGPMConstants_get_SOMOU(This,pVal)	\
    (This)->lpVtbl -> get_SOMOU(This,pVal)

#define IGPMConstants_get_SecurityFlags(This,vbOwner,vbGroup,vbDACL,vbSACL,pVal)	\
    (This)->lpVtbl -> get_SecurityFlags(This,vbOwner,vbGroup,vbDACL,vbSACL,pVal)

#define IGPMConstants_get_DoNotValidateDC(This,pVal)	\
    (This)->lpVtbl -> get_DoNotValidateDC(This,pVal)

#define IGPMConstants_get_ReportHTML(This,pVal)	\
    (This)->lpVtbl -> get_ReportHTML(This,pVal)

#define IGPMConstants_get_ReportXML(This,pVal)	\
    (This)->lpVtbl -> get_ReportXML(This,pVal)

#define IGPMConstants_get_RSOPModeUnknown(This,pVal)	\
    (This)->lpVtbl -> get_RSOPModeUnknown(This,pVal)

#define IGPMConstants_get_RSOPModePlanning(This,pVal)	\
    (This)->lpVtbl -> get_RSOPModePlanning(This,pVal)

#define IGPMConstants_get_RSOPModeLogging(This,pVal)	\
    (This)->lpVtbl -> get_RSOPModeLogging(This,pVal)

#define IGPMConstants_get_EntryTypeUser(This,pVal)	\
    (This)->lpVtbl -> get_EntryTypeUser(This,pVal)

#define IGPMConstants_get_EntryTypeComputer(This,pVal)	\
    (This)->lpVtbl -> get_EntryTypeComputer(This,pVal)

#define IGPMConstants_get_EntryTypeLocalGroup(This,pVal)	\
    (This)->lpVtbl -> get_EntryTypeLocalGroup(This,pVal)

#define IGPMConstants_get_EntryTypeGlobalGroup(This,pVal)	\
    (This)->lpVtbl -> get_EntryTypeGlobalGroup(This,pVal)

#define IGPMConstants_get_EntryTypeUniversalGroup(This,pVal)	\
    (This)->lpVtbl -> get_EntryTypeUniversalGroup(This,pVal)

#define IGPMConstants_get_EntryTypeUNCPath(This,pVal)	\
    (This)->lpVtbl -> get_EntryTypeUNCPath(This,pVal)

#define IGPMConstants_get_EntryTypeUnknown(This,pVal)	\
    (This)->lpVtbl -> get_EntryTypeUnknown(This,pVal)

#define IGPMConstants_get_DestinationOptionSameAsSource(This,pVal)	\
    (This)->lpVtbl -> get_DestinationOptionSameAsSource(This,pVal)

#define IGPMConstants_get_DestinationOptionNone(This,pVal)	\
    (This)->lpVtbl -> get_DestinationOptionNone(This,pVal)

#define IGPMConstants_get_DestinationOptionByRelativeName(This,pVal)	\
    (This)->lpVtbl -> get_DestinationOptionByRelativeName(This,pVal)

#define IGPMConstants_get_DestinationOptionSet(This,pVal)	\
    (This)->lpVtbl -> get_DestinationOptionSet(This,pVal)

#define IGPMConstants_get_MigrationTableOnly(This,pVal)	\
    (This)->lpVtbl -> get_MigrationTableOnly(This,pVal)

#define IGPMConstants_get_ProcessSecurity(This,pVal)	\
    (This)->lpVtbl -> get_ProcessSecurity(This,pVal)

#define IGPMConstants_get_RsopLoggingNoComputer(This,pVal)	\
    (This)->lpVtbl -> get_RsopLoggingNoComputer(This,pVal)

#define IGPMConstants_get_RsopLoggingNoUser(This,pVal)	\
    (This)->lpVtbl -> get_RsopLoggingNoUser(This,pVal)

#define IGPMConstants_get_RsopPlanningAssumeSlowLink(This,pVal)	\
    (This)->lpVtbl -> get_RsopPlanningAssumeSlowLink(This,pVal)

#define IGPMConstants_get_RsopPlanningLoopbackOption(This,vbMerge,pVal)	\
    (This)->lpVtbl -> get_RsopPlanningLoopbackOption(This,vbMerge,pVal)

#define IGPMConstants_get_RsopPlanningAssumeUserWQLFilterTrue(This,pVal)	\
    (This)->lpVtbl -> get_RsopPlanningAssumeUserWQLFilterTrue(This,pVal)

#define IGPMConstants_get_RsopPlanningAssumeCompWQLFilterTrue(This,pVal)	\
    (This)->lpVtbl -> get_RsopPlanningAssumeCompWQLFilterTrue(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermGPOApply_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermGPOApply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermGPORead_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermGPORead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermGPOEdit_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermGPOEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermGPOEditSecurityAndDelete_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermGPOEditSecurityAndDelete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermGPOCustom_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermGPOCustom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermWMIFilterEdit_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermWMIFilterEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermWMIFilterFullControl_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermWMIFilterFullControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermWMIFilterCustom_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermWMIFilterCustom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermSOMLink_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermSOMLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermSOMLogging_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermSOMLogging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermSOMPlanning_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermSOMPlanning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermSOMGPOCreate_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermSOMGPOCreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermSOMWMICreate_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermSOMWMICreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermSOMWMIFullControl_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermSOMWMIFullControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPOPermissions_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPOPermissions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPOEffectivePermissions_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPOEffectivePermissions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPODisplayName_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPODisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPOWMIFilter_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPOWMIFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPOID_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPOID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPOComputerExtensions_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPOComputerExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPOUserExtensions_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPOUserExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertySOMLinks_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertySOMLinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPODomain_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPODomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyBackupMostRecent_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyBackupMostRecent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchOpEquals_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchOperation *pVal);


void __RPC_STUB IGPMConstants_get_SearchOpEquals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchOpContains_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchOperation *pVal);


void __RPC_STUB IGPMConstants_get_SearchOpContains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchOpNotContains_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchOperation *pVal);


void __RPC_STUB IGPMConstants_get_SearchOpNotContains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchOpNotEquals_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchOperation *pVal);


void __RPC_STUB IGPMConstants_get_SearchOpNotEquals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_UsePDC_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_UsePDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_UseAnyDC_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_UseAnyDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_DoNotUseW2KDC_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_DoNotUseW2KDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SOMSite_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSOMType *pVal);


void __RPC_STUB IGPMConstants_get_SOMSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SOMDomain_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSOMType *pVal);


void __RPC_STUB IGPMConstants_get_SOMDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SOMOU_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSOMType *pVal);


void __RPC_STUB IGPMConstants_get_SOMOU_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SecurityFlags_Proxy( 
    IGPMConstants * This,
    /* [in] */ VARIANT_BOOL vbOwner,
    /* [in] */ VARIANT_BOOL vbGroup,
    /* [in] */ VARIANT_BOOL vbDACL,
    /* [in] */ VARIANT_BOOL vbSACL,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_SecurityFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_DoNotValidateDC_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_DoNotValidateDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_ReportHTML_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMReportType *pVal);


void __RPC_STUB IGPMConstants_get_ReportHTML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_ReportXML_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMReportType *pVal);


void __RPC_STUB IGPMConstants_get_ReportXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_RSOPModeUnknown_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMRSOPMode *pVal);


void __RPC_STUB IGPMConstants_get_RSOPModeUnknown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_RSOPModePlanning_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMRSOPMode *pVal);


void __RPC_STUB IGPMConstants_get_RSOPModePlanning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_RSOPModeLogging_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMRSOPMode *pVal);


void __RPC_STUB IGPMConstants_get_RSOPModeLogging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_EntryTypeUser_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMEntryType *pVal);


void __RPC_STUB IGPMConstants_get_EntryTypeUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_EntryTypeComputer_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMEntryType *pVal);


void __RPC_STUB IGPMConstants_get_EntryTypeComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_EntryTypeLocalGroup_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMEntryType *pVal);


void __RPC_STUB IGPMConstants_get_EntryTypeLocalGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_EntryTypeGlobalGroup_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMEntryType *pVal);


void __RPC_STUB IGPMConstants_get_EntryTypeGlobalGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_EntryTypeUniversalGroup_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMEntryType *pVal);


void __RPC_STUB IGPMConstants_get_EntryTypeUniversalGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_EntryTypeUNCPath_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMEntryType *pVal);


void __RPC_STUB IGPMConstants_get_EntryTypeUNCPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_EntryTypeUnknown_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMEntryType *pVal);


void __RPC_STUB IGPMConstants_get_EntryTypeUnknown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_DestinationOptionSameAsSource_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMDestinationOption *pVal);


void __RPC_STUB IGPMConstants_get_DestinationOptionSameAsSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_DestinationOptionNone_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMDestinationOption *pVal);


void __RPC_STUB IGPMConstants_get_DestinationOptionNone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_DestinationOptionByRelativeName_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMDestinationOption *pVal);


void __RPC_STUB IGPMConstants_get_DestinationOptionByRelativeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_DestinationOptionSet_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMDestinationOption *pVal);


void __RPC_STUB IGPMConstants_get_DestinationOptionSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_MigrationTableOnly_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_MigrationTableOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_ProcessSecurity_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_ProcessSecurity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_RsopLoggingNoComputer_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_RsopLoggingNoComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_RsopLoggingNoUser_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_RsopLoggingNoUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_RsopPlanningAssumeSlowLink_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_RsopPlanningAssumeSlowLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_RsopPlanningLoopbackOption_Proxy( 
    IGPMConstants * This,
    /* [in] */ VARIANT_BOOL vbMerge,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_RsopPlanningLoopbackOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_RsopPlanningAssumeUserWQLFilterTrue_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_RsopPlanningAssumeUserWQLFilterTrue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_RsopPlanningAssumeCompWQLFilterTrue_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMConstants_get_RsopPlanningAssumeCompWQLFilterTrue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMConstants_INTERFACE_DEFINED__ */


#ifndef __IGPMResult_INTERFACE_DEFINED__
#define __IGPMResult_INTERFACE_DEFINED__

/* interface IGPMResult */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86DFF7E9-F76F-42AB-9570-CEBC6BE8A52D")
    IGPMResult : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ IGPMStatusMsgCollection **ppIGPMStatusMsgCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Result( 
            /* [retval][out] */ VARIANT *pvarResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OverallStatus( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMResult * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMResult * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMResult * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMResult * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMResult * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IGPMResult * This,
            /* [retval][out] */ IGPMStatusMsgCollection **ppIGPMStatusMsgCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Result )( 
            IGPMResult * This,
            /* [retval][out] */ VARIANT *pvarResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OverallStatus )( 
            IGPMResult * This);
        
        END_INTERFACE
    } IGPMResultVtbl;

    interface IGPMResult
    {
        CONST_VTBL struct IGPMResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMResult_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMResult_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMResult_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMResult_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMResult_get_Status(This,ppIGPMStatusMsgCollection)	\
    (This)->lpVtbl -> get_Status(This,ppIGPMStatusMsgCollection)

#define IGPMResult_get_Result(This,pvarResult)	\
    (This)->lpVtbl -> get_Result(This,pvarResult)

#define IGPMResult_OverallStatus(This)	\
    (This)->lpVtbl -> OverallStatus(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMResult_get_Status_Proxy( 
    IGPMResult * This,
    /* [retval][out] */ IGPMStatusMsgCollection **ppIGPMStatusMsgCollection);


void __RPC_STUB IGPMResult_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMResult_get_Result_Proxy( 
    IGPMResult * This,
    /* [retval][out] */ VARIANT *pvarResult);


void __RPC_STUB IGPMResult_get_Result_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMResult_OverallStatus_Proxy( 
    IGPMResult * This);


void __RPC_STUB IGPMResult_OverallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMResult_INTERFACE_DEFINED__ */


#ifndef __IGPMMapEntryCollection_INTERFACE_DEFINED__
#define __IGPMMapEntryCollection_INTERFACE_DEFINED__

/* interface IGPMMapEntryCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMMapEntryCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB0BF49B-E53F-443F-B807-8BE22BFB6D42")
    IGPMMapEntryCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMMapEntryCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMMapEntryCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMMapEntryCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMMapEntryCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMMapEntryCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMMapEntryCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMMapEntryCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMMapEntryCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMMapEntryCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMMapEntryCollection * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMMapEntryCollection * This,
            /* [retval][out] */ IEnumVARIANT **pVal);
        
        END_INTERFACE
    } IGPMMapEntryCollectionVtbl;

    interface IGPMMapEntryCollection
    {
        CONST_VTBL struct IGPMMapEntryCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMMapEntryCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMMapEntryCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMMapEntryCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMMapEntryCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMMapEntryCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMMapEntryCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMMapEntryCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMMapEntryCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMMapEntryCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMMapEntryCollection_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMMapEntryCollection_get_Count_Proxy( 
    IGPMMapEntryCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMMapEntryCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMMapEntryCollection_get_Item_Proxy( 
    IGPMMapEntryCollection * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMMapEntryCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMMapEntryCollection_get__NewEnum_Proxy( 
    IGPMMapEntryCollection * This,
    /* [retval][out] */ IEnumVARIANT **pVal);


void __RPC_STUB IGPMMapEntryCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMMapEntryCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMMapEntry_INTERFACE_DEFINED__
#define __IGPMMapEntry_INTERFACE_DEFINED__

/* interface IGPMMapEntry */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMMapEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E79AD06-2381-4444-BE4C-FF693E6E6F2B")
    IGPMMapEntry : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ BSTR *pbstrSource) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Destination( 
            /* [retval][out] */ BSTR *pbstrDestination) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DestinationOption( 
            /* [retval][out] */ GPMDestinationOption *pgpmDestOption) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryType( 
            /* [retval][out] */ GPMEntryType *pgpmEntryType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMMapEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMMapEntry * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMMapEntry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMMapEntry * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMMapEntry * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMMapEntry * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMMapEntry * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMMapEntry * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Source )( 
            IGPMMapEntry * This,
            /* [retval][out] */ BSTR *pbstrSource);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Destination )( 
            IGPMMapEntry * This,
            /* [retval][out] */ BSTR *pbstrDestination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationOption )( 
            IGPMMapEntry * This,
            /* [retval][out] */ GPMDestinationOption *pgpmDestOption);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EntryType )( 
            IGPMMapEntry * This,
            /* [retval][out] */ GPMEntryType *pgpmEntryType);
        
        END_INTERFACE
    } IGPMMapEntryVtbl;

    interface IGPMMapEntry
    {
        CONST_VTBL struct IGPMMapEntryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMMapEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMMapEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMMapEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMMapEntry_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMMapEntry_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMMapEntry_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMMapEntry_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMMapEntry_get_Source(This,pbstrSource)	\
    (This)->lpVtbl -> get_Source(This,pbstrSource)

#define IGPMMapEntry_get_Destination(This,pbstrDestination)	\
    (This)->lpVtbl -> get_Destination(This,pbstrDestination)

#define IGPMMapEntry_get_DestinationOption(This,pgpmDestOption)	\
    (This)->lpVtbl -> get_DestinationOption(This,pgpmDestOption)

#define IGPMMapEntry_get_EntryType(This,pgpmEntryType)	\
    (This)->lpVtbl -> get_EntryType(This,pgpmEntryType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMMapEntry_get_Source_Proxy( 
    IGPMMapEntry * This,
    /* [retval][out] */ BSTR *pbstrSource);


void __RPC_STUB IGPMMapEntry_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMMapEntry_get_Destination_Proxy( 
    IGPMMapEntry * This,
    /* [retval][out] */ BSTR *pbstrDestination);


void __RPC_STUB IGPMMapEntry_get_Destination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMMapEntry_get_DestinationOption_Proxy( 
    IGPMMapEntry * This,
    /* [retval][out] */ GPMDestinationOption *pgpmDestOption);


void __RPC_STUB IGPMMapEntry_get_DestinationOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMMapEntry_get_EntryType_Proxy( 
    IGPMMapEntry * This,
    /* [retval][out] */ GPMEntryType *pgpmEntryType);


void __RPC_STUB IGPMMapEntry_get_EntryType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMMapEntry_INTERFACE_DEFINED__ */


#ifndef __IGPMMigrationTable_INTERFACE_DEFINED__
#define __IGPMMigrationTable_INTERFACE_DEFINED__

/* interface IGPMMigrationTable */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMMigrationTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48F823B1-EFAF-470B-B6ED-40D14EE1A4EC")
    IGPMMigrationTable : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ BSTR bstrMigrationTablePath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ long lFlags,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddEntry( 
            /* [in] */ BSTR bstrSource,
            /* [in] */ GPMEntryType gpmEntryType,
            /* [optional][in] */ VARIANT *pvarDestination,
            /* [retval][out] */ IGPMMapEntry **ppEntry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEntry( 
            /* [in] */ BSTR bstrSource,
            /* [retval][out] */ IGPMMapEntry **ppEntry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteEntry( 
            /* [in] */ BSTR bstrSource) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateDestination( 
            /* [in] */ BSTR bstrSource,
            /* [optional][in] */ VARIANT *pvarDestination,
            /* [retval][out] */ IGPMMapEntry **ppEntry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Validate( 
            /* [retval][out] */ IGPMResult **ppResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEntries( 
            /* [retval][out] */ IGPMMapEntryCollection **ppEntries) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMMigrationTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMMigrationTable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMMigrationTable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMMigrationTable * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMMigrationTable * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMMigrationTable * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMMigrationTable * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMMigrationTable * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IGPMMigrationTable * This,
            /* [in] */ BSTR bstrMigrationTablePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IGPMMigrationTable * This,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT var);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddEntry )( 
            IGPMMigrationTable * This,
            /* [in] */ BSTR bstrSource,
            /* [in] */ GPMEntryType gpmEntryType,
            /* [optional][in] */ VARIANT *pvarDestination,
            /* [retval][out] */ IGPMMapEntry **ppEntry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEntry )( 
            IGPMMigrationTable * This,
            /* [in] */ BSTR bstrSource,
            /* [retval][out] */ IGPMMapEntry **ppEntry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteEntry )( 
            IGPMMigrationTable * This,
            /* [in] */ BSTR bstrSource);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UpdateDestination )( 
            IGPMMigrationTable * This,
            /* [in] */ BSTR bstrSource,
            /* [optional][in] */ VARIANT *pvarDestination,
            /* [retval][out] */ IGPMMapEntry **ppEntry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Validate )( 
            IGPMMigrationTable * This,
            /* [retval][out] */ IGPMResult **ppResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEntries )( 
            IGPMMigrationTable * This,
            /* [retval][out] */ IGPMMapEntryCollection **ppEntries);
        
        END_INTERFACE
    } IGPMMigrationTableVtbl;

    interface IGPMMigrationTable
    {
        CONST_VTBL struct IGPMMigrationTableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMMigrationTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMMigrationTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMMigrationTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMMigrationTable_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMMigrationTable_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMMigrationTable_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMMigrationTable_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMMigrationTable_Save(This,bstrMigrationTablePath)	\
    (This)->lpVtbl -> Save(This,bstrMigrationTablePath)

#define IGPMMigrationTable_Add(This,lFlags,var)	\
    (This)->lpVtbl -> Add(This,lFlags,var)

#define IGPMMigrationTable_AddEntry(This,bstrSource,gpmEntryType,pvarDestination,ppEntry)	\
    (This)->lpVtbl -> AddEntry(This,bstrSource,gpmEntryType,pvarDestination,ppEntry)

#define IGPMMigrationTable_GetEntry(This,bstrSource,ppEntry)	\
    (This)->lpVtbl -> GetEntry(This,bstrSource,ppEntry)

#define IGPMMigrationTable_DeleteEntry(This,bstrSource)	\
    (This)->lpVtbl -> DeleteEntry(This,bstrSource)

#define IGPMMigrationTable_UpdateDestination(This,bstrSource,pvarDestination,ppEntry)	\
    (This)->lpVtbl -> UpdateDestination(This,bstrSource,pvarDestination,ppEntry)

#define IGPMMigrationTable_Validate(This,ppResult)	\
    (This)->lpVtbl -> Validate(This,ppResult)

#define IGPMMigrationTable_GetEntries(This,ppEntries)	\
    (This)->lpVtbl -> GetEntries(This,ppEntries)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMMigrationTable_Save_Proxy( 
    IGPMMigrationTable * This,
    /* [in] */ BSTR bstrMigrationTablePath);


void __RPC_STUB IGPMMigrationTable_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMMigrationTable_Add_Proxy( 
    IGPMMigrationTable * This,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT var);


void __RPC_STUB IGPMMigrationTable_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMMigrationTable_AddEntry_Proxy( 
    IGPMMigrationTable * This,
    /* [in] */ BSTR bstrSource,
    /* [in] */ GPMEntryType gpmEntryType,
    /* [optional][in] */ VARIANT *pvarDestination,
    /* [retval][out] */ IGPMMapEntry **ppEntry);


void __RPC_STUB IGPMMigrationTable_AddEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMMigrationTable_GetEntry_Proxy( 
    IGPMMigrationTable * This,
    /* [in] */ BSTR bstrSource,
    /* [retval][out] */ IGPMMapEntry **ppEntry);


void __RPC_STUB IGPMMigrationTable_GetEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMMigrationTable_DeleteEntry_Proxy( 
    IGPMMigrationTable * This,
    /* [in] */ BSTR bstrSource);


void __RPC_STUB IGPMMigrationTable_DeleteEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMMigrationTable_UpdateDestination_Proxy( 
    IGPMMigrationTable * This,
    /* [in] */ BSTR bstrSource,
    /* [optional][in] */ VARIANT *pvarDestination,
    /* [retval][out] */ IGPMMapEntry **ppEntry);


void __RPC_STUB IGPMMigrationTable_UpdateDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMMigrationTable_Validate_Proxy( 
    IGPMMigrationTable * This,
    /* [retval][out] */ IGPMResult **ppResult);


void __RPC_STUB IGPMMigrationTable_Validate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMMigrationTable_GetEntries_Proxy( 
    IGPMMigrationTable * This,
    /* [retval][out] */ IGPMMapEntryCollection **ppEntries);


void __RPC_STUB IGPMMigrationTable_GetEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMMigrationTable_INTERFACE_DEFINED__ */



#ifndef __GPMGMTLib_LIBRARY_DEFINED__
#define __GPMGMTLib_LIBRARY_DEFINED__

/* library GPMGMTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_GPMGMTLib;

EXTERN_C const CLSID CLSID_GPM;

#ifdef __cplusplus

class DECLSPEC_UUID("F5694708-88FE-4B35-BABF-E56162D5FBC8")
GPM;
#endif

EXTERN_C const CLSID CLSID_GPMDomain;

#ifdef __cplusplus

class DECLSPEC_UUID("710901BE-1050-4CB1-838A-C5CFF259E183")
GPMDomain;
#endif

EXTERN_C const CLSID CLSID_GPMSitesContainer;

#ifdef __cplusplus

class DECLSPEC_UUID("229F5C42-852C-4B30-945F-C522BE9BD386")
GPMSitesContainer;
#endif

EXTERN_C const CLSID CLSID_GPMBackupDir;

#ifdef __cplusplus

class DECLSPEC_UUID("FCE4A59D-0F21-4AFA-B859-E6D0C62CD10C")
GPMBackupDir;
#endif

EXTERN_C const CLSID CLSID_GPMSOM;

#ifdef __cplusplus

class DECLSPEC_UUID("32D93FAC-450E-44CF-829C-8B22FF6BDAE1")
GPMSOM;
#endif

EXTERN_C const CLSID CLSID_GPMSearchCriteria;

#ifdef __cplusplus

class DECLSPEC_UUID("17AACA26-5CE0-44FA-8CC0-5259E6483566")
GPMSearchCriteria;
#endif

EXTERN_C const CLSID CLSID_GPMPermission;

#ifdef __cplusplus

class DECLSPEC_UUID("5871A40A-E9C0-46EC-913E-944EF9225A94")
GPMPermission;
#endif

EXTERN_C const CLSID CLSID_GPMSecurityInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("547A5E8F-9162-4516-A4DF-9DDB9686D846")
GPMSecurityInfo;
#endif

EXTERN_C const CLSID CLSID_GPMBackup;

#ifdef __cplusplus

class DECLSPEC_UUID("ED1A54B8-5EFA-482A-93C0-8AD86F0D68C3")
GPMBackup;
#endif

EXTERN_C const CLSID CLSID_GPMBackupCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("EB8F035B-70DB-4A9F-9676-37C25994E9DC")
GPMBackupCollection;
#endif

EXTERN_C const CLSID CLSID_GPMSOMCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("24C1F147-3720-4F5B-A9C3-06B4E4F931D2")
GPMSOMCollection;
#endif

EXTERN_C const CLSID CLSID_GPMWMIFilter;

#ifdef __cplusplus

class DECLSPEC_UUID("626745D8-0DEA-4062-BF60-CFC5B1CA1286")
GPMWMIFilter;
#endif

EXTERN_C const CLSID CLSID_GPMWMIFilterCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("74DC6D28-E820-47D6-A0B8-F08D93D7FA33")
GPMWMIFilterCollection;
#endif

EXTERN_C const CLSID CLSID_GPMRSOP;

#ifdef __cplusplus

class DECLSPEC_UUID("489B0CAF-9EC2-4EB7-91F5-B6F71D43DA8C")
GPMRSOP;
#endif

EXTERN_C const CLSID CLSID_GPMGPO;

#ifdef __cplusplus

class DECLSPEC_UUID("D2CE2994-59B5-4064-B581-4D68486A16C4")
GPMGPO;
#endif

EXTERN_C const CLSID CLSID_GPMGPOCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("7A057325-832D-4DE3-A41F-C780436A4E09")
GPMGPOCollection;
#endif

EXTERN_C const CLSID CLSID_GPMGPOLink;

#ifdef __cplusplus

class DECLSPEC_UUID("C1DF9880-5303-42C6-8A3C-0488E1BF7364")
GPMGPOLink;
#endif

EXTERN_C const CLSID CLSID_GPMGPOLinksCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("F6ED581A-49A5-47E2-B771-FD8DC02B6259")
GPMGPOLinksCollection;
#endif

EXTERN_C const CLSID CLSID_GPMAsyncCancel;

#ifdef __cplusplus

class DECLSPEC_UUID("372796A9-76EC-479D-AD6C-556318ED5F9D")
GPMAsyncCancel;
#endif

EXTERN_C const CLSID CLSID_GPMStatusMsgCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("2824E4BE-4BCC-4CAC-9E60-0E3ED7F12496")
GPMStatusMsgCollection;
#endif

EXTERN_C const CLSID CLSID_GPMStatusMessage;

#ifdef __cplusplus

class DECLSPEC_UUID("4B77CC94-D255-409B-BC62-370881715A19")
GPMStatusMessage;
#endif

EXTERN_C const CLSID CLSID_GPMEnum;

#ifdef __cplusplus

class DECLSPEC_UUID("36ED64E5-7266-4545-8E14-1645EEBA2A90")
GPMEnum;
#endif

EXTERN_C const CLSID CLSID_GPMTrustee;

#ifdef __cplusplus

class DECLSPEC_UUID("C54A700D-19B6-4211-BCB0-E8E2475E471E")
GPMTrustee;
#endif

EXTERN_C const CLSID CLSID_GPMClientSideExtension;

#ifdef __cplusplus

class DECLSPEC_UUID("C1A2E70E-659C-4B1A-940B-F88B0AF9C8A4")
GPMClientSideExtension;
#endif

EXTERN_C const CLSID CLSID_GPMCSECollection;

#ifdef __cplusplus

class DECLSPEC_UUID("CF92B828-2D44-4B61-B10A-B327AFD42DA8")
GPMCSECollection;
#endif

EXTERN_C const CLSID CLSID_GPMConstants;

#ifdef __cplusplus

class DECLSPEC_UUID("3855E880-CD9E-4D0C-9EAF-1579283A1888")
GPMConstants;
#endif

EXTERN_C const CLSID CLSID_GPMResult;

#ifdef __cplusplus

class DECLSPEC_UUID("92101AC0-9287-4206-A3B2-4BDB73D225F6")
GPMResult;
#endif

EXTERN_C const CLSID CLSID_GPMMapEntryCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("0CF75D5B-A3A1-4C55-B4FE-9E149C41F66D")
GPMMapEntryCollection;
#endif

EXTERN_C const CLSID CLSID_GPMMapEntry;

#ifdef __cplusplus

class DECLSPEC_UUID("8C975253-5431-4471-B35D-0626C928258A")
GPMMapEntry;
#endif

EXTERN_C const CLSID CLSID_GPMMigrationTable;

#ifdef __cplusplus

class DECLSPEC_UUID("55AF4043-2A06-4F72-ABEF-631B44079C76")
GPMMigrationTable;
#endif

EXTERN_C const CLSID CLSID_GPOReportProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("18CBB703-4F47-4DCE-A5DD-3817DDBF8169")
GPOReportProvider;
#endif
#endif /* __GPMGMTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\HlIface.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for hliface.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __hliface_h__
#define __hliface_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_hliface_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// HLIface.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// OLE Hyperlinking Interfaces.

#ifndef __hlink_h__														
#include "hlink.h"														
#endif // __hlink_h__														


extern RPC_IF_HANDLE __MIDL_itf_hliface_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hliface_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\HLink.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for hlink.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __hlink_h__
#define __hlink_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IHlink_FWD_DEFINED__
#define __IHlink_FWD_DEFINED__
typedef interface IHlink IHlink;
#endif 	/* __IHlink_FWD_DEFINED__ */


#ifndef __IHlinkSite_FWD_DEFINED__
#define __IHlinkSite_FWD_DEFINED__
typedef interface IHlinkSite IHlinkSite;
#endif 	/* __IHlinkSite_FWD_DEFINED__ */


#ifndef __IHlinkTarget_FWD_DEFINED__
#define __IHlinkTarget_FWD_DEFINED__
typedef interface IHlinkTarget IHlinkTarget;
#endif 	/* __IHlinkTarget_FWD_DEFINED__ */


#ifndef __IHlinkFrame_FWD_DEFINED__
#define __IHlinkFrame_FWD_DEFINED__
typedef interface IHlinkFrame IHlinkFrame;
#endif 	/* __IHlinkFrame_FWD_DEFINED__ */


#ifndef __IEnumHLITEM_FWD_DEFINED__
#define __IEnumHLITEM_FWD_DEFINED__
typedef interface IEnumHLITEM IEnumHLITEM;
#endif 	/* __IEnumHLITEM_FWD_DEFINED__ */


#ifndef __IHlinkBrowseContext_FWD_DEFINED__
#define __IHlinkBrowseContext_FWD_DEFINED__
typedef interface IHlinkBrowseContext IHlinkBrowseContext;
#endif 	/* __IHlinkBrowseContext_FWD_DEFINED__ */


#ifndef __IExtensionServices_FWD_DEFINED__
#define __IExtensionServices_FWD_DEFINED__
typedef interface IExtensionServices IExtensionServices;
#endif 	/* __IExtensionServices_FWD_DEFINED__ */


/* header files for imported files */
#include "urlmon.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_hlink_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// HLInk.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// OLE Hyperlinking Interfaces.
                                                                              
#ifndef HLINK_H                                                               
#define HLINK_H                                                               
                                                                              






// ;BUGBUG We temporarily support the old 'source' names                              
#define SID_SHlinkFrame IID_IHlinkFrame
#define IID_IHlinkSource IID_IHlinkTarget                                     
#define IHlinkSource IHlinkTarget                                             
#define IHlinkSourceVtbl IHlinkTargetVtbl                                     
#define LPHLINKSOURCE LPHLINKTARGET                                           
                                                                              
/****************************************************************************/
/**** Error codes                                                        ****/
/****************************************************************************/
#ifndef _HLINK_ERRORS_DEFINED                                                 
#define _HLINK_ERRORS_DEFINED                                                 
#define HLINK_E_FIRST                    (OLE_E_LAST+1)                       
#define HLINK_S_FIRST                    (OLE_S_LAST+1)                       
#define HLINK_S_DONTHIDE                 (HLINK_S_FIRST)                      
#endif //_HLINK_ERRORS_DEFINED                                                
                                                                              
                                                                              
/****************************************************************************/
/**** Hyperlink APIs                                                     ****/
/****************************************************************************/
                                                                              
#define CFSTR_HYPERLINK         (TEXT("Hyperlink"))                         
                                                                              
                                                                              
STDAPI HlinkCreateFromMoniker(                                                
             IMoniker * pimkTrgt,                                             
             LPCWSTR pwzLocation,                                             
             LPCWSTR pwzFriendlyName,                                         
             IHlinkSite * pihlsite,                                           
             DWORD dwSiteData,                                                
             IUnknown * piunkOuter,                                           
             REFIID riid,                                                     
             void ** ppvObj);                                                 
                                                                              
STDAPI HlinkCreateFromString(                                                 
             LPCWSTR pwzTarget,                                               
             LPCWSTR pwzLocation,                                             
             LPCWSTR pwzFriendlyName,                                         
             IHlinkSite * pihlsite,                                           
             DWORD dwSiteData,                                                
             IUnknown * piunkOuter,                                           
             REFIID riid,                                                     
             void ** ppvObj);                                                 
                                                                              
STDAPI HlinkCreateFromData(                                                   
             IDataObject *piDataObj,                                          
             IHlinkSite * pihlsite,                                           
             DWORD dwSiteData,                                                
             IUnknown * piunkOuter,                                           
             REFIID riid,                                                     
             void ** ppvObj);                                                 
                                                                              
STDAPI HlinkQueryCreateFromData(IDataObject *piDataObj);                      
                                                                              
STDAPI HlinkClone(                                                            
             IHlink * pihl,                                                   
             REFIID riid,                                                     
             IHlinkSite * pihlsiteForClone,                                   
             DWORD dwSiteData,                                                
             void ** ppvObj);                                                 
                                                                              
STDAPI HlinkCreateBrowseContext(                                              
             IUnknown * piunkOuter,                                           
             REFIID riid,                                                     
             void ** ppvObj);                                                 
                                                                              
STDAPI HlinkNavigateToStringReference(                                        
             LPCWSTR pwzTarget,                                               
             LPCWSTR pwzLocation,                                             
             IHlinkSite * pihlsite,                                           
             DWORD dwSiteData,                                                
             IHlinkFrame *pihlframe,                                          
             DWORD grfHLNF,                                                   
             LPBC pibc,                                                       
             IBindStatusCallback * pibsc,                                     
             IHlinkBrowseContext *pihlbc);                                    
                                                                              
STDAPI HlinkNavigate(                                                         
             IHlink * pihl,                                                   
             IHlinkFrame * pihlframe,                                         
             DWORD grfHLNF,                                                   
             LPBC pbc,                                                        
             IBindStatusCallback * pibsc,                                     
             IHlinkBrowseContext *pihlbc);                                    
                                                                              
STDAPI HlinkOnNavigate(                                                       
             IHlinkFrame * pihlframe,                                         
             IHlinkBrowseContext * pihlbc,                                    
             DWORD grfHLNF,                                                   
             IMoniker * pimkTarget,                                           
             LPCWSTR pwzLocation,                                             
             LPCWSTR pwzFriendlyName,                                         
             ULONG * puHLID);                                                 
                                                                              
STDAPI HlinkUpdateStackItem(                                                  
             IHlinkFrame * pihlframe,                                         
             IHlinkBrowseContext * pihlbc,                                    
             ULONG uHLID,                                                     
             IMoniker * pimkTrgt,                                             
             LPCWSTR pwzLocation,                                             
             LPCWSTR pwzFriendlyName);                                        
                                                                              
STDAPI HlinkOnRenameDocument(                                                 
             DWORD dwReserved,                                                
             IHlinkBrowseContext * pihlbc,                                    
             IMoniker * pimkOld,                                              
             IMoniker * pimkNew);                                             
                                                                              
STDAPI HlinkResolveMonikerForData(                                            
             LPMONIKER pimkReference,                                         
             DWORD reserved,                                                  
             LPBC pibc,                                                       
             ULONG cFmtetc,                                                   
             FORMATETC * rgFmtetc,                                            
             IBindStatusCallback * pibsc,                                     
             LPMONIKER pimkBase);                                             
                                                                              
STDAPI HlinkResolveStringForData(                                             
             LPCWSTR pwzReference,                                            
             DWORD reserved,                                                  
             LPBC pibc,                                                       
             ULONG cFmtetc,                                                   
             FORMATETC * rgFmtetc,                                            
             IBindStatusCallback * pibsc,                                     
             LPMONIKER pimkBase);                                             
                                                                              
STDAPI HlinkParseDisplayName(                                                 
             LPBC pibc,                                                       
             LPCWSTR pwzDisplayName,                                          
             BOOL fNoForceAbs,                                                
             ULONG * pcchEaten,                                               
             IMoniker ** ppimk);                                              
                                                                              
STDAPI HlinkCreateExtensionServices(                                          
             LPCWSTR pwzAdditionalHeaders,                                    
             HWND phwnd,                                                      
             LPCWSTR pszUsername,                                             
             LPCWSTR pszPassword,                                             
             IUnknown * piunkOuter,                                           
             REFIID riid,                                                     
             void ** ppvObj);                                                 
                                                                              
STDAPI HlinkPreprocessMoniker(                                                
             LPBC pibc,                                                       
             IMoniker *pimkIn,                                                
             IMoniker **ppimkOut);                                            
                                                                              
STDAPI OleSaveToStreamEx(                                                     
             IUnknown * piunk,                                                
             IStream * pistm,                                                 
             BOOL fClearDirty);                                               
                                                                              
typedef 
enum _HLSR_NOREDEF10
    {	HLSR_HOME	= 0,
	HLSR_SEARCHPAGE	= 1,
	HLSR_HISTORYFOLDER	= 2
    } 	HLSR;

                                                                              
STDAPI HlinkSetSpecialReference(                                              
             ULONG uReference,                                                
             LPCWSTR pwzReference);                                           
                                                                              
STDAPI HlinkGetSpecialReference(                                              
             ULONG uReference,                                                
             __deref_out LPWSTR *ppwzReference);                                          
                                                                              
typedef 
enum _HLSHORTCUTF__NOREDEF10
    {	HLSHORTCUTF_DEFAULT	= 0,
	HLSHORTCUTF_DONTACTUALLYCREATE	= 0x1,
	HLSHORTCUTF_USEFILENAMEFROMFRIENDLYNAME	= 0x2,
	HLSHORTCUTF_USEUNIQUEFILENAME	= 0x4,
	HLSHORTCUTF_MAYUSEEXISTINGSHORTCUT	= 0x8
    } 	HLSHORTCUTF;

                                                                              
STDAPI HlinkCreateShortcut(                                                   
             DWORD grfHLSHORTCUTF,                                            
             IHlink *pihl,                                                    
             LPCWSTR pwzDir,                                                  
             LPCWSTR pwzFileName,                                             
             __deref_out LPWSTR *ppwzShortcutFile,                                        
             DWORD dwReserved);                                               
                                                                              
STDAPI HlinkCreateShortcutFromMoniker(                                        
             DWORD grfHLSHORTCUTF,                                            
             IMoniker *pimkTarget,                                            
             LPCWSTR pwzLocation,                                             
             LPCWSTR pwzDir,                                                  
             LPCWSTR pwzFileName,                                             
             __deref_out LPWSTR *ppwzShortcutFile,                                        
             DWORD dwReserved);                                               
                                                                              
STDAPI HlinkCreateShortcutFromString(                                         
             DWORD grfHLSHORTCUTF,                                            
             LPCWSTR pwzTarget,                                               
             LPCWSTR pwzLocation,                                             
             LPCWSTR pwzDir,                                                  
             LPCWSTR pwzFileName,                                             
             __deref_out LPWSTR *ppwzShortcutFile,                                        
             DWORD dwReserved);                                               
                                                                              
STDAPI HlinkResolveShortcut(                                                  
             LPCWSTR pwzShortcutFileName,                                     
             IHlinkSite * pihlsite,                                           
             DWORD dwSiteData,                                                
             IUnknown * piunkOuter,                                           
             REFIID riid,                                                     
             void ** ppvObj);                                                 
                                                                              
STDAPI HlinkResolveShortcutToMoniker(                                         
             LPCWSTR pwzShortcutFileName,                                     
             IMoniker **ppimkTarget,                                          
             __deref_out LPWSTR *ppwzLocation);                                           
                                                                              
STDAPI HlinkResolveShortcutToString(                                          
             LPCWSTR pwzShortcutFileName,                                     
             __deref_out LPWSTR *ppwzTarget,                                              
             __deref_out LPWSTR *ppwzLocation);                                           
                                                                              
                                                                              
 STDAPI HlinkIsShortcut(LPCWSTR pwzFileName);                                 
                                                                              
                                                                              
STDAPI HlinkGetValueFromParams(                                               
             LPCWSTR pwzParams,                                               
             LPCWSTR pwzName,                                                 
             __deref_out LPWSTR *ppwzValue);                                              
                                                                              
                                                                              
typedef 
enum _HLTRANSLATEF_NOREDEF10
    {	HLTRANSLATEF_DEFAULT	= 0,
	HLTRANSLATEF_DONTAPPLYDEFAULTPREFIX	= 0x1
    } 	HLTRANSLATEF;

                                                                              
STDAPI HlinkTranslateURL(                                                     
             LPCWSTR pwzURL,                                                  
             DWORD grfFlags,                                                  
             __deref_out LPWSTR *ppwzTranslatedURL);                                      
                                                                              
                                                                              
                                                                              
/****************************************************************************/
/**** Hyperlink interface definitions                                    ****/
/****************************************************************************/
                                                                              
#ifndef _LPHLINK_DEFINED
#define _LPHLINK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0000_v0_0_s_ifspec;

#ifndef __IHlink_INTERFACE_DEFINED__
#define __IHlink_INTERFACE_DEFINED__

/* interface IHlink */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IHlink *LPHLINK;

typedef /* [public] */ 
enum __MIDL_IHlink_0001
    {	HLNF_INTERNALJUMP	= 0x1,
	HLNF_OPENINNEWWINDOW	= 0x2,
	HLNF_NAVIGATINGBACK	= 0x4,
	HLNF_NAVIGATINGFORWARD	= 0x8,
	HLNF_NAVIGATINGTOSTACKITEM	= 0x10,
	HLNF_CREATENOHISTORY	= 0x20
    } 	HLNF;

typedef /* [public] */ 
enum __MIDL_IHlink_0002
    {	HLINKGETREF_DEFAULT	= 0,
	HLINKGETREF_ABSOLUTE	= 1,
	HLINKGETREF_RELATIVE	= 2
    } 	HLINKGETREF;

typedef /* [public] */ 
enum __MIDL_IHlink_0003
    {	HLFNAMEF_DEFAULT	= 0,
	HLFNAMEF_TRYCACHE	= 0x1,
	HLFNAMEF_TRYPRETTYTARGET	= 0x2,
	HLFNAMEF_TRYFULLTARGET	= 0x4,
	HLFNAMEF_TRYWIN95SHORTCUT	= 0x8
    } 	HLFNAMEF;

typedef /* [public] */ 
enum __MIDL_IHlink_0004
    {	HLINKMISC_RELATIVE	= 0x1
    } 	HLINKMISC;

typedef /* [public] */ 
enum __MIDL_IHlink_0005
    {	HLINKSETF_TARGET	= 0x1,
	HLINKSETF_LOCATION	= 0x2
    } 	HLINKSETF;


EXTERN_C const IID IID_IHlink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c3-baf9-11ce-8c82-00aa004ba90b")
    IHlink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHlinkSite( 
            /* [unique][in] */ __RPC__in_opt IHlinkSite *pihlSite,
            /* [in] */ DWORD dwSiteData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHlinkSite( 
            /* [out] */ __RPC__deref_out_opt IHlinkSite **ppihlSite,
            /* [out] */ __RPC__out DWORD *pdwSiteData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMonikerReference( 
            /* [in] */ DWORD grfHLSETF,
            /* [unique][in] */ __RPC__in_opt IMoniker *pimkTarget,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzLocation) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetMonikerReference( 
            /* [in] */ DWORD dwWhichRef,
            /* [out] */ IMoniker **ppimkTarget,
            /* [out] */ LPWSTR *ppwzLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStringReference( 
            /* [in] */ DWORD grfHLSETF,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzTarget,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringReference( 
            /* [in] */ DWORD dwWhichRef,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzTarget,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzFriendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFriendlyName( 
            /* [in] */ DWORD grfHLFNAMEF,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzFriendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTargetFrameName( 
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzTargetFrameName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetFrameName( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzTargetFrameName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMiscStatus( 
            /* [out] */ __RPC__out DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Navigate( 
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt LPBC pibc,
            /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pibsc,
            /* [unique][in] */ __RPC__in_opt IHlinkBrowseContext *pihlbc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAdditionalParams( 
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzAdditionalParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAdditionalParams( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzAdditionalParams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHlinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHlink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHlink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHlink * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHlinkSite )( 
            IHlink * This,
            /* [unique][in] */ __RPC__in_opt IHlinkSite *pihlSite,
            /* [in] */ DWORD dwSiteData);
        
        HRESULT ( STDMETHODCALLTYPE *GetHlinkSite )( 
            IHlink * This,
            /* [out] */ __RPC__deref_out_opt IHlinkSite **ppihlSite,
            /* [out] */ __RPC__out DWORD *pdwSiteData);
        
        HRESULT ( STDMETHODCALLTYPE *SetMonikerReference )( 
            IHlink * This,
            /* [in] */ DWORD grfHLSETF,
            /* [unique][in] */ __RPC__in_opt IMoniker *pimkTarget,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzLocation);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetMonikerReference )( 
            IHlink * This,
            /* [in] */ DWORD dwWhichRef,
            /* [out] */ IMoniker **ppimkTarget,
            /* [out] */ LPWSTR *ppwzLocation);
        
        HRESULT ( STDMETHODCALLTYPE *SetStringReference )( 
            IHlink * This,
            /* [in] */ DWORD grfHLSETF,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzTarget,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringReference )( 
            IHlink * This,
            /* [in] */ DWORD dwWhichRef,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzTarget,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzLocation);
        
        HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            IHlink * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzFriendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            IHlink * This,
            /* [in] */ DWORD grfHLFNAMEF,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzFriendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *SetTargetFrameName )( 
            IHlink * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzTargetFrameName);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetFrameName )( 
            IHlink * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzTargetFrameName);
        
        HRESULT ( STDMETHODCALLTYPE *GetMiscStatus )( 
            IHlink * This,
            /* [out] */ __RPC__out DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Navigate )( 
            IHlink * This,
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt LPBC pibc,
            /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pibsc,
            /* [unique][in] */ __RPC__in_opt IHlinkBrowseContext *pihlbc);
        
        HRESULT ( STDMETHODCALLTYPE *SetAdditionalParams )( 
            IHlink * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzAdditionalParams);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdditionalParams )( 
            IHlink * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzAdditionalParams);
        
        END_INTERFACE
    } IHlinkVtbl;

    interface IHlink
    {
        CONST_VTBL struct IHlinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHlink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHlink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHlink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHlink_SetHlinkSite(This,pihlSite,dwSiteData)	\
    ( (This)->lpVtbl -> SetHlinkSite(This,pihlSite,dwSiteData) ) 

#define IHlink_GetHlinkSite(This,ppihlSite,pdwSiteData)	\
    ( (This)->lpVtbl -> GetHlinkSite(This,ppihlSite,pdwSiteData) ) 

#define IHlink_SetMonikerReference(This,grfHLSETF,pimkTarget,pwzLocation)	\
    ( (This)->lpVtbl -> SetMonikerReference(This,grfHLSETF,pimkTarget,pwzLocation) ) 

#define IHlink_GetMonikerReference(This,dwWhichRef,ppimkTarget,ppwzLocation)	\
    ( (This)->lpVtbl -> GetMonikerReference(This,dwWhichRef,ppimkTarget,ppwzLocation) ) 

#define IHlink_SetStringReference(This,grfHLSETF,pwzTarget,pwzLocation)	\
    ( (This)->lpVtbl -> SetStringReference(This,grfHLSETF,pwzTarget,pwzLocation) ) 

#define IHlink_GetStringReference(This,dwWhichRef,ppwzTarget,ppwzLocation)	\
    ( (This)->lpVtbl -> GetStringReference(This,dwWhichRef,ppwzTarget,ppwzLocation) ) 

#define IHlink_SetFriendlyName(This,pwzFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwzFriendlyName) ) 

#define IHlink_GetFriendlyName(This,grfHLFNAMEF,ppwzFriendlyName)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,grfHLFNAMEF,ppwzFriendlyName) ) 

#define IHlink_SetTargetFrameName(This,pwzTargetFrameName)	\
    ( (This)->lpVtbl -> SetTargetFrameName(This,pwzTargetFrameName) ) 

#define IHlink_GetTargetFrameName(This,ppwzTargetFrameName)	\
    ( (This)->lpVtbl -> GetTargetFrameName(This,ppwzTargetFrameName) ) 

#define IHlink_GetMiscStatus(This,pdwStatus)	\
    ( (This)->lpVtbl -> GetMiscStatus(This,pdwStatus) ) 

#define IHlink_Navigate(This,grfHLNF,pibc,pibsc,pihlbc)	\
    ( (This)->lpVtbl -> Navigate(This,grfHLNF,pibc,pibsc,pihlbc) ) 

#define IHlink_SetAdditionalParams(This,pwzAdditionalParams)	\
    ( (This)->lpVtbl -> SetAdditionalParams(This,pwzAdditionalParams) ) 

#define IHlink_GetAdditionalParams(This,ppwzAdditionalParams)	\
    ( (This)->lpVtbl -> GetAdditionalParams(This,ppwzAdditionalParams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IHlink_RemoteGetMonikerReference_Proxy( 
    IHlink * This,
    /* [in] */ DWORD dwWhichRef,
    /* [out] */ __RPC__deref_out_opt IMoniker **ppimkTarget,
    /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzLocation);


void __RPC_STUB IHlink_RemoteGetMonikerReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHlink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hlink_0000_0001 */
/* [local] */ 

#endif
#ifndef _LPHLINKSITE_DEFINED
#define _LPHLINKSITE_DEFINED
EXTERN_C const GUID SID_SContainer;


extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0001_v0_0_s_ifspec;

#ifndef __IHlinkSite_INTERFACE_DEFINED__
#define __IHlinkSite_INTERFACE_DEFINED__

/* interface IHlinkSite */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IHlinkSite *LPHLINKSITE;

typedef /* [public] */ 
enum __MIDL_IHlinkSite_0001
    {	HLINKWHICHMK_CONTAINER	= 1,
	HLINKWHICHMK_BASE	= 2
    } 	HLINKWHICHMK;


EXTERN_C const IID IID_IHlinkSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c2-baf9-11ce-8c82-00aa004ba90b")
    IHlinkSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryService( 
            /* [in] */ DWORD dwSiteData,
            /* [in] */ __RPC__in REFGUID guidService,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppiunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMoniker( 
            /* [in] */ DWORD dwSiteData,
            /* [in] */ DWORD dwAssign,
            /* [in] */ DWORD dwWhich,
            /* [out] */ __RPC__deref_out_opt IMoniker **ppimk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadyToNavigate( 
            /* [in] */ DWORD dwSiteData,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNavigationComplete( 
            /* [in] */ DWORD dwSiteData,
            /* [in] */ DWORD dwreserved,
            /* [in] */ HRESULT hrError,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHlinkSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHlinkSite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHlinkSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHlinkSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryService )( 
            IHlinkSite * This,
            /* [in] */ DWORD dwSiteData,
            /* [in] */ __RPC__in REFGUID guidService,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppiunk);
        
        HRESULT ( STDMETHODCALLTYPE *GetMoniker )( 
            IHlinkSite * This,
            /* [in] */ DWORD dwSiteData,
            /* [in] */ DWORD dwAssign,
            /* [in] */ DWORD dwWhich,
            /* [out] */ __RPC__deref_out_opt IMoniker **ppimk);
        
        HRESULT ( STDMETHODCALLTYPE *ReadyToNavigate )( 
            IHlinkSite * This,
            /* [in] */ DWORD dwSiteData,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *OnNavigationComplete )( 
            IHlinkSite * This,
            /* [in] */ DWORD dwSiteData,
            /* [in] */ DWORD dwreserved,
            /* [in] */ HRESULT hrError,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzError);
        
        END_INTERFACE
    } IHlinkSiteVtbl;

    interface IHlinkSite
    {
        CONST_VTBL struct IHlinkSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHlinkSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHlinkSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHlinkSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHlinkSite_QueryService(This,dwSiteData,guidService,riid,ppiunk)	\
    ( (This)->lpVtbl -> QueryService(This,dwSiteData,guidService,riid,ppiunk) ) 

#define IHlinkSite_GetMoniker(This,dwSiteData,dwAssign,dwWhich,ppimk)	\
    ( (This)->lpVtbl -> GetMoniker(This,dwSiteData,dwAssign,dwWhich,ppimk) ) 

#define IHlinkSite_ReadyToNavigate(This,dwSiteData,dwReserved)	\
    ( (This)->lpVtbl -> ReadyToNavigate(This,dwSiteData,dwReserved) ) 

#define IHlinkSite_OnNavigationComplete(This,dwSiteData,dwreserved,hrError,pwzError)	\
    ( (This)->lpVtbl -> OnNavigationComplete(This,dwSiteData,dwreserved,hrError,pwzError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHlinkSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hlink_0000_0002 */
/* [local] */ 

#endif
#ifndef _LPHLINKTARGET_DEFINED
#define _LPHLINKTARGET_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0002_v0_0_s_ifspec;

#ifndef __IHlinkTarget_INTERFACE_DEFINED__
#define __IHlinkTarget_INTERFACE_DEFINED__

/* interface IHlinkTarget */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IHlinkTarget *LPHLINKTARGET;


EXTERN_C const IID IID_IHlinkTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c4-baf9-11ce-8c82-00aa004ba90b")
    IHlinkTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBrowseContext( 
            /* [unique][in] */ __RPC__in_opt IHlinkBrowseContext *pihlbc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrowseContext( 
            /* [out] */ __RPC__deref_out_opt IHlinkBrowseContext **ppihlbc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Navigate( 
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzJumpLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMoniker( 
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzLocation,
            /* [in] */ DWORD dwAssign,
            /* [out] */ __RPC__deref_out_opt IMoniker **ppimkLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFriendlyName( 
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzLocation,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzFriendlyName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHlinkTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHlinkTarget * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHlinkTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHlinkTarget * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBrowseContext )( 
            IHlinkTarget * This,
            /* [unique][in] */ __RPC__in_opt IHlinkBrowseContext *pihlbc);
        
        HRESULT ( STDMETHODCALLTYPE *GetBrowseContext )( 
            IHlinkTarget * This,
            /* [out] */ __RPC__deref_out_opt IHlinkBrowseContext **ppihlbc);
        
        HRESULT ( STDMETHODCALLTYPE *Navigate )( 
            IHlinkTarget * This,
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzJumpLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetMoniker )( 
            IHlinkTarget * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzLocation,
            /* [in] */ DWORD dwAssign,
            /* [out] */ __RPC__deref_out_opt IMoniker **ppimkLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            IHlinkTarget * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzLocation,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzFriendlyName);
        
        END_INTERFACE
    } IHlinkTargetVtbl;

    interface IHlinkTarget
    {
        CONST_VTBL struct IHlinkTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHlinkTarget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHlinkTarget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHlinkTarget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHlinkTarget_SetBrowseContext(This,pihlbc)	\
    ( (This)->lpVtbl -> SetBrowseContext(This,pihlbc) ) 

#define IHlinkTarget_GetBrowseContext(This,ppihlbc)	\
    ( (This)->lpVtbl -> GetBrowseContext(This,ppihlbc) ) 

#define IHlinkTarget_Navigate(This,grfHLNF,pwzJumpLocation)	\
    ( (This)->lpVtbl -> Navigate(This,grfHLNF,pwzJumpLocation) ) 

#define IHlinkTarget_GetMoniker(This,pwzLocation,dwAssign,ppimkLocation)	\
    ( (This)->lpVtbl -> GetMoniker(This,pwzLocation,dwAssign,ppimkLocation) ) 

#define IHlinkTarget_GetFriendlyName(This,pwzLocation,ppwzFriendlyName)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,pwzLocation,ppwzFriendlyName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHlinkTarget_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hlink_0000_0003 */
/* [local] */ 

#endif
#ifndef _LPHLINKFRAME_DEFINED
#define _LPHLINKFRAME_DEFINED
EXTERN_C const GUID SID_SHlinkFrame;


extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0003_v0_0_s_ifspec;

#ifndef __IHlinkFrame_INTERFACE_DEFINED__
#define __IHlinkFrame_INTERFACE_DEFINED__

/* interface IHlinkFrame */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IHlinkFrame *LPHLINKFRAME;


EXTERN_C const IID IID_IHlinkFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c5-baf9-11ce-8c82-00aa004ba90b")
    IHlinkFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBrowseContext( 
            /* [unique][in] */ __RPC__in_opt IHlinkBrowseContext *pihlbc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrowseContext( 
            /* [out] */ __RPC__deref_out_opt IHlinkBrowseContext **ppihlbc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Navigate( 
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt LPBC pbc,
            /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pibsc,
            /* [unique][in] */ __RPC__in_opt IHlink *pihlNavigate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNavigate( 
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt IMoniker *pimkTarget,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzLocation,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzFriendlyName,
            /* [in] */ DWORD dwreserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateHlink( 
            /* [in] */ ULONG uHLID,
            /* [unique][in] */ __RPC__in_opt IMoniker *pimkTarget,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzLocation,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzFriendlyName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHlinkFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHlinkFrame * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHlinkFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHlinkFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBrowseContext )( 
            IHlinkFrame * This,
            /* [unique][in] */ __RPC__in_opt IHlinkBrowseContext *pihlbc);
        
        HRESULT ( STDMETHODCALLTYPE *GetBrowseContext )( 
            IHlinkFrame * This,
            /* [out] */ __RPC__deref_out_opt IHlinkBrowseContext **ppihlbc);
        
        HRESULT ( STDMETHODCALLTYPE *Navigate )( 
            IHlinkFrame * This,
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt LPBC pbc,
            /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pibsc,
            /* [unique][in] */ __RPC__in_opt IHlink *pihlNavigate);
        
        HRESULT ( STDMETHODCALLTYPE *OnNavigate )( 
            IHlinkFrame * This,
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt IMoniker *pimkTarget,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzLocation,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzFriendlyName,
            /* [in] */ DWORD dwreserved);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateHlink )( 
            IHlinkFrame * This,
            /* [in] */ ULONG uHLID,
            /* [unique][in] */ __RPC__in_opt IMoniker *pimkTarget,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzLocation,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pwzFriendlyName);
        
        END_INTERFACE
    } IHlinkFrameVtbl;

    interface IHlinkFrame
    {
        CONST_VTBL struct IHlinkFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHlinkFrame_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHlinkFrame_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHlinkFrame_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHlinkFrame_SetBrowseContext(This,pihlbc)	\
    ( (This)->lpVtbl -> SetBrowseContext(This,pihlbc) ) 

#define IHlinkFrame_GetBrowseContext(This,ppihlbc)	\
    ( (This)->lpVtbl -> GetBrowseContext(This,ppihlbc) ) 

#define IHlinkFrame_Navigate(This,grfHLNF,pbc,pibsc,pihlNavigate)	\
    ( (This)->lpVtbl -> Navigate(This,grfHLNF,pbc,pibsc,pihlNavigate) ) 

#define IHlinkFrame_OnNavigate(This,grfHLNF,pimkTarget,pwzLocation,pwzFriendlyName,dwreserved)	\
    ( (This)->lpVtbl -> OnNavigate(This,grfHLNF,pimkTarget,pwzLocation,pwzFriendlyName,dwreserved) ) 

#define IHlinkFrame_UpdateHlink(This,uHLID,pimkTarget,pwzLocation,pwzFriendlyName)	\
    ( (This)->lpVtbl -> UpdateHlink(This,uHLID,pimkTarget,pwzLocation,pwzFriendlyName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHlinkFrame_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hlink_0000_0004 */
/* [local] */ 

#endif
#ifndef _LPENUMHLITEM_DEFINED
#define _LPENUMHLITEM_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0004_v0_0_s_ifspec;

#ifndef __IEnumHLITEM_INTERFACE_DEFINED__
#define __IEnumHLITEM_INTERFACE_DEFINED__

/* interface IEnumHLITEM */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IEnumHLITEM *LPENUMHLITEM;

typedef struct tagHLITEM
    {
    ULONG uHLID;
    LPWSTR pwzFriendlyName;
    } 	HLITEM;

typedef /* [unique] */ HLITEM *LPHLITEM;


EXTERN_C const IID IID_IEnumHLITEM;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c6-baf9-11ce-8c82-00aa004ba90b")
    IEnumHLITEM : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ HLITEM *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHLITEM **ppienumhlitem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHLITEMVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHLITEM * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHLITEM * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHLITEM * This);
        
        HRESULT ( __stdcall *Next )( 
            IEnumHLITEM * This,
            /* [in] */ ULONG celt,
            /* [out] */ HLITEM *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHLITEM * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHLITEM * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHLITEM * This,
            /* [out] */ IEnumHLITEM **ppienumhlitem);
        
        END_INTERFACE
    } IEnumHLITEMVtbl;

    interface IEnumHLITEM
    {
        CONST_VTBL struct IEnumHLITEMVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHLITEM_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumHLITEM_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumHLITEM_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumHLITEM_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumHLITEM_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumHLITEM_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumHLITEM_Clone(This,ppienumhlitem)	\
    ( (This)->lpVtbl -> Clone(This,ppienumhlitem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumHLITEM_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hlink_0000_0005 */
/* [local] */ 

#endif
#ifndef _LPHLINKBROWSECONTEXT_DEFINED
#define _LPHLINKBROWSECONTEXT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0005_v0_0_s_ifspec;

#ifndef __IHlinkBrowseContext_INTERFACE_DEFINED__
#define __IHlinkBrowseContext_INTERFACE_DEFINED__

/* interface IHlinkBrowseContext */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IHlinkBrowseContext *LPHLINKBROWSECONTEXT;


enum __MIDL_IHlinkBrowseContext_0001
    {	HLTB_DOCKEDLEFT	= 0,
	HLTB_DOCKEDTOP	= 1,
	HLTB_DOCKEDRIGHT	= 2,
	HLTB_DOCKEDBOTTOM	= 3,
	HLTB_FLOATING	= 4
    } ;
typedef struct _tagHLTBINFO
    {
    ULONG uDockType;
    RECT rcTbPos;
    } 	HLTBINFO;


enum __MIDL_IHlinkBrowseContext_0002
    {	HLBWIF_HASFRAMEWNDINFO	= 0x1,
	HLBWIF_HASDOCWNDINFO	= 0x2,
	HLBWIF_FRAMEWNDMAXIMIZED	= 0x4,
	HLBWIF_DOCWNDMAXIMIZED	= 0x8,
	HLBWIF_HASWEBTOOLBARINFO	= 0x10,
	HLBWIF_WEBTOOLBARHIDDEN	= 0x20
    } ;
typedef struct _tagHLBWINFO
    {
    ULONG cbSize;
    DWORD grfHLBWIF;
    RECT rcFramePos;
    RECT rcDocPos;
    HLTBINFO hltbinfo;
    } 	HLBWINFO;

typedef /* [unique] */ HLBWINFO *LPHLBWINFO;


enum __MIDL_IHlinkBrowseContext_0003
    {	HLID_INVALID	= 0,
	HLID_PREVIOUS	= 0xffffffff,
	HLID_NEXT	= 0xfffffffe,
	HLID_CURRENT	= 0xfffffffd,
	HLID_STACKBOTTOM	= 0xfffffffc,
	HLID_STACKTOP	= 0xfffffffb
    } ;

enum __MIDL_IHlinkBrowseContext_0004
    {	HLQF_ISVALID	= 0x1,
	HLQF_ISCURRENT	= 0x2
    } ;

EXTERN_C const IID IID_IHlinkBrowseContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c7-baf9-11ce-8c82-00aa004ba90b")
    IHlinkBrowseContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Register( 
            /* [in] */ DWORD reserved,
            /* [unique][in] */ IUnknown *piunk,
            /* [unique][in] */ IMoniker *pimk,
            /* [out] */ DWORD *pdwRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [unique][in] */ IMoniker *pimk,
            /* [in] */ BOOL fBindIfRootRegistered,
            /* [out] */ IUnknown **ppiunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Revoke( 
            /* [in] */ DWORD dwRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBrowseWindowInfo( 
            /* [unique][in] */ HLBWINFO *phlbwi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrowseWindowInfo( 
            /* [out] */ HLBWINFO *phlbwi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInitialHlink( 
            /* [unique][in] */ IMoniker *pimkTarget,
            /* [unique][in] */ LPCWSTR pwzLocation,
            /* [unique][in] */ LPCWSTR pwzFriendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNavigateHlink( 
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ IMoniker *pimkTarget,
            /* [unique][in] */ LPCWSTR pwzLocation,
            /* [unique][in] */ LPCWSTR pwzFriendlyName,
            /* [out] */ ULONG *puHLID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateHlink( 
            /* [in] */ ULONG uHLID,
            /* [unique][in] */ IMoniker *pimkTarget,
            /* [unique][in] */ LPCWSTR pwzLocation,
            /* [unique][in] */ LPCWSTR pwzFriendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumNavigationStack( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ DWORD grfHLFNAMEF,
            /* [out] */ IEnumHLITEM **ppienumhlitem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryHlink( 
            /* [in] */ DWORD grfHLQF,
            /* [in] */ ULONG uHLID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHlink( 
            /* [in] */ ULONG uHLID,
            /* [out] */ IHlink **ppihl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentHlink( 
            /* [in] */ ULONG uHLID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [unique][in] */ IUnknown *piunkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppiunkObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ DWORD reserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHlinkBrowseContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHlinkBrowseContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHlinkBrowseContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHlinkBrowseContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Register )( 
            IHlinkBrowseContext * This,
            /* [in] */ DWORD reserved,
            /* [unique][in] */ IUnknown *piunk,
            /* [unique][in] */ IMoniker *pimk,
            /* [out] */ DWORD *pdwRegister);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IHlinkBrowseContext * This,
            /* [unique][in] */ IMoniker *pimk,
            /* [in] */ BOOL fBindIfRootRegistered,
            /* [out] */ IUnknown **ppiunk);
        
        HRESULT ( STDMETHODCALLTYPE *Revoke )( 
            IHlinkBrowseContext * This,
            /* [in] */ DWORD dwRegister);
        
        HRESULT ( STDMETHODCALLTYPE *SetBrowseWindowInfo )( 
            IHlinkBrowseContext * This,
            /* [unique][in] */ HLBWINFO *phlbwi);
        
        HRESULT ( STDMETHODCALLTYPE *GetBrowseWindowInfo )( 
            IHlinkBrowseContext * This,
            /* [out] */ HLBWINFO *phlbwi);
        
        HRESULT ( STDMETHODCALLTYPE *SetInitialHlink )( 
            IHlinkBrowseContext * This,
            /* [unique][in] */ IMoniker *pimkTarget,
            /* [unique][in] */ LPCWSTR pwzLocation,
            /* [unique][in] */ LPCWSTR pwzFriendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *OnNavigateHlink )( 
            IHlinkBrowseContext * This,
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ IMoniker *pimkTarget,
            /* [unique][in] */ LPCWSTR pwzLocation,
            /* [unique][in] */ LPCWSTR pwzFriendlyName,
            /* [out] */ ULONG *puHLID);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateHlink )( 
            IHlinkBrowseContext * This,
            /* [in] */ ULONG uHLID,
            /* [unique][in] */ IMoniker *pimkTarget,
            /* [unique][in] */ LPCWSTR pwzLocation,
            /* [unique][in] */ LPCWSTR pwzFriendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumNavigationStack )( 
            IHlinkBrowseContext * This,
            /* [in] */ DWORD dwReserved,
            /* [in] */ DWORD grfHLFNAMEF,
            /* [out] */ IEnumHLITEM **ppienumhlitem);
        
        HRESULT ( STDMETHODCALLTYPE *QueryHlink )( 
            IHlinkBrowseContext * This,
            /* [in] */ DWORD grfHLQF,
            /* [in] */ ULONG uHLID);
        
        HRESULT ( STDMETHODCALLTYPE *GetHlink )( 
            IHlinkBrowseContext * This,
            /* [in] */ ULONG uHLID,
            /* [out] */ IHlink **ppihl);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentHlink )( 
            IHlinkBrowseContext * This,
            /* [in] */ ULONG uHLID);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IHlinkBrowseContext * This,
            /* [unique][in] */ IUnknown *piunkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppiunkObj);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IHlinkBrowseContext * This,
            /* [in] */ DWORD reserved);
        
        END_INTERFACE
    } IHlinkBrowseContextVtbl;

    interface IHlinkBrowseContext
    {
        CONST_VTBL struct IHlinkBrowseContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHlinkBrowseContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHlinkBrowseContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHlinkBrowseContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHlinkBrowseContext_Register(This,reserved,piunk,pimk,pdwRegister)	\
    ( (This)->lpVtbl -> Register(This,reserved,piunk,pimk,pdwRegister) ) 

#define IHlinkBrowseContext_GetObject(This,pimk,fBindIfRootRegistered,ppiunk)	\
    ( (This)->lpVtbl -> GetObject(This,pimk,fBindIfRootRegistered,ppiunk) ) 

#define IHlinkBrowseContext_Revoke(This,dwRegister)	\
    ( (This)->lpVtbl -> Revoke(This,dwRegister) ) 

#define IHlinkBrowseContext_SetBrowseWindowInfo(This,phlbwi)	\
    ( (This)->lpVtbl -> SetBrowseWindowInfo(This,phlbwi) ) 

#define IHlinkBrowseContext_GetBrowseWindowInfo(This,phlbwi)	\
    ( (This)->lpVtbl -> GetBrowseWindowInfo(This,phlbwi) ) 

#define IHlinkBrowseContext_SetInitialHlink(This,pimkTarget,pwzLocation,pwzFriendlyName)	\
    ( (This)->lpVtbl -> SetInitialHlink(This,pimkTarget,pwzLocation,pwzFriendlyName) ) 

#define IHlinkBrowseContext_OnNavigateHlink(This,grfHLNF,pimkTarget,pwzLocation,pwzFriendlyName,puHLID)	\
    ( (This)->lpVtbl -> OnNavigateHlink(This,grfHLNF,pimkTarget,pwzLocation,pwzFriendlyName,puHLID) ) 

#define IHlinkBrowseContext_UpdateHlink(This,uHLID,pimkTarget,pwzLocation,pwzFriendlyName)	\
    ( (This)->lpVtbl -> UpdateHlink(This,uHLID,pimkTarget,pwzLocation,pwzFriendlyName) ) 

#define IHlinkBrowseContext_EnumNavigationStack(This,dwReserved,grfHLFNAMEF,ppienumhlitem)	\
    ( (This)->lpVtbl -> EnumNavigationStack(This,dwReserved,grfHLFNAMEF,ppienumhlitem) ) 

#define IHlinkBrowseContext_QueryHlink(This,grfHLQF,uHLID)	\
    ( (This)->lpVtbl -> QueryHlink(This,grfHLQF,uHLID) ) 

#define IHlinkBrowseContext_GetHlink(This,uHLID,ppihl)	\
    ( (This)->lpVtbl -> GetHlink(This,uHLID,ppihl) ) 

#define IHlinkBrowseContext_SetCurrentHlink(This,uHLID)	\
    ( (This)->lpVtbl -> SetCurrentHlink(This,uHLID) ) 

#define IHlinkBrowseContext_Clone(This,piunkOuter,riid,ppiunkObj)	\
    ( (This)->lpVtbl -> Clone(This,piunkOuter,riid,ppiunkObj) ) 

#define IHlinkBrowseContext_Close(This,reserved)	\
    ( (This)->lpVtbl -> Close(This,reserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHlinkBrowseContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hlink_0000_0006 */
/* [local] */ 

#endif
#ifndef _LPEXTENSIONSERVICES_DEFINED
#define _LPEXTENSIONSERVICES_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0006_v0_0_s_ifspec;

#ifndef __IExtensionServices_INTERFACE_DEFINED__
#define __IExtensionServices_INTERFACE_DEFINED__

/* interface IExtensionServices */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IExtensionServices *LPEXTENSIONSERVICES;


EXTERN_C const IID IID_IExtensionServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9cb-baf9-11ce-8c82-00aa004ba90b")
    IExtensionServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAdditionalHeaders( 
            /* [in] */ LPCWSTR pwzAdditionalHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthenticateData( 
            /* [in] */ HWND phwnd,
            /* [in] */ LPCWSTR pwzUsername,
            /* [in] */ LPCWSTR pwzPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtensionServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExtensionServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExtensionServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExtensionServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAdditionalHeaders )( 
            IExtensionServices * This,
            /* [in] */ LPCWSTR pwzAdditionalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuthenticateData )( 
            IExtensionServices * This,
            /* [in] */ HWND phwnd,
            /* [in] */ LPCWSTR pwzUsername,
            /* [in] */ LPCWSTR pwzPassword);
        
        END_INTERFACE
    } IExtensionServicesVtbl;

    interface IExtensionServices
    {
        CONST_VTBL struct IExtensionServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtensionServices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExtensionServices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExtensionServices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExtensionServices_SetAdditionalHeaders(This,pwzAdditionalHeaders)	\
    ( (This)->lpVtbl -> SetAdditionalHeaders(This,pwzAdditionalHeaders) ) 

#define IExtensionServices_SetAuthenticateData(This,phwnd,pwzUsername,pwzPassword)	\
    ( (This)->lpVtbl -> SetAuthenticateData(This,phwnd,pwzUsername,pwzPassword) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExtensionServices_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hlink_0000_0007 */
/* [local] */ 

#endif
                                                                              
#endif // !HLINK_H                                                            


extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hlink_0000_0007_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IHlink_GetMonikerReference_Proxy( 
    IHlink * This,
    /* [in] */ DWORD dwWhichRef,
    /* [out] */ IMoniker **ppimkTarget,
    /* [out] */ LPWSTR *ppwzLocation);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IHlink_GetMonikerReference_Stub( 
    IHlink * This,
    /* [in] */ DWORD dwWhichRef,
    /* [out] */ __RPC__deref_out_opt IMoniker **ppimkTarget,
    /* [out] */ __RPC__deref_out_opt LPWSTR *ppwzLocation);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\hidusage.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

        HIDUSAGE.H

Abstract:

   Public Definitions of HID USAGES.

Environment:

    Kernel & user mode

--*/

#ifndef   __HIDUSAGE_H__
#define   __HIDUSAGE_H__

//
// Usage Pages
//

typedef USHORT USAGE, *PUSAGE;

#define HID_USAGE_PAGE_UNDEFINED      ((USAGE) 0x00)
#define HID_USAGE_PAGE_GENERIC        ((USAGE) 0x01)
#define HID_USAGE_PAGE_SIMULATION     ((USAGE) 0x02)
#define HID_USAGE_PAGE_VR             ((USAGE) 0x03)
#define HID_USAGE_PAGE_SPORT          ((USAGE) 0x04)
#define HID_USAGE_PAGE_GAME           ((USAGE) 0x05)
#define HID_USAGE_PAGE_KEYBOARD       ((USAGE) 0x07)
#define HID_USAGE_PAGE_LED            ((USAGE) 0x08)
#define HID_USAGE_PAGE_BUTTON         ((USAGE) 0x09)
#define HID_USAGE_PAGE_ORDINAL        ((USAGE) 0x0A)
#define HID_USAGE_PAGE_TELEPHONY      ((USAGE) 0x0B)
#define HID_USAGE_PAGE_CONSUMER       ((USAGE) 0x0C)
#define HID_USAGE_PAGE_DIGITIZER      ((USAGE) 0x0D)
#define HID_USAGE_PAGE_UNICODE        ((USAGE) 0x10)
#define HID_USAGE_PAGE_ALPHANUMERIC   ((USAGE) 0x14)


//
// Usages from Generic Desktop Page (0x01)
//

#define HID_USAGE_GENERIC_POINTER      ((USAGE) 0x01)
#define HID_USAGE_GENERIC_MOUSE        ((USAGE) 0x02)
#define HID_USAGE_GENERIC_JOYSTICK     ((USAGE) 0x04)
#define HID_USAGE_GENERIC_GAMEPAD      ((USAGE) 0x05)
#define HID_USAGE_GENERIC_KEYBOARD     ((USAGE) 0x06)
#define HID_USAGE_GENERIC_KEYPAD       ((USAGE) 0x07)
#define HID_USAGE_GENERIC_SYSTEM_CTL   ((USAGE) 0x80)

#define HID_USAGE_GENERIC_X                        ((USAGE) 0x30)
#define HID_USAGE_GENERIC_Y                        ((USAGE) 0x31)
#define HID_USAGE_GENERIC_Z                        ((USAGE) 0x32)
#define HID_USAGE_GENERIC_RX                       ((USAGE) 0x33)
#define HID_USAGE_GENERIC_RY                       ((USAGE) 0x34)
#define HID_USAGE_GENERIC_RZ                       ((USAGE) 0x35)
#define HID_USAGE_GENERIC_SLIDER                   ((USAGE) 0x36)
#define HID_USAGE_GENERIC_DIAL                     ((USAGE) 0x37)
#define HID_USAGE_GENERIC_WHEEL                    ((USAGE) 0x38)
#define HID_USAGE_GENERIC_HATSWITCH                ((USAGE) 0x39)
#define HID_USAGE_GENERIC_COUNTED_BUFFER           ((USAGE) 0x3A)
#define HID_USAGE_GENERIC_BYTE_COUNT               ((USAGE) 0x3B)
#define HID_USAGE_GENERIC_MOTION_WAKEUP            ((USAGE) 0x3C)
#define HID_USAGE_GENERIC_VX                       ((USAGE) 0x40)
#define HID_USAGE_GENERIC_VY                       ((USAGE) 0x41)
#define HID_USAGE_GENERIC_VZ                       ((USAGE) 0x42)
#define HID_USAGE_GENERIC_VBRX                     ((USAGE) 0x43)
#define HID_USAGE_GENERIC_VBRY                     ((USAGE) 0x44)
#define HID_USAGE_GENERIC_VBRZ                     ((USAGE) 0x45)
#define HID_USAGE_GENERIC_VNO                      ((USAGE) 0x46)
#define HID_USAGE_GENERIC_SYSCTL_POWER             ((USAGE) 0x81)
#define HID_USAGE_GENERIC_SYSCTL_SLEEP             ((USAGE) 0x82)
#define HID_USAGE_GENERIC_SYSCTL_WAKE              ((USAGE) 0x83)
#define HID_USAGE_GENERIC_SYSCTL_CONTEXT_MENU      ((USAGE) 0x84)
#define HID_USAGE_GENERIC_SYSCTL_MAIN_MENU         ((USAGE) 0x85)
#define HID_USAGE_GENERIC_SYSCTL_APP_MENU          ((USAGE) 0x86)
#define HID_USAGE_GENERIC_SYSCTL_HELP_MENU         ((USAGE) 0x87)
#define HID_USAGE_GENERIC_SYSCTL_MENU_EXIT         ((USAGE) 0x88)
#define HID_USAGE_GENERIC_SYSCTL_MENU_SELECT       ((USAGE) 0x89)
#define HID_USAGE_GENERIC_SYSCTL_MENU_RIGHT        ((USAGE) 0x8A)
#define HID_USAGE_GENERIC_SYSCTL_MENU_LEFT         ((USAGE) 0x8B)
#define HID_USAGE_GENERIC_SYSCTL_MENU_UP           ((USAGE) 0x8C)
#define HID_USAGE_GENERIC_SYSCTL_MENU_DOWN         ((USAGE) 0x8D)

//
// Usages from Simulation Controls Page (0x02)
//

#define HID_USAGE_SIMULATION_RUDDER                ((USAGE) 0xBA)
#define HID_USAGE_SIMULATION_THROTTLE              ((USAGE) 0xBB)

//
// Virtual Reality Controls Page (0x03)
//


//
// Sport Controls Page (0x04)
//


//
// Game Controls Page (0x05)
//


//
// Keyboard/Keypad Page (0x07)
//

        // Error "keys"
#define HID_USAGE_KEYBOARD_NOEVENT     ((USAGE) 0x00)
#define HID_USAGE_KEYBOARD_ROLLOVER    ((USAGE) 0x01)
#define HID_USAGE_KEYBOARD_POSTFAIL    ((USAGE) 0x02)
#define HID_USAGE_KEYBOARD_UNDEFINED   ((USAGE) 0x03)

        // Letters
#define HID_USAGE_KEYBOARD_aA          ((USAGE) 0x04)
#define HID_USAGE_KEYBOARD_zZ          ((USAGE) 0x1D)
        // Numbers
#define HID_USAGE_KEYBOARD_ONE         ((USAGE) 0x1E)
#define HID_USAGE_KEYBOARD_ZERO        ((USAGE) 0x27)
        // Modifier Keys
#define HID_USAGE_KEYBOARD_LCTRL       ((USAGE) 0xE0)
#define HID_USAGE_KEYBOARD_LSHFT       ((USAGE) 0xE1)
#define HID_USAGE_KEYBOARD_LALT        ((USAGE) 0xE2)
#define HID_USAGE_KEYBOARD_LGUI        ((USAGE) 0xE3)
#define HID_USAGE_KEYBOARD_RCTRL       ((USAGE) 0xE4)
#define HID_USAGE_KEYBOARD_RSHFT       ((USAGE) 0xE5)
#define HID_USAGE_KEYBOARD_RALT        ((USAGE) 0xE6)
#define HID_USAGE_KEYBOARD_RGUI        ((USAGE) 0xE7)
#define HID_USAGE_KEYBOARD_SCROLL_LOCK ((USAGE) 0x47)
#define HID_USAGE_KEYBOARD_NUM_LOCK    ((USAGE) 0x53)
#define HID_USAGE_KEYBOARD_CAPS_LOCK   ((USAGE) 0x39)
        // Funtion keys
#define HID_USAGE_KEYBOARD_F1          ((USAGE) 0x3A)
#define HID_USAGE_KEYBOARD_F12         ((USAGE) 0x45)

#define HID_USAGE_KEYBOARD_RETURN      ((USAGE) 0x28)
#define HID_USAGE_KEYBOARD_ESCAPE      ((USAGE) 0x29)
#define HID_USAGE_KEYBOARD_DELETE      ((USAGE) 0x2A)

#define HID_USAGE_KEYBOARD_PRINT_SCREEN ((USAGE) 0x46)

// and hundreds more...

//
// LED Page (0x08)
//

#define HID_USAGE_LED_NUM_LOCK               ((USAGE) 0x01)
#define HID_USAGE_LED_CAPS_LOCK              ((USAGE) 0x02)
#define HID_USAGE_LED_SCROLL_LOCK            ((USAGE) 0x03)
#define HID_USAGE_LED_COMPOSE                ((USAGE) 0x04)
#define HID_USAGE_LED_KANA                   ((USAGE) 0x05)
#define HID_USAGE_LED_POWER                  ((USAGE) 0x06)
#define HID_USAGE_LED_SHIFT                  ((USAGE) 0x07)
#define HID_USAGE_LED_DO_NOT_DISTURB         ((USAGE) 0x08)
#define HID_USAGE_LED_MUTE                   ((USAGE) 0x09)
#define HID_USAGE_LED_TONE_ENABLE            ((USAGE) 0x0A)
#define HID_USAGE_LED_HIGH_CUT_FILTER        ((USAGE) 0x0B)
#define HID_USAGE_LED_LOW_CUT_FILTER         ((USAGE) 0x0C)
#define HID_USAGE_LED_EQUALIZER_ENABLE       ((USAGE) 0x0D)
#define HID_USAGE_LED_SOUND_FIELD_ON         ((USAGE) 0x0E)
#define HID_USAGE_LED_SURROUND_FIELD_ON      ((USAGE) 0x0F)
#define HID_USAGE_LED_REPEAT                 ((USAGE) 0x10)
#define HID_USAGE_LED_STEREO                 ((USAGE) 0x11)
#define HID_USAGE_LED_SAMPLING_RATE_DETECT   ((USAGE) 0x12)
#define HID_USAGE_LED_SPINNING               ((USAGE) 0x13)
#define HID_USAGE_LED_CAV                    ((USAGE) 0x14)
#define HID_USAGE_LED_CLV                    ((USAGE) 0x15)
#define HID_USAGE_LED_RECORDING_FORMAT_DET   ((USAGE) 0x16)
#define HID_USAGE_LED_OFF_HOOK               ((USAGE) 0x17)
#define HID_USAGE_LED_RING                   ((USAGE) 0x18)
#define HID_USAGE_LED_MESSAGE_WAITING        ((USAGE) 0x19)
#define HID_USAGE_LED_DATA_MODE              ((USAGE) 0x1A)
#define HID_USAGE_LED_BATTERY_OPERATION      ((USAGE) 0x1B)
#define HID_USAGE_LED_BATTERY_OK             ((USAGE) 0x1C)
#define HID_USAGE_LED_BATTERY_LOW            ((USAGE) 0x1D)
#define HID_USAGE_LED_SPEAKER                ((USAGE) 0x1E)
#define HID_USAGE_LED_HEAD_SET               ((USAGE) 0x1F)
#define HID_USAGE_LED_HOLD                   ((USAGE) 0x20)
#define HID_USAGE_LED_MICROPHONE             ((USAGE) 0x21)
#define HID_USAGE_LED_COVERAGE               ((USAGE) 0x22)
#define HID_USAGE_LED_NIGHT_MODE             ((USAGE) 0x23)
#define HID_USAGE_LED_SEND_CALLS             ((USAGE) 0x24)
#define HID_USAGE_LED_CALL_PICKUP            ((USAGE) 0x25)
#define HID_USAGE_LED_CONFERENCE             ((USAGE) 0x26)
#define HID_USAGE_LED_STAND_BY               ((USAGE) 0x27)
#define HID_USAGE_LED_CAMERA_ON              ((USAGE) 0x28)
#define HID_USAGE_LED_CAMERA_OFF             ((USAGE) 0x29)
#define HID_USAGE_LED_ON_LINE                ((USAGE) 0x2A)
#define HID_USAGE_LED_OFF_LINE               ((USAGE) 0x2B)
#define HID_USAGE_LED_BUSY                   ((USAGE) 0x2C)
#define HID_USAGE_LED_READY                  ((USAGE) 0x2D)
#define HID_USAGE_LED_PAPER_OUT              ((USAGE) 0x2E)
#define HID_USAGE_LED_PAPER_JAM              ((USAGE) 0x2F)
#define HID_USAGE_LED_REMOTE                 ((USAGE) 0x30)
#define HID_USAGE_LED_FORWARD                ((USAGE) 0x31)
#define HID_USAGE_LED_REVERSE                ((USAGE) 0x32)
#define HID_USAGE_LED_STOP                   ((USAGE) 0x33)
#define HID_USAGE_LED_REWIND                 ((USAGE) 0x34)
#define HID_USAGE_LED_FAST_FORWARD           ((USAGE) 0x35)
#define HID_USAGE_LED_PLAY                   ((USAGE) 0x36)
#define HID_USAGE_LED_PAUSE                  ((USAGE) 0x37)
#define HID_USAGE_LED_RECORD                 ((USAGE) 0x38)
#define HID_USAGE_LED_ERROR                  ((USAGE) 0x39)
#define HID_USAGE_LED_SELECTED_INDICATOR     ((USAGE) 0x3A)
#define HID_USAGE_LED_IN_USE_INDICATOR       ((USAGE) 0x3B)
#define HID_USAGE_LED_MULTI_MODE_INDICATOR   ((USAGE) 0x3C)
#define HID_USAGE_LED_INDICATOR_ON           ((USAGE) 0x3D)
#define HID_USAGE_LED_INDICATOR_FLASH        ((USAGE) 0x3E)
#define HID_USAGE_LED_INDICATOR_SLOW_BLINK   ((USAGE) 0x3F)
#define HID_USAGE_LED_INDICATOR_FAST_BLINK   ((USAGE) 0x40)
#define HID_USAGE_LED_INDICATOR_OFF          ((USAGE) 0x41)
#define HID_USAGE_LED_FLASH_ON_TIME          ((USAGE) 0x42)
#define HID_USAGE_LED_SLOW_BLINK_ON_TIME     ((USAGE) 0x43)
#define HID_USAGE_LED_SLOW_BLINK_OFF_TIME    ((USAGE) 0x44)
#define HID_USAGE_LED_FAST_BLINK_ON_TIME     ((USAGE) 0x45)
#define HID_USAGE_LED_FAST_BLINK_OFF_TIME    ((USAGE) 0x46)
#define HID_USAGE_LED_INDICATOR_COLOR        ((USAGE) 0x47)
#define HID_USAGE_LED_RED                    ((USAGE) 0x48)
#define HID_USAGE_LED_GREEN                  ((USAGE) 0x49)
#define HID_USAGE_LED_AMBER                  ((USAGE) 0x4A)
#define HID_USAGE_LED_GENERIC_INDICATOR      ((USAGE) 0x4B)

//
//  Button Page (0x09)
//
//  There is no need to label these usages.
//


//
//  Ordinal Page (0x0A)
//
//  There is no need to label these usages.
//


//
//  Telephony Device Page (0x0B)
//

#define HID_USAGE_TELEPHONY_PHONE                  ((USAGE) 0x01)
#define HID_USAGE_TELEPHONY_ANSWERING_MACHINE      ((USAGE) 0x02)
#define HID_USAGE_TELEPHONY_MESSAGE_CONTROLS       ((USAGE) 0x03)
#define HID_USAGE_TELEPHONY_HANDSET                ((USAGE) 0x04)
#define HID_USAGE_TELEPHONY_HEADSET                ((USAGE) 0x05)
#define HID_USAGE_TELEPHONY_KEYPAD                 ((USAGE) 0x06)
#define HID_USAGE_TELEPHONY_PROGRAMMABLE_BUTTON    ((USAGE) 0x07)

//
// and others...
//

#define HID_USAGE_CONSUMERCTRL          ((USAGE)0x01)
#define HID_USAGE_DIGITIZER_PEN         ((USAGE)0x02)
#define HID_USAGE_DIGITIZER_IN_RANGE    ((USAGE)0x32)
#define HID_USAGE_DIGITIZER_TIP_SWITCH  ((USAGE)0x42)
#define HID_USAGE_DIGITIZER_BARREL_SWITCH ((USAGE)0x44)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\HtmlGuid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995-1998               **
//*********************************************************************

//
//	HTMLGUID.H - GUID definition for HTML viewer object
//

#ifndef _HTMLGUID_H_
#define _HTMLGUID_H_

// GUID for HTML viewer is: {25336920-03F9-11cf-8FD0-00AA00686F13}
DEFINE_GUID(CLSID_HTMLViewer, 0x25336920, 0x3f9, 0x11cf, 0x8f, 0xd0, 0x0, 0xaa, 0x0, 0x68, 0x6f, 0x13);

// GUID for BSCB proxy is: {25336922-03F9-11cf-8FD0-00AA00686F13}
DEFINE_GUID(CLSID_HTMLBSCBProxy, 0x25336922, 0x3f9, 0x11cf, 0x8f, 0xd0, 0x0, 0xaa, 0x0, 0x68, 0x6f, 0x13);

// The GUID used to identify the TypeLib of the HTML Page
// {71BC8840-60BB-11cf-8B97-00AA00476DA6}
DEFINE_GUID(GUID_PageTL,
0x71bc8840, 0x60bb, 0x11cf, 0x8b, 0x97, 0x0, 0xaa, 0x0, 0x47, 0x6d, 0xa6);

// The GUID used to identify the Primary dispinterface of the HTML Page
// {71BC8841-60BB-11cf-8B97-00AA00476DA6}
DEFINE_GUID(IID_PageProps,
0x71bc8841, 0x60bb, 0x11cf, 0x8b, 0x97, 0x0, 0xaa, 0x0, 0x47, 0x6d, 0xa6);

// The GUID used to identify the Event dispinterface of the HTML Page
// The page events are currently commented out but will be added later
// so I grabbed a guid for the events now.
// {71BC8842-60BB-11cf-8B97-00AA00476DA6}
DEFINE_GUID(IID_PageEvents,
0x71bc8842, 0x60bb, 0x11cf, 0x8b, 0x97, 0x0, 0xaa, 0x0, 0x47, 0x6d, 0xa6);

// The GUID used to identify the coclass of the HTML Page
// {71BC8843-60BB-11cf-8B97-00AA00476DA6}
DEFINE_GUID(CLSID_Page,
0x71bc8843, 0x60bb, 0x11cf, 0x8b, 0x97, 0x0, 0xaa, 0x0, 0x47, 0x6d, 0xa6);


#endif // _HTMLGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\htiframe.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for htiframe.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __htiframe_h__
#define __htiframe_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITargetNotify_FWD_DEFINED__
#define __ITargetNotify_FWD_DEFINED__
typedef interface ITargetNotify ITargetNotify;
#endif 	/* __ITargetNotify_FWD_DEFINED__ */


#ifndef __ITargetNotify2_FWD_DEFINED__
#define __ITargetNotify2_FWD_DEFINED__
typedef interface ITargetNotify2 ITargetNotify2;
#endif 	/* __ITargetNotify2_FWD_DEFINED__ */


#ifndef __ITargetFrame2_FWD_DEFINED__
#define __ITargetFrame2_FWD_DEFINED__
typedef interface ITargetFrame2 ITargetFrame2;
#endif 	/* __ITargetFrame2_FWD_DEFINED__ */


#ifndef __ITargetContainer_FWD_DEFINED__
#define __ITargetContainer_FWD_DEFINED__
typedef interface ITargetContainer ITargetContainer;
#endif 	/* __ITargetContainer_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_htiframe_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// HTIframe.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// OLE Hyperlinking ITargetFrame2 Interfaces.



EXTERN_C const IID IID_ITargetFrame2;
EXTERN_C const IID IID_ITargetContainer;
#ifndef _LPTARGETFRAME2_DEFINED
#define _LPTARGETFRAME2_DEFINED
#define TF_NAVIGATE 0x7FAEABAC
#define TARGET_NOTIFY_OBJECT_NAME L"863a99a0-21bc-11d0-82b4-00a0c90c29c5"


extern RPC_IF_HANDLE __MIDL_itf_htiframe_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_htiframe_0000_0000_v0_0_s_ifspec;

#ifndef __ITargetNotify_INTERFACE_DEFINED__
#define __ITargetNotify_INTERFACE_DEFINED__

/* interface ITargetNotify */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer ITargetNotify *LPTARGETNOTIFY;


EXTERN_C const IID IID_ITargetNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("863a99a0-21bc-11d0-82b4-00a0c90c29c5")
    ITargetNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCreate( 
            /* [in] */ __RPC__in_opt IUnknown *pUnkDestination,
            /* [in] */ ULONG cbCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnReuse( 
            /* [in] */ __RPC__in_opt IUnknown *pUnkDestination) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITargetNotify * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITargetNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITargetNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCreate )( 
            ITargetNotify * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkDestination,
            /* [in] */ ULONG cbCookie);
        
        HRESULT ( STDMETHODCALLTYPE *OnReuse )( 
            ITargetNotify * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkDestination);
        
        END_INTERFACE
    } ITargetNotifyVtbl;

    interface ITargetNotify
    {
        CONST_VTBL struct ITargetNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITargetNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITargetNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITargetNotify_OnCreate(This,pUnkDestination,cbCookie)	\
    ( (This)->lpVtbl -> OnCreate(This,pUnkDestination,cbCookie) ) 

#define ITargetNotify_OnReuse(This,pUnkDestination)	\
    ( (This)->lpVtbl -> OnReuse(This,pUnkDestination) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITargetNotify_INTERFACE_DEFINED__ */


#ifndef __ITargetNotify2_INTERFACE_DEFINED__
#define __ITargetNotify2_INTERFACE_DEFINED__

/* interface ITargetNotify2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer ITargetNotify2 *LPTARGETNOTIFY2;


EXTERN_C const IID IID_ITargetNotify2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6b1-98b5-11cf-bb82-00aa00bdce0b")
    ITargetNotify2 : public ITargetNotify
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOptionString( 
            /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetNotify2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITargetNotify2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITargetNotify2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITargetNotify2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCreate )( 
            ITargetNotify2 * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkDestination,
            /* [in] */ ULONG cbCookie);
        
        HRESULT ( STDMETHODCALLTYPE *OnReuse )( 
            ITargetNotify2 * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkDestination);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptionString )( 
            ITargetNotify2 * This,
            /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrOptions);
        
        END_INTERFACE
    } ITargetNotify2Vtbl;

    interface ITargetNotify2
    {
        CONST_VTBL struct ITargetNotify2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetNotify2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITargetNotify2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITargetNotify2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITargetNotify2_OnCreate(This,pUnkDestination,cbCookie)	\
    ( (This)->lpVtbl -> OnCreate(This,pUnkDestination,cbCookie) ) 

#define ITargetNotify2_OnReuse(This,pUnkDestination)	\
    ( (This)->lpVtbl -> OnReuse(This,pUnkDestination) ) 


#define ITargetNotify2_GetOptionString(This,pbstrOptions)	\
    ( (This)->lpVtbl -> GetOptionString(This,pbstrOptions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITargetNotify2_INTERFACE_DEFINED__ */


#ifndef __ITargetFrame2_INTERFACE_DEFINED__
#define __ITargetFrame2_INTERFACE_DEFINED__

/* interface ITargetFrame2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer ITargetFrame2 *LPTARGETFRAME2;

typedef /* [public] */ 
enum __MIDL_ITargetFrame2_0001
    {	FINDFRAME_NONE	= 0,
	FINDFRAME_JUSTTESTEXISTENCE	= 1,
	FINDFRAME_INTERNAL	= 0x80000000
    } 	FINDFRAME_FLAGS;

typedef /* [public] */ 
enum __MIDL_ITargetFrame2_0002
    {	FRAMEOPTIONS_SCROLL_YES	= 0x1,
	FRAMEOPTIONS_SCROLL_NO	= 0x2,
	FRAMEOPTIONS_SCROLL_AUTO	= 0x4,
	FRAMEOPTIONS_NORESIZE	= 0x8,
	FRAMEOPTIONS_NO3DBORDER	= 0x10,
	FRAMEOPTIONS_DESKTOP	= 0x20,
	FRAMEOPTIONS_BROWSERBAND	= 0x40
    } 	FRAMEOPTIONS_FLAGS;


EXTERN_C const IID IID_ITargetFrame2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86D52E11-94A8-11d0-82AF-00C04FD5AE38")
    ITargetFrame2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFrameName( 
            /* [in] */ __RPC__in LPCWSTR pszFrameName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameName( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszFrameName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentFrame( 
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameSrc( 
            /* [in] */ __RPC__in LPCWSTR pszFrameSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameSrc( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszFrameSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFramesContainer( 
            /* [out] */ __RPC__deref_out_opt IOleContainer **ppContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameOptions( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameOptions( 
            /* [out] */ __RPC__out DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameMargins( 
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameMargins( 
            /* [out] */ __RPC__out DWORD *pdwWidth,
            /* [out] */ __RPC__out DWORD *pdwHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFrame( 
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszTargetName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkTargetFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetAlias( 
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszTargetName,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszTargetAlias) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetFrame2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITargetFrame2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITargetFrame2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITargetFrame2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameName )( 
            ITargetFrame2 * This,
            /* [in] */ __RPC__in LPCWSTR pszFrameName);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameName )( 
            ITargetFrame2 * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszFrameName);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentFrame )( 
            ITargetFrame2 * This,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkParent);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameSrc )( 
            ITargetFrame2 * This,
            /* [in] */ __RPC__in LPCWSTR pszFrameSrc);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameSrc )( 
            ITargetFrame2 * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszFrameSrc);
        
        HRESULT ( STDMETHODCALLTYPE *GetFramesContainer )( 
            ITargetFrame2 * This,
            /* [out] */ __RPC__deref_out_opt IOleContainer **ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameOptions )( 
            ITargetFrame2 * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameOptions )( 
            ITargetFrame2 * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameMargins )( 
            ITargetFrame2 * This,
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameMargins )( 
            ITargetFrame2 * This,
            /* [out] */ __RPC__out DWORD *pdwWidth,
            /* [out] */ __RPC__out DWORD *pdwHeight);
        
        HRESULT ( STDMETHODCALLTYPE *FindFrame )( 
            ITargetFrame2 * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszTargetName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkTargetFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetAlias )( 
            ITargetFrame2 * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszTargetName,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszTargetAlias);
        
        END_INTERFACE
    } ITargetFrame2Vtbl;

    interface ITargetFrame2
    {
        CONST_VTBL struct ITargetFrame2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetFrame2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITargetFrame2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITargetFrame2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITargetFrame2_SetFrameName(This,pszFrameName)	\
    ( (This)->lpVtbl -> SetFrameName(This,pszFrameName) ) 

#define ITargetFrame2_GetFrameName(This,ppszFrameName)	\
    ( (This)->lpVtbl -> GetFrameName(This,ppszFrameName) ) 

#define ITargetFrame2_GetParentFrame(This,ppunkParent)	\
    ( (This)->lpVtbl -> GetParentFrame(This,ppunkParent) ) 

#define ITargetFrame2_SetFrameSrc(This,pszFrameSrc)	\
    ( (This)->lpVtbl -> SetFrameSrc(This,pszFrameSrc) ) 

#define ITargetFrame2_GetFrameSrc(This,ppszFrameSrc)	\
    ( (This)->lpVtbl -> GetFrameSrc(This,ppszFrameSrc) ) 

#define ITargetFrame2_GetFramesContainer(This,ppContainer)	\
    ( (This)->lpVtbl -> GetFramesContainer(This,ppContainer) ) 

#define ITargetFrame2_SetFrameOptions(This,dwFlags)	\
    ( (This)->lpVtbl -> SetFrameOptions(This,dwFlags) ) 

#define ITargetFrame2_GetFrameOptions(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetFrameOptions(This,pdwFlags) ) 

#define ITargetFrame2_SetFrameMargins(This,dwWidth,dwHeight)	\
    ( (This)->lpVtbl -> SetFrameMargins(This,dwWidth,dwHeight) ) 

#define ITargetFrame2_GetFrameMargins(This,pdwWidth,pdwHeight)	\
    ( (This)->lpVtbl -> GetFrameMargins(This,pdwWidth,pdwHeight) ) 

#define ITargetFrame2_FindFrame(This,pszTargetName,dwFlags,ppunkTargetFrame)	\
    ( (This)->lpVtbl -> FindFrame(This,pszTargetName,dwFlags,ppunkTargetFrame) ) 

#define ITargetFrame2_GetTargetAlias(This,pszTargetName,ppszTargetAlias)	\
    ( (This)->lpVtbl -> GetTargetAlias(This,pszTargetName,ppszTargetAlias) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITargetFrame2_INTERFACE_DEFINED__ */


#ifndef __ITargetContainer_INTERFACE_DEFINED__
#define __ITargetContainer_INTERFACE_DEFINED__

/* interface ITargetContainer */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer ITargetContainer *LPTARGETCONTAINER;


EXTERN_C const IID IID_ITargetContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7847EC01-2BEC-11d0-82B4-00A0C90C29C5")
    ITargetContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrameUrl( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszFrameSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFramesContainer( 
            /* [out] */ __RPC__deref_out_opt IOleContainer **ppContainer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITargetContainer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITargetContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITargetContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameUrl )( 
            ITargetContainer * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszFrameSrc);
        
        HRESULT ( STDMETHODCALLTYPE *GetFramesContainer )( 
            ITargetContainer * This,
            /* [out] */ __RPC__deref_out_opt IOleContainer **ppContainer);
        
        END_INTERFACE
    } ITargetContainerVtbl;

    interface ITargetContainer
    {
        CONST_VTBL struct ITargetContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITargetContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITargetContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITargetContainer_GetFrameUrl(This,ppszFrameSrc)	\
    ( (This)->lpVtbl -> GetFrameUrl(This,ppszFrameSrc) ) 

#define ITargetContainer_GetFramesContainer(This,ppContainer)	\
    ( (This)->lpVtbl -> GetFramesContainer(This,ppContainer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITargetContainer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_htiframe_0000_0004 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_htiframe_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_htiframe_0000_0004_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\httprequestid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows HTTP Services (WinHTTP)
//  Copyright (C) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------


#ifndef __HTTPREQUESTID_H__
#define __HTTPREQUESTID_H__

#define DISPID_HTTPREQUEST_BASE                     0x00000001


#define DISPID_HTTPREQUEST_OPEN                     (DISPID_HTTPREQUEST_BASE)
#define DISPID_HTTPREQUEST_SETREQUESTHEADER         (DISPID_HTTPREQUEST_BASE + 1)
#define DISPID_HTTPREQUEST_GETRESPONSEHEADER        (DISPID_HTTPREQUEST_BASE + 2)
#define DISPID_HTTPREQUEST_GETALLRESPONSEHEADERS    (DISPID_HTTPREQUEST_BASE + 3)
#define DISPID_HTTPREQUEST_SEND                     (DISPID_HTTPREQUEST_BASE + 4)
#define DISPID_HTTPREQUEST_OPTION                   (DISPID_HTTPREQUEST_BASE + 5)
#define DISPID_HTTPREQUEST_STATUS                   (DISPID_HTTPREQUEST_BASE + 6)
#define DISPID_HTTPREQUEST_STATUSTEXT               (DISPID_HTTPREQUEST_BASE + 7)
#define DISPID_HTTPREQUEST_RESPONSETEXT             (DISPID_HTTPREQUEST_BASE + 8)
#define DISPID_HTTPREQUEST_RESPONSEBODY             (DISPID_HTTPREQUEST_BASE + 9)
#define DISPID_HTTPREQUEST_RESPONSESTREAM           (DISPID_HTTPREQUEST_BASE + 10)
#define DISPID_HTTPREQUEST_ABORT                    (DISPID_HTTPREQUEST_BASE + 11)
#define DISPID_HTTPREQUEST_SETPROXY                 (DISPID_HTTPREQUEST_BASE + 12)
#define DISPID_HTTPREQUEST_SETCREDENTIALS           (DISPID_HTTPREQUEST_BASE + 13)
#define DISPID_HTTPREQUEST_WAITFORRESPONSE          (DISPID_HTTPREQUEST_BASE + 14)
#define DISPID_HTTPREQUEST_SETTIMEOUTS              (DISPID_HTTPREQUEST_BASE + 15)
#define DISPID_HTTPREQUEST_SETCLIENTCERTIFICATE     (DISPID_HTTPREQUEST_BASE + 16)
#define DISPID_HTTPREQUEST_SETAUTOLOGONPOLICY       (DISPID_HTTPREQUEST_BASE + 17)

#endif // __HTTPREQUESTID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\htiface.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for htiface.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __htiface_h__
#define __htiface_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITargetFrame_FWD_DEFINED__
#define __ITargetFrame_FWD_DEFINED__
typedef interface ITargetFrame ITargetFrame;
#endif 	/* __ITargetFrame_FWD_DEFINED__ */


#ifndef __ITargetEmbedding_FWD_DEFINED__
#define __ITargetEmbedding_FWD_DEFINED__
typedef interface ITargetEmbedding ITargetEmbedding;
#endif 	/* __ITargetEmbedding_FWD_DEFINED__ */


#ifndef __ITargetFramePriv_FWD_DEFINED__
#define __ITargetFramePriv_FWD_DEFINED__
typedef interface ITargetFramePriv ITargetFramePriv;
#endif 	/* __ITargetFramePriv_FWD_DEFINED__ */


#ifndef __ITargetFramePriv2_FWD_DEFINED__
#define __ITargetFramePriv2_FWD_DEFINED__
typedef interface ITargetFramePriv2 ITargetFramePriv2;
#endif 	/* __ITargetFramePriv2_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "urlmon.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_htiface_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// HTIface.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// OLE Hyperlinking ITargetFrame Interfaces.

#ifndef _LPTARGETFRAME2_DEFINED														
#include "htiframe.h"														
#endif // _LPTARGETFRAME2_DEFINED														


EXTERN_C const IID IID_ITargetFrame;
EXTERN_C const IID IID_ITargetEmbedding;
EXTERN_C const IID IID_ITargetFramePriv;
EXTERN_C const IID IID_ITargetFramePriv2;
#ifndef _LPTARGETFRAME_DEFINED
#define _LPTARGETFRAME_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_htiface_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_htiface_0000_0000_v0_0_s_ifspec;

#ifndef __ITargetFrame_INTERFACE_DEFINED__
#define __ITargetFrame_INTERFACE_DEFINED__

/* interface ITargetFrame */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer ITargetFrame *LPTARGETFRAME;

typedef /* [public] */ 
enum __MIDL_ITargetFrame_0001
    {	NAVIGATEFRAME_FL_RECORD	= 0x1,
	NAVIGATEFRAME_FL_POST	= 0x2,
	NAVIGATEFRAME_FL_NO_DOC_CACHE	= 0x4,
	NAVIGATEFRAME_FL_NO_IMAGE_CACHE	= 0x8,
	NAVIGATEFRAME_FL_AUTH_FAIL_CACHE_OK	= 0x10,
	NAVIGATEFRAME_FL_SENDING_FROM_FORM	= 0x20,
	NAVIGATEFRAME_FL_REALLY_SENDING_FROM_FORM	= 0x40
    } 	NAVIGATEFRAME_FLAGS;

typedef struct tagNavigateData
    {
    ULONG ulTarget;
    ULONG ulURL;
    ULONG ulRefURL;
    ULONG ulPostData;
    DWORD dwFlags;
    } 	NAVIGATEDATA;


EXTERN_C const IID IID_ITargetFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5f78c80-5252-11cf-90fa-00AA0042106e")
    ITargetFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFrameName( 
            /* [in] */ __RPC__in LPCWSTR pszFrameName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameName( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszFrameName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentFrame( 
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFrame( 
            /* [in] */ __RPC__in LPCWSTR pszTargetName,
            /* [in] */ __RPC__in_opt IUnknown *ppunkContextFrame,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkTargetFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameSrc( 
            /* [in] */ __RPC__in LPCWSTR pszFrameSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameSrc( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszFrameSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFramesContainer( 
            /* [out] */ __RPC__deref_out_opt IOleContainer **ppContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameOptions( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameOptions( 
            /* [out] */ __RPC__out DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameMargins( 
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameMargins( 
            /* [out] */ __RPC__out DWORD *pdwWidth,
            /* [out] */ __RPC__out DWORD *pdwHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoteNavigate( 
            /* [in] */ ULONG cLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cLength) ULONG *pulData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnChildFrameActivate( 
            /* [in] */ __RPC__in_opt IUnknown *pUnkChildFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnChildFrameDeactivate( 
            /* [in] */ __RPC__in_opt IUnknown *pUnkChildFrame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITargetFrame * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITargetFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITargetFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameName )( 
            ITargetFrame * This,
            /* [in] */ __RPC__in LPCWSTR pszFrameName);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameName )( 
            ITargetFrame * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszFrameName);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentFrame )( 
            ITargetFrame * This,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkParent);
        
        HRESULT ( STDMETHODCALLTYPE *FindFrame )( 
            ITargetFrame * This,
            /* [in] */ __RPC__in LPCWSTR pszTargetName,
            /* [in] */ __RPC__in_opt IUnknown *ppunkContextFrame,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkTargetFrame);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameSrc )( 
            ITargetFrame * This,
            /* [in] */ __RPC__in LPCWSTR pszFrameSrc);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameSrc )( 
            ITargetFrame * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszFrameSrc);
        
        HRESULT ( STDMETHODCALLTYPE *GetFramesContainer )( 
            ITargetFrame * This,
            /* [out] */ __RPC__deref_out_opt IOleContainer **ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameOptions )( 
            ITargetFrame * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameOptions )( 
            ITargetFrame * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameMargins )( 
            ITargetFrame * This,
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameMargins )( 
            ITargetFrame * This,
            /* [out] */ __RPC__out DWORD *pdwWidth,
            /* [out] */ __RPC__out DWORD *pdwHeight);
        
        HRESULT ( STDMETHODCALLTYPE *RemoteNavigate )( 
            ITargetFrame * This,
            /* [in] */ ULONG cLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cLength) ULONG *pulData);
        
        HRESULT ( STDMETHODCALLTYPE *OnChildFrameActivate )( 
            ITargetFrame * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkChildFrame);
        
        HRESULT ( STDMETHODCALLTYPE *OnChildFrameDeactivate )( 
            ITargetFrame * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkChildFrame);
        
        END_INTERFACE
    } ITargetFrameVtbl;

    interface ITargetFrame
    {
        CONST_VTBL struct ITargetFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetFrame_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITargetFrame_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITargetFrame_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITargetFrame_SetFrameName(This,pszFrameName)	\
    ( (This)->lpVtbl -> SetFrameName(This,pszFrameName) ) 

#define ITargetFrame_GetFrameName(This,ppszFrameName)	\
    ( (This)->lpVtbl -> GetFrameName(This,ppszFrameName) ) 

#define ITargetFrame_GetParentFrame(This,ppunkParent)	\
    ( (This)->lpVtbl -> GetParentFrame(This,ppunkParent) ) 

#define ITargetFrame_FindFrame(This,pszTargetName,ppunkContextFrame,dwFlags,ppunkTargetFrame)	\
    ( (This)->lpVtbl -> FindFrame(This,pszTargetName,ppunkContextFrame,dwFlags,ppunkTargetFrame) ) 

#define ITargetFrame_SetFrameSrc(This,pszFrameSrc)	\
    ( (This)->lpVtbl -> SetFrameSrc(This,pszFrameSrc) ) 

#define ITargetFrame_GetFrameSrc(This,ppszFrameSrc)	\
    ( (This)->lpVtbl -> GetFrameSrc(This,ppszFrameSrc) ) 

#define ITargetFrame_GetFramesContainer(This,ppContainer)	\
    ( (This)->lpVtbl -> GetFramesContainer(This,ppContainer) ) 

#define ITargetFrame_SetFrameOptions(This,dwFlags)	\
    ( (This)->lpVtbl -> SetFrameOptions(This,dwFlags) ) 

#define ITargetFrame_GetFrameOptions(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetFrameOptions(This,pdwFlags) ) 

#define ITargetFrame_SetFrameMargins(This,dwWidth,dwHeight)	\
    ( (This)->lpVtbl -> SetFrameMargins(This,dwWidth,dwHeight) ) 

#define ITargetFrame_GetFrameMargins(This,pdwWidth,pdwHeight)	\
    ( (This)->lpVtbl -> GetFrameMargins(This,pdwWidth,pdwHeight) ) 

#define ITargetFrame_RemoteNavigate(This,cLength,pulData)	\
    ( (This)->lpVtbl -> RemoteNavigate(This,cLength,pulData) ) 

#define ITargetFrame_OnChildFrameActivate(This,pUnkChildFrame)	\
    ( (This)->lpVtbl -> OnChildFrameActivate(This,pUnkChildFrame) ) 

#define ITargetFrame_OnChildFrameDeactivate(This,pUnkChildFrame)	\
    ( (This)->lpVtbl -> OnChildFrameDeactivate(This,pUnkChildFrame) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITargetFrame_INTERFACE_DEFINED__ */


#ifndef __ITargetEmbedding_INTERFACE_DEFINED__
#define __ITargetEmbedding_INTERFACE_DEFINED__

/* interface ITargetEmbedding */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer ITargetEmbedding *LPTARGETEMBEDDING;


EXTERN_C const IID IID_ITargetEmbedding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("548793C0-9E74-11cf-9655-00A0C9034923")
    ITargetEmbedding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTargetFrame( 
            /* [out] */ __RPC__deref_out_opt ITargetFrame **ppTargetFrame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetEmbeddingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITargetEmbedding * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITargetEmbedding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITargetEmbedding * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetFrame )( 
            ITargetEmbedding * This,
            /* [out] */ __RPC__deref_out_opt ITargetFrame **ppTargetFrame);
        
        END_INTERFACE
    } ITargetEmbeddingVtbl;

    interface ITargetEmbedding
    {
        CONST_VTBL struct ITargetEmbeddingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetEmbedding_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITargetEmbedding_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITargetEmbedding_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITargetEmbedding_GetTargetFrame(This,ppTargetFrame)	\
    ( (This)->lpVtbl -> GetTargetFrame(This,ppTargetFrame) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITargetEmbedding_INTERFACE_DEFINED__ */


#ifndef __ITargetFramePriv_INTERFACE_DEFINED__
#define __ITargetFramePriv_INTERFACE_DEFINED__

/* interface ITargetFramePriv */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer ITargetFramePriv *LPTARGETFRAMEPRIV;


EXTERN_C const IID IID_ITargetFramePriv;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9216E421-2BF5-11d0-82B4-00A0C90C29C5")
    ITargetFramePriv : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindFrameDownwards( 
            /* [in] */ __RPC__in LPCWSTR pszTargetName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkTargetFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFrameInContext( 
            /* [in] */ __RPC__in LPCWSTR pszTargetName,
            /* [in] */ __RPC__in_opt IUnknown *punkContextFrame,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkTargetFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnChildFrameActivate( 
            /* [in] */ __RPC__in_opt IUnknown *pUnkChildFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnChildFrameDeactivate( 
            /* [in] */ __RPC__in_opt IUnknown *pUnkChildFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NavigateHack( 
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt LPBC pbc,
            /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pibsc,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszTargetName,
            /* [in] */ __RPC__in LPCWSTR pszUrl,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindBrowserByIndex( 
            /* [in] */ DWORD dwID,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkBrowser) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetFramePrivVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITargetFramePriv * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITargetFramePriv * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITargetFramePriv * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindFrameDownwards )( 
            ITargetFramePriv * This,
            /* [in] */ __RPC__in LPCWSTR pszTargetName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkTargetFrame);
        
        HRESULT ( STDMETHODCALLTYPE *FindFrameInContext )( 
            ITargetFramePriv * This,
            /* [in] */ __RPC__in LPCWSTR pszTargetName,
            /* [in] */ __RPC__in_opt IUnknown *punkContextFrame,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkTargetFrame);
        
        HRESULT ( STDMETHODCALLTYPE *OnChildFrameActivate )( 
            ITargetFramePriv * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkChildFrame);
        
        HRESULT ( STDMETHODCALLTYPE *OnChildFrameDeactivate )( 
            ITargetFramePriv * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkChildFrame);
        
        HRESULT ( STDMETHODCALLTYPE *NavigateHack )( 
            ITargetFramePriv * This,
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt LPBC pbc,
            /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pibsc,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszTargetName,
            /* [in] */ __RPC__in LPCWSTR pszUrl,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszLocation);
        
        HRESULT ( STDMETHODCALLTYPE *FindBrowserByIndex )( 
            ITargetFramePriv * This,
            /* [in] */ DWORD dwID,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkBrowser);
        
        END_INTERFACE
    } ITargetFramePrivVtbl;

    interface ITargetFramePriv
    {
        CONST_VTBL struct ITargetFramePrivVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetFramePriv_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITargetFramePriv_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITargetFramePriv_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITargetFramePriv_FindFrameDownwards(This,pszTargetName,dwFlags,ppunkTargetFrame)	\
    ( (This)->lpVtbl -> FindFrameDownwards(This,pszTargetName,dwFlags,ppunkTargetFrame) ) 

#define ITargetFramePriv_FindFrameInContext(This,pszTargetName,punkContextFrame,dwFlags,ppunkTargetFrame)	\
    ( (This)->lpVtbl -> FindFrameInContext(This,pszTargetName,punkContextFrame,dwFlags,ppunkTargetFrame) ) 

#define ITargetFramePriv_OnChildFrameActivate(This,pUnkChildFrame)	\
    ( (This)->lpVtbl -> OnChildFrameActivate(This,pUnkChildFrame) ) 

#define ITargetFramePriv_OnChildFrameDeactivate(This,pUnkChildFrame)	\
    ( (This)->lpVtbl -> OnChildFrameDeactivate(This,pUnkChildFrame) ) 

#define ITargetFramePriv_NavigateHack(This,grfHLNF,pbc,pibsc,pszTargetName,pszUrl,pszLocation)	\
    ( (This)->lpVtbl -> NavigateHack(This,grfHLNF,pbc,pibsc,pszTargetName,pszUrl,pszLocation) ) 

#define ITargetFramePriv_FindBrowserByIndex(This,dwID,ppunkBrowser)	\
    ( (This)->lpVtbl -> FindBrowserByIndex(This,dwID,ppunkBrowser) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITargetFramePriv_INTERFACE_DEFINED__ */


#ifndef __ITargetFramePriv2_INTERFACE_DEFINED__
#define __ITargetFramePriv2_INTERFACE_DEFINED__

/* interface ITargetFramePriv2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer ITargetFramePriv2 *LPTARGETFRAMEPRIV2;


EXTERN_C const IID IID_ITargetFramePriv2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2C867E6-69D6-46F2-A611-DED9A4BD7FEF")
    ITargetFramePriv2 : public ITargetFramePriv
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AggregatedNavigation2( 
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt LPBC pbc,
            /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pibsc,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszTargetName,
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszLocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetFramePriv2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITargetFramePriv2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITargetFramePriv2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITargetFramePriv2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindFrameDownwards )( 
            ITargetFramePriv2 * This,
            /* [in] */ __RPC__in LPCWSTR pszTargetName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkTargetFrame);
        
        HRESULT ( STDMETHODCALLTYPE *FindFrameInContext )( 
            ITargetFramePriv2 * This,
            /* [in] */ __RPC__in LPCWSTR pszTargetName,
            /* [in] */ __RPC__in_opt IUnknown *punkContextFrame,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkTargetFrame);
        
        HRESULT ( STDMETHODCALLTYPE *OnChildFrameActivate )( 
            ITargetFramePriv2 * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkChildFrame);
        
        HRESULT ( STDMETHODCALLTYPE *OnChildFrameDeactivate )( 
            ITargetFramePriv2 * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkChildFrame);
        
        HRESULT ( STDMETHODCALLTYPE *NavigateHack )( 
            ITargetFramePriv2 * This,
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt LPBC pbc,
            /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pibsc,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszTargetName,
            /* [in] */ __RPC__in LPCWSTR pszUrl,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszLocation);
        
        HRESULT ( STDMETHODCALLTYPE *FindBrowserByIndex )( 
            ITargetFramePriv2 * This,
            /* [in] */ DWORD dwID,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunkBrowser);
        
        HRESULT ( STDMETHODCALLTYPE *AggregatedNavigation2 )( 
            ITargetFramePriv2 * This,
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ __RPC__in_opt LPBC pbc,
            /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pibsc,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszTargetName,
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszLocation);
        
        END_INTERFACE
    } ITargetFramePriv2Vtbl;

    interface ITargetFramePriv2
    {
        CONST_VTBL struct ITargetFramePriv2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetFramePriv2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITargetFramePriv2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITargetFramePriv2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITargetFramePriv2_FindFrameDownwards(This,pszTargetName,dwFlags,ppunkTargetFrame)	\
    ( (This)->lpVtbl -> FindFrameDownwards(This,pszTargetName,dwFlags,ppunkTargetFrame) ) 

#define ITargetFramePriv2_FindFrameInContext(This,pszTargetName,punkContextFrame,dwFlags,ppunkTargetFrame)	\
    ( (This)->lpVtbl -> FindFrameInContext(This,pszTargetName,punkContextFrame,dwFlags,ppunkTargetFrame) ) 

#define ITargetFramePriv2_OnChildFrameActivate(This,pUnkChildFrame)	\
    ( (This)->lpVtbl -> OnChildFrameActivate(This,pUnkChildFrame) ) 

#define ITargetFramePriv2_OnChildFrameDeactivate(This,pUnkChildFrame)	\
    ( (This)->lpVtbl -> OnChildFrameDeactivate(This,pUnkChildFrame) ) 

#define ITargetFramePriv2_NavigateHack(This,grfHLNF,pbc,pibsc,pszTargetName,pszUrl,pszLocation)	\
    ( (This)->lpVtbl -> NavigateHack(This,grfHLNF,pbc,pibsc,pszTargetName,pszUrl,pszLocation) ) 

#define ITargetFramePriv2_FindBrowserByIndex(This,dwID,ppunkBrowser)	\
    ( (This)->lpVtbl -> FindBrowserByIndex(This,dwID,ppunkBrowser) ) 


#define ITargetFramePriv2_AggregatedNavigation2(This,grfHLNF,pbc,pibsc,pszTargetName,pUri,pszLocation)	\
    ( (This)->lpVtbl -> AggregatedNavigation2(This,grfHLNF,pbc,pibsc,pszTargetName,pUri,pszLocation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITargetFramePriv2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_htiface_0000_0004 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_htiface_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_htiface_0000_0004_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\httpcach.h ===
#ifndef _HTTPCACH_H_
#define _HTTPCACH_H_

//
// key and data for uri-cache
//

#define URI_CACHE_NAME             L"URI"

class IUriKey : public IHttpCacheKey
{
 public:
    PCWSTR
    GetCacheName(
        VOID
    ) const
    {
        return URI_CACHE_NAME;
    }

    virtual
    PCWSTR
    GetUrl(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetSiteName(
        VOID
    ) const = 0;

    virtual
    DWORD
    GetSiteId(
        VOID
    ) const = 0;

    virtual
    VOID
    UpdateFrequentlyHitTickCount(
        DWORD   dwTicks
    ) = 0;

    virtual
    PCWSTR
    GetConfigPath(
        VOID
    ) const = 0;
};

//
// key and data for file-cache
//

#define FILE_CACHE_NAME             L"FILE"

class IFileKey : public IHttpCacheKey
{
public:
    PCWSTR
    GetCacheName(
        VOID
    ) const
    {
        return FILE_CACHE_NAME;
    }

    virtual
    PCWSTR
    GetPath(
        VOID
    ) const = 0;
};

//
// key and data for token-cache
//

#define TOKEN_CACHE_NAME            L"TOKEN"

class IHttpTokenKey : public IHttpCacheKey
{
 public:
    PCWSTR
    GetCacheName(
        VOID
    ) const
    {
        return TOKEN_CACHE_NAME;
    }

    virtual
    PCWSTR
    GetUserName(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetPasswordHash(
        VOID
    ) const = 0;

    //
    // return the LOGON32_LOGON_* method used when logging on the user
    //
    
    virtual
    DWORD
    GetLogonMethod(
        VOID
    ) const = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\hwebcore.h ===
/*++

   Copyright    (c)    2004    Microsoft Corporation

   Module  Name :
     hostable_web_core.h

   Abstract:

     Hostable web core enables processes other than the W3WP.exe to load the IISCore 
     and effectively host pages without having to reverse-engineer IIS W3 core 
     functionality (ISAPI filter/extension support, authentication, authorization, 
     configuring http.sys, compression, etc.).  

     This header file defines the interface between the hostable web core and the hosting process

     Note: Only single instance of the hostable web core will be allowed within one process
     Attempt to initialize more than one will result in failure

   Environment:
       Win32 - User Mode

   Project:
      IIS7

--*/

#ifndef _HOSTABLE_WEB_CORE_H_
#define _HOSTABLE_WEB_CORE_H_

// 
// The actual names of the hostable webcore DLL and the start/stop entry points
//

#define WEB_CORE_DLL_NAME                L"hwebcore.dll"
#define WEB_CORE_ACTIVATE_DLL_ENTRY      "WebCoreActivate"
#define WEB_CORE_SHUTDOWN_DLL_ENTRY      "WebCoreShutdown"



//
// Prototype for the WEB_CORE_ACTIVATE_DLL_ENTRY call used to
// start the hostable webcore. 
// Hosting process must provide path to the Application Host config file
// that contains the description of sites/applications/appools
// second parameter is meant mainly for identifying webcore instance
// when reporting NT event log events
//
// Return values:
//
// HRESULT_FROM_WIN32( ERROR_SERVICE_ALREADY_RUNNING ) - returned if
//   instance of the hostable web core is already running in the process
//
// HRESULT_FROM_WIN32( ERROR_INVALID_DATA ) - most likely this error
//   means configuration error in the AppHostConfigFile
//
// any other error that occurs during activation will be reported
//

typedef HRESULT
(*PFN_WEB_CORE_ACTIVATE)
(
    IN PCWSTR                           pszAppHostConfigFile,
    IN PCWSTR                           pszRootWebConfigFile,    
    IN PCWSTR                           pszInstanceName
);


//
// Prototype for the WEB_CORE_SHUTDOWN_DLL_ENTRY call used to
// stop the hostable webcore. 
// Hosting process may choose between immediate shutdown and graceful shutdown
// If graceful shutdown is chosen then hostable webcore will stop receiving
// new requests and wait for the currently executing requests to complete for certain time
// (as specified in the config)
//
// Return values:
//
// HRESULT_FROM_WIN32( ERROR_SERVICE_NOT_ACTIVE ) - returned if
//   hostable web core is not running and there is nothing to stop
//
// HRESULT_FROM_WIN32( ERROR_INVALID_SERVICE_CONTROL ) - returned if shutdown
//   is already in progress. Note that this error wouldn't be returned
//   if current shutdown in progress been triggered by the callback thread 
//   (the one that notifies about config change or bad health). In that case 
//   host asking for shutdown will be blocked until callback thread is completed
//
// HRESULT_FROM_WIN32( ERROR_SERVICE_REQUEST_TIMEOUT ) - returned if graceful
//   shutdown was requested but was not able to complete within a given period
//   This is rather a WARNING because webcore gets shutdown forcefully 
//   if graceful shutdown attempt times out. But caller may want to be informed
//   that some requests may have been forcefully cancelled
//
// any other error that occurs during termination will be reported
//

typedef HRESULT
(*PFN_WEB_CORE_SHUTDOWN)
(
    IN DWORD                     fImmediate
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\HtmlHelp.h ===
/****************************************************************************
*                                                                           *
* HtmlHelp.h                                                                *
*                                                                           *
* Copyright (c) 1996-1997, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __HTMLHELP_H__
#define __HTMLHELP_H__

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#if _MSC_VER < 1200
// Defines for Win64
#ifndef _WIN64
#define DWORD_PTR DWORD
#endif
#endif

// Commands to pass to HtmlHelp()

#define HH_DISPLAY_TOPIC        0x0000
#define HH_HELP_FINDER          0x0000  // WinHelp equivalent
#define HH_DISPLAY_TOC          0x0001  
#define HH_DISPLAY_INDEX        0x0002  
#define HH_DISPLAY_SEARCH       0x0003  
#define HH_SET_WIN_TYPE         0x0004
#define HH_GET_WIN_TYPE         0x0005
#define HH_GET_WIN_HANDLE       0x0006
#define HH_ENUM_INFO_TYPE       0x0007  // Get Info type name, call repeatedly to enumerate, -1 at end
#define HH_SET_INFO_TYPE        0x0008  // Add Info type to filter.
#define HH_SYNC                 0x0009
#define HH_RESERVED1            0x000A
#define HH_RESERVED2            0x000B
#define HH_RESERVED3            0x000C
#define HH_KEYWORD_LOOKUP       0x000D
#define HH_DISPLAY_TEXT_POPUP   0x000E  // display string resource id or text in a popup window
#define HH_HELP_CONTEXT         0x000F  // display mapped numeric value in dwData
#define HH_TP_HELP_CONTEXTMENU  0x0010  // text popup help, same as WinHelp HELP_CONTEXTMENU
#define HH_TP_HELP_WM_HELP      0x0011  // text popup help, same as WinHelp HELP_WM_HELP
#define HH_CLOSE_ALL            0x0012  // close all windows opened directly or indirectly by the caller
#define HH_ALINK_LOOKUP         0x0013  // ALink version of HH_KEYWORD_LOOKUP
#define HH_GET_LAST_ERROR       0x0014  // not currently implemented // See HHERROR.h
#define HH_ENUM_CATEGORY        0x0015	// Get category name, call repeatedly to enumerate, -1 at end
#define HH_ENUM_CATEGORY_IT     0x0016  // Get category info type members, call repeatedly to enumerate, -1 at end
#define HH_RESET_IT_FILTER      0x0017  // Clear the info type filter of all info types.
#define HH_SET_INCLUSIVE_FILTER 0x0018  // set inclusive filtering method for untyped topics to be included in display
#define HH_SET_EXCLUSIVE_FILTER 0x0019  // set exclusive filtering method for untyped topics to be excluded from display
#define HH_INITIALIZE            0x001C  // Initializes the help system.
#define HH_UNINITIALIZE          0x001D  // Uninitializes the help system.
#define HH_SET_QUERYSERVICE     0x001E  // Set the Host IQueryService interface
#define HH_PRETRANSLATEMESSAGE  0x00fd  // Pumps messages. (NULL, NULL, MSG*). 
#define HH_SET_GLOBAL_PROPERTY  0x00fc  // Set a global property. (NULL, NULL, HH_GPROP)
#define HH_SAFE_DISPLAY_TOPIC   0x0020  // private addition to the interface for InternetExplorer.

#define HHWIN_PROP_TAB_AUTOHIDESHOW (1 << 0)    // Automatically hide/show tri-pane window
#define HHWIN_PROP_ONTOP            (1 << 1)    // Top-most window
#define HHWIN_PROP_NOTITLEBAR       (1 << 2)    // no title bar
#define HHWIN_PROP_NODEF_STYLES     (1 << 3)    // no default window styles (only HH_WINTYPE.dwStyles)
#define HHWIN_PROP_NODEF_EXSTYLES   (1 << 4)    // no default extended window styles (only HH_WINTYPE.dwExStyles)
#define HHWIN_PROP_TRI_PANE         (1 << 5)    // use a tri-pane window
#define HHWIN_PROP_NOTB_TEXT        (1 << 6)    // no text on toolbar buttons
#define HHWIN_PROP_POST_QUIT        (1 << 7)    // post WM_QUIT message when window closes
#define HHWIN_PROP_AUTO_SYNC        (1 << 8)    // automatically ssync contents and index
#define HHWIN_PROP_TRACKING         (1 << 9)    // send tracking notification messages
#define HHWIN_PROP_TAB_SEARCH       (1 << 10)   // include search tab in navigation pane
#define HHWIN_PROP_TAB_HISTORY      (1 << 11)   // include history tab in navigation pane
#define HHWIN_PROP_TAB_FAVORITES    (1 << 12)   // include favorites tab in navigation pane
#define HHWIN_PROP_CHANGE_TITLE     (1 << 13)   // Put current HTML title in title bar
#define HHWIN_PROP_NAV_ONLY_WIN     (1 << 14)   // Only display the navigation window
#define HHWIN_PROP_NO_TOOLBAR       (1 << 15)   // Don't display a toolbar
#define HHWIN_PROP_MENU             (1 << 16)   // Menu
#define HHWIN_PROP_TAB_ADVSEARCH    (1 << 17)   // Advanced FTS UI.
#define HHWIN_PROP_USER_POS         (1 << 18)   // After initial creation, user controls window size/position
#define HHWIN_PROP_TAB_CUSTOM1      (1 << 19)   // Use custom tab #1
#define HHWIN_PROP_TAB_CUSTOM2      (1 << 20)   // Use custom tab #2
#define HHWIN_PROP_TAB_CUSTOM3      (1 << 21)   // Use custom tab #3
#define HHWIN_PROP_TAB_CUSTOM4      (1 << 22)   // Use custom tab #4
#define HHWIN_PROP_TAB_CUSTOM5      (1 << 23)   // Use custom tab #5
#define HHWIN_PROP_TAB_CUSTOM6      (1 << 24)   // Use custom tab #6
#define HHWIN_PROP_TAB_CUSTOM7      (1 << 25)   // Use custom tab #7
#define HHWIN_PROP_TAB_CUSTOM8      (1 << 26)   // Use custom tab #8
#define HHWIN_PROP_TAB_CUSTOM9      (1 << 27)   // Use custom tab #9
#define HHWIN_TB_MARGIN             (1 << 28)   // the window type has a margin

#define HHWIN_PARAM_PROPERTIES      (1 << 1)    // valid fsWinProperties
#define HHWIN_PARAM_STYLES          (1 << 2)    // valid dwStyles
#define HHWIN_PARAM_EXSTYLES        (1 << 3)    // valid dwExStyles
#define HHWIN_PARAM_RECT            (1 << 4)    // valid rcWindowPos
#define HHWIN_PARAM_NAV_WIDTH       (1 << 5)    // valid iNavWidth
#define HHWIN_PARAM_SHOWSTATE       (1 << 6)    // valid nShowState
#define HHWIN_PARAM_INFOTYPES       (1 << 7)    // valid apInfoTypes
#define HHWIN_PARAM_TB_FLAGS        (1 << 8)    // valid fsToolBarFlags
#define HHWIN_PARAM_EXPANSION       (1 << 9)    // valid fNotExpanded
#define HHWIN_PARAM_TABPOS          (1 << 10)   // valid tabpos
#define HHWIN_PARAM_TABORDER        (1 << 11)   // valid taborder
#define HHWIN_PARAM_HISTORY_COUNT   (1 << 12)   // valid cHistory
#define HHWIN_PARAM_CUR_TAB         (1 << 13)   // valid curNavType

#define HHWIN_BUTTON_EXPAND         (1 << 1)    // Expand/contract button
#define HHWIN_BUTTON_BACK           (1 << 2)    // Back button
#define HHWIN_BUTTON_FORWARD        (1 << 3)    // Forward button
#define HHWIN_BUTTON_STOP           (1 << 4)    // Stop button
#define HHWIN_BUTTON_REFRESH        (1 << 5)    // Refresh button
#define HHWIN_BUTTON_HOME           (1 << 6)    // Home button
#define HHWIN_BUTTON_BROWSE_FWD     (1 << 7)    // not implemented
#define HHWIN_BUTTON_BROWSE_BCK     (1 << 8)    // not implemented
#define HHWIN_BUTTON_NOTES          (1 << 9)    // not implemented
#define HHWIN_BUTTON_CONTENTS       (1 << 10)   // not implemented
#define HHWIN_BUTTON_SYNC           (1 << 11)   // Sync button
#define HHWIN_BUTTON_OPTIONS        (1 << 12)   // Options button
#define HHWIN_BUTTON_PRINT          (1 << 13)   // Print button
#define HHWIN_BUTTON_INDEX          (1 << 14)   // not implemented
#define HHWIN_BUTTON_SEARCH         (1 << 15)   // not implemented
#define HHWIN_BUTTON_HISTORY        (1 << 16)   // not implemented
#define HHWIN_BUTTON_FAVORITES      (1 << 17)   // not implemented
#define HHWIN_BUTTON_JUMP1          (1 << 18)
#define HHWIN_BUTTON_JUMP2          (1 << 19)
#define HHWIN_BUTTON_ZOOM           (1 << 20)
#define HHWIN_BUTTON_TOC_NEXT       (1 << 21)
#define HHWIN_BUTTON_TOC_PREV       (1 << 22)

#define HHWIN_DEF_BUTTONS           \
            (HHWIN_BUTTON_EXPAND |  \
             HHWIN_BUTTON_BACK |    \
             HHWIN_BUTTON_OPTIONS | \
             HHWIN_BUTTON_PRINT)

// Button IDs

#define IDTB_EXPAND             200
#define IDTB_CONTRACT           201
#define IDTB_STOP               202
#define IDTB_REFRESH            203
#define IDTB_BACK               204
#define IDTB_HOME               205
#define IDTB_SYNC               206
#define IDTB_PRINT              207
#define IDTB_OPTIONS            208
#define IDTB_FORWARD            209
#define IDTB_NOTES              210 // not implemented
#define IDTB_BROWSE_FWD         211
#define IDTB_BROWSE_BACK        212
#define IDTB_CONTENTS           213 // not implemented
#define IDTB_INDEX              214 // not implemented
#define IDTB_SEARCH             215 // not implemented
#define IDTB_HISTORY            216 // not implemented
#define IDTB_FAVORITES          217 // not implemented
#define IDTB_JUMP1              218
#define IDTB_JUMP2              219
#define IDTB_CUSTOMIZE          221
#define IDTB_ZOOM               222
#define IDTB_TOC_NEXT           223
#define IDTB_TOC_PREV           224

// Notification codes

#define HHN_FIRST       (0U-860U)
#define HHN_LAST        (0U-879U)

#define HHN_NAVCOMPLETE   (HHN_FIRST-0)
#define HHN_TRACK         (HHN_FIRST-1)
#define HHN_WINDOW_CREATE (HHN_FIRST-2)

typedef struct tagHHN_NOTIFY
{
    NMHDR   hdr;
    PCSTR   pszUrl; // Multi-byte, null-terminated string
} HHN_NOTIFY;

typedef struct tagHH_POPUP
{
    int       cbStruct;      // sizeof this structure
    HINSTANCE hinst;         // instance handle for string resource
    UINT      idString;      // string resource id, or text id if pszFile is specified in HtmlHelp call
    LPCTSTR   pszText;       // used if idString is zero
    POINT     pt;            // top center of popup window
    COLORREF  clrForeground; // use -1 for default
    COLORREF  clrBackground; // use -1 for default
    RECT      rcMargins;     // amount of space between edges of window and text, -1 for each member to ignore
    LPCTSTR   pszFont;       // facename, point size, char set, BOLD ITALIC UNDERLINE
} HH_POPUP;

typedef struct tagHH_AKLINK
{
    int       cbStruct;     // sizeof this structure
    BOOL      fReserved;    // must be FALSE (really!)
    LPCTSTR   pszKeywords;  // semi-colon separated keywords
    LPCTSTR   pszUrl;       // URL to jump to if no keywords found (may be NULL)
    LPCTSTR   pszMsgText;   // Message text to display in MessageBox if pszUrl is NULL and no keyword match
    LPCTSTR   pszMsgTitle;  // Message text to display in MessageBox if pszUrl is NULL and no keyword match
    LPCTSTR   pszWindow;    // Window to display URL in
    BOOL      fIndexOnFail; // Displays index if keyword lookup fails.
} HH_AKLINK;

enum {
    HHWIN_NAVTYPE_TOC,
    HHWIN_NAVTYPE_INDEX,
    HHWIN_NAVTYPE_SEARCH,
    HHWIN_NAVTYPE_FAVORITES,
    HHWIN_NAVTYPE_HISTORY,   // not implemented
    HHWIN_NAVTYPE_AUTHOR,
    HHWIN_NAVTYPE_CUSTOM_FIRST = 11
};

enum {
    IT_INCLUSIVE,
    IT_EXCLUSIVE,
    IT_HIDDEN,
};

typedef struct tagHH_ENUM_IT
{
    int       cbStruct;          // size of this structure
    int       iType;             // the type of the information type ie. Inclusive, Exclusive, or Hidden
    LPCSTR    pszCatName;        // Set to the name of the Category to enumerate the info types in a category; else NULL
    LPCSTR    pszITName;         // volitile pointer to the name of the infotype. Allocated by call. Caller responsible for freeing
    LPCSTR    pszITDescription;  // volitile pointer to the description of the infotype.
} HH_ENUM_IT, *PHH_ENUM_IT;

typedef struct tagHH_ENUM_CAT
{
    int       cbStruct;          // size of this structure
    LPCSTR    pszCatName;        // volitile pointer to the category name
    LPCSTR    pszCatDescription; // volitile pointer to the category description
} HH_ENUM_CAT, *PHH_ENUM_CAT;

typedef struct tagHH_SET_INFOTYPE
{
    int       cbStruct;          // the size of this structure
    LPCSTR    pszCatName;        // the name of the category, if any, the InfoType is a member of.
    LPCSTR    pszInfoTypeName;   // the name of the info type to add to the filter
} HH_SET_INFOTYPE, *PHH_SET_INFOTYPE;

typedef DWORD HH_INFOTYPE;
typedef HH_INFOTYPE* PHH_INFOTYPE;

enum {
    HHWIN_NAVTAB_TOP,
    HHWIN_NAVTAB_LEFT,
    HHWIN_NAVTAB_BOTTOM,
};

#define HH_MAX_TABS 19  // maximum number of tabs

enum {
    HH_TAB_CONTENTS,
    HH_TAB_INDEX,
    HH_TAB_SEARCH,
    HH_TAB_FAVORITES,
    HH_TAB_HISTORY,
    HH_TAB_AUTHOR,

    HH_TAB_CUSTOM_FIRST = 11,
    HH_TAB_CUSTOM_LAST = HH_MAX_TABS
};

#define HH_MAX_TABS_CUSTOM (HH_TAB_CUSTOM_LAST - HH_TAB_CUSTOM_FIRST + 1)

// HH_DISPLAY_SEARCH Command Related Structures and Constants

#define HH_FTS_DEFAULT_PROXIMITY (-1)

typedef struct tagHH_FTS_QUERY
{
    int cbStruct;            // Sizeof structure in bytes.
    BOOL fUniCodeStrings;    // TRUE if all strings are unicode.
    LPCTSTR pszSearchQuery;  // String containing the search query.
    LONG iProximity;         // Word proximity.
    BOOL fStemmedSearch;     // TRUE for StemmedSearch only.
    BOOL fTitleOnly;         // TRUE for Title search only.
    BOOL fExecute;           // TRUE to initiate the search.
    LPCTSTR pszWindow;       // Window to display in
} HH_FTS_QUERY;

// HH_WINTYPE Structure

typedef struct tagHH_WINTYPE {
    int     cbStruct;        // IN: size of this structure including all Information Types
    BOOL    fUniCodeStrings; // IN/OUT: TRUE if all strings are in UNICODE
    LPCTSTR pszType;         // IN/OUT: Name of a type of window
    DWORD   fsValidMembers;  // IN: Bit flag of valid members (HHWIN_PARAM_)
    DWORD   fsWinProperties; // IN/OUT: Properties/attributes of the window (HHWIN_)

    LPCTSTR pszCaption;      // IN/OUT: Window title
    DWORD   dwStyles;        // IN/OUT: Window styles
    DWORD   dwExStyles;      // IN/OUT: Extended Window styles
    RECT    rcWindowPos;     // IN: Starting position, OUT: current position
    int     nShowState;      // IN: show state (e.g., SW_SHOW)

    HWND  hwndHelp;          // OUT: window handle
    HWND  hwndCaller;        // OUT: who called this window

    HH_INFOTYPE* paInfoTypes;  // IN: Pointer to an array of Information Types

    // The following members are only valid if HHWIN_PROP_TRI_PANE is set

    HWND  hwndToolBar;      // OUT: toolbar window in tri-pane window
    HWND  hwndNavigation;   // OUT: navigation window in tri-pane window
    HWND  hwndHTML;         // OUT: window displaying HTML in tri-pane window
    int   iNavWidth;        // IN/OUT: width of navigation window
    RECT  rcHTML;           // OUT: HTML window coordinates

    LPCTSTR pszToc;         // IN: Location of the table of contents file
    LPCTSTR pszIndex;       // IN: Location of the index file
    LPCTSTR pszFile;        // IN: Default location of the html file
    LPCTSTR pszHome;        // IN/OUT: html file to display when Home button is clicked
    DWORD   fsToolBarFlags; // IN: flags controling the appearance of the toolbar
    BOOL    fNotExpanded;   // IN: TRUE/FALSE to contract or expand, OUT: current state
    int     curNavType;     // IN/OUT: UI to display in the navigational pane
    int     tabpos;         // IN/OUT: HHWIN_NAVTAB_TOP, HHWIN_NAVTAB_LEFT, or HHWIN_NAVTAB_BOTTOM
    int     idNotify;       // IN: ID to use for WM_NOTIFY messages
    BYTE    tabOrder[HH_MAX_TABS + 1];    // IN/OUT: tab order: Contents, Index, Search, History, Favorites, Reserved 1-5, Custom tabs
    int     cHistory;       // IN/OUT: number of history items to keep (default is 30)
    LPCTSTR pszJump1;       // Text for HHWIN_BUTTON_JUMP1
    LPCTSTR pszJump2;       // Text for HHWIN_BUTTON_JUMP2
    LPCTSTR pszUrlJump1;    // URL for HHWIN_BUTTON_JUMP1
    LPCTSTR pszUrlJump2;    // URL for HHWIN_BUTTON_JUMP2
    RECT    rcMinSize;      // Minimum size for window (ignored in version 1)
    int     cbInfoTypes;    // size of paInfoTypes;
    LPCTSTR pszCustomTabs;  // multiple zero-terminated strings
} HH_WINTYPE, *PHH_WINTYPE;

enum {
    HHACT_TAB_CONTENTS,
    HHACT_TAB_INDEX,
    HHACT_TAB_SEARCH,
    HHACT_TAB_HISTORY,
    HHACT_TAB_FAVORITES,

    HHACT_EXPAND,
    HHACT_CONTRACT,
    HHACT_BACK,
    HHACT_FORWARD,
    HHACT_STOP,
    HHACT_REFRESH,
    HHACT_HOME,
    HHACT_SYNC,
    HHACT_OPTIONS,
    HHACT_PRINT,
    HHACT_HIGHLIGHT,
    HHACT_CUSTOMIZE,
    HHACT_JUMP1,
    HHACT_JUMP2,
    HHACT_ZOOM,
    HHACT_TOC_NEXT,
    HHACT_TOC_PREV,
    HHACT_NOTES,

    HHACT_LAST_ENUM,
};

typedef struct tagHHNTRACK
{
    NMHDR   hdr;
    PCSTR   pszCurUrl;      // Multi-byte, null-terminated string
    int     idAction;       // HHACT_ value
    HH_WINTYPE* phhWinType; // Current window type structure
} HHNTRACK;

HWND
WINAPI
HtmlHelpA(
    HWND hwndCaller,
    LPCSTR pszFile,
    UINT uCommand,
    DWORD_PTR dwData
    );

HWND
WINAPI
HtmlHelpW(
    HWND hwndCaller,
    LPCWSTR pszFile,
    UINT uCommand,
    DWORD_PTR dwData
    );
#ifdef UNICODE
#define HtmlHelp  HtmlHelpW
#else
#define HtmlHelp  HtmlHelpA
#endif // !UNICODE

// Use the following for GetProcAddress to load from hhctrl.ocx

#define ATOM_HTMLHELP_API_ANSI    (LPTSTR)((DWORD)((WORD)(14)))
#define ATOM_HTMLHELP_API_UNICODE (LPTSTR)((DWORD)((WORD)(15)))

///////////////////////////////////////////////////////////////////////////////
//
// Global Control Properties. 
//
typedef enum tagHH_GPROPID
{
    HH_GPROPID_SINGLETHREAD=1,      // VARIANT_BOOL: True for single thread
    HH_GPROPID_TOOLBAR_MARGIN=2,    // long: Provides a left/right margin around the toolbar.
    HH_GPROPID_UI_LANGUAGE=3,       // long: LangId of the UI.
    HH_GPROPID_CURRENT_SUBSET=4,    // BSTR: Current subset.
    HH_GPROPID_CONTENT_LANGUAGE=5   // long: LandId for desired content.
} HH_GPROPID;

///////////////////////////////////////////////////////////////////////////////
//
// Global Property structure
//
#ifdef __oaidl_h__

#pragma pack(push, 8)

typedef struct tagHH_GLOBAL_PROPERTY
{
    HH_GPROPID  id;
    VARIANT     var;
} HH_GLOBAL_PROPERTY ;

#pragma pack(pop)
#endif

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __HTMLHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\HttpExt.h ===
/********
*
*  Copyright (c) 1995  Process Software Corporation
*
*  Copyright (c) 1995-1999  Microsoft Corporation
*
*
*  Module Name  : HttpExt.h
*
*  Abstract :
*
*     This module contains  the structure definitions and prototypes for the
*      HTTP Server Extension interface used to build ISAPI Applications
*
******************/

#ifndef _HTTPEXT_H_
#define _HTTPEXT_H_

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif


/************************************************************
 *   Manifest Constants
 ************************************************************/

#define   HSE_VERSION_MAJOR           7      // major version of this spec
#define   HSE_VERSION_MINOR           0      // minor version of this spec
#define   HSE_LOG_BUFFER_LEN         80
#define   HSE_MAX_EXT_DLL_NAME_LEN  256

#define   HSE_VERSION     MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR )

//
// the following are the status codes returned by the Extension DLL
//

#define   HSE_STATUS_SUCCESS                       1
#define   HSE_STATUS_SUCCESS_AND_KEEP_CONN         2
#define   HSE_STATUS_PENDING                       3
#define   HSE_STATUS_ERROR                         4

//
// The following are the values to request services with the
//   ServerSupportFunction().
//  Values from 0 to 1000 are reserved for future versions of the interface

#define   HSE_REQ_BASE                             0
#define   HSE_REQ_SEND_URL_REDIRECT_RESP           ( HSE_REQ_BASE + 1 )
#define   HSE_REQ_SEND_URL                         ( HSE_REQ_BASE + 2 )
#define   HSE_REQ_SEND_RESPONSE_HEADER             ( HSE_REQ_BASE + 3 )
#define   HSE_REQ_DONE_WITH_SESSION                ( HSE_REQ_BASE + 4 )
#define   HSE_REQ_END_RESERVED                     1000

//
//  These are Microsoft specific extensions
//

#define   HSE_REQ_MAP_URL_TO_PATH                  (HSE_REQ_END_RESERVED+1)
#define   HSE_REQ_GET_SSPI_INFO                    (HSE_REQ_END_RESERVED+2)
#define   HSE_APPEND_LOG_PARAMETER                 (HSE_REQ_END_RESERVED+3)
#define   HSE_REQ_IO_COMPLETION                    (HSE_REQ_END_RESERVED+5)
#define   HSE_REQ_TRANSMIT_FILE                    (HSE_REQ_END_RESERVED+6)
#define   HSE_REQ_REFRESH_ISAPI_ACL                (HSE_REQ_END_RESERVED+7)
#define   HSE_REQ_IS_KEEP_CONN                     (HSE_REQ_END_RESERVED+8)
#define   HSE_REQ_ASYNC_READ_CLIENT                (HSE_REQ_END_RESERVED+10)
#define   HSE_REQ_GET_IMPERSONATION_TOKEN          (HSE_REQ_END_RESERVED+11)
#define   HSE_REQ_MAP_URL_TO_PATH_EX               (HSE_REQ_END_RESERVED+12)
#define   HSE_REQ_ABORTIVE_CLOSE                   (HSE_REQ_END_RESERVED+14)
#define   HSE_REQ_GET_CERT_INFO_EX                 (HSE_REQ_END_RESERVED+15)
#define   HSE_REQ_SEND_RESPONSE_HEADER_EX          (HSE_REQ_END_RESERVED+16)
#define   HSE_REQ_CLOSE_CONNECTION                 (HSE_REQ_END_RESERVED+17)
#define   HSE_REQ_IS_CONNECTED                     (HSE_REQ_END_RESERVED+18)
#define   HSE_REQ_MAP_UNICODE_URL_TO_PATH          (HSE_REQ_END_RESERVED+23)
#define   HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX       (HSE_REQ_END_RESERVED+24)
#define   HSE_REQ_EXEC_UNICODE_URL                 (HSE_REQ_END_RESERVED+25)
#define   HSE_REQ_EXEC_URL                         (HSE_REQ_END_RESERVED+26)
#define   HSE_REQ_GET_EXEC_URL_STATUS              (HSE_REQ_END_RESERVED+27)
#define   HSE_REQ_SEND_CUSTOM_ERROR                (HSE_REQ_END_RESERVED+28)
#define   HSE_REQ_IS_IN_PROCESS                    (HSE_REQ_END_RESERVED+30)
#define   HSE_REQ_REPORT_UNHEALTHY                 (HSE_REQ_END_RESERVED+32)
#define   HSE_REQ_NORMALIZE_URL                    (HSE_REQ_END_RESERVED+33)
#define   HSE_REQ_VECTOR_SEND                      (HSE_REQ_END_RESERVED+37)
#define   HSE_REQ_GET_ANONYMOUS_TOKEN              (HSE_REQ_END_RESERVED+38)
#define   HSE_REQ_GET_CACHE_INVALIDATION_CALLBACK  (HSE_REQ_END_RESERVED+40)
#define   HSE_REQ_GET_UNICODE_ANONYMOUS_TOKEN      (HSE_REQ_END_RESERVED+41)
#define   HSE_REQ_GET_TRACE_INFO                   (HSE_REQ_END_RESERVED+42)
#define   HSE_REQ_SET_FLUSH_FLAG                   (HSE_REQ_END_RESERVED+43)
#define   HSE_REQ_GET_TRACE_INFO_EX                (HSE_REQ_END_RESERVED+44)
#define   HSE_REQ_RAISE_TRACE_EVENT                (HSE_REQ_END_RESERVED+45)
#define   HSE_REQ_GET_CONFIG_OBJECT                (HSE_REQ_END_RESERVED+46)
#define   HSE_REQ_GET_WORKER_PROCESS_SETTINGS      (HSE_REQ_END_RESERVED+47)
#define   HSE_REQ_GET_PROTOCOL_MANAGER_CUSTOM_INTERFACE_CALLBACK \
                                                   (HSE_REQ_END_RESERVED+48)
#define   HSE_REQ_CANCEL_IO                        (HSE_REQ_END_RESERVED+49)

//
//  Bit Flags for TerminateExtension
//
//    HSE_TERM_ADVISORY_UNLOAD - Server wants to unload the extension,
//          extension can return TRUE if OK, FALSE if the server should not
//          unload the extension
//
//    HSE_TERM_MUST_UNLOAD - Server indicating the extension is about to be
//          unloaded, the extension cannot refuse.
//

#define HSE_TERM_ADVISORY_UNLOAD                   0x00000001
#define HSE_TERM_MUST_UNLOAD                       0x00000002

//
// Flags for IO Functions, supported for IO Funcs.
//  TF means ServerSupportFunction( HSE_REQ_TRANSMIT_FILE)
//

# define HSE_IO_SYNC                      0x00000001   // for WriteClient
# define HSE_IO_ASYNC                     0x00000002   // for WriteClient/TF/EU
# define HSE_IO_DISCONNECT_AFTER_SEND     0x00000004   // for TF
# define HSE_IO_SEND_HEADERS              0x00000008   // for TF
# define HSE_IO_NODELAY                   0x00001000   // turn off nagling 

//
// These three are only used by VectorSend
//

# define HSE_IO_FINAL_SEND                0x00000010
# define HSE_IO_CACHE_RESPONSE            0x00000020
# define HSE_IO_TRY_SKIP_CUSTOM_ERRORS    0x00000040


/************************************************************
 *   Type Definitions
 ************************************************************/

typedef   LPVOID          HCONN;

//
// structure passed to GetExtensionVersion()
//

typedef struct   _HSE_VERSION_INFO {

    DWORD  dwExtensionVersion;
    CHAR   lpszExtensionDesc[HSE_MAX_EXT_DLL_NAME_LEN];

} HSE_VERSION_INFO, *LPHSE_VERSION_INFO;


//
// structure passed to extension procedure on a new request
//
typedef struct _EXTENSION_CONTROL_BLOCK {

    DWORD     cbSize;                 // size of this struct.
    DWORD     dwVersion;              // version info of this spec
    HCONN     ConnID;                 // Context number not to be modified!
    DWORD     dwHttpStatusCode;       // HTTP Status code
    CHAR      lpszLogData[HSE_LOG_BUFFER_LEN];// null terminated log info specific to this Extension DLL

    LPSTR     lpszMethod;             // REQUEST_METHOD
    LPSTR     lpszQueryString;        // QUERY_STRING
    LPSTR     lpszPathInfo;           // PATH_INFO
    LPSTR     lpszPathTranslated;     // PATH_TRANSLATED

    DWORD     cbTotalBytes;           // Total bytes indicated from client
    DWORD     cbAvailable;            // Available number of bytes
    LPBYTE    lpbData;                // pointer to cbAvailable bytes

    LPSTR     lpszContentType;        // Content type of client data

    BOOL (WINAPI * GetServerVariable) ( HCONN       hConn,
                                        LPSTR       lpszVariableName,
                                        LPVOID      lpvBuffer,
                                        LPDWORD     lpdwSize );

    BOOL (WINAPI * WriteClient)  ( HCONN      ConnID,
                                   LPVOID     Buffer,
                                   LPDWORD    lpdwBytes,
                                   DWORD      dwReserved );

    BOOL (WINAPI * ReadClient)  ( HCONN      ConnID,
                                  LPVOID     lpvBuffer,
                                  LPDWORD    lpdwSize );

    BOOL (WINAPI * ServerSupportFunction)( HCONN      hConn,
                                           DWORD      dwHSERequest,
                                           LPVOID     lpvBuffer,
                                           LPDWORD    lpdwSize,
                                           LPDWORD    lpdwDataType );

} EXTENSION_CONTROL_BLOCK, *LPEXTENSION_CONTROL_BLOCK;




//
//  Bit field of flags that can be on a virtual directory
//

#define HSE_URL_FLAGS_READ          0x00000001    // Allow for Read
#define HSE_URL_FLAGS_WRITE         0x00000002    // Allow for Write
#define HSE_URL_FLAGS_EXECUTE       0x00000004    // Allow for Execute
#define HSE_URL_FLAGS_SSL           0x00000008    // Require SSL
#define HSE_URL_FLAGS_DONT_CACHE    0x00000010    // Don't cache (vroot only)
#define HSE_URL_FLAGS_NEGO_CERT     0x00000020    // Allow client SSL certs
#define HSE_URL_FLAGS_REQUIRE_CERT  0x00000040    // Require client SSL certs
#define HSE_URL_FLAGS_MAP_CERT      0x00000080    // Map SSL cert to NT account
#define HSE_URL_FLAGS_SSL128        0x00000100    // Require 128 bit SSL
#define HSE_URL_FLAGS_SCRIPT        0x00000200    // Allow for Script execution

#define HSE_URL_FLAGS_MASK          0x000003ff

//
//  Structure for extended information on a URL mapping
//

typedef struct _HSE_URL_MAPEX_INFO {

    CHAR   lpszPath[MAX_PATH]; // Physical path root mapped to
    DWORD  dwFlags;            // Flags associated with this URL path
    DWORD  cchMatchingPath;    // Number of matching characters in physical path
    DWORD  cchMatchingURL;     // Number of matching characters in URL

    DWORD  dwReserved1;
    DWORD  dwReserved2;

} HSE_URL_MAPEX_INFO, * LPHSE_URL_MAPEX_INFO;


typedef struct _HSE_UNICODE_URL_MAPEX_INFO {

    WCHAR  lpszPath[MAX_PATH]; // Physical path root mapped to
    DWORD  dwFlags;            // Flags associated with this URL path
    DWORD  cchMatchingPath;    // Number of matching characters in physical path
    DWORD  cchMatchingURL;     // Number of matching characters in URL

} HSE_UNICODE_URL_MAPEX_INFO, * LPHSE_UNICODE_URL_MAPEX_INFO;


//
// PFN_HSE_IO_COMPLETION - callback function for the Async I/O Completion.
//

typedef VOID
  (WINAPI * PFN_HSE_IO_COMPLETION)(
                                   IN EXTENSION_CONTROL_BLOCK * pECB,
                                   IN PVOID    pContext,
                                   IN DWORD    cbIO,
                                   IN DWORD    dwError
                                   );



//
// HSE_TF_INFO defines the type for HTTP SERVER EXTENSION support for
//  ISAPI applications to send files using TransmitFile.
// A pointer to this object should be used with ServerSupportFunction()
//  for HSE_REQ_TRANSMIT_FILE.
//

typedef struct _HSE_TF_INFO  {

    //
    // callback and context information
    // the callback function will be called when IO is completed.
    // the context specified will be used during such callback.
    //
    // These values (if non-NULL) will override the one set by calling
    //  ServerSupportFunction() with HSE_REQ_IO_COMPLETION
    //
    PFN_HSE_IO_COMPLETION   pfnHseIO;
    PVOID  pContext;

    // file should have been opened with FILE_FLAG_SEQUENTIAL_SCAN
    HANDLE hFile;

    //
    // HTTP header and status code
    // These fields are used only if HSE_IO_SEND_HEADERS is present in dwFlags
    //

    LPCSTR pszStatusCode; // HTTP Status Code  eg: "200 OK"

    DWORD  BytesToWrite;  // special value of "0" means write entire file.
    DWORD  Offset;        // offset value within the file to start from

    PVOID  pHead;         // Head buffer to be sent before file data
    DWORD  HeadLength;    // header length
    PVOID  pTail;         // Tail buffer to be sent after file data
    DWORD  TailLength;    // tail length

    DWORD  dwFlags;       // includes HSE_IO_DISCONNECT_AFTER_SEND, ...

} HSE_TF_INFO, * LPHSE_TF_INFO;


//
// HSE_SEND_HEADER_EX_INFO allows an ISAPI application to send headers
// and specify keep-alive behavior in the same call.
//

typedef struct _HSE_SEND_HEADER_EX_INFO  {

    //
    // HTTP status code and header
    //

    LPCSTR  pszStatus;  // HTTP status code  eg: "200 OK"
    LPCSTR  pszHeader;  // HTTP header

    DWORD   cchStatus;  // number of characters in status code
    DWORD   cchHeader;  // number of characters in header

    BOOL    fKeepConn;  // keep client connection alive?

} HSE_SEND_HEADER_EX_INFO, * LPHSE_SEND_HEADER_EX_INFO;

//
// Flags for use with HSE_REQ_EXEC_URL
//

#define HSE_EXEC_URL_NO_HEADERS                     0x02
#define HSE_EXEC_URL_IGNORE_CURRENT_INTERCEPTOR     0x04
#define HSE_EXEC_URL_IGNORE_VALIDATION_AND_RANGE    0x10
#define HSE_EXEC_URL_DISABLE_CUSTOM_ERROR           0x20
#define HSE_EXEC_URL_SSI_CMD                        0x40
#define HSE_EXEC_URL_HTTP_CACHE_ELIGIBLE            0x80
          
//
// HSE_EXEC_URL_USER_INFO provides a new user content for use with
// HSE_REQ_EXEC_URL
//

typedef struct _HSE_EXEC_URL_USER_INFO  {

    HANDLE hImpersonationToken;
    LPSTR pszCustomUserName;
    LPSTR pszCustomAuthType;

} HSE_EXEC_URL_USER_INFO, * LPHSE_EXEC_URL_USER_INFO;

//
// HSE_EXEC_URL_ENTITY_INFO describes the entity body to be provided
// to the executed request using HSE_REQ_EXEC_URL
//

typedef struct _HSE_EXEC_URL_ENTITY_INFO  {
    
    DWORD cbAvailable;
    LPVOID lpbData;
    
} HSE_EXEC_URL_ENTITY_INFO, * LPHSE_EXEC_URL_ENTITY_INFO;

//
// HSE_EXEC_URL_STATUS provides the status of the last HSE_REQ_EXEC_URL 
// call
//

typedef struct _HSE_EXEC_URL_STATUS  {

    USHORT uHttpStatusCode;
    USHORT uHttpSubStatus;
    DWORD dwWin32Error;

} HSE_EXEC_URL_STATUS, * LPHSE_EXEC_URL_STATUS;

//
// HSE_EXEC_URL_INFO provides a description of the request to execute
// on behalf of the ISAPI.  
//

typedef struct _HSE_EXEC_URL_INFO  {

    LPSTR pszUrl;                       // URL to execute
    LPSTR pszMethod;                    // Method
    LPSTR pszChildHeaders;              // Request headers for child
    LPHSE_EXEC_URL_USER_INFO pUserInfo; // User for new request
    LPHSE_EXEC_URL_ENTITY_INFO pEntity; // Entity body for new request
    DWORD dwExecUrlFlags;               // Flags

} HSE_EXEC_URL_INFO, * LPHSE_EXEC_URL_INFO;

//
// HSE_EXEC_UNICODE_URL_USER_INFO provides a new user content for use with
// HSE_REQ_EXEC_UNICODE_URL
//

typedef struct _HSE_EXEC_UNICODE_URL_USER_INFO  {

    HANDLE hImpersonationToken;
    LPWSTR pszCustomUserName;
    LPSTR  pszCustomAuthType;

} HSE_EXEC_UNICODE_URL_USER_INFO, * LPHSE_EXEC_UNICODE_URL_USER_INFO;

//
// HSE_EXEC_UNICODE_URL_INFO provides a description of the request to execute
// on behalf of the ISAPI.  
//

typedef struct _HSE_EXEC_UNICODE_URL_INFO  {

    LPWSTR pszUrl;                              // URL to execute
    LPSTR  pszMethod;                           // Method
    LPSTR  pszChildHeaders;                     // Request headers for child
    LPHSE_EXEC_UNICODE_URL_USER_INFO pUserInfo; // User for new request
    LPHSE_EXEC_URL_ENTITY_INFO pEntity;         // Entity body for new request
    DWORD  dwExecUrlFlags;                      // Flags

} HSE_EXEC_UNICODE_URL_INFO, * LPHSE_EXEC_UNICODE_URL_INFO;

//
// HSE_CUSTOM_ERROR_INFO structured used in HSE_REQ_SEND_CUSTOM_ERROR
// 

typedef struct _HSE_CUSTOM_ERROR_INFO  {

    CHAR * pszStatus;
    USHORT uHttpSubError;
    BOOL fAsync;

} HSE_CUSTOM_ERROR_INFO, * LPHSE_CUSTOM_ERROR_INFO;


//
// structures for the HSE_REQ_VECTOR_SEND ServerSupportFunction
//


//
// Types of vector-elements currently supported
//
#define HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER       0
#define HSE_VECTOR_ELEMENT_TYPE_FILE_HANDLE         1

//
// element of the vector
//

typedef struct _HSE_VECTOR_ELEMENT
{
    DWORD ElementType;  // Type of element (buffer/file/fragment etc)

    PVOID pvContext;    // The context representing the element to be sent

    ULONGLONG cbOffset; // Offset from the start of hFile

    ULONGLONG cbSize;   // Number of bytes to send
} HSE_VECTOR_ELEMENT, *LPHSE_VECTOR_ELEMENT;

//
// The whole vector to be passed to the ServerSupportFunction
//

typedef struct _HSE_RESPONSE_VECTOR
{
    DWORD dwFlags;                          // combination of HSE_IO_* flags

    LPSTR pszStatus;                        // Status line to send like "200 OK"
    LPSTR pszHeaders;                       // Headers to send

    DWORD nElementCount;                    // Number of HSE_VECTOR_ELEMENT's
    LPHSE_VECTOR_ELEMENT lpElementArray;    // Pointer to those elements
} HSE_RESPONSE_VECTOR, *LPHSE_RESPONSE_VECTOR;


typedef HRESULT
  (WINAPI * PFN_HSE_CACHE_INVALIDATION_CALLBACK)(
        WCHAR *pszUrl);


#if(_WIN32_WINNT >= 0x400)
#include <wincrypt.h>
//
//      CERT_CONTEXT_EX is passed as an an argument to 
//  ServerSupportFunction( HSE_REQ_GET_CERT_INFO_EX )
//

typedef struct _CERT_CONTEXT_EX {
    CERT_CONTEXT    CertContext;
    DWORD           cbAllocated;
    DWORD           dwCertificateFlags;
} CERT_CONTEXT_EX;
#endif



//
// HSE_TRACE_INFO structure used to get debug trace info
// from core web server
//

typedef struct _HSE_TRACE_INFO
{

    //
    // Recommendation from IIS to trace the request
    //

    BOOL        fTraceRequest; 
    
    //
    // The unique trace context ID for the current request
    //

    BYTE        TraceContextId[16];
    
    //
    // Reserved for future use
    //

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    
} HSE_TRACE_INFO, *LPHSE_TRACE_INFO;


//
// HSE_REQ_GET_TRACE_INFO_EX SSF uses 
// the HTTP_TRACE_CONFIGURATION structure defined in httptrace.h
//

//
// HSE_REQ_RAISE_TRACE_EVENT SSF uses 
// the HTTP_TRACE_EVENT structure defined in httptrace.h
//

//
// SSF_REQ_GET_WORKER_PROCESS_SETTINGS returns IWpfSettings pointer.
// IWpfSettings is defined in the wpframework.h
//

//
// SSF_REQ_GET_CONFIG_OBJECT returns INativeConfigurationSystem pointer.
// INativeConfigurationSystem is defined in the nativerd.h
//

//
// HSE_GET_PROTOCOL_MANAGER_CUSTOM_INTERFACE_CALLBACK returns pointer to
// PFN_HSE_GET_PROTOCOL_MANAGER_CUSTOM_INTERFACE_CALLBACK function type
//

typedef HRESULT
  (WINAPI * PFN_HSE_GET_PROTOCOL_MANAGER_CUSTOM_INTERFACE_CALLBACK)(
                            LPCWSTR       pszProtocolManagerDll,
                            LPCWSTR       pszProtocolManagerDllInitFunction,
                            DWORD         dwCustomInterfaceId,
                            PVOID*        ppCustomInterface );


//
// Flags for determining application type
//

#define HSE_APP_FLAG_IN_PROCESS   0
#define HSE_APP_FLAG_ISOLATED_OOP 1
#define HSE_APP_FLAG_POOLED_OOP   2


/************************************************************
 *   Function Prototypes 
 *   o  for functions exported from the ISAPI Application DLL
 ************************************************************/

BOOL  WINAPI   GetExtensionVersion( __out HSE_VERSION_INFO  *pVer );
DWORD WINAPI   HttpExtensionProc( __in EXTENSION_CONTROL_BLOCK *pECB );
BOOL  WINAPI   TerminateExtension( DWORD dwFlags );

// the following type declarations is for use in the server side

typedef BOOL
    (WINAPI * PFN_GETEXTENSIONVERSION)( HSE_VERSION_INFO  *pVer );

typedef DWORD 
    (WINAPI * PFN_HTTPEXTENSIONPROC )( EXTENSION_CONTROL_BLOCK * pECB );

typedef BOOL  (WINAPI * PFN_TERMINATEEXTENSION )( DWORD dwFlags );


#ifdef __cplusplus
}
#endif


#endif  // end definition _HTTPEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\HttpFilt.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    httpfilt.h

Abstract:

    This module contains the Microsoft HTTP filter extension info

Revision History:

--*/

#ifndef _HTTPFILT_H_
#define _HTTPFILT_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Define ULONG_PTR if necessary
//

#if !defined(__midl) && defined(_X86_) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif

//
// The INT_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. UINT_PTR is
// the unsigned variation.
//
// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.
//
#if ( 501 < __midl )

    typedef unsigned __int3264 ULONG_PTR, *PULONG_PTR;

#else  // midl64
// old midl and C++ compiler

#if defined(_WIN64)
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
#else
    typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;
#endif
#endif // midl64


//
//  Current version of the filter spec is 7.0
//

#define HTTP_FILTER_REVISION    MAKELONG( 0, 7 )

#define SF_MAX_USERNAME         (256+1)
#define SF_MAX_PASSWORD         (256+1)
#define SF_MAX_AUTH_TYPE        (32+1)

#define SF_MAX_FILTER_DESC_LEN  (256+1)


//
//  These values can be used with the pfnSFCallback function supplied in
//  the filter context structure
//

enum SF_REQ_TYPE
{
    //
    //  Sends a complete HTTP server response header including
    //  the status, server version, message time and MIME version.
    //
    //  Server extensions should append other information at the end,
    //  such as Content-type, Content-length etc followed by an extra
    //  '\r\n'.
    //
    //  pData - Zero terminated string pointing to optional
    //      status string (i.e., "401 Access Denied") or NULL for
    //      the default response of "200 OK".
    //
    //  ul1 - Zero terminated string pointing to optional data to be
    //      appended and set with the header.  If NULL, the header will
    //      be terminated with an empty line.
    //

    SF_REQ_SEND_RESPONSE_HEADER,

    //
    //  If the server denies the HTTP request, add the specified headers
    //  to the server error response.
    //
    //  This allows an authentication filter to advertise its services
    //  w/o filtering every request.  Generally the headers will be
    //  WWW-Authenticate headers with custom authentication schemes but
    //  no restriction is placed on what headers may be specified.
    //
    //  pData - Zero terminated string pointing to one or more header lines
    //      with terminating '\r\n'.
    //

    SF_REQ_ADD_HEADERS_ON_DENIAL,

    //
    //  Only used by raw data filters that return SF_STATUS_READ_NEXT
    //
    //  ul1 - size in bytes for the next read
    //

    SF_REQ_SET_NEXT_READ_SIZE,

    //
    //  Used to indicate this request is a proxy request
    //
    //  ul1 - The proxy flags to set
    //      0x00000001 - This is a HTTP proxy request
    //
    //

    SF_REQ_SET_PROXY_INFO,

    //
    //  Returns the connection ID contained in the ConnID field of an
    //  ISAPI Application's Extension Control Block.  This value can be used
    //  as a key to cooridinate shared data between Filters and Applications.
    //
    //  pData - Pointer to DWORD that receives the connection ID.
    //

    SF_REQ_GET_CONNID,

    //
    // Used to set a SSPI security context + impersonation token
    // derived from a client certificate.
    //
    // pData - certificate info ( PHTTP_FILTER_CERTIFICATE_INFO )
    // ul1 - CtxtHandle*
    // ul2 - impersonation handle
    //

    SF_REQ_SET_CERTIFICATE_INFO,

    //
    // Used to get an IIS property
    // as defined in SF_PROPERTY_IIS
    //
    // ul1 - Property ID
    //

    SF_REQ_GET_PROPERTY,

    //
    // Used to normalize an URL
    //
    // pData - URL to normalize
    //

    SF_REQ_NORMALIZE_URL,

    //
    // Disable Notifications
    //
    // ul1 - notifications to disable
    //

    SF_REQ_DISABLE_NOTIFICATIONS,

} ;


enum SF_PROPERTY_IIS
{
    SF_PROPERTY_SSL_CTXT,
    SF_PROPERTY_INSTANCE_NUM_ID
} ;


//
//  These values are returned by the filter entry point when a new request is
//  received indicating their interest in this particular request
//

enum SF_STATUS_TYPE
{
    //
    //  The filter has handled the HTTP request.  The server should disconnect
    //  the session.
    //

    SF_STATUS_REQ_FINISHED = 0x8000000,

    //
    //  Same as SF_STATUS_FINISHED except the server should keep the TCP
    //  session open if the option was negotiated
    //

    SF_STATUS_REQ_FINISHED_KEEP_CONN,

    //
    //  The next filter in the notification chain should be called
    //

    SF_STATUS_REQ_NEXT_NOTIFICATION,

    //
    //  This filter handled the notification.  No other handles should be
    //  called for this particular notification type
    //

    SF_STATUS_REQ_HANDLED_NOTIFICATION,

    //
    //  An error occurred.  The server should use GetLastError() and indicate
    //  the error to the client
    //

    SF_STATUS_REQ_ERROR,

    //
    //  The filter is an opaque stream filter and we're negotiating the
    //  session parameters.  Only valid for raw read notification.
    //

    SF_STATUS_REQ_READ_NEXT
};

//
//  pvNotification points to this structure for all request notification types
//

typedef struct _HTTP_FILTER_CONTEXT
{
    DWORD          cbSize;

    //
    //  This is the structure revision level.
    //

    DWORD          Revision;

    //
    //  Private context information for the server.
    //

    PVOID          ServerContext;
    DWORD          ulReserved;

    //
    //  TRUE if this request is coming over a secure port
    //

    BOOL           fIsSecurePort;

    //
    //  A context that can be used by the filter
    //

    PVOID          pFilterContext;

    //
    //  Server callbacks
    //

    BOOL (WINAPI * GetServerVariable) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszVariableName,
        LPVOID                        lpvBuffer,
        LPDWORD                       lpdwSize
        );

    BOOL (WINAPI * AddResponseHeaders) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszHeaders,
        DWORD                         dwReserved
        );

    BOOL (WINAPI * WriteClient)  (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPVOID                        Buffer,
        LPDWORD                       lpdwBytes,
        DWORD                         dwReserved
        );

    VOID * (WINAPI * AllocMem) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        DWORD                         cbSize,
        DWORD                         dwReserved
        );

    BOOL (WINAPI * ServerSupportFunction) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        enum SF_REQ_TYPE              sfReq,
        PVOID                         pData,
        ULONG_PTR                     ul1,
        ULONG_PTR                     ul2
        );
} HTTP_FILTER_CONTEXT, *PHTTP_FILTER_CONTEXT;

//
//  This structure is the notification info for the read and send raw data
//  notification types
//

typedef struct _HTTP_FILTER_RAW_DATA
{
    //
    //  This is a pointer to the data for the filter to process.
    //

    PVOID         pvInData;
    DWORD         cbInData;       // Number of valid data bytes
    DWORD         cbInBuffer;     // Total size of buffer

    DWORD         dwReserved;

} HTTP_FILTER_RAW_DATA, *PHTTP_FILTER_RAW_DATA;

//
//  This structure is the notification info for when the server is about to
//  process the client headers
//

typedef struct _HTTP_FILTER_PREPROC_HEADERS
{
    //
    //  For SF_NOTIFY_PREPROC_HEADERS, retrieves the specified header value.
    //  Header names should include the trailing ':'.  The special values
    //  'method', 'url' and 'version' can be used to retrieve the individual
    //  portions of the request line
    //

    BOOL (WINAPI * GetHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPVOID                        lpvBuffer,
        LPDWORD                       lpdwSize
        );

    //
    //  Replaces this header value to the specified value.  To delete a header,
    //  specified a value of '\0'.
    //

    BOOL (WINAPI * SetHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPSTR                         lpszValue
        );

    //
    //  Adds the specified header and value
    //

    BOOL (WINAPI * AddHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPSTR                         lpszValue
        );

    DWORD HttpStatus;               // New in 4.0, status for SEND_RESPONSE
    DWORD dwReserved;               // New in 4.0

} HTTP_FILTER_PREPROC_HEADERS, *PHTTP_FILTER_PREPROC_HEADERS;

typedef HTTP_FILTER_PREPROC_HEADERS HTTP_FILTER_SEND_RESPONSE;
typedef HTTP_FILTER_PREPROC_HEADERS *PHTTP_FILTER_SEND_RESPONSE;

//
//  Authentication information for this request.
//

typedef struct _HTTP_FILTER_AUTHENT
{
    //
    //  Pointer to username and password, empty strings for the anonymous user
    //
    //  Client's can overwrite these buffers which are guaranteed to be at
    //  least SF_MAX_USERNAME and SF_MAX_PASSWORD bytes large.
    //

    CHAR * pszUser;
    DWORD  cbUserBuff;

    CHAR * pszPassword;
    DWORD  cbPasswordBuff;

} HTTP_FILTER_AUTHENT, *PHTTP_FILTER_AUTHENT;



//
//  Indicates the server is going to use the specific physical mapping for
//  the specified URL.  Filters can modify the physical path in place.
//

typedef struct _HTTP_FILTER_URL_MAP
{
    const CHAR * pszURL;

    CHAR *       pszPhysicalPath;
    DWORD        cbPathBuff;

} HTTP_FILTER_URL_MAP, *PHTTP_FILTER_URL_MAP;

//
//  Indicates the server is going to use the specific physical mapping for
//  the specified URL.  Filters can modify the physical path in place.
//
//  Additional members beyond those from HTTP_FILTER_URL_MAP are
//  informational.
//

typedef struct _HTTP_FILTER_URL_MAP_EX
{
    const CHAR * pszURL;

    CHAR *       pszPhysicalPath;
    DWORD        cbPathBuff;

    //
    // The AccessPerm metabase property that applies to this URL
    //
    DWORD        dwFlags;

    //
    // Number of matching characters in physical path corresponding
    // to the metabase node that applies.
    //
    DWORD        cchMatchingPath;

    //
    // Number of matching characters in the URL corresponding
    // to the metabase node that applies.
    //
    DWORD        cchMatchingURL;

    //
    // The physical path of the dll or exe that to which this
    // URL is script mapped.  This member will be NULL if no
    // script map applies.
    //
    const CHAR * pszScriptMapEntry;

} HTTP_FILTER_URL_MAP_EX, *PHTTP_FILTER_URL_MAP_EX;


//
//  Bitfield indicating the requested resource has been denied by the server due
//  to a logon failure, an ACL on a resource, an ISAPI Filter or an
//  ISAPI Application/CGI Application.
//
//  SF_DENIED_BY_CONFIG can appear with SF_DENIED_LOGON if the server
//  configuration did not allow the user to logon.
//

#define SF_DENIED_LOGON             0x00000001
#define SF_DENIED_RESOURCE          0x00000002
#define SF_DENIED_FILTER            0x00000004
#define SF_DENIED_APPLICATION       0x00000008

#define SF_DENIED_BY_CONFIG         0x00010000

typedef struct _HTTP_FILTER_ACCESS_DENIED
{
    const CHAR * pszURL;            // Requesting URL
    const CHAR * pszPhysicalPath;   // Physical path of resource
    DWORD        dwReason;          // Bitfield of SF_DENIED flags

} HTTP_FILTER_ACCESS_DENIED, *PHTTP_FILTER_ACCESS_DENIED;


//
//  The log information about to be written to the server log file.  The
//  string pointers can be replaced but the memory must remain valid until
//  the next notification
//

typedef struct _HTTP_FILTER_LOG
{
    const CHAR * pszClientHostName;
    const CHAR * pszClientUserName;
    const CHAR * pszServerName;
    const CHAR * pszOperation;
    const CHAR * pszTarget;
    const CHAR * pszParameters;

    DWORD  dwHttpStatus;
    DWORD  dwWin32Status;

    DWORD  dwBytesSent;             // IIS 4.0 and later
    DWORD  dwBytesRecvd;            // IIS 4.0 and later
    DWORD  msTimeForProcessing;     // IIS 4.0 and later

} HTTP_FILTER_LOG, *PHTTP_FILTER_LOG;

//
// Called once the client request has been authenticated.
//

typedef struct _HTTP_FILTER_AUTH_COMPLETE_INFO
{
    //
    //  For SF_NOTIFY_AUTH_COMPLETE, retrieves the specified header value.
    //  Header names should include the trailing ':'.  The special values
    //  'method', 'url' and 'version' can be used to retrieve the individual
    //  portions of the request line
    //

    BOOL (WINAPI * GetHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPVOID                        lpvBuffer,
        LPDWORD                       lpdwSize
        );

    //
    //  Replaces this header value to the specified value.  To delete a header,
    //  specified a value of '\0'.
    //

    BOOL (WINAPI * SetHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPSTR                         lpszValue
        );

    //
    //  Adds the specified header and value
    //

    BOOL (WINAPI * AddHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPSTR                         lpszValue
        );
        
    //
    //  Get the authenticated user impersonation token
    //
    
    BOOL (WINAPI * GetUserToken) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        HANDLE *                      phToken
        );
    
    //
    //  Status code to use when sending response
    //
    
    DWORD HttpStatus;               
    
    //
    //  Determines whether to reset auth if URL changed
    //
    
    BOOL  fResetAuth;             
    
    //
    //  Reserved
    //
    
    DWORD dwReserved;            
    
} HTTP_FILTER_AUTH_COMPLETE_INFO, *PHTTP_FILTER_AUTH_COMPLETE_INFO;

//
//  Notification Flags
//
//  SF_NOTIFY_SECURE_PORT
//  SF_NOTIFY_NONSECURE_PORT
//
//      Indicates whether the application wants to be notified for transactions
//      that are happenning on the server port(s) that support data encryption
//      (such as PCT and SSL), on only the non-secure port(s) or both.
//
//  SF_NOTIFY_READ_RAW_DATA
//
//      Applications are notified after the server reads a block of memory
//      from the client but before the server does any processing on the
//      block.  The data block may contain HTTP headers and entity data.
//
//
//

#define SF_NOTIFY_SECURE_PORT               0x00000001
#define SF_NOTIFY_NONSECURE_PORT            0x00000002

#define SF_NOTIFY_READ_RAW_DATA             0x00008000
#define SF_NOTIFY_PREPROC_HEADERS           0x00004000
#define SF_NOTIFY_AUTHENTICATION            0x00002000
#define SF_NOTIFY_URL_MAP                   0x00001000
#define SF_NOTIFY_ACCESS_DENIED             0x00000800
#define SF_NOTIFY_SEND_RESPONSE             0x00000040
#define SF_NOTIFY_SEND_RAW_DATA             0x00000400
#define SF_NOTIFY_LOG                       0x00000200
#define SF_NOTIFY_END_OF_REQUEST            0x00000080
#define SF_NOTIFY_END_OF_NET_SESSION        0x00000100
#define SF_NOTIFY_AUTH_COMPLETE             0x04000000

//
//  Filter ordering flags
//
//  Filters will tend to be notified by their specified
//  ordering.  For ties, notification order is determined by load order.
//
//  SF_NOTIFY_ORDER_HIGH - Authentication or data transformation filters
//  SF_NOTIFY_ORDER_MEDIUM
//  SF_NOTIFY_ORDER_LOW  - Logging filters that want the results of any other
//                      filters might specify this order.
//

#define SF_NOTIFY_ORDER_HIGH               0x00080000
#define SF_NOTIFY_ORDER_MEDIUM             0x00040000
#define SF_NOTIFY_ORDER_LOW                0x00020000
#define SF_NOTIFY_ORDER_DEFAULT            SF_NOTIFY_ORDER_LOW

#define SF_NOTIFY_ORDER_MASK               (SF_NOTIFY_ORDER_HIGH   |    \
                                            SF_NOTIFY_ORDER_MEDIUM |    \
                                            SF_NOTIFY_ORDER_LOW)

//
//  Filter version information, passed to GetFilterVersion
//

typedef struct _HTTP_FILTER_VERSION
{
    //
    //  Version of the spec the server is using
    //

    DWORD  dwServerFilterVersion;

    //
    //  Fields specified by the client
    //

    DWORD  dwFilterVersion;
    CHAR   lpszFilterDesc[SF_MAX_FILTER_DESC_LEN];
    DWORD  dwFlags;


} HTTP_FILTER_VERSION, *PHTTP_FILTER_VERSION;



//
//  A filter DLL's entry point looks like this.  The return code should be
//  an SF_STATUS_TYPE
//
//  NotificationType - Type of notification
//  pvNotification - Pointer to notification specific data
//

DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvNotification
    );

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    );

BOOL
WINAPI
TerminateFilter(
    DWORD dwFlags
    );


#ifdef __cplusplus
}
#endif

#endif //_HTTPFILT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\httpserv.h ===
#ifndef _HTTPSERV_H_
#define _HTTPSERV_H_

#if (!defined(_WIN64) && !defined(WIN32))
#error httpserv.h is only supported on WIN32 or WIN64 platforms
#endif

#include <ahadmin.h>
#include <http.h>

//
// Request triggered notifications
//

//
// Request deterministic notifications
//

// request is beginning
#define RQ_BEGIN_REQUEST               0x00000001
// request is being authenticated
#define RQ_AUTHENTICATE_REQUEST        0x00000002
// request is being authorized
#define RQ_AUTHORIZE_REQUEST           0x00000004
// satisfy request from cache
#define RQ_RESOLVE_REQUEST_CACHE       0x00000008
// map handler for request
#define RQ_MAP_REQUEST_HANDLER         0x00000010
// acquire request state
#define RQ_ACQUIRE_REQUEST_STATE       0x00000020
// pre-execute handler
#define RQ_PRE_EXECUTE_REQUEST_HANDLER 0x00000040 
// execute handler
#define RQ_EXECUTE_REQUEST_HANDLER     0x00000080
// release request state
#define RQ_RELEASE_REQUEST_STATE       0x00000100
// update cache
#define RQ_UPDATE_REQUEST_CACHE        0x00000200
// log request
#define RQ_LOG_REQUEST                 0x00000400
// end request
#define RQ_END_REQUEST                 0x00000800

//
// Request non-deterministic notifications
//

// custom notification
#define RQ_CUSTOM_NOTIFICATION         0x10000000
// send response
#define RQ_SEND_RESPONSE               0x20000000
// read entity
#define RQ_READ_ENTITY                 0x40000000
// map a url to a physical path
#define RQ_MAP_PATH                    0x80000000

// 
// Global notifications
//

// stop accepting new requests
#define GL_STOP_LISTENING               0x00000002
// cache cleanup before termination
#define GL_CACHE_CLEANUP                0x00000004
// cache operation
#define GL_CACHE_OPERATION              0x00000010
// health check
#define GL_HEALTH_CHECK                 0x00000020
// configuration changed
#define GL_CONFIGURATION_CHANGE         0x00000040
// file changed
#define GL_FILE_CHANGE                  0x00000080
// before request pipeline has started
#define GL_PRE_BEGIN_REQUEST            0x00000100
// application start
#define GL_APPLICATION_START            0x00000200
// resolve modules for an application
#define GL_APPLICATION_RESOLVE_MODULES  0x00000400
// application end
#define GL_APPLICATION_STOP             0x00000800
// RSCA query
#define GL_RSCA_QUERY                   0x00001000
// trace event was raised
#define GL_TRACE_EVENT                  0x00002000
// custom notification
#define GL_CUSTOM_NOTIFICATION          0x00004000
// thread cleanup notification
#define GL_THREAD_CLEANUP               0x00008000

//
// Request notification return status
//

typedef enum REQUEST_NOTIFICATION_STATUS
{
    RQ_NOTIFICATION_CONTINUE,                   // continue processing
                                                // for notification
    RQ_NOTIFICATION_PENDING,                    // suspend processing
                                                // for notification
    RQ_NOTIFICATION_FINISH_REQUEST              // finish request
                                                // processing
};

//
// Out of band return codes
//

typedef enum GLOBAL_NOTIFICATION_STATUS
{
    GL_NOTIFICATION_CONTINUE,                  // continue processing
                                               // for notification
    GL_NOTIFICATION_HANDLED                    // finish processing for
                                               // notification
};

// 
// Priority class aliases
//

#define PRIORITY_ALIAS_FIRST              L"FIRST"
#define PRIORITY_ALIAS_HIGH               L"HIGH"
#define PRIORITY_ALIAS_MEDIUM             L"MEDIUM"
#define PRIORITY_ALIAS_LOW                L"LOW"
#define PRIORITY_ALIAS_LAST               L"LAST"

//
// Cache operations
//

typedef enum CACHE_OPERATION
{
    CACHE_OPERATION_RETRIEVE,
    CACHE_OPERATION_ADD,
    CACHE_OPERATION_DELETE,
    CACHE_OPERATION_FLUSH_PREFIX,
    CACHE_OPERATION_ENUM
};

//
// Module identifier
//

typedef VOID*            HTTP_MODULE_ID;

//
// Flags for IHttpContext->CloneContext()
//

#define CLONE_FLAG_BASICS              0x01 
#define CLONE_FLAG_HEADERS             0x02 
#define CLONE_FLAG_ENTITY              0x04 
#define CLONE_FLAG_NO_PRECONDITION     0x08 
#define CLONE_FLAG_NO_DAV              0x10

//
// Flags for IHttpContext->ExecuteRequest()
//

#define EXECUTE_FLAG_NO_HEADERS                     0x01
#define EXECUTE_FLAG_IGNORE_CURRENT_INTERCEPTOR     0x02
#define EXECUTE_FLAG_IGNORE_APPPOOL                 0x04
#define EXECUTE_FLAG_DISABLE_CUSTOM_ERROR           0x08
#define EXECUTE_FLAG_SAME_URL                       0x10
// do not flush the child response but copy it back to the parent
#define EXECUTE_FLAG_BUFFER_RESPONSE                0x20
// child response is still eligible for http.sys caching
#define EXECUTE_FLAG_HTTP_CACHE_ELIGIBLE            0x40


//
// forward declarations
//
struct HTTP_TRACE_CONFIGURATION;
struct HTTP_TRACE_EVENT;

class  IWpfSettings;
class  IHttpTraceContext;

//
// Module-specific context descriptor
//
class IHttpStoredContext
{
 public:
    virtual
    VOID
    CleanupStoredContext(
        VOID
    ) = 0;
};

//
// Context container
//
class IHttpModuleContextContainer
{
 public:
    virtual
    IHttpStoredContext *
    GetModuleContext(
        IN HTTP_MODULE_ID       moduleId
    ) = 0;

    virtual
    HRESULT
    SetModuleContext(
        IN IHttpStoredContext * ppStoredContext,
        IN HTTP_MODULE_ID       moduleId
    ) = 0;  
};

//
// Dispensed context container
//
class IDispensedHttpModuleContextContainer : public IHttpModuleContextContainer
{
public:
    virtual
    VOID
    ReleaseContainer(
        VOID
    ) = 0;
};

//
// Performance counter descriptor
//
class IHttpPerfCounterInfo
{
 public:
    virtual
    VOID
    IncrementCounter(
        DWORD               dwCounterIndex,
        DWORD               dwValue = 1
    ) = 0;

    virtual
    VOID
    DecrementCounter(
        DWORD               dwCounterIndex,
        DWORD               dwValue = 1
    ) = 0;
};

//
// Application descriptor
//
class IHttpApplication
{
 public:
    virtual
    PCWSTR
    GetApplicationPhysicalPath(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetApplicationId(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetAppConfigPath(
        VOID
    ) const = 0;

    virtual
    IHttpModuleContextContainer *
    GetModuleContextContainer(
        VOID
    ) = 0;
};

class IScriptMapInfo;

// 
// URI cache entry descriptor
// 
class IHttpUrlInfo
{
 public:
    virtual
    IHttpModuleContextContainer *
    GetModuleContextContainer(
        VOID
    ) = 0;

    virtual
    BOOL
    IsFrequentlyHit(
        VOID
    ) const = 0;
};

// 
// Script map descriptor
// 
class IScriptMapInfo
{
 public:
    virtual
    PCWSTR
    GetPath(
        VOID
    ) const = 0;

    virtual
    PCSTR
    GetAllowedVerbs(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetModules(
        OUT DWORD *         pcchModules = NULL
    ) const = 0;

    virtual
    PCWSTR
    GetScriptProcessor(
        OUT DWORD *         pcchScriptProcessor = NULL
    ) const = 0;

    virtual
    PCWSTR
    GetManagedType(
        OUT DWORD *         pcchManagedType = NULL
    ) const = 0;

    virtual
    BOOL
    GetAllowPathInfoForScriptMappings(
        VOID
    ) const = 0;

    virtual
    DWORD
    GetRequiredAccess(
        VOID
    ) const = 0;

    virtual
    DWORD
    GetResourceType(
        VOID
    ) const = 0;

    virtual
    BOOL
    GetIsStarScriptMap(
        VOID
    ) const = 0;

    virtual
    DWORD
    GetResponseBufferLimit(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetName(
        VOID
    ) const = 0;
};

class IHttpTokenEntry;

// 
// Metadata descriptor
// 
class IMetadataInfo
{
 public:
    virtual
    PCWSTR
    GetMetaPath(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetVrPath(
        VOID
    ) const = 0;

    virtual
    IHttpTokenEntry *
    GetVrToken(
        VOID
    ) = 0;

    virtual
    IHttpModuleContextContainer *
    GetModuleContextContainer(
        VOID
    ) = 0;
};

// 
// Provides an inteface to an http request object.  The methods on this
// class can be used to inspect and modify request data.
// 
class IHttpRequest
{
 public:
    virtual
    HTTP_REQUEST *
    GetRawHttpRequest(
        VOID
    ) = 0;

    virtual
    const HTTP_REQUEST *
    GetRawHttpRequest(
        VOID
    ) const = 0;

    virtual
    PCSTR
    GetHeader(
        IN PCSTR                pszHeaderName,
        OUT USHORT *            pcchHeaderValue = NULL
    ) const = 0;

    virtual
    PCSTR
    GetHeader(
        IN  HTTP_HEADER_ID      ulHeaderIndex,
        OUT USHORT *            pcchHeaderValue = NULL
    ) const = 0;

    virtual
    HRESULT
    SetHeader(
        IN PCSTR                pszHeaderName,
        IN PCSTR                pszHeaderValue,
        IN USHORT               cchHeaderValue,
        IN BOOL                 fReplace
    ) = 0;

    virtual
    HRESULT
    SetHeader(
        IN HTTP_HEADER_ID       ulHeaderIndex,
        IN PCSTR                pszHeaderValue,
        IN USHORT               cchHeaderValue,
        IN BOOL                 fReplace
    ) = 0;

    virtual
    HRESULT
    DeleteHeader(
        IN PCSTR                pszHeaderName
    ) = 0;

    virtual
    HRESULT
    DeleteHeader(
        IN HTTP_HEADER_ID       ulHeaderIndex
    ) = 0;

    virtual
    PCSTR
    GetHttpMethod(
        VOID
    ) const = 0;

    virtual
    HRESULT
    SetHttpMethod(
        IN PCSTR                pszHttpMethod
    ) = 0;

    virtual
    HRESULT
    SetUrl(
        IN PCWSTR               pszUrl,
        IN DWORD                cchUrl,
        IN BOOL                 fResetQueryString
    ) = 0;

    virtual
    HRESULT
    SetUrl(
        IN PCSTR                pszUrl,
        IN DWORD                cchUrl,
        IN BOOL                 fResetQueryString
    ) = 0;

    virtual
    BOOL
    GetUrlChanged(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetForwardedUrl(
        VOID
    ) const = 0;

    virtual
    PSOCKADDR
    GetLocalAddress(
        VOID
    ) const = 0;

    virtual
    PSOCKADDR
    GetRemoteAddress(
        VOID
    ) const = 0;

    virtual
    HRESULT
    ReadEntityBody(
        OUT VOID *              pvBuffer,
        IN  DWORD               cbBuffer,
        IN  BOOL                fAsync,
        OUT DWORD *             pcbBytesReceived,
        OUT BOOL *              pfCompletionPending = NULL
    ) = 0;

    virtual
    HRESULT
    InsertEntityBody(
        IN VOID *               pvBuffer,
        IN DWORD                cbBuffer
    ) = 0;

    virtual
    DWORD
    GetRemainingEntityBytes(
        VOID
    ) = 0;

    virtual
    VOID
    GetHttpVersion(
        OUT USHORT *            pMajorVersion,
        OUT USHORT *            pMinorVersion
    ) const = 0;

    virtual
    HRESULT
    GetClientCertificate(
        OUT HTTP_SSL_CLIENT_CERT_INFO **    ppClientCertInfo,
        OUT BOOL *                          pfClientCertNegotiated
    ) = 0;

    virtual
    HRESULT
    NegotiateClientCertificate(
        IN BOOL                 fAsync,
        OUT BOOL *              pfCompletionPending = NULL
    ) = 0;

    virtual
    DWORD
    GetSiteId(
        VOID
    ) const = 0;

    virtual
    HRESULT
    GetHeaderChanges(
        IN      DWORD   dwOldChangeNumber,
        OUT     DWORD * pdwNewChangeNumber,
        IN OUT  PCSTR   knownHeaderSnapshot[HttpHeaderRequestMaximum],
        IN OUT  DWORD * pdwUnknownHeaderSnapShot,
        IN OUT  PCSTR **ppUnknownHeaderNameSnapShot,
        IN OUT  PCSTR **ppUnknownHeaderValueSnapShot,
        __out_ecount(HttpHeaderRequestMaximum+1)
                DWORD   diffedKnownHeaderIndices[HttpHeaderRequestMaximum+1],
        OUT     DWORD * pdwDiffedUnknownHeaders,
        OUT     DWORD **ppDiffedUnknownHeaderIndices
    ) = 0;
};

class IHttpCachePolicy
{
 public:
    virtual
    HTTP_CACHE_POLICY *
    GetKernelCachePolicy(
        VOID
    ) = 0;

    virtual
    VOID
    SetKernelCacheInvalidatorSet(
        VOID
    ) = 0;

    virtual
    HTTP_CACHE_POLICY *
    GetUserCachePolicy(
        VOID
    ) = 0;

    virtual
    HRESULT
    AppendVaryByHeader(
        PCSTR   pszHeader
    ) = 0;

    virtual
    PCSTR
    GetVaryByHeaders(
        VOID
    ) const = 0;

    virtual
    HRESULT
    AppendVaryByQueryString(
        PCSTR   pszParam
    ) = 0;

    virtual
    PCSTR
    GetVaryByQueryStrings(
        VOID
    ) const = 0;

    virtual
    HRESULT
    SetVaryByValue(
        PCSTR   pszValue
    ) = 0;

    virtual
    PCSTR
    GetVaryByValue(
        VOID
    ) const = 0;

    virtual
    BOOL
    IsUserCacheEnabled(
        VOID
    ) const = 0;

    virtual
    VOID
    DisableUserCache(
        VOID
    ) = 0;

    virtual
    BOOL
    IsCached(
        VOID
    ) const = 0;

    virtual
    VOID
    SetIsCached(
        VOID
    ) = 0;

    virtual
    BOOL
    GetKernelCacheInvalidatorSet(
        VOID
    ) const = 0;
};

// 
// Response descriptor
// 
class IHttpResponse
{
 public:
    virtual
    HTTP_RESPONSE *
    GetRawHttpResponse(
        VOID
    ) = 0;

    virtual
    const HTTP_RESPONSE *
    GetRawHttpResponse(
        VOID
    ) const = 0;

    virtual
    IHttpCachePolicy *
    GetCachePolicy(
        VOID
    ) = 0;

    virtual
    HRESULT
    SetStatus(
        IN USHORT                   statusCode,
        IN PCSTR                    pszReason,
        IN USHORT                   uSubStatus = 0,
        IN HRESULT                  hrErrorToReport = S_OK,
        IN IAppHostConfigException *pException = NULL,
        IN BOOL                     fTrySkipCustomErrors = FALSE
    ) = 0;

    virtual
    HRESULT
    SetHeader(
        IN PCSTR                pszHeaderName,
        IN PCSTR                pszHeaderValue,
        IN USHORT               cchHeaderValue,
        IN BOOL                 fReplace
    ) = 0;

    virtual
    HRESULT
    SetHeader(
        IN HTTP_HEADER_ID       ulHeaderIndex,
        IN PCSTR                pszHeaderValue,
        IN USHORT               cchHeaderValue,
        IN BOOL                 fReplace
    ) = 0;

    virtual
    HRESULT
    DeleteHeader(
        IN PCSTR                pszHeaderName
    ) = 0;

    virtual
    HRESULT
    DeleteHeader(
        IN HTTP_HEADER_ID       ulHeaderIndex
    ) = 0;

    virtual
    PCSTR
    GetHeader(
        IN PCSTR                pszHeaderName,
        OUT USHORT *            pcchHeaderValue = NULL
    ) const = 0;

    virtual
    PCSTR
    GetHeader(
        IN  HTTP_HEADER_ID      ulHeaderIndex,
        OUT USHORT *            pcchHeaderValue = NULL
    ) const = 0;

    virtual
    VOID
    Clear(
        VOID
    ) = 0;

    virtual
    VOID
    ClearHeaders(
        VOID
    ) = 0;

    virtual
    VOID
    SetNeedDisconnect(
        VOID
    ) = 0;

    virtual
    VOID
    ResetConnection(
        VOID
    ) = 0;

    virtual
    VOID
    DisableKernelCache(
        ULONG reason = 9
    ) = 0;

    virtual
    BOOL
    GetKernelCacheEnabled(
        VOID
    ) const = 0;

    virtual
    VOID
    SuppressHeaders(
        VOID
    ) = 0;

    virtual
    BOOL
    GetHeadersSuppressed(
        VOID
    ) const = 0;

    virtual
    HRESULT
    Flush(
        IN BOOL                 fAsync,
        IN BOOL                 fMoreData,
        OUT DWORD *             pcbSent,
        OUT BOOL *              pfCompletionExpected = NULL
    ) = 0;

    virtual
    HRESULT
    Redirect(
        IN PCSTR                pszUrl,
        IN BOOL                 fResetStatusCode = TRUE,
        IN BOOL                 fIncludeParameters = FALSE
    ) = 0;

    virtual
    HRESULT
    WriteEntityChunkByReference(
        IN HTTP_DATA_CHUNK *    pDataChunk,
        IN LONG                 lInsertPosition = -1
    ) = 0;

    virtual
    HRESULT
    WriteEntityChunks(
        IN  HTTP_DATA_CHUNK *   pDataChunks,
        IN  DWORD               nChunks,
        IN  BOOL                fAsync,
        IN  BOOL                fMoreData,
        OUT DWORD *             pcbSent,
        OUT BOOL *              pfCompletionExpected = NULL
    ) = 0;

    virtual
    VOID
    DisableBuffering(
        VOID
    ) = 0;

    virtual
    VOID
    GetStatus(
        OUT USHORT *                    pStatusCode,
        OUT USHORT *                    pSubStatus = NULL,
        OUT PCSTR *                     ppszReason = NULL,
        OUT USHORT *                    pcchReason = NULL,
        OUT HRESULT *                   phrErrorToReport = NULL,
        OUT PCWSTR *                    ppszModule = NULL,
        OUT DWORD *                     pdwNotification = NULL,
        OUT IAppHostConfigException **  ppException = NULL,
        OUT BOOL *                      pfTrySkipCustomErrors = NULL
    ) = 0;

    virtual
    HRESULT
    SetErrorDescription(
        IN PCWSTR                       pszDescription,
        IN DWORD                        cchDescription,
        IN BOOL                         fHtmlEncode = TRUE
    ) = 0;

    virtual
    PCWSTR
    GetErrorDescription(
        OUT DWORD *                     pcchDescription = NULL
    ) = 0;

    virtual
    HRESULT
    GetHeaderChanges(
        IN      DWORD   dwOldChangeNumber,
        OUT     DWORD * pdwNewChangeNumber,
        IN OUT  PCSTR   knownHeaderSnapshot[HttpHeaderResponseMaximum],
        IN OUT  DWORD * pdwUnknownHeaderSnapShot,
        IN OUT  PCSTR **ppUnknownHeaderNameSnapShot,
        IN OUT  PCSTR **ppUnknownHeaderValueSnapShot,
        __out_ecount(HttpHeaderResponseMaximum+1)
                DWORD   diffedKnownHeaderIndices[HttpHeaderResponseMaximum+1],
        OUT     DWORD * pdwDiffedUnknownHeaders,
        OUT     DWORD **ppDiffedUnknownHeaderIndices
    ) = 0;

    virtual
    VOID
    CloseConnection(
        VOID
    ) = 0;
};

// 
// User descriptor
// 
class IHttpUser
{
 public:
    virtual
    PCWSTR
    GetRemoteUserName(
        VOID
    ) = 0;

    virtual
    PCWSTR
    GetUserName(
        VOID
    ) = 0;

    virtual 
    PCWSTR
    GetAuthenticationType(
        VOID
    ) = 0;

    virtual
    PCWSTR
    GetPassword(
        VOID
    ) = 0;  

    virtual
    HANDLE
    GetImpersonationToken(
        VOID
    ) = 0;

    virtual
    HANDLE
    GetPrimaryToken(
        VOID
    ) = 0;

    virtual
    VOID
    ReferenceUser(
        VOID
    ) = 0;

    virtual
    VOID
    DereferenceUser(
        VOID
    ) = 0;

    virtual
    BOOL
    SupportsIsInRole(
        VOID
    ) = 0;

    virtual
    HRESULT
    IsInRole(
        IN  PCWSTR  pszRoleName,
        OUT BOOL *  pfInRole
    ) = 0;

    virtual
    PVOID
    GetUserVariable(
        IN PCSTR    pszVariableName
    ) = 0;
};

#define HTTP_USER_VARIABLE_SID              "SID"
#define HTTP_USER_VARIABLE_CTXT_HANDLE      "CtxtHandle"
#define HTTP_USER_VARIABLE_CRED_HANDLE      "CredHandle"

// 
// Connection descriptor
// 
class IHttpConnection
{
 public:
    virtual
    BOOL
    IsConnected(
        VOID
    ) const = 0;

    virtual
    VOID *
    AllocateMemory(
        DWORD               cbAllocation
    ) = 0;

    virtual
    IHttpModuleContextContainer *
    GetModuleContextContainer(
        VOID
    ) = 0;
};

// 
// Forward declarations
// 
class IHttpFileInfo;
class IHttpSite;
class ICustomNotificationProvider;
class IHttpEventProvider;
class CHttpModule;

//
// IHttpContext extended interface versions (no extended versions
// exist currently)
//
enum HTTP_CONTEXT_INTERFACE_VERSION
{
};

// 
// Context object representing the processing of an HTTP request
// 
class IHttpContext
{
 public:
    virtual
    IHttpSite *
    GetSite(
        VOID
    ) = 0;

    virtual
    IHttpApplication *
    GetApplication(
        VOID
    ) = 0;

    virtual
    IHttpConnection *
    GetConnection(
        VOID
    ) = 0;

    virtual
    IHttpRequest *
    GetRequest(
        VOID
    ) = 0;

    virtual
    IHttpResponse *
    GetResponse(
        VOID
    ) = 0;

    virtual
    BOOL
    GetResponseHeadersSent(
        VOID
    ) const = 0;

    virtual
    IHttpUser *
    GetUser(
        VOID
    ) const = 0;

    virtual
    IHttpModuleContextContainer *
    GetModuleContextContainer(
        VOID
    ) = 0;

    virtual
    VOID
    IndicateCompletion(
        IN REQUEST_NOTIFICATION_STATUS     notificationStatus
    ) = 0;

    virtual
    HRESULT
    PostCompletion(
        IN DWORD                cbBytes
    ) = 0;

    virtual
    VOID
    DisableNotifications(
        IN DWORD                dwNotifications,
        IN DWORD                dwPostNotifications
    ) = 0;

    virtual
    BOOL
    GetNextNotification(
        IN  REQUEST_NOTIFICATION_STATUS status,
        OUT DWORD *                     pdwNotification,
        OUT BOOL *                      pfIsPostNotification,
        OUT CHttpModule **              ppModuleInfo,
        OUT IHttpEventProvider **       ppRequestOutput
    ) = 0;

    virtual
    BOOL
    GetIsLastNotification(
        IN  REQUEST_NOTIFICATION_STATUS status
    ) = 0;    

    virtual
    HRESULT
    ExecuteRequest(
        IN BOOL                 fAsync,
        IN IHttpContext *       pHttpContext,
        IN DWORD                dwExecuteFlags,
        IN IHttpUser *          pHttpUser,
        OUT BOOL *              pfCompletionExpected = NULL
    ) = 0;                      

    virtual
    DWORD
    GetExecuteFlags(
        VOID
    ) const = 0;

    virtual
    HRESULT
    GetServerVariable(
        PCSTR               pszVariableName,
        __deref_out_ecount(*pcchValueLength) PCWSTR * ppszValue,
        __out DWORD *       pcchValueLength
    ) = 0;

    virtual
    HRESULT
    GetServerVariable(
        PCSTR               pszVariableName,
        __deref_out_ecount(*pcchValueLength) PCSTR * ppszValue,
        __out DWORD *       pcchValueLength
    ) = 0;

    virtual
    HRESULT
    SetServerVariable(
        PCSTR               pszVariableName,
        PCWSTR              pszVariableValue
    ) = 0;

    virtual
    VOID *
    AllocateRequestMemory(
        IN DWORD                cbAllocation
    ) = 0;

    virtual
    IHttpUrlInfo *
    GetUrlInfo(
        VOID
    ) = 0;

    virtual
    IMetadataInfo *
    GetMetadata(
        VOID
    ) = 0;

    virtual
    PCWSTR
    GetPhysicalPath(
        OUT DWORD *         pcchPhysicalPath = NULL
    ) = 0;

    virtual
    PCWSTR
    GetScriptName(
        OUT DWORD *         pcchScriptName = NULL
    ) const = 0;

    virtual
    PCWSTR
    GetScriptTranslated(
        OUT DWORD *         pcchScriptTranslated = NULL
    ) = 0;

    virtual
    IScriptMapInfo *
    GetScriptMap(
        VOID
    ) const = 0;

    virtual
    VOID
    SetRequestHandled(
        VOID
    ) = 0;

    virtual
    IHttpFileInfo *
    GetFileInfo(
        VOID
    ) const = 0;

    virtual
    HRESULT
    MapPath(
                                           PCWSTR   pszUrl,
        __out_bcount_opt(*pcbPhysicalPath) PWSTR    pszPhysicalPath,
                                    IN OUT DWORD *  pcbPhysicalPath
    ) = 0;

    virtual
    HRESULT
    NotifyCustomNotification(
        ICustomNotificationProvider *   pCustomOutput,
        OUT BOOL *                      pfCompletionExpected
    ) = 0;

    virtual
    IHttpContext *
    GetParentContext(
        VOID
    ) const = 0;

    virtual
    IHttpContext *
    GetRootContext(
        VOID
    ) const = 0;

    virtual
    HRESULT
    CloneContext(
        IN DWORD                dwCloneFlags,
        OUT IHttpContext **     ppHttpContext
    ) = 0;

    virtual
    HRESULT
    ReleaseClonedContext(
        VOID
    ) = 0;

    virtual
    HRESULT
    GetCurrentExecutionStats(
        OUT DWORD * pdwNotification,
        OUT DWORD * pdwNotificationStartTickCount = NULL,
        OUT PCWSTR *  ppszModule = NULL,
        OUT DWORD * pdwModuleStartTickCount = NULL,
        OUT DWORD * pdwAsyncNotification = NULL,
        OUT DWORD * pdwAsyncNotificationStartTickCount = NULL
    ) const = 0;

    virtual
    IHttpTraceContext *
    GetTraceContext(
        VOID
    ) const = 0;

    virtual
    HRESULT
    GetServerVarChanges(
        IN      DWORD       dwOldChangeNumber,
        OUT     DWORD *     pdwNewChangeNumber,
        IN OUT  DWORD *     pdwVariableSnapShot,
        IN OUT  PCSTR **    ppVariableNameSnapShot,
        IN OUT  PCWSTR **   ppVariableValueSnapShot,
        OUT     DWORD *     pdwDiffedVariables,
        OUT     DWORD **    ppDiffedVariableIndices
    ) = 0;

    virtual
    HRESULT
    CancelIo(
        VOID
    ) = 0;

    virtual
    HRESULT
    MapHandler(
        IN      DWORD               dwSiteId,
        IN      PCWSTR              pszSiteName,
        IN      PCWSTR              pszUrl,
        IN      PCSTR               pszVerb,
        OUT     IScriptMapInfo **   ppScriptMap,
        IN      BOOL                fIgnoreWildcardMappings = FALSE
    ) = 0;

    virtual
    HRESULT
    GetExtendedInterface(
        IN  HTTP_CONTEXT_INTERFACE_VERSION  version,
        OUT PVOID *                         ppInterface
    ) = 0;
};


class IHttpTraceContext
{
public:
    virtual
    HRESULT
    GetTraceConfiguration(
        IN OUT HTTP_TRACE_CONFIGURATION *  pHttpTraceConfiguration
    ) = 0;
    
    virtual    
    HRESULT
    SetTraceConfiguration(
        IN HTTP_MODULE_ID              moduleId,
        IN HTTP_TRACE_CONFIGURATION *  pHttpTraceConfiguration,
        IN DWORD                       cHttpTraceConfiguration = 1
    ) = 0;

    virtual
    HRESULT
    RaiseTraceEvent(
        IN HTTP_TRACE_EVENT * pTraceEvent 
    ) = 0;

    virtual
    LPCGUID
    GetTraceActivityId(
    ) = 0;

    virtual
    HRESULT
    QuickTrace(
        IN PCWSTR   pszData1,
        IN PCWSTR   pszData2 = NULL,
        IN HRESULT  hrLastError = S_OK,
        //
        // 4 == TRACE_LEVEL_INFORMATION
        //
        IN UCHAR    Level = 4
    ) = 0;
};

class IHttpCacheSpecificData;

//
// Cache helpers
//

class IHttpCacheKey
{
 public:
    virtual
    DWORD
    GetHash(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetCacheName(
        VOID
    ) const = 0;

    virtual
    bool
    GetIsEqual(
        IHttpCacheKey *         pCacheCompareKey
    ) const = 0;

    virtual
    bool
    GetIsPrefix(
        IHttpCacheKey *         pCacheCompareKey
    ) const = 0;

    virtual
    VOID
    Enum(
        IHttpCacheSpecificData *
    ) = 0;
};

class IHttpCacheSpecificData
{
 public:
    virtual
    IHttpCacheKey *
    GetCacheKey(
        VOID
    ) const = 0;

    virtual
    VOID
    ReferenceCacheData(
        VOID
    ) = 0;

    virtual
    VOID
    DereferenceCacheData(
        VOID
    ) = 0;

    virtual
    VOID
    ResetTTL(
        VOID
    ) = 0;

    virtual
    VOID
    DecrementTTL(
        OUT BOOL    *pfTTLExpired
    ) = 0;

    virtual
    VOID
    SetFlushed(
        VOID
    ) = 0;

    virtual
    BOOL
    GetFlushed(
        VOID
    ) const = 0;
};

// 
// Site descriptor
// 
class IHttpSite
{
 public:
    virtual
    DWORD
    GetSiteId(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetSiteName(
        VOID
    ) const = 0;

    virtual
    IHttpModuleContextContainer *
    GetModuleContextContainer(
        VOID
    ) = 0;

    virtual
    IHttpPerfCounterInfo *
    GetPerfCounterInfo(
        VOID
    ) = 0;
};

//
// File change monitor
//
//
class IHttpFileMonitor
{
 public:
    virtual
    IHttpModuleContextContainer *
    GetModuleContextContainer(
        VOID
    ) = 0;

    virtual
    VOID
    DereferenceFileMonitor(
        VOID
    ) = 0;
};

//
// File descriptor
// 
// 
class IHttpFileInfo : public IHttpCacheSpecificData
{
 public:
    virtual
    DWORD
    GetAttributes(
        VOID
    ) const = 0;

    virtual
    VOID
    GetSize(
        OUT ULARGE_INTEGER *        pliSize
    ) const = 0;

    virtual
    const BYTE *
    GetFileBuffer(
        VOID
    ) const = 0;

    virtual
    HANDLE
    GetFileHandle(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetFilePath(
        VOID
    ) const = 0;

    virtual
    PCSTR
    GetETag(
        OUT USHORT *                pcchETag = NULL
    ) const = 0;

    virtual
    VOID
    GetLastModifiedTime(
        OUT FILETIME *              pFileTime
    ) const = 0;

    virtual
    PCSTR
    GetLastModifiedString(
        VOID
    ) const = 0;

    virtual
    BOOL
    GetHttpCacheAllowed(
        OUT DWORD *     pSecondsToLive
    ) const = 0;

    virtual
    HRESULT
    AccessCheck(
        IN HANDLE                   hUserToken,
        IN PSID                     pUserSid
    ) = 0;

    virtual
    HANDLE
    GetVrToken(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetVrPath(
        VOID
    ) const = 0;

    virtual
    IHttpModuleContextContainer *
    GetModuleContextContainer(
        VOID
    ) = 0;

    virtual
    BOOL
    CheckIfFileHasChanged(
        IN HANDLE                   hUserToken
    ) = 0;
};


// 
// Token-cache entry
// 
class IHttpTokenEntry : public IHttpCacheSpecificData
{
 public:
    virtual
    HANDLE
    GetImpersonationToken(
        VOID
    ) = 0;

    virtual
    HANDLE
    GetPrimaryToken(
        VOID
    ) = 0;

    virtual
    PSID
    GetSid(
        VOID
    ) = 0;
};


//
// IHttpServer extended interface versions (no extended versions
// exist currently)
//
enum HTTP_SERVER_INTERFACE_VERSION
{
};


//
// Global utility descriptor
//
class IHttpServer
{
 public:
    virtual
    BOOL
    IsCommandLineLaunch(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetAppPoolName(
        VOID
    ) const = 0;

    virtual
    HRESULT
    AssociateWithThreadPool(
        IN HANDLE                              hHandle,
        IN LPOVERLAPPED_COMPLETION_ROUTINE     completionRoutine
    ) = 0;

    virtual
    VOID
    IncrementThreadCount(
        VOID
    ) = 0;

    virtual
    VOID
    DecrementThreadCount(
        VOID
    ) = 0;

    virtual
    VOID
    ReportUnhealthy(
        IN PCWSTR               pszReasonString,
        IN HRESULT              hrReason
    ) = 0;

    virtual
    VOID
    RecycleProcess(
        PCWSTR                  pszReason
    ) = 0;

    virtual
    IAppHostAdminManager *
    GetAdminManager(
        VOID
    ) const = 0;

    virtual
    HRESULT
    GetFileInfo(
        IN  PCWSTR               pszPhysicalPath,
        IN  HANDLE               hUserToken,
        IN  PSID                 pSid,
        IN  PCWSTR               pszChangeNotificationPath,
        IN  HANDLE               hChangeNotificationToken,
        IN  BOOL                 fCache,
        OUT IHttpFileInfo **     ppFileInfo,
        IN  IHttpTraceContext *  pHttpTraceContext = NULL
    ) = 0;

    virtual
    HRESULT
    FlushKernelCache(
        IN PCWSTR               pszUrl
    ) = 0;

    virtual
    HRESULT
    DoCacheOperation(
        IN CACHE_OPERATION              cacheOperation,
        IN IHttpCacheKey *              pCacheKey,
        OUT IHttpCacheSpecificData **   ppCacheSpecificData,
        IN  IHttpTraceContext *         pHttpTraceContext = NULL
    ) = 0;

    virtual
    GLOBAL_NOTIFICATION_STATUS
    NotifyCustomNotification(
        ICustomNotificationProvider * pCustomOutput
    ) = 0;

    virtual
    IHttpPerfCounterInfo *
    GetPerfCounterInfo(
        VOID
    ) = 0;

    virtual
    VOID
    RecycleApplication(
        PCWSTR                  pszAppConfigPath
    ) = 0;

    virtual
    VOID
    NotifyConfigurationChange(
        PCWSTR                  pszPath
    ) = 0;

    virtual
    VOID
    NotifyFileChange(
        PCWSTR                  pszFileName
    ) = 0;

    virtual
    IDispensedHttpModuleContextContainer *
    DispenseContainer(
        VOID
    ) = 0;

    virtual
    HRESULT
    AddFragmentToCache(
        IN HTTP_DATA_CHUNK *    pDataChunk,
        PCWSTR                  pszFragmentName
    ) = 0;

    virtual
    HRESULT
    ReadFragmentFromCache(
        PCWSTR          pszFragmentName,
        OUT BYTE *      pvBuffer,
        DWORD           cbSize,
        OUT DWORD *     pcbCopied
    ) = 0;

    virtual
    HRESULT
    RemoveFragmentFromCache(
        PCWSTR          pszFragmentName
    ) = 0;

    virtual
    HRESULT
    GetWorkerProcessSettings(
        OUT IWpfSettings ** ppWorkerProcessSettings
    ) = 0;

    virtual
    HRESULT
    GetProtocolManagerCustomInterface(
        IN PCWSTR       pProtocolManagerDll,
        IN PCWSTR       pProtocolManagerDllInitFunction,
        IN DWORD        dwCustomInterfaceId,
        OUT PVOID*      ppCustomInterface
    ) = 0;

    virtual
    BOOL
    SatisfiesPrecondition(
        PCWSTR          pszPrecondition,
        BOOL *          pfUnknownPrecondition = NULL
    ) const = 0;

    virtual
    IHttpTraceContext *
    GetTraceContext(
        VOID
    ) const = 0;

    virtual
    HRESULT
    RegisterFileChangeMonitor(
        PCWSTR                  pszPath,
        HANDLE                  hToken,
        IHttpFileMonitor **     ppFileMonitor
    ) = 0;

    virtual
    HRESULT
    GetExtendedInterface(
        IN  HTTP_SERVER_INTERFACE_VERSION   version,
        OUT PVOID *                         ppInterface
    ) = 0;
};

//
// Notification specific output for notifications
//
class IHttpEventProvider
{
 public:
    virtual
    VOID
    SetErrorStatus(
        HRESULT             hrError
    ) = 0;

};

//
// Completion information for notifications
//
class IHttpCompletionInfo
{
 public:
    virtual
    DWORD
    GetCompletionBytes(
        VOID
    ) const = 0;

    virtual
    HRESULT
    GetCompletionStatus(
        VOID
    ) const = 0;
};


//
// RQ_ and GL_ CUSTOM_NOTIFICATION outputs
//

class ICustomNotificationProvider : public IHttpEventProvider
{
 public:
    virtual
    PCWSTR
    QueryNotificationType(
        VOID
    ) = 0;
};

//
// RQ_REQUEST_AUTHENTICATE descriptor
//
class IAuthenticationProvider : public IHttpEventProvider
{
 public:
    virtual
    VOID
    SetUser(
        IN IHttpUser *          pUser
    ) = 0;
};

//
// RQ_MAP_REQUEST_HANDLER
//
class IMapHandlerProvider : public IHttpEventProvider
{
 public:
    virtual
    HRESULT
    SetScriptName(
        PCWSTR                  pszScriptName,
        DWORD                   cchScriptName
    ) = 0;

    virtual
    VOID
    SetScriptMap(
        IN IScriptMapInfo *     pScriptMap
    ) = 0;

    virtual
    VOID
    SetFileInfo(
        IN IHttpFileInfo *      pFileInfo
    ) = 0;
};

//
// RQ_MAP_PATH
//
class IMapPathProvider : public IHttpEventProvider
{
 public:
    virtual
    PCWSTR
    GetUrl(
    ) const = 0;

    virtual
    PCWSTR
    GetPhysicalPath(
    ) const = 0;

    virtual
    HRESULT
    SetPhysicalPath(
        PCWSTR pszPhysicalPath,
        DWORD  cchPhysicalPath
    ) = 0;
};


//
// RQ_SEND_RESPONSE
//
class ISendResponseProvider : public IHttpEventProvider
{
 public:
    virtual
    BOOL
    GetHeadersBeingSent(
        VOID
    ) const = 0;

    virtual
    DWORD
    GetFlags(
        VOID
    ) const = 0;

    virtual
    VOID
    SetFlags(
        DWORD dwFlags
    ) = 0;

    virtual
    HTTP_LOG_DATA *
    GetLogData(
        VOID
    ) const = 0;

    virtual
    HRESULT
    SetLogData(
        IN HTTP_LOG_DATA *pLogData
    ) = 0;

    virtual
    BOOL
    GetReadyToLogData(
        VOID
    ) const = 0;
};

//
// RQ_READ_ENTITY
//
class IReadEntityProvider : public IHttpEventProvider
{
 public:
    virtual
    VOID
    GetEntity(
        OUT PVOID *             ppBuffer,
        OUT DWORD *             pcbData,
        OUT DWORD *             pcbBuffer
    ) = 0;

    virtual
    VOID
    SetEntity(
        IN PVOID            pBuffer,
        DWORD               cbData,
        DWORD               cbBuffer
    ) = 0;
};

//
// GL_PRE_BEGIN_REQUEST provider
//
class IPreBeginRequestProvider : public IHttpEventProvider
{
 public:
    virtual
    IHttpContext *
    GetHttpContext(
        VOID
    ) = 0;
};

//
// GL_APPLICATION_START provider
//
class IHttpApplicationProvider : public IHttpEventProvider
{
 public:
    virtual
    IHttpApplication *
    GetApplication(
        VOID
    ) = 0;
};

typedef IHttpApplicationProvider    IHttpApplicationStartProvider;

class IHttpModuleFactory;

//
// GL_APPLICATION_RESOLVE_MODULES provider
//
class IHttpApplicationResolveModulesProvider : public IHttpApplicationProvider
{
 public:
    virtual 
    HRESULT
    RegisterModule(
        IN HTTP_MODULE_ID       parentModuleId,
        IN IHttpModuleFactory * pModuleFactory,
        IN PCWSTR               pszModuleName,
        IN PCWSTR               pszModuleType,
        IN PCWSTR               pszModulePreCondition,
        IN DWORD                dwRequestNotifications,
        IN DWORD                dwPostRequestNotifications
    ) = 0;

    virtual
    HRESULT
    SetPriorityForRequestNotification(
        IN PCWSTR               pszModuleName,
        IN DWORD                dwRequestNotification,
        IN PCWSTR               pszPriorityAlias
    ) = 0;
};

//
// GL_APPLICATION_STOP provider
//
typedef IHttpApplicationProvider   IHttpApplicationStopProvider;

//
// GL_RSCA_QUERY provider
//
class IGlobalRSCAQueryProvider : public IHttpEventProvider
{
 public:
    virtual
    PCWSTR
    GetFunctionName(
        VOID
    ) const = 0;

    virtual
    PCWSTR
    GetFunctionParameters(
        VOID
    ) const = 0;

    virtual
    HRESULT
    GetOutputBuffer(
        DWORD       cbBuffer,
        OUT BYTE ** ppbBuffer
    ) = 0;

    virtual
    HRESULT
    ResizeOutputBuffer(
        DWORD          cbNewBuffer,
        DWORD          cbBytesToCopy,
        IN OUT BYTE ** ppbBuffer
    ) = 0;

    virtual
    VOID
    SetResult(
        DWORD       cbData,
        HRESULT     hr
    ) = 0;
};


//
// GL_STOP_LISTENING
//
class IGlobalStopListeningProvider : public IHttpEventProvider
{
 public:
    virtual
    BOOL
    DrainRequestsGracefully(
        VOID
    ) const = 0;
};

//
// GL_CACHE_OPERATION
//
class ICacheProvider : public IHttpEventProvider
{
 public:
    virtual
    CACHE_OPERATION
    GetCacheOperation(
        VOID
    ) const = 0;

    virtual
    IHttpCacheKey *
    GetCacheKey(
        VOID
    ) const = 0;

    virtual
    IHttpCacheSpecificData *
    GetCacheRecord(
        VOID
    ) const = 0;

    virtual
    VOID
    SetCacheRecord(
        IHttpCacheSpecificData *    pCacheRecord
    ) = 0;

    virtual
    IHttpTraceContext *
    GetTraceContext(
        VOID
    ) const = 0;
};

//
// GL_CONFIGURATION_CHANGE
//
class IGlobalConfigurationChangeProvider : public IHttpEventProvider
{
 public:
    virtual
    PCWSTR
    GetChangePath(
        VOID
    ) const = 0;
};

//
// GL_FILE_CHANGE
//
class IGlobalFileChangeProvider : public IHttpEventProvider
{
public:
    virtual
    PCWSTR
    GetFileName(
        VOID
    ) const = 0;

    virtual
    IHttpFileMonitor *
    GetFileMonitor(
        VOID
    ) = 0;
};


//
// GL_TRACE_EVENT
//
class IGlobalTraceEventProvider : public IHttpEventProvider
{
 public:
    virtual
    HRESULT
    GetTraceEvent(
        OUT HTTP_TRACE_EVENT ** ppTraceEvent
    ) = 0;

    virtual
    BOOL
    CheckSubscription(
        IN HTTP_MODULE_ID   ModuleId    
    ) = 0;     

    virtual
    HRESULT 
    GetCurrentHttpRequestContext(
        OUT IHttpContext ** ppHttpContext
    ) = 0;
};


//
// GL_THREAD_CLEANUP
//
class IGlobalThreadCleanupProvider : public IHttpEventProvider
{
public:
    virtual
    IHttpApplication *
    GetApplication(
        VOID
    ) = 0;
};


class CHttpModule
{
public:
    // RQ_BEGIN_REQUEST

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnBeginRequest(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPostBeginRequest(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    // RQ_AUTHENTICATE_REQUEST

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnAuthenticateRequest(
        IN IHttpContext *                       pHttpContext,
        IN IAuthenticationProvider *            pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPostAuthenticateRequest(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    // RQ_AUTHORIZE_REQUEST

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnAuthorizeRequest(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPostAuthorizeRequest(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    // RQ_RESOLVE_REQUEST_CACHE

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnResolveRequestCache(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPostResolveRequestCache(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    // RQ_MAP_REQUEST_HANDLER

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnMapRequestHandler(
        IN IHttpContext *                       pHttpContext,
        IN IMapHandlerProvider *                pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPostMapRequestHandler(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    // RQ_ACQUIRE_REQUEST_STATE

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnAcquireRequestState(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPostAcquireRequestState(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    // RQ_PRE_EXECUTE_REQUEST_HANDLER

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPreExecuteRequestHandler(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPostPreExecuteRequestHandler(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    // RQ_EXECUTE_REQUEST_HANDLER

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnExecuteRequestHandler(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPostExecuteRequestHandler(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )    
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }

    // RQ_RELEASE_REQUEST_STATE

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnReleaseRequestState(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPostReleaseRequestState(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    // RQ_UPDATE_REQUEST_CACHE

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnUpdateRequestCache(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }


    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPostUpdateRequestCache(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }

    // RQ_LOG_REQUEST

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnLogRequest(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPostLogRequest(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return RQ_NOTIFICATION_CONTINUE;
    }

    // RQ_END_REQUEST

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnEndRequest(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return RQ_NOTIFICATION_CONTINUE;
    }

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnPostEndRequest(
        IN IHttpContext *                       pHttpContext,
        IN IHttpEventProvider *                 pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }

    // RQ_SEND_RESPONSE

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnSendResponse(
        IN IHttpContext *                       pHttpContext,
        IN ISendResponseProvider *              pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }

    // RQ_MAP_PATH

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnMapPath(
        IN IHttpContext *                       pHttpContext,
        IN IMapPathProvider *                   pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }

    // RQ_READ_ENTITY

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnReadEntity(
        IN IHttpContext *                       pHttpContext,
        IN IReadEntityProvider *                pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }

    // RQ_CUSTOM_NOTIFICATION

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnCustomRequestNotification(
        IN IHttpContext *                       pHttpContext,
        IN ICustomNotificationProvider *        pProvider
    )
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }

    // completion

    virtual 
    REQUEST_NOTIFICATION_STATUS
    OnAsyncCompletion(
        IN IHttpContext *                       pHttpContext,
        IN DWORD                                dwNotification,
        IN BOOL                                 fPostNotification,
        IN IHttpEventProvider *                 pProvider,
        IN IHttpCompletionInfo *                pCompletionInfo        
    )    
    {
        UNREFERENCED_PARAMETER( pHttpContext );
        UNREFERENCED_PARAMETER( dwNotification );
        UNREFERENCED_PARAMETER( fPostNotification );
        UNREFERENCED_PARAMETER( pProvider );
        UNREFERENCED_PARAMETER( pCompletionInfo );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CHttpModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();
        
        return RQ_NOTIFICATION_CONTINUE;
    }

    virtual
    VOID
    Dispose(
        VOID
    )
    {
        delete this;
    }

 protected:

    CHttpModule()
    {}

    virtual
    ~CHttpModule()
    {}
};

class CGlobalModule
{
 public:

    // GL_STOP_LISTENING 

    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalStopListening(
        IN IGlobalStopListeningProvider  *  pProvider
    )
    {
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    // GL_CACHE_CLEANUP
    
    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalCacheCleanup(
        VOID
    )
    {
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    // GL_CACHE_OPERATION
    
    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalCacheOperation(
        IN ICacheProvider  *  pProvider
    )
    {
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    // GL_HEALTH_CHECK
    
    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalHealthCheck(
        VOID
    )
    {
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    // GL_CONFIGURATION_CHANGE
    
    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalConfigurationChange(
        IN IGlobalConfigurationChangeProvider  *  pProvider
    )
    {
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    // GL_FILE_CHANGE 
    
    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalFileChange(
        IN IGlobalFileChangeProvider *  pProvider
    )
    {
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    // GL_PRE_BEGIN_REQUEST 
    
    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalPreBeginRequest(
        IN IPreBeginRequestProvider  *  pProvider
    )
    {
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    // GL_APPLICATION_START 
    
    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalApplicationStart(
        IN IHttpApplicationStartProvider  *  pProvider
    )
    {
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    // GL_APPLICATION_RESOLVE_MODULES
    
    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalApplicationResolveModules(
        IN IHttpApplicationResolveModulesProvider  *  pProvider
    )
    {
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    // GL_APPLICATION_STOP

    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalApplicationStop(
        IN IHttpApplicationStopProvider *   pProvider
    )
    {
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    // GL_RSCA_QUERY
    
    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalRSCAQuery(
        IN IGlobalRSCAQueryProvider  *  pProvider
    )
    {
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    // GL_TRACE_EVENT
    
    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalTraceEvent(
        IN IGlobalTraceEventProvider  *  pProvider
    )
    {
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    // GL_CUSTOM_NOTIFICATION
    
    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalCustomNotification(
        IN ICustomNotificationProvider *    pProvider
    )
    {
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }

    virtual
    VOID
    Terminate(
        VOID
    ) = 0;

    // GL_THREAD_CLEANUP
    
    virtual 
    GLOBAL_NOTIFICATION_STATUS
    OnGlobalThreadCleanup(
        IN IGlobalThreadCleanupProvider *    pProvider
    )
    {
        UNREFERENCED_PARAMETER( pProvider );
        OutputDebugStringA(
            "This module subscribed to event "
            __FUNCTION__
            " but did not override the method in its CGlobalModule implementation."
            "  Please check the method signature to make sure it matches the corresponding method.\n");
        DebugBreak();

        return GL_NOTIFICATION_CONTINUE;
    }
};


class IModuleAllocator
{
 public:
    virtual
    VOID *
    AllocateMemory(
        IN DWORD                    cbAllocation
    ) = 0;
};


class IHttpModuleFactory
{
 public:
    virtual
    HRESULT
    GetHttpModule(
        OUT CHttpModule **          ppModule, 
        IN  IModuleAllocator *      pAllocator
    ) = 0;

    virtual
    VOID
    Terminate(
        VOID
    ) = 0;
};


//
// Register-module desriptor
//
class IHttpModuleRegistrationInfo
{
 public:
    virtual 
    PCWSTR 
    GetName(
        VOID
    ) const = 0;

    virtual 
    HTTP_MODULE_ID
    GetId(
        VOID
    ) const = 0;

    virtual 
    HRESULT
    SetRequestNotifications(
        IN IHttpModuleFactory * pModuleFactory,
        IN DWORD                dwRequestNotifications,
        IN DWORD                dwPostRequestNotifications
    ) = 0;

    virtual 
    HRESULT
    SetGlobalNotifications(
        IN CGlobalModule *      pGlobalModule,
        IN DWORD                dwGlobalNotifications
    ) = 0;

    virtual
    HRESULT
    SetPriorityForRequestNotification(
        IN DWORD                dwRequestNotification, 
        IN PCWSTR               pszPriority
    ) = 0;

    virtual
    HRESULT
    SetPriorityForGlobalNotification(
        IN DWORD                dwGlobalNotification, 
        IN PCWSTR               pszPriority
    ) = 0;
};


//
// Register Module entrypoint
// 

typedef
HRESULT
(WINAPI * PFN_REGISTERMODULE)(
    DWORD                           dwServerVersion,
    IHttpModuleRegistrationInfo *   pModuleInfo,
    IHttpServer *                   pGlobalInfo
);

#define MODULE_REGISTERMODULE   "RegisterModule"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\http.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    Http.h

Abstract:

    This header corresponds to the HTTP API specification

Revision History:

--*/


#ifndef __HTTP_H__
#define __HTTP_H__

#pragma once

#if _WIN32_WINNT >= 0x0501

//
// HTTPAPI is available on
//
// a) WinXP SP2 and higher
// b) Windows 2003 and higher
// c) Longhorn and higher.
//




#include <winsock2.h>
#include <ws2tcpip.h>


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Flags for HttpInitialize() and HttpTerminate().
//

//
// HTTP_INITIALIZE_SERVER - Initializes the HTTP API layer and driver for
//                          applications using server APIs.
//
// HTTP_INITIALIZE_CONFIG - Initializes the HTTP API layer and driver for
//                          applications using HTTP configuration APIs.
//
//
// Notes -
//
// 1. These flags can be used in combination.
//
// 2. HttpTerminate() must be called for each call to HttpInitialize() made
//    with each flag set when invoking HttpInitialize.  For example, one
//    could make two calls to HttpInitialize() setting HTTP_INITIALIZE_SERVER
//    the first time and HTTP_INITIALIZE_CONFIG the second time.  One call
//    to HttpTerminate() with both flags set suffices to clean up both
//    calls to HttpInitialize().
//

#define HTTP_INITIALIZE_SERVER          0x00000001
#define HTTP_INITIALIZE_CONFIG          0x00000002

#if _WIN32_WINNT >= 0x0600

//
// Following section defines the properties supported by the
// server side HTTP API.
//

typedef enum _HTTP_SERVER_PROPERTY
{
    //
    // Used for enabling server side authentication.
    //

    HttpServerAuthenticationProperty,

    //
    // Used for enabling logging.
    //

    HttpServerLoggingProperty,

    //
    // Used for setting QoS properties.
    //

    HttpServerQosProperty,

    //
    // Used for configuring timeouts.
    //

    HttpServerTimeoutsProperty,

    //
    // Used for limiting request queue lengths.
    //

    HttpServerQueueLengthProperty,

    //
    // Used for manipulating the state.
    //

    HttpServerStateProperty,

    //
    // Used for modifying the verbosity level of 503 type responses
    // generated by server side API.
    //

    HttpServer503VerbosityProperty,

    //
    // Used for manipulating Url Group to Request Queue association.
    //

    HttpServerBindingProperty,

    //
    // Extended authentication property.
    //

    HttpServerExtendedAuthenticationProperty,

    //
    // Listening endpoint property.
    //

    HttpServerListenEndpointProperty


} HTTP_SERVER_PROPERTY, *PHTTP_SERVER_PROPERTY;

#define HTTP_MAX_SERVER_QUEUE_LENGTH    0x7FFFFFFF
#define HTTP_MIN_SERVER_QUEUE_LENGTH    1

//
// Generic property flags. Each structure defining a property info typically
// contain an element of this type.
//

typedef struct _HTTP_PROPERTY_FLAGS
{
    ULONG Present:1;

} HTTP_PROPERTY_FLAGS, *PHTTP_PROPERTY_FLAGS;

//
// Enabled state.
//

typedef enum _HTTP_ENABLED_STATE
{
    HttpEnabledStateActive,
    HttpEnabledStateInactive,

} HTTP_ENABLED_STATE, *PHTTP_ENABLED_STATE;


typedef struct _HTTP_STATE_INFO
{
    HTTP_PROPERTY_FLAGS Flags;
    HTTP_ENABLED_STATE  State;

} HTTP_STATE_INFO, *PHTTP_STATE_INFO;

//
// Defines the verbosity level for a request queue which will be used
// when sending "503 - Service Unavailable" type error responses. Note that
// this setting only affects the error responses generated internally
// by HTTPAPI.
//

typedef enum _HTTP_503_RESPONSE_VERBOSITY
{
    //
    // Instead of sending a 503 response, the connection will be reset.
    // This is the default behavior.
    //
    Http503ResponseVerbosityBasic,

    //
    // Will send a 503 w/ a generic reason phrase.
    //
    Http503ResponseVerbosityLimited,

    //
    // Will send a 503 w/ a detailed reason phrase.
    //
    Http503ResponseVerbosityFull

} HTTP_503_RESPONSE_VERBOSITY, *PHTTP_503_RESPONSE_VERBOSITY;

//
// Network QoS related.
//

typedef enum _HTTP_QOS_SETTING_TYPE
{
    HttpQosSettingTypeBandwidth,
    HttpQosSettingTypeConnectionLimit

} HTTP_QOS_SETTING_TYPE, *PHTTP_QOS_SETTING_TYPE;

typedef struct _HTTP_QOS_SETTING_INFO
{
    HTTP_QOS_SETTING_TYPE QosType;
    PVOID QosSetting;
} HTTP_QOS_SETTING_INFO, *PHTTP_QOS_SETTING_INFO;

typedef struct _HTTP_CONNECTION_LIMIT_INFO
{
    HTTP_PROPERTY_FLAGS Flags;
    ULONG MaxConnections;

} HTTP_CONNECTION_LIMIT_INFO, *PHTTP_CONNECTION_LIMIT_INFO;

typedef struct _HTTP_BANDWIDTH_LIMIT_INFO
{
    HTTP_PROPERTY_FLAGS Flags;
    ULONG MaxBandwidth;

} HTTP_BANDWIDTH_LIMIT_INFO, *PHTTP_BANDWIDTH_LIMIT_INFO;

//
// Bandwidth throttling limit can not be set lower than the following
// number. The value is in bytes/sec.
//

#define HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE ((ULONG)1024)

//
// Distinguished value for bandwidth, connection limits and logging rollover
// size indicating "no limit".
//

#define HTTP_LIMIT_INFINITE   ((ULONG)-1)

//
// Timeout information.
//

//
// For manipulating global timeout settings.
// These timers run when connection does not belong to any application.
// Value zero is not allowed for driver wide timeout settings.
//

typedef enum _HTTP_SERVICE_CONFIG_TIMEOUT_KEY
{
    IdleConnectionTimeout = 0,
    HeaderWaitTimeout

} HTTP_SERVICE_CONFIG_TIMEOUT_KEY, *PHTTP_SERVICE_CONFIG_TIMEOUT_KEY;

typedef USHORT HTTP_SERVICE_CONFIG_TIMEOUT_PARAM,
               *PHTTP_SERVICE_CONFIG_TIMEOUT_PARAM;

//
// To set a timeout value use the set structure. To query/delete use the key
// directly. When you query a timeout value the output buffer must be exactly
// the sizeof param.
//

typedef struct _HTTP_SERVICE_CONFIG_TIMEOUT_SET
{
    HTTP_SERVICE_CONFIG_TIMEOUT_KEY KeyDesc;
    HTTP_SERVICE_CONFIG_TIMEOUT_PARAM ParamDesc;

} HTTP_SERVICE_CONFIG_TIMEOUT_SET, *PHTTP_SERVICE_CONFIG_TIMEOUT_SET;

//
// For manipulating application specific timeout settings.
// These timers run when there's a request being processed on a connection
// and HTTPAPI has already associated the request with an application.
// Setting a timeout value to zero will cause HTTPAPI to revert to default.
//

typedef struct _HTTP_TIMEOUT_LIMIT_INFO
{
    HTTP_PROPERTY_FLAGS Flags;

    //
    // Timeouts configured in seconds.
    //

    USHORT EntityBody;
    USHORT DrainEntityBody;
    USHORT RequestQueue;

    //
    // Following two timeouts are only enforced after first request on
    // connection is routed to the application. These will not manipulate
    // the driver wide timeouts.
    //

    USHORT IdleConnection;
    USHORT HeaderWait;

    //
    // Timeouts configured in bytes/second.
    // This timer can be turned off by setting it to MAXULONG.
    //

    ULONG MinSendRate;

} HTTP_TIMEOUT_LIMIT_INFO, *PHTTP_TIMEOUT_LIMIT_INFO;

//
// Controls whether IP-based URLs should listen on the specific IP or wildcard.
//

typedef struct _HTTP_LISTEN_ENDPOINT_INFO
{
    HTTP_PROPERTY_FLAGS Flags;

    BOOLEAN EnableSharing;

} HTTP_LISTEN_ENDPOINT_INFO, *PHTTP_LISTEN_ENDPOINT_INFO;


typedef struct _HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS
{
    USHORT              DomainNameLength;
    PWSTR               DomainName;
    USHORT              RealmLength;
    PWSTR               Realm;
} HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS,
  *PHTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS;

typedef struct _HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS
{
    USHORT      RealmLength;
    PWSTR       Realm;
} HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS,
  *PHTTP_SERVER_AUTHENTICATION_BASIC_PARAMS;

//
// Definitions used for setting server side authentication property.
//

#define HTTP_AUTH_ENABLE_BASIC          (0x00000001)
#define HTTP_AUTH_ENABLE_DIGEST         (0x00000002)
#define HTTP_AUTH_ENABLE_NTLM           (0x00000004)
#define HTTP_AUTH_ENABLE_NEGOTIATE      (0x00000008)
#define HTTP_AUTH_ENABLE_KERBEROS       (0x00000010)

#define HTTP_AUTH_ENABLE_ALL             \
            (HTTP_AUTH_ENABLE_BASIC     |\
             HTTP_AUTH_ENABLE_DIGEST    |\
             HTTP_AUTH_ENABLE_NTLM      |\
             HTTP_AUTH_ENABLE_NEGOTIATE |\
             HTTP_AUTH_ENABLE_KERBEROS)


C_ASSERT(HTTP_AUTH_ENABLE_NEGOTIATE > HTTP_AUTH_ENABLE_NTLM);
C_ASSERT(HTTP_AUTH_ENABLE_NTLM > HTTP_AUTH_ENABLE_DIGEST);
C_ASSERT(HTTP_AUTH_ENABLE_DIGEST > HTTP_AUTH_ENABLE_BASIC);

#define HTTP_AUTH_EX_FLAG_ENABLE_KERBEROS_CREDENTIAL_CACHING  (0x01)
#define HTTP_AUTH_EX_FLAG_CAPTURE_CREDENTIAL                  (0x02)

typedef struct _HTTP_SERVER_AUTHENTICATION_INFO
{
    HTTP_PROPERTY_FLAGS Flags;

    ULONG AuthSchemes;

    BOOLEAN ReceiveMutualAuth;
    BOOLEAN ReceiveContextHandle;
    BOOLEAN DisableNTLMCredentialCaching;

    UCHAR   ExFlags;

    HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS DigestParams;
    HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS  BasicParams;

} HTTP_SERVER_AUTHENTICATION_INFO, *PHTTP_SERVER_AUTHENTICATION_INFO;

//
// Definitions used for setting logging property.
//

//
// The known log fields recognized/supported by HTTPAPI. Following fields
// are used for W3C logging. Subset of them are also used for error
// logging.
//

#define HTTP_LOG_FIELD_DATE                  0x00000001
#define HTTP_LOG_FIELD_TIME                  0x00000002
#define HTTP_LOG_FIELD_CLIENT_IP             0x00000004
#define HTTP_LOG_FIELD_USER_NAME             0x00000008
#define HTTP_LOG_FIELD_SITE_NAME             0x00000010
#define HTTP_LOG_FIELD_COMPUTER_NAME         0x00000020
#define HTTP_LOG_FIELD_SERVER_IP             0x00000040
#define HTTP_LOG_FIELD_METHOD                0x00000080
#define HTTP_LOG_FIELD_URI_STEM              0x00000100
#define HTTP_LOG_FIELD_URI_QUERY             0x00000200
#define HTTP_LOG_FIELD_STATUS                0x00000400
#define HTTP_LOG_FIELD_WIN32_STATUS          0x00000800
#define HTTP_LOG_FIELD_BYTES_SENT            0x00001000
#define HTTP_LOG_FIELD_BYTES_RECV            0x00002000
#define HTTP_LOG_FIELD_TIME_TAKEN            0x00004000
#define HTTP_LOG_FIELD_SERVER_PORT           0x00008000
#define HTTP_LOG_FIELD_USER_AGENT            0x00010000
#define HTTP_LOG_FIELD_COOKIE                0x00020000
#define HTTP_LOG_FIELD_REFERER               0x00040000
#define HTTP_LOG_FIELD_VERSION               0x00080000
#define HTTP_LOG_FIELD_HOST                  0x00100000
#define HTTP_LOG_FIELD_SUB_STATUS            0x00200000

//
// Fields that are used only for error logging.
//

#define HTTP_LOG_FIELD_CLIENT_PORT           0x00400000
#define HTTP_LOG_FIELD_URI                   0x00800000
#define HTTP_LOG_FIELD_SITE_ID               0x01000000
#define HTTP_LOG_FIELD_REASON                0x02000000
#define HTTP_LOG_FIELD_QUEUE_NAME            0x04000000

//
// Defines the logging type.
//

typedef enum _HTTP_LOGGING_TYPE
{
    HttpLoggingTypeW3C,
    HttpLoggingTypeIIS,
    HttpLoggingTypeNCSA,
    HttpLoggingTypeRaw

} HTTP_LOGGING_TYPE, *PHTTP_LOGGING_TYPE;

//
// Defines the rollover type for log files.
//

typedef enum _HTTP_LOGGING_ROLLOVER_TYPE
{
    HttpLoggingRolloverSize,
    HttpLoggingRolloverDaily,
    HttpLoggingRolloverWeekly,
    HttpLoggingRolloverMonthly,
    HttpLoggingRolloverHourly

} HTTP_LOGGING_ROLLOVER_TYPE, *PHTTP_LOGGING_ROLLOVER_TYPE;

//
// Log file rollover size can not be set lower than the following
// limit. The value is in bytes.
//

#define HTTP_MIN_ALLOWED_LOG_FILE_ROLLOVER_SIZE ((ULONG)(1 * 1024 * 1024))

//
// Logging option flags. When used in the logging configuration alters
// some default logging behaviour.
//
// HTTP_LOGGING_FLAG_LOCAL_TIME_ROLLOVER - This flag is used to change
//      the log file rollover to happen by local time based. By default
//      log file rollovers happen by GMT time.
//
// HTTP_LOGGING_FLAG_USE_UTF8_CONVERSION - When set the unicode fields
//      will be converted to UTF8 multibytes when writting to the log
//      files. When this flag is not present, the local code page
//      conversion happens.
//
// HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY -
// HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY - These two flags are used to
//      to do selective logging. If neither of them are present both
//      types of requests will be logged. Only one these flags can be
//      set at a time. They are mutually exclusive.
//

#define HTTP_LOGGING_FLAG_LOCAL_TIME_ROLLOVER         (0x00000001)
#define HTTP_LOGGING_FLAG_USE_UTF8_CONVERSION         (0x00000002)
#define HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY             (0x00000004)
#define HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY            (0x00000008)

//
// Configuration structure used for setting the logging property.
//

typedef struct _HTTP_LOGGING_INFO
{
    //
    // Specifies whether this property exists or not.
    //

    HTTP_PROPERTY_FLAGS Flags;

    //
    // Optional logging flags.
    //

    ULONG LoggingFlags;

    //
    // Optional informatonal software directive string for W3C type logging. Not
    // used for other types of logging. If nothing is provided here HTTPAPI will
    // log a default string. Any arbitrary string could be used here to identify
    // the application. Length cannot be greater than MAX_PATH. Lenght is in
    // bytes.
    //

    PCWSTR SoftwareName;
    USHORT SoftwareNameLength;

    //
    // Log file directory must be a fully qualified path.
    // Length must be in number of bytes.
    //

    USHORT DirectoryNameLength;
    PCWSTR DirectoryName;

    //
    // Specifies the format for the log files.
    //

    HTTP_LOGGING_TYPE Format;

    //
    // Bitmask value indicates which fields to be logged
    // if the log format is set to W3C. This must be the 'bitwise or'
    // of the HTTP_LOG_FIELD_... values.
    //

    ULONG Fields;

    //
    // Following fields are reserved they must be NULL and zero..
    //

    PVOID pExtFields;
    USHORT NumOfExtFields;

    //
    // Reserved must be zero.
    //

    USHORT MaxRecordSize;

    //
    // Defines the rollover type for the log files.
    //

    HTTP_LOGGING_ROLLOVER_TYPE RolloverType;

    //
    // Indicates the maximum size (in bytes) after which
    // the log files should be rolled over. A value of -1
    // (HTTP_LIMIT_INFINITE) indicates an unlimited size.
    // This value is discarded if rollover type is not set to
    // HttpLoggingRolloverSize.
    //

    ULONG RolloverSize;

    //
    // Specifies the security descriptor to be applied to
    // the log files and the sub-directories. If null we will
    // inherit the system default. This security descriptor must
    // be self-relative.
    //

    PSECURITY_DESCRIPTOR pSecurityDescriptor;

} HTTP_LOGGING_INFO, *PHTTP_LOGGING_INFO;

//
// Binding information.
//

typedef struct _HTTP_BINDING_INFO
{
    HTTP_PROPERTY_FLAGS Flags;
    HANDLE RequestQueueHandle;

} HTTP_BINDING_INFO, *PHTTP_BINDING_INFO;

//
// Definitions for request queue manipulation.
//
// These flags are used with HttpCreateRequestQueue() API.
//
// HTTP_CREATE_REQUEST_QUEUE_FLAG_OPEN_EXISTING - To open an existing request
// queue. The request queue name must be supplied.
//
// HTTP_CREATE_REQUEST_QUEUE_FLAG_CONTROLLER - Creates the request queue and
// marks that the caller process is not willing to do send/receive (HTTP I/O)on
// the handle directly.
//

#define HTTP_CREATE_REQUEST_QUEUE_FLAG_OPEN_EXISTING       (0x00000001)
#define HTTP_CREATE_REQUEST_QUEUE_FLAG_CONTROLLER          (0x00000002)

#endif // _WIN32_WINNT >= 0x0600

//
// Flags for HttpReceiveHttpRequest().
//
// HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY - Specifies that the caller would like
// any available entity body to be copied along with the protocol headers.
//
// HTTP_RECEIVE_REQUEST_FLAG_FLUSH_BODY - Specifies that the caller would like
// all of the entity bodies to be copied along with the protocol headers.
//

#define HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY         0x00000001
#define HTTP_RECEIVE_REQUEST_FLAG_FLUSH_BODY        0x00000002


#if _WIN32_WINNT >= 0x0600

//
// Flags for HttpReceiveRequestEntityBody().
//
// HTTP_RECEIVE_REQUEST_ENTITY_BODY_FLAG_FILL_BUFFER - Specifies that the
// caller would like the buffer to get filled up with entity bodies unless
// there are no more entity bodies to be copied.
//

#define HTTP_RECEIVE_REQUEST_ENTITY_BODY_FLAG_FILL_BUFFER   0x00000001

#endif // _WIN32_WINNT >= 0x0600


//
// Flags for HttpSendHttpResponse() and HttpSendResponseEntityBody().
//
// HTTP_SEND_RESPONSE_FLAG_DISCONNECT - Specifies that the network connection
// should be disconnected immediately after sending the response, overriding
// the HTTP protocol's persistent connection features, such as
// "Connection: keep-alive".
//
// HTTP_SEND_RESPONSE_FLAG_MORE_DATA - Specifies that additional entity body
// data will be sent by the caller.
//
// HTTP_SEND_RESPONSE_FLAG_BUFFER_DATA - Specifies that a caller wants the
// response to complete as soon as possible at the cost of buffering partial
// or the entire response.
//
// HTTP_SEND_RESPONSE_FLAG_ENABLE_NAGLING - Specifies that a caller wants to
// enable the TCP nagling algorithm for this particular send.
//

#define HTTP_SEND_RESPONSE_FLAG_DISCONNECT          0x00000001
#define HTTP_SEND_RESPONSE_FLAG_MORE_DATA           0x00000002
#define HTTP_SEND_RESPONSE_FLAG_BUFFER_DATA         0x00000004
#define HTTP_SEND_RESPONSE_FLAG_ENABLE_NAGLING      0x00000008


//
// Flags for HttpFlushResponseCache().
//
// HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE - Flushes the specified URL and all
// hierarchally-related sub-URLs from the response or fragment cache.
//

#define HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE          0x00000001


//
// Opaque identifiers for various HTTPAPI objects.
//

typedef ULONGLONG      HTTP_OPAQUE_ID,         *PHTTP_OPAQUE_ID;

typedef HTTP_OPAQUE_ID HTTP_REQUEST_ID,        *PHTTP_REQUEST_ID;
typedef HTTP_OPAQUE_ID HTTP_CONNECTION_ID,     *PHTTP_CONNECTION_ID;
typedef HTTP_OPAQUE_ID HTTP_RAW_CONNECTION_ID, *PHTTP_RAW_CONNECTION_ID;

#if _WIN32_WINNT >= 0x0600

typedef HTTP_OPAQUE_ID HTTP_URL_GROUP_ID,      *PHTTP_URL_GROUP_ID;
typedef HTTP_OPAQUE_ID HTTP_SERVER_SESSION_ID, *PHTTP_SERVER_SESSION_ID;

#endif // _WIN32_WINNT >= 0x0600

//
// Macros for opaque identifier manipulations.
//

#define HTTP_NULL_ID            (0ui64)
#define HTTP_IS_NULL_ID(pid)    (HTTP_NULL_ID == *(pid))
#define HTTP_SET_NULL_ID(pid)   (*(pid) = HTTP_NULL_ID)

//
// This structure defines a file byte range.
//
// If the Length field is HTTP_BYTE_RANGE_TO_EOF then the remainder of the
// file (everything after StartingOffset) is sent.
//

#define HTTP_BYTE_RANGE_TO_EOF ((ULONGLONG)-1)

typedef struct _HTTP_BYTE_RANGE
{
    ULARGE_INTEGER StartingOffset;
    ULARGE_INTEGER Length;

} HTTP_BYTE_RANGE, *PHTTP_BYTE_RANGE;

//
// The type for HTTP protocol version numbers.
//

typedef struct _HTTP_VERSION
{
    USHORT MajorVersion;
    USHORT MinorVersion;

} HTTP_VERSION, *PHTTP_VERSION;

//
// Some useful macros for HTTP protocol version manipulation.
//

#define HTTP_VERSION_UNKNOWN    { 0, 0 }
#define HTTP_VERSION_0_9        { 0, 9 }
#define HTTP_VERSION_1_0        { 1, 0 }
#define HTTP_VERSION_1_1        { 1, 1 }

#define HTTP_SET_VERSION(version, major, minor)             \
do {                                                        \
    (version).MajorVersion = (major);                       \
    (version).MinorVersion = (minor);                       \
} while (0, 0)

#define HTTP_EQUAL_VERSION(version, major, minor)           \
    ((version).MajorVersion == (major) &&                   \
     (version).MinorVersion == (minor))

#define HTTP_GREATER_VERSION(version, major, minor)         \
    ((version).MajorVersion > (major) ||                    \
     ((version).MajorVersion == (major) &&                  \
      (version).MinorVersion > (minor)))

#define HTTP_LESS_VERSION(version, major, minor)            \
    ((version).MajorVersion < (major) ||                    \
     ((version).MajorVersion == (major) &&                  \
      (version).MinorVersion < (minor)))

#define HTTP_NOT_EQUAL_VERSION(version, major, minor)       \
    (!HTTP_EQUAL_VERSION(version, major, minor))

#define HTTP_GREATER_EQUAL_VERSION(version, major, minor)   \
    (!HTTP_LESS_VERSION(version, major, minor))

#define HTTP_LESS_EQUAL_VERSION(version, major, minor)      \
    (!HTTP_GREATER_VERSION(version, major, minor))

//
// The enum type for HTTP verbs.
//

typedef enum _HTTP_VERB
{
    HttpVerbUnparsed,
    HttpVerbUnknown,
    HttpVerbInvalid,
    HttpVerbOPTIONS,
    HttpVerbGET,
    HttpVerbHEAD,
    HttpVerbPOST,
    HttpVerbPUT,
    HttpVerbDELETE,
    HttpVerbTRACE,
    HttpVerbCONNECT,
    HttpVerbTRACK,  // used by Microsoft Cluster Server for a non-logged trace
    HttpVerbMOVE,
    HttpVerbCOPY,
    HttpVerbPROPFIND,
    HttpVerbPROPPATCH,
    HttpVerbMKCOL,
    HttpVerbLOCK,
    HttpVerbUNLOCK,
    HttpVerbSEARCH,

    HttpVerbMaximum

} HTTP_VERB, *PHTTP_VERB;

//
// Symbols for all HTTP/1.1 headers and other tokens. Notice request +
// response values overlap. Make sure you know which type of header array
// you are indexing.
//
// These values are used as offsets into arrays and as token values in
// HTTP_KNOWN_HEADER arrays in HTTP_REQUEST_HEADERS and HTTP_RESPONSE_HEADERS.
//
// See RFC 2616, HTTP/1.1, for further explanation of most of these headers.
//

typedef enum _HTTP_HEADER_ID
{
    HttpHeaderCacheControl          = 0,    // general-header [section 4.5]
    HttpHeaderConnection            = 1,    // general-header [section 4.5]
    HttpHeaderDate                  = 2,    // general-header [section 4.5]
    HttpHeaderKeepAlive             = 3,    // general-header [not in rfc]
    HttpHeaderPragma                = 4,    // general-header [section 4.5]
    HttpHeaderTrailer               = 5,    // general-header [section 4.5]
    HttpHeaderTransferEncoding      = 6,    // general-header [section 4.5]
    HttpHeaderUpgrade               = 7,    // general-header [section 4.5]
    HttpHeaderVia                   = 8,    // general-header [section 4.5]
    HttpHeaderWarning               = 9,    // general-header [section 4.5]

    HttpHeaderAllow                 = 10,   // entity-header  [section 7.1]
    HttpHeaderContentLength         = 11,   // entity-header  [section 7.1]
    HttpHeaderContentType           = 12,   // entity-header  [section 7.1]
    HttpHeaderContentEncoding       = 13,   // entity-header  [section 7.1]
    HttpHeaderContentLanguage       = 14,   // entity-header  [section 7.1]
    HttpHeaderContentLocation       = 15,   // entity-header  [section 7.1]
    HttpHeaderContentMd5            = 16,   // entity-header  [section 7.1]
    HttpHeaderContentRange          = 17,   // entity-header  [section 7.1]
    HttpHeaderExpires               = 18,   // entity-header  [section 7.1]
    HttpHeaderLastModified          = 19,   // entity-header  [section 7.1]


    // Request Headers

    HttpHeaderAccept                = 20,   // request-header [section 5.3]
    HttpHeaderAcceptCharset         = 21,   // request-header [section 5.3]
    HttpHeaderAcceptEncoding        = 22,   // request-header [section 5.3]
    HttpHeaderAcceptLanguage        = 23,   // request-header [section 5.3]
    HttpHeaderAuthorization         = 24,   // request-header [section 5.3]
    HttpHeaderCookie                = 25,   // request-header [not in rfc]
    HttpHeaderExpect                = 26,   // request-header [section 5.3]
    HttpHeaderFrom                  = 27,   // request-header [section 5.3]
    HttpHeaderHost                  = 28,   // request-header [section 5.3]
    HttpHeaderIfMatch               = 29,   // request-header [section 5.3]

    HttpHeaderIfModifiedSince       = 30,   // request-header [section 5.3]
    HttpHeaderIfNoneMatch           = 31,   // request-header [section 5.3]
    HttpHeaderIfRange               = 32,   // request-header [section 5.3]
    HttpHeaderIfUnmodifiedSince     = 33,   // request-header [section 5.3]
    HttpHeaderMaxForwards           = 34,   // request-header [section 5.3]
    HttpHeaderProxyAuthorization    = 35,   // request-header [section 5.3]
    HttpHeaderReferer               = 36,   // request-header [section 5.3]
    HttpHeaderRange                 = 37,   // request-header [section 5.3]
    HttpHeaderTe                    = 38,   // request-header [section 5.3]
    HttpHeaderTranslate             = 39,   // request-header [webDAV, not in rfc 2518]

    HttpHeaderUserAgent             = 40,   // request-header [section 5.3]

    HttpHeaderRequestMaximum        = 41,


    // Response Headers

    HttpHeaderAcceptRanges          = 20,   // response-header [section 6.2]
    HttpHeaderAge                   = 21,   // response-header [section 6.2]
    HttpHeaderEtag                  = 22,   // response-header [section 6.2]
    HttpHeaderLocation              = 23,   // response-header [section 6.2]
    HttpHeaderProxyAuthenticate     = 24,   // response-header [section 6.2]
    HttpHeaderRetryAfter            = 25,   // response-header [section 6.2]
    HttpHeaderServer                = 26,   // response-header [section 6.2]
    HttpHeaderSetCookie             = 27,   // response-header [not in rfc]
    HttpHeaderVary                  = 28,   // response-header [section 6.2]
    HttpHeaderWwwAuthenticate       = 29,   // response-header [section 6.2]

    HttpHeaderResponseMaximum       = 30,


    HttpHeaderMaximum               = 41

} HTTP_HEADER_ID, *PHTTP_HEADER_ID;


//
// Structure defining format of a known HTTP header.
// Name is from HTTP_HEADER_ID.
//

typedef struct _HTTP_KNOWN_HEADER
{
    USHORT RawValueLength;     // in bytes not including the NUL
    PCSTR  pRawValue;

} HTTP_KNOWN_HEADER, *PHTTP_KNOWN_HEADER;

//
// Structure defining format of an unknown header.
//

typedef struct _HTTP_UNKNOWN_HEADER
{
    USHORT NameLength;          // in bytes not including the NUL
    USHORT RawValueLength;      // in bytes not including the NUL
    PCSTR  pName;               // The header name (minus the ':' character)
    PCSTR  pRawValue;           // The header value

} HTTP_UNKNOWN_HEADER, *PHTTP_UNKNOWN_HEADER;

#if _WIN32_WINNT >= 0x0600

//
// Log fields data structure is used for logging a request. This structure must
// be provided along with an HttpSendHttpResponse or HttpSendResponseEntityBody
// call that concludes the send.
//

// Base structure is for future versioning.

typedef enum _HTTP_LOG_DATA_TYPE
{
    HttpLogDataTypeFields = 0

} HTTP_LOG_DATA_TYPE, *PHTTP_LOG_DATA_TYPE;

// should we DECLSPEC_ALIGN(4 or 8) == DECLSPEC_POINTERALIGN?
typedef struct _HTTP_LOG_DATA
{
    HTTP_LOG_DATA_TYPE Type;

} HTTP_LOG_DATA, *PHTTP_LOG_DATA;

// Current log fields data structure for of type HttpLogDataTypeFields.

typedef struct _HTTP_LOG_FIELDS_DATA
{
    HTTP_LOG_DATA Base;

    USHORT UserNameLength;
    USHORT UriStemLength;
    USHORT ClientIpLength;
    USHORT ServerNameLength;
    USHORT ServiceNameLength;
    USHORT ServerIpLength;
    USHORT MethodLength;
    USHORT UriQueryLength;
    USHORT HostLength;
    USHORT UserAgentLength;
    USHORT CookieLength;
    USHORT ReferrerLength;

    PWCHAR UserName;
    PWCHAR UriStem;
    PCHAR  ClientIp;
    PCHAR  ServerName;
    PCHAR  ServiceName;
    PCHAR  ServerIp;
    PCHAR  Method;
    PCHAR  UriQuery;
    PCHAR  Host;
    PCHAR  UserAgent;
    PCHAR  Cookie;
    PCHAR  Referrer;

    USHORT ServerPort;
    USHORT ProtocolStatus;

    ULONG  Win32Status;

    HTTP_VERB MethodNum;

    USHORT SubStatus;

} HTTP_LOG_FIELDS_DATA, *PHTTP_LOG_FIELDS_DATA;

#endif // _WIN32_WINNT >= 0x0600

//
// This enum defines a data source for a particular chunk of data.
//

typedef enum _HTTP_DATA_CHUNK_TYPE
{
    HttpDataChunkFromMemory,
    HttpDataChunkFromFileHandle,
    HttpDataChunkFromFragmentCache,
    HttpDataChunkFromFragmentCacheEx,

    HttpDataChunkMaximum

} HTTP_DATA_CHUNK_TYPE, *PHTTP_DATA_CHUNK_TYPE;


//
// This structure describes an individual data chunk.
//

typedef struct _HTTP_DATA_CHUNK
{
    //
    // The type of this data chunk.
    //

    HTTP_DATA_CHUNK_TYPE DataChunkType;

    //
    // The data chunk structures, one per supported data chunk type.
    //

    union
    {
        //
        // From-memory data chunk.
        //

        struct
        {
            PVOID pBuffer;
            ULONG BufferLength;

        } FromMemory;

        //
        // From-file handle data chunk.
        //

        struct
        {
            HTTP_BYTE_RANGE ByteRange;
            HANDLE          FileHandle;

        } FromFileHandle;

        //
        // From-fragment cache data chunk.
        //

        struct
        {
            USHORT FragmentNameLength;      // in bytes not including the NUL
            PCWSTR pFragmentName;

        } FromFragmentCache;

        //
        // From-fragment cache data chunk that specifies a byte range.
        //

        struct
        {
            HTTP_BYTE_RANGE ByteRange;
            PCWSTR pFragmentName;           // NULL-terminated string

        } FromFragmentCacheEx;

    };

} HTTP_DATA_CHUNK, *PHTTP_DATA_CHUNK;

//
// HTTP API doesn't support 16 bit applications.
// Neither WIN32 nor _WIN64 was defined.
//

C_ASSERT(TYPE_ALIGNMENT(HTTP_DATA_CHUNK) == sizeof(ULONGLONG));

//
// Structure defining format of request headers.
//

typedef struct _HTTP_REQUEST_HEADERS
{
    //
    // The array of unknown HTTP headers and the number of
    // entries in the array.
    //

    USHORT               UnknownHeaderCount;
    PHTTP_UNKNOWN_HEADER pUnknownHeaders;

    //
    // Trailers - we don't use these currently, reserved for a future release
    //
    USHORT               TrailerCount;   // Reserved, must be 0
    PHTTP_UNKNOWN_HEADER pTrailers;      // Reserved, must be NULL


    //
    // Known headers.
    //

    HTTP_KNOWN_HEADER    KnownHeaders[HttpHeaderRequestMaximum];

} HTTP_REQUEST_HEADERS, *PHTTP_REQUEST_HEADERS;

//
// Structure defining format of response headers.
//

typedef struct _HTTP_RESPONSE_HEADERS
{
    //
    // The array of unknown HTTP headers and the number of
    // entries in the array.
    //

    USHORT               UnknownHeaderCount;
    PHTTP_UNKNOWN_HEADER pUnknownHeaders;

    //
    // Trailers - we don't use these currently, reserved for a future release
    //
    USHORT               TrailerCount;   // Reserved, must be 0
    PHTTP_UNKNOWN_HEADER pTrailers;      // Reserved, must be NULL

    //
    // Known headers.
    //

    HTTP_KNOWN_HEADER    KnownHeaders[HttpHeaderResponseMaximum];

} HTTP_RESPONSE_HEADERS, *PHTTP_RESPONSE_HEADERS;

//
// Structure defining format of transport address. Use pLocalAddress->sa_family
// to determine whether this is an IPv4 address (AF_INET) or IPv6 (AF_INET6).
//
// pRemoteAddress->sa_family will be the same as pLocalAddress->sa_family.
//
// SOCKADDRs are always in network order, not host order.
//

typedef struct _HTTP_TRANSPORT_ADDRESS
{
    PSOCKADDR      pRemoteAddress;
    PSOCKADDR      pLocalAddress;

} HTTP_TRANSPORT_ADDRESS, *PHTTP_TRANSPORT_ADDRESS;

//
// Structure defining format of cooked URL.
//

typedef struct _HTTP_COOKED_URL
{
    //
    // Pointers overlap and point into pFullUrl. NULL if not present.
    //

    USHORT FullUrlLength;       // in bytes not including the NUL
    USHORT HostLength;          // in bytes (no NUL)
    USHORT AbsPathLength;       // in bytes (no NUL)
    USHORT QueryStringLength;   // in bytes (no NUL)

    PCWSTR pFullUrl;     // points to "http://hostname:port/abs/.../path?query"
    PCWSTR pHost;        // points to the first char in the hostname
    PCWSTR pAbsPath;     // Points to the 3rd '/' char
    PCWSTR pQueryString; // Points to the 1st '?' char or NULL

} HTTP_COOKED_URL, *PHTTP_COOKED_URL;

//
// An opaque context for URL manipulation.
//

typedef ULONGLONG HTTP_URL_CONTEXT;


#if _WIN32_WINNT >= 0x0600

//
// Optional flags for URL manipulation functions.
//
// HTTP_URL_FLAG_REMOVE_ALL : When this flag is used
// when removing a Url from a url group, regardless of
// the passed URL, all of the Urls from the url group
// will be removed.
//

#define HTTP_URL_FLAG_REMOVE_ALL                0x00000001


//
// Request Authentication related.
//

typedef enum _HTTP_AUTH_STATUS
{
    HttpAuthStatusSuccess,
    HttpAuthStatusNotAuthenticated,
    HttpAuthStatusFailure

} HTTP_AUTH_STATUS, *PHTTP_AUTH_STATUS;


typedef enum _HTTP_REQUEST_AUTH_TYPE
{
    HttpRequestAuthTypeNone = 0,
    HttpRequestAuthTypeBasic,
    HttpRequestAuthTypeDigest,
    HttpRequestAuthTypeNTLM,
    HttpRequestAuthTypeNegotiate,
    HttpRequestAuthTypeKerberos


} HTTP_REQUEST_AUTH_TYPE, *PHTTP_REQUEST_AUTH_TYPE;

#endif // _WIN32_WINNT >= 0x0600

//
// SSL Client certificate information.
//

typedef struct _HTTP_SSL_CLIENT_CERT_INFO
{
    ULONG   CertFlags;
    ULONG   CertEncodedSize;
    PUCHAR  pCertEncoded;
    HANDLE  Token;
    BOOLEAN CertDeniedByMapper;

} HTTP_SSL_CLIENT_CERT_INFO, *PHTTP_SSL_CLIENT_CERT_INFO;

//
// Data computed during SSL handshake.
//

typedef struct _HTTP_SSL_INFO
{
    USHORT ServerCertKeySize;
    USHORT ConnectionKeySize;
    ULONG  ServerCertIssuerSize;
    ULONG  ServerCertSubjectSize;

    PCSTR  pServerCertIssuer;
    PCSTR  pServerCertSubject;

    PHTTP_SSL_CLIENT_CERT_INFO pClientCertInfo;
    ULONG                      SslClientCertNegotiated;

} HTTP_SSL_INFO, *PHTTP_SSL_INFO;


#if _WIN32_WINNT >= 0x0600

//
// Generic request information type.
//

typedef enum _HTTP_REQUEST_INFO_TYPE
{
    HttpRequestInfoTypeAuth

} HTTP_REQUEST_INFO_TYPE, *PHTTP_REQUEST_INFO_TYPE;

typedef struct _HTTP_REQUEST_INFO
{
    HTTP_REQUEST_INFO_TYPE InfoType;
    ULONG                  InfoLength;
    PVOID                  pInfo;

} HTTP_REQUEST_INFO, *PHTTP_REQUEST_INFO;

#ifndef __SECSTATUS_DEFINED__
typedef LONG SECURITY_STATUS;
#define __SECSTATUS_DEFINED__
#endif // __SECSTATUS_DEFINED__

//
// Authentication request info structure
//

#define HTTP_REQUEST_AUTH_FLAG_TOKEN_FOR_CACHED_CRED (0x00000001)

typedef struct _HTTP_REQUEST_AUTH_INFO
{
    HTTP_AUTH_STATUS AuthStatus;
    SECURITY_STATUS  SecStatus;

    ULONG Flags;

    HTTP_REQUEST_AUTH_TYPE AuthType;

    HANDLE AccessToken;
    ULONG ContextAttributes;

    //
    // Optional serialized context.
    //

    ULONG PackedContextLength;
    ULONG PackedContextType;
    PVOID PackedContext;

    //
    // Optional mutual authentication data and its length in bytes.
    //

    ULONG MutualAuthDataLength;
    PCHAR pMutualAuthData;

    //
    // For SSPI based schemes the package name is returned. Length does
    // not include the terminating null and it is in bytes.
    //

    USHORT PackageNameLength;
    PWSTR pPackageName;

} HTTP_REQUEST_AUTH_INFO, *PHTTP_REQUEST_AUTH_INFO;

#endif // _WIN32_WINNT >= 0x0600

//
// The structure of an HTTP request for downlevel OS
//

typedef struct _HTTP_REQUEST_V1
{
    //
    // Request flags (see HTTP_REQUEST_FLAG_* definitions below).
    //

    ULONG Flags;

    //
    // An opaque request identifier. These values are used by the driver
    // to correlate outgoing responses with incoming requests.
    //

    HTTP_CONNECTION_ID ConnectionId;
    HTTP_REQUEST_ID    RequestId;

    //
    // The context associated with the URL prefix.
    //

    HTTP_URL_CONTEXT UrlContext;

    //
    // The HTTP version number.
    //

    HTTP_VERSION Version;

    //
    // The request verb.
    //

    HTTP_VERB Verb;

    //
    // The length of the verb string if the Verb field is HttpVerbUnknown.
    //

    USHORT UnknownVerbLength;           // in bytes not including the NUL

    //
    // The length of the raw (uncooked) URL
    //

    USHORT RawUrlLength;                // in bytes not including the NUL

    //
    // Pointer to the verb string if the Verb field is HttpVerbUnknown.
    //

    PCSTR  pUnknownVerb;

    //
    // Pointer to the raw (uncooked) URL
    //

    PCSTR  pRawUrl;

    //
    // The canonicalized Unicode URL
    //

    HTTP_COOKED_URL CookedUrl;

    //
    // Local and remote transport addresses for the connection.
    //

    HTTP_TRANSPORT_ADDRESS Address;

    //
    // The request headers.
    //

    HTTP_REQUEST_HEADERS Headers;

    //
    // The total number of bytes received from network for this request.
    //

    ULONGLONG BytesReceived;

    //
    // pEntityChunks is an array of EntityChunkCount HTTP_DATA_CHUNKs. The
    // entity body is copied only if HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY
    // was passed to HttpReceiveHttpRequest().
    //

    USHORT           EntityChunkCount;
    PHTTP_DATA_CHUNK pEntityChunks;

    //
    // SSL connection information.
    //

    HTTP_RAW_CONNECTION_ID RawConnectionId;
    PHTTP_SSL_INFO         pSslInfo;

} HTTP_REQUEST_V1, *PHTTP_REQUEST_V1;

#if _WIN32_WINNT >= 0x0600

// Longhorn

//
// Version 2.0 members are defined here
// N.B. One must define V2 elements in two places :(
//      This is due to the fact that C++ doesn't allow anonymous
//      structure declarations and one must use structure
//      inheritance instead.
//

#ifdef __cplusplus

typedef struct _HTTP_REQUEST_V2 : _HTTP_REQUEST_V1
{
    //
    // Version 1.0 members are inherited
    // Version 2.0 members are declared below
    //

    //
    // Additional Request Informations.
    //

    USHORT             RequestInfoCount;
    PHTTP_REQUEST_INFO pRequestInfo;
} HTTP_REQUEST_V2, *PHTTP_REQUEST_V2;

#else // __cplusplus

typedef struct _HTTP_REQUEST_V2
{
    struct _HTTP_REQUEST_V1;        // Anonymous structure

    //
    // Version 2.0 members are declared below
    //

    //
    // Additional Request Informations.
    //

    USHORT             RequestInfoCount;
    PHTTP_REQUEST_INFO pRequestInfo;
} HTTP_REQUEST_V2, *PHTTP_REQUEST_V2;

#endif  // __cplusplus

typedef HTTP_REQUEST_V2 HTTP_REQUEST;

#else // _WIN32_WINNT >= 0x0600

typedef HTTP_REQUEST_V1 HTTP_REQUEST;

#endif  // _WIN32_WINNT >= 0x0600

typedef HTTP_REQUEST * PHTTP_REQUEST;


//
// Values for HTTP_REQUEST::Flags. Zero or more of these may be ORed together.
//
// HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS - there is more entity body
// to be read for this request. Otherwise, there is no entity body or
// all of the entity body was copied into pEntityChunks.
// HTTP_REQUEST_FLAG_IP_ROUTED - This flag indicates that the request has been
// routed based on host plus ip or ip binding.This is a hint for the application
// to include the local ip while flushing kernel cache entries build for this
// request if any.
//

#define HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS   0x00000001
#define HTTP_REQUEST_FLAG_IP_ROUTED                 0x00000002


//
// This structure describes an HTTP response.
//

typedef struct _HTTP_RESPONSE_V1
{
    //
    // Response flags (see HTTP_RESPONSE_FLAG_* definitions below).
    //

    ULONG Flags;

    //
    // The raw HTTP protocol version number.
    //

    HTTP_VERSION Version;

    //
    // The HTTP status code (e.g., 200).
    //

    USHORT StatusCode;

    //
    // The HTTP reason (e.g., "OK"). This MUST not contain
    // non-ASCII characters (i.e., all chars must be in range 0x20-0x7E).
    //

    USHORT ReasonLength;                 // in bytes not including the '\0'
    PCSTR  pReason;

    //
    // The response headers.
    //

    HTTP_RESPONSE_HEADERS Headers;

    //
    // pEntityChunks points to an array of EntityChunkCount HTTP_DATA_CHUNKs.
    //

    USHORT           EntityChunkCount;
    PHTTP_DATA_CHUNK pEntityChunks;

} HTTP_RESPONSE_V1, *PHTTP_RESPONSE_V1;

#if _WIN32_WINNT >= 0x0600

// Longhorn

typedef enum _HTTP_RESPONSE_INFO_TYPE
{
    HttpResponseInfoTypeMultipleKnownHeaders,
    HttpResponseInfoTypeAuthenticationProperty
} HTTP_RESPONSE_INFO_TYPE, PHTTP_RESPONSE_INFO_TYPE;

typedef struct _HTTP_RESPONSE_INFO
{
    HTTP_RESPONSE_INFO_TYPE Type;
    ULONG                   Length;
    PVOID                   pInfo;
} HTTP_RESPONSE_INFO, *PHTTP_RESPONSE_INFO;

#define HTTP_RESPONSE_INFO_FLAGS_PRESERVE_ORDER         0x00000001

//
// This structure allows the provision of providing multiple known headers.
//

typedef struct _HTTP_MULTIPLE_KNOWN_HEADERS
{
    //
    // Known header id.
    //

    HTTP_HEADER_ID      HeaderId;

    ULONG               Flags;

    //
    // Number of headers of the same category.
    //

    USHORT              KnownHeaderCount;

    //
    // Array of known header structures.
    //

    PHTTP_KNOWN_HEADER  KnownHeaders;

} HTTP_MULTIPLE_KNOWN_HEADERS, *PHTTP_MULTIPLE_KNOWN_HEADERS;

//
// Version 2.0 members are defined here
// N.B. One must define V2 elements in two places :(
//      This is due to the fact that C++ doesn't allow anonymous
//      structure declarations and one must use structure
//      inheritance instead.
//

#ifdef __cplusplus

typedef struct _HTTP_RESPONSE_V2 : _HTTP_RESPONSE_V1
{
    //
    // Version 1.0 members are inherited
    // Version 2.0 members are declared below
    //

    USHORT ResponseInfoCount;
    PHTTP_RESPONSE_INFO pResponseInfo;

} HTTP_RESPONSE_V2, *PHTTP_RESPONSE_V2;

#else // __cplusplus

typedef struct _HTTP_RESPONSE_V2
{
    struct _HTTP_RESPONSE_V1;

    //
    // Version 2.0 members are declared below
    //

    USHORT ResponseInfoCount;
    PHTTP_RESPONSE_INFO pResponseInfo;
} HTTP_RESPONSE_V2, *PHTTP_RESPONSE_V2;

#endif  // __cplusplus

typedef HTTP_RESPONSE_V2 HTTP_RESPONSE;

#else // _WIN32_WINNT >= 0x0600

typedef HTTP_RESPONSE_V1 HTTP_RESPONSE;

#endif  // _WIN32_WINNT >= 0x0600

typedef HTTP_RESPONSE *PHTTP_RESPONSE;

//
// Api Version. This is used to ensure compatibility between applications and
// httpapi.dll and http.sys.
//
// This must not be confused with the HTTP Protocol version.
//

typedef struct _HTTPAPI_VERSION
{
    USHORT HttpApiMajorVersion;
    USHORT HttpApiMinorVersion;

} HTTPAPI_VERSION, *PHTTPAPI_VERSION;


#if _WIN32_WINNT >= 0x0600

// Longhorn

#define HTTPAPI_VERSION_2 { 2, 0 }

#endif // _WIN32_WINNT >= 0x0600

#define HTTPAPI_VERSION_1 { 1, 0 }

#define HTTPAPI_EQUAL_VERSION(version, major, minor)                \
    ((version).HttpApiMajorVersion == (major) &&                    \
     (version).HttpApiMinorVersion == (minor))

#define HTTPAPI_GREATER_VERSION(version, major, minor)              \
    ((version).HttpApiMajorVersion > (major) ||                     \
     ((version).HttpApiMajorVersion == (major) &&                   \
      (version).HttpApiMinorVersion > (minor)))

#define HTTPAPI_LESS_VERSION(version, major, minor)                 \
    ((version).HttpApiMajorVersion < (major) ||                     \
     ((version).HttpApiMajorVersion == (major) &&                   \
      (version).HttpApiMinorVersion < (minor)))

#define HTTPAPI_VERSION_GREATER_OR_EQUAL( version, major, minor)    \
    (!HTTPAPI_LESS_VERSION(version, major, minor))


//
// Cache control.
//

//
// This enum defines the available cache policies.
//

typedef enum _HTTP_CACHE_POLICY_TYPE
{
    HttpCachePolicyNocache,
    HttpCachePolicyUserInvalidates,
    HttpCachePolicyTimeToLive,

    HttpCachePolicyMaximum

} HTTP_CACHE_POLICY_TYPE, *PHTTP_CACHE_POLICY_TYPE;


//
//  Only cache unauthorized GETs + HEADs.
//

typedef struct _HTTP_CACHE_POLICY
{
    HTTP_CACHE_POLICY_TYPE  Policy;
    ULONG                   SecondsToLive;

} HTTP_CACHE_POLICY, *PHTTP_CACHE_POLICY;

//
// Enum that is used with HttpSetServiceConfiguration(),
// HttpQueryServiceConfiguration(), and HttpDeleteServiceConfiguration() APIs.
//

typedef enum _HTTP_SERVICE_CONFIG_ID
{
    HttpServiceConfigIPListenList,    // Set, Query & Delete.
    HttpServiceConfigSSLCertInfo,     // Set, Query & Delete.
    HttpServiceConfigUrlAclInfo,      // Set, Query & Delete.
    HttpServiceConfigTimeout,         // Set, Query & Delete.
    HttpServiceConfigMax

} HTTP_SERVICE_CONFIG_ID, *PHTTP_SERVICE_CONFIG_ID;

//
// Generic Query enum that can be used with HttpQueryServiceConfiguration()
//

typedef enum _HTTP_SERVICE_CONFIG_QUERY_TYPE
{
    HttpServiceConfigQueryExact,
    HttpServiceConfigQueryNext,
    HttpServiceConfigQueryMax

} HTTP_SERVICE_CONFIG_QUERY_TYPE, *PHTTP_SERVICE_CONFIG_QUERY_TYPE;

//
// This data structure is used to define a key of the SSL certificate hash
// store.
//

typedef struct _HTTP_SERVICE_CONFIG_SSL_KEY
{
    PSOCKADDR pIpPort;
} HTTP_SERVICE_CONFIG_SSL_KEY, *PHTTP_SERVICE_CONFIG_SSL_KEY;

//
// This defines a record for the SSL config store.
//

typedef struct _HTTP_SERVICE_CONFIG_SSL_PARAM
{
    ULONG SslHashLength;      // Length of the SSL hash (in bytes)
    PVOID pSslHash;           // Pointer to the SSL hash
    GUID  AppId;              // A unique identifier that can be used to
                              // identify the app that has set this parameter

    PWSTR  pSslCertStoreName; // Store name to read the server certificate
                              // from; defaults to "MY". Certificate must be
                              // stored in the LOCAL_MACHINE context.

    //
    // The following settings are used only for client certificates
    //

    //
    // DefaultCertCheckMode is a bit flag with the following semantics
    //  0x1     - Client certificate will not be verified for revocation
    //  0x2     - Only cached certificate revocation will be used.
    //  0x4     - Enable use of the DefaultRevocationFreshnessTime setting
    //  0x10000 - No usage check.

    DWORD  DefaultCertCheckMode;

    //
    // DefaultRevocationFreshnessTime (seconds) - How often to check for
    // an updated Certificate revocation list (CRL). If this value is 0
    // then the new CRL is updated only if the previous one expires
    //

    DWORD  DefaultRevocationFreshnessTime;

    //
    // DefaultRevocationUrlRetrievalTimeout (milliseconds) - Timeout on
    // attempt to retrieve certificate revocation list from the remote URL.
    //

    DWORD  DefaultRevocationUrlRetrievalTimeout;

    //
    // pDefaultSslCtlIdentifier - Restrict the certificate issuers that you
    // want to trust. Can be a subset of the certificate issuers that are
    // trusted by the machine.
    //

    PWSTR  pDefaultSslCtlIdentifier;

    //
    // Store name under LOCAL_MACHINE where Ctl identified by
    // pDefaultSslCtlIdentifier is stored.
    //

    PWSTR  pDefaultSslCtlStoreName;

    //
    // Default Flags - see HTTP_SERVICE_CONFIG_SSL_FLAG* below.
    //

    DWORD  DefaultFlags;

} HTTP_SERVICE_CONFIG_SSL_PARAM, *PHTTP_SERVICE_CONFIG_SSL_PARAM;

#define HTTP_SERVICE_CONFIG_SSL_FLAG_USE_DS_MAPPER         0x00000001
#define HTTP_SERVICE_CONFIG_SSL_FLAG_NEGOTIATE_CLIENT_CERT 0x00000002
#if _WIN32_WINNT < 0x0600
#define HTTP_SERVICE_CONFIG_SSL_FLAG_NO_RAW_FILTER         0x00000004
#endif // _WIN32_WINNT < 0x0600

//
// This data structure is used by HttpSetServiceConfiguration() for the
// config ID HttpServiceConfigSSLCertInfo.  It's used to add a new record
// to the SSL store.
//

typedef struct _HTTP_SERVICE_CONFIG_SSL_SET
{
    HTTP_SERVICE_CONFIG_SSL_KEY   KeyDesc;
    HTTP_SERVICE_CONFIG_SSL_PARAM ParamDesc;
} HTTP_SERVICE_CONFIG_SSL_SET, *PHTTP_SERVICE_CONFIG_SSL_SET;

//
// This data structure is used by HttpQueryServiceConfiguration() for the
// config ID HttpServiceConfigSSLCertInfo. It's used to query a particular
// record from the SSL store.
//
// If QueryType is HttpServiceConfigQueryExact, then one particular record of
// the type HTTP_SERVICE_CONFIG_SSL_SET is returned. If the QueryType is
// HttpServiceConfigQueryNext, then the next instance of
// HTTP_SERVICE_CONFIG_SSL_SET is returned. In such cases, the dwToken field
// represents the cursor. For the first item,  dwToken has to be 0.
// For subsequent items, dwToken has to be incremented by 1,
// until ERROR_NO_MORE_ITEMS is returned.
//

typedef struct _HTTP_SERVICE_CONFIG_SSL_QUERY
{
    HTTP_SERVICE_CONFIG_QUERY_TYPE  QueryDesc;
    HTTP_SERVICE_CONFIG_SSL_KEY     KeyDesc;
    DWORD                           dwToken;
} HTTP_SERVICE_CONFIG_SSL_QUERY, *PHTTP_SERVICE_CONFIG_SSL_QUERY;

//
// Set/Delete IP Listen-Only List record
//
// Used as a parameter to both HttpSetServiceConfiguration() and
// HttpDeleteServiceConfiguration() functions.
//

typedef struct _HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM
{
    USHORT      AddrLength;
    PSOCKADDR   pAddress;
} HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM, *PHTTP_SERVICE_CONFIG_IP_LISTEN_PARAM;

//
// Query IP Listen-Only List record.
//
// Parameter to HttpQueryServiceConfiguration() for the config ID
// HttpServiceConfigIPListenList.  On successful return, AddrList
// contains an array of AddrCount elements.  Caller must provide a
// large enough buffer to hold all elements in one call.
//
// Caller may determine the type of each returned element by examining
// AddrList[i].ss_family. If it's AF_INET, use ((PSOCKADDR_IN) &AddrList[i]);
// otherwise, for AF_INET6, use ((PSOCKADDR_IN6) &AddrList[i])
// to select the appropriate address type.
//

typedef struct _HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY
{
    ULONG              AddrCount;
    SOCKADDR_STORAGE   AddrList[ANYSIZE_ARRAY];
} HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY, *PHTTP_SERVICE_CONFIG_IP_LISTEN_QUERY;

//
// URL ACL
//
//
typedef struct _HTTP_SERVICE_CONFIG_URLACL_KEY
{
    PWSTR pUrlPrefix;

} HTTP_SERVICE_CONFIG_URLACL_KEY, *PHTTP_SERVICE_CONFIG_URLACL_KEY;

//
// This defines a record for the SSL config store.
//

typedef struct _HTTP_SERVICE_CONFIG_URLACL_PARAM
{
    PWSTR pStringSecurityDescriptor;
} HTTP_SERVICE_CONFIG_URLACL_PARAM, *PHTTP_SERVICE_CONFIG_URLACL_PARAM;


//
// This data structure is used by HttpSetServiceConfiguration for the config ID
// HttpServiceConfigUrlAclInfo. It is used to add a new record to the URL ACL
// store.
//

typedef struct _HTTP_SERVICE_CONFIG_URLACL_SET
{
    HTTP_SERVICE_CONFIG_URLACL_KEY   KeyDesc;
    HTTP_SERVICE_CONFIG_URLACL_PARAM ParamDesc;
} HTTP_SERVICE_CONFIG_URLACL_SET, *PHTTP_SERVICE_CONFIG_URLACL_SET;


//
// This data structure is used by HttpQueryServiceConfiguration() for the
// config ID HttpServiceConfigUrlAclInfo. It's used to query a particular
// record from the URL ACL store.
//
// If QueryType is HttpServiceConfigQueryExact, then one particular record of
// the type HTTP_SERVICE_CONFIG_URLACL_SET is returned. If the QueryType is
// HttpServiceConfigQueryNext, then the next instance of
// HTTP_SERVICE_CONFIG_URLACL_SET is returned. In such cases, the dwToken field
// represents the cursor. For the first item,  dwToken has to be 0.
// For subsequent items, dwToken has to be incremented by 1,
// until ERROR_NO_MORE_ITEMS is returned.
//

typedef struct _HTTP_SERVICE_CONFIG_URLACL_QUERY
{
    HTTP_SERVICE_CONFIG_QUERY_TYPE  QueryDesc;
    HTTP_SERVICE_CONFIG_URLACL_KEY  KeyDesc;
    DWORD                           dwToken;
} HTTP_SERVICE_CONFIG_URLACL_QUERY, *PHTTP_SERVICE_CONFIG_URLACL_QUERY;


//
// Define our API linkage.
//

#if !defined(HTTPAPI_LINKAGE)
#define HTTPAPI_LINKAGE DECLSPEC_IMPORT
#endif  // !HTTPAPI_LINKAGE

//
// Initialize/Terminate APIs.
//


// NOTE: MUST be called once before all other APIs

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpInitialize(
    IN HTTPAPI_VERSION Version,
    IN ULONG Flags,
    __reserved IN OUT PVOID pReserved
    );

// NOTE: MUST be called after final API call returns.

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpTerminate(
    IN ULONG Flags,
    __reserved IN OUT PVOID pReserved
    );

//
// HTTP Request Queue manipulation APIs.
//
// This API is maintained for backward competibility for the first
// version of the HTTPAPI and should not be used. Instead the new
// HttpCreateRequestQueue() API must be used.
//
// Use CloseHandle() to release the handles returned by
// HttpCreateHttpHandle() API.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCreateHttpHandle(
    OUT PHANDLE pReqQueueHandle,
    __reserved IN ULONG Reserved
    );

#if _WIN32_WINNT >= 0x0600

//
// Extended Request Queue manipulation APIs.
//
// Use HttpCloseRequestQueue() API to close the handles
// created by the HttpCreateRequestQueue API.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCreateRequestQueue(
    IN HTTPAPI_VERSION Version,
    IN PCWSTR pName OPTIONAL,
    IN PSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL,
    IN ULONG Flags OPTIONAL,
    OUT PHANDLE pReqQueueHandle
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCloseRequestQueue(
    IN HANDLE ReqQueueHandle
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSetRequestQueueProperty(
    IN HANDLE Handle,
    IN HTTP_SERVER_PROPERTY Property,
    __in_bcount(PropertyInformationLength) IN PVOID pPropertyInformation,
    IN ULONG PropertyInformationLength,
    __reserved IN ULONG Reserved,
    __reserved IN PVOID pReserved
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpQueryRequestQueueProperty(
    IN HANDLE Handle,
    IN HTTP_SERVER_PROPERTY Property,
    __out_bcount_part(PropertyInformationLength, *pReturnLength)
    OUT PVOID pPropertyInformation,
    IN ULONG PropertyInformationLength,
    __reserved IN ULONG Reserved,
    __out_opt OUT PULONG pReturnLength OPTIONAL,
    __reserved IN PVOID pReserved
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpShutdownRequestQueue(
    IN HANDLE ReqQueueHandle
    );

#endif // _WIN32_WINNT >= 0x0600

//
// SSL APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpReceiveClientCertificate(
    IN HANDLE ReqQueueHandle,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN ULONG Flags,
    __out_bcount_part(SslClientCertInfoSize, *pBytesReceived)
    OUT PHTTP_SSL_CLIENT_CERT_INFO pSslClientCertInfo,
    IN ULONG SslClientCertInfoSize,
    __out_opt OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

#if _WIN32_WINNT >= 0x0600

//
// Server Session APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCreateServerSession(
    IN HTTPAPI_VERSION Version,
    OUT PHTTP_SERVER_SESSION_ID pServerSessionId,
    __reserved IN ULONG Reserved
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCloseServerSession(
    IN HTTP_SERVER_SESSION_ID ServerSessionId
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpQueryServerSessionProperty(
    IN HTTP_SERVER_SESSION_ID ServerSessionId,
    IN HTTP_SERVER_PROPERTY Property,
    __out_bcount_part(PropertyInformationLength, *pReturnLength)
    OUT PVOID pPropertyInformation,
    IN ULONG PropertyInformationLength,
    __out_opt OUT PULONG pReturnLength OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSetServerSessionProperty(
    IN HTTP_SERVER_SESSION_ID ServerSessionId,
    IN HTTP_SERVER_PROPERTY Property,
    __in_bcount(PropertyInformationLength) IN PVOID pPropertyInformation,
    IN ULONG PropertyInformationLength
    );

#endif // _WIN32_WINNT >= 0x0600

//
// Url Configuration APIs. Can only be used for V1 request queues.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpAddUrl(
    IN HANDLE ReqQueueHandle,
    IN PCWSTR pFullyQualifiedUrl,
    __reserved IN PVOID pReserved
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpRemoveUrl(
    IN HANDLE ReqQueueHandle,
    IN PCWSTR pFullyQualifiedUrl
    );

#if _WIN32_WINNT >= 0x0600

//
// Url Group APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCreateUrlGroup(
    IN HTTP_SERVER_SESSION_ID ServerSessionId,
    OUT PHTTP_URL_GROUP_ID pUrlGroupId,
    __reserved IN ULONG Reserved
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCloseUrlGroup(
    IN HTTP_URL_GROUP_ID UrlGroupId
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpAddUrlToUrlGroup(
    IN HTTP_URL_GROUP_ID UrlGroupId,
    IN PCWSTR pFullyQualifiedUrl,
    IN HTTP_URL_CONTEXT UrlContext OPTIONAL,
    __reserved IN ULONG Reserved
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpRemoveUrlFromUrlGroup(
    IN HTTP_URL_GROUP_ID UrlGroupId,
    IN PCWSTR pFullyQualifiedUrl,
    IN ULONG Flags
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSetUrlGroupProperty(
    IN HTTP_URL_GROUP_ID UrlGroupId,
    IN HTTP_SERVER_PROPERTY Property,
    __in_bcount(PropertyInformationLength) IN PVOID pPropertyInformation,
    IN ULONG PropertyInformationLength
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpQueryUrlGroupProperty(
    IN HTTP_URL_GROUP_ID UrlGroupId,
    IN HTTP_SERVER_PROPERTY Property,
    __out_bcount_part(PropertyInformationLength, *pReturnLength)
    OUT PVOID pPropertyInformation,
    IN ULONG PropertyInformationLength,
    __out_opt OUT PULONG pReturnLength OPTIONAL
    );

#endif // _WIN32_WINNT >= 0x0600

//
// HTTP Server I/O APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpReceiveHttpRequest(
    IN HANDLE ReqQueueHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    __out_bcount_part(RequestBufferLength, *pBytesReceived)
    OUT PHTTP_REQUEST pRequestBuffer,
    IN ULONG RequestBufferLength,
    __out_opt OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpReceiveRequestEntityBody(
    IN HANDLE ReqQueueHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    __out_bcount_part(BufferLength, *pBytesReceived) OUT PVOID pBuffer,
    IN ULONG BufferLength,
    __out_opt OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

#if _WIN32_WINNT >= 0x0600

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSendHttpResponse(
    IN HANDLE ReqQueueHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    IN PHTTP_RESPONSE pHttpResponse,
    IN PHTTP_CACHE_POLICY pCachePolicy OPTIONAL,
    OUT PULONG pBytesSent OPTIONAL,
    OUT PVOID pReserved1 OPTIONAL, // must be NULL
    IN ULONG Reserved2 OPTIONAL, // must be 0
    IN LPOVERLAPPED pOverlapped OPTIONAL,
    IN PHTTP_LOG_DATA pLogData OPTIONAL
    );

#else // _WIN32_WINNT >= 0x0600

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSendHttpResponse(
    IN HANDLE ReqQueueHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    IN PHTTP_RESPONSE pHttpResponse,
    IN PVOID pReserved1 OPTIONAL, // must be NULL
    OUT PULONG pBytesSent OPTIONAL,
    OUT PVOID pReserved2 OPTIONAL, // must be NULL
    IN ULONG Reserved3 OPTIONAL, // must be 0
    IN LPOVERLAPPED pOverlapped OPTIONAL,
    IN PVOID pReserved4 OPTIONAL  // must be NULL
    );

#endif // _WIN32_WINNT >= 0x0600

#if _WIN32_WINNT >= 0x0600

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSendResponseEntityBody(
    IN HANDLE ReqQueueHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    IN USHORT EntityChunkCount OPTIONAL,
    __in_ecount_opt(EntityChunkCount)
    IN PHTTP_DATA_CHUNK pEntityChunks OPTIONAL,
    OUT PULONG pBytesSent OPTIONAL,
    OUT PVOID pReserved1 OPTIONAL, // must be NULL
    IN ULONG Reserved2 OPTIONAL, // must be 0
    IN LPOVERLAPPED pOverlapped OPTIONAL,
    IN PHTTP_LOG_DATA pLogData OPTIONAL
    );

#else // _WIN32_WINNT >= 0x0600

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSendResponseEntityBody(
    IN HANDLE ReqQueueHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    IN USHORT EntityChunkCount OPTIONAL,
    __in_ecount_opt(EntityChunkCount)
    IN PHTTP_DATA_CHUNK pEntityChunks OPTIONAL,
    OUT PULONG pBytesSent OPTIONAL,
    OUT PVOID pReserved1 OPTIONAL, // must be NULL
    IN ULONG Reserved2 OPTIONAL, // must be 0
    IN LPOVERLAPPED pOverlapped OPTIONAL,
    IN PVOID pReserved3 OPTIONAL  // must be NULL
    );

#endif // _WIN32_WINNT >= 0x0600

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpWaitForDisconnect(
    IN HANDLE ReqQueueHandle,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

#if _WIN32_WINNT >= 0x0600

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpWaitForDisconnectEx(
    IN HANDLE ReqQueueHandle,
    IN HTTP_CONNECTION_ID ConnectionId,
    __reserved IN ULONG Reserved OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCancelHttpRequest(
    IN HANDLE ReqQueueHandle,
    IN HTTP_REQUEST_ID RequestId,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpWaitForDemandStart(
    IN HANDLE ReqQueueHandle,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );


#endif // _WIN32_WINNT >= 0x0600

//
// Cache manipulation APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFlushResponseCache(
    IN HANDLE ReqQueueHandle,
    IN PCWSTR pUrlPrefix,
    IN ULONG Flags,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpAddFragmentToCache(
    IN HANDLE ReqQueueHandle,
    IN PCWSTR pUrlPrefix,
    IN PHTTP_DATA_CHUNK pDataChunk,
    IN PHTTP_CACHE_POLICY pCachePolicy,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpReadFragmentFromCache(
    IN HANDLE ReqQueueHandle,
    IN PCWSTR pUrlPrefix,
    IN PHTTP_BYTE_RANGE pByteRange OPTIONAL,
    __out_bcount_part(BufferLength, *pBytesRead) OUT PVOID pBuffer,
    IN ULONG BufferLength,
    OUT PULONG pBytesRead OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

//
// Server configuration APIs
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSetServiceConfiguration(
    __reserved IN HANDLE ServiceHandle,
    IN HTTP_SERVICE_CONFIG_ID ConfigId,
    __in_bcount(ConfigInformationLength) IN PVOID pConfigInformation,
    IN ULONG ConfigInformationLength,
    __reserved IN LPOVERLAPPED pOverlapped
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpDeleteServiceConfiguration(
    __reserved IN HANDLE ServiceHandle,
    IN HTTP_SERVICE_CONFIG_ID ConfigId,
    __in_bcount(ConfigInformationLength) IN PVOID pConfigInformation,
    IN ULONG ConfigInformationLength,
    __reserved IN LPOVERLAPPED pOverlapped
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpQueryServiceConfiguration(
    __reserved IN HANDLE ServiceHandle,
    IN HTTP_SERVICE_CONFIG_ID ConfigId,
    __in_bcount_opt(InputConfigInformationLength)
    IN PVOID pInputConfigInformation OPTIONAL,
    IN ULONG InputConfigInformationLength OPTIONAL,
    __out_bcount_part_opt(OutputConfigInformationLength, *pReturnLength)
    OUT PVOID pOutputConfigInformation OPTIONAL,
    IN ULONG OutputConfigInformationLength OPTIONAL,
    __out_opt OUT PULONG pReturnLength OPTIONAL,
    __reserved IN LPOVERLAPPED pOverlapped
    );


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus

#endif // _WIN32_WINNT >= 0x0501

#endif // __HTTP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\httptrace.h ===
#ifndef _HTTP_TRACE_H
#define _HTTP_TRACE_H
/*++

    Copyright (c) 2005 Microsoft Corporation

    Module Name:

        httptrace.h

    Abstract:

        Definition of the event tracing structures for IIS
        (applies for IIS version >= 7 )

--*/

//
// HTTP_TRACE_TYPE contains type that are supported by 
// the IIS trace infrastructure.
// The enum values match the equivalent VARIANT types.
//
enum HTTP_TRACE_TYPE
{ 
    HTTP_TRACE_TYPE_BYTE = 17,         // mof type "uint8"
    HTTP_TRACE_TYPE_USHORT = 18,       // mof type "uint16"
    HTTP_TRACE_TYPE_ULONG = 19,        // mof type "uint32"
    HTTP_TRACE_TYPE_ULONGLONG = 21,    // mof type "uint64"
    HTTP_TRACE_TYPE_CHAR = 16,         // mof type "int8"
    HTTP_TRACE_TYPE_SHORT = 2,         // mof type "int16"
    HTTP_TRACE_TYPE_LONG = 3,          // mof type "int32"
    HTTP_TRACE_TYPE_LONGLONG = 20,     // mof type "int64"
    HTTP_TRACE_TYPE_LPCWSTR = 31,      // mof type string "w"
    HTTP_TRACE_TYPE_LPCSTR = 30,       // mof type string "a"
    HTTP_TRACE_TYPE_LPCGUID = 72,      // mof type object "Guid"
    HTTP_TRACE_TYPE_BOOL = 11,         // mof type object "boolean"
};

// bit values for the HTTP_TRACE_EVENT.dwFlags

//
// If HTTP_TRACE_EVENT_FLAG_STATIC_DESCRIPTIVE_FIELDS is set then
// consumers of the trace event can assume that
// pProviderGuid, pAreaGuid, pszEventName in the HTTP_TRACE_EVENT
// and pszName and pszDescription in each HTTP_TRACE_EVENT_ITEM
// entry are static (their memory is available throughout the 
// process lifetime). If event needs to be buffered there is no need 
// to copy values for these fields
//
#define HTTP_TRACE_EVENT_FLAG_STATIC_DESCRIPTIVE_FIELDS       0x01

//
// In addition to TRACE_LEVEL_FATAL - TRACE_LEVEL_VERBOSE
//
#define HTTP_TRACE_LEVEL_START  6
#define HTTP_TRACE_LEVEL_END    7

struct HTTP_TRACE_EVENT_ITEM;

//
// Each Trace event will need to be described with the HTTP_TRACE_EVENT structure. 
// It is designed to contain all the information relevant to ETW, 
// but ETW is not the only consumer
//
//

struct HTTP_TRACE_EVENT
{
    //
    // Trace Provider (such as "WWW Server")
    //
    LPCGUID                 pProviderGuid ;    
    //
    // Trace Area Flag ( a bit flag that may represent area such as "Authentication")
    //
    DWORD                   dwArea;             
    //
    // GUID equivalent to the Area Flag
    //
    LPCGUID                 pAreaGuid;          
    //
    // ID of the event (in the ETW terminology this would be the Event Type)
    //
    DWORD                   dwEvent; 
    //
    // String matching the event ID (dwEvent)
    //
    LPCWSTR                 pszEventName;
    //
    // Event version
    //
    DWORD                   dwEventVersion;
    //
    // Verbosity of the event ( General, FatalError, Error, Warning, Info, Verbose)
    // In the ETW terminology this is the "event level"
    DWORD                   dwVerbosity;
    //
    // Activity GUID. For the http request based event 
    // it may represent the request ID
    //
    LPCGUID                 pActivityGuid;      
    //
    // Additional GUID to allow to associate 
    // multiple related activities
    //
    LPCGUID                 pRelatedActivityGuid;
    //
    // Optional timestamp (in GetTickCount() ticks )
    // If set to 0 then system will fill in the TickCount.
    //
    DWORD                   dwTimeStamp; 
    //
    // Flags (reserved: Set to 0)
    //
    DWORD                   dwFlags;
    //
    //
    // Number of entries in the structured
    // description of the event
    // Note that the maximum allowed number of EventTraceItems    
    // should match the ETW internal limit of 16 
    //
    DWORD                   cEventItems; 
    //
    // Array of individual entries describing
    // the event
    //
    __field_ecount(cEventItems) HTTP_TRACE_EVENT_ITEM * pEventItems; 
};


// Each HTTP_TRACE_EVENT can have multiple items or elements that describe the event
// (for example the "GENERAL_REQUEST_START" event contains an item with the Request URL)

struct HTTP_TRACE_EVENT_ITEM
{
    //
    // Friendly name of the item (for example "RequestUrl")
    //
    LPCWSTR          pszName;
    //
    // Data type that pbData is pointed to
    //
    HTTP_TRACE_TYPE  dwDataType;
    //
    // Pointer to the actual data (needs to be casted based on the dwDataType)
    // For example the HTTP_TRACE_EVENT_ITEM describing HTTP request URL would have
    // the pbData pointing to the actual URL string
    //
    PBYTE   pbData;
    //
    // # of bytes of the actual data (it should matter only for string types)
    //
    DWORD   cbData;
    //
    // Additional description of the data - enumerations take advantage of this field    
    // (always set to NULL if not used)
    //
    LPCWSTR pszDataDescription;
};


//
// HTTP_TRACE_CONFIGURATION is used by both trace providers and trace consumers
// Trace consumers declare the TraceProviders and TraceAreas of the interest.
// Trace providers can retrieve what areas at what verbosity is allowed
// for a given provider
//

struct HTTP_TRACE_CONFIGURATION
{
    LPCGUID     pProviderGuid;
    DWORD       dwAreas;
    DWORD       dwVerbosity;
    BOOL        fProviderEnabled;
};

//
// Definiton of the GUIDs for the TRACE Providers that ship with IIS
// or are related to IIS
//

DEFINE_GUID( GUID_IIS_ALL_TRACE_PROVIDERS,
             0x00000000,0x0000,0x0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);

DEFINE_GUID( GUID_IIS_WWW_SERVER_TRACE_PROVIDER,
             0x3a2a4e84,0x4c21,0x4981,0xae,0x10,0x3f,0xda,0x0d,0x9b,0x0f,0x83);

// ETW name for the provider: "ASP.NET Events
DEFINE_GUID( GUID_IIS_ASPNET_TRACE_PROVIDER,
             0xAFF081FE,0x0247,0x4275,0x9C,0x4E,0x02,0x1F,0x3D,0xC1,0xDA,0x35);

// ETW name for the provider: "IIS: Active Server Pages (ASP)"
DEFINE_GUID( GUID_IIS_ASP_TRACE_TRACE_PROVIDER,
             0x06b94d9a,0xb15e,0x456e,0xa4,0xef,0x37,0xc9,0x84,0xa2,0xcb,0x4b);

DEFINE_GUID( GUID_IIS_WWW_GLOBAL_TRACE_PROVIDER,
             0xd55d3bc9,0xcba9,0x44df,0x82,0x7e,0x13,0x2d,0x3a,0x45,0x96,0xc2);

// ETW name for the provider: "IIS: WWW Isapi Extension"
DEFINE_GUID( GUID_IIS_ISAPI_TRACE_PROVIDER,
             0xa1c2040e,0x8840,0x4c31,0xba,0x11,0x98,0x71,0x03,0x1a,0x19,0xea);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Iadmext.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997-1999           **/
/**********************************************************************/

/*
    iadmext.h

    This module contains the interface for extensions to the IISADMIN service.


    FILE HISTORY:
    7/8/97      michth      created
*/

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iadmext_h__
#define __iadmext_h__

#ifdef __cplusplus
extern "C"{
#endif



/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "ocidl.h"

/*
The Main Interface. All extensions must support this interface.
*/
// {51DFE970-F6F2-11d0-B9BD-00A0C922E750}
DEFINE_GUID(IID_IADMEXT, 0x51dfe970, 0xf6f2, 0x11d0, 0xb9, 0xbd, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);

/*
InProcess COM Registration. All extensions must write a subkey name by the
CLSID for the above interface under this key in the Registry.
*/
#define IISADMIN_EXTENSIONS_REG_KEYA          "SOFTWARE\\Microsoft\\InetStp\\Extensions"
#define IISADMIN_EXTENSIONS_REG_KEYW          L"SOFTWARE\\Microsoft\\InetStp\\Extensions"
#define IISADMIN_EXTENSIONS_REG_KEY           TEXT("SOFTWARE\\Microsoft\\InetStp\\Extensions")

/*
DCOM Registration. CLSIDS for the DCOM interface provided by these extensions will
be written to this key and ID by IISADMIN as a multisz property.

This is intended for use by other applications which need to find out what classid's are
registered.
*/

#define IISADMIN_EXTENSIONS_CLSID_MD_KEYA      "LM/IISADMIN/EXTENSIONS/DCOMCLSIDS"
#define IISADMIN_EXTENSIONS_CLSID_MD_KEYW      L"LM/IISADMIN/EXTENSIONS/DCOMCLSIDS"
#define IISADMIN_EXTENSIONS_CLSID_MD_KEY      TEXT("LM/IISADMIN/EXTENSIONS/DCOMCLSIDS")
#define IISADMIN_EXTENSIONS_CLSID_MD_ID       MD_IISADMIN_EXTENSIONS

#ifndef __IADMEXT_INTERFACE_DEFINED__
#define __IADMEXT_INTERFACE_DEFINED__


EXTERN_C const IID IID_IADMEXT;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IADMEXT : public IUnknown
    {
    public:
        //
        // All methods below will be called under a thread which has called
        // CoInitializeEx(NULL, COINIT_MULTITHREADED).
        //
        // The IMSAdminBase Object will be available during all of these calls.
        //

        //
        // Initialize will be called by IISADMIN when it initializes.
        //
        virtual HRESULT STDMETHODCALLTYPE Initialize(void) = 0;

        //
        // EnumDcomCLSIDs will be called by IISADMIN when it initializes,
        // and the returned CLSIDs will be written to the metabase at
        // the path IISADMIN_EXTENSIONS_CLSID_MD_KEY.
        //
        virtual HRESULT STDMETHODCALLTYPE EnumDcomCLSIDs(
            /* [size_is][out] */ CLSID *pclsidDcom,
            /* [in] */ DWORD dwEnumIndex) = 0;

        //
        // Terminate will be called by IISADMIN when it terminates.
        //
        virtual HRESULT STDMETHODCALLTYPE Terminate(void) = 0;

    };

#else   /* C style interface */
#endif
#endif  /* __IADMEXT_INTERFACE_DEFINED__ */

#ifdef __cplusplus
}
#endif

#endif // __iadmext_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\IAccess.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for iaccess.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iaccess_h__
#define __iaccess_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAccessControl_FWD_DEFINED__
#define __IAccessControl_FWD_DEFINED__
typedef interface IAccessControl IAccessControl;
#endif 	/* __IAccessControl_FWD_DEFINED__ */


#ifndef __IAuditControl_FWD_DEFINED__
#define __IAuditControl_FWD_DEFINED__
typedef interface IAuditControl IAuditControl;
#endif 	/* __IAuditControl_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "accctrl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_iaccess_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 1020 )
#pragma once
#endif
typedef /* [allocate] */ PACTRL_ACCESSW PACTRL_ACCESSW_ALLOCATE_ALL_NODES;

typedef /* [allocate] */ PACTRL_AUDITW PACTRL_AUDITW_ALLOCATE_ALL_NODES;




extern RPC_IF_HANDLE __MIDL_itf_iaccess_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iaccess_0000_0000_v0_0_s_ifspec;

#ifndef __IAccessControl_INTERFACE_DEFINED__
#define __IAccessControl_INTERFACE_DEFINED__

/* interface IAccessControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAccessControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EEDD23E0-8410-11CE-A1C3-08002B2B8D8F")
    IAccessControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GrantAccessRights( 
            /* [in] */ __RPC__in PACTRL_ACCESSW pAccessList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccessRights( 
            /* [in] */ __RPC__in PACTRL_ACCESSW pAccessList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOwner( 
            /* [in] */ __RPC__in PTRUSTEEW pOwner,
            /* [in] */ __RPC__in PTRUSTEEW pGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeAccessRights( 
            /* [in] */ __RPC__in LPWSTR lpProperty,
            /* [in] */ ULONG cTrustees,
            /* [size_is][in] */ __RPC__in_ecount_full(cTrustees) TRUSTEEW prgTrustees[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllAccessRights( 
            /* [in] */ __RPC__in LPWSTR lpProperty,
            /* [out] */ __RPC__deref_out_opt PACTRL_ACCESSW_ALLOCATE_ALL_NODES *ppAccessList,
            /* [out] */ __RPC__deref_out_opt PTRUSTEEW *ppOwner,
            /* [out] */ __RPC__deref_out_opt PTRUSTEEW *ppGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAccessAllowed( 
            /* [in] */ __RPC__in PTRUSTEEW pTrustee,
            /* [in] */ __RPC__in LPWSTR lpProperty,
            /* [in] */ ACCESS_RIGHTS AccessRights,
            /* [out] */ __RPC__out BOOL *pfAccessAllowed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccessControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAccessControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAccessControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAccessControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GrantAccessRights )( 
            IAccessControl * This,
            /* [in] */ __RPC__in PACTRL_ACCESSW pAccessList);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccessRights )( 
            IAccessControl * This,
            /* [in] */ __RPC__in PACTRL_ACCESSW pAccessList);
        
        HRESULT ( STDMETHODCALLTYPE *SetOwner )( 
            IAccessControl * This,
            /* [in] */ __RPC__in PTRUSTEEW pOwner,
            /* [in] */ __RPC__in PTRUSTEEW pGroup);
        
        HRESULT ( STDMETHODCALLTYPE *RevokeAccessRights )( 
            IAccessControl * This,
            /* [in] */ __RPC__in LPWSTR lpProperty,
            /* [in] */ ULONG cTrustees,
            /* [size_is][in] */ __RPC__in_ecount_full(cTrustees) TRUSTEEW prgTrustees[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllAccessRights )( 
            IAccessControl * This,
            /* [in] */ __RPC__in LPWSTR lpProperty,
            /* [out] */ __RPC__deref_out_opt PACTRL_ACCESSW_ALLOCATE_ALL_NODES *ppAccessList,
            /* [out] */ __RPC__deref_out_opt PTRUSTEEW *ppOwner,
            /* [out] */ __RPC__deref_out_opt PTRUSTEEW *ppGroup);
        
        HRESULT ( STDMETHODCALLTYPE *IsAccessAllowed )( 
            IAccessControl * This,
            /* [in] */ __RPC__in PTRUSTEEW pTrustee,
            /* [in] */ __RPC__in LPWSTR lpProperty,
            /* [in] */ ACCESS_RIGHTS AccessRights,
            /* [out] */ __RPC__out BOOL *pfAccessAllowed);
        
        END_INTERFACE
    } IAccessControlVtbl;

    interface IAccessControl
    {
        CONST_VTBL struct IAccessControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccessControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAccessControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAccessControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAccessControl_GrantAccessRights(This,pAccessList)	\
    ( (This)->lpVtbl -> GrantAccessRights(This,pAccessList) ) 

#define IAccessControl_SetAccessRights(This,pAccessList)	\
    ( (This)->lpVtbl -> SetAccessRights(This,pAccessList) ) 

#define IAccessControl_SetOwner(This,pOwner,pGroup)	\
    ( (This)->lpVtbl -> SetOwner(This,pOwner,pGroup) ) 

#define IAccessControl_RevokeAccessRights(This,lpProperty,cTrustees,prgTrustees)	\
    ( (This)->lpVtbl -> RevokeAccessRights(This,lpProperty,cTrustees,prgTrustees) ) 

#define IAccessControl_GetAllAccessRights(This,lpProperty,ppAccessList,ppOwner,ppGroup)	\
    ( (This)->lpVtbl -> GetAllAccessRights(This,lpProperty,ppAccessList,ppOwner,ppGroup) ) 

#define IAccessControl_IsAccessAllowed(This,pTrustee,lpProperty,AccessRights,pfAccessAllowed)	\
    ( (This)->lpVtbl -> IsAccessAllowed(This,pTrustee,lpProperty,AccessRights,pfAccessAllowed) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAccessControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_iaccess_0000_0001 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_iaccess_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iaccess_0000_0001_v0_0_s_ifspec;

#ifndef __IAuditControl_INTERFACE_DEFINED__
#define __IAuditControl_INTERFACE_DEFINED__

/* interface IAuditControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAuditControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1da6292f-bc66-11ce-aae3-00aa004c2737")
    IAuditControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GrantAuditRights( 
            /* [in] */ __RPC__in PACTRL_AUDITW pAuditList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuditRights( 
            /* [in] */ __RPC__in PACTRL_AUDITW pAuditList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeAuditRights( 
            /* [in] */ __RPC__in LPWSTR lpProperty,
            /* [in] */ ULONG cTrustees,
            /* [size_is][in] */ __RPC__in_ecount_full(cTrustees) TRUSTEEW prgTrustees[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllAuditRights( 
            /* [in] */ __RPC__in LPWSTR lpProperty,
            /* [out] */ __RPC__deref_out_opt PACTRL_AUDITW *ppAuditList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAccessAudited( 
            /* [in] */ __RPC__in PTRUSTEEW pTrustee,
            /* [in] */ ACCESS_RIGHTS AuditRights,
            /* [out] */ __RPC__out BOOL *pfAccessAudited) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuditControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAuditControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAuditControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAuditControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GrantAuditRights )( 
            IAuditControl * This,
            /* [in] */ __RPC__in PACTRL_AUDITW pAuditList);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuditRights )( 
            IAuditControl * This,
            /* [in] */ __RPC__in PACTRL_AUDITW pAuditList);
        
        HRESULT ( STDMETHODCALLTYPE *RevokeAuditRights )( 
            IAuditControl * This,
            /* [in] */ __RPC__in LPWSTR lpProperty,
            /* [in] */ ULONG cTrustees,
            /* [size_is][in] */ __RPC__in_ecount_full(cTrustees) TRUSTEEW prgTrustees[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllAuditRights )( 
            IAuditControl * This,
            /* [in] */ __RPC__in LPWSTR lpProperty,
            /* [out] */ __RPC__deref_out_opt PACTRL_AUDITW *ppAuditList);
        
        HRESULT ( STDMETHODCALLTYPE *IsAccessAudited )( 
            IAuditControl * This,
            /* [in] */ __RPC__in PTRUSTEEW pTrustee,
            /* [in] */ ACCESS_RIGHTS AuditRights,
            /* [out] */ __RPC__out BOOL *pfAccessAudited);
        
        END_INTERFACE
    } IAuditControlVtbl;

    interface IAuditControl
    {
        CONST_VTBL struct IAuditControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuditControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAuditControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAuditControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAuditControl_GrantAuditRights(This,pAuditList)	\
    ( (This)->lpVtbl -> GrantAuditRights(This,pAuditList) ) 

#define IAuditControl_SetAuditRights(This,pAuditList)	\
    ( (This)->lpVtbl -> SetAuditRights(This,pAuditList) ) 

#define IAuditControl_RevokeAuditRights(This,lpProperty,cTrustees,prgTrustees)	\
    ( (This)->lpVtbl -> RevokeAuditRights(This,lpProperty,cTrustees,prgTrustees) ) 

#define IAuditControl_GetAllAuditRights(This,lpProperty,ppAuditList)	\
    ( (This)->lpVtbl -> GetAllAuditRights(This,lpProperty,ppAuditList) ) 

#define IAuditControl_IsAccessAudited(This,pTrustee,AuditRights,pfAccessAudited)	\
    ( (This)->lpVtbl -> IsAccessAudited(This,pTrustee,AuditRights,pfAccessAudited) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAuditControl_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\IACOM_i.c ===
//-------------------------------------------------------------------------- 
// 
//  Copyright (c) Microsoft Corporation.  All rights reserved. 
// 
//  File: iacom_i.c 
//      Microsoft Tablet PC API definitions 
// 
//-------------------------------------------------------------------------- 
	
 	
 	

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for iacom.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_COMINKANALYSISLib,0x1761E494,0xA3D0,0x4f8e,0x87,0xC5,0xC0,0x95,0x66,0xB2,0x29,0x72);


MIDL_DEFINE_GUID(IID, IID_IInkAnalyzer,0x31F8B4AE,0xF970,0x3A72,0x85,0x95,0x86,0x7D,0x28,0x6E,0x3B,0x7B);


MIDL_DEFINE_GUID(IID, IID_IContextNode,0x160BC1B3,0x5997,0x3D3C,0x9E,0x5A,0xE3,0x8B,0xCB,0x21,0x20,0x47);


MIDL_DEFINE_GUID(IID, IID_IContextNodes,0x23A56238,0xA883,0x4393,0xB5,0x39,0x8C,0x1E,0x29,0x96,0xB7,0xA2);


MIDL_DEFINE_GUID(IID, IID_IAnalysisRegion,0xF76EBC66,0xABEF,0x3248,0xAE,0x9B,0xF2,0x0D,0x4B,0x91,0x49,0xFE);


MIDL_DEFINE_GUID(IID, IID_IContextLink,0x715389A8,0x84B1,0x3B52,0x98,0xFC,0xE2,0xCC,0xCD,0x27,0xD4,0xB9);


MIDL_DEFINE_GUID(IID, IID_IContextLinks,0x2914EB5A,0x8B3D,0x4381,0xA7,0x33,0x15,0x09,0xA2,0x29,0x53,0x94);


MIDL_DEFINE_GUID(IID, IID_IInkAnalysisRecognizer,0xBD5F33DF,0xBEBB,0x3D05,0x98,0xAC,0xF0,0x98,0x6D,0x3B,0xEF,0x17);


MIDL_DEFINE_GUID(IID, IID_IInkAnalysisRecognizers,0x7C3B2C8F,0x1ADD,0x309A,0x92,0x01,0x22,0xC6,0xE0,0xDD,0xA6,0x33);


MIDL_DEFINE_GUID(IID, IID_IAnalysisAlternate,0x5DB42FCE,0x8FDE,0x3E45,0x8C,0x4A,0x22,0x4C,0x89,0x03,0x4F,0x02);


MIDL_DEFINE_GUID(IID, IID_IAnalysisAlternates,0x4262DF99,0x1C25,0x3CF8,0x98,0xCB,0x45,0x28,0xDE,0x75,0x0F,0x08);


MIDL_DEFINE_GUID(IID, IID_IAnalysisWarning,0xB7BC3EF6,0xC944,0x33C5,0x89,0x17,0x19,0xBD,0x3E,0x0C,0x83,0x27);


MIDL_DEFINE_GUID(IID, IID_IAnalysisWarnings,0x304ADA62,0xDEC1,0x35BF,0x84,0xAE,0xA6,0x1B,0xB8,0x46,0xAD,0xD7);


MIDL_DEFINE_GUID(IID, IID_IAnalysisStatus,0x8E16FC8B,0xF1DC,0x38C9,0xBB,0x8F,0x7E,0xF7,0xB0,0xD6,0xC5,0xAE);


MIDL_DEFINE_GUID(IID, IID_IMatchesCriteriaCallBack,0xA11BEA2D,0x62F5,0x3DDC,0xAE,0xFD,0x5B,0xFE,0xD2,0xED,0x43,0xE9);


MIDL_DEFINE_GUID(IID, IID__IAnalysisEvents,0x67CCF9D3,0xFE75,0x338D,0xBB,0x4B,0xFD,0x0F,0xF1,0x8C,0x82,0x58);


MIDL_DEFINE_GUID(IID, IID__IAnalysisProxyEvents,0x70049599,0x2E75,0x3FEC,0xA5,0x97,0xC8,0x19,0x11,0x05,0xF4,0xFB);


MIDL_DEFINE_GUID(CLSID, CLSID_InkAnalyzer,0xB4BAB526,0x5BA1,0x3C4D,0xAF,0x21,0xCF,0xDC,0xD9,0xAA,0xF2,0xD2);


MIDL_DEFINE_GUID(CLSID, CLSID_AnalysisRegion,0x3C3E7657,0x4F0C,0x3FC4,0x8A,0x89,0xA5,0xB0,0xF7,0xEB,0x48,0x0A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for iacom.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_COMINKANALYSISLib,0x1761E494,0xA3D0,0x4f8e,0x87,0xC5,0xC0,0x95,0x66,0xB2,0x29,0x72);


MIDL_DEFINE_GUID(IID, IID_IInkAnalyzer,0x31F8B4AE,0xF970,0x3A72,0x85,0x95,0x86,0x7D,0x28,0x6E,0x3B,0x7B);


MIDL_DEFINE_GUID(IID, IID_IContextNode,0x160BC1B3,0x5997,0x3D3C,0x9E,0x5A,0xE3,0x8B,0xCB,0x21,0x20,0x47);


MIDL_DEFINE_GUID(IID, IID_IContextNodes,0x23A56238,0xA883,0x4393,0xB5,0x39,0x8C,0x1E,0x29,0x96,0xB7,0xA2);


MIDL_DEFINE_GUID(IID, IID_IAnalysisRegion,0xF76EBC66,0xABEF,0x3248,0xAE,0x9B,0xF2,0x0D,0x4B,0x91,0x49,0xFE);


MIDL_DEFINE_GUID(IID, IID_IContextLink,0x715389A8,0x84B1,0x3B52,0x98,0xFC,0xE2,0xCC,0xCD,0x27,0xD4,0xB9);


MIDL_DEFINE_GUID(IID, IID_IContextLinks,0x2914EB5A,0x8B3D,0x4381,0xA7,0x33,0x15,0x09,0xA2,0x29,0x53,0x94);


MIDL_DEFINE_GUID(IID, IID_IInkAnalysisRecognizer,0xBD5F33DF,0xBEBB,0x3D05,0x98,0xAC,0xF0,0x98,0x6D,0x3B,0xEF,0x17);


MIDL_DEFINE_GUID(IID, IID_IInkAnalysisRecognizers,0x7C3B2C8F,0x1ADD,0x309A,0x92,0x01,0x22,0xC6,0xE0,0xDD,0xA6,0x33);


MIDL_DEFINE_GUID(IID, IID_IAnalysisAlternate,0x5DB42FCE,0x8FDE,0x3E45,0x8C,0x4A,0x22,0x4C,0x89,0x03,0x4F,0x02);


MIDL_DEFINE_GUID(IID, IID_IAnalysisAlternates,0x4262DF99,0x1C25,0x3CF8,0x98,0xCB,0x45,0x28,0xDE,0x75,0x0F,0x08);


MIDL_DEFINE_GUID(IID, IID_IAnalysisWarning,0xB7BC3EF6,0xC944,0x33C5,0x89,0x17,0x19,0xBD,0x3E,0x0C,0x83,0x27);


MIDL_DEFINE_GUID(IID, IID_IAnalysisWarnings,0x304ADA62,0xDEC1,0x35BF,0x84,0xAE,0xA6,0x1B,0xB8,0x46,0xAD,0xD7);


MIDL_DEFINE_GUID(IID, IID_IAnalysisStatus,0x8E16FC8B,0xF1DC,0x38C9,0xBB,0x8F,0x7E,0xF7,0xB0,0xD6,0xC5,0xAE);


MIDL_DEFINE_GUID(IID, IID_IMatchesCriteriaCallBack,0xA11BEA2D,0x62F5,0x3DDC,0xAE,0xFD,0x5B,0xFE,0xD2,0xED,0x43,0xE9);


MIDL_DEFINE_GUID(IID, IID__IAnalysisEvents,0x67CCF9D3,0xFE75,0x338D,0xBB,0x4B,0xFD,0x0F,0xF1,0x8C,0x82,0x58);


MIDL_DEFINE_GUID(IID, IID__IAnalysisProxyEvents,0x70049599,0x2E75,0x3FEC,0xA5,0x97,0xC8,0x19,0x11,0x05,0xF4,0xFB);


MIDL_DEFINE_GUID(CLSID, CLSID_InkAnalyzer,0xB4BAB526,0x5BA1,0x3C4D,0xAF,0x21,0xCF,0xDC,0xD9,0xAA,0xF2,0xD2);


MIDL_DEFINE_GUID(CLSID, CLSID_AnalysisRegion,0x3C3E7657,0x4F0C,0x3FC4,0x8A,0x89,0xA5,0xB0,0xF7,0xEB,0x48,0x0A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ia64reg.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects
*/
//++
//
// Module Name:
//
//  ia64reg.h
//
// Abstract:
//
//  This module contains the code view representation of IA64 register set.
//
// Revision History:
//
//--

#ifndef _IA64REG_
#define _IA64REG_
#if _MSC_VER > 1000
#pragma once
#endif


typedef enum IA64_REG_INDEX {              

    //
    // Register set for Intel IA64              
    //


    // Branch Registers              

    CV_IA64_BrRp     =   512,              
    CV_IA64_BrS0     =   513,              
    CV_IA64_BrS1     =   514,              
    CV_IA64_BrS2     =   515,              
    CV_IA64_BrS3     =   516,              
    CV_IA64_BrS4     =   517,              
    CV_IA64_BrT0     =   518,              
    CV_IA64_BrT1     =   519,              

    // Predicate Registers              

    CV_IA64_Preds     =   768,              

    // Banked General Registers              

    CV_IA64_IntH0    =   832,              
    CV_IA64_IntH1    =   833,              
    CV_IA64_IntH2    =   834,              
    CV_IA64_IntH3    =   835,              
    CV_IA64_IntH4    =   836,              
    CV_IA64_IntH5    =   837,              
    CV_IA64_IntH6    =   838,              
    CV_IA64_IntH7    =   839,              
    CV_IA64_IntH8    =   840,              
    CV_IA64_IntH9    =   841,              
    CV_IA64_IntH10    =   842,              
    CV_IA64_IntH11    =   843,              
    CV_IA64_IntH12    =   844,              
    CV_IA64_IntH13    =   845,              
    CV_IA64_IntH14    =   846,              
    CV_IA64_IntH15    =   847,              

    // Special Registers              

    CV_IA64_Ip     =   1016,              
    CV_IA64_Umask  =   1017,              
    CV_IA64_Cfm    =   1018,              
    CV_IA64_Psr    =   1019,              

    // Banked General Registers              

    CV_IA64_Nats     =   1020,              
    CV_IA64_Nats2    =   1021,              
    CV_IA64_Nats3    =   1022,              

    // General-Purpose Registers              

    // INTEGER REGISTER              
    CV_IA64_IntZero  =   1024,              
    CV_IA64_IntGp    =   1025,              
    CV_IA64_IntT0    =   1026,              
    CV_IA64_IntT1    =   1027,              
    CV_IA64_IntS0    =   1028,              
    CV_IA64_IntS1    =   1029,              
    CV_IA64_IntS2    =   1030,              
    CV_IA64_IntS3    =   1031,              
    CV_IA64_IntV0    =   1032,              
    CV_IA64_IntAp    =   1033,              
    CV_IA64_IntT2    =   1034,              
    CV_IA64_IntT3    =   1035,              
    CV_IA64_IntSp    =   1036,              
    CV_IA64_IntT4    =   1037,              
    CV_IA64_IntT5    =   1038,              
    CV_IA64_IntT6    =   1039,              
    CV_IA64_IntT7    =   1040,              
    CV_IA64_IntT8    =   1041,              
    CV_IA64_IntT9    =   1042,              
    CV_IA64_IntT10   =   1043,              
    CV_IA64_IntT11   =   1044,              
    CV_IA64_IntT12   =   1045,              
    CV_IA64_IntT13   =   1046,              
    CV_IA64_IntT14   =   1047,              
    CV_IA64_IntT15   =   1048,              
    CV_IA64_IntT16   =   1049,              
    CV_IA64_IntT17   =   1050,              
    CV_IA64_IntT18   =   1051,              
    CV_IA64_IntT19   =   1052,              
    CV_IA64_IntT20   =   1053,              
    CV_IA64_IntT21   =   1054,              
    CV_IA64_IntT22   =   1055,              

    // Register Stack              
    CV_IA64_IntR32   =   1056,              
    CV_IA64_IntR33   =   1057,              
    CV_IA64_IntR34   =   1058,              
    CV_IA64_IntR35   =   1059,              
    CV_IA64_IntR36   =   1060,              
    CV_IA64_IntR37   =   1061,              
    CV_IA64_IntR38   =   1062,              
    CV_IA64_IntR39   =   1063,              
    CV_IA64_IntR40   =   1064,              
    CV_IA64_IntR41   =   1065,              
    CV_IA64_IntR42   =   1066,              
    CV_IA64_IntR43   =   1067,              
    CV_IA64_IntR44   =   1068,              
    CV_IA64_IntR45   =   1069,              
    CV_IA64_IntR46   =   1070,              
    CV_IA64_IntR47   =   1071,              
    CV_IA64_IntR48   =   1072,              
    CV_IA64_IntR49   =   1073,              
    CV_IA64_IntR50   =   1074,              
    CV_IA64_IntR51   =   1075,              
    CV_IA64_IntR52   =   1076,              
    CV_IA64_IntR53   =   1077,              
    CV_IA64_IntR54   =   1078,              
    CV_IA64_IntR55   =   1079,              
    CV_IA64_IntR56   =   1080,              
    CV_IA64_IntR57   =   1081,              
    CV_IA64_IntR58   =   1082,              
    CV_IA64_IntR59   =   1083,              
    CV_IA64_IntR60   =   1084,              
    CV_IA64_IntR61   =   1085,              
    CV_IA64_IntR62   =   1086,              
    CV_IA64_IntR63   =   1087,              
    CV_IA64_IntR64   =   1088,              
    CV_IA64_IntR65   =   1089,              
    CV_IA64_IntR66   =   1090,              
    CV_IA64_IntR67   =   1091,              
    CV_IA64_IntR68   =   1092,              
    CV_IA64_IntR69   =   1093,              
    CV_IA64_IntR70   =   1094,              
    CV_IA64_IntR71   =   1095,              
    CV_IA64_IntR72   =   1096,              
    CV_IA64_IntR73   =   1097,              
    CV_IA64_IntR74   =   1098,              
    CV_IA64_IntR75   =   1099,              
    CV_IA64_IntR76   =   1100,              
    CV_IA64_IntR77   =   1101,              
    CV_IA64_IntR78   =   1102,              
    CV_IA64_IntR79   =   1103,              
    CV_IA64_IntR80   =   1104,              
    CV_IA64_IntR81   =   1105,              
    CV_IA64_IntR82   =   1106,              
    CV_IA64_IntR83   =   1107,              
    CV_IA64_IntR84   =   1108,              
    CV_IA64_IntR85   =   1109,              
    CV_IA64_IntR86   =   1110,              
    CV_IA64_IntR87   =   1111,              
    CV_IA64_IntR88   =   1112,              
    CV_IA64_IntR89   =   1113,              
    CV_IA64_IntR90   =   1114,              
    CV_IA64_IntR91   =   1115,              
    CV_IA64_IntR92   =   1116,              
    CV_IA64_IntR93   =   1117,              
    CV_IA64_IntR94   =   1118,              
    CV_IA64_IntR95   =   1119,              
    CV_IA64_IntR96   =   1120,              
    CV_IA64_IntR97   =   1121,              
    CV_IA64_IntR98   =   1122,              
    CV_IA64_IntR99   =   1123,              
    CV_IA64_IntR100   =   1124,              
    CV_IA64_IntR101   =   1125,              
    CV_IA64_IntR102   =   1126,              
    CV_IA64_IntR103   =   1127,              
    CV_IA64_IntR104   =   1128,              
    CV_IA64_IntR105   =   1129,              
    CV_IA64_IntR106   =   1130,              
    CV_IA64_IntR107   =   1131,              
    CV_IA64_IntR108   =   1132,              
    CV_IA64_IntR109   =   1133,              
    CV_IA64_IntR110   =   1134,              
    CV_IA64_IntR111   =   1135,              
    CV_IA64_IntR112   =   1136,              
    CV_IA64_IntR113   =   1137,              
    CV_IA64_IntR114   =   1138,              
    CV_IA64_IntR115   =   1139,              
    CV_IA64_IntR116   =   1140,              
    CV_IA64_IntR117   =   1141,              
    CV_IA64_IntR118   =   1142,              
    CV_IA64_IntR119   =   1143,              
    CV_IA64_IntR120   =   1144,              
    CV_IA64_IntR121   =   1145,              
    CV_IA64_IntR122   =   1146,              
    CV_IA64_IntR123   =   1147,              
    CV_IA64_IntR124   =   1148,              
    CV_IA64_IntR125   =   1149,              
    CV_IA64_IntR126   =   1150,              
    CV_IA64_IntR127   =   1151,              

    // Floating-Point Registers              

    // Low Floating Point Registers              
    CV_IA64_FltZero  =   2048,              
    CV_IA64_FltOne   =   2049,              
    CV_IA64_FltS0    =   2050,              
    CV_IA64_FltS1    =   2051,              
    CV_IA64_FltS2    =   2052,              
    CV_IA64_FltS3    =   2053,              
    CV_IA64_FltT0    =   2054,              
    CV_IA64_FltT1    =   2055,              
    CV_IA64_FltT2    =   2056,              
    CV_IA64_FltT3    =   2057,              
    CV_IA64_FltT4    =   2058,              
    CV_IA64_FltT5    =   2059,              
    CV_IA64_FltT6    =   2060,              
    CV_IA64_FltT7    =   2061,              
    CV_IA64_FltT8    =   2062,              
    CV_IA64_FltT9    =   2063,              
    CV_IA64_FltS4    =   2064,              
    CV_IA64_FltS5    =   2065,              
    CV_IA64_FltS6    =   2066,              
    CV_IA64_FltS7    =   2067,              
    CV_IA64_FltS8    =   2068,              
    CV_IA64_FltS9    =   2069,              
    CV_IA64_FltS10   =   2070,              
    CV_IA64_FltS11   =   2071,              
    CV_IA64_FltS12   =   2072,              
    CV_IA64_FltS13   =   2073,              
    CV_IA64_FltS14   =   2074,              
    CV_IA64_FltS15   =   2075,              
    CV_IA64_FltS16   =   2076,              
    CV_IA64_FltS17   =   2077,              
    CV_IA64_FltS18   =   2078,              
    CV_IA64_FltS19   =   2079,              

    // High Floating Point Registers              
    CV_IA64_FltF32   =   2080,              
    CV_IA64_FltF33   =   2081,              
    CV_IA64_FltF34   =   2082,              
    CV_IA64_FltF35   =   2083,              
    CV_IA64_FltF36   =   2084,              
    CV_IA64_FltF37   =   2085,              
    CV_IA64_FltF38   =   2086,              
    CV_IA64_FltF39   =   2087,              
    CV_IA64_FltF40   =   2088,              
    CV_IA64_FltF41   =   2089,              
    CV_IA64_FltF42   =   2090,              
    CV_IA64_FltF43   =   2091,              
    CV_IA64_FltF44   =   2092,              
    CV_IA64_FltF45   =   2093,              
    CV_IA64_FltF46   =   2094,              
    CV_IA64_FltF47   =   2095,              
    CV_IA64_FltF48   =   2096,              
    CV_IA64_FltF49   =   2097,              
    CV_IA64_FltF50   =   2098,              
    CV_IA64_FltF51   =   2099,              
    CV_IA64_FltF52   =   2100,              
    CV_IA64_FltF53   =   2101,              
    CV_IA64_FltF54   =   2102,              
    CV_IA64_FltF55   =   2103,              
    CV_IA64_FltF56   =   2104,              
    CV_IA64_FltF57   =   2105,              
    CV_IA64_FltF58   =   2106,              
    CV_IA64_FltF59   =   2107,              
    CV_IA64_FltF60   =   2108,              
    CV_IA64_FltF61   =   2109,              
    CV_IA64_FltF62   =   2110,              
    CV_IA64_FltF63   =   2111,              
    CV_IA64_FltF64   =   2112,              
    CV_IA64_FltF65   =   2113,              
    CV_IA64_FltF66   =   2114,              
    CV_IA64_FltF67   =   2115,              
    CV_IA64_FltF68   =   2116,              
    CV_IA64_FltF69   =   2117,              
    CV_IA64_FltF70   =   2118,              
    CV_IA64_FltF71   =   2119,              
    CV_IA64_FltF72   =   2120,              
    CV_IA64_FltF73   =   2121,              
    CV_IA64_FltF74   =   2122,              
    CV_IA64_FltF75   =   2123,              
    CV_IA64_FltF76   =   2124,              
    CV_IA64_FltF77   =   2125,              
    CV_IA64_FltF78   =   2126,              
    CV_IA64_FltF79   =   2127,              
    CV_IA64_FltF80   =   2128,              
    CV_IA64_FltF81   =   2129,              
    CV_IA64_FltF82   =   2130,              
    CV_IA64_FltF83   =   2131,              
    CV_IA64_FltF84   =   2132,              
    CV_IA64_FltF85   =   2133,              
    CV_IA64_FltF86   =   2134,              
    CV_IA64_FltF87   =   2135,              
    CV_IA64_FltF88   =   2136,              
    CV_IA64_FltF89   =   2137,              
    CV_IA64_FltF90   =   2138,              
    CV_IA64_FltF91   =   2139,              
    CV_IA64_FltF92   =   2140,              
    CV_IA64_FltF93   =   2141,              
    CV_IA64_FltF94   =   2142,              
    CV_IA64_FltF95   =   2143,              
    CV_IA64_FltF96   =   2144,              
    CV_IA64_FltF97   =   2145,              
    CV_IA64_FltF98   =   2146,              
    CV_IA64_FltF99   =   2147,              
    CV_IA64_FltF100   =   2148,              
    CV_IA64_FltF101   =   2149,              
    CV_IA64_FltF102   =   2150,              
    CV_IA64_FltF103   =   2151,              
    CV_IA64_FltF104   =   2152,              
    CV_IA64_FltF105   =   2153,              
    CV_IA64_FltF106   =   2154,              
    CV_IA64_FltF107   =   2155,              
    CV_IA64_FltF108   =   2156,              
    CV_IA64_FltF109   =   2157,              
    CV_IA64_FltF110   =   2158,              
    CV_IA64_FltF111   =   2159,              
    CV_IA64_FltF112   =   2160,              
    CV_IA64_FltF113   =   2161,              
    CV_IA64_FltF114   =   2162,              
    CV_IA64_FltF115   =   2163,              
    CV_IA64_FltF116   =   2164,              
    CV_IA64_FltF117   =   2165,              
    CV_IA64_FltF118   =   2166,              
    CV_IA64_FltF119   =   2167,              
    CV_IA64_FltF120   =   2168,              
    CV_IA64_FltF121   =   2169,              
    CV_IA64_FltF122   =   2170,              
    CV_IA64_FltF123   =   2171,              
    CV_IA64_FltF124   =   2172,              
    CV_IA64_FltF125   =   2173,              
    CV_IA64_FltF126   =   2174,              
    CV_IA64_FltF127   =   2175,              

    // Application Registers              

    CV_IA64_ApKR0    =   3072,              
    CV_IA64_ApKR1    =   3073,              
    CV_IA64_ApKR2    =   3074,              
    CV_IA64_ApKR3    =   3075,              
    CV_IA64_ApKR4    =   3076,              
    CV_IA64_ApKR5    =   3077,              
    CV_IA64_ApKR6    =   3078,              
    CV_IA64_ApKR7    =   3079,              
    CV_IA64_AR8      =   3080,              
    CV_IA64_AR9      =   3081,              
    CV_IA64_AR10     =   3082,              
    CV_IA64_AR11     =   3083,              
    CV_IA64_AR12     =   3084,              
    CV_IA64_AR13     =   3085,              
    CV_IA64_AR14     =   3086,              
    CV_IA64_AR15     =   3087,              
    CV_IA64_RsRSC    =   3088,              
    CV_IA64_RsBSP    =   3089,              
    CV_IA64_RsBSPSTORE =   3090,              
    CV_IA64_RsRNAT   =   3091,              
    CV_IA64_AR20     =   3092,              
    CV_IA64_AR21     =   3093,              
    CV_IA64_AR22     =   3094,              
    CV_IA64_AR23     =   3095,              
    CV_IA64_AR24     =   3096,              
    CV_IA64_AR25     =   3097,              
    CV_IA64_AR26     =   3098,              
    CV_IA64_AR27     =   3099,              
    CV_IA64_AR28     =   3100,              
    CV_IA64_AR29     =   3101,              
    CV_IA64_AR30     =   3102,              
    CV_IA64_AR31     =   3103,              
    CV_IA64_ApCCV    =   3104,              
    CV_IA64_AR33     =   3105,              
    CV_IA64_AR34     =   3106,              
    CV_IA64_AR35     =   3107,              
    CV_IA64_ApUNAT   =   3108,              
    CV_IA64_AR37     =   3109,              
    CV_IA64_AR38     =   3110,              
    CV_IA64_AR39     =   3111,              
    CV_IA64_StFPSR   =   3112,              
    CV_IA64_AR41     =   3113,              
    CV_IA64_AR42     =   3114,              
    CV_IA64_AR43     =   3115,              
    CV_IA64_ApITC    =   3116,              
    CV_IA64_AR45     =   3117,              
    CV_IA64_AR46     =   3118,              
    CV_IA64_AR47     =   3119,              
    CV_IA64_AR48     =   3120,              
    CV_IA64_AR49     =   3121,              
    CV_IA64_AR50     =   3122,              
    CV_IA64_AR51     =   3123,              
    CV_IA64_AR52     =   3124,              
    CV_IA64_AR53     =   3125,              
    CV_IA64_AR54     =   3126,              
    CV_IA64_AR55     =   3127,              
    CV_IA64_AR56     =   3128,              
    CV_IA64_AR57     =   3129,              
    CV_IA64_AR58     =   3130,              
    CV_IA64_AR59     =   3131,              
    CV_IA64_AR60     =   3132,              
    CV_IA64_AR61     =   3133,              
    CV_IA64_AR62     =   3134,              
    CV_IA64_AR63     =   3135,              
    CV_IA64_RsPFS    =   3136,              
    CV_IA64_ApLC     =   3137,              
    CV_IA64_ApEC     =   3138,              
    CV_IA64_AR67   =   3139,              
    CV_IA64_AR68   =   3140,              
    CV_IA64_AR69   =   3141,              
    CV_IA64_AR70   =   3142,              
    CV_IA64_AR71   =   3143,              
    CV_IA64_AR72   =   3144,              
    CV_IA64_AR73   =   3145,              
    CV_IA64_AR74   =   3146,              
    CV_IA64_AR75   =   3147,              
    CV_IA64_AR76   =   3148,              
    CV_IA64_AR77   =   3149,              
    CV_IA64_AR78   =   3150,              
    CV_IA64_AR79   =   3151,              
    CV_IA64_AR80   =   3152,              
    CV_IA64_AR81   =   3153,              
    CV_IA64_AR82   =   3154,              
    CV_IA64_AR83   =   3155,              
    CV_IA64_AR84   =   3156,              
    CV_IA64_AR85   =   3157,              
    CV_IA64_AR86   =   3158,              
    CV_IA64_AR87   =   3159,              
    CV_IA64_AR88   =   3160,              
    CV_IA64_AR89   =   3161,              
    CV_IA64_AR90   =   3162,              
    CV_IA64_AR91   =   3163,              
    CV_IA64_AR92   =   3164,              
    CV_IA64_AR93   =   3165,              
    CV_IA64_AR94   =   3166,              
    CV_IA64_AR95   =   3167,              
    CV_IA64_AR96   =   3168,              
    CV_IA64_AR97   =   3169,              
    CV_IA64_AR98   =   3170,              
    CV_IA64_AR99   =   3171,              
    CV_IA64_AR100   =   3172,              
    CV_IA64_AR101   =   3173,              
    CV_IA64_AR102   =   3174,              
    CV_IA64_AR103   =   3175,              
    CV_IA64_AR104   =   3176,              
    CV_IA64_AR105   =   3177,              
    CV_IA64_AR106   =   3178,              
    CV_IA64_AR107   =   3179,              
    CV_IA64_AR108   =   3180,              
    CV_IA64_AR109   =   3181,              
    CV_IA64_AR110   =   3182,              
    CV_IA64_AR111   =   3183,              
    CV_IA64_AR112   =   3184,              
    CV_IA64_AR113   =   3185,              
    CV_IA64_AR114   =   3186,              
    CV_IA64_AR115   =   3187,              
    CV_IA64_AR116   =   3188,              
    CV_IA64_AR117   =   3189,              
    CV_IA64_AR118   =   3190,              
    CV_IA64_AR119   =   3191,              
    CV_IA64_AR120   =   3192,              
    CV_IA64_AR121   =   3193,              
    CV_IA64_AR122   =   3194,              
    CV_IA64_AR123   =   3195,              
    CV_IA64_AR124   =   3196,              
    CV_IA64_AR125   =   3197,              
    CV_IA64_AR126   =   3198,              
    CV_IA64_AR127   =   3199,              

    // CPUID Registers                
    CV_IA64_CPUID0  =   3328,              
    CV_IA64_CPUID1  =   3329,              
    CV_IA64_CPUID2  =   3330,              
    CV_IA64_CPUID3  =   3331,              
    CV_IA64_CPUID4  =   3332,              

    // Control Registers              

    CV_IA64_ApDCR    =   4096,              
    CV_IA64_ApITM    =   4097,              
    CV_IA64_ApIVA    =   4098,              
    CV_IA64_CR3      =   4099,              
    CV_IA64_CR4      =   4100,              
    CV_IA64_CR5      =   4101,              
    CV_IA64_CR6      =   4102,              
    CV_IA64_CR7      =   4103,              
    CV_IA64_ApPTA    =   4104,              
    CV_IA64_ApGPTA   =   4105,              
    CV_IA64_CR10     =   4106,              
    CV_IA64_CR11     =   4107,              
    CV_IA64_CR12     =   4108,              
    CV_IA64_CR13     =   4109,              
    CV_IA64_CR14     =   4110,              
    CV_IA64_CR15     =   4111,              
    CV_IA64_StIPSR   =   4112,              
    CV_IA64_StISR    =   4113,              
    CV_IA64_CR18     =   4114,              
    CV_IA64_StIIP    =   4115,              
    CV_IA64_StIFA    =   4116,              
    CV_IA64_StITIR   =   4117,              
    CV_IA64_StIIPA   =   4118,              
    CV_IA64_StIFS    =   4119,              
    CV_IA64_StIIM    =   4120,              
    CV_IA64_StIHA    =   4121,              
    CV_IA64_CR26     =   4122,              
    CV_IA64_CR27     =   4123,              
    CV_IA64_CR28     =   4124,              
    CV_IA64_CR29     =   4125,              
    CV_IA64_CR30     =   4126,              
    CV_IA64_CR31     =   4127,              
    CV_IA64_CR32     =   4128,              
    CV_IA64_CR33     =   4129,              
    CV_IA64_CR34     =   4130,              
    CV_IA64_CR35     =   4131,              
    CV_IA64_CR36     =   4132,              
    CV_IA64_CR37     =   4133,              
    CV_IA64_CR38     =   4134,              
    CV_IA64_CR39     =   4135,              
    CV_IA64_CR40     =   4136,              
    CV_IA64_CR41     =   4137,              
    CV_IA64_CR42     =   4138,              
    CV_IA64_CR43     =   4139,              
    CV_IA64_CR44     =   4140,              
    CV_IA64_CR45     =   4141,              
    CV_IA64_CR46     =   4142,              
    CV_IA64_CR47     =   4143,              
    CV_IA64_CR48     =   4144,              
    CV_IA64_CR49     =   4145,              
    CV_IA64_CR50     =   4146,              
    CV_IA64_CR51     =   4147,              
    CV_IA64_CR52     =   4148,              
    CV_IA64_CR53     =   4149,              
    CV_IA64_CR54     =   4150,              
    CV_IA64_CR55     =   4151,              
    CV_IA64_CR56     =   4152,              
    CV_IA64_CR57     =   4153,              
    CV_IA64_CR58     =   4154,              
    CV_IA64_CR59     =   4155,              
    CV_IA64_CR60     =   4156,              
    CV_IA64_CR61     =   4157,              
    CV_IA64_CR62     =   4158,              
    CV_IA64_CR63     =   4159,              
    CV_IA64_SaLID    =   4160,              
    CV_IA64_SaIVR    =   4161,              
    CV_IA64_SaTPR    =   4162,              
    CV_IA64_SaEOI    =   4163,              
    CV_IA64_SaIRR0   =   4164,              
    CV_IA64_SaIRR1   =   4165,              
    CV_IA64_SaIRR2   =   4166,              
    CV_IA64_SaIRR3   =   4167,              
    CV_IA64_SaITV    =   4168,              
    CV_IA64_SaPMV    =   4169,              
    CV_IA64_SaCMCV   =   4170,              
    CV_IA64_CR75     =   4171,              
    CV_IA64_CR76     =   4172,              
    CV_IA64_CR77     =   4173,              
    CV_IA64_CR78     =   4174,              
    CV_IA64_CR79     =   4175,              
    CV_IA64_SaLRR0   =   4176,              
    CV_IA64_SaLRR1   =   4177,              
    CV_IA64_CR82     =   4178,              
    CV_IA64_CR83     =   4179,              
    CV_IA64_CR84     =   4180,              
    CV_IA64_CR85     =   4181,              
    CV_IA64_CR86     =   4182,              
    CV_IA64_CR87     =   4183,              
    CV_IA64_CR88     =   4184,              
    CV_IA64_CR89     =   4185,              
    CV_IA64_CR90     =   4186,              
    CV_IA64_CR91     =   4187,              
    CV_IA64_CR92     =   4188,              
    CV_IA64_CR93     =   4189,              
    CV_IA64_CR94     =   4190,              
    CV_IA64_CR95     =   4191,              
    CV_IA64_CR96     =   4192,              
    CV_IA64_CR97     =   4193,              
    CV_IA64_CR98     =   4194,              
    CV_IA64_CR99     =   4195,              
    CV_IA64_CR100    =   4196,              
    CV_IA64_CR101    =   4197,              
    CV_IA64_CR102    =   4198,              
    CV_IA64_CR103    =   4199,              
    CV_IA64_CR104    =   4200,              
    CV_IA64_CR105    =   4201,              
    CV_IA64_CR106    =   4202,              
    CV_IA64_CR107    =   4203,              
    CV_IA64_CR108    =   4204,              
    CV_IA64_CR109    =   4205,              
    CV_IA64_CR110    =   4206,              
    CV_IA64_CR111    =   4207,              
    CV_IA64_CR112    =   4208,              
    CV_IA64_CR113    =   4209,              
    CV_IA64_CR114    =   4210,              
    CV_IA64_CR115    =   4211,              
    CV_IA64_CR116    =   4212,              
    CV_IA64_CR117    =   4213,              
    CV_IA64_CR118    =   4214,              
    CV_IA64_CR119    =   4215,              
    CV_IA64_CR120    =   4216,              
    CV_IA64_CR121    =   4217,              
    CV_IA64_CR122    =   4218,              
    CV_IA64_CR123    =   4219,              
    CV_IA64_CR124    =   4220,              
    CV_IA64_CR125    =   4221,              
    CV_IA64_CR126    =   4222,              
    CV_IA64_CR127    =   4223,              

    // Protection Key Registers              

    CV_IA64_Pkr0     =   5120,              
    CV_IA64_Pkr1     =   5121,              
    CV_IA64_Pkr2     =   5122,              
    CV_IA64_Pkr3     =   5123,              
    CV_IA64_Pkr4     =   5124,              
    CV_IA64_Pkr5     =   5125,              
    CV_IA64_Pkr6     =   5126,              
    CV_IA64_Pkr7     =   5127,              
    CV_IA64_Pkr8     =   5128,              
    CV_IA64_Pkr9     =   5129,              
    CV_IA64_Pkr10    =   5130,              
    CV_IA64_Pkr11    =   5131,              
    CV_IA64_Pkr12    =   5132,              
    CV_IA64_Pkr13    =   5133,              
    CV_IA64_Pkr14    =   5134,              
    CV_IA64_Pkr15    =   5135,              

    // Region Registers

    CV_IA64_Rr0      =   6144,              
    CV_IA64_Rr1      =   6145,              
    CV_IA64_Rr2      =   6146,              
    CV_IA64_Rr3      =   6147,              
    CV_IA64_Rr4      =   6148,              
    CV_IA64_Rr5      =   6149,              
    CV_IA64_Rr6      =   6150,              
    CV_IA64_Rr7      =   6151,              

    // Performance Monitor Data Registers              

    CV_IA64_PFD0     =   7168,              
    CV_IA64_PFD1     =   7169,              
    CV_IA64_PFD2     =   7170,              
    CV_IA64_PFD3     =   7171,              
    CV_IA64_PFD4     =   7172,              
    CV_IA64_PFD5     =   7173,              
    CV_IA64_PFD6     =   7174,              
    CV_IA64_PFD7     =   7175,              

    // Performance Monitor Config Registers              

    CV_IA64_PFC0     =   7424,              
    CV_IA64_PFC1     =   7425,              
    CV_IA64_PFC2     =   7426,              
    CV_IA64_PFC3     =   7427,              
    CV_IA64_PFC4     =   7428,              
    CV_IA64_PFC5     =   7429,              
    CV_IA64_PFC6     =   7430,              
    CV_IA64_PFC7     =   7431,              

    // Instruction Translation Registers              

    CV_IA64_TrI0     =   8192,              
    CV_IA64_TrI1     =   8193,              
    CV_IA64_TrI2     =   8194,              
    CV_IA64_TrI3     =   8195,              
    CV_IA64_TrI4     =   8196,              
    CV_IA64_TrI5     =   8197,              
    CV_IA64_TrI6     =   8198,              
    CV_IA64_TrI7     =   8199,              

    // Data Translation Registers              

    CV_IA64_TrD0     =   8320,              
    CV_IA64_TrD1     =   8321,              
    CV_IA64_TrD2     =   8322,              
    CV_IA64_TrD3     =   8323,              
    CV_IA64_TrD4     =   8324,              
    CV_IA64_TrD5     =   8325,              
    CV_IA64_TrD6     =   8326,              
    CV_IA64_TrD7     =   8327,              

    // Instruction Breakpoint Registers              

    CV_IA64_DbI0     =   8448,              
    CV_IA64_DbI1     =   8449,              
    CV_IA64_DbI2     =   8450,              
    CV_IA64_DbI3     =   8451,              
    CV_IA64_DbI4     =   8452,              
    CV_IA64_DbI5     =   8453,              
    CV_IA64_DbI6     =   8454,              
    CV_IA64_DbI7     =   8455,              

    // Data Breakpoint Registers              

    CV_IA64_DbD0     =   8576,              
    CV_IA64_DbD1     =   8577,              
    CV_IA64_DbD2     =   8578,              
    CV_IA64_DbD3     =   8579,              
    CV_IA64_DbD4     =   8580,              
    CV_IA64_DbD5     =   8581,              
    CV_IA64_DbD6     =   8582,              
    CV_IA64_DbD7     =   8583,              

} IA64_REG_INDEX;              

//
// __lfetch control defines.
//

#define MD_LFHINT_NONE    0x00
#define MD_LFHINT_NT1     0x01
#define MD_LFHINT_NT2     0x02
#define MD_LFHINT_NTA     0x03

#endif // _IA64REG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\hxhelppaneproxy.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for hxhelppaneproxy.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __hxhelppaneproxy_h__
#define __hxhelppaneproxy_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IHxHelpPane_FWD_DEFINED__
#define __IHxHelpPane_FWD_DEFINED__
typedef interface IHxHelpPane IHxHelpPane;
#endif 	/* __IHxHelpPane_FWD_DEFINED__ */


#ifndef __HxHelpPane_FWD_DEFINED__
#define __HxHelpPane_FWD_DEFINED__

#ifdef __cplusplus
typedef class HxHelpPane HxHelpPane;
#else
typedef struct HxHelpPane HxHelpPane;
#endif /* __cplusplus */

#endif 	/* __HxHelpPane_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_hxhelppaneproxy_0000_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_hxhelppaneproxy_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hxhelppaneproxy_0000_0000_v0_0_s_ifspec;

#ifndef __IHxHelpPane_INTERFACE_DEFINED__
#define __IHxHelpPane_INTERFACE_DEFINED__

/* interface IHxHelpPane */
/* [hidden][oleautomation][helpstring][uuid][unique][object] */ 


EXTERN_C const IID IID_IHxHelpPane;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8cec5884-07a1-11d9-b15e-000d56bfe6ee")
    IHxHelpPane : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DisplayTask( 
            /* [in] */ __RPC__in BSTR bstrUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayContents( 
            /* [in] */ __RPC__in BSTR bstrUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplaySearchResults( 
            /* [in] */ __RPC__in BSTR bstrSearchQuery) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHxHelpPaneVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHxHelpPane * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHxHelpPane * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHxHelpPane * This);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayTask )( 
            IHxHelpPane * This,
            /* [in] */ __RPC__in BSTR bstrUrl);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayContents )( 
            IHxHelpPane * This,
            /* [in] */ __RPC__in BSTR bstrUrl);
        
        HRESULT ( STDMETHODCALLTYPE *DisplaySearchResults )( 
            IHxHelpPane * This,
            /* [in] */ __RPC__in BSTR bstrSearchQuery);
        
        END_INTERFACE
    } IHxHelpPaneVtbl;

    interface IHxHelpPane
    {
        CONST_VTBL struct IHxHelpPaneVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHxHelpPane_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHxHelpPane_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHxHelpPane_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHxHelpPane_DisplayTask(This,bstrUrl)	\
    ( (This)->lpVtbl -> DisplayTask(This,bstrUrl) ) 

#define IHxHelpPane_DisplayContents(This,bstrUrl)	\
    ( (This)->lpVtbl -> DisplayContents(This,bstrUrl) ) 

#define IHxHelpPane_DisplaySearchResults(This,bstrSearchQuery)	\
    ( (This)->lpVtbl -> DisplaySearchResults(This,bstrSearchQuery) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHxHelpPane_INTERFACE_DEFINED__ */



#ifndef __HelpPane_LIBRARY_DEFINED__
#define __HelpPane_LIBRARY_DEFINED__

/* library HelpPane */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HelpPane;

EXTERN_C const CLSID CLSID_HxHelpPane;

#ifdef __cplusplus

class DECLSPEC_UUID("8cec58e7-07a1-11d9-b15e-000d56bfe6ee")
HxHelpPane;
#endif
#endif /* __HelpPane_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_hxhelppaneproxy_0000_0001 */
/* [local] */ 

#ifdef _INC_COMDEF
    _COM_SMARTPTR_TYPEDEF(IHxHelpPane,__uuidof(IHxHelpPane)) ;
#endif


extern RPC_IF_HANDLE __MIDL_itf_hxhelppaneproxy_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hxhelppaneproxy_0000_0001_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\IACOM.h ===
//-------------------------------------------------------------------------- 
// 
//  Copyright (c) Microsoft Corporation.  All rights reserved. 
// 
//  File: iacom.h 
//      Microsoft Tablet PC API definitions 
// 
//-------------------------------------------------------------------------- 
	
 	
 	

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for iacom.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __iacom_h__
#define __iacom_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IInkAnalyzer_FWD_DEFINED__
#define __IInkAnalyzer_FWD_DEFINED__
typedef interface IInkAnalyzer IInkAnalyzer;
#endif 	/* __IInkAnalyzer_FWD_DEFINED__ */


#ifndef __IContextNode_FWD_DEFINED__
#define __IContextNode_FWD_DEFINED__
typedef interface IContextNode IContextNode;
#endif 	/* __IContextNode_FWD_DEFINED__ */


#ifndef __IContextNodes_FWD_DEFINED__
#define __IContextNodes_FWD_DEFINED__
typedef interface IContextNodes IContextNodes;
#endif 	/* __IContextNodes_FWD_DEFINED__ */


#ifndef __IAnalysisRegion_FWD_DEFINED__
#define __IAnalysisRegion_FWD_DEFINED__
typedef interface IAnalysisRegion IAnalysisRegion;
#endif 	/* __IAnalysisRegion_FWD_DEFINED__ */


#ifndef __IContextLink_FWD_DEFINED__
#define __IContextLink_FWD_DEFINED__
typedef interface IContextLink IContextLink;
#endif 	/* __IContextLink_FWD_DEFINED__ */


#ifndef __IContextLinks_FWD_DEFINED__
#define __IContextLinks_FWD_DEFINED__
typedef interface IContextLinks IContextLinks;
#endif 	/* __IContextLinks_FWD_DEFINED__ */


#ifndef __IInkAnalysisRecognizer_FWD_DEFINED__
#define __IInkAnalysisRecognizer_FWD_DEFINED__
typedef interface IInkAnalysisRecognizer IInkAnalysisRecognizer;
#endif 	/* __IInkAnalysisRecognizer_FWD_DEFINED__ */


#ifndef __IInkAnalysisRecognizers_FWD_DEFINED__
#define __IInkAnalysisRecognizers_FWD_DEFINED__
typedef interface IInkAnalysisRecognizers IInkAnalysisRecognizers;
#endif 	/* __IInkAnalysisRecognizers_FWD_DEFINED__ */


#ifndef __IAnalysisAlternate_FWD_DEFINED__
#define __IAnalysisAlternate_FWD_DEFINED__
typedef interface IAnalysisAlternate IAnalysisAlternate;
#endif 	/* __IAnalysisAlternate_FWD_DEFINED__ */


#ifndef __IAnalysisAlternates_FWD_DEFINED__
#define __IAnalysisAlternates_FWD_DEFINED__
typedef interface IAnalysisAlternates IAnalysisAlternates;
#endif 	/* __IAnalysisAlternates_FWD_DEFINED__ */


#ifndef __IAnalysisWarning_FWD_DEFINED__
#define __IAnalysisWarning_FWD_DEFINED__
typedef interface IAnalysisWarning IAnalysisWarning;
#endif 	/* __IAnalysisWarning_FWD_DEFINED__ */


#ifndef __IAnalysisWarnings_FWD_DEFINED__
#define __IAnalysisWarnings_FWD_DEFINED__
typedef interface IAnalysisWarnings IAnalysisWarnings;
#endif 	/* __IAnalysisWarnings_FWD_DEFINED__ */


#ifndef __IAnalysisStatus_FWD_DEFINED__
#define __IAnalysisStatus_FWD_DEFINED__
typedef interface IAnalysisStatus IAnalysisStatus;
#endif 	/* __IAnalysisStatus_FWD_DEFINED__ */


#ifndef __IMatchesCriteriaCallBack_FWD_DEFINED__
#define __IMatchesCriteriaCallBack_FWD_DEFINED__
typedef interface IMatchesCriteriaCallBack IMatchesCriteriaCallBack;
#endif 	/* __IMatchesCriteriaCallBack_FWD_DEFINED__ */


#ifndef ___IAnalysisEvents_FWD_DEFINED__
#define ___IAnalysisEvents_FWD_DEFINED__
typedef interface _IAnalysisEvents _IAnalysisEvents;
#endif 	/* ___IAnalysisEvents_FWD_DEFINED__ */


#ifndef ___IAnalysisProxyEvents_FWD_DEFINED__
#define ___IAnalysisProxyEvents_FWD_DEFINED__
typedef interface _IAnalysisProxyEvents _IAnalysisProxyEvents;
#endif 	/* ___IAnalysisProxyEvents_FWD_DEFINED__ */


#ifndef __InkAnalyzer_FWD_DEFINED__
#define __InkAnalyzer_FWD_DEFINED__

#ifdef __cplusplus
typedef class InkAnalyzer InkAnalyzer;
#else
typedef struct InkAnalyzer InkAnalyzer;
#endif /* __cplusplus */

#endif 	/* __InkAnalyzer_FWD_DEFINED__ */


#ifndef __AnalysisRegion_FWD_DEFINED__
#define __AnalysisRegion_FWD_DEFINED__

#ifdef __cplusplus
typedef class AnalysisRegion AnalysisRegion;
#else
typedef struct AnalysisRegion AnalysisRegion;
#endif /* __cplusplus */

#endif 	/* __AnalysisRegion_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_iacom_0000 */
/* [local] */ 

#ifndef _COMINKANALYSIS_H_
#define _COMINKANALYSIS_H_


extern RPC_IF_HANDLE __MIDL_itf_iacom_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iacom_0000_v0_0_s_ifspec;


#ifndef __COMINKANALYSISLib_LIBRARY_DEFINED__
#define __COMINKANALYSISLib_LIBRARY_DEFINED__

/* library COMINKANALYSISLib */
/* [helpcontext][helpstring][version][uuid] */ 















typedef /* [helpcontext][helpstring] */ 
enum StrokeType
    {	StrokeType_Unclassified	= 0,
	StrokeType_Writing	= 1,
	StrokeType_Drawing	= 2
    } 	StrokeType;

typedef /* [helpcontext][helpstring] */ 
enum ConfirmationType
    {	ConfirmationType_None	= 0,
	ConfirmationType_NodeTypeAndProperties	= 3,
	ConfirmationType_TopBoundary	= 4
    } 	ConfirmationType;

typedef /* [helpcontext][helpstring] */ 
enum AnalysisModes
    {	AnalysisModes_None	= 0,
	AnalysisModes_AutomaticReconciliation	= 0x2,
	AnalysisModes_StrokeCacheAutoCleanup	= 0x4,
	AnalysisModes_Personalization	= 0x8,
	AnalysisModes_Default	= 0xd
    } 	AnalysisModes;

typedef /* [helpcontext][helpstring] */ 
enum SemanticType
    {	SemanticType_None	= 0,
	SemanticType_Underline	= 1,
	SemanticType_Strikethrough	= 2,
	SemanticType_Highlight	= 3,
	SemanticType_ScratchOut	= 4,
	SemanticType_VerticalRange	= 5,
	SemanticType_Callout	= 6,
	SemanticType_Enclosure	= 7,
	SemanticType_Comment	= 100,
	SemanticType_Container	= 200,
	SemanticType_Connector	= 201
    } 	SemanticType;

typedef /* [helpcontext][helpstring] */ 
enum ContextLinkDirection
    {	ContextLinkDirection_LinksWith	= 0,
	ContextLinkDirection_LinksFrom	= 1,
	ContextLinkDirection_LinksTo	= 2
    } 	ContextLinkDirection;

typedef /* [helpcontext][helpstring] */ 
enum AnalysisWarningCode
    {	AnalysisWarningCode_Aborted	= 0,
	AnalysisWarningCode_NoMatchingInkAnalysisRecognizerFound	= 1,
	AnalysisWarningCode_FactoidNotSupported	= 2,
	AnalysisWarningCode_FactoidCoercionNotSupported	= 3,
	AnalysisWarningCode_GuideNotSupported	= 4,
	AnalysisWarningCode_WordlistNotSupported	= 5,
	AnalysisWarningCode_WordModeNotSupported	= 6,
	AnalysisWarningCode_PartialDictionaryTermsNotSupported	= 7,
	AnalysisWarningCode_TextRecognitionProcessFailed	= 8,
	AnalysisWarningCode_AddInkToRecognizerFailed	= 9,
	AnalysisWarningCode_SetPrefixSuffixFailed	= 10,
	AnalysisWarningCode_InkAnalysisRecognizerInitializationFailed	= 11,
	AnalysisWarningCode_ConfirmedWithoutInkRecognition	= 12,
	AnalysisWarningCode_BackgroundException	= 13,
	AnalysisWarningCode_ContextNodeLocationNotSet	= 14,
	AnalysisWarningCode_LanguageIdNotRespected	= 15,
	AnalysisWarningCode_EnableUnicodeCharacterRangesNotSupported	= 16,
	AnalysisWarningCode_TopInkBreaksOnlyNotSupported	= 17,
	AnalysisWarningCode_AnalysisAlreadyRunning	= 18
    } 	AnalysisWarningCode;

typedef /* [helpcontext][helpstring] */ 
enum RecognitionConfidence
    {	RecognitionConfidence_Strong	= 0,
	RecognitionConfidence_Intermediate	= 1,
	RecognitionConfidence_Poor	= 2,
	RecognitionConfidence_Unknown	= 3
    } 	RecognitionConfidence;

typedef /* [helpcontext][helpstring] */ 
enum InkAnalysisRecognizerCapabilities
    {	RC_None	= 0,
	RC_DoNotCare	= 0x1,
	RC_Object	= 0x2,
	RC_FreeInput	= 0x4,
	RC_LinedInput	= 0x8,
	RC_BoxedInput	= 0x10,
	RC_CharacterAutoCompletionInput	= 0x20,
	RC_RightAndDown	= 0x40,
	RC_LeftAndDown	= 0x80,
	RC_DownAndLeft	= 0x100,
	RC_DownAndRight	= 0x200,
	RC_ArbitraryAngle	= 0x400,
	RC_Lattice	= 0x800,
	RC_AdviseInkChange	= 0x1000,
	RC_StrokeReorder	= 0x2000,
	RC_Personalizable	= 0x4000,
	RC_PrefersArbitraryAngle	= 0x8000,
	RC_PrefersParagraphBreaking	= 0x10000,
	RC_PrefersSegmentationRecognition	= 0x20000
    } 	InkAnalysisRecognizerCapabilities;

typedef struct InkAnalysisRecognizerGuide
    {
    RECT rectWritingBox;
    RECT rectDrawnBox;
    long cRows;
    long cColumns;
    long midline;
    } 	InkAnalysisRecognizerGuide;


EXTERN_C const IID LIBID_COMINKANALYSISLib;

#ifndef __IInkAnalyzer_INTERFACE_DEFINED__
#define __IInkAnalyzer_INTERFACE_DEFINED__

/* interface IInkAnalyzer */
/* [unique][helpcontext][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IInkAnalyzer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31F8B4AE-F970-3A72-8595-867D286E3B7B")
    IInkAnalyzer : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetDirtyRegion( 
            /* [out] */ IAnalysisRegion **ppDirtyRegion) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetDirtyRegion( 
            /* [in] */ IAnalysisRegion *pDirtyRegion) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetStrokeType( 
            /* [in] */ LONG lStrokeId,
            /* [in] */ StrokeType StrokeType) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetStrokesType( 
            /* [in] */ ULONG ulStrokeIdCount,
            /* [size_is][in] */ LONG *plStrokes,
            /* [in] */ StrokeType StrokeType) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetStrokeType( 
            /* [in] */ LONG lStrokeId,
            /* [out] */ StrokeType *pStrokeType) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetStrokeLanguageId( 
            /* [in] */ LONG lStrokeId,
            /* [in] */ LONG lLanguageId) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetStrokesLanguageId( 
            /* [in] */ ULONG ulStrokeIdCount,
            /* [size_is][in] */ LONG *plStrokes,
            /* [in] */ LONG lStrokesLCID) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetStrokeLanguageId( 
            /* [in] */ LONG strokeId,
            /* [out] */ LONG *plLanguageId) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetRootNode( 
            /* [out] */ IContextNode **ppRootNode) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE BackgroundAnalyze( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Analyze( 
            /* [out] */ IAnalysisStatus **ppStatus) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IsAnalyzing( 
            /* [out] */ VARIANT_BOOL *pbAnalyzing) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Reconcile( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE TransactionalReconcile( 
            /* [in] */ LONG lTimeLimit,
            /* [out] */ VARIANT_BOOL *pbMoreToReconcile) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Abort( 
            /* [out] */ IAnalysisRegion **ppAbortedRegion) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetInkAnalysisRecognizersByPriority( 
            /* [out] */ IInkAnalysisRecognizers **ppInkAnalysisRecognizers) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetRecognizedString( 
            /* [out] */ BSTR *pbstrRecognizedString) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE AddStroke( 
            /* [in] */ LONG lStrokeId,
            /* [in] */ ULONG ulStrokePacketDataCount,
            /* [size_is][in] */ LONG *plStrokePacketData,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [out] */ IContextNode **ppContextNodeStrokeAddedTo) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE AddStrokes( 
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [size_is][in] */ ULONG *pulPacketDataCountPerStroke,
            /* [in] */ LONG *plStrokePacketData,
            /* [out] */ IContextNode **ppContextNodeStrokeAddedTo) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE AddStrokeForLanguage( 
            /* [in] */ LONG lStrokeId,
            /* [in] */ LONG lStrokeLCID,
            /* [in] */ ULONG ulStrokePacketDataCount,
            /* [size_is][in] */ LONG *plStrokePacketData,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [out] */ IContextNode **ppContextNodeStrokeAddedTo) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE AddStrokesForLanguage( 
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plIdofStrokesToAdd,
            /* [in] */ LONG lStrokesLCID,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [size_is][in] */ ULONG *pulPacketDataCountPerStroke,
            /* [in] */ LONG *plStrokePacketData,
            /* [out] */ IContextNode **ppContextNodeStrokeAddedTo) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ClearStrokeData( 
            /* [in] */ LONG lStrokeId) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE RemoveStroke( 
            /* [in] */ LONG lStrokeId) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE RemoveStrokes( 
            /* [in] */ ULONG ulStrokeIdCount,
            /* [size_is][in] */ LONG *plStrokeIds) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE UpdateStrokesData( 
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [size_is][in] */ ULONG *pulPacketDataCountPerStroke,
            /* [in] */ LONG *plStrokePacketData) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetAnalysisModes( 
            /* [out] */ AnalysisModes *pAnalysisMode) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetAnalysisModes( 
            /* [in] */ AnalysisModes analysisMode) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CreateAnalysisHint( 
            /* [out] */ IContextNode **ppAnalysisHint) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE DeleteAnalysisHint( 
            /* [in] */ IContextNode *pHintToDelete) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetAnalysisHints( 
            /* [out] */ IContextNodes **ppAnalysisHints) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetAnalysisHintsByName( 
            /* [in] */ BSTR hintName,
            /* [out] */ IContextNodes **ppAnalysisHints) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CreateContextNodes( 
            /* [out] */ IContextNodes **ppContextNodes) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetAlternatesForContextNodes( 
            /* [in] */ IContextNodes *pContextNodes,
            /* [in] */ ULONG ulMaximumAlternates,
            /* [out] */ IAnalysisAlternates **ppAlternates) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetAlternatesForStrokes( 
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokes,
            /* [in] */ ULONG ulMaximumAlternates,
            /* [out] */ IAnalysisAlternates **ppAlternates) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetAlternates( 
            /* [out] */ IAnalysisAlternates **ppAlternates) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ModifyTopAlternate( 
            /* [in] */ IAnalysisAlternate *pAlternate) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ModifyTopAlternateWithConfirmation( 
            /* [in] */ IAnalysisAlternate *alternate,
            /* [in] */ VARIANT_BOOL fconfirmAutomatically) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CreateCustomRecognizer( 
            /* [in] */ const GUID *pInkAnalysisRecognizerId,
            /* [out] */ IContextNode **ppContextNode) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE AddStrokeToCustomRecognizer( 
            /* [in] */ LONG lStrokeId,
            /* [in] */ ULONG ulStrokePacketDataCount,
            /* [size_is][in] */ LONG *plStrokePacketData,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [in] */ IContextNode *pCustomRecognizer,
            /* [out] */ IContextNode **ppContextNodeStrokeAddedTo) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE AddStrokesToCustomRecognizer( 
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [size_is][in] */ ULONG *pulPacketDataCountPerStroke,
            /* [in] */ LONG *plStrokePacketData,
            /* [in] */ IContextNode *pCustomRecognizer,
            /* [out] */ IContextNode **ppContextNodeStrokeAddedTo) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindNode( 
            /* [in] */ const GUID *pId,
            /* [out] */ IContextNode **ppContextNodeFound) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindLeafNodes( 
            /* [out] */ IContextNodes **ppContextNodesFound) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindInkLeafNodesForStrokes( 
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [out] */ IContextNodes **ppContextNodesFound) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindInkLeafNodes( 
            /* [out] */ IContextNodes **ppContextNodesFound) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindNodesOfType( 
            /* [in] */ const GUID *pNodeType,
            /* [out] */ IContextNodes **ppContextNodesFound) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindNodesOfTypeForStrokes( 
            /* [in] */ const GUID *pNodeType,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [out] */ IContextNodes **ppContextNodesFound) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindNodesOfTypeInSubTree( 
            /* [in] */ const GUID *pNodeType,
            /* [in] */ IContextNode *pContextNodeToSearchFrom,
            /* [out] */ IContextNodes **ppContextNodesFound) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindNodesWithCallBack( 
            /* [in] */ IMatchesCriteriaCallBack *pCriteria,
            /* [out] */ IContextNodes **ppContextNodesFound) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindNodesWithCallBackInSubTree( 
            /* [in] */ IMatchesCriteriaCallBack *pCriteria,
            /* [in] */ IContextNode *pContextNodeToSearchFrom,
            /* [out] */ IContextNodes **ppContextNodesFound) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE LoadResults( 
            /* [in] */ ULONG ulDataSize,
            /* [size_is][in] */ BYTE *pbSerializedData,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plOriginalStrokeIds,
            /* [size_is][in] */ LONG *plModifiedStrokeIds,
            /* [out] */ VARIANT_BOOL *pfRetVal) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SaveResults( 
            /* [in] */ ULONG ulMappedStrokeIdsCount,
            /* [size_is][in] */ LONG *plOriginalStrokeIds,
            /* [size_is][in] */ LONG *plModifiedStrokeIds,
            /* [out][in] */ ULONG *pulSerializedDataSize,
            /* [size_is][out] */ BYTE **ppbSerializedData) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SaveResultsForNodes( 
            /* [in] */ ULONG ulMappedStrokeIdsCount,
            /* [size_is][in] */ LONG *plOriginalStrokeIds,
            /* [size_is][in] */ LONG *plModifiedStrokeIds,
            /* [in] */ IContextNodes *pContextNodes,
            /* [out][in] */ ULONG *pulSerializedDataSize,
            /* [size_is][out] */ BYTE **ppbSerializedData) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SaveResultsForStrokes( 
            /* [in] */ ULONG ulMappedStrokeIdsCount,
            /* [size_is][in] */ LONG *plOriginalStrokeIds,
            /* [size_is][in] */ LONG *plModifiedStrokeIds,
            /* [in] */ ULONG ulStrokeIdCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [out][in] */ ULONG *pulSerializedDataSize,
            /* [size_is][out] */ BYTE **ppbSerializedData) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetNodesFromTextRange( 
            /* [out][in] */ LONG *plStart,
            /* [out][in] */ LONG *plLength,
            /* [out] */ IContextNodes **ppContextNodes,
            /* [defaultvalue][in] */ IContextNodes *pNodesToSearch = 0) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetTextRangeFromNodes( 
            /* [out] */ LONG *plStart,
            /* [out] */ LONG *plLength,
            /* [in] */ IContextNodes *pNodesToSearch) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Search( 
            /* [in] */ BSTR bstrPhraseToMatch,
            /* [out][in] */ ULONG *pulSearchResultCount,
            /* [size_is][out] */ ULONG **ppulStrokeCountPerResult,
            /* [out][in] */ ULONG *pulStrokeIdsCount,
            /* [size_is][out] */ ULONG **ppulStrokeIds) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SearchWithLanguageId( 
            /* [in] */ BSTR bstrPhraseToMatch,
            /* [in] */ LONG lSearchStringLanguageId,
            /* [out][in] */ ULONG *pulSearchResultCount,
            /* [size_is][out] */ ULONG **ppulStrokeCountPerResult,
            /* [out][in] */ ULONG *pulStrokeIdsCount,
            /* [size_is][out] */ ULONG **ppulStrokeIds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInkAnalyzerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInkAnalyzer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInkAnalyzer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInkAnalyzer * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDirtyRegion )( 
            IInkAnalyzer * This,
            /* [out] */ IAnalysisRegion **ppDirtyRegion);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDirtyRegion )( 
            IInkAnalyzer * This,
            /* [in] */ IAnalysisRegion *pDirtyRegion);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStrokeType )( 
            IInkAnalyzer * This,
            /* [in] */ LONG lStrokeId,
            /* [in] */ StrokeType StrokeType);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStrokesType )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulStrokeIdCount,
            /* [size_is][in] */ LONG *plStrokes,
            /* [in] */ StrokeType StrokeType);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStrokeType )( 
            IInkAnalyzer * This,
            /* [in] */ LONG lStrokeId,
            /* [out] */ StrokeType *pStrokeType);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStrokeLanguageId )( 
            IInkAnalyzer * This,
            /* [in] */ LONG lStrokeId,
            /* [in] */ LONG lLanguageId);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStrokesLanguageId )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulStrokeIdCount,
            /* [size_is][in] */ LONG *plStrokes,
            /* [in] */ LONG lStrokesLCID);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStrokeLanguageId )( 
            IInkAnalyzer * This,
            /* [in] */ LONG strokeId,
            /* [out] */ LONG *plLanguageId);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRootNode )( 
            IInkAnalyzer * This,
            /* [out] */ IContextNode **ppRootNode);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *BackgroundAnalyze )( 
            IInkAnalyzer * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Analyze )( 
            IInkAnalyzer * This,
            /* [out] */ IAnalysisStatus **ppStatus);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsAnalyzing )( 
            IInkAnalyzer * This,
            /* [out] */ VARIANT_BOOL *pbAnalyzing);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reconcile )( 
            IInkAnalyzer * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *TransactionalReconcile )( 
            IInkAnalyzer * This,
            /* [in] */ LONG lTimeLimit,
            /* [out] */ VARIANT_BOOL *pbMoreToReconcile);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IInkAnalyzer * This,
            /* [out] */ IAnalysisRegion **ppAbortedRegion);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetInkAnalysisRecognizersByPriority )( 
            IInkAnalyzer * This,
            /* [out] */ IInkAnalysisRecognizers **ppInkAnalysisRecognizers);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRecognizedString )( 
            IInkAnalyzer * This,
            /* [out] */ BSTR *pbstrRecognizedString);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddStroke )( 
            IInkAnalyzer * This,
            /* [in] */ LONG lStrokeId,
            /* [in] */ ULONG ulStrokePacketDataCount,
            /* [size_is][in] */ LONG *plStrokePacketData,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [out] */ IContextNode **ppContextNodeStrokeAddedTo);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddStrokes )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [size_is][in] */ ULONG *pulPacketDataCountPerStroke,
            /* [in] */ LONG *plStrokePacketData,
            /* [out] */ IContextNode **ppContextNodeStrokeAddedTo);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddStrokeForLanguage )( 
            IInkAnalyzer * This,
            /* [in] */ LONG lStrokeId,
            /* [in] */ LONG lStrokeLCID,
            /* [in] */ ULONG ulStrokePacketDataCount,
            /* [size_is][in] */ LONG *plStrokePacketData,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [out] */ IContextNode **ppContextNodeStrokeAddedTo);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddStrokesForLanguage )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plIdofStrokesToAdd,
            /* [in] */ LONG lStrokesLCID,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [size_is][in] */ ULONG *pulPacketDataCountPerStroke,
            /* [in] */ LONG *plStrokePacketData,
            /* [out] */ IContextNode **ppContextNodeStrokeAddedTo);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearStrokeData )( 
            IInkAnalyzer * This,
            /* [in] */ LONG lStrokeId);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveStroke )( 
            IInkAnalyzer * This,
            /* [in] */ LONG lStrokeId);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveStrokes )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulStrokeIdCount,
            /* [size_is][in] */ LONG *plStrokeIds);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *UpdateStrokesData )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [size_is][in] */ ULONG *pulPacketDataCountPerStroke,
            /* [in] */ LONG *plStrokePacketData);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAnalysisModes )( 
            IInkAnalyzer * This,
            /* [out] */ AnalysisModes *pAnalysisMode);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAnalysisModes )( 
            IInkAnalyzer * This,
            /* [in] */ AnalysisModes analysisMode);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateAnalysisHint )( 
            IInkAnalyzer * This,
            /* [out] */ IContextNode **ppAnalysisHint);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteAnalysisHint )( 
            IInkAnalyzer * This,
            /* [in] */ IContextNode *pHintToDelete);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAnalysisHints )( 
            IInkAnalyzer * This,
            /* [out] */ IContextNodes **ppAnalysisHints);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAnalysisHintsByName )( 
            IInkAnalyzer * This,
            /* [in] */ BSTR hintName,
            /* [out] */ IContextNodes **ppAnalysisHints);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateContextNodes )( 
            IInkAnalyzer * This,
            /* [out] */ IContextNodes **ppContextNodes);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAlternatesForContextNodes )( 
            IInkAnalyzer * This,
            /* [in] */ IContextNodes *pContextNodes,
            /* [in] */ ULONG ulMaximumAlternates,
            /* [out] */ IAnalysisAlternates **ppAlternates);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAlternatesForStrokes )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokes,
            /* [in] */ ULONG ulMaximumAlternates,
            /* [out] */ IAnalysisAlternates **ppAlternates);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAlternates )( 
            IInkAnalyzer * This,
            /* [out] */ IAnalysisAlternates **ppAlternates);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ModifyTopAlternate )( 
            IInkAnalyzer * This,
            /* [in] */ IAnalysisAlternate *pAlternate);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ModifyTopAlternateWithConfirmation )( 
            IInkAnalyzer * This,
            /* [in] */ IAnalysisAlternate *alternate,
            /* [in] */ VARIANT_BOOL fconfirmAutomatically);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateCustomRecognizer )( 
            IInkAnalyzer * This,
            /* [in] */ const GUID *pInkAnalysisRecognizerId,
            /* [out] */ IContextNode **ppContextNode);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddStrokeToCustomRecognizer )( 
            IInkAnalyzer * This,
            /* [in] */ LONG lStrokeId,
            /* [in] */ ULONG ulStrokePacketDataCount,
            /* [size_is][in] */ LONG *plStrokePacketData,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [in] */ IContextNode *pCustomRecognizer,
            /* [out] */ IContextNode **ppContextNodeStrokeAddedTo);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddStrokesToCustomRecognizer )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [in] */ ULONG ulStrokePacketDescriptionCount,
            /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
            /* [size_is][in] */ ULONG *pulPacketDataCountPerStroke,
            /* [in] */ LONG *plStrokePacketData,
            /* [in] */ IContextNode *pCustomRecognizer,
            /* [out] */ IContextNode **ppContextNodeStrokeAddedTo);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindNode )( 
            IInkAnalyzer * This,
            /* [in] */ const GUID *pId,
            /* [out] */ IContextNode **ppContextNodeFound);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindLeafNodes )( 
            IInkAnalyzer * This,
            /* [out] */ IContextNodes **ppContextNodesFound);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindInkLeafNodesForStrokes )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [out] */ IContextNodes **ppContextNodesFound);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindInkLeafNodes )( 
            IInkAnalyzer * This,
            /* [out] */ IContextNodes **ppContextNodesFound);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindNodesOfType )( 
            IInkAnalyzer * This,
            /* [in] */ const GUID *pNodeType,
            /* [out] */ IContextNodes **ppContextNodesFound);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindNodesOfTypeForStrokes )( 
            IInkAnalyzer * This,
            /* [in] */ const GUID *pNodeType,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [out] */ IContextNodes **ppContextNodesFound);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindNodesOfTypeInSubTree )( 
            IInkAnalyzer * This,
            /* [in] */ const GUID *pNodeType,
            /* [in] */ IContextNode *pContextNodeToSearchFrom,
            /* [out] */ IContextNodes **ppContextNodesFound);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindNodesWithCallBack )( 
            IInkAnalyzer * This,
            /* [in] */ IMatchesCriteriaCallBack *pCriteria,
            /* [out] */ IContextNodes **ppContextNodesFound);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindNodesWithCallBackInSubTree )( 
            IInkAnalyzer * This,
            /* [in] */ IMatchesCriteriaCallBack *pCriteria,
            /* [in] */ IContextNode *pContextNodeToSearchFrom,
            /* [out] */ IContextNodes **ppContextNodesFound);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *LoadResults )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulDataSize,
            /* [size_is][in] */ BYTE *pbSerializedData,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plOriginalStrokeIds,
            /* [size_is][in] */ LONG *plModifiedStrokeIds,
            /* [out] */ VARIANT_BOOL *pfRetVal);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SaveResults )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulMappedStrokeIdsCount,
            /* [size_is][in] */ LONG *plOriginalStrokeIds,
            /* [size_is][in] */ LONG *plModifiedStrokeIds,
            /* [out][in] */ ULONG *pulSerializedDataSize,
            /* [size_is][out] */ BYTE **ppbSerializedData);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SaveResultsForNodes )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulMappedStrokeIdsCount,
            /* [size_is][in] */ LONG *plOriginalStrokeIds,
            /* [size_is][in] */ LONG *plModifiedStrokeIds,
            /* [in] */ IContextNodes *pContextNodes,
            /* [out][in] */ ULONG *pulSerializedDataSize,
            /* [size_is][out] */ BYTE **ppbSerializedData);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SaveResultsForStrokes )( 
            IInkAnalyzer * This,
            /* [in] */ ULONG ulMappedStrokeIdsCount,
            /* [size_is][in] */ LONG *plOriginalStrokeIds,
            /* [size_is][in] */ LONG *plModifiedStrokeIds,
            /* [in] */ ULONG ulStrokeIdCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [out][in] */ ULONG *pulSerializedDataSize,
            /* [size_is][out] */ BYTE **ppbSerializedData);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNodesFromTextRange )( 
            IInkAnalyzer * This,
            /* [out][in] */ LONG *plStart,
            /* [out][in] */ LONG *plLength,
            /* [out] */ IContextNodes **ppContextNodes,
            /* [defaultvalue][in] */ IContextNodes *pNodesToSearch);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTextRangeFromNodes )( 
            IInkAnalyzer * This,
            /* [out] */ LONG *plStart,
            /* [out] */ LONG *plLength,
            /* [in] */ IContextNodes *pNodesToSearch);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Search )( 
            IInkAnalyzer * This,
            /* [in] */ BSTR bstrPhraseToMatch,
            /* [out][in] */ ULONG *pulSearchResultCount,
            /* [size_is][out] */ ULONG **ppulStrokeCountPerResult,
            /* [out][in] */ ULONG *pulStrokeIdsCount,
            /* [size_is][out] */ ULONG **ppulStrokeIds);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SearchWithLanguageId )( 
            IInkAnalyzer * This,
            /* [in] */ BSTR bstrPhraseToMatch,
            /* [in] */ LONG lSearchStringLanguageId,
            /* [out][in] */ ULONG *pulSearchResultCount,
            /* [size_is][out] */ ULONG **ppulStrokeCountPerResult,
            /* [out][in] */ ULONG *pulStrokeIdsCount,
            /* [size_is][out] */ ULONG **ppulStrokeIds);
        
        END_INTERFACE
    } IInkAnalyzerVtbl;

    interface IInkAnalyzer
    {
        CONST_VTBL struct IInkAnalyzerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInkAnalyzer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInkAnalyzer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInkAnalyzer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInkAnalyzer_GetDirtyRegion(This,ppDirtyRegion)	\
    (This)->lpVtbl -> GetDirtyRegion(This,ppDirtyRegion)

#define IInkAnalyzer_SetDirtyRegion(This,pDirtyRegion)	\
    (This)->lpVtbl -> SetDirtyRegion(This,pDirtyRegion)

#define IInkAnalyzer_SetStrokeType(This,lStrokeId,StrokeType)	\
    (This)->lpVtbl -> SetStrokeType(This,lStrokeId,StrokeType)

#define IInkAnalyzer_SetStrokesType(This,ulStrokeIdCount,plStrokes,StrokeType)	\
    (This)->lpVtbl -> SetStrokesType(This,ulStrokeIdCount,plStrokes,StrokeType)

#define IInkAnalyzer_GetStrokeType(This,lStrokeId,pStrokeType)	\
    (This)->lpVtbl -> GetStrokeType(This,lStrokeId,pStrokeType)

#define IInkAnalyzer_SetStrokeLanguageId(This,lStrokeId,lLanguageId)	\
    (This)->lpVtbl -> SetStrokeLanguageId(This,lStrokeId,lLanguageId)

#define IInkAnalyzer_SetStrokesLanguageId(This,ulStrokeIdCount,plStrokes,lStrokesLCID)	\
    (This)->lpVtbl -> SetStrokesLanguageId(This,ulStrokeIdCount,plStrokes,lStrokesLCID)

#define IInkAnalyzer_GetStrokeLanguageId(This,strokeId,plLanguageId)	\
    (This)->lpVtbl -> GetStrokeLanguageId(This,strokeId,plLanguageId)

#define IInkAnalyzer_GetRootNode(This,ppRootNode)	\
    (This)->lpVtbl -> GetRootNode(This,ppRootNode)

#define IInkAnalyzer_BackgroundAnalyze(This)	\
    (This)->lpVtbl -> BackgroundAnalyze(This)

#define IInkAnalyzer_Analyze(This,ppStatus)	\
    (This)->lpVtbl -> Analyze(This,ppStatus)

#define IInkAnalyzer_IsAnalyzing(This,pbAnalyzing)	\
    (This)->lpVtbl -> IsAnalyzing(This,pbAnalyzing)

#define IInkAnalyzer_Reconcile(This)	\
    (This)->lpVtbl -> Reconcile(This)

#define IInkAnalyzer_TransactionalReconcile(This,lTimeLimit,pbMoreToReconcile)	\
    (This)->lpVtbl -> TransactionalReconcile(This,lTimeLimit,pbMoreToReconcile)

#define IInkAnalyzer_Abort(This,ppAbortedRegion)	\
    (This)->lpVtbl -> Abort(This,ppAbortedRegion)

#define IInkAnalyzer_GetInkAnalysisRecognizersByPriority(This,ppInkAnalysisRecognizers)	\
    (This)->lpVtbl -> GetInkAnalysisRecognizersByPriority(This,ppInkAnalysisRecognizers)

#define IInkAnalyzer_GetRecognizedString(This,pbstrRecognizedString)	\
    (This)->lpVtbl -> GetRecognizedString(This,pbstrRecognizedString)

#define IInkAnalyzer_AddStroke(This,lStrokeId,ulStrokePacketDataCount,plStrokePacketData,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,ppContextNodeStrokeAddedTo)	\
    (This)->lpVtbl -> AddStroke(This,lStrokeId,ulStrokePacketDataCount,plStrokePacketData,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,ppContextNodeStrokeAddedTo)

#define IInkAnalyzer_AddStrokes(This,ulStrokeIdsCount,plStrokeIds,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,pulPacketDataCountPerStroke,plStrokePacketData,ppContextNodeStrokeAddedTo)	\
    (This)->lpVtbl -> AddStrokes(This,ulStrokeIdsCount,plStrokeIds,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,pulPacketDataCountPerStroke,plStrokePacketData,ppContextNodeStrokeAddedTo)

#define IInkAnalyzer_AddStrokeForLanguage(This,lStrokeId,lStrokeLCID,ulStrokePacketDataCount,plStrokePacketData,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,ppContextNodeStrokeAddedTo)	\
    (This)->lpVtbl -> AddStrokeForLanguage(This,lStrokeId,lStrokeLCID,ulStrokePacketDataCount,plStrokePacketData,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,ppContextNodeStrokeAddedTo)

#define IInkAnalyzer_AddStrokesForLanguage(This,ulStrokeIdsCount,plIdofStrokesToAdd,lStrokesLCID,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,pulPacketDataCountPerStroke,plStrokePacketData,ppContextNodeStrokeAddedTo)	\
    (This)->lpVtbl -> AddStrokesForLanguage(This,ulStrokeIdsCount,plIdofStrokesToAdd,lStrokesLCID,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,pulPacketDataCountPerStroke,plStrokePacketData,ppContextNodeStrokeAddedTo)

#define IInkAnalyzer_ClearStrokeData(This,lStrokeId)	\
    (This)->lpVtbl -> ClearStrokeData(This,lStrokeId)

#define IInkAnalyzer_RemoveStroke(This,lStrokeId)	\
    (This)->lpVtbl -> RemoveStroke(This,lStrokeId)

#define IInkAnalyzer_RemoveStrokes(This,ulStrokeIdCount,plStrokeIds)	\
    (This)->lpVtbl -> RemoveStrokes(This,ulStrokeIdCount,plStrokeIds)

#define IInkAnalyzer_UpdateStrokesData(This,ulStrokeIdsCount,plStrokeIds,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,pulPacketDataCountPerStroke,plStrokePacketData)	\
    (This)->lpVtbl -> UpdateStrokesData(This,ulStrokeIdsCount,plStrokeIds,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,pulPacketDataCountPerStroke,plStrokePacketData)

#define IInkAnalyzer_GetAnalysisModes(This,pAnalysisMode)	\
    (This)->lpVtbl -> GetAnalysisModes(This,pAnalysisMode)

#define IInkAnalyzer_SetAnalysisModes(This,analysisMode)	\
    (This)->lpVtbl -> SetAnalysisModes(This,analysisMode)

#define IInkAnalyzer_CreateAnalysisHint(This,ppAnalysisHint)	\
    (This)->lpVtbl -> CreateAnalysisHint(This,ppAnalysisHint)

#define IInkAnalyzer_DeleteAnalysisHint(This,pHintToDelete)	\
    (This)->lpVtbl -> DeleteAnalysisHint(This,pHintToDelete)

#define IInkAnalyzer_GetAnalysisHints(This,ppAnalysisHints)	\
    (This)->lpVtbl -> GetAnalysisHints(This,ppAnalysisHints)

#define IInkAnalyzer_GetAnalysisHintsByName(This,hintName,ppAnalysisHints)	\
    (This)->lpVtbl -> GetAnalysisHintsByName(This,hintName,ppAnalysisHints)

#define IInkAnalyzer_CreateContextNodes(This,ppContextNodes)	\
    (This)->lpVtbl -> CreateContextNodes(This,ppContextNodes)

#define IInkAnalyzer_GetAlternatesForContextNodes(This,pContextNodes,ulMaximumAlternates,ppAlternates)	\
    (This)->lpVtbl -> GetAlternatesForContextNodes(This,pContextNodes,ulMaximumAlternates,ppAlternates)

#define IInkAnalyzer_GetAlternatesForStrokes(This,ulStrokeIdsCount,plStrokes,ulMaximumAlternates,ppAlternates)	\
    (This)->lpVtbl -> GetAlternatesForStrokes(This,ulStrokeIdsCount,plStrokes,ulMaximumAlternates,ppAlternates)

#define IInkAnalyzer_GetAlternates(This,ppAlternates)	\
    (This)->lpVtbl -> GetAlternates(This,ppAlternates)

#define IInkAnalyzer_ModifyTopAlternate(This,pAlternate)	\
    (This)->lpVtbl -> ModifyTopAlternate(This,pAlternate)

#define IInkAnalyzer_ModifyTopAlternateWithConfirmation(This,alternate,fconfirmAutomatically)	\
    (This)->lpVtbl -> ModifyTopAlternateWithConfirmation(This,alternate,fconfirmAutomatically)

#define IInkAnalyzer_CreateCustomRecognizer(This,pInkAnalysisRecognizerId,ppContextNode)	\
    (This)->lpVtbl -> CreateCustomRecognizer(This,pInkAnalysisRecognizerId,ppContextNode)

#define IInkAnalyzer_AddStrokeToCustomRecognizer(This,lStrokeId,ulStrokePacketDataCount,plStrokePacketData,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,pCustomRecognizer,ppContextNodeStrokeAddedTo)	\
    (This)->lpVtbl -> AddStrokeToCustomRecognizer(This,lStrokeId,ulStrokePacketDataCount,plStrokePacketData,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,pCustomRecognizer,ppContextNodeStrokeAddedTo)

#define IInkAnalyzer_AddStrokesToCustomRecognizer(This,ulStrokeIdsCount,plStrokeIds,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,pulPacketDataCountPerStroke,plStrokePacketData,pCustomRecognizer,ppContextNodeStrokeAddedTo)	\
    (This)->lpVtbl -> AddStrokesToCustomRecognizer(This,ulStrokeIdsCount,plStrokeIds,ulStrokePacketDescriptionCount,pStrokePacketDescriptionGuids,pulPacketDataCountPerStroke,plStrokePacketData,pCustomRecognizer,ppContextNodeStrokeAddedTo)

#define IInkAnalyzer_FindNode(This,pId,ppContextNodeFound)	\
    (This)->lpVtbl -> FindNode(This,pId,ppContextNodeFound)

#define IInkAnalyzer_FindLeafNodes(This,ppContextNodesFound)	\
    (This)->lpVtbl -> FindLeafNodes(This,ppContextNodesFound)

#define IInkAnalyzer_FindInkLeafNodesForStrokes(This,ulStrokeIdsCount,plStrokeIds,ppContextNodesFound)	\
    (This)->lpVtbl -> FindInkLeafNodesForStrokes(This,ulStrokeIdsCount,plStrokeIds,ppContextNodesFound)

#define IInkAnalyzer_FindInkLeafNodes(This,ppContextNodesFound)	\
    (This)->lpVtbl -> FindInkLeafNodes(This,ppContextNodesFound)

#define IInkAnalyzer_FindNodesOfType(This,pNodeType,ppContextNodesFound)	\
    (This)->lpVtbl -> FindNodesOfType(This,pNodeType,ppContextNodesFound)

#define IInkAnalyzer_FindNodesOfTypeForStrokes(This,pNodeType,ulStrokeIdsCount,plStrokeIds,ppContextNodesFound)	\
    (This)->lpVtbl -> FindNodesOfTypeForStrokes(This,pNodeType,ulStrokeIdsCount,plStrokeIds,ppContextNodesFound)

#define IInkAnalyzer_FindNodesOfTypeInSubTree(This,pNodeType,pContextNodeToSearchFrom,ppContextNodesFound)	\
    (This)->lpVtbl -> FindNodesOfTypeInSubTree(This,pNodeType,pContextNodeToSearchFrom,ppContextNodesFound)

#define IInkAnalyzer_FindNodesWithCallBack(This,pCriteria,ppContextNodesFound)	\
    (This)->lpVtbl -> FindNodesWithCallBack(This,pCriteria,ppContextNodesFound)

#define IInkAnalyzer_FindNodesWithCallBackInSubTree(This,pCriteria,pContextNodeToSearchFrom,ppContextNodesFound)	\
    (This)->lpVtbl -> FindNodesWithCallBackInSubTree(This,pCriteria,pContextNodeToSearchFrom,ppContextNodesFound)

#define IInkAnalyzer_LoadResults(This,ulDataSize,pbSerializedData,ulStrokeIdsCount,plOriginalStrokeIds,plModifiedStrokeIds,pfRetVal)	\
    (This)->lpVtbl -> LoadResults(This,ulDataSize,pbSerializedData,ulStrokeIdsCount,plOriginalStrokeIds,plModifiedStrokeIds,pfRetVal)

#define IInkAnalyzer_SaveResults(This,ulMappedStrokeIdsCount,plOriginalStrokeIds,plModifiedStrokeIds,pulSerializedDataSize,ppbSerializedData)	\
    (This)->lpVtbl -> SaveResults(This,ulMappedStrokeIdsCount,plOriginalStrokeIds,plModifiedStrokeIds,pulSerializedDataSize,ppbSerializedData)

#define IInkAnalyzer_SaveResultsForNodes(This,ulMappedStrokeIdsCount,plOriginalStrokeIds,plModifiedStrokeIds,pContextNodes,pulSerializedDataSize,ppbSerializedData)	\
    (This)->lpVtbl -> SaveResultsForNodes(This,ulMappedStrokeIdsCount,plOriginalStrokeIds,plModifiedStrokeIds,pContextNodes,pulSerializedDataSize,ppbSerializedData)

#define IInkAnalyzer_SaveResultsForStrokes(This,ulMappedStrokeIdsCount,plOriginalStrokeIds,plModifiedStrokeIds,ulStrokeIdCount,plStrokeIds,pulSerializedDataSize,ppbSerializedData)	\
    (This)->lpVtbl -> SaveResultsForStrokes(This,ulMappedStrokeIdsCount,plOriginalStrokeIds,plModifiedStrokeIds,ulStrokeIdCount,plStrokeIds,pulSerializedDataSize,ppbSerializedData)

#define IInkAnalyzer_GetNodesFromTextRange(This,plStart,plLength,ppContextNodes,pNodesToSearch)	\
    (This)->lpVtbl -> GetNodesFromTextRange(This,plStart,plLength,ppContextNodes,pNodesToSearch)

#define IInkAnalyzer_GetTextRangeFromNodes(This,plStart,plLength,pNodesToSearch)	\
    (This)->lpVtbl -> GetTextRangeFromNodes(This,plStart,plLength,pNodesToSearch)

#define IInkAnalyzer_Search(This,bstrPhraseToMatch,pulSearchResultCount,ppulStrokeCountPerResult,pulStrokeIdsCount,ppulStrokeIds)	\
    (This)->lpVtbl -> Search(This,bstrPhraseToMatch,pulSearchResultCount,ppulStrokeCountPerResult,pulStrokeIdsCount,ppulStrokeIds)

#define IInkAnalyzer_SearchWithLanguageId(This,bstrPhraseToMatch,lSearchStringLanguageId,pulSearchResultCount,ppulStrokeCountPerResult,pulStrokeIdsCount,ppulStrokeIds)	\
    (This)->lpVtbl -> SearchWithLanguageId(This,bstrPhraseToMatch,lSearchStringLanguageId,pulSearchResultCount,ppulStrokeCountPerResult,pulStrokeIdsCount,ppulStrokeIds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetDirtyRegion_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ IAnalysisRegion **ppDirtyRegion);


void __RPC_STUB IInkAnalyzer_GetDirtyRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_SetDirtyRegion_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ IAnalysisRegion *pDirtyRegion);


void __RPC_STUB IInkAnalyzer_SetDirtyRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_SetStrokeType_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ LONG lStrokeId,
    /* [in] */ StrokeType StrokeType);


void __RPC_STUB IInkAnalyzer_SetStrokeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_SetStrokesType_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulStrokeIdCount,
    /* [size_is][in] */ LONG *plStrokes,
    /* [in] */ StrokeType StrokeType);


void __RPC_STUB IInkAnalyzer_SetStrokesType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetStrokeType_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ LONG lStrokeId,
    /* [out] */ StrokeType *pStrokeType);


void __RPC_STUB IInkAnalyzer_GetStrokeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_SetStrokeLanguageId_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ LONG lStrokeId,
    /* [in] */ LONG lLanguageId);


void __RPC_STUB IInkAnalyzer_SetStrokeLanguageId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_SetStrokesLanguageId_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulStrokeIdCount,
    /* [size_is][in] */ LONG *plStrokes,
    /* [in] */ LONG lStrokesLCID);


void __RPC_STUB IInkAnalyzer_SetStrokesLanguageId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetStrokeLanguageId_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ LONG strokeId,
    /* [out] */ LONG *plLanguageId);


void __RPC_STUB IInkAnalyzer_GetStrokeLanguageId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetRootNode_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ IContextNode **ppRootNode);


void __RPC_STUB IInkAnalyzer_GetRootNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_BackgroundAnalyze_Proxy( 
    IInkAnalyzer * This);


void __RPC_STUB IInkAnalyzer_BackgroundAnalyze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_Analyze_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ IAnalysisStatus **ppStatus);


void __RPC_STUB IInkAnalyzer_Analyze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_IsAnalyzing_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ VARIANT_BOOL *pbAnalyzing);


void __RPC_STUB IInkAnalyzer_IsAnalyzing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_Reconcile_Proxy( 
    IInkAnalyzer * This);


void __RPC_STUB IInkAnalyzer_Reconcile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_TransactionalReconcile_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ LONG lTimeLimit,
    /* [out] */ VARIANT_BOOL *pbMoreToReconcile);


void __RPC_STUB IInkAnalyzer_TransactionalReconcile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_Abort_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ IAnalysisRegion **ppAbortedRegion);


void __RPC_STUB IInkAnalyzer_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetInkAnalysisRecognizersByPriority_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ IInkAnalysisRecognizers **ppInkAnalysisRecognizers);


void __RPC_STUB IInkAnalyzer_GetInkAnalysisRecognizersByPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetRecognizedString_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ BSTR *pbstrRecognizedString);


void __RPC_STUB IInkAnalyzer_GetRecognizedString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_AddStroke_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ LONG lStrokeId,
    /* [in] */ ULONG ulStrokePacketDataCount,
    /* [size_is][in] */ LONG *plStrokePacketData,
    /* [in] */ ULONG ulStrokePacketDescriptionCount,
    /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
    /* [out] */ IContextNode **ppContextNodeStrokeAddedTo);


void __RPC_STUB IInkAnalyzer_AddStroke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_AddStrokes_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plStrokeIds,
    /* [in] */ ULONG ulStrokePacketDescriptionCount,
    /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
    /* [size_is][in] */ ULONG *pulPacketDataCountPerStroke,
    /* [in] */ LONG *plStrokePacketData,
    /* [out] */ IContextNode **ppContextNodeStrokeAddedTo);


void __RPC_STUB IInkAnalyzer_AddStrokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_AddStrokeForLanguage_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ LONG lStrokeId,
    /* [in] */ LONG lStrokeLCID,
    /* [in] */ ULONG ulStrokePacketDataCount,
    /* [size_is][in] */ LONG *plStrokePacketData,
    /* [in] */ ULONG ulStrokePacketDescriptionCount,
    /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
    /* [out] */ IContextNode **ppContextNodeStrokeAddedTo);


void __RPC_STUB IInkAnalyzer_AddStrokeForLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_AddStrokesForLanguage_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plIdofStrokesToAdd,
    /* [in] */ LONG lStrokesLCID,
    /* [in] */ ULONG ulStrokePacketDescriptionCount,
    /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
    /* [size_is][in] */ ULONG *pulPacketDataCountPerStroke,
    /* [in] */ LONG *plStrokePacketData,
    /* [out] */ IContextNode **ppContextNodeStrokeAddedTo);


void __RPC_STUB IInkAnalyzer_AddStrokesForLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_ClearStrokeData_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ LONG lStrokeId);


void __RPC_STUB IInkAnalyzer_ClearStrokeData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_RemoveStroke_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ LONG lStrokeId);


void __RPC_STUB IInkAnalyzer_RemoveStroke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_RemoveStrokes_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulStrokeIdCount,
    /* [size_is][in] */ LONG *plStrokeIds);


void __RPC_STUB IInkAnalyzer_RemoveStrokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_UpdateStrokesData_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plStrokeIds,
    /* [in] */ ULONG ulStrokePacketDescriptionCount,
    /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
    /* [size_is][in] */ ULONG *pulPacketDataCountPerStroke,
    /* [in] */ LONG *plStrokePacketData);


void __RPC_STUB IInkAnalyzer_UpdateStrokesData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetAnalysisModes_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ AnalysisModes *pAnalysisMode);


void __RPC_STUB IInkAnalyzer_GetAnalysisModes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_SetAnalysisModes_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ AnalysisModes analysisMode);


void __RPC_STUB IInkAnalyzer_SetAnalysisModes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_CreateAnalysisHint_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ IContextNode **ppAnalysisHint);


void __RPC_STUB IInkAnalyzer_CreateAnalysisHint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_DeleteAnalysisHint_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ IContextNode *pHintToDelete);


void __RPC_STUB IInkAnalyzer_DeleteAnalysisHint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetAnalysisHints_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ IContextNodes **ppAnalysisHints);


void __RPC_STUB IInkAnalyzer_GetAnalysisHints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetAnalysisHintsByName_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ BSTR hintName,
    /* [out] */ IContextNodes **ppAnalysisHints);


void __RPC_STUB IInkAnalyzer_GetAnalysisHintsByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_CreateContextNodes_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ IContextNodes **ppContextNodes);


void __RPC_STUB IInkAnalyzer_CreateContextNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetAlternatesForContextNodes_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ IContextNodes *pContextNodes,
    /* [in] */ ULONG ulMaximumAlternates,
    /* [out] */ IAnalysisAlternates **ppAlternates);


void __RPC_STUB IInkAnalyzer_GetAlternatesForContextNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetAlternatesForStrokes_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plStrokes,
    /* [in] */ ULONG ulMaximumAlternates,
    /* [out] */ IAnalysisAlternates **ppAlternates);


void __RPC_STUB IInkAnalyzer_GetAlternatesForStrokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetAlternates_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ IAnalysisAlternates **ppAlternates);


void __RPC_STUB IInkAnalyzer_GetAlternates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_ModifyTopAlternate_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ IAnalysisAlternate *pAlternate);


void __RPC_STUB IInkAnalyzer_ModifyTopAlternate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_ModifyTopAlternateWithConfirmation_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ IAnalysisAlternate *alternate,
    /* [in] */ VARIANT_BOOL fconfirmAutomatically);


void __RPC_STUB IInkAnalyzer_ModifyTopAlternateWithConfirmation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_CreateCustomRecognizer_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ const GUID *pInkAnalysisRecognizerId,
    /* [out] */ IContextNode **ppContextNode);


void __RPC_STUB IInkAnalyzer_CreateCustomRecognizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_AddStrokeToCustomRecognizer_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ LONG lStrokeId,
    /* [in] */ ULONG ulStrokePacketDataCount,
    /* [size_is][in] */ LONG *plStrokePacketData,
    /* [in] */ ULONG ulStrokePacketDescriptionCount,
    /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
    /* [in] */ IContextNode *pCustomRecognizer,
    /* [out] */ IContextNode **ppContextNodeStrokeAddedTo);


void __RPC_STUB IInkAnalyzer_AddStrokeToCustomRecognizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_AddStrokesToCustomRecognizer_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plStrokeIds,
    /* [in] */ ULONG ulStrokePacketDescriptionCount,
    /* [size_is][in] */ GUID *pStrokePacketDescriptionGuids,
    /* [size_is][in] */ ULONG *pulPacketDataCountPerStroke,
    /* [in] */ LONG *plStrokePacketData,
    /* [in] */ IContextNode *pCustomRecognizer,
    /* [out] */ IContextNode **ppContextNodeStrokeAddedTo);


void __RPC_STUB IInkAnalyzer_AddStrokesToCustomRecognizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_FindNode_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ const GUID *pId,
    /* [out] */ IContextNode **ppContextNodeFound);


void __RPC_STUB IInkAnalyzer_FindNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_FindLeafNodes_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ IContextNodes **ppContextNodesFound);


void __RPC_STUB IInkAnalyzer_FindLeafNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_FindInkLeafNodesForStrokes_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plStrokeIds,
    /* [out] */ IContextNodes **ppContextNodesFound);


void __RPC_STUB IInkAnalyzer_FindInkLeafNodesForStrokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_FindInkLeafNodes_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ IContextNodes **ppContextNodesFound);


void __RPC_STUB IInkAnalyzer_FindInkLeafNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_FindNodesOfType_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ const GUID *pNodeType,
    /* [out] */ IContextNodes **ppContextNodesFound);


void __RPC_STUB IInkAnalyzer_FindNodesOfType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_FindNodesOfTypeForStrokes_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ const GUID *pNodeType,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plStrokeIds,
    /* [out] */ IContextNodes **ppContextNodesFound);


void __RPC_STUB IInkAnalyzer_FindNodesOfTypeForStrokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_FindNodesOfTypeInSubTree_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ const GUID *pNodeType,
    /* [in] */ IContextNode *pContextNodeToSearchFrom,
    /* [out] */ IContextNodes **ppContextNodesFound);


void __RPC_STUB IInkAnalyzer_FindNodesOfTypeInSubTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_FindNodesWithCallBack_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ IMatchesCriteriaCallBack *pCriteria,
    /* [out] */ IContextNodes **ppContextNodesFound);


void __RPC_STUB IInkAnalyzer_FindNodesWithCallBack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_FindNodesWithCallBackInSubTree_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ IMatchesCriteriaCallBack *pCriteria,
    /* [in] */ IContextNode *pContextNodeToSearchFrom,
    /* [out] */ IContextNodes **ppContextNodesFound);


void __RPC_STUB IInkAnalyzer_FindNodesWithCallBackInSubTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_LoadResults_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulDataSize,
    /* [size_is][in] */ BYTE *pbSerializedData,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plOriginalStrokeIds,
    /* [size_is][in] */ LONG *plModifiedStrokeIds,
    /* [out] */ VARIANT_BOOL *pfRetVal);


void __RPC_STUB IInkAnalyzer_LoadResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_SaveResults_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulMappedStrokeIdsCount,
    /* [size_is][in] */ LONG *plOriginalStrokeIds,
    /* [size_is][in] */ LONG *plModifiedStrokeIds,
    /* [out][in] */ ULONG *pulSerializedDataSize,
    /* [size_is][out] */ BYTE **ppbSerializedData);


void __RPC_STUB IInkAnalyzer_SaveResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_SaveResultsForNodes_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulMappedStrokeIdsCount,
    /* [size_is][in] */ LONG *plOriginalStrokeIds,
    /* [size_is][in] */ LONG *plModifiedStrokeIds,
    /* [in] */ IContextNodes *pContextNodes,
    /* [out][in] */ ULONG *pulSerializedDataSize,
    /* [size_is][out] */ BYTE **ppbSerializedData);


void __RPC_STUB IInkAnalyzer_SaveResultsForNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_SaveResultsForStrokes_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ ULONG ulMappedStrokeIdsCount,
    /* [size_is][in] */ LONG *plOriginalStrokeIds,
    /* [size_is][in] */ LONG *plModifiedStrokeIds,
    /* [in] */ ULONG ulStrokeIdCount,
    /* [size_is][in] */ LONG *plStrokeIds,
    /* [out][in] */ ULONG *pulSerializedDataSize,
    /* [size_is][out] */ BYTE **ppbSerializedData);


void __RPC_STUB IInkAnalyzer_SaveResultsForStrokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetNodesFromTextRange_Proxy( 
    IInkAnalyzer * This,
    /* [out][in] */ LONG *plStart,
    /* [out][in] */ LONG *plLength,
    /* [out] */ IContextNodes **ppContextNodes,
    /* [defaultvalue][in] */ IContextNodes *pNodesToSearch);


void __RPC_STUB IInkAnalyzer_GetNodesFromTextRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_GetTextRangeFromNodes_Proxy( 
    IInkAnalyzer * This,
    /* [out] */ LONG *plStart,
    /* [out] */ LONG *plLength,
    /* [in] */ IContextNodes *pNodesToSearch);


void __RPC_STUB IInkAnalyzer_GetTextRangeFromNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_Search_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ BSTR bstrPhraseToMatch,
    /* [out][in] */ ULONG *pulSearchResultCount,
    /* [size_is][out] */ ULONG **ppulStrokeCountPerResult,
    /* [out][in] */ ULONG *pulStrokeIdsCount,
    /* [size_is][out] */ ULONG **ppulStrokeIds);


void __RPC_STUB IInkAnalyzer_Search_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalyzer_SearchWithLanguageId_Proxy( 
    IInkAnalyzer * This,
    /* [in] */ BSTR bstrPhraseToMatch,
    /* [in] */ LONG lSearchStringLanguageId,
    /* [out][in] */ ULONG *pulSearchResultCount,
    /* [size_is][out] */ ULONG **ppulStrokeCountPerResult,
    /* [out][in] */ ULONG *pulStrokeIdsCount,
    /* [size_is][out] */ ULONG **ppulStrokeIds);


void __RPC_STUB IInkAnalyzer_SearchWithLanguageId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInkAnalyzer_INTERFACE_DEFINED__ */


#ifndef __IContextNode_INTERFACE_DEFINED__
#define __IContextNode_INTERFACE_DEFINED__

/* interface IContextNode */
/* [object][unique][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID_IContextNode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("160BC1B3-5997-3D3C-9E5A-E38BCB212047")
    IContextNode : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetId( 
            /* [out] */ GUID *pId) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pContextNodeType) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetLocation( 
            /* [out] */ IAnalysisRegion **ppIAnalysisRegion) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetTypeName( 
            /* [out] */ BSTR *pbstrContextNodeType) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetLocation( 
            /* [in] */ IAnalysisRegion *pIAnalysisRegion) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetParentNode( 
            /* [out] */ IContextNode **ppParentContextNode) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Reparent( 
            /* [in] */ IContextNode *pNewParent) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetSubNodes( 
            /* [out] */ IContextNodes **ppSubContextNodes) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CreateSubNode( 
            /* [in] */ const GUID *pNodeType,
            /* [out] */ IContextNode **ppContextNodeCreated) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CreatePartiallyPopulatedSubNode( 
            /* [in] */ const GUID *pNodeType,
            /* [in] */ const GUID *pNodeId,
            /* [in] */ IAnalysisRegion *pNodeLocation,
            /* [out] */ IContextNode **ppPartiallyPopulatedContextNodeCreated) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetPartiallyPopulated( 
            /* [out] */ VARIANT_BOOL *pfPartiallyPopulated) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetPartiallyPopulated( 
            /* [in] */ VARIANT_BOOL fPartiallyPopulated) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE LoadPropertiesData( 
            /* [in] */ ULONG cbPropertiesDataSize,
            /* [size_is][in] */ BYTE *pbPropertiesData,
            /* [out] */ VARIANT_BOOL *pfSuccessful) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SavePropertiesData( 
            /* [out][in] */ ULONG *pulPropertiesDataSize,
            /* [size_is][out] */ BYTE **ppbPropertiesData) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE DeleteSubNode( 
            /* [in] */ IContextNode *pContextNodeToDelete) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE AddPropertyData( 
            /* [in] */ const GUID *pPropertyDataId,
            /* [in] */ ULONG ulPropertyDataSize,
            /* [size_is][in] */ BYTE *pbPropertyData) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyData( 
            /* [in] */ const GUID *pPropertyDataId,
            /* [out][in] */ ULONG *pulPropertyDataSize,
            /* [size_is][out] */ BYTE **ppbPropertyData) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE RemovePropertyData( 
            /* [in] */ const GUID *pPropertyDataId) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyDataIds( 
            /* [out][in] */ ULONG *pulGuidCount,
            /* [size_is][out] */ GUID **ppGuids) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ContainsPropertyData( 
            /* [in] */ const GUID *pPropertyDataId,
            /* [out] */ VARIANT_BOOL *pbContains) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetStrokes( 
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetStrokeIds( 
            /* [out][in] */ ULONG *pulStrokeIdsCount,
            /* [size_is][out] */ LONG **pplStrokes) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetStrokeCount( 
            /* [out] */ ULONG *pulStrokeCount) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetStrokePacketDataById( 
            /* [in] */ LONG strokeId,
            /* [out][in] */ ULONG *pStrokePacketDataCount,
            /* [size_is][out] */ LONG **pplStrokePacketData) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetStrokePacketDescriptionById( 
            /* [in] */ LONG lStrokeId,
            /* [out][in] */ ULONG *pulStrokePacketDescriptionCount,
            /* [size_is][out] */ GUID **ppStrokePacketDescriptionGuids) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE MoveSubNodeToPosition( 
            /* [in] */ IContextNode *pSubnodeToMove,
            /* [in] */ ULONG ulNewIndex) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ReparentStrokesByIdToNode( 
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [in] */ IContextNode *pContextNodeDestination) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Confirm( 
            /* [in] */ ConfirmationType confirmedType) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IsConfirmed( 
            /* [in] */ ConfirmationType confirmedType,
            /* [out] */ VARIANT_BOOL *pfTypeConfirmed) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetContextLinks( 
            /* [out] */ IContextLinks **ppContextLinks) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IsAlternateStringSupported( 
            /* [in] */ BSTR bstrAlternateString,
            /* [out] */ VARIANT_BOOL *pfIsSupported) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IsStringSupported( 
            /* [retval][out] */ VARIANT_BOOL *pfIsSupported) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextNodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextNode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextNode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextNode * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetId )( 
            IContextNode * This,
            /* [out] */ GUID *pId);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IContextNode * This,
            /* [out] */ GUID *pContextNodeType);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLocation )( 
            IContextNode * This,
            /* [out] */ IAnalysisRegion **ppIAnalysisRegion);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTypeName )( 
            IContextNode * This,
            /* [out] */ BSTR *pbstrContextNodeType);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetLocation )( 
            IContextNode * This,
            /* [in] */ IAnalysisRegion *pIAnalysisRegion);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetParentNode )( 
            IContextNode * This,
            /* [out] */ IContextNode **ppParentContextNode);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reparent )( 
            IContextNode * This,
            /* [in] */ IContextNode *pNewParent);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubNodes )( 
            IContextNode * This,
            /* [out] */ IContextNodes **ppSubContextNodes);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateSubNode )( 
            IContextNode * This,
            /* [in] */ const GUID *pNodeType,
            /* [out] */ IContextNode **ppContextNodeCreated);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePartiallyPopulatedSubNode )( 
            IContextNode * This,
            /* [in] */ const GUID *pNodeType,
            /* [in] */ const GUID *pNodeId,
            /* [in] */ IAnalysisRegion *pNodeLocation,
            /* [out] */ IContextNode **ppPartiallyPopulatedContextNodeCreated);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPartiallyPopulated )( 
            IContextNode * This,
            /* [out] */ VARIANT_BOOL *pfPartiallyPopulated);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPartiallyPopulated )( 
            IContextNode * This,
            /* [in] */ VARIANT_BOOL fPartiallyPopulated);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *LoadPropertiesData )( 
            IContextNode * This,
            /* [in] */ ULONG cbPropertiesDataSize,
            /* [size_is][in] */ BYTE *pbPropertiesData,
            /* [out] */ VARIANT_BOOL *pfSuccessful);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SavePropertiesData )( 
            IContextNode * This,
            /* [out][in] */ ULONG *pulPropertiesDataSize,
            /* [size_is][out] */ BYTE **ppbPropertiesData);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteSubNode )( 
            IContextNode * This,
            /* [in] */ IContextNode *pContextNodeToDelete);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPropertyData )( 
            IContextNode * This,
            /* [in] */ const GUID *pPropertyDataId,
            /* [in] */ ULONG ulPropertyDataSize,
            /* [size_is][in] */ BYTE *pbPropertyData);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyData )( 
            IContextNode * This,
            /* [in] */ const GUID *pPropertyDataId,
            /* [out][in] */ ULONG *pulPropertyDataSize,
            /* [size_is][out] */ BYTE **ppbPropertyData);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePropertyData )( 
            IContextNode * This,
            /* [in] */ const GUID *pPropertyDataId);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyDataIds )( 
            IContextNode * This,
            /* [out][in] */ ULONG *pulGuidCount,
            /* [size_is][out] */ GUID **ppGuids);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ContainsPropertyData )( 
            IContextNode * This,
            /* [in] */ const GUID *pPropertyDataId,
            /* [out] */ VARIANT_BOOL *pbContains);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStrokes )( 
            IContextNode * This,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStrokeIds )( 
            IContextNode * This,
            /* [out][in] */ ULONG *pulStrokeIdsCount,
            /* [size_is][out] */ LONG **pplStrokes);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStrokeCount )( 
            IContextNode * This,
            /* [out] */ ULONG *pulStrokeCount);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStrokePacketDataById )( 
            IContextNode * This,
            /* [in] */ LONG strokeId,
            /* [out][in] */ ULONG *pStrokePacketDataCount,
            /* [size_is][out] */ LONG **pplStrokePacketData);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStrokePacketDescriptionById )( 
            IContextNode * This,
            /* [in] */ LONG lStrokeId,
            /* [out][in] */ ULONG *pulStrokePacketDescriptionCount,
            /* [size_is][out] */ GUID **ppStrokePacketDescriptionGuids);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *MoveSubNodeToPosition )( 
            IContextNode * This,
            /* [in] */ IContextNode *pSubnodeToMove,
            /* [in] */ ULONG ulNewIndex);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReparentStrokesByIdToNode )( 
            IContextNode * This,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [in] */ IContextNode *pContextNodeDestination);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Confirm )( 
            IContextNode * This,
            /* [in] */ ConfirmationType confirmedType);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsConfirmed )( 
            IContextNode * This,
            /* [in] */ ConfirmationType confirmedType,
            /* [out] */ VARIANT_BOOL *pfTypeConfirmed);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetContextLinks )( 
            IContextNode * This,
            /* [out] */ IContextLinks **ppContextLinks);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsAlternateStringSupported )( 
            IContextNode * This,
            /* [in] */ BSTR bstrAlternateString,
            /* [out] */ VARIANT_BOOL *pfIsSupported);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsStringSupported )( 
            IContextNode * This,
            /* [retval][out] */ VARIANT_BOOL *pfIsSupported);
        
        END_INTERFACE
    } IContextNodeVtbl;

    interface IContextNode
    {
        CONST_VTBL struct IContextNodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextNode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextNode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextNode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextNode_GetId(This,pId)	\
    (This)->lpVtbl -> GetId(This,pId)

#define IContextNode_GetType(This,pContextNodeType)	\
    (This)->lpVtbl -> GetType(This,pContextNodeType)

#define IContextNode_GetLocation(This,ppIAnalysisRegion)	\
    (This)->lpVtbl -> GetLocation(This,ppIAnalysisRegion)

#define IContextNode_GetTypeName(This,pbstrContextNodeType)	\
    (This)->lpVtbl -> GetTypeName(This,pbstrContextNodeType)

#define IContextNode_SetLocation(This,pIAnalysisRegion)	\
    (This)->lpVtbl -> SetLocation(This,pIAnalysisRegion)

#define IContextNode_GetParentNode(This,ppParentContextNode)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentContextNode)

#define IContextNode_Reparent(This,pNewParent)	\
    (This)->lpVtbl -> Reparent(This,pNewParent)

#define IContextNode_GetSubNodes(This,ppSubContextNodes)	\
    (This)->lpVtbl -> GetSubNodes(This,ppSubContextNodes)

#define IContextNode_CreateSubNode(This,pNodeType,ppContextNodeCreated)	\
    (This)->lpVtbl -> CreateSubNode(This,pNodeType,ppContextNodeCreated)

#define IContextNode_CreatePartiallyPopulatedSubNode(This,pNodeType,pNodeId,pNodeLocation,ppPartiallyPopulatedContextNodeCreated)	\
    (This)->lpVtbl -> CreatePartiallyPopulatedSubNode(This,pNodeType,pNodeId,pNodeLocation,ppPartiallyPopulatedContextNodeCreated)

#define IContextNode_GetPartiallyPopulated(This,pfPartiallyPopulated)	\
    (This)->lpVtbl -> GetPartiallyPopulated(This,pfPartiallyPopulated)

#define IContextNode_SetPartiallyPopulated(This,fPartiallyPopulated)	\
    (This)->lpVtbl -> SetPartiallyPopulated(This,fPartiallyPopulated)

#define IContextNode_LoadPropertiesData(This,cbPropertiesDataSize,pbPropertiesData,pfSuccessful)	\
    (This)->lpVtbl -> LoadPropertiesData(This,cbPropertiesDataSize,pbPropertiesData,pfSuccessful)

#define IContextNode_SavePropertiesData(This,pulPropertiesDataSize,ppbPropertiesData)	\
    (This)->lpVtbl -> SavePropertiesData(This,pulPropertiesDataSize,ppbPropertiesData)

#define IContextNode_DeleteSubNode(This,pContextNodeToDelete)	\
    (This)->lpVtbl -> DeleteSubNode(This,pContextNodeToDelete)

#define IContextNode_AddPropertyData(This,pPropertyDataId,ulPropertyDataSize,pbPropertyData)	\
    (This)->lpVtbl -> AddPropertyData(This,pPropertyDataId,ulPropertyDataSize,pbPropertyData)

#define IContextNode_GetPropertyData(This,pPropertyDataId,pulPropertyDataSize,ppbPropertyData)	\
    (This)->lpVtbl -> GetPropertyData(This,pPropertyDataId,pulPropertyDataSize,ppbPropertyData)

#define IContextNode_RemovePropertyData(This,pPropertyDataId)	\
    (This)->lpVtbl -> RemovePropertyData(This,pPropertyDataId)

#define IContextNode_GetPropertyDataIds(This,pulGuidCount,ppGuids)	\
    (This)->lpVtbl -> GetPropertyDataIds(This,pulGuidCount,ppGuids)

#define IContextNode_ContainsPropertyData(This,pPropertyDataId,pbContains)	\
    (This)->lpVtbl -> ContainsPropertyData(This,pPropertyDataId,pbContains)

#define IContextNode_SetStrokes(This,ulStrokeIdsCount,plStrokeIds)	\
    (This)->lpVtbl -> SetStrokes(This,ulStrokeIdsCount,plStrokeIds)

#define IContextNode_GetStrokeIds(This,pulStrokeIdsCount,pplStrokes)	\
    (This)->lpVtbl -> GetStrokeIds(This,pulStrokeIdsCount,pplStrokes)

#define IContextNode_GetStrokeCount(This,pulStrokeCount)	\
    (This)->lpVtbl -> GetStrokeCount(This,pulStrokeCount)

#define IContextNode_GetStrokePacketDataById(This,strokeId,pStrokePacketDataCount,pplStrokePacketData)	\
    (This)->lpVtbl -> GetStrokePacketDataById(This,strokeId,pStrokePacketDataCount,pplStrokePacketData)

#define IContextNode_GetStrokePacketDescriptionById(This,lStrokeId,pulStrokePacketDescriptionCount,ppStrokePacketDescriptionGuids)	\
    (This)->lpVtbl -> GetStrokePacketDescriptionById(This,lStrokeId,pulStrokePacketDescriptionCount,ppStrokePacketDescriptionGuids)

#define IContextNode_MoveSubNodeToPosition(This,pSubnodeToMove,ulNewIndex)	\
    (This)->lpVtbl -> MoveSubNodeToPosition(This,pSubnodeToMove,ulNewIndex)

#define IContextNode_ReparentStrokesByIdToNode(This,ulStrokeIdsCount,plStrokeIds,pContextNodeDestination)	\
    (This)->lpVtbl -> ReparentStrokesByIdToNode(This,ulStrokeIdsCount,plStrokeIds,pContextNodeDestination)

#define IContextNode_Confirm(This,confirmedType)	\
    (This)->lpVtbl -> Confirm(This,confirmedType)

#define IContextNode_IsConfirmed(This,confirmedType,pfTypeConfirmed)	\
    (This)->lpVtbl -> IsConfirmed(This,confirmedType,pfTypeConfirmed)

#define IContextNode_GetContextLinks(This,ppContextLinks)	\
    (This)->lpVtbl -> GetContextLinks(This,ppContextLinks)

#define IContextNode_IsAlternateStringSupported(This,bstrAlternateString,pfIsSupported)	\
    (This)->lpVtbl -> IsAlternateStringSupported(This,bstrAlternateString,pfIsSupported)

#define IContextNode_IsStringSupported(This,pfIsSupported)	\
    (This)->lpVtbl -> IsStringSupported(This,pfIsSupported)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetId_Proxy( 
    IContextNode * This,
    /* [out] */ GUID *pId);


void __RPC_STUB IContextNode_GetId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetType_Proxy( 
    IContextNode * This,
    /* [out] */ GUID *pContextNodeType);


void __RPC_STUB IContextNode_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetLocation_Proxy( 
    IContextNode * This,
    /* [out] */ IAnalysisRegion **ppIAnalysisRegion);


void __RPC_STUB IContextNode_GetLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetTypeName_Proxy( 
    IContextNode * This,
    /* [out] */ BSTR *pbstrContextNodeType);


void __RPC_STUB IContextNode_GetTypeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_SetLocation_Proxy( 
    IContextNode * This,
    /* [in] */ IAnalysisRegion *pIAnalysisRegion);


void __RPC_STUB IContextNode_SetLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetParentNode_Proxy( 
    IContextNode * This,
    /* [out] */ IContextNode **ppParentContextNode);


void __RPC_STUB IContextNode_GetParentNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_Reparent_Proxy( 
    IContextNode * This,
    /* [in] */ IContextNode *pNewParent);


void __RPC_STUB IContextNode_Reparent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetSubNodes_Proxy( 
    IContextNode * This,
    /* [out] */ IContextNodes **ppSubContextNodes);


void __RPC_STUB IContextNode_GetSubNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_CreateSubNode_Proxy( 
    IContextNode * This,
    /* [in] */ const GUID *pNodeType,
    /* [out] */ IContextNode **ppContextNodeCreated);


void __RPC_STUB IContextNode_CreateSubNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_CreatePartiallyPopulatedSubNode_Proxy( 
    IContextNode * This,
    /* [in] */ const GUID *pNodeType,
    /* [in] */ const GUID *pNodeId,
    /* [in] */ IAnalysisRegion *pNodeLocation,
    /* [out] */ IContextNode **ppPartiallyPopulatedContextNodeCreated);


void __RPC_STUB IContextNode_CreatePartiallyPopulatedSubNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetPartiallyPopulated_Proxy( 
    IContextNode * This,
    /* [out] */ VARIANT_BOOL *pfPartiallyPopulated);


void __RPC_STUB IContextNode_GetPartiallyPopulated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_SetPartiallyPopulated_Proxy( 
    IContextNode * This,
    /* [in] */ VARIANT_BOOL fPartiallyPopulated);


void __RPC_STUB IContextNode_SetPartiallyPopulated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_LoadPropertiesData_Proxy( 
    IContextNode * This,
    /* [in] */ ULONG cbPropertiesDataSize,
    /* [size_is][in] */ BYTE *pbPropertiesData,
    /* [out] */ VARIANT_BOOL *pfSuccessful);


void __RPC_STUB IContextNode_LoadPropertiesData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_SavePropertiesData_Proxy( 
    IContextNode * This,
    /* [out][in] */ ULONG *pulPropertiesDataSize,
    /* [size_is][out] */ BYTE **ppbPropertiesData);


void __RPC_STUB IContextNode_SavePropertiesData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_DeleteSubNode_Proxy( 
    IContextNode * This,
    /* [in] */ IContextNode *pContextNodeToDelete);


void __RPC_STUB IContextNode_DeleteSubNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_AddPropertyData_Proxy( 
    IContextNode * This,
    /* [in] */ const GUID *pPropertyDataId,
    /* [in] */ ULONG ulPropertyDataSize,
    /* [size_is][in] */ BYTE *pbPropertyData);


void __RPC_STUB IContextNode_AddPropertyData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetPropertyData_Proxy( 
    IContextNode * This,
    /* [in] */ const GUID *pPropertyDataId,
    /* [out][in] */ ULONG *pulPropertyDataSize,
    /* [size_is][out] */ BYTE **ppbPropertyData);


void __RPC_STUB IContextNode_GetPropertyData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_RemovePropertyData_Proxy( 
    IContextNode * This,
    /* [in] */ const GUID *pPropertyDataId);


void __RPC_STUB IContextNode_RemovePropertyData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetPropertyDataIds_Proxy( 
    IContextNode * This,
    /* [out][in] */ ULONG *pulGuidCount,
    /* [size_is][out] */ GUID **ppGuids);


void __RPC_STUB IContextNode_GetPropertyDataIds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_ContainsPropertyData_Proxy( 
    IContextNode * This,
    /* [in] */ const GUID *pPropertyDataId,
    /* [out] */ VARIANT_BOOL *pbContains);


void __RPC_STUB IContextNode_ContainsPropertyData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_SetStrokes_Proxy( 
    IContextNode * This,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plStrokeIds);


void __RPC_STUB IContextNode_SetStrokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetStrokeIds_Proxy( 
    IContextNode * This,
    /* [out][in] */ ULONG *pulStrokeIdsCount,
    /* [size_is][out] */ LONG **pplStrokes);


void __RPC_STUB IContextNode_GetStrokeIds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetStrokeCount_Proxy( 
    IContextNode * This,
    /* [out] */ ULONG *pulStrokeCount);


void __RPC_STUB IContextNode_GetStrokeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetStrokePacketDataById_Proxy( 
    IContextNode * This,
    /* [in] */ LONG strokeId,
    /* [out][in] */ ULONG *pStrokePacketDataCount,
    /* [size_is][out] */ LONG **pplStrokePacketData);


void __RPC_STUB IContextNode_GetStrokePacketDataById_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetStrokePacketDescriptionById_Proxy( 
    IContextNode * This,
    /* [in] */ LONG lStrokeId,
    /* [out][in] */ ULONG *pulStrokePacketDescriptionCount,
    /* [size_is][out] */ GUID **ppStrokePacketDescriptionGuids);


void __RPC_STUB IContextNode_GetStrokePacketDescriptionById_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_MoveSubNodeToPosition_Proxy( 
    IContextNode * This,
    /* [in] */ IContextNode *pSubnodeToMove,
    /* [in] */ ULONG ulNewIndex);


void __RPC_STUB IContextNode_MoveSubNodeToPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_ReparentStrokesByIdToNode_Proxy( 
    IContextNode * This,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plStrokeIds,
    /* [in] */ IContextNode *pContextNodeDestination);


void __RPC_STUB IContextNode_ReparentStrokesByIdToNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_Confirm_Proxy( 
    IContextNode * This,
    /* [in] */ ConfirmationType confirmedType);


void __RPC_STUB IContextNode_Confirm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_IsConfirmed_Proxy( 
    IContextNode * This,
    /* [in] */ ConfirmationType confirmedType,
    /* [out] */ VARIANT_BOOL *pfTypeConfirmed);


void __RPC_STUB IContextNode_IsConfirmed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_GetContextLinks_Proxy( 
    IContextNode * This,
    /* [out] */ IContextLinks **ppContextLinks);


void __RPC_STUB IContextNode_GetContextLinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_IsAlternateStringSupported_Proxy( 
    IContextNode * This,
    /* [in] */ BSTR bstrAlternateString,
    /* [out] */ VARIANT_BOOL *pfIsSupported);


void __RPC_STUB IContextNode_IsAlternateStringSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNode_IsStringSupported_Proxy( 
    IContextNode * This,
    /* [retval][out] */ VARIANT_BOOL *pfIsSupported);


void __RPC_STUB IContextNode_IsStringSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextNode_INTERFACE_DEFINED__ */


#ifndef __IContextNodes_INTERFACE_DEFINED__
#define __IContextNodes_INTERFACE_DEFINED__

/* interface IContextNodes */
/* [object][unique][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID_IContextNodes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("23A56238-A883-4393-B539-8C1E2996B7A2")
    IContextNodes : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetContextNode( 
            /* [in] */ ULONG ulIndex,
            /* [out] */ IContextNode **ppContextNode) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE AddContextNode( 
            /* [in] */ IContextNode *pContextNode) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE RemoveContextNode( 
            /* [in] */ IContextNode *pContextNode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextNodesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextNodes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextNodes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextNodes * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IContextNodes * This,
            /* [out] */ ULONG *pulCount);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetContextNode )( 
            IContextNodes * This,
            /* [in] */ ULONG ulIndex,
            /* [out] */ IContextNode **ppContextNode);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddContextNode )( 
            IContextNodes * This,
            /* [in] */ IContextNode *pContextNode);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveContextNode )( 
            IContextNodes * This,
            /* [in] */ IContextNode *pContextNode);
        
        END_INTERFACE
    } IContextNodesVtbl;

    interface IContextNodes
    {
        CONST_VTBL struct IContextNodesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextNodes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextNodes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextNodes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextNodes_GetCount(This,pulCount)	\
    (This)->lpVtbl -> GetCount(This,pulCount)

#define IContextNodes_GetContextNode(This,ulIndex,ppContextNode)	\
    (This)->lpVtbl -> GetContextNode(This,ulIndex,ppContextNode)

#define IContextNodes_AddContextNode(This,pContextNode)	\
    (This)->lpVtbl -> AddContextNode(This,pContextNode)

#define IContextNodes_RemoveContextNode(This,pContextNode)	\
    (This)->lpVtbl -> RemoveContextNode(This,pContextNode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNodes_GetCount_Proxy( 
    IContextNodes * This,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB IContextNodes_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNodes_GetContextNode_Proxy( 
    IContextNodes * This,
    /* [in] */ ULONG ulIndex,
    /* [out] */ IContextNode **ppContextNode);


void __RPC_STUB IContextNodes_GetContextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNodes_AddContextNode_Proxy( 
    IContextNodes * This,
    /* [in] */ IContextNode *pContextNode);


void __RPC_STUB IContextNodes_AddContextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextNodes_RemoveContextNode_Proxy( 
    IContextNodes * This,
    /* [in] */ IContextNode *pContextNode);


void __RPC_STUB IContextNodes_RemoveContextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextNodes_INTERFACE_DEFINED__ */


#ifndef __IAnalysisRegion_INTERFACE_DEFINED__
#define __IAnalysisRegion_INTERFACE_DEFINED__

/* interface IAnalysisRegion */
/* [unique][uuid][helpcontext][helpstring][object] */ 


EXTERN_C const IID IID_IAnalysisRegion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F76EBC66-ABEF-3248-AE9B-F20D4B9149FE")
    IAnalysisRegion : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IsEmpty( 
            /* [out] */ VARIANT_BOOL *pfIsEmpty) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE MakeEmpty( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE MakeInfinite( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IsInfinite( 
            /* [out] */ VARIANT_BOOL *pfIsInfinite) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAnalysisRegion **pClonedRegion) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetRegionScans( 
            /* [out] */ ULONG *pulRectCount,
            /* [out] */ RECT **pRegionScans) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE UnionRectangle( 
            /* [in] */ RECT *pRectangle) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE UnionRegion( 
            /* [in] */ IAnalysisRegion *pRegionToUnion) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetBounds( 
            /* [out] */ RECT *pBoundingRectangle) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IntersectRectangle( 
            /* [in] */ RECT *pIntersectingRectangle) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IntersectRegion( 
            /* [in] */ IAnalysisRegion *pRegionToIntersect) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IntersectsWith( 
            /* [in] */ RECT *pRectangle,
            /* [out] */ VARIANT_BOOL *pfIsIntersecting) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ExcludeRectangle( 
            /* [in] */ RECT *pExcludingRectangle) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ExcludeRegion( 
            /* [in] */ IAnalysisRegion *pRegionToExclude) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE EqualsRegion( 
            /* [in] */ IAnalysisRegion *pOtherRegion,
            /* [out] */ VARIANT_BOOL *pfRegionsEqual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnalysisRegionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAnalysisRegion * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAnalysisRegion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAnalysisRegion * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsEmpty )( 
            IAnalysisRegion * This,
            /* [out] */ VARIANT_BOOL *pfIsEmpty);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *MakeEmpty )( 
            IAnalysisRegion * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *MakeInfinite )( 
            IAnalysisRegion * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsInfinite )( 
            IAnalysisRegion * This,
            /* [out] */ VARIANT_BOOL *pfIsInfinite);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAnalysisRegion * This,
            /* [out] */ IAnalysisRegion **pClonedRegion);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRegionScans )( 
            IAnalysisRegion * This,
            /* [out] */ ULONG *pulRectCount,
            /* [out] */ RECT **pRegionScans);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnionRectangle )( 
            IAnalysisRegion * This,
            /* [in] */ RECT *pRectangle);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnionRegion )( 
            IAnalysisRegion * This,
            /* [in] */ IAnalysisRegion *pRegionToUnion);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetBounds )( 
            IAnalysisRegion * This,
            /* [out] */ RECT *pBoundingRectangle);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *IntersectRectangle )( 
            IAnalysisRegion * This,
            /* [in] */ RECT *pIntersectingRectangle);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *IntersectRegion )( 
            IAnalysisRegion * This,
            /* [in] */ IAnalysisRegion *pRegionToIntersect);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *IntersectsWith )( 
            IAnalysisRegion * This,
            /* [in] */ RECT *pRectangle,
            /* [out] */ VARIANT_BOOL *pfIsIntersecting);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExcludeRectangle )( 
            IAnalysisRegion * This,
            /* [in] */ RECT *pExcludingRectangle);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExcludeRegion )( 
            IAnalysisRegion * This,
            /* [in] */ IAnalysisRegion *pRegionToExclude);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EqualsRegion )( 
            IAnalysisRegion * This,
            /* [in] */ IAnalysisRegion *pOtherRegion,
            /* [out] */ VARIANT_BOOL *pfRegionsEqual);
        
        END_INTERFACE
    } IAnalysisRegionVtbl;

    interface IAnalysisRegion
    {
        CONST_VTBL struct IAnalysisRegionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnalysisRegion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAnalysisRegion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAnalysisRegion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAnalysisRegion_IsEmpty(This,pfIsEmpty)	\
    (This)->lpVtbl -> IsEmpty(This,pfIsEmpty)

#define IAnalysisRegion_MakeEmpty(This)	\
    (This)->lpVtbl -> MakeEmpty(This)

#define IAnalysisRegion_MakeInfinite(This)	\
    (This)->lpVtbl -> MakeInfinite(This)

#define IAnalysisRegion_IsInfinite(This,pfIsInfinite)	\
    (This)->lpVtbl -> IsInfinite(This,pfIsInfinite)

#define IAnalysisRegion_Clone(This,pClonedRegion)	\
    (This)->lpVtbl -> Clone(This,pClonedRegion)

#define IAnalysisRegion_GetRegionScans(This,pulRectCount,pRegionScans)	\
    (This)->lpVtbl -> GetRegionScans(This,pulRectCount,pRegionScans)

#define IAnalysisRegion_UnionRectangle(This,pRectangle)	\
    (This)->lpVtbl -> UnionRectangle(This,pRectangle)

#define IAnalysisRegion_UnionRegion(This,pRegionToUnion)	\
    (This)->lpVtbl -> UnionRegion(This,pRegionToUnion)

#define IAnalysisRegion_GetBounds(This,pBoundingRectangle)	\
    (This)->lpVtbl -> GetBounds(This,pBoundingRectangle)

#define IAnalysisRegion_IntersectRectangle(This,pIntersectingRectangle)	\
    (This)->lpVtbl -> IntersectRectangle(This,pIntersectingRectangle)

#define IAnalysisRegion_IntersectRegion(This,pRegionToIntersect)	\
    (This)->lpVtbl -> IntersectRegion(This,pRegionToIntersect)

#define IAnalysisRegion_IntersectsWith(This,pRectangle,pfIsIntersecting)	\
    (This)->lpVtbl -> IntersectsWith(This,pRectangle,pfIsIntersecting)

#define IAnalysisRegion_ExcludeRectangle(This,pExcludingRectangle)	\
    (This)->lpVtbl -> ExcludeRectangle(This,pExcludingRectangle)

#define IAnalysisRegion_ExcludeRegion(This,pRegionToExclude)	\
    (This)->lpVtbl -> ExcludeRegion(This,pRegionToExclude)

#define IAnalysisRegion_EqualsRegion(This,pOtherRegion,pfRegionsEqual)	\
    (This)->lpVtbl -> EqualsRegion(This,pOtherRegion,pfRegionsEqual)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_IsEmpty_Proxy( 
    IAnalysisRegion * This,
    /* [out] */ VARIANT_BOOL *pfIsEmpty);


void __RPC_STUB IAnalysisRegion_IsEmpty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_MakeEmpty_Proxy( 
    IAnalysisRegion * This);


void __RPC_STUB IAnalysisRegion_MakeEmpty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_MakeInfinite_Proxy( 
    IAnalysisRegion * This);


void __RPC_STUB IAnalysisRegion_MakeInfinite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_IsInfinite_Proxy( 
    IAnalysisRegion * This,
    /* [out] */ VARIANT_BOOL *pfIsInfinite);


void __RPC_STUB IAnalysisRegion_IsInfinite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_Clone_Proxy( 
    IAnalysisRegion * This,
    /* [out] */ IAnalysisRegion **pClonedRegion);


void __RPC_STUB IAnalysisRegion_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_GetRegionScans_Proxy( 
    IAnalysisRegion * This,
    /* [out] */ ULONG *pulRectCount,
    /* [out] */ RECT **pRegionScans);


void __RPC_STUB IAnalysisRegion_GetRegionScans_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_UnionRectangle_Proxy( 
    IAnalysisRegion * This,
    /* [in] */ RECT *pRectangle);


void __RPC_STUB IAnalysisRegion_UnionRectangle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_UnionRegion_Proxy( 
    IAnalysisRegion * This,
    /* [in] */ IAnalysisRegion *pRegionToUnion);


void __RPC_STUB IAnalysisRegion_UnionRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_GetBounds_Proxy( 
    IAnalysisRegion * This,
    /* [out] */ RECT *pBoundingRectangle);


void __RPC_STUB IAnalysisRegion_GetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_IntersectRectangle_Proxy( 
    IAnalysisRegion * This,
    /* [in] */ RECT *pIntersectingRectangle);


void __RPC_STUB IAnalysisRegion_IntersectRectangle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_IntersectRegion_Proxy( 
    IAnalysisRegion * This,
    /* [in] */ IAnalysisRegion *pRegionToIntersect);


void __RPC_STUB IAnalysisRegion_IntersectRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_IntersectsWith_Proxy( 
    IAnalysisRegion * This,
    /* [in] */ RECT *pRectangle,
    /* [out] */ VARIANT_BOOL *pfIsIntersecting);


void __RPC_STUB IAnalysisRegion_IntersectsWith_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_ExcludeRectangle_Proxy( 
    IAnalysisRegion * This,
    /* [in] */ RECT *pExcludingRectangle);


void __RPC_STUB IAnalysisRegion_ExcludeRectangle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_ExcludeRegion_Proxy( 
    IAnalysisRegion * This,
    /* [in] */ IAnalysisRegion *pRegionToExclude);


void __RPC_STUB IAnalysisRegion_ExcludeRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisRegion_EqualsRegion_Proxy( 
    IAnalysisRegion * This,
    /* [in] */ IAnalysisRegion *pOtherRegion,
    /* [out] */ VARIANT_BOOL *pfRegionsEqual);


void __RPC_STUB IAnalysisRegion_EqualsRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAnalysisRegion_INTERFACE_DEFINED__ */


#ifndef __IContextLink_INTERFACE_DEFINED__
#define __IContextLink_INTERFACE_DEFINED__

/* interface IContextLink */
/* [object][unique][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID_IContextLink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("715389A8-84B1-3B52-98FC-E2CCCD27D4B9")
    IContextLink : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetDestinationNode( 
            /* [out] */ IContextNode **ppDstContextNodeId) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetSourceNode( 
            /* [out] */ IContextNode **ppSrcContextNodeId) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetContextLinkDirection( 
            /* [out] */ ContextLinkDirection *pContextLinkDirection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextLinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextLink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextLink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextLink * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDestinationNode )( 
            IContextLink * This,
            /* [out] */ IContextNode **ppDstContextNodeId);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSourceNode )( 
            IContextLink * This,
            /* [out] */ IContextNode **ppSrcContextNodeId);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetContextLinkDirection )( 
            IContextLink * This,
            /* [out] */ ContextLinkDirection *pContextLinkDirection);
        
        END_INTERFACE
    } IContextLinkVtbl;

    interface IContextLink
    {
        CONST_VTBL struct IContextLinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextLink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextLink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextLink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextLink_GetDestinationNode(This,ppDstContextNodeId)	\
    (This)->lpVtbl -> GetDestinationNode(This,ppDstContextNodeId)

#define IContextLink_GetSourceNode(This,ppSrcContextNodeId)	\
    (This)->lpVtbl -> GetSourceNode(This,ppSrcContextNodeId)

#define IContextLink_GetContextLinkDirection(This,pContextLinkDirection)	\
    (This)->lpVtbl -> GetContextLinkDirection(This,pContextLinkDirection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextLink_GetDestinationNode_Proxy( 
    IContextLink * This,
    /* [out] */ IContextNode **ppDstContextNodeId);


void __RPC_STUB IContextLink_GetDestinationNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextLink_GetSourceNode_Proxy( 
    IContextLink * This,
    /* [out] */ IContextNode **ppSrcContextNodeId);


void __RPC_STUB IContextLink_GetSourceNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextLink_GetContextLinkDirection_Proxy( 
    IContextLink * This,
    /* [out] */ ContextLinkDirection *pContextLinkDirection);


void __RPC_STUB IContextLink_GetContextLinkDirection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextLink_INTERFACE_DEFINED__ */


#ifndef __IContextLinks_INTERFACE_DEFINED__
#define __IContextLinks_INTERFACE_DEFINED__

/* interface IContextLinks */
/* [object][unique][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID_IContextLinks;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2914EB5A-8B3D-4381-A733-1509A2295394")
    IContextLinks : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetContextLink( 
            /* [in] */ ULONG ulIndex,
            /* [out] */ IContextLink **ppContextLink) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE AddContextLink( 
            /* [in] */ IContextNode *pDestinationNode,
            /* [in] */ ContextLinkDirection linkDirection,
            /* [out] */ IContextLink **ppContextLinkToAdd) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE DeleteContextLink( 
            /* [in] */ IContextLink *pContextLinkToDelete) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextLinksVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextLinks * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextLinks * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextLinks * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IContextLinks * This,
            /* [out] */ ULONG *pulCount);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetContextLink )( 
            IContextLinks * This,
            /* [in] */ ULONG ulIndex,
            /* [out] */ IContextLink **ppContextLink);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddContextLink )( 
            IContextLinks * This,
            /* [in] */ IContextNode *pDestinationNode,
            /* [in] */ ContextLinkDirection linkDirection,
            /* [out] */ IContextLink **ppContextLinkToAdd);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteContextLink )( 
            IContextLinks * This,
            /* [in] */ IContextLink *pContextLinkToDelete);
        
        END_INTERFACE
    } IContextLinksVtbl;

    interface IContextLinks
    {
        CONST_VTBL struct IContextLinksVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextLinks_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextLinks_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextLinks_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextLinks_GetCount(This,pulCount)	\
    (This)->lpVtbl -> GetCount(This,pulCount)

#define IContextLinks_GetContextLink(This,ulIndex,ppContextLink)	\
    (This)->lpVtbl -> GetContextLink(This,ulIndex,ppContextLink)

#define IContextLinks_AddContextLink(This,pDestinationNode,linkDirection,ppContextLinkToAdd)	\
    (This)->lpVtbl -> AddContextLink(This,pDestinationNode,linkDirection,ppContextLinkToAdd)

#define IContextLinks_DeleteContextLink(This,pContextLinkToDelete)	\
    (This)->lpVtbl -> DeleteContextLink(This,pContextLinkToDelete)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextLinks_GetCount_Proxy( 
    IContextLinks * This,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB IContextLinks_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextLinks_GetContextLink_Proxy( 
    IContextLinks * This,
    /* [in] */ ULONG ulIndex,
    /* [out] */ IContextLink **ppContextLink);


void __RPC_STUB IContextLinks_GetContextLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextLinks_AddContextLink_Proxy( 
    IContextLinks * This,
    /* [in] */ IContextNode *pDestinationNode,
    /* [in] */ ContextLinkDirection linkDirection,
    /* [out] */ IContextLink **ppContextLinkToAdd);


void __RPC_STUB IContextLinks_AddContextLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IContextLinks_DeleteContextLink_Proxy( 
    IContextLinks * This,
    /* [in] */ IContextLink *pContextLinkToDelete);


void __RPC_STUB IContextLinks_DeleteContextLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextLinks_INTERFACE_DEFINED__ */


#ifndef __IInkAnalysisRecognizer_INTERFACE_DEFINED__
#define __IInkAnalysisRecognizer_INTERFACE_DEFINED__

/* interface IInkAnalysisRecognizer */
/* [object][unique][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID_IInkAnalysisRecognizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BD5F33DF-BEBB-3D05-98AC-F0986D3BEF17")
    IInkAnalysisRecognizer : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetGuid( 
            /* [out] */ GUID *pId) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetVendor( 
            /* [out] */ BSTR *pbstrVendor) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ InkAnalysisRecognizerCapabilities *pCapabilities) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetSupportedProperties( 
            /* [out][in] */ ULONG *pulPropertiesCount,
            /* [size_is][out] */ GUID **ppProperties) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetLanguages( 
            /* [out][in] */ ULONG *pulLanguagesCount,
            /* [size_is][out] */ ULONG **ppulLanguages) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetUnicodeRanges( 
            /* [out][in] */ ULONG *pulNumberOfRanges,
            /* [size_is][out] */ WCHAR **ppulLowUnicode,
            /* [size_is][out] */ USHORT **ppusUnicodeRangeLength) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetAsHighestPriorityInkAnalysisRecognizer( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInkAnalysisRecognizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInkAnalysisRecognizer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInkAnalysisRecognizer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInkAnalysisRecognizer * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IInkAnalysisRecognizer * This,
            /* [out] */ BSTR *pbstrName);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetGuid )( 
            IInkAnalysisRecognizer * This,
            /* [out] */ GUID *pId);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVendor )( 
            IInkAnalysisRecognizer * This,
            /* [out] */ BSTR *pbstrVendor);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            IInkAnalysisRecognizer * This,
            /* [out] */ InkAnalysisRecognizerCapabilities *pCapabilities);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSupportedProperties )( 
            IInkAnalysisRecognizer * This,
            /* [out][in] */ ULONG *pulPropertiesCount,
            /* [size_is][out] */ GUID **ppProperties);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLanguages )( 
            IInkAnalysisRecognizer * This,
            /* [out][in] */ ULONG *pulLanguagesCount,
            /* [size_is][out] */ ULONG **ppulLanguages);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUnicodeRanges )( 
            IInkAnalysisRecognizer * This,
            /* [out][in] */ ULONG *pulNumberOfRanges,
            /* [size_is][out] */ WCHAR **ppulLowUnicode,
            /* [size_is][out] */ USHORT **ppusUnicodeRangeLength);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAsHighestPriorityInkAnalysisRecognizer )( 
            IInkAnalysisRecognizer * This);
        
        END_INTERFACE
    } IInkAnalysisRecognizerVtbl;

    interface IInkAnalysisRecognizer
    {
        CONST_VTBL struct IInkAnalysisRecognizerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInkAnalysisRecognizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInkAnalysisRecognizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInkAnalysisRecognizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInkAnalysisRecognizer_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IInkAnalysisRecognizer_GetGuid(This,pId)	\
    (This)->lpVtbl -> GetGuid(This,pId)

#define IInkAnalysisRecognizer_GetVendor(This,pbstrVendor)	\
    (This)->lpVtbl -> GetVendor(This,pbstrVendor)

#define IInkAnalysisRecognizer_GetCapabilities(This,pCapabilities)	\
    (This)->lpVtbl -> GetCapabilities(This,pCapabilities)

#define IInkAnalysisRecognizer_GetSupportedProperties(This,pulPropertiesCount,ppProperties)	\
    (This)->lpVtbl -> GetSupportedProperties(This,pulPropertiesCount,ppProperties)

#define IInkAnalysisRecognizer_GetLanguages(This,pulLanguagesCount,ppulLanguages)	\
    (This)->lpVtbl -> GetLanguages(This,pulLanguagesCount,ppulLanguages)

#define IInkAnalysisRecognizer_GetUnicodeRanges(This,pulNumberOfRanges,ppulLowUnicode,ppusUnicodeRangeLength)	\
    (This)->lpVtbl -> GetUnicodeRanges(This,pulNumberOfRanges,ppulLowUnicode,ppusUnicodeRangeLength)

#define IInkAnalysisRecognizer_SetAsHighestPriorityInkAnalysisRecognizer(This)	\
    (This)->lpVtbl -> SetAsHighestPriorityInkAnalysisRecognizer(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalysisRecognizer_GetName_Proxy( 
    IInkAnalysisRecognizer * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IInkAnalysisRecognizer_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalysisRecognizer_GetGuid_Proxy( 
    IInkAnalysisRecognizer * This,
    /* [out] */ GUID *pId);


void __RPC_STUB IInkAnalysisRecognizer_GetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalysisRecognizer_GetVendor_Proxy( 
    IInkAnalysisRecognizer * This,
    /* [out] */ BSTR *pbstrVendor);


void __RPC_STUB IInkAnalysisRecognizer_GetVendor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalysisRecognizer_GetCapabilities_Proxy( 
    IInkAnalysisRecognizer * This,
    /* [out] */ InkAnalysisRecognizerCapabilities *pCapabilities);


void __RPC_STUB IInkAnalysisRecognizer_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalysisRecognizer_GetSupportedProperties_Proxy( 
    IInkAnalysisRecognizer * This,
    /* [out][in] */ ULONG *pulPropertiesCount,
    /* [size_is][out] */ GUID **ppProperties);


void __RPC_STUB IInkAnalysisRecognizer_GetSupportedProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalysisRecognizer_GetLanguages_Proxy( 
    IInkAnalysisRecognizer * This,
    /* [out][in] */ ULONG *pulLanguagesCount,
    /* [size_is][out] */ ULONG **ppulLanguages);


void __RPC_STUB IInkAnalysisRecognizer_GetLanguages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalysisRecognizer_GetUnicodeRanges_Proxy( 
    IInkAnalysisRecognizer * This,
    /* [out][in] */ ULONG *pulNumberOfRanges,
    /* [size_is][out] */ WCHAR **ppulLowUnicode,
    /* [size_is][out] */ USHORT **ppusUnicodeRangeLength);


void __RPC_STUB IInkAnalysisRecognizer_GetUnicodeRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalysisRecognizer_SetAsHighestPriorityInkAnalysisRecognizer_Proxy( 
    IInkAnalysisRecognizer * This);


void __RPC_STUB IInkAnalysisRecognizer_SetAsHighestPriorityInkAnalysisRecognizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInkAnalysisRecognizer_INTERFACE_DEFINED__ */


#ifndef __IInkAnalysisRecognizers_INTERFACE_DEFINED__
#define __IInkAnalysisRecognizers_INTERFACE_DEFINED__

/* interface IInkAnalysisRecognizers */
/* [object][unique][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID_IInkAnalysisRecognizers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7C3B2C8F-1ADD-309A-9201-22C6E0DDA633")
    IInkAnalysisRecognizers : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetInkAnalysisRecognizer( 
            /* [in] */ ULONG ulIndex,
            /* [out] */ IInkAnalysisRecognizer **ppInkAnalysisRecognizer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInkAnalysisRecognizersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInkAnalysisRecognizers * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInkAnalysisRecognizers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInkAnalysisRecognizers * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IInkAnalysisRecognizers * This,
            /* [out] */ ULONG *pulCount);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetInkAnalysisRecognizer )( 
            IInkAnalysisRecognizers * This,
            /* [in] */ ULONG ulIndex,
            /* [out] */ IInkAnalysisRecognizer **ppInkAnalysisRecognizer);
        
        END_INTERFACE
    } IInkAnalysisRecognizersVtbl;

    interface IInkAnalysisRecognizers
    {
        CONST_VTBL struct IInkAnalysisRecognizersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInkAnalysisRecognizers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInkAnalysisRecognizers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInkAnalysisRecognizers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInkAnalysisRecognizers_GetCount(This,pulCount)	\
    (This)->lpVtbl -> GetCount(This,pulCount)

#define IInkAnalysisRecognizers_GetInkAnalysisRecognizer(This,ulIndex,ppInkAnalysisRecognizer)	\
    (This)->lpVtbl -> GetInkAnalysisRecognizer(This,ulIndex,ppInkAnalysisRecognizer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalysisRecognizers_GetCount_Proxy( 
    IInkAnalysisRecognizers * This,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB IInkAnalysisRecognizers_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IInkAnalysisRecognizers_GetInkAnalysisRecognizer_Proxy( 
    IInkAnalysisRecognizers * This,
    /* [in] */ ULONG ulIndex,
    /* [out] */ IInkAnalysisRecognizer **ppInkAnalysisRecognizer);


void __RPC_STUB IInkAnalysisRecognizers_GetInkAnalysisRecognizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInkAnalysisRecognizers_INTERFACE_DEFINED__ */


#ifndef __IAnalysisAlternate_INTERFACE_DEFINED__
#define __IAnalysisAlternate_INTERFACE_DEFINED__

/* interface IAnalysisAlternate */
/* [object][unique][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID_IAnalysisAlternate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5DB42FCE-8FDE-3E45-8C4A-224C89034F02")
    IAnalysisAlternate : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetAlternateNodes( 
            /* [out] */ IContextNodes **ppAlternateNodes) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetRecognizedString( 
            /* [out] */ BSTR *pbstrRecognizedString) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetStrokeIds( 
            /* [out][in] */ ULONG *pulStrokeIdsCount,
            /* [size_is][out] */ LONG **pplStrokeIds) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetRecognitionConfidence( 
            /* [out] */ RecognitionConfidence *pConfidence) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnalysisAlternateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAnalysisAlternate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAnalysisAlternate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAnalysisAlternate * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAlternateNodes )( 
            IAnalysisAlternate * This,
            /* [out] */ IContextNodes **ppAlternateNodes);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRecognizedString )( 
            IAnalysisAlternate * This,
            /* [out] */ BSTR *pbstrRecognizedString);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStrokeIds )( 
            IAnalysisAlternate * This,
            /* [out][in] */ ULONG *pulStrokeIdsCount,
            /* [size_is][out] */ LONG **pplStrokeIds);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRecognitionConfidence )( 
            IAnalysisAlternate * This,
            /* [out] */ RecognitionConfidence *pConfidence);
        
        END_INTERFACE
    } IAnalysisAlternateVtbl;

    interface IAnalysisAlternate
    {
        CONST_VTBL struct IAnalysisAlternateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnalysisAlternate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAnalysisAlternate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAnalysisAlternate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAnalysisAlternate_GetAlternateNodes(This,ppAlternateNodes)	\
    (This)->lpVtbl -> GetAlternateNodes(This,ppAlternateNodes)

#define IAnalysisAlternate_GetRecognizedString(This,pbstrRecognizedString)	\
    (This)->lpVtbl -> GetRecognizedString(This,pbstrRecognizedString)

#define IAnalysisAlternate_GetStrokeIds(This,pulStrokeIdsCount,pplStrokeIds)	\
    (This)->lpVtbl -> GetStrokeIds(This,pulStrokeIdsCount,pplStrokeIds)

#define IAnalysisAlternate_GetRecognitionConfidence(This,pConfidence)	\
    (This)->lpVtbl -> GetRecognitionConfidence(This,pConfidence)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisAlternate_GetAlternateNodes_Proxy( 
    IAnalysisAlternate * This,
    /* [out] */ IContextNodes **ppAlternateNodes);


void __RPC_STUB IAnalysisAlternate_GetAlternateNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisAlternate_GetRecognizedString_Proxy( 
    IAnalysisAlternate * This,
    /* [out] */ BSTR *pbstrRecognizedString);


void __RPC_STUB IAnalysisAlternate_GetRecognizedString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisAlternate_GetStrokeIds_Proxy( 
    IAnalysisAlternate * This,
    /* [out][in] */ ULONG *pulStrokeIdsCount,
    /* [size_is][out] */ LONG **pplStrokeIds);


void __RPC_STUB IAnalysisAlternate_GetStrokeIds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisAlternate_GetRecognitionConfidence_Proxy( 
    IAnalysisAlternate * This,
    /* [out] */ RecognitionConfidence *pConfidence);


void __RPC_STUB IAnalysisAlternate_GetRecognitionConfidence_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAnalysisAlternate_INTERFACE_DEFINED__ */


#ifndef __IAnalysisAlternates_INTERFACE_DEFINED__
#define __IAnalysisAlternates_INTERFACE_DEFINED__

/* interface IAnalysisAlternates */
/* [object][unique][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID_IAnalysisAlternates;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4262DF99-1C25-3CF8-98CB-4528DE750F08")
    IAnalysisAlternates : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetAnalysisAlternate( 
            /* [in] */ ULONG ulIndex,
            /* [out] */ IAnalysisAlternate **ppAlternate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnalysisAlternatesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAnalysisAlternates * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAnalysisAlternates * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAnalysisAlternates * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IAnalysisAlternates * This,
            /* [out] */ ULONG *pulCount);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAnalysisAlternate )( 
            IAnalysisAlternates * This,
            /* [in] */ ULONG ulIndex,
            /* [out] */ IAnalysisAlternate **ppAlternate);
        
        END_INTERFACE
    } IAnalysisAlternatesVtbl;

    interface IAnalysisAlternates
    {
        CONST_VTBL struct IAnalysisAlternatesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnalysisAlternates_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAnalysisAlternates_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAnalysisAlternates_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAnalysisAlternates_GetCount(This,pulCount)	\
    (This)->lpVtbl -> GetCount(This,pulCount)

#define IAnalysisAlternates_GetAnalysisAlternate(This,ulIndex,ppAlternate)	\
    (This)->lpVtbl -> GetAnalysisAlternate(This,ulIndex,ppAlternate)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisAlternates_GetCount_Proxy( 
    IAnalysisAlternates * This,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB IAnalysisAlternates_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisAlternates_GetAnalysisAlternate_Proxy( 
    IAnalysisAlternates * This,
    /* [in] */ ULONG ulIndex,
    /* [out] */ IAnalysisAlternate **ppAlternate);


void __RPC_STUB IAnalysisAlternates_GetAnalysisAlternate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAnalysisAlternates_INTERFACE_DEFINED__ */


#ifndef __IAnalysisWarning_INTERFACE_DEFINED__
#define __IAnalysisWarning_INTERFACE_DEFINED__

/* interface IAnalysisWarning */
/* [object][unique][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID_IAnalysisWarning;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B7BC3EF6-C944-33C5-8917-19BD3E0C8327")
    IAnalysisWarning : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetWarningCode( 
            /* [out] */ AnalysisWarningCode *pWarningCode) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetNodeIds( 
            /* [out][in] */ ULONG *pulNodeIdCount,
            /* [size_is][out] */ GUID **ppNodeIds) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetHint( 
            /* [out] */ IContextNode **pAnalysisHint) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetBackgroundError( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnalysisWarningVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAnalysisWarning * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAnalysisWarning * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAnalysisWarning * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetWarningCode )( 
            IAnalysisWarning * This,
            /* [out] */ AnalysisWarningCode *pWarningCode);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNodeIds )( 
            IAnalysisWarning * This,
            /* [out][in] */ ULONG *pulNodeIdCount,
            /* [size_is][out] */ GUID **ppNodeIds);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetHint )( 
            IAnalysisWarning * This,
            /* [out] */ IContextNode **pAnalysisHint);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetBackgroundError )( 
            IAnalysisWarning * This);
        
        END_INTERFACE
    } IAnalysisWarningVtbl;

    interface IAnalysisWarning
    {
        CONST_VTBL struct IAnalysisWarningVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnalysisWarning_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAnalysisWarning_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAnalysisWarning_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAnalysisWarning_GetWarningCode(This,pWarningCode)	\
    (This)->lpVtbl -> GetWarningCode(This,pWarningCode)

#define IAnalysisWarning_GetNodeIds(This,pulNodeIdCount,ppNodeIds)	\
    (This)->lpVtbl -> GetNodeIds(This,pulNodeIdCount,ppNodeIds)

#define IAnalysisWarning_GetHint(This,pAnalysisHint)	\
    (This)->lpVtbl -> GetHint(This,pAnalysisHint)

#define IAnalysisWarning_GetBackgroundError(This)	\
    (This)->lpVtbl -> GetBackgroundError(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisWarning_GetWarningCode_Proxy( 
    IAnalysisWarning * This,
    /* [out] */ AnalysisWarningCode *pWarningCode);


void __RPC_STUB IAnalysisWarning_GetWarningCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisWarning_GetNodeIds_Proxy( 
    IAnalysisWarning * This,
    /* [out][in] */ ULONG *pulNodeIdCount,
    /* [size_is][out] */ GUID **ppNodeIds);


void __RPC_STUB IAnalysisWarning_GetNodeIds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisWarning_GetHint_Proxy( 
    IAnalysisWarning * This,
    /* [out] */ IContextNode **pAnalysisHint);


void __RPC_STUB IAnalysisWarning_GetHint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisWarning_GetBackgroundError_Proxy( 
    IAnalysisWarning * This);


void __RPC_STUB IAnalysisWarning_GetBackgroundError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAnalysisWarning_INTERFACE_DEFINED__ */


#ifndef __IAnalysisWarnings_INTERFACE_DEFINED__
#define __IAnalysisWarnings_INTERFACE_DEFINED__

/* interface IAnalysisWarnings */
/* [object][unique][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID_IAnalysisWarnings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("304ADA62-DEC1-35BF-84AE-A61BB846ADD7")
    IAnalysisWarnings : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetAnalysisWarning( 
            /* [in] */ ULONG ulIndex,
            /* [out] */ IAnalysisWarning **ppIAnalysisWarning) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnalysisWarningsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAnalysisWarnings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAnalysisWarnings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAnalysisWarnings * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IAnalysisWarnings * This,
            /* [out] */ ULONG *pulCount);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAnalysisWarning )( 
            IAnalysisWarnings * This,
            /* [in] */ ULONG ulIndex,
            /* [out] */ IAnalysisWarning **ppIAnalysisWarning);
        
        END_INTERFACE
    } IAnalysisWarningsVtbl;

    interface IAnalysisWarnings
    {
        CONST_VTBL struct IAnalysisWarningsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnalysisWarnings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAnalysisWarnings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAnalysisWarnings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAnalysisWarnings_GetCount(This,pulCount)	\
    (This)->lpVtbl -> GetCount(This,pulCount)

#define IAnalysisWarnings_GetAnalysisWarning(This,ulIndex,ppIAnalysisWarning)	\
    (This)->lpVtbl -> GetAnalysisWarning(This,ulIndex,ppIAnalysisWarning)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisWarnings_GetCount_Proxy( 
    IAnalysisWarnings * This,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB IAnalysisWarnings_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisWarnings_GetAnalysisWarning_Proxy( 
    IAnalysisWarnings * This,
    /* [in] */ ULONG ulIndex,
    /* [out] */ IAnalysisWarning **ppIAnalysisWarning);


void __RPC_STUB IAnalysisWarnings_GetAnalysisWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAnalysisWarnings_INTERFACE_DEFINED__ */


#ifndef __IAnalysisStatus_INTERFACE_DEFINED__
#define __IAnalysisStatus_INTERFACE_DEFINED__

/* interface IAnalysisStatus */
/* [object][unique][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID_IAnalysisStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E16FC8B-F1DC-38C9-BB8F-7EF7B0D6C5AE")
    IAnalysisStatus : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IsSuccessful( 
            /* [out] */ VARIANT_BOOL *pfSuccessful) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetAppliedChangesRegion( 
            /* [out] */ IAnalysisRegion **pAppliedChangesRegion) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetWarnings( 
            /* [out] */ IAnalysisWarnings **ppAnalysisWarnings) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnalysisStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAnalysisStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAnalysisStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAnalysisStatus * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsSuccessful )( 
            IAnalysisStatus * This,
            /* [out] */ VARIANT_BOOL *pfSuccessful);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAppliedChangesRegion )( 
            IAnalysisStatus * This,
            /* [out] */ IAnalysisRegion **pAppliedChangesRegion);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetWarnings )( 
            IAnalysisStatus * This,
            /* [out] */ IAnalysisWarnings **ppAnalysisWarnings);
        
        END_INTERFACE
    } IAnalysisStatusVtbl;

    interface IAnalysisStatus
    {
        CONST_VTBL struct IAnalysisStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnalysisStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAnalysisStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAnalysisStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAnalysisStatus_IsSuccessful(This,pfSuccessful)	\
    (This)->lpVtbl -> IsSuccessful(This,pfSuccessful)

#define IAnalysisStatus_GetAppliedChangesRegion(This,pAppliedChangesRegion)	\
    (This)->lpVtbl -> GetAppliedChangesRegion(This,pAppliedChangesRegion)

#define IAnalysisStatus_GetWarnings(This,ppAnalysisWarnings)	\
    (This)->lpVtbl -> GetWarnings(This,ppAnalysisWarnings)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisStatus_IsSuccessful_Proxy( 
    IAnalysisStatus * This,
    /* [out] */ VARIANT_BOOL *pfSuccessful);


void __RPC_STUB IAnalysisStatus_IsSuccessful_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisStatus_GetAppliedChangesRegion_Proxy( 
    IAnalysisStatus * This,
    /* [out] */ IAnalysisRegion **pAppliedChangesRegion);


void __RPC_STUB IAnalysisStatus_GetAppliedChangesRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IAnalysisStatus_GetWarnings_Proxy( 
    IAnalysisStatus * This,
    /* [out] */ IAnalysisWarnings **ppAnalysisWarnings);


void __RPC_STUB IAnalysisStatus_GetWarnings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAnalysisStatus_INTERFACE_DEFINED__ */


#ifndef __IMatchesCriteriaCallBack_INTERFACE_DEFINED__
#define __IMatchesCriteriaCallBack_INTERFACE_DEFINED__

/* interface IMatchesCriteriaCallBack */
/* [object][unique][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID_IMatchesCriteriaCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A11BEA2D-62F5-3DDC-AEFD-5BFED2ED43E9")
    IMatchesCriteriaCallBack : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE EvaluateContextNode( 
            /* [in] */ IContextNode *pContextNodeToEvaluate,
            /* [out] */ VARIANT_BOOL *pbResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMatchesCriteriaCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMatchesCriteriaCallBack * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMatchesCriteriaCallBack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMatchesCriteriaCallBack * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EvaluateContextNode )( 
            IMatchesCriteriaCallBack * This,
            /* [in] */ IContextNode *pContextNodeToEvaluate,
            /* [out] */ VARIANT_BOOL *pbResult);
        
        END_INTERFACE
    } IMatchesCriteriaCallBackVtbl;

    interface IMatchesCriteriaCallBack
    {
        CONST_VTBL struct IMatchesCriteriaCallBackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMatchesCriteriaCallBack_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMatchesCriteriaCallBack_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMatchesCriteriaCallBack_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMatchesCriteriaCallBack_EvaluateContextNode(This,pContextNodeToEvaluate,pbResult)	\
    (This)->lpVtbl -> EvaluateContextNode(This,pContextNodeToEvaluate,pbResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IMatchesCriteriaCallBack_EvaluateContextNode_Proxy( 
    IMatchesCriteriaCallBack * This,
    /* [in] */ IContextNode *pContextNodeToEvaluate,
    /* [out] */ VARIANT_BOOL *pbResult);


void __RPC_STUB IMatchesCriteriaCallBack_EvaluateContextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMatchesCriteriaCallBack_INTERFACE_DEFINED__ */


#ifndef ___IAnalysisEvents_INTERFACE_DEFINED__
#define ___IAnalysisEvents_INTERFACE_DEFINED__

/* interface _IAnalysisEvents */
/* [object][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID__IAnalysisEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67CCF9D3-FE75-338D-BB4B-FD0FF18C8258")
    _IAnalysisEvents : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ResultsUpdated( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IAnalysisStatus *pAnalysisStatus) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IntermediateResultsUpdated( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IAnalysisStatus *pAnalysisStatus) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Activity( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE UpdateStrokesCache( 
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ReadyToReconcile( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _IAnalysisEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            _IAnalysisEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            _IAnalysisEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            _IAnalysisEvents * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ResultsUpdated )( 
            _IAnalysisEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IAnalysisStatus *pAnalysisStatus);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *IntermediateResultsUpdated )( 
            _IAnalysisEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IAnalysisStatus *pAnalysisStatus);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Activity )( 
            _IAnalysisEvents * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *UpdateStrokesCache )( 
            _IAnalysisEvents * This,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReadyToReconcile )( 
            _IAnalysisEvents * This);
        
        END_INTERFACE
    } _IAnalysisEventsVtbl;

    interface _IAnalysisEvents
    {
        CONST_VTBL struct _IAnalysisEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IAnalysisEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IAnalysisEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IAnalysisEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IAnalysisEvents_ResultsUpdated(This,pInkAnalyzer,pAnalysisStatus)	\
    (This)->lpVtbl -> ResultsUpdated(This,pInkAnalyzer,pAnalysisStatus)

#define _IAnalysisEvents_IntermediateResultsUpdated(This,pInkAnalyzer,pAnalysisStatus)	\
    (This)->lpVtbl -> IntermediateResultsUpdated(This,pInkAnalyzer,pAnalysisStatus)

#define _IAnalysisEvents_Activity(This)	\
    (This)->lpVtbl -> Activity(This)

#define _IAnalysisEvents_UpdateStrokesCache(This,ulStrokeIdsCount,plStrokeIds)	\
    (This)->lpVtbl -> UpdateStrokesCache(This,ulStrokeIdsCount,plStrokeIds)

#define _IAnalysisEvents_ReadyToReconcile(This)	\
    (This)->lpVtbl -> ReadyToReconcile(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisEvents_ResultsUpdated_Proxy( 
    _IAnalysisEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer,
    /* [in] */ IAnalysisStatus *pAnalysisStatus);


void __RPC_STUB _IAnalysisEvents_ResultsUpdated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisEvents_IntermediateResultsUpdated_Proxy( 
    _IAnalysisEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer,
    /* [in] */ IAnalysisStatus *pAnalysisStatus);


void __RPC_STUB _IAnalysisEvents_IntermediateResultsUpdated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisEvents_Activity_Proxy( 
    _IAnalysisEvents * This);


void __RPC_STUB _IAnalysisEvents_Activity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisEvents_UpdateStrokesCache_Proxy( 
    _IAnalysisEvents * This,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plStrokeIds);


void __RPC_STUB _IAnalysisEvents_UpdateStrokesCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisEvents_ReadyToReconcile_Proxy( 
    _IAnalysisEvents * This);


void __RPC_STUB _IAnalysisEvents_ReadyToReconcile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* ___IAnalysisEvents_INTERFACE_DEFINED__ */


#ifndef ___IAnalysisProxyEvents_INTERFACE_DEFINED__
#define ___IAnalysisProxyEvents_INTERFACE_DEFINED__

/* interface _IAnalysisProxyEvents */
/* [object][uuid][helpcontext][helpstring] */ 


EXTERN_C const IID IID__IAnalysisProxyEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70049599-2E75-3FEC-A597-C8191105F4FB")
    _IAnalysisProxyEvents : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE InkAnalyzerStateChanging( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ContextNodePropertiesUpdated( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextNode *pContextNodeUpdated,
            /* [in] */ ULONG ulPropertiesIdsCount,
            /* [size_is][in] */ GUID *pUpdatedProperties) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE PopulateContextNode( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextNode *pContextNodeToPopulate,
            /* [in] */ VARIANT_BOOL bPopulateSubTree) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ContextNodeCreated( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextNode *pContextNodeCreated) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ContextNodeDeleting( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextNode *pContextNodeToBeDeleted) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ContextNodeReparenting( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextNode *pNewParentContextNode,
            /* [in] */ IContextNode *pContextNodeToBeReparented) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ContextNodeMovingToPosition( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextNode *pSubnodeToMove,
            /* [in] */ IContextNode *pParentContextNode,
            /* [in] */ ULONG ulNewIndex) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE StrokesReparented( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [in] */ IContextNode *pSourceContextNode,
            /* [in] */ IContextNode *pDestinationContextNode) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE NewStrokesLoaded( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [in] */ IContextNode *pNodeWithStrokes) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ContextNodeLinkAdding( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextLink *pContextLinkToBeAdded) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ContextNodeLinkDeleting( 
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextLink *pContextLinkToBeDeleted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _IAnalysisProxyEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            _IAnalysisProxyEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            _IAnalysisProxyEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            _IAnalysisProxyEvents * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *InkAnalyzerStateChanging )( 
            _IAnalysisProxyEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ContextNodePropertiesUpdated )( 
            _IAnalysisProxyEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextNode *pContextNodeUpdated,
            /* [in] */ ULONG ulPropertiesIdsCount,
            /* [size_is][in] */ GUID *pUpdatedProperties);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *PopulateContextNode )( 
            _IAnalysisProxyEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextNode *pContextNodeToPopulate,
            /* [in] */ VARIANT_BOOL bPopulateSubTree);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ContextNodeCreated )( 
            _IAnalysisProxyEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextNode *pContextNodeCreated);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ContextNodeDeleting )( 
            _IAnalysisProxyEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextNode *pContextNodeToBeDeleted);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ContextNodeReparenting )( 
            _IAnalysisProxyEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextNode *pNewParentContextNode,
            /* [in] */ IContextNode *pContextNodeToBeReparented);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ContextNodeMovingToPosition )( 
            _IAnalysisProxyEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextNode *pSubnodeToMove,
            /* [in] */ IContextNode *pParentContextNode,
            /* [in] */ ULONG ulNewIndex);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *StrokesReparented )( 
            _IAnalysisProxyEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [in] */ IContextNode *pSourceContextNode,
            /* [in] */ IContextNode *pDestinationContextNode);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *NewStrokesLoaded )( 
            _IAnalysisProxyEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ ULONG ulStrokeIdsCount,
            /* [size_is][in] */ LONG *plStrokeIds,
            /* [in] */ IContextNode *pNodeWithStrokes);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ContextNodeLinkAdding )( 
            _IAnalysisProxyEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextLink *pContextLinkToBeAdded);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ContextNodeLinkDeleting )( 
            _IAnalysisProxyEvents * This,
            /* [in] */ IInkAnalyzer *pInkAnalyzer,
            /* [in] */ IContextLink *pContextLinkToBeDeleted);
        
        END_INTERFACE
    } _IAnalysisProxyEventsVtbl;

    interface _IAnalysisProxyEvents
    {
        CONST_VTBL struct _IAnalysisProxyEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IAnalysisProxyEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IAnalysisProxyEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IAnalysisProxyEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IAnalysisProxyEvents_InkAnalyzerStateChanging(This,pInkAnalyzer)	\
    (This)->lpVtbl -> InkAnalyzerStateChanging(This,pInkAnalyzer)

#define _IAnalysisProxyEvents_ContextNodePropertiesUpdated(This,pInkAnalyzer,pContextNodeUpdated,ulPropertiesIdsCount,pUpdatedProperties)	\
    (This)->lpVtbl -> ContextNodePropertiesUpdated(This,pInkAnalyzer,pContextNodeUpdated,ulPropertiesIdsCount,pUpdatedProperties)

#define _IAnalysisProxyEvents_PopulateContextNode(This,pInkAnalyzer,pContextNodeToPopulate,bPopulateSubTree)	\
    (This)->lpVtbl -> PopulateContextNode(This,pInkAnalyzer,pContextNodeToPopulate,bPopulateSubTree)

#define _IAnalysisProxyEvents_ContextNodeCreated(This,pInkAnalyzer,pContextNodeCreated)	\
    (This)->lpVtbl -> ContextNodeCreated(This,pInkAnalyzer,pContextNodeCreated)

#define _IAnalysisProxyEvents_ContextNodeDeleting(This,pInkAnalyzer,pContextNodeToBeDeleted)	\
    (This)->lpVtbl -> ContextNodeDeleting(This,pInkAnalyzer,pContextNodeToBeDeleted)

#define _IAnalysisProxyEvents_ContextNodeReparenting(This,pInkAnalyzer,pNewParentContextNode,pContextNodeToBeReparented)	\
    (This)->lpVtbl -> ContextNodeReparenting(This,pInkAnalyzer,pNewParentContextNode,pContextNodeToBeReparented)

#define _IAnalysisProxyEvents_ContextNodeMovingToPosition(This,pInkAnalyzer,pSubnodeToMove,pParentContextNode,ulNewIndex)	\
    (This)->lpVtbl -> ContextNodeMovingToPosition(This,pInkAnalyzer,pSubnodeToMove,pParentContextNode,ulNewIndex)

#define _IAnalysisProxyEvents_StrokesReparented(This,pInkAnalyzer,ulStrokeIdsCount,plStrokeIds,pSourceContextNode,pDestinationContextNode)	\
    (This)->lpVtbl -> StrokesReparented(This,pInkAnalyzer,ulStrokeIdsCount,plStrokeIds,pSourceContextNode,pDestinationContextNode)

#define _IAnalysisProxyEvents_NewStrokesLoaded(This,pInkAnalyzer,ulStrokeIdsCount,plStrokeIds,pNodeWithStrokes)	\
    (This)->lpVtbl -> NewStrokesLoaded(This,pInkAnalyzer,ulStrokeIdsCount,plStrokeIds,pNodeWithStrokes)

#define _IAnalysisProxyEvents_ContextNodeLinkAdding(This,pInkAnalyzer,pContextLinkToBeAdded)	\
    (This)->lpVtbl -> ContextNodeLinkAdding(This,pInkAnalyzer,pContextLinkToBeAdded)

#define _IAnalysisProxyEvents_ContextNodeLinkDeleting(This,pInkAnalyzer,pContextLinkToBeDeleted)	\
    (This)->lpVtbl -> ContextNodeLinkDeleting(This,pInkAnalyzer,pContextLinkToBeDeleted)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisProxyEvents_InkAnalyzerStateChanging_Proxy( 
    _IAnalysisProxyEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer);


void __RPC_STUB _IAnalysisProxyEvents_InkAnalyzerStateChanging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisProxyEvents_ContextNodePropertiesUpdated_Proxy( 
    _IAnalysisProxyEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer,
    /* [in] */ IContextNode *pContextNodeUpdated,
    /* [in] */ ULONG ulPropertiesIdsCount,
    /* [size_is][in] */ GUID *pUpdatedProperties);


void __RPC_STUB _IAnalysisProxyEvents_ContextNodePropertiesUpdated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisProxyEvents_PopulateContextNode_Proxy( 
    _IAnalysisProxyEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer,
    /* [in] */ IContextNode *pContextNodeToPopulate,
    /* [in] */ VARIANT_BOOL bPopulateSubTree);


void __RPC_STUB _IAnalysisProxyEvents_PopulateContextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisProxyEvents_ContextNodeCreated_Proxy( 
    _IAnalysisProxyEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer,
    /* [in] */ IContextNode *pContextNodeCreated);


void __RPC_STUB _IAnalysisProxyEvents_ContextNodeCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisProxyEvents_ContextNodeDeleting_Proxy( 
    _IAnalysisProxyEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer,
    /* [in] */ IContextNode *pContextNodeToBeDeleted);


void __RPC_STUB _IAnalysisProxyEvents_ContextNodeDeleting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisProxyEvents_ContextNodeReparenting_Proxy( 
    _IAnalysisProxyEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer,
    /* [in] */ IContextNode *pNewParentContextNode,
    /* [in] */ IContextNode *pContextNodeToBeReparented);


void __RPC_STUB _IAnalysisProxyEvents_ContextNodeReparenting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisProxyEvents_ContextNodeMovingToPosition_Proxy( 
    _IAnalysisProxyEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer,
    /* [in] */ IContextNode *pSubnodeToMove,
    /* [in] */ IContextNode *pParentContextNode,
    /* [in] */ ULONG ulNewIndex);


void __RPC_STUB _IAnalysisProxyEvents_ContextNodeMovingToPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisProxyEvents_StrokesReparented_Proxy( 
    _IAnalysisProxyEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plStrokeIds,
    /* [in] */ IContextNode *pSourceContextNode,
    /* [in] */ IContextNode *pDestinationContextNode);


void __RPC_STUB _IAnalysisProxyEvents_StrokesReparented_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisProxyEvents_NewStrokesLoaded_Proxy( 
    _IAnalysisProxyEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer,
    /* [in] */ ULONG ulStrokeIdsCount,
    /* [size_is][in] */ LONG *plStrokeIds,
    /* [in] */ IContextNode *pNodeWithStrokes);


void __RPC_STUB _IAnalysisProxyEvents_NewStrokesLoaded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisProxyEvents_ContextNodeLinkAdding_Proxy( 
    _IAnalysisProxyEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer,
    /* [in] */ IContextLink *pContextLinkToBeAdded);


void __RPC_STUB _IAnalysisProxyEvents_ContextNodeLinkAdding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE _IAnalysisProxyEvents_ContextNodeLinkDeleting_Proxy( 
    _IAnalysisProxyEvents * This,
    /* [in] */ IInkAnalyzer *pInkAnalyzer,
    /* [in] */ IContextLink *pContextLinkToBeDeleted);


void __RPC_STUB _IAnalysisProxyEvents_ContextNodeLinkDeleting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* ___IAnalysisProxyEvents_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_InkAnalyzer;

#ifdef __cplusplus

class DECLSPEC_UUID("B4BAB526-5BA1-3C4D-AF21-CFDCD9AAF2D2")
InkAnalyzer;
#endif

EXTERN_C const CLSID CLSID_AnalysisRegion;

#ifdef __cplusplus

class DECLSPEC_UUID("3C3E7657-4F0C-3FC4-8A89-A5B0F7EB480A")
AnalysisRegion;
#endif
#endif /* __COMINKANALYSISLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_iacom_0272 */
/* [local] */ 

#endif /* of #define _COMINKANALYSIS_H_*/


extern RPC_IF_HANDLE __MIDL_itf_iacom_0272_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iacom_0272_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\IAGuid.h ===
//--------------------------------------------------------------------------
//  This is part of the Microsoft Tablet PC Platform SDK
//  Copyright (C) 2002 Microsoft Corporation
//  All rights reserved.
//
//
// Module:       
//      IAGuid.h
//
//--------------------------------------------------------------------------

#if !defined(_IA_GUID)
#define _IA_GUID

#pragma warning(disable : 4115)
#include <objbase.h>
#pragma warning(default : 4115)

EXTERN_C const GUID NULLGUID;

#define INDEX_GUID_ROTATEDBOUNDINGBOX       0
#define INDEX_GUID_CUSTOMRECOGNIZERID       1
#define INDEX_GUID_SHAPENAME                2
#define INDEX_GUID_ALIGNMENTLEVEL           3
#define INDEX_GUID_NODEDATA                 4
#define INDEX_GUID_SEMANTICTYPE             5
#define INDEX_GUID_CONTENTTYPE              6
#define INDEX_GUID_ASCENDER                 7
#define INDEX_GUID_DESCENDER                8
#define INDEX_GUID_BASELINE                 9
#define INDEX_GUID_MIDLINE                 10
#define INDEX_GUID_RECOGNIZEDSTRING        11
#define INDEX_GUID_CONFIDENCELEVEL         12
#define INDEX_GUID_HOTPOINTS               13
#define INDEX_GUID_CENTROID                14


#define INDEX_GUID_ANALYSISHINTNAME         0
#define INDEX_GUID_GUIDE                    1
#define INDEX_GUID_WORDMODE                 2
#define INDEX_GUID_COERCETOFACTOID          3
#define INDEX_GUID_ALLOWPARTIALDICTIONARYTERMS 4
#define INDEX_GUID_PREFIXTEXT               5
#define INDEX_GUID_SUFFIXTEXT               6
#define INDEX_GUID_FACTOID                  7
#define INDEX_GUID_WORDLIST                 8
#define INDEX_GUID_TOPINKBREAKSONLY         9
#define INDEX_GUID_ENABLEDUNICODECHARACTERRANGES 10


#define INDEX_GUID_ROOT                     0
#define INDEX_GUID_UNCLASSIFIEDINK          1
#define INDEX_GUID_WRITINGREGION            2
#define INDEX_GUID_ANALYSISHINT             3
#define INDEX_GUID_OBJECT                   4
#define INDEX_GUID_INKDRAWING               5
#define INDEX_GUID_IMAGE                    6
#define INDEX_GUID_PARAGRAPH                7
#define INDEX_GUID_LINE                     8
#define INDEX_GUID_INKBULLET                9
#define INDEX_GUID_INKWORD                 10
#define INDEX_GUID_TEXTWORD                11
#define INDEX_GUID_CUSTOMRECOGNIZER        12

#define INDEX_INK_ANALYSIS_GUID_MAX                   128

#if !defined(INITGUID)

EXTERN_C const ULONG KNOWN_INK_ANALYSIS_GUID_BASE_INDEX;
EXTERN_C const ULONG KNOWN_INK_ANALYSIS_GUID_INDEX_LIMIT;

EXTERN_C const ULONG CUSTOM_INK_ANALYSIS_GUID_BASE_INDEX;

EXTERN_C const GUID FAR KNOWN_INK_ANALYSIS_GUIDS[];

EXTERN_C const ULONG KNOWN_INK_ANALYSIS_GUID_COUNT;

#if defined(__cplusplus)

// Guids for predefined Context Node Properties
EXTERN_C const GUID& GUID_CNP_ROTATEDBOUNDINGBOX;
EXTERN_C const GUID& GUID_CNP_SHAPENAME;
EXTERN_C const GUID& GUID_CNP_ALIGNMENTLEVEL;
EXTERN_C const GUID& GUID_CNP_CONTENTTYPE;
EXTERN_C const GUID& GUID_CNP_NODEDATA;
EXTERN_C const GUID& GUID_CNP_ASCENDER;
EXTERN_C const GUID& GUID_CNP_DESCENDER;
EXTERN_C const GUID& GUID_CNP_BASELINE;
EXTERN_C const GUID& GUID_CNP_MIDLINE;
EXTERN_C const GUID& GUID_CNP_RECOGNIZEDSTRING;
EXTERN_C const GUID& GUID_CNP_CUSTOMRECOGNIZERID;
EXTERN_C const GUID& GUID_CNP_CONFIDENCELEVEL;
EXTERN_C const GUID& GUID_CNP_SEMANTICTYPE;
EXTERN_C const GUID& GUID_CNP_HOTPOINTS;
EXTERN_C const GUID& GUID_CNP_CENTROID;

// Guids for predefined AnalysisHint properties
EXTERN_C const GUID& GUID_AHP_ANALYSISHINTNAME;
EXTERN_C const GUID& GUID_AHP_GUIDE;
EXTERN_C const GUID& GUID_AHP_WORDMODE;
EXTERN_C const GUID& GUID_AHP_COERCETOFACTOID;
EXTERN_C const GUID& GUID_AHP_ALLOWPARTIALDICTIONARYTERMS;
EXTERN_C const GUID& GUID_AHP_PREFIXTEXT;
EXTERN_C const GUID& GUID_AHP_SUFFIXTEXT;
EXTERN_C const GUID& GUID_AHP_FACTOID;
EXTERN_C const GUID& GUID_AHP_WORDLIST;
EXTERN_C const GUID& GUID_AHP_TOPINKBREAKSONLY;
EXTERN_C const GUID& GUID_AHP_ENABLEDUNICODECHARACTERRANGES;


// Guids for predefined Context Node Type
EXTERN_C const GUID& GUID_CNT_ROOT;
EXTERN_C const GUID& GUID_CNT_UNCLASSIFIEDINK;
EXTERN_C const GUID& GUID_CNT_WRITINGREGION;
EXTERN_C const GUID& GUID_CNT_ANALYSISHINT;
EXTERN_C const GUID& GUID_CNT_OBJECT;
EXTERN_C const GUID& GUID_CNT_INKDRAWING;
EXTERN_C const GUID& GUID_CNT_IMAGE;
EXTERN_C const GUID& GUID_CNT_PARAGRAPH;
EXTERN_C const GUID& GUID_CNT_LINE;
EXTERN_C const GUID& GUID_CNT_INKBULLET;
EXTERN_C const GUID& GUID_CNT_INKWORD;
EXTERN_C const GUID& GUID_CNT_TEXTWORD;
EXTERN_C const GUID& GUID_CNT_CUSTOMRECOGNIZER;

#endif // of #if defined(__cplusplus)

#else /* of #if !defined(INITGUID) */


#define MAX_KNOWN_INK_ANALYSIS_GUID_INDEX    128

EXTERN_C const ULONG KNOWN_INK_ANALYSIS_GUID_INDEX_LIMIT = MAX_KNOWN_INK_ANALYSIS_GUID_INDEX;
EXTERN_C const ULONG CUSTOM_INK_ANALYSIS_GUID_BASE_INDEX = MAX_KNOWN_INK_ANALYSIS_GUID_INDEX;

// We need to have the real count of GUID values here to satisfy PreFix

EXTERN_C const GUID FAR KNOWN_INK_ANALYSIS_GUIDS[15] = 
{
    // Known Properties
    { 0x9DABD067, 0x4748, 0x4e35, { 0xBA, 0x1F, 0xF6, 0x43, 0xFB, 0xE6, 0x7C, 0x62 } },   // RotatedBoundingBox
    { 0xCE620704, 0x71F7, 0x4C87, { 0xA8, 0x55, 0x8b, 0x66, 0xCD, 0x70, 0xC7, 0x67 } },   // CustomAnalysisRecognizerId
    { 0x83AA077C, 0x955A, 0x4EF8, { 0x80, 0x15, 0xD5, 0x32, 0x35, 0xEB, 0x15, 0x30 } },   // ShapeName
    { 0xAE0BFB16, 0xB9DF, 0x4399, { 0x82, 0x28, 0x1F, 0x5B, 0x6D, 0x90, 0x56, 0xED } },   // Indent Level
    { 0xF5D5FB58, 0x4AA1, 0x448A, { 0xA9, 0x00, 0x40, 0x5F, 0x6D, 0xA1, 0xF8, 0x8D } },   // Node Data
    { 0xE0FDA714, 0xD3A9, 0x4CEE, { 0xBB, 0xB6, 0xAD, 0x0C, 0x8A, 0xA7, 0x18, 0x76 } },   // Semantic type
    { 0x5BC84266, 0x7D7E, 0x4CCC, { 0xA8, 0x1F, 0x16, 0xA2, 0x56, 0xF6, 0xCB, 0x30 } },   // Content Type

    // Recognition Result Properties
    { 0xFFBE58C0, 0x9895, 0x4A5d, { 0xB0, 0x6B, 0xC7, 0xC9, 0x77, 0x4E, 0x32, 0x47 } },   // Ascender
    { 0x106F1013, 0x0517, 0x4BB3, { 0x83, 0x28, 0x2D, 0x6C, 0xBA, 0xB1, 0x00, 0xE3 } },   // Descender
    { 0x19859AE9, 0x35ED, 0x4D53, { 0x91, 0x9D, 0xF7, 0x05, 0xEC, 0xA8, 0x34, 0x73 } },   // Midline
    { 0xEC351E6F, 0xF560, 0x4C0F, { 0xAD, 0x13, 0x17, 0xC0, 0xCD, 0x49, 0x8D, 0xAF } },   // BaseLine 
    { 0x25979182, 0x2D6B, 0x44A3, { 0xAC, 0xD6, 0x5A, 0x2A, 0xD5, 0x1C, 0xD0, 0x5D } },   // TopString
    
    // Recognition Lattice Properties
    { 0x7DFE11A7, 0xFB5D, 0x4958, { 0x87, 0x65, 0x15, 0x4A, 0xDF, 0x0D, 0x83, 0x3F } },   // ConfidenceLevel
    { 0x4F344747, 0xBC2D, 0x471E, { 0x8C, 0xBA, 0x00, 0x2D, 0x11, 0xA3, 0x6E, 0x32 } },   // HotPoints
    { 0xFDC4935E, 0xF009, 0x4C92, { 0x8B, 0x17, 0x37, 0x54, 0xCC, 0xAB, 0x0D, 0xF4 } },   // Centroid
};

EXTERN_C const GUID FAR KNOWN_INK_ANALYSIS_HINT_GUIDS[11] =
{
    // AnalysisHint Properties
    { 0x2967B8B1, 0x739D, 0x4837, { 0x99, 0xA2, 0x50, 0xFD, 0xA9, 0x70, 0x35, 0x69 } },   // AnalysisHintName
    { 0x6D112F6B, 0xD5F9, 0x4c6c, { 0xA4, 0x9C, 0x3A, 0x7C, 0xB8, 0xCB, 0x7E, 0x9A } },   // Guide
    { 0x08D18D88, 0xDD81, 0x4489, { 0x80, 0xD6, 0x11, 0x19, 0x7F, 0x83, 0x63, 0x16 } },   // WordMode
    { 0x4A7A02B9, 0x3D6E, 0x4127, { 0x94, 0x53, 0x12, 0x91, 0x1F, 0x36, 0xC6, 0xA4 } },   // Coerce
    { 0xA41B59B6, 0x3D34, 0x4c06, { 0x85, 0x91, 0x3B, 0x88, 0xA8, 0xA5, 0xAE, 0x00 } },   // AllowPartialDictionaryTerms
    { 0xF77659DC, 0x7480, 0x4598, { 0xAA, 0xB4, 0xDC, 0x9B, 0x28, 0x05, 0x59, 0xF1 } },   // PrefixText
    { 0xAF720D9E, 0x7A41, 0x4099, { 0x85, 0x59, 0x2A, 0x50, 0x8B, 0x35, 0xCC, 0x87 } },   // SuffixText
    { 0x9D104BEA, 0x822B, 0x430b, { 0xBA, 0x6A, 0xE0, 0x53, 0x30, 0xDC, 0xC7, 0x0F } },   // Factoid
    { 0xFCEBB0BD, 0xE304, 0x4966, { 0x80, 0x22, 0x09, 0xCD, 0x4B, 0x45, 0xCD, 0x3D } },   // Wordlist
    { 0x131F5E3B, 0x2B85, 0x43a2, { 0x90, 0xD0, 0xE7, 0x9B, 0x1F, 0x0F, 0xAE, 0x0E } },   // TopInkBreaksOnly
    { 0x02AFC9E0, 0xCB15, 0x42b0, { 0xAC, 0x66, 0x29, 0xF3, 0xD8, 0x22, 0xC5, 0xA2 } },   // EnabledUnicodeCharacterRanges
};

// We need to have the real count of GUID values here to satisfy PreFix

EXTERN_C const GUID FAR KNOWN_NODETYPE_GUIDS[13] = 
{
    { 0xA219A8C3, 0xCEB5, 0x4E26, { 0xBC, 0x66, 0xE8, 0xE3, 0xB4, 0xF9, 0xAA, 0xE1 } },   // Root
    { 0x1CC7E245, 0xD03D, 0x4DF2, { 0x8A, 0x81, 0xA5, 0x5C, 0xF7, 0x40, 0x3E, 0xB5 } },   // Unclassified
    { 0xEC91D634, 0x4105, 0x4C84, { 0x9E, 0x4D, 0xF6, 0x9E, 0xBA, 0x17, 0xFA, 0xEC } },   // WritingRegion
    { 0xB3E85327, 0x34D8, 0x4A53, { 0x9B, 0xED, 0xC4, 0xAA, 0x61, 0x24, 0x28, 0xD3 } },   // AnalysisHint
    { 0x9D81B680, 0x534F, 0x4FFF, { 0xB9, 0xD0, 0xAE, 0x39, 0x95, 0xEA, 0x37, 0x86 } },   // Object
    { 0xAA19D319, 0x57CD, 0x4503, { 0x93, 0x50, 0x6C, 0x0F, 0xB7, 0x66, 0xA4, 0xB8 } },   // InkDrawing
    { 0x142D59BA, 0x3E9A, 0x4EE0, { 0xBC, 0x91, 0x19, 0x9A, 0x7B, 0x7F, 0x7E, 0x17 } },   // Image
    { 0x65B9CE71, 0xA963, 0x48AD, { 0x91, 0x3F, 0x41, 0x1E, 0x81, 0xC9, 0x85, 0xF0 } },   // Paragraph
    { 0x67D98603, 0xB3C5, 0x4261, { 0x82, 0x56, 0xAD, 0xC3, 0xCE, 0xA2, 0xAD, 0x67 } },   // Line
    { 0x88A74BDF, 0x43FA, 0x4A15, { 0x89, 0x0B, 0x9A, 0x33, 0x86, 0x5A, 0x60, 0x91 } },   // InkBullet
    { 0xBD6AAA31, 0x588B, 0x4246, { 0x86, 0x50, 0x4E, 0x78, 0x59, 0x23, 0x30, 0x17 } },   // InkWord
    { 0x4F84A842, 0x2936, 0x464C, { 0xAB, 0x61, 0x37, 0x52, 0x45, 0x1C, 0x21, 0x29 } },   // TextWord
    { 0x8A269227, 0x2BD1, 0x4281, { 0xAB, 0x62, 0x79, 0xFA, 0x24, 0x18, 0xA5, 0xAC } },   // CustomRecognizer

};


EXTERN_C const ULONG KNOWN_INK_ANALYSIS_GUID_COUNT = sizeof(KNOWN_INK_ANALYSIS_GUIDS) / sizeof(GUID);

#if defined(__cplusplus)

EXTERN_C const GUID& GUID_CNP_ROTATEDBOUNDINGBOX            = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_ROTATEDBOUNDINGBOX             ]; 
EXTERN_C const GUID& GUID_CNP_CUSTOMRECOGNIZERID            = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_CUSTOMRECOGNIZERID             ]; 
EXTERN_C const GUID& GUID_CNP_SHAPENAME                     = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_SHAPENAME                      ]; 
EXTERN_C const GUID& GUID_CNP_ALIGNMENTLEVEL                = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_ALIGNMENTLEVEL                 ]; 
EXTERN_C const GUID& GUID_CNP_CONTENTTYPE                   = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_CONTENTTYPE                    ]; 
EXTERN_C const GUID& GUID_CNP_NODEDATA                      = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_NODEDATA                       ];
EXTERN_C const GUID& GUID_CNP_SEMANTICTYPE                  = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_SEMANTICTYPE                   ];
EXTERN_C const GUID& GUID_CNP_ASCENDER                      = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_ASCENDER                       ]; 
EXTERN_C const GUID& GUID_CNP_DESCENDER                     = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_DESCENDER                      ]; 
EXTERN_C const GUID& GUID_CNP_BASELINE                      = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_BASELINE                       ]; 
EXTERN_C const GUID& GUID_CNP_MIDLINE                       = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_MIDLINE                        ]; 
EXTERN_C const GUID& GUID_CNP_RECOGNIZEDSTRING              = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_RECOGNIZEDSTRING               ]; 
EXTERN_C const GUID& GUID_CNP_CONFIDENCELEVEL               = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_CONFIDENCELEVEL                ];
EXTERN_C const GUID& GUID_CNP_HOTPOINTS                     = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_HOTPOINTS                      ];
EXTERN_C const GUID& GUID_CNP_CENTROID                      = KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_CENTROID                       ];

EXTERN_C const GUID& GUID_AHP_ANALYSISHINTNAME              = KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_ANALYSISHINTNAME             ]; 
EXTERN_C const GUID& GUID_AHP_GUIDE                         = KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_GUIDE                        ]; 
EXTERN_C const GUID& GUID_AHP_WORDMODE                      = KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_WORDMODE                     ]; 
EXTERN_C const GUID& GUID_AHP_COERCETOFACTOID               = KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_COERCETOFACTOID              ]; 
EXTERN_C const GUID& GUID_AHP_ALLOWPARTIALDICTIONARYTERMS   = KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_ALLOWPARTIALDICTIONARYTERMS  ]; 
EXTERN_C const GUID& GUID_AHP_PREFIXTEXT                    = KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_PREFIXTEXT                   ]; 
EXTERN_C const GUID& GUID_AHP_SUFFIXTEXT                    = KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_SUFFIXTEXT                   ]; 
EXTERN_C const GUID& GUID_AHP_FACTOID                       = KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_FACTOID                      ]; 
EXTERN_C const GUID& GUID_AHP_WORDLIST                      = KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_WORDLIST                     ]; 
EXTERN_C const GUID& GUID_AHP_TOPINKBREAKSONLY              = KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_TOPINKBREAKSONLY             ]; 
EXTERN_C const GUID& GUID_AHP_ENABLEDUNICODECHARACTERRANGES = KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_ENABLEDUNICODECHARACTERRANGES]; 


EXTERN_C const GUID& GUID_CNT_ROOT                          = KNOWN_NODETYPE_GUIDS[INDEX_GUID_ROOT                  ];
EXTERN_C const GUID& GUID_CNT_UNCLASSIFIEDINK               = KNOWN_NODETYPE_GUIDS[INDEX_GUID_UNCLASSIFIEDINK       ];
EXTERN_C const GUID& GUID_CNT_WRITINGREGION                 = KNOWN_NODETYPE_GUIDS[INDEX_GUID_WRITINGREGION         ];
EXTERN_C const GUID& GUID_CNT_ANALYSISHINT                  = KNOWN_NODETYPE_GUIDS[INDEX_GUID_ANALYSISHINT          ];
EXTERN_C const GUID& GUID_CNT_OBJECT                        = KNOWN_NODETYPE_GUIDS[INDEX_GUID_OBJECT                ];
EXTERN_C const GUID& GUID_CNT_INKDRAWING                    = KNOWN_NODETYPE_GUIDS[INDEX_GUID_INKDRAWING            ];
EXTERN_C const GUID& GUID_CNT_IMAGE                         = KNOWN_NODETYPE_GUIDS[INDEX_GUID_IMAGE                 ];
EXTERN_C const GUID& GUID_CNT_PARAGRAPH                     = KNOWN_NODETYPE_GUIDS[INDEX_GUID_PARAGRAPH             ];
EXTERN_C const GUID& GUID_CNT_LINE                          = KNOWN_NODETYPE_GUIDS[INDEX_GUID_LINE                  ];
EXTERN_C const GUID& GUID_CNT_INKBULLET                     = KNOWN_NODETYPE_GUIDS[INDEX_GUID_INKBULLET             ];
EXTERN_C const GUID& GUID_CNT_INKWORD                       = KNOWN_NODETYPE_GUIDS[INDEX_GUID_INKWORD               ];
EXTERN_C const GUID& GUID_CNT_TEXTWORD                      = KNOWN_NODETYPE_GUIDS[INDEX_GUID_TEXTWORD              ];
EXTERN_C const GUID& GUID_CNT_CUSTOMRECOGNIZER              = KNOWN_NODETYPE_GUIDS[INDEX_GUID_CUSTOMRECOGNIZER      ];

#endif //of #if defined(__cplusplus)

#endif /* of #if !defined(INITGUID) */

#if !defined(__cplusplus)

#define GUID_CNP_ROTATEDBOUNDINGBOX            (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_ROTATEDBOUNDINGBOX           ]))) 
#define GUID_CNP_CUSTOMRECOGNIZERID            (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_CUSTOMRECOGNIZERID           ])))
#define GUID_CNP_SHAPENAME                     (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_SHAPENAME                    ]))) 
#define GUID_CNP_ALIGNMENTLEVEL                (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_ALIGNMENTLEVEL               ])))
#define GUID_CNP_CONTENTTYPE                   (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_CONTENTTYPE                  ])))
#define GUID_CNP_NODEDATA                      (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_NODEDATA                     ])))
#define GUID_CNP_SEMANTICTYPE                  (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_SEMANTICTYPE                 ])))
#define GUID_CNP_ASCENDER                      (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_ASCENDER                    ]))) 
#define GUID_CNP_DESCENDER                     (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_DESCENDER                   ]))) 
#define GUID_CNP_BASELINE                      (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_BASELINE                     ]))) 
#define GUID_CNP_MIDLINE                       (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_MIDLINE                      ]))) 
#define GUID_CNP_RECOGNIZEDSTRING              (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_RECOGNIZEDSTRING             ]))) 
#define GUID_CNP_CONFIDENCELEVEL               (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_CONFIDENCELEVEL              ])))
#define GUID_CNP_HOTPOINTS                     (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_HOTPOINTS                    ])))
#define GUID_CNP_CENTROID                      (*((GUID*)&(KNOWN_INK_ANALYSIS_GUIDS[INDEX_GUID_CENTROID                     ])))

#define GUID_AHP_ANALYSISHINTNAME              (*((GUID*)&(KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_ANALYSISHINTNAME             ]))) 
#define GUID_AHP_GUIDE                         (*((GUID*)&(KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_GUIDE                        ]))) 
#define GUID_AHP_WORDMODE                      (*((GUID*)&(KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_WORDMODE                     ]))) 
#define GUID_AHP_COERCETOFACTOID               (*((GUID*)&(KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_COERCETOFACTOID              ]))) 
#define GUID_AHP_ALLOWPARTIALDICTIONARYTERMS   (*((GUID*)&(KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_ALLOWPARTIALDICTIONARYTERMS  ]))) 
#define GUID_AHP_PREFIXTEXT                    (*((GUID*)&(KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_PREFIXTEXT                   ]))) 
#define GUID_AHP_SUFFIXTEXT                    (*((GUID*)&(KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_SUFFIXTEXT                   ]))) 
#define GUID_AHP_FACTOID                       (*((GUID*)&(KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_FACTOID                      ]))) 
#define GUID_AHP_WORDLIST                      (*((GUID*)&(KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_WORDLIST                     ])))
#define GUID_AHP_TOPINKBREAKSONLY              (*((GUID*)&(KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_TOPINKBREAKSONLY             ])))
#define GUID_AHP_ENABLEDUNICODECHARACTERRANGES (*((GUID*)&(KNOWN_INK_ANALYSIS_HINT_GUIDS[INDEX_GUID_ENABLEDUNICODECHARACTERRANGES])))


#define GUID_CNT_ROOT                          (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_ROOT                  ])))
#define GUID_CNT_UNCLASSIFIEDINKNODE           (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_UNCLASSIFIEDINK       ])))
#define GUID_CNT_WRITINGREGION                 (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_WRITINGREGION         ])))
#define GUID_CNT_ANALYSISHINT                  (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_ANALYSISHINT          ])))
#define GUID_CNT_OBJECT                        (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_OBJECT                ])))
#define GUID_CNT_INKDRAWING                    (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_INKDRAWING            ])))
#define GUID_CNT_IMAGE                         (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_IMAGE                 ])))
#define GUID_CNT_PARAGRAPH                     (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_PARAGRAPH             ])))
#define GUID_CNT_LINE                          (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_LINE                  ])))
#define GUID_CNT_INKBULLET                     (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_INKBULLET             ])))
#define GUID_CNT_INKWORD                       (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_INKWORD               ])))
#define GUID_CNT_TEXTWORD                      (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_TEXTWORD              ])))
#define GUID_CNT_CUSTOMRECOGNIZER              (*((GUID*)&(KNOWN_NODETYPE_GUIDS[INDEX_GUID_CUSTOMRECOGNIZER      ])))

#endif //of #if !defined(__cplusplus)

#endif /* of #if !defined(_WISP_GUID) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Iads.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for ads.odl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __iads_h__
#define __iads_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IADs_FWD_DEFINED__
#define __IADs_FWD_DEFINED__
typedef interface IADs IADs;
#endif 	/* __IADs_FWD_DEFINED__ */


#ifndef __IADsContainer_FWD_DEFINED__
#define __IADsContainer_FWD_DEFINED__
typedef interface IADsContainer IADsContainer;
#endif 	/* __IADsContainer_FWD_DEFINED__ */


#ifndef __IADsCollection_FWD_DEFINED__
#define __IADsCollection_FWD_DEFINED__
typedef interface IADsCollection IADsCollection;
#endif 	/* __IADsCollection_FWD_DEFINED__ */


#ifndef __IADsMembers_FWD_DEFINED__
#define __IADsMembers_FWD_DEFINED__
typedef interface IADsMembers IADsMembers;
#endif 	/* __IADsMembers_FWD_DEFINED__ */


#ifndef __IADsPropertyList_FWD_DEFINED__
#define __IADsPropertyList_FWD_DEFINED__
typedef interface IADsPropertyList IADsPropertyList;
#endif 	/* __IADsPropertyList_FWD_DEFINED__ */


#ifndef __IADsPropertyEntry_FWD_DEFINED__
#define __IADsPropertyEntry_FWD_DEFINED__
typedef interface IADsPropertyEntry IADsPropertyEntry;
#endif 	/* __IADsPropertyEntry_FWD_DEFINED__ */


#ifndef __PropertyEntry_FWD_DEFINED__
#define __PropertyEntry_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropertyEntry PropertyEntry;
#else
typedef struct PropertyEntry PropertyEntry;
#endif /* __cplusplus */

#endif 	/* __PropertyEntry_FWD_DEFINED__ */


#ifndef __IADsPropertyValue_FWD_DEFINED__
#define __IADsPropertyValue_FWD_DEFINED__
typedef interface IADsPropertyValue IADsPropertyValue;
#endif 	/* __IADsPropertyValue_FWD_DEFINED__ */


#ifndef __IADsPropertyValue2_FWD_DEFINED__
#define __IADsPropertyValue2_FWD_DEFINED__
typedef interface IADsPropertyValue2 IADsPropertyValue2;
#endif 	/* __IADsPropertyValue2_FWD_DEFINED__ */


#ifndef __PropertyValue_FWD_DEFINED__
#define __PropertyValue_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropertyValue PropertyValue;
#else
typedef struct PropertyValue PropertyValue;
#endif /* __cplusplus */

#endif 	/* __PropertyValue_FWD_DEFINED__ */


#ifndef __IPrivateDispatch_FWD_DEFINED__
#define __IPrivateDispatch_FWD_DEFINED__
typedef interface IPrivateDispatch IPrivateDispatch;
#endif 	/* __IPrivateDispatch_FWD_DEFINED__ */


#ifndef __IPrivateUnknown_FWD_DEFINED__
#define __IPrivateUnknown_FWD_DEFINED__
typedef interface IPrivateUnknown IPrivateUnknown;
#endif 	/* __IPrivateUnknown_FWD_DEFINED__ */


#ifndef __IADsExtension_FWD_DEFINED__
#define __IADsExtension_FWD_DEFINED__
typedef interface IADsExtension IADsExtension;
#endif 	/* __IADsExtension_FWD_DEFINED__ */


#ifndef __IADsDeleteOps_FWD_DEFINED__
#define __IADsDeleteOps_FWD_DEFINED__
typedef interface IADsDeleteOps IADsDeleteOps;
#endif 	/* __IADsDeleteOps_FWD_DEFINED__ */


#ifndef __IADsNamespaces_FWD_DEFINED__
#define __IADsNamespaces_FWD_DEFINED__
typedef interface IADsNamespaces IADsNamespaces;
#endif 	/* __IADsNamespaces_FWD_DEFINED__ */


#ifndef __IADsClass_FWD_DEFINED__
#define __IADsClass_FWD_DEFINED__
typedef interface IADsClass IADsClass;
#endif 	/* __IADsClass_FWD_DEFINED__ */


#ifndef __IADsProperty_FWD_DEFINED__
#define __IADsProperty_FWD_DEFINED__
typedef interface IADsProperty IADsProperty;
#endif 	/* __IADsProperty_FWD_DEFINED__ */


#ifndef __IADsSyntax_FWD_DEFINED__
#define __IADsSyntax_FWD_DEFINED__
typedef interface IADsSyntax IADsSyntax;
#endif 	/* __IADsSyntax_FWD_DEFINED__ */


#ifndef __IADsLocality_FWD_DEFINED__
#define __IADsLocality_FWD_DEFINED__
typedef interface IADsLocality IADsLocality;
#endif 	/* __IADsLocality_FWD_DEFINED__ */


#ifndef __IADsO_FWD_DEFINED__
#define __IADsO_FWD_DEFINED__
typedef interface IADsO IADsO;
#endif 	/* __IADsO_FWD_DEFINED__ */


#ifndef __IADsOU_FWD_DEFINED__
#define __IADsOU_FWD_DEFINED__
typedef interface IADsOU IADsOU;
#endif 	/* __IADsOU_FWD_DEFINED__ */


#ifndef __IADsDomain_FWD_DEFINED__
#define __IADsDomain_FWD_DEFINED__
typedef interface IADsDomain IADsDomain;
#endif 	/* __IADsDomain_FWD_DEFINED__ */


#ifndef __IADsComputer_FWD_DEFINED__
#define __IADsComputer_FWD_DEFINED__
typedef interface IADsComputer IADsComputer;
#endif 	/* __IADsComputer_FWD_DEFINED__ */


#ifndef __IADsComputerOperations_FWD_DEFINED__
#define __IADsComputerOperations_FWD_DEFINED__
typedef interface IADsComputerOperations IADsComputerOperations;
#endif 	/* __IADsComputerOperations_FWD_DEFINED__ */


#ifndef __IADsGroup_FWD_DEFINED__
#define __IADsGroup_FWD_DEFINED__
typedef interface IADsGroup IADsGroup;
#endif 	/* __IADsGroup_FWD_DEFINED__ */


#ifndef __IADsUser_FWD_DEFINED__
#define __IADsUser_FWD_DEFINED__
typedef interface IADsUser IADsUser;
#endif 	/* __IADsUser_FWD_DEFINED__ */


#ifndef __IADsPrintQueue_FWD_DEFINED__
#define __IADsPrintQueue_FWD_DEFINED__
typedef interface IADsPrintQueue IADsPrintQueue;
#endif 	/* __IADsPrintQueue_FWD_DEFINED__ */


#ifndef __IADsPrintQueueOperations_FWD_DEFINED__
#define __IADsPrintQueueOperations_FWD_DEFINED__
typedef interface IADsPrintQueueOperations IADsPrintQueueOperations;
#endif 	/* __IADsPrintQueueOperations_FWD_DEFINED__ */


#ifndef __IADsPrintJob_FWD_DEFINED__
#define __IADsPrintJob_FWD_DEFINED__
typedef interface IADsPrintJob IADsPrintJob;
#endif 	/* __IADsPrintJob_FWD_DEFINED__ */


#ifndef __IADsPrintJobOperations_FWD_DEFINED__
#define __IADsPrintJobOperations_FWD_DEFINED__
typedef interface IADsPrintJobOperations IADsPrintJobOperations;
#endif 	/* __IADsPrintJobOperations_FWD_DEFINED__ */


#ifndef __IADsService_FWD_DEFINED__
#define __IADsService_FWD_DEFINED__
typedef interface IADsService IADsService;
#endif 	/* __IADsService_FWD_DEFINED__ */


#ifndef __IADsServiceOperations_FWD_DEFINED__
#define __IADsServiceOperations_FWD_DEFINED__
typedef interface IADsServiceOperations IADsServiceOperations;
#endif 	/* __IADsServiceOperations_FWD_DEFINED__ */


#ifndef __IADsFileService_FWD_DEFINED__
#define __IADsFileService_FWD_DEFINED__
typedef interface IADsFileService IADsFileService;
#endif 	/* __IADsFileService_FWD_DEFINED__ */


#ifndef __IADsFileServiceOperations_FWD_DEFINED__
#define __IADsFileServiceOperations_FWD_DEFINED__
typedef interface IADsFileServiceOperations IADsFileServiceOperations;
#endif 	/* __IADsFileServiceOperations_FWD_DEFINED__ */


#ifndef __IADsFileShare_FWD_DEFINED__
#define __IADsFileShare_FWD_DEFINED__
typedef interface IADsFileShare IADsFileShare;
#endif 	/* __IADsFileShare_FWD_DEFINED__ */


#ifndef __IADsSession_FWD_DEFINED__
#define __IADsSession_FWD_DEFINED__
typedef interface IADsSession IADsSession;
#endif 	/* __IADsSession_FWD_DEFINED__ */


#ifndef __IADsResource_FWD_DEFINED__
#define __IADsResource_FWD_DEFINED__
typedef interface IADsResource IADsResource;
#endif 	/* __IADsResource_FWD_DEFINED__ */


#ifndef __IADsOpenDSObject_FWD_DEFINED__
#define __IADsOpenDSObject_FWD_DEFINED__
typedef interface IADsOpenDSObject IADsOpenDSObject;
#endif 	/* __IADsOpenDSObject_FWD_DEFINED__ */


#ifndef __IDirectoryObject_FWD_DEFINED__
#define __IDirectoryObject_FWD_DEFINED__
typedef interface IDirectoryObject IDirectoryObject;
#endif 	/* __IDirectoryObject_FWD_DEFINED__ */


#ifndef __IDirectorySearch_FWD_DEFINED__
#define __IDirectorySearch_FWD_DEFINED__
typedef interface IDirectorySearch IDirectorySearch;
#endif 	/* __IDirectorySearch_FWD_DEFINED__ */


#ifndef __IDirectorySchemaMgmt_FWD_DEFINED__
#define __IDirectorySchemaMgmt_FWD_DEFINED__
typedef interface IDirectorySchemaMgmt IDirectorySchemaMgmt;
#endif 	/* __IDirectorySchemaMgmt_FWD_DEFINED__ */


#ifndef __IADsAggregatee_FWD_DEFINED__
#define __IADsAggregatee_FWD_DEFINED__
typedef interface IADsAggregatee IADsAggregatee;
#endif 	/* __IADsAggregatee_FWD_DEFINED__ */


#ifndef __IADsAggregator_FWD_DEFINED__
#define __IADsAggregator_FWD_DEFINED__
typedef interface IADsAggregator IADsAggregator;
#endif 	/* __IADsAggregator_FWD_DEFINED__ */


#ifndef __IADsAccessControlEntry_FWD_DEFINED__
#define __IADsAccessControlEntry_FWD_DEFINED__
typedef interface IADsAccessControlEntry IADsAccessControlEntry;
#endif 	/* __IADsAccessControlEntry_FWD_DEFINED__ */


#ifndef __AccessControlEntry_FWD_DEFINED__
#define __AccessControlEntry_FWD_DEFINED__

#ifdef __cplusplus
typedef class AccessControlEntry AccessControlEntry;
#else
typedef struct AccessControlEntry AccessControlEntry;
#endif /* __cplusplus */

#endif 	/* __AccessControlEntry_FWD_DEFINED__ */


#ifndef __IADsAccessControlList_FWD_DEFINED__
#define __IADsAccessControlList_FWD_DEFINED__
typedef interface IADsAccessControlList IADsAccessControlList;
#endif 	/* __IADsAccessControlList_FWD_DEFINED__ */


#ifndef __AccessControlList_FWD_DEFINED__
#define __AccessControlList_FWD_DEFINED__

#ifdef __cplusplus
typedef class AccessControlList AccessControlList;
#else
typedef struct AccessControlList AccessControlList;
#endif /* __cplusplus */

#endif 	/* __AccessControlList_FWD_DEFINED__ */


#ifndef __IADsSecurityDescriptor_FWD_DEFINED__
#define __IADsSecurityDescriptor_FWD_DEFINED__
typedef interface IADsSecurityDescriptor IADsSecurityDescriptor;
#endif 	/* __IADsSecurityDescriptor_FWD_DEFINED__ */


#ifndef __SecurityDescriptor_FWD_DEFINED__
#define __SecurityDescriptor_FWD_DEFINED__

#ifdef __cplusplus
typedef class SecurityDescriptor SecurityDescriptor;
#else
typedef struct SecurityDescriptor SecurityDescriptor;
#endif /* __cplusplus */

#endif 	/* __SecurityDescriptor_FWD_DEFINED__ */


#ifndef __IADsLargeInteger_FWD_DEFINED__
#define __IADsLargeInteger_FWD_DEFINED__
typedef interface IADsLargeInteger IADsLargeInteger;
#endif 	/* __IADsLargeInteger_FWD_DEFINED__ */


#ifndef __LargeInteger_FWD_DEFINED__
#define __LargeInteger_FWD_DEFINED__

#ifdef __cplusplus
typedef class LargeInteger LargeInteger;
#else
typedef struct LargeInteger LargeInteger;
#endif /* __cplusplus */

#endif 	/* __LargeInteger_FWD_DEFINED__ */


#ifndef __IADsNameTranslate_FWD_DEFINED__
#define __IADsNameTranslate_FWD_DEFINED__
typedef interface IADsNameTranslate IADsNameTranslate;
#endif 	/* __IADsNameTranslate_FWD_DEFINED__ */


#ifndef __NameTranslate_FWD_DEFINED__
#define __NameTranslate_FWD_DEFINED__

#ifdef __cplusplus
typedef class NameTranslate NameTranslate;
#else
typedef struct NameTranslate NameTranslate;
#endif /* __cplusplus */

#endif 	/* __NameTranslate_FWD_DEFINED__ */


#ifndef __IADsCaseIgnoreList_FWD_DEFINED__
#define __IADsCaseIgnoreList_FWD_DEFINED__
typedef interface IADsCaseIgnoreList IADsCaseIgnoreList;
#endif 	/* __IADsCaseIgnoreList_FWD_DEFINED__ */


#ifndef __CaseIgnoreList_FWD_DEFINED__
#define __CaseIgnoreList_FWD_DEFINED__

#ifdef __cplusplus
typedef class CaseIgnoreList CaseIgnoreList;
#else
typedef struct CaseIgnoreList CaseIgnoreList;
#endif /* __cplusplus */

#endif 	/* __CaseIgnoreList_FWD_DEFINED__ */


#ifndef __IADsFaxNumber_FWD_DEFINED__
#define __IADsFaxNumber_FWD_DEFINED__
typedef interface IADsFaxNumber IADsFaxNumber;
#endif 	/* __IADsFaxNumber_FWD_DEFINED__ */


#ifndef __FaxNumber_FWD_DEFINED__
#define __FaxNumber_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxNumber FaxNumber;
#else
typedef struct FaxNumber FaxNumber;
#endif /* __cplusplus */

#endif 	/* __FaxNumber_FWD_DEFINED__ */


#ifndef __IADsNetAddress_FWD_DEFINED__
#define __IADsNetAddress_FWD_DEFINED__
typedef interface IADsNetAddress IADsNetAddress;
#endif 	/* __IADsNetAddress_FWD_DEFINED__ */


#ifndef __NetAddress_FWD_DEFINED__
#define __NetAddress_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetAddress NetAddress;
#else
typedef struct NetAddress NetAddress;
#endif /* __cplusplus */

#endif 	/* __NetAddress_FWD_DEFINED__ */


#ifndef __IADsOctetList_FWD_DEFINED__
#define __IADsOctetList_FWD_DEFINED__
typedef interface IADsOctetList IADsOctetList;
#endif 	/* __IADsOctetList_FWD_DEFINED__ */


#ifndef __OctetList_FWD_DEFINED__
#define __OctetList_FWD_DEFINED__

#ifdef __cplusplus
typedef class OctetList OctetList;
#else
typedef struct OctetList OctetList;
#endif /* __cplusplus */

#endif 	/* __OctetList_FWD_DEFINED__ */


#ifndef __IADsEmail_FWD_DEFINED__
#define __IADsEmail_FWD_DEFINED__
typedef interface IADsEmail IADsEmail;
#endif 	/* __IADsEmail_FWD_DEFINED__ */


#ifndef __Email_FWD_DEFINED__
#define __Email_FWD_DEFINED__

#ifdef __cplusplus
typedef class Email Email;
#else
typedef struct Email Email;
#endif /* __cplusplus */

#endif 	/* __Email_FWD_DEFINED__ */


#ifndef __IADsPath_FWD_DEFINED__
#define __IADsPath_FWD_DEFINED__
typedef interface IADsPath IADsPath;
#endif 	/* __IADsPath_FWD_DEFINED__ */


#ifndef __Path_FWD_DEFINED__
#define __Path_FWD_DEFINED__

#ifdef __cplusplus
typedef class Path Path;
#else
typedef struct Path Path;
#endif /* __cplusplus */

#endif 	/* __Path_FWD_DEFINED__ */


#ifndef __IADsReplicaPointer_FWD_DEFINED__
#define __IADsReplicaPointer_FWD_DEFINED__
typedef interface IADsReplicaPointer IADsReplicaPointer;
#endif 	/* __IADsReplicaPointer_FWD_DEFINED__ */


#ifndef __ReplicaPointer_FWD_DEFINED__
#define __ReplicaPointer_FWD_DEFINED__

#ifdef __cplusplus
typedef class ReplicaPointer ReplicaPointer;
#else
typedef struct ReplicaPointer ReplicaPointer;
#endif /* __cplusplus */

#endif 	/* __ReplicaPointer_FWD_DEFINED__ */


#ifndef __IADsAcl_FWD_DEFINED__
#define __IADsAcl_FWD_DEFINED__
typedef interface IADsAcl IADsAcl;
#endif 	/* __IADsAcl_FWD_DEFINED__ */


#ifndef __IADsTimestamp_FWD_DEFINED__
#define __IADsTimestamp_FWD_DEFINED__
typedef interface IADsTimestamp IADsTimestamp;
#endif 	/* __IADsTimestamp_FWD_DEFINED__ */


#ifndef __Timestamp_FWD_DEFINED__
#define __Timestamp_FWD_DEFINED__

#ifdef __cplusplus
typedef class Timestamp Timestamp;
#else
typedef struct Timestamp Timestamp;
#endif /* __cplusplus */

#endif 	/* __Timestamp_FWD_DEFINED__ */


#ifndef __IADsPostalAddress_FWD_DEFINED__
#define __IADsPostalAddress_FWD_DEFINED__
typedef interface IADsPostalAddress IADsPostalAddress;
#endif 	/* __IADsPostalAddress_FWD_DEFINED__ */


#ifndef __PostalAddress_FWD_DEFINED__
#define __PostalAddress_FWD_DEFINED__

#ifdef __cplusplus
typedef class PostalAddress PostalAddress;
#else
typedef struct PostalAddress PostalAddress;
#endif /* __cplusplus */

#endif 	/* __PostalAddress_FWD_DEFINED__ */


#ifndef __IADsBackLink_FWD_DEFINED__
#define __IADsBackLink_FWD_DEFINED__
typedef interface IADsBackLink IADsBackLink;
#endif 	/* __IADsBackLink_FWD_DEFINED__ */


#ifndef __BackLink_FWD_DEFINED__
#define __BackLink_FWD_DEFINED__

#ifdef __cplusplus
typedef class BackLink BackLink;
#else
typedef struct BackLink BackLink;
#endif /* __cplusplus */

#endif 	/* __BackLink_FWD_DEFINED__ */


#ifndef __IADsTypedName_FWD_DEFINED__
#define __IADsTypedName_FWD_DEFINED__
typedef interface IADsTypedName IADsTypedName;
#endif 	/* __IADsTypedName_FWD_DEFINED__ */


#ifndef __TypedName_FWD_DEFINED__
#define __TypedName_FWD_DEFINED__

#ifdef __cplusplus
typedef class TypedName TypedName;
#else
typedef struct TypedName TypedName;
#endif /* __cplusplus */

#endif 	/* __TypedName_FWD_DEFINED__ */


#ifndef __IADsHold_FWD_DEFINED__
#define __IADsHold_FWD_DEFINED__
typedef interface IADsHold IADsHold;
#endif 	/* __IADsHold_FWD_DEFINED__ */


#ifndef __Hold_FWD_DEFINED__
#define __Hold_FWD_DEFINED__

#ifdef __cplusplus
typedef class Hold Hold;
#else
typedef struct Hold Hold;
#endif /* __cplusplus */

#endif 	/* __Hold_FWD_DEFINED__ */


#ifndef __IADsObjectOptions_FWD_DEFINED__
#define __IADsObjectOptions_FWD_DEFINED__
typedef interface IADsObjectOptions IADsObjectOptions;
#endif 	/* __IADsObjectOptions_FWD_DEFINED__ */


#ifndef __IADsPathname_FWD_DEFINED__
#define __IADsPathname_FWD_DEFINED__
typedef interface IADsPathname IADsPathname;
#endif 	/* __IADsPathname_FWD_DEFINED__ */


#ifndef __Pathname_FWD_DEFINED__
#define __Pathname_FWD_DEFINED__

#ifdef __cplusplus
typedef class Pathname Pathname;
#else
typedef struct Pathname Pathname;
#endif /* __cplusplus */

#endif 	/* __Pathname_FWD_DEFINED__ */


#ifndef __IADsADSystemInfo_FWD_DEFINED__
#define __IADsADSystemInfo_FWD_DEFINED__
typedef interface IADsADSystemInfo IADsADSystemInfo;
#endif 	/* __IADsADSystemInfo_FWD_DEFINED__ */


#ifndef __ADSystemInfo_FWD_DEFINED__
#define __ADSystemInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class ADSystemInfo ADSystemInfo;
#else
typedef struct ADSystemInfo ADSystemInfo;
#endif /* __cplusplus */

#endif 	/* __ADSystemInfo_FWD_DEFINED__ */


#ifndef __IADsWinNTSystemInfo_FWD_DEFINED__
#define __IADsWinNTSystemInfo_FWD_DEFINED__
typedef interface IADsWinNTSystemInfo IADsWinNTSystemInfo;
#endif 	/* __IADsWinNTSystemInfo_FWD_DEFINED__ */


#ifndef __WinNTSystemInfo_FWD_DEFINED__
#define __WinNTSystemInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class WinNTSystemInfo WinNTSystemInfo;
#else
typedef struct WinNTSystemInfo WinNTSystemInfo;
#endif /* __cplusplus */

#endif 	/* __WinNTSystemInfo_FWD_DEFINED__ */


#ifndef __IADsDNWithBinary_FWD_DEFINED__
#define __IADsDNWithBinary_FWD_DEFINED__
typedef interface IADsDNWithBinary IADsDNWithBinary;
#endif 	/* __IADsDNWithBinary_FWD_DEFINED__ */


#ifndef __DNWithBinary_FWD_DEFINED__
#define __DNWithBinary_FWD_DEFINED__

#ifdef __cplusplus
typedef class DNWithBinary DNWithBinary;
#else
typedef struct DNWithBinary DNWithBinary;
#endif /* __cplusplus */

#endif 	/* __DNWithBinary_FWD_DEFINED__ */


#ifndef __IADsDNWithString_FWD_DEFINED__
#define __IADsDNWithString_FWD_DEFINED__
typedef interface IADsDNWithString IADsDNWithString;
#endif 	/* __IADsDNWithString_FWD_DEFINED__ */


#ifndef __DNWithString_FWD_DEFINED__
#define __DNWithString_FWD_DEFINED__

#ifdef __cplusplus
typedef class DNWithString DNWithString;
#else
typedef struct DNWithString DNWithString;
#endif /* __cplusplus */

#endif 	/* __DNWithString_FWD_DEFINED__ */


#ifndef __IADsSecurityUtility_FWD_DEFINED__
#define __IADsSecurityUtility_FWD_DEFINED__
typedef interface IADsSecurityUtility IADsSecurityUtility;
#endif 	/* __IADsSecurityUtility_FWD_DEFINED__ */


#ifndef __ADsSecurityUtility_FWD_DEFINED__
#define __ADsSecurityUtility_FWD_DEFINED__

#ifdef __cplusplus
typedef class ADsSecurityUtility ADsSecurityUtility;
#else
typedef struct ADsSecurityUtility ADsSecurityUtility;
#endif /* __cplusplus */

#endif 	/* __ADsSecurityUtility_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __ActiveDs_LIBRARY_DEFINED__
#define __ActiveDs_LIBRARY_DEFINED__

/* library ActiveDs */
/* [helpstring][version][uuid] */ 

#pragma once
#pragma once
#pragma once
typedef /* [public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_ads_0000_0000_0001
    {	ADSTYPE_INVALID	= 0,
	ADSTYPE_DN_STRING	= ( ADSTYPE_INVALID + 1 ) ,
	ADSTYPE_CASE_EXACT_STRING	= ( ADSTYPE_DN_STRING + 1 ) ,
	ADSTYPE_CASE_IGNORE_STRING	= ( ADSTYPE_CASE_EXACT_STRING + 1 ) ,
	ADSTYPE_PRINTABLE_STRING	= ( ADSTYPE_CASE_IGNORE_STRING + 1 ) ,
	ADSTYPE_NUMERIC_STRING	= ( ADSTYPE_PRINTABLE_STRING + 1 ) ,
	ADSTYPE_BOOLEAN	= ( ADSTYPE_NUMERIC_STRING + 1 ) ,
	ADSTYPE_INTEGER	= ( ADSTYPE_BOOLEAN + 1 ) ,
	ADSTYPE_OCTET_STRING	= ( ADSTYPE_INTEGER + 1 ) ,
	ADSTYPE_UTC_TIME	= ( ADSTYPE_OCTET_STRING + 1 ) ,
	ADSTYPE_LARGE_INTEGER	= ( ADSTYPE_UTC_TIME + 1 ) ,
	ADSTYPE_PROV_SPECIFIC	= ( ADSTYPE_LARGE_INTEGER + 1 ) ,
	ADSTYPE_OBJECT_CLASS	= ( ADSTYPE_PROV_SPECIFIC + 1 ) ,
	ADSTYPE_CASEIGNORE_LIST	= ( ADSTYPE_OBJECT_CLASS + 1 ) ,
	ADSTYPE_OCTET_LIST	= ( ADSTYPE_CASEIGNORE_LIST + 1 ) ,
	ADSTYPE_PATH	= ( ADSTYPE_OCTET_LIST + 1 ) ,
	ADSTYPE_POSTALADDRESS	= ( ADSTYPE_PATH + 1 ) ,
	ADSTYPE_TIMESTAMP	= ( ADSTYPE_POSTALADDRESS + 1 ) ,
	ADSTYPE_BACKLINK	= ( ADSTYPE_TIMESTAMP + 1 ) ,
	ADSTYPE_TYPEDNAME	= ( ADSTYPE_BACKLINK + 1 ) ,
	ADSTYPE_HOLD	= ( ADSTYPE_TYPEDNAME + 1 ) ,
	ADSTYPE_NETADDRESS	= ( ADSTYPE_HOLD + 1 ) ,
	ADSTYPE_REPLICAPOINTER	= ( ADSTYPE_NETADDRESS + 1 ) ,
	ADSTYPE_FAXNUMBER	= ( ADSTYPE_REPLICAPOINTER + 1 ) ,
	ADSTYPE_EMAIL	= ( ADSTYPE_FAXNUMBER + 1 ) ,
	ADSTYPE_NT_SECURITY_DESCRIPTOR	= ( ADSTYPE_EMAIL + 1 ) ,
	ADSTYPE_UNKNOWN	= ( ADSTYPE_NT_SECURITY_DESCRIPTOR + 1 ) ,
	ADSTYPE_DN_WITH_BINARY	= ( ADSTYPE_UNKNOWN + 1 ) ,
	ADSTYPE_DN_WITH_STRING	= ( ADSTYPE_DN_WITH_BINARY + 1 ) 
    } 	ADSTYPEENUM;

typedef ADSTYPEENUM ADSTYPE;

typedef unsigned char BYTE;

typedef unsigned char *LPBYTE;

typedef unsigned char *PBYTE;

typedef LPWSTR ADS_DN_STRING;

typedef LPWSTR *PADS_DN_STRING;

typedef LPWSTR ADS_CASE_EXACT_STRING;

typedef LPWSTR *PADS_CASE_EXACT_STRING;

typedef LPWSTR ADS_CASE_IGNORE_STRING;

typedef LPWSTR *PADS_CASE_IGNORE_STRING;

typedef LPWSTR ADS_PRINTABLE_STRING;

typedef LPWSTR *PADS_PRINTABLE_STRING;

typedef LPWSTR ADS_NUMERIC_STRING;

typedef LPWSTR *PADS_NUMERIC_STRING;

typedef DWORD ADS_BOOLEAN;

typedef DWORD *LPNDS_BOOLEAN;

typedef DWORD ADS_INTEGER;

typedef DWORD *PADS_INTEGER;

typedef /* [public][public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0002
    {
    DWORD dwLength;
    LPBYTE lpValue;
    } 	ADS_OCTET_STRING;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0002 *PADS_OCTET_STRING;

typedef /* [public][public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0003
    {
    DWORD dwLength;
    LPBYTE lpValue;
    } 	ADS_NT_SECURITY_DESCRIPTOR;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0003 *PADS_NT_SECURITY_DESCRIPTOR;

typedef SYSTEMTIME ADS_UTC_TIME;

typedef SYSTEMTIME *PADS_UTC_TIME;

typedef LARGE_INTEGER ADS_LARGE_INTEGER;

typedef LARGE_INTEGER *PADS_LARGE_INTEGER;

typedef LPWSTR ADS_OBJECT_CLASS;

typedef LPWSTR *PADS_OBJECT_CLASS;

typedef /* [public][public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0004
    {
    DWORD dwLength;
    LPBYTE lpValue;
    } 	ADS_PROV_SPECIFIC;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0004 *PADS_PROV_SPECIFIC;

typedef struct _ADS_CASEIGNORE_LIST
    {
    struct _ADS_CASEIGNORE_LIST *Next;
    LPWSTR String;
    } 	ADS_CASEIGNORE_LIST;

typedef struct _ADS_CASEIGNORE_LIST *PADS_CASEIGNORE_LIST;

typedef struct _ADS_OCTET_LIST
    {
    struct _ADS_OCTET_LIST *Next;
    DWORD Length;
    BYTE *Data;
    } 	ADS_OCTET_LIST;

typedef struct _ADS_OCTET_LIST *PADS_OCTET_LIST;

typedef /* [public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0005
    {
    DWORD Type;
    LPWSTR VolumeName;
    LPWSTR Path;
    } 	ADS_PATH;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0005 *PADS_PATH;

typedef /* [public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0006
    {
    LPWSTR PostalAddress[ 6 ];
    } 	ADS_POSTALADDRESS;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0006 *PADS_POSTALADDRESS;

typedef /* [public][public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0007
    {
    DWORD WholeSeconds;
    DWORD EventID;
    } 	ADS_TIMESTAMP;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0007 *PADS_TIMESTAMP;

typedef /* [public][public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0008
    {
    DWORD RemoteID;
    LPWSTR ObjectName;
    } 	ADS_BACKLINK;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0008 *PADS_BACKLINK;

typedef /* [public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0009
    {
    LPWSTR ObjectName;
    DWORD Level;
    DWORD Interval;
    } 	ADS_TYPEDNAME;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0009 *PADS_TYPEDNAME;

typedef /* [public][public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0010
    {
    LPWSTR ObjectName;
    DWORD Amount;
    } 	ADS_HOLD;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0010 *PADS_HOLD;

typedef /* [public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0011
    {
    DWORD AddressType;
    DWORD AddressLength;
    BYTE *Address;
    } 	ADS_NETADDRESS;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0011 *PADS_NETADDRESS;

typedef /* [public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0012
    {
    LPWSTR ServerName;
    DWORD ReplicaType;
    DWORD ReplicaNumber;
    DWORD Count;
    PADS_NETADDRESS ReplicaAddressHints;
    } 	ADS_REPLICAPOINTER;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0012 *PADS_REPLICAPOINTER;

typedef /* [public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0013
    {
    LPWSTR TelephoneNumber;
    DWORD NumberOfBits;
    LPBYTE Parameters;
    } 	ADS_FAXNUMBER;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0013 *PADS_FAXNUMBER;

typedef /* [public][public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0014
    {
    LPWSTR Address;
    DWORD Type;
    } 	ADS_EMAIL;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0014 *PADS_EMAIL;

typedef /* [public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0015
    {
    DWORD dwLength;
    LPBYTE lpBinaryValue;
    LPWSTR pszDNString;
    } 	ADS_DN_WITH_BINARY;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0015 *PADS_DN_WITH_BINARY;

typedef /* [public] */ struct __MIDL___MIDL_itf_ads_0000_0000_0016
    {
    LPWSTR pszStringValue;
    LPWSTR pszDNString;
    } 	ADS_DN_WITH_STRING;

typedef struct __MIDL___MIDL_itf_ads_0000_0000_0016 *PADS_DN_WITH_STRING;

typedef struct _adsvalue
    {
    ADSTYPE dwType;
    union 
        {
        ADS_DN_STRING DNString;
        ADS_CASE_EXACT_STRING CaseExactString;
        ADS_CASE_IGNORE_STRING CaseIgnoreString;
        ADS_PRINTABLE_STRING PrintableString;
        ADS_NUMERIC_STRING NumericString;
        ADS_BOOLEAN Boolean;
        ADS_INTEGER Integer;
        ADS_OCTET_STRING OctetString;
        ADS_UTC_TIME UTCTime;
        ADS_LARGE_INTEGER LargeInteger;
        ADS_OBJECT_CLASS ClassName;
        ADS_PROV_SPECIFIC ProviderSpecific;
        PADS_CASEIGNORE_LIST pCaseIgnoreList;
        PADS_OCTET_LIST pOctetList;
        PADS_PATH pPath;
        PADS_POSTALADDRESS pPostalAddress;
        ADS_TIMESTAMP Timestamp;
        ADS_BACKLINK BackLink;
        PADS_TYPEDNAME pTypedName;
        ADS_HOLD Hold;
        PADS_NETADDRESS pNetAddress;
        PADS_REPLICAPOINTER pReplicaPointer;
        PADS_FAXNUMBER pFaxNumber;
        ADS_EMAIL Email;
        ADS_NT_SECURITY_DESCRIPTOR SecurityDescriptor;
        PADS_DN_WITH_BINARY pDNWithBinary;
        PADS_DN_WITH_STRING pDNWithString;
        } 	;
    } 	ADSVALUE;

typedef struct _adsvalue *PADSVALUE;

typedef struct _adsvalue *LPADSVALUE;

typedef struct _ads_attr_info
    {
    LPWSTR pszAttrName;
    DWORD dwControlCode;
    ADSTYPE dwADsType;
    PADSVALUE pADsValues;
    DWORD dwNumValues;
    } 	ADS_ATTR_INFO;

typedef struct _ads_attr_info *PADS_ATTR_INFO;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0000_0000_0018
    {	ADS_SECURE_AUTHENTICATION	= 0x1,
	ADS_USE_ENCRYPTION	= 0x2,
	ADS_USE_SSL	= 0x2,
	ADS_READONLY_SERVER	= 0x4,
	ADS_PROMPT_CREDENTIALS	= 0x8,
	ADS_NO_AUTHENTICATION	= 0x10,
	ADS_FAST_BIND	= 0x20,
	ADS_USE_SIGNING	= 0x40,
	ADS_USE_SEALING	= 0x80,
	ADS_USE_DELEGATION	= 0x100,
	ADS_SERVER_BIND	= 0x200,
	ADS_NO_REFERRAL_CHASING	= 0x400,
	ADS_AUTH_RESERVED	= 0x80000000
    } 	ADS_AUTHENTICATION_ENUM;

#define	ADS_ATTR_CLEAR	( 1 )

#define	ADS_ATTR_UPDATE	( 2 )

#define	ADS_ATTR_APPEND	( 3 )

#define	ADS_ATTR_DELETE	( 4 )

typedef struct _ads_object_info
    {
    LPWSTR pszRDN;
    LPWSTR pszObjectDN;
    LPWSTR pszParentDN;
    LPWSTR pszSchemaDN;
    LPWSTR pszClassName;
    } 	ADS_OBJECT_INFO;

typedef struct _ads_object_info *PADS_OBJECT_INFO;

typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_ads_0000_0000_0019
    {	ADS_STATUS_S_OK	= 0,
	ADS_STATUS_INVALID_SEARCHPREF	= ( ADS_STATUS_S_OK + 1 ) ,
	ADS_STATUS_INVALID_SEARCHPREFVALUE	= ( ADS_STATUS_INVALID_SEARCHPREF + 1 ) 
    } 	ADS_STATUSENUM;

typedef ADS_STATUSENUM ADS_STATUS;

typedef ADS_STATUSENUM *PADS_STATUS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0000_0000_0020
    {	ADS_DEREF_NEVER	= 0,
	ADS_DEREF_SEARCHING	= 1,
	ADS_DEREF_FINDING	= 2,
	ADS_DEREF_ALWAYS	= 3
    } 	ADS_DEREFENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0000_0000_0021
    {	ADS_SCOPE_BASE	= 0,
	ADS_SCOPE_ONELEVEL	= 1,
	ADS_SCOPE_SUBTREE	= 2
    } 	ADS_SCOPEENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0000_0000_0022
    {	ADSIPROP_ASYNCHRONOUS	= 0,
	ADSIPROP_DEREF_ALIASES	= 0x1,
	ADSIPROP_SIZE_LIMIT	= 0x2,
	ADSIPROP_TIME_LIMIT	= 0x3,
	ADSIPROP_ATTRIBTYPES_ONLY	= 0x4,
	ADSIPROP_SEARCH_SCOPE	= 0x5,
	ADSIPROP_TIMEOUT	= 0x6,
	ADSIPROP_PAGESIZE	= 0x7,
	ADSIPROP_PAGED_TIME_LIMIT	= 0x8,
	ADSIPROP_CHASE_REFERRALS	= 0x9,
	ADSIPROP_SORT_ON	= 0xa,
	ADSIPROP_CACHE_RESULTS	= 0xb,
	ADSIPROP_ADSIFLAG	= 0xc
    } 	ADS_PREFERENCES_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0000_0000_0023
    {	ADSI_DIALECT_LDAP	= 0,
	ADSI_DIALECT_SQL	= 0x1
    } 	ADSI_DIALECT_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0000_0000_0024
    {	ADS_CHASE_REFERRALS_NEVER	= 0,
	ADS_CHASE_REFERRALS_SUBORDINATE	= 0x20,
	ADS_CHASE_REFERRALS_EXTERNAL	= 0x40,
	ADS_CHASE_REFERRALS_ALWAYS	= ( ADS_CHASE_REFERRALS_SUBORDINATE | ADS_CHASE_REFERRALS_EXTERNAL ) 
    } 	ADS_CHASE_REFERRALS_ENUM;

typedef /* [public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_ads_0000_0000_0025
    {	ADS_SEARCHPREF_ASYNCHRONOUS	= 0,
	ADS_SEARCHPREF_DEREF_ALIASES	= ( ADS_SEARCHPREF_ASYNCHRONOUS + 1 ) ,
	ADS_SEARCHPREF_SIZE_LIMIT	= ( ADS_SEARCHPREF_DEREF_ALIASES + 1 ) ,
	ADS_SEARCHPREF_TIME_LIMIT	= ( ADS_SEARCHPREF_SIZE_LIMIT + 1 ) ,
	ADS_SEARCHPREF_ATTRIBTYPES_ONLY	= ( ADS_SEARCHPREF_TIME_LIMIT + 1 ) ,
	ADS_SEARCHPREF_SEARCH_SCOPE	= ( ADS_SEARCHPREF_ATTRIBTYPES_ONLY + 1 ) ,
	ADS_SEARCHPREF_TIMEOUT	= ( ADS_SEARCHPREF_SEARCH_SCOPE + 1 ) ,
	ADS_SEARCHPREF_PAGESIZE	= ( ADS_SEARCHPREF_TIMEOUT + 1 ) ,
	ADS_SEARCHPREF_PAGED_TIME_LIMIT	= ( ADS_SEARCHPREF_PAGESIZE + 1 ) ,
	ADS_SEARCHPREF_CHASE_REFERRALS	= ( ADS_SEARCHPREF_PAGED_TIME_LIMIT + 1 ) ,
	ADS_SEARCHPREF_SORT_ON	= ( ADS_SEARCHPREF_CHASE_REFERRALS + 1 ) ,
	ADS_SEARCHPREF_CACHE_RESULTS	= ( ADS_SEARCHPREF_SORT_ON + 1 ) ,
	ADS_SEARCHPREF_DIRSYNC	= ( ADS_SEARCHPREF_CACHE_RESULTS + 1 ) ,
	ADS_SEARCHPREF_TOMBSTONE	= ( ADS_SEARCHPREF_DIRSYNC + 1 ) ,
	ADS_SEARCHPREF_VLV	= ( ADS_SEARCHPREF_TOMBSTONE + 1 ) ,
	ADS_SEARCHPREF_ATTRIBUTE_QUERY	= ( ADS_SEARCHPREF_VLV + 1 ) ,
	ADS_SEARCHPREF_SECURITY_MASK	= ( ADS_SEARCHPREF_ATTRIBUTE_QUERY + 1 ) ,
	ADS_SEARCHPREF_DIRSYNC_FLAG	= ( ADS_SEARCHPREF_SECURITY_MASK + 1 ) ,
	ADS_SEARCHPREF_EXTENDED_DN	= ( ADS_SEARCHPREF_DIRSYNC_FLAG + 1 ) 
    } 	ADS_SEARCHPREF_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0000_0000_0026
    {	ADS_PASSWORD_ENCODE_REQUIRE_SSL	= 0,
	ADS_PASSWORD_ENCODE_CLEAR	= 1
    } 	ADS_PASSWORD_ENCODING_ENUM;

typedef ADS_SEARCHPREF_ENUM ADS_SEARCHPREF;

typedef struct ads_searchpref_info
    {
    ADS_SEARCHPREF dwSearchPref;
    ADSVALUE vValue;
    ADS_STATUS dwStatus;
    } 	ADS_SEARCHPREF_INFO;

typedef struct ads_searchpref_info *PADS_SEARCHPREF_INFO;

typedef struct ads_searchpref_info *LPADS_SEARCHPREF_INFO;

#define	ADS_DIRSYNC_COOKIE	( L"fc8cb04d-311d-406c-8cb9-1ae8b843b418" )

#define	ADS_VLV_RESPONSE	( L"fc8cb04d-311d-406c-8cb9-1ae8b843b419" )

typedef HANDLE ADS_SEARCH_HANDLE;

typedef HANDLE *PADS_SEARCH_HANDLE;

typedef struct ads_search_column
    {
    LPWSTR pszAttrName;
    ADSTYPE dwADsType;
    PADSVALUE pADsValues;
    DWORD dwNumValues;
    HANDLE hReserved;
    } 	ADS_SEARCH_COLUMN;

typedef struct ads_search_column *PADS_SEARCH_COLUMN;

typedef struct _ads_attr_def
    {
    LPWSTR pszAttrName;
    ADSTYPE dwADsType;
    DWORD dwMinRange;
    DWORD dwMaxRange;
    BOOL fMultiValued;
    } 	ADS_ATTR_DEF;

typedef struct _ads_attr_def *PADS_ATTR_DEF;

typedef struct _ads_class_def
    {
    LPWSTR pszClassName;
    DWORD dwMandatoryAttrs;
    LPWSTR *ppszMandatoryAttrs;
    DWORD optionalAttrs;
    LPWSTR **ppszOptionalAttrs;
    DWORD dwNamingAttrs;
    LPWSTR **ppszNamingAttrs;
    DWORD dwSuperClasses;
    LPWSTR **ppszSuperClasses;
    BOOL fIsContainer;
    } 	ADS_CLASS_DEF;

typedef struct _ads_class_def *PADS_CLASS_DEF;

typedef struct _ads_sortkey
    {
    LPWSTR pszAttrType;
    LPWSTR pszReserved;
    BOOLEAN fReverseorder;
    } 	ADS_SORTKEY;

typedef struct _ads_sortkey *PADS_SORTKEY;

typedef struct _ads_vlv
    {
    DWORD dwBeforeCount;
    DWORD dwAfterCount;
    DWORD dwOffset;
    DWORD dwContentCount;
    LPWSTR pszTarget;
    DWORD dwContextIDLength;
    LPBYTE lpContextID;
    } 	ADS_VLV;

typedef struct _ads_vlv *PADS_VLV;

#define	ADS_EXT_MINEXTDISPID	( 1 )

#define	ADS_EXT_MAXEXTDISPID	( 16777215 )

#define	ADS_EXT_INITCREDENTIALS	( 1 )

#define	ADS_EXT_INITIALIZE_COMPLETE	( 2 )

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0000_0000_0027
    {	ADS_PROPERTY_CLEAR	= 1,
	ADS_PROPERTY_UPDATE	= 2,
	ADS_PROPERTY_APPEND	= 3,
	ADS_PROPERTY_DELETE	= 4
    } 	ADS_PROPERTY_OPERATION_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0015_0001
    {	ADS_SYSTEMFLAG_DISALLOW_DELETE	= 0x80000000,
	ADS_SYSTEMFLAG_CONFIG_ALLOW_RENAME	= 0x40000000,
	ADS_SYSTEMFLAG_CONFIG_ALLOW_MOVE	= 0x20000000,
	ADS_SYSTEMFLAG_CONFIG_ALLOW_LIMITED_MOVE	= 0x10000000,
	ADS_SYSTEMFLAG_DOMAIN_DISALLOW_RENAME	= 0x8000000,
	ADS_SYSTEMFLAG_DOMAIN_DISALLOW_MOVE	= 0x4000000,
	ADS_SYSTEMFLAG_CR_NTDS_NC	= 0x1,
	ADS_SYSTEMFLAG_CR_NTDS_DOMAIN	= 0x2,
	ADS_SYSTEMFLAG_ATTR_NOT_REPLICATED	= 0x1,
	ADS_SYSTEMFLAG_ATTR_IS_CONSTRUCTED	= 0x4
    } 	ADS_SYSTEMFLAG_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0021_0001
    {	ADS_GROUP_TYPE_GLOBAL_GROUP	= 0x2,
	ADS_GROUP_TYPE_DOMAIN_LOCAL_GROUP	= 0x4,
	ADS_GROUP_TYPE_LOCAL_GROUP	= 0x4,
	ADS_GROUP_TYPE_UNIVERSAL_GROUP	= 0x8,
	ADS_GROUP_TYPE_SECURITY_ENABLED	= 0x80000000
    } 	ADS_GROUP_TYPE_ENUM;

typedef 
enum ADS_USER_FLAG
    {	ADS_UF_SCRIPT	= 0x1,
	ADS_UF_ACCOUNTDISABLE	= 0x2,
	ADS_UF_HOMEDIR_REQUIRED	= 0x8,
	ADS_UF_LOCKOUT	= 0x10,
	ADS_UF_PASSWD_NOTREQD	= 0x20,
	ADS_UF_PASSWD_CANT_CHANGE	= 0x40,
	ADS_UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED	= 0x80,
	ADS_UF_TEMP_DUPLICATE_ACCOUNT	= 0x100,
	ADS_UF_NORMAL_ACCOUNT	= 0x200,
	ADS_UF_INTERDOMAIN_TRUST_ACCOUNT	= 0x800,
	ADS_UF_WORKSTATION_TRUST_ACCOUNT	= 0x1000,
	ADS_UF_SERVER_TRUST_ACCOUNT	= 0x2000,
	ADS_UF_DONT_EXPIRE_PASSWD	= 0x10000,
	ADS_UF_MNS_LOGON_ACCOUNT	= 0x20000,
	ADS_UF_SMARTCARD_REQUIRED	= 0x40000,
	ADS_UF_TRUSTED_FOR_DELEGATION	= 0x80000,
	ADS_UF_NOT_DELEGATED	= 0x100000,
	ADS_UF_USE_DES_KEY_ONLY	= 0x200000,
	ADS_UF_DONT_REQUIRE_PREAUTH	= 0x400000,
	ADS_UF_PASSWORD_EXPIRED	= 0x800000,
	ADS_UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION	= 0x1000000
    } 	ADS_USER_FLAG_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0043_0001
    {	ADS_RIGHT_DELETE	= 0x10000,
	ADS_RIGHT_READ_CONTROL	= 0x20000,
	ADS_RIGHT_WRITE_DAC	= 0x40000,
	ADS_RIGHT_WRITE_OWNER	= 0x80000,
	ADS_RIGHT_SYNCHRONIZE	= 0x100000,
	ADS_RIGHT_ACCESS_SYSTEM_SECURITY	= 0x1000000,
	ADS_RIGHT_GENERIC_READ	= 0x80000000,
	ADS_RIGHT_GENERIC_WRITE	= 0x40000000,
	ADS_RIGHT_GENERIC_EXECUTE	= 0x20000000,
	ADS_RIGHT_GENERIC_ALL	= 0x10000000,
	ADS_RIGHT_DS_CREATE_CHILD	= 0x1,
	ADS_RIGHT_DS_DELETE_CHILD	= 0x2,
	ADS_RIGHT_ACTRL_DS_LIST	= 0x4,
	ADS_RIGHT_DS_SELF	= 0x8,
	ADS_RIGHT_DS_READ_PROP	= 0x10,
	ADS_RIGHT_DS_WRITE_PROP	= 0x20,
	ADS_RIGHT_DS_DELETE_TREE	= 0x40,
	ADS_RIGHT_DS_LIST_OBJECT	= 0x80,
	ADS_RIGHT_DS_CONTROL_ACCESS	= 0x100
    } 	ADS_RIGHTS_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0043_0002
    {	ADS_ACETYPE_ACCESS_ALLOWED	= 0,
	ADS_ACETYPE_ACCESS_DENIED	= 0x1,
	ADS_ACETYPE_SYSTEM_AUDIT	= 0x2,
	ADS_ACETYPE_ACCESS_ALLOWED_OBJECT	= 0x5,
	ADS_ACETYPE_ACCESS_DENIED_OBJECT	= 0x6,
	ADS_ACETYPE_SYSTEM_AUDIT_OBJECT	= 0x7,
	ADS_ACETYPE_SYSTEM_ALARM_OBJECT	= 0x8,
	ADS_ACETYPE_ACCESS_ALLOWED_CALLBACK	= 0x9,
	ADS_ACETYPE_ACCESS_DENIED_CALLBACK	= 0xa,
	ADS_ACETYPE_ACCESS_ALLOWED_CALLBACK_OBJECT	= 0xb,
	ADS_ACETYPE_ACCESS_DENIED_CALLBACK_OBJECT	= 0xc,
	ADS_ACETYPE_SYSTEM_AUDIT_CALLBACK	= 0xd,
	ADS_ACETYPE_SYSTEM_ALARM_CALLBACK	= 0xe,
	ADS_ACETYPE_SYSTEM_AUDIT_CALLBACK_OBJECT	= 0xf,
	ADS_ACETYPE_SYSTEM_ALARM_CALLBACK_OBJECT	= 0x10
    } 	ADS_ACETYPE_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0043_0003
    {	ADS_ACEFLAG_INHERIT_ACE	= 0x2,
	ADS_ACEFLAG_NO_PROPAGATE_INHERIT_ACE	= 0x4,
	ADS_ACEFLAG_INHERIT_ONLY_ACE	= 0x8,
	ADS_ACEFLAG_INHERITED_ACE	= 0x10,
	ADS_ACEFLAG_VALID_INHERIT_FLAGS	= 0x1f,
	ADS_ACEFLAG_SUCCESSFUL_ACCESS	= 0x40,
	ADS_ACEFLAG_FAILED_ACCESS	= 0x80
    } 	ADS_ACEFLAG_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0043_0004
    {	ADS_FLAG_OBJECT_TYPE_PRESENT	= 0x1,
	ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT	= 0x2
    } 	ADS_FLAGTYPE_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0043_0005
    {	ADS_SD_CONTROL_SE_OWNER_DEFAULTED	= 0x1,
	ADS_SD_CONTROL_SE_GROUP_DEFAULTED	= 0x2,
	ADS_SD_CONTROL_SE_DACL_PRESENT	= 0x4,
	ADS_SD_CONTROL_SE_DACL_DEFAULTED	= 0x8,
	ADS_SD_CONTROL_SE_SACL_PRESENT	= 0x10,
	ADS_SD_CONTROL_SE_SACL_DEFAULTED	= 0x20,
	ADS_SD_CONTROL_SE_DACL_AUTO_INHERIT_REQ	= 0x100,
	ADS_SD_CONTROL_SE_SACL_AUTO_INHERIT_REQ	= 0x200,
	ADS_SD_CONTROL_SE_DACL_AUTO_INHERITED	= 0x400,
	ADS_SD_CONTROL_SE_SACL_AUTO_INHERITED	= 0x800,
	ADS_SD_CONTROL_SE_DACL_PROTECTED	= 0x1000,
	ADS_SD_CONTROL_SE_SACL_PROTECTED	= 0x2000,
	ADS_SD_CONTROL_SE_SELF_RELATIVE	= 0x8000
    } 	ADS_SD_CONTROL_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0043_0006
    {	ADS_SD_REVISION_DS	= 4
    } 	ADS_SD_REVISION_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0044_0001
    {	ADS_NAME_TYPE_1779	= 1,
	ADS_NAME_TYPE_CANONICAL	= 2,
	ADS_NAME_TYPE_NT4	= 3,
	ADS_NAME_TYPE_DISPLAY	= 4,
	ADS_NAME_TYPE_DOMAIN_SIMPLE	= 5,
	ADS_NAME_TYPE_ENTERPRISE_SIMPLE	= 6,
	ADS_NAME_TYPE_GUID	= 7,
	ADS_NAME_TYPE_UNKNOWN	= 8,
	ADS_NAME_TYPE_USER_PRINCIPAL_NAME	= 9,
	ADS_NAME_TYPE_CANONICAL_EX	= 10,
	ADS_NAME_TYPE_SERVICE_PRINCIPAL_NAME	= 11,
	ADS_NAME_TYPE_SID_OR_SID_HISTORY_NAME	= 12
    } 	ADS_NAME_TYPE_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0044_0002
    {	ADS_NAME_INITTYPE_DOMAIN	= 1,
	ADS_NAME_INITTYPE_SERVER	= 2,
	ADS_NAME_INITTYPE_GC	= 3
    } 	ADS_NAME_INITTYPE_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0058_0001
    {	ADS_OPTION_SERVERNAME	= 0,
	ADS_OPTION_REFERRALS	= ( ADS_OPTION_SERVERNAME + 1 ) ,
	ADS_OPTION_PAGE_SIZE	= ( ADS_OPTION_REFERRALS + 1 ) ,
	ADS_OPTION_SECURITY_MASK	= ( ADS_OPTION_PAGE_SIZE + 1 ) ,
	ADS_OPTION_MUTUAL_AUTH_STATUS	= ( ADS_OPTION_SECURITY_MASK + 1 ) ,
	ADS_OPTION_QUOTA	= ( ADS_OPTION_MUTUAL_AUTH_STATUS + 1 ) ,
	ADS_OPTION_PASSWORD_PORTNUMBER	= ( ADS_OPTION_QUOTA + 1 ) ,
	ADS_OPTION_PASSWORD_METHOD	= ( ADS_OPTION_PASSWORD_PORTNUMBER + 1 ) ,
	ADS_OPTION_ACCUMULATIVE_MODIFICATION	= ( ADS_OPTION_PASSWORD_METHOD + 1 ) ,
	ADS_OPTION_SKIP_SID_LOOKUP	= ( ADS_OPTION_ACCUMULATIVE_MODIFICATION + 1 ) 
    } 	ADS_OPTION_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0058_0002
    {	ADS_SECURITY_INFO_OWNER	= 0x1,
	ADS_SECURITY_INFO_GROUP	= 0x2,
	ADS_SECURITY_INFO_DACL	= 0x4,
	ADS_SECURITY_INFO_SACL	= 0x8
    } 	ADS_SECURITY_INFO_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0059_0001
    {	ADS_SETTYPE_FULL	= 1,
	ADS_SETTYPE_PROVIDER	= 2,
	ADS_SETTYPE_SERVER	= 3,
	ADS_SETTYPE_DN	= 4
    } 	ADS_SETTYPE_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0059_0002
    {	ADS_FORMAT_WINDOWS	= 1,
	ADS_FORMAT_WINDOWS_NO_SERVER	= 2,
	ADS_FORMAT_WINDOWS_DN	= 3,
	ADS_FORMAT_WINDOWS_PARENT	= 4,
	ADS_FORMAT_X500	= 5,
	ADS_FORMAT_X500_NO_SERVER	= 6,
	ADS_FORMAT_X500_DN	= 7,
	ADS_FORMAT_X500_PARENT	= 8,
	ADS_FORMAT_SERVER	= 9,
	ADS_FORMAT_PROVIDER	= 10,
	ADS_FORMAT_LEAF	= 11
    } 	ADS_FORMAT_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0059_0003
    {	ADS_DISPLAY_FULL	= 1,
	ADS_DISPLAY_VALUE_ONLY	= 2
    } 	ADS_DISPLAY_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0059_0004
    {	ADS_ESCAPEDMODE_DEFAULT	= 1,
	ADS_ESCAPEDMODE_ON	= 2,
	ADS_ESCAPEDMODE_OFF	= 3,
	ADS_ESCAPEDMODE_OFF_EX	= 4
    } 	ADS_ESCAPE_MODE_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0064_0001
    {	ADS_PATH_FILE	= 1,
	ADS_PATH_FILESHARE	= 2,
	ADS_PATH_REGISTRY	= 3
    } 	ADS_PATHTYPE_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_ads_0001_0064_0002
    {	ADS_SD_FORMAT_IID	= 1,
	ADS_SD_FORMAT_RAW	= 2,
	ADS_SD_FORMAT_HEXSTRING	= 3
    } 	ADS_SD_FORMAT_ENUM;


EXTERN_C const IID LIBID_ActiveDs;

#ifndef __IADs_INTERFACE_DEFINED__
#define __IADs_INTERFACE_DEFINED__

/* interface IADs */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fd8256d0-fd15-11ce-abc4-02608c9e7553")
    IADs : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GUID( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ADsPath( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Schema( 
            /* [retval][out] */ BSTR *retval) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetInfo( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetInfo( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEx( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutEx( 
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetInfoEx( 
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADs * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADs * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IADs * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IADs * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IADs * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IADs * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            IADs * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schema )( 
            IADs * This,
            /* [retval][out] */ BSTR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IADs * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            IADs * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IADs * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IADs * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IADs * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IADs * This,
            /* [in] */ long lnControlCode,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vProp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetInfoEx )( 
            IADs * This,
            /* [in] */ VARIANT vProperties,
            /* [in] */ long lnReserved);
        
        END_INTERFACE
    } IADsVtbl;

    interface IADs
    {
        CONST_VTBL struct IADsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IADs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IADs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IADs_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IADs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IADs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IADs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IADs_get_Name(This,retval)	\
    ( (This)->lpVtbl -> get_Name(This,retval) ) 

#define IADs_get_Class(This,retval)	\
    ( (This)->lpVtbl -> get_Class(This,retval) ) 

#define IADs_get_GUID(This,retval)	\
    ( (This)->lpVtbl -> get_GUID(This,retval) ) 

#define IADs_get_ADsPath(This,retval)	\
    ( (This)->lpVtbl -> get_ADsPath(This,retval) ) 

#define IADs_get_Parent(This,retval)	\
    ( (This)->lpVtbl -> get_Parent(This,retval) ) 

#define IADs_get_Schema(This,retval)	\
    ( (This)->lpVtbl -> get_Schema(This,retval) ) 

#define IADs_GetInfo(This)	\
    ( (This)->lpVtbl -> GetInfo(This) ) 

#define IADs_SetInfo(This)	\
    ( (This)->lpVtbl -> SetInfo(This) ) 

#define IADs_Get(This,bstrName,pvProp)	\
    ( (This)->lpVtbl -> Get(This,bstrName,pvProp) ) 

#define IADs_Put(This,bstrName,vProp)	\
    ( (This)->lpVtbl -> Put(This,bstrName,vProp) ) 

#define IADs_GetEx(This,bstrName,pvProp)	\
    ( (This)->lpVtbl -> GetEx(This,bstrName,pvProp) ) 

#define IADs_PutEx(This,lnControlCode,bstrName,vProp)	\
    ( (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp) ) 

#define IADs_GetInfoEx(This,vProperties,lnReserved)	\
    ( (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IADs_INTERFACE_DEFINED__ */


#ifndef __IADsContainer_INTERFACE_DEFINED__
#define __IADsContainer_INTERFACE_DEFINED__

/* interface IADsContainer */
/* [object][dual][oleautomation][uuid] */ 


EXTERN_C const IID IID_IADsContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("001677d0-fd16-11ce-abc4-02608c9e7553")
    IADsContainer : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *retval) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Filter( 
            /* [retval][out] */ VARIANT *pVar) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Filter( 
            /* [in] */ VARIANT Var) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Hints( 
            /* [retval][out] */ VARIANT *pvFilter) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Hints( 
            /* [in] */ VARIANT vHints) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR ClassName,
            /* [in] */ BSTR RelativeName,
            /* [retval][out] */ IDispatch **ppObject) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ BSTR ClassName,
            /* [in] */ BSTR RelativeName,
            /* [retval][out] */ IDispatch **ppObject) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ BSTR bstrClassName,
            /* [in] */ BSTR bstrRelativeName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CopyHere( 
            /* [in] */ BSTR SourceName,
            /* [in] */ BSTR NewName,
            /* [out][retval] */ IDispatch **ppObject) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveHere( 
            /* [in] */ BSTR SourceName,
            /* [in] */ BSTR NewName,
            /* [out][retval] */ IDispatch **ppObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsContainer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADsContainer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADsContainer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADsContainer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADsContainer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IADsContainer * This,
            /* [retval][out] */ long *retval);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IADsContainer * This,
            /* [retval][out] */ IUnknown **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filter )( 
            IADsContainer * This,
            /* [retval][out] */ VARIANT *pVar);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Filter )( 
            IADsContainer * This,
            /* [in] */ VARIANT Var);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Hints )( 
            IADsContainer * This,
            /* [retval][out] */ VARIANT *pvFilter);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Hints )( 
            IADsContainer * This,
            /* [in] */ VARIANT vHints);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IADsContainer * This,
            /* [in] */ BSTR ClassName,
            /* [in] */ BSTR RelativeName,
            /* [retval][out] */ IDispatch **ppObject);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Create )( 
            IADsContainer * This,
            /* [in] */ BSTR ClassName,
            /* [in] */ BSTR RelativeName,
            /* [retval][out] */ IDispatch **ppObject);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IADsContainer * This,
            /* [in] */ BSTR bstrClassName,
            /* [in] */ BSTR bstrRelativeName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *CopyHere )( 
            IADsContainer * This,
            /* [in] */ BSTR SourceName,
            /* [in] */ BSTR NewName,
            /* [out][retval] */ IDispatch **ppObject);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *MoveHere )( 
            IADsContainer * This,
            /* [in] */ BSTR SourceName,
            /* [in] */ BSTR NewName,
            /* [out][retval] */ IDispatch **ppObject);
        
        END_INTERFACE
    } IADsContainerVtbl;

    interface IADsContainer
    {
        CONST_VTBL struct IADsContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IADsContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IADsContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IADsContainer_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IADsContainer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IADsContainer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IADsContainer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IADsContainer_get_Count(This,retval)	\
    ( (This)->lpVtbl -> 