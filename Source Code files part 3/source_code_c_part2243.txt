r allocated buffer.
// dwRegFlags determines how registry is accessed (see above).
// dwFlags determine which registry policies are accessed (see above).
// Returns S_OK if action is valid; ??? if action is not valid.

EXTERN_C const IID IID_IInternetZoneManagerEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A4C23339-8E06-431e-9BF4-7E711C085648")
    IInternetZoneManagerEx : public IInternetZoneManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetZoneActionPolicyEx( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneActionPolicyEx( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetZoneManagerExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetZoneManagerEx * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetZoneManagerEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetZoneManagerEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributes )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneAttributes )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneCustomPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneCustomPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *PromptAction )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LogAction )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateZoneEnumerator )( 
            IInternetZoneManagerEx * This,
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAt )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyZoneEnumerator )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CopyTemplatePoliciesToZone )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicyEx )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicyEx )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IInternetZoneManagerExVtbl;

    interface IInternetZoneManagerEx
    {
        CONST_VTBL struct IInternetZoneManagerExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetZoneManagerEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetZoneManagerEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetZoneManagerEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetZoneManagerEx_GetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> GetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx_SetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> SetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)	\
    ( (This)->lpVtbl -> PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) ) 

#define IInternetZoneManagerEx_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)	\
    ( (This)->lpVtbl -> LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) ) 

#define IInternetZoneManagerEx_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)	\
    ( (This)->lpVtbl -> CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) ) 

#define IInternetZoneManagerEx_GetZoneAt(This,dwEnum,dwIndex,pdwZone)	\
    ( (This)->lpVtbl -> GetZoneAt(This,dwEnum,dwIndex,pdwZone) ) 

#define IInternetZoneManagerEx_DestroyZoneEnumerator(This,dwEnum)	\
    ( (This)->lpVtbl -> DestroyZoneEnumerator(This,dwEnum) ) 

#define IInternetZoneManagerEx_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)	\
    ( (This)->lpVtbl -> CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) ) 


#define IInternetZoneManagerEx_GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 

#define IInternetZoneManagerEx_SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetZoneManagerEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0044 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPINTERNETZONEMANAGEREX2_DEFINED
#define _LPINTERNETZONEMANAGEREX2_DEFINED
#define SECURITY_IE_STATE_GREEN 0x00000000
#define SECURITY_IE_STATE_RED   0x00000001


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0044_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0044_v0_0_s_ifspec;

#ifndef __IInternetZoneManagerEx2_INTERFACE_DEFINED__
#define __IInternetZoneManagerEx2_INTERFACE_DEFINED__

/* interface IInternetZoneManagerEx2 */
/* [unique][helpstring][uuid][object][local] */ 

// Gets the zone attributes (information in registry other than actual security
// policies associated with the zone).  Zone attributes are fixed as:
// Can also verify template settings by matching current settings with security template

EXTERN_C const IID IID_IInternetZoneManagerEx2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EDC17559-DD5D-4846-8EEF-8BECBA5A4ABF")
    IInternetZoneManagerEx2 : public IInternetZoneManagerEx
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetZoneAttributesEx( 
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneSecurityState( 
            /* [in] */ DWORD dwZoneIndex,
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIESecurityState( 
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered,
            /* [in] */ BOOL fNoCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FixUnsecureSettings( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetZoneManagerEx2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetZoneManagerEx2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetZoneManagerEx2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributes )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneAttributes )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneCustomPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneCustomPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *PromptAction )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LogAction )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateZoneEnumerator )( 
            IInternetZoneManagerEx2 * This,
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAt )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyZoneEnumerator )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CopyTemplatePoliciesToZone )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicyEx )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicyEx )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributesEx )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneSecurityState )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZoneIndex,
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered);
        
        HRESULT ( STDMETHODCALLTYPE *GetIESecurityState )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered,
            /* [in] */ BOOL fNoCache);
        
        HRESULT ( STDMETHODCALLTYPE *FixUnsecureSettings )( 
            IInternetZoneManagerEx2 * This);
        
        END_INTERFACE
    } IInternetZoneManagerEx2Vtbl;

    interface IInternetZoneManagerEx2
    {
        CONST_VTBL struct IInternetZoneManagerEx2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetZoneManagerEx2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetZoneManagerEx2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetZoneManagerEx2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetZoneManagerEx2_GetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> GetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx2_SetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> SetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx2_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)	\
    ( (This)->lpVtbl -> PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) ) 

#define IInternetZoneManagerEx2_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)	\
    ( (This)->lpVtbl -> LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) ) 

#define IInternetZoneManagerEx2_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)	\
    ( (This)->lpVtbl -> CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) ) 

#define IInternetZoneManagerEx2_GetZoneAt(This,dwEnum,dwIndex,pdwZone)	\
    ( (This)->lpVtbl -> GetZoneAt(This,dwEnum,dwIndex,pdwZone) ) 

#define IInternetZoneManagerEx2_DestroyZoneEnumerator(This,dwEnum)	\
    ( (This)->lpVtbl -> DestroyZoneEnumerator(This,dwEnum) ) 

#define IInternetZoneManagerEx2_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)	\
    ( (This)->lpVtbl -> CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) ) 


#define IInternetZoneManagerEx2_GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 

#define IInternetZoneManagerEx2_SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 


#define IInternetZoneManagerEx2_GetZoneAttributesEx(This,dwZone,pZoneAttributes,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneAttributesEx(This,dwZone,pZoneAttributes,dwFlags) ) 

#define IInternetZoneManagerEx2_GetZoneSecurityState(This,dwZoneIndex,fRespectPolicy,pdwState,pfPolicyEncountered)	\
    ( (This)->lpVtbl -> GetZoneSecurityState(This,dwZoneIndex,fRespectPolicy,pdwState,pfPolicyEncountered) ) 

#define IInternetZoneManagerEx2_GetIESecurityState(This,fRespectPolicy,pdwState,pfPolicyEncountered,fNoCache)	\
    ( (This)->lpVtbl -> GetIESecurityState(This,fRespectPolicy,pdwState,pfPolicyEncountered,fNoCache) ) 

#define IInternetZoneManagerEx2_FixUnsecureSettings(This)	\
    ( (This)->lpVtbl -> FixUnsecureSettings(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetZoneManagerEx2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0045 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
EXTERN_C const IID CLSID_SoftDistExt;  
#ifndef _LPSOFTDISTEXT_DEFINED
#define _LPSOFTDISTEXT_DEFINED

#define SOFTDIST_FLAG_USAGE_EMAIL        0x00000001
#define SOFTDIST_FLAG_USAGE_PRECACHE     0x00000002
#define SOFTDIST_FLAG_USAGE_AUTOINSTALL  0x00000004
#define SOFTDIST_FLAG_DELETE_SUBSCRIPTION 0x00000008


#define SOFTDIST_ADSTATE_NONE                0x00000000
#define SOFTDIST_ADSTATE_AVAILABLE       0x00000001
#define SOFTDIST_ADSTATE_DOWNLOADED      0x00000002
#define SOFTDIST_ADSTATE_INSTALLED           0x00000003

typedef struct _tagCODEBASEHOLD
    {
    ULONG cbSize;
    LPWSTR szDistUnit;
    LPWSTR szCodeBase;
    DWORD dwVersionMS;
    DWORD dwVersionLS;
    DWORD dwStyle;
    } 	CODEBASEHOLD;

typedef struct _tagCODEBASEHOLD *LPCODEBASEHOLD;

typedef struct _tagSOFTDISTINFO
    {
    ULONG cbSize;
    DWORD dwFlags;
    DWORD dwAdState;
    LPWSTR szTitle;
    LPWSTR szAbstract;
    LPWSTR szHREF;
    DWORD dwInstalledVersionMS;
    DWORD dwInstalledVersionLS;
    DWORD dwUpdateVersionMS;
    DWORD dwUpdateVersionLS;
    DWORD dwAdvertisedVersionMS;
    DWORD dwAdvertisedVersionLS;
    DWORD dwReserved;
    } 	SOFTDISTINFO;

typedef struct _tagSOFTDISTINFO *LPSOFTDISTINFO;



extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0045_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0045_v0_0_s_ifspec;

#ifndef __ISoftDistExt_INTERFACE_DEFINED__
#define __ISoftDistExt_INTERFACE_DEFINED__

/* interface ISoftDistExt */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_ISoftDistExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B15B8DC1-C7E1-11d0-8680-00AA00BDCB71")
    ISoftDistExt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessSoftDist( 
            /* [in] */ LPCWSTR szCDFURL,
            /* [in] */ IXMLElement *pSoftDistElement,
            /* [out][in] */ LPSOFTDISTINFO lpsdi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstCodeBase( 
            /* [annotation][in] */ 
            __RPC__in  LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextCodeBase( 
            /* [annotation][in] */ 
            __RPC__in  LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsyncInstallDistributionUnit( 
            /* [in] */ IBindCtx *pbc,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD flags,
            /* [in] */ LPCODEBASEHOLD lpcbh) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftDistExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftDistExt * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftDistExt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftDistExt * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessSoftDist )( 
            ISoftDistExt * This,
            /* [in] */ LPCWSTR szCDFURL,
            /* [in] */ IXMLElement *pSoftDistElement,
            /* [out][in] */ LPSOFTDISTINFO lpsdi);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstCodeBase )( 
            ISoftDistExt * This,
            /* [annotation][in] */ 
            __RPC__in  LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextCodeBase )( 
            ISoftDistExt * This,
            /* [annotation][in] */ 
            __RPC__in  LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *AsyncInstallDistributionUnit )( 
            ISoftDistExt * This,
            /* [in] */ IBindCtx *pbc,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD flags,
            /* [in] */ LPCODEBASEHOLD lpcbh);
        
        END_INTERFACE
    } ISoftDistExtVtbl;

    interface ISoftDistExt
    {
        CONST_VTBL struct ISoftDistExtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftDistExt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftDistExt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftDistExt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftDistExt_ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi)	\
    ( (This)->lpVtbl -> ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi) ) 

#define ISoftDistExt_GetFirstCodeBase(This,szCodeBase,dwMaxSize)	\
    ( (This)->lpVtbl -> GetFirstCodeBase(This,szCodeBase,dwMaxSize) ) 

#define ISoftDistExt_GetNextCodeBase(This,szCodeBase,dwMaxSize)	\
    ( (This)->lpVtbl -> GetNextCodeBase(This,szCodeBase,dwMaxSize) ) 

#define ISoftDistExt_AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh)	\
    ( (This)->lpVtbl -> AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftDistExt_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0046 */
/* [local] */ 

STDAPI GetSoftwareUpdateInfo( LPCWSTR szDistUnit, LPSOFTDISTINFO psdi );
STDAPI SetSoftwareUpdateAdvertisementState( LPCWSTR szDistUnit, DWORD dwAdState, DWORD dwAdvertisedVersionMS, DWORD dwAdvertisedVersionLS );
#endif
#ifndef _LPCATALOGFILEINFO_DEFINED
#define _LPCATALOGFILEINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0046_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0046_v0_0_s_ifspec;

#ifndef __ICatalogFileInfo_INTERFACE_DEFINED__
#define __ICatalogFileInfo_INTERFACE_DEFINED__

/* interface ICatalogFileInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ ICatalogFileInfo *LPCATALOGFILEINFO;


EXTERN_C const IID IID_ICatalogFileInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("711C7600-6B48-11d1-B403-00AA00B92AF1")
    ICatalogFileInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCatalogFile( 
            /* [annotation][out] */ 
            __RPC__out  LPSTR *ppszCatalogFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJavaTrust( 
            /* [out] */ void **ppJavaTrust) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogFileInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatalogFileInfo * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatalogFileInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatalogFileInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogFile )( 
            ICatalogFileInfo * This,
            /* [annotation][out] */ 
            __RPC__out  LPSTR *ppszCatalogFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetJavaTrust )( 
            ICatalogFileInfo * This,
            /* [out] */ void **ppJavaTrust);
        
        END_INTERFACE
    } ICatalogFileInfoVtbl;

    interface ICatalogFileInfo
    {
        CONST_VTBL struct ICatalogFileInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogFileInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICatalogFileInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICatalogFileInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICatalogFileInfo_GetCatalogFile(This,ppszCatalogFile)	\
    ( (This)->lpVtbl -> GetCatalogFile(This,ppszCatalogFile) ) 

#define ICatalogFileInfo_GetJavaTrust(This,ppJavaTrust)	\
    ( (This)->lpVtbl -> GetJavaTrust(This,ppJavaTrust) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICatalogFileInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0047 */
/* [local] */ 

#endif
#ifndef _LPDATAFILTER_DEFINED
#define _LPDATAFILTER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0047_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0047_v0_0_s_ifspec;

#ifndef __IDataFilter_INTERFACE_DEFINED__
#define __IDataFilter_INTERFACE_DEFINED__

/* interface IDataFilter */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IDataFilter *LPDATAFILTER;


EXTERN_C const IID IID_IDataFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69d14c80-c18e-11d0-a9ce-006097942311")
    IDataFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoEncode( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(lInBufferSize) BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(lOutBufferSize) BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ __RPC__out LONG *plInBytesRead,
            /* [out] */ __RPC__out LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoDecode( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(lInBufferSize) BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(lOutBufferSize) BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ __RPC__out LONG *plInBytesRead,
            /* [out] */ __RPC__out LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEncodingLevel( 
            /* [in] */ DWORD dwEncLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDataFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDataFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDataFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoEncode )( 
            __RPC__in IDataFilter * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(lInBufferSize) BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(lOutBufferSize) BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ __RPC__out LONG *plInBytesRead,
            /* [out] */ __RPC__out LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *DoDecode )( 
            __RPC__in IDataFilter * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(lInBufferSize) BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(lOutBufferSize) BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ __RPC__out LONG *plInBytesRead,
            /* [out] */ __RPC__out LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetEncodingLevel )( 
            __RPC__in IDataFilter * This,
            /* [in] */ DWORD dwEncLevel);
        
        END_INTERFACE
    } IDataFilterVtbl;

    interface IDataFilter
    {
        CONST_VTBL struct IDataFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataFilter_DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)	\
    ( (This)->lpVtbl -> DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved) ) 

#define IDataFilter_DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)	\
    ( (This)->lpVtbl -> DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved) ) 

#define IDataFilter_SetEncodingLevel(This,dwEncLevel)	\
    ( (This)->lpVtbl -> SetEncodingLevel(This,dwEncLevel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0048 */
/* [local] */ 

#endif
#ifndef _LPENCODINGFILTERFACTORY_DEFINED
#define _LPENCODINGFILTERFACTORY_DEFINED
typedef struct _tagPROTOCOLFILTERDATA
    {
    DWORD cbSize;
    IInternetProtocolSink *pProtocolSink;
    IInternetProtocol *pProtocol;
    IUnknown *pUnk;
    DWORD dwFilterFlags;
    } 	PROTOCOLFILTERDATA;



extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0048_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0048_v0_0_s_ifspec;

#ifndef __IEncodingFilterFactory_INTERFACE_DEFINED__
#define __IEncodingFilterFactory_INTERFACE_DEFINED__

/* interface IEncodingFilterFactory */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IEncodingFilterFactory *LPENCODINGFILTERFACTORY;

typedef struct _tagDATAINFO
    {
    ULONG ulTotalSize;
    ULONG ulavrPacketSize;
    ULONG ulConnectSpeed;
    ULONG ulProcessorSpeed;
    } 	DATAINFO;


EXTERN_C const IID IID_IEncodingFilterFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70bdde00-c18e-11d0-a9ce-006097942311")
    IEncodingFilterFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindBestFilter( 
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [in] */ DATAINFO info,
            /* [out] */ IDataFilter **ppDF) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultFilter( 
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [out] */ IDataFilter **ppDF) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEncodingFilterFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEncodingFilterFactory * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEncodingFilterFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEncodingFilterFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindBestFilter )( 
            IEncodingFilterFactory * This,
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [in] */ DATAINFO info,
            /* [out] */ IDataFilter **ppDF);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultFilter )( 
            IEncodingFilterFactory * This,
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [out] */ IDataFilter **ppDF);
        
        END_INTERFACE
    } IEncodingFilterFactoryVtbl;

    interface IEncodingFilterFactory
    {
        CONST_VTBL struct IEncodingFilterFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEncodingFilterFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEncodingFilterFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEncodingFilterFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEncodingFilterFactory_FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF)	\
    ( (This)->lpVtbl -> FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF) ) 

#define IEncodingFilterFactory_GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF)	\
    ( (This)->lpVtbl -> GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEncodingFilterFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0049 */
/* [local] */ 

#endif
#ifndef _HITLOGGING_DEFINED
#define _HITLOGGING_DEFINED
// Logging-specific apis
BOOL WINAPI IsLoggingEnabledA(__in LPCSTR  pszUrl);                    
BOOL WINAPI IsLoggingEnabledW(__in LPCWSTR  pwszUrl);                  
#ifdef UNICODE                                                       
#define IsLoggingEnabled         IsLoggingEnabledW                   
#else                                                                
#define IsLoggingEnabled         IsLoggingEnabledA                   
#endif // !UNICODE                                                   
typedef struct _tagHIT_LOGGING_INFO
    {
    DWORD dwStructSize;
    LPSTR lpszLoggedUrlName;
    SYSTEMTIME StartTime;
    SYSTEMTIME EndTime;
    LPSTR lpszExtendedInfo;
    } 	HIT_LOGGING_INFO;

typedef struct _tagHIT_LOGGING_INFO *LPHIT_LOGGING_INFO;

BOOL WINAPI WriteHitLogging(__in LPHIT_LOGGING_INFO lpLogginginfo);    
#define CONFIRMSAFETYACTION_LOADOBJECT  0x00000001
struct CONFIRMSAFETY
    {
    CLSID clsid;
    IUnknown *pUnk;
    DWORD dwFlags;
    } ;
EXTERN_C const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY; 
#endif
#ifndef _LPIWRAPPEDPROTOCOL_DEFINED
#define _LPIWRAPPEDPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0049_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0049_v0_0_s_ifspec;

#ifndef __IWrappedProtocol_INTERFACE_DEFINED__
#define __IWrappedProtocol_INTERFACE_DEFINED__

/* interface IWrappedProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWrappedProtocol *LPIWRAPPEDPROTOCOL;


EXTERN_C const IID IID_IWrappedProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53c84785-8425-4dc5-971b-e58d9c19f9b6")
    IWrappedProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWrapperCode( 
            /* [out] */ LONG *pnCode,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWrappedProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWrappedProtocol * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWrappedProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWrappedProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWrapperCode )( 
            IWrappedProtocol * This,
            /* [out] */ LONG *pnCode,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IWrappedProtocolVtbl;

    interface IWrappedProtocol
    {
        CONST_VTBL struct IWrappedProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWrappedProtocol_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWrappedProtocol_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWrappedProtocol_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWrappedProtocol_GetWrapperCode(This,pnCode,dwReserved)	\
    ( (This)->lpVtbl -> GetWrapperCode(This,pnCode,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWrappedProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0050 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0050_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0050_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     __RPC__in unsigned long *, __RPC__in HWND * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Proxy( 
    IBinding * This,
    /* [out] */ CLSID *pclsidProtocol,
    /* [out] */ DWORD *pdwResult,
    /* [annotation][out] */ 
    __RPC__out  LPOLESTR *pszResult,
    /* [out][in] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Stub( 
    __RPC__in IBinding * This,
    /* [out] */ __RPC__out CLSID *pclsidProtocol,
    /* [out] */ __RPC__out DWORD *pdwResult,
    /* [out] */ __RPC__deref_out_opt LPOLESTR *pszResult,
    /* [in] */ DWORD dwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Proxy( 
    IBindStatusCallback * This,
    /* [out] */ DWORD *grfBINDF,
    /* [unique][out][in] */ BINDINFO *pbindinfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Stub( 
    __RPC__in IBindStatusCallback * This,
    /* [out] */ __RPC__out DWORD *grfBINDF,
    /* [unique][out][in] */ __RPC__inout_opt RemBINDINFO *pbindinfo,
    /* [unique][out][in] */ __RPC__inout_opt RemSTGMEDIUM *pstgmed);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ FORMATETC *pformatetc,
    /* [in] */ STGMEDIUM *pstgmed);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Stub( 
    __RPC__in IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ __RPC__in RemFORMATETC *pformatetc,
    /* [in] */ __RPC__in RemSTGMEDIUM *pstgmed);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallbackEx_GetBindInfoEx_Proxy( 
    IBindStatusCallbackEx * This,
    /* [out] */ DWORD *grfBINDF,
    /* [unique][out][in] */ BINDINFO *pbindinfo,
    /* [out] */ DWORD *grfBINDF2,
    /* [out] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallbackEx_GetBindInfoEx_Stub( 
    __RPC__in IBindStatusCallbackEx * This,
    /* [out] */ __RPC__out DWORD *grfBINDF,
    /* [unique][out][in] */ __RPC__inout_opt RemBINDINFO *pbindinfo,
    /* [unique][out][in] */ __RPC__inout_opt RemSTGMEDIUM *pstgmed,
    /* [out] */ __RPC__out DWORD *grfBINDF2,
    /* [out] */ __RPC__out DWORD *pdwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Proxy( 
    IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Stub( 
    __RPC__in IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(*pcbBuf) BYTE *pBuffer,
    /* [out][in] */ __RPC__inout DWORD *pcbBuf);

/* [local] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Proxy( 
    IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Stub( 
    __RPC__in IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(*pcbBuf) BYTE *pBuffer,
    /* [out][in] */ __RPC__inout DWORD *pcbBuf,
    /* [out][in] */ __RPC__inout DWORD *pdwFlags,
    /* [out][in] */ __RPC__inout DWORD *pdwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Proxy( 
    IBindHost * This,
    /* [in] */ IMoniker *pMk,
    /* [in] */ IBindCtx *pBC,
    /* [in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Stub( 
    __RPC__in IBindHost * This,
    /* [unique][in] */ __RPC__in_opt IMoniker *pMk,
    /* [unique][in] */ __RPC__in_opt IBindCtx *pBC,
    /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pBSC,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObj);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Proxy( 
    IBindHost * This,
    /* [in] */ IMoniker *pMk,
    /* [in] */ IBindCtx *pBC,
    /* [in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Stub( 
    __RPC__in IBindHost * This,
    /* [unique][in] */ __RPC__in_opt IMoniker *pMk,
    /* [unique][in] */ __RPC__in_opt IBindCtx *pBC,
    /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pBSC,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObj);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\UserEnv.h ===
//=============================================================================
//  userenv.h   -   Header file for user environment API.
//                  User Profiles, environment variables, and Group Policy
//
//  Copyright (c) Microsoft Corporation 1995-2002
//  All rights reserved
//
//=============================================================================


#ifndef _INC_USERENV
#define _INC_USERENV

#include <wbemcli.h>

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_USERENV_)
#define USERENVAPI DECLSPEC_IMPORT
#else
#define USERENVAPI
#endif


#ifdef __cplusplus
extern "C" {
#endif

//=============================================================================
//
// LoadUserProfile
//
// Loads the specified user's profile.
//
// Most applications should not need to use this function.  It's used
// when a user has logged onto the system or a service starts in a named
// user account.
//
// hToken        - Token for the user, returned from LogonUser()
// lpProfileInfo - Address of a PROFILEINFO structure
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:  The caller of this function must have admin privileges on the machine.
//
//        Upon successful return, the hProfile member of the PROFILEINFO
//        structure is a registry key handle opened to the root
//        of the user's hive.  It has been opened with full access. If
//        you need to read or write to the user's registry file, use
//        this key instead of HKEY_CURRENT_USER.  Do not close this
//        handle.  Instead pass it to UnloadUserProfile to close
//        the handle.
//
//=============================================================================

#include <profinfo.h>

#define PI_NOUI         0x00000001      // Prevents displaying of messages
#define PI_APPLYPOLICY  0x00000002      // Apply NT4 style policy

USERENVAPI
BOOL
WINAPI
LoadUserProfileA(
    __in    HANDLE          hToken,
    __inout LPPROFILEINFOA  lpProfileInfo);
USERENVAPI
BOOL
WINAPI
LoadUserProfileW(
    __in    HANDLE          hToken,
    __inout LPPROFILEINFOW  lpProfileInfo);
#ifdef UNICODE
#define LoadUserProfile  LoadUserProfileW
#else
#define LoadUserProfile  LoadUserProfileA
#endif // !UNICODE

//=============================================================================
//
// UnloadUserProfile
//
// Unloads a user's profile that was loaded by LoadUserProfile()
//
// hToken        -  Token for the user, returned from LogonUser()
// hProfile      -  hProfile member of the PROFILEINFO structure
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     The caller of this function must have admin privileges on the machine.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
UnloadUserProfile(
    __in    HANDLE  hToken,
    __in    HANDLE  hProfile);

//=============================================================================
//
// GetProfilesDirectory
//
// Returns the path to the root of where all user profiles are stored.
//
// lpProfilesDir  -  Receives the path
// lpcchSize      -  Size of lpProfilesDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfilesDir is not large enough or NULL, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Users
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
GetProfilesDirectoryA(
    __out_ecount_opt(*lpcchSize)    LPSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetProfilesDirectoryW(
    __out_ecount_opt(*lpcchSize)    LPWSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
#ifdef UNICODE
#define GetProfilesDirectory  GetProfilesDirectoryW
#else
#define GetProfilesDirectory  GetProfilesDirectoryA
#endif // !UNICODE

//=============================================================================
//
//  GetProfileType()
//
//  Returns the type of the profile that is loaded for a user.
//
//  dwFlags   - Returns the profile flags
//
//  Return:     TRUE if successful
//              FALSE if an error occurs. Call GetLastError for more details
//
//  Comments:   if profile is not already loaded the function will return an error.
//              The caller needs to have access to HKLM part of the registry.
//              (exists by default)
//
//=============================================================================

#if(WINVER >= 0x0500)

//
// Flags that can be set in the dwFlags field
//

#define PT_TEMPORARY         0x00000001      // A profile has been allocated that will be deleted at logoff.
#define PT_ROAMING           0x00000002      // The loaded profile is a roaming profile.
#define PT_MANDATORY         0x00000004      // The loaded profile is mandatory.

USERENVAPI
BOOL
WINAPI
GetProfileType(
    __out DWORD *dwFlags);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  DeleteProfile()
//
//  Deletes the profile and all other user related settings from the machine
//
//  lpSidString    - String form of the user sid.
//  lpProfilePath  - ProfilePath (if Null, lookup in the registry)
//  lpComputerName - Computer Name from which profile has to be deleted
//
//  Return:     TRUE if successful
//              FALSE if an error occurs. Call GetLastError for more details
//
//  Comments:   Deletes the profile directory, registry and appmgmt stuff
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
DeleteProfileA (
    __in        LPCSTR    lpSidString,
    __in_opt    LPCSTR    lpProfilePath,
    __in_opt    LPCSTR    lpComputerName);
USERENVAPI
BOOL
WINAPI
DeleteProfileW (
    __in        LPCWSTR    lpSidString,
    __in_opt    LPCWSTR    lpProfilePath,
    __in_opt    LPCWSTR    lpComputerName);
#ifdef UNICODE
#define DeleteProfile  DeleteProfileW
#else
#define DeleteProfile  DeleteProfileA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  CreateProfile()
//
//  Creating a user profile without loading it. 
//
//  pszUserSid     - String form of the user sid.
//  pszUserName    - Name of the user, used as the base name to create the 
//                   profile directory
//  pszProfilePath - Returned full profile path 
//  cchProfilePath - Size of pszProfilePath buffer
//
//  Return:     S_OK : Successfully created the profile
//              E_ACCESSDENIED : The caller does not have enough permission to
//                     create the profile. The caller has to be administrators
//                     in order for this API to succeed.
//              HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) : a profile is 
//                     already exists for the given user.
//              Others : Standard HRESULT error codes.
//                          
//  Comments:   
//=============================================================================

#if(WINVER >= 0x0600)

USERENVAPI
HRESULT
WINAPI
CreateProfile(
    __in                            LPCWSTR pszUserSid,
    __in                            LPCWSTR pszUserName,
    __out_ecount(cchProfilePath)    LPWSTR  pszProfilePath,
    __in                            DWORD   cchProfilePath);

#endif /* WINVER >= 0x0600 */

//=============================================================================
//
// GetDefaultUserProfilesDirectory
//
// Returns the path to the root of the default user profile
//
// lpProfileDir   -  Receives the path
// lpcchSize      -  Size of lpProfileDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfileDir is not large enough or NULL, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Users\Default
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
GetDefaultUserProfileDirectoryA(
    __out_ecount_opt(*lpcchSize)    LPSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetDefaultUserProfileDirectoryW(
    __out_ecount_opt(*lpcchSize)    LPWSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
#ifdef UNICODE
#define GetDefaultUserProfileDirectory  GetDefaultUserProfileDirectoryW
#else
#define GetDefaultUserProfileDirectory  GetDefaultUserProfileDirectoryA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetAllUsersProfilesDirectory
//
// Returns the path to the root of the All Users profile
//
// lpProfileDir   -  Receives the path
// lpcchSize      -  Size of lpProfileDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfileDir is not large enough or NULL, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Program Data
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
GetAllUsersProfileDirectoryA(
    __out_ecount_opt(*lpcchSize)    LPSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetAllUsersProfileDirectoryW(
    __out_ecount_opt(*lpcchSize)    LPWSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
#ifdef UNICODE
#define GetAllUsersProfileDirectory  GetAllUsersProfileDirectoryW
#else
#define GetAllUsersProfileDirectory  GetAllUsersProfileDirectoryA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetUserProfileDirectory
//
// Returns the path to the root of the requested user's profile
//
// hToken         -  User's token returned from LogonUser()
// lpProfileDir   -  Receives the path
// lpcchSize      -  Size of lpProfileDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfileDir is not large enough or NULL, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Users\Joe
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
GetUserProfileDirectoryA(
    __in                            HANDLE  hToken,
    __out_ecount_opt(*lpcchSize)    LPSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetUserProfileDirectoryW(
    __in                            HANDLE  hToken,
    __out_ecount_opt(*lpcchSize)    LPWSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
#ifdef UNICODE
#define GetUserProfileDirectory  GetUserProfileDirectoryW
#else
#define GetUserProfileDirectory  GetUserProfileDirectoryA
#endif // !UNICODE

//=============================================================================
//
// CreateEnvironmentBlock
//
// Returns the environment variables for the specified user.  This block
// can then be passed to CreateProcessAsUser().
//
// lpEnvironment  -  Receives a pointer to the new environment block
// hToken         -  User's token returned from LogonUser() (optional, can be NULL)
// bInherit       -  Inherit from the current process's environment block
//                   or start from a clean state.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If hToken is NULL, the returned environment block will contain
//           system variables only.
//
//           Call DestroyEnvironmentBlock to free the buffer when finished.
//
//           If this block is passed to CreateProcessAsUser, the
//           CREATE_UNICODE_ENVIRONMENT flag must also be set.
//
//=============================================================================

BOOL
WINAPI
CreateEnvironmentBlock(
    __out       LPVOID  *lpEnvironment,
    __in_opt    HANDLE  hToken,
    __in        BOOL    bInherit);

//=============================================================================
//
// DestroyEnvironmentBlock
//
// Frees environment variables created by CreateEnvironmentBlock
//
// lpEnvironment  -  A pointer to the environment block
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

BOOL
WINAPI
DestroyEnvironmentBlock(
    __in    LPVOID  lpEnvironment);

//=============================================================================
//
// ExpandEnvironmentStringsForUser
//
// Expands the source string using the environment block for the
// specified user.  If hToken is null, the system environment block
// will be used (no user environment variables).
//
// hToken         -  User's token returned from LogonUser() (optional, can be NULL)
// lpSrc          -  Pointer to the string with environment variables
// lpDest         -  Buffer that receives the expanded string
// dwSize         -  Size of lpDest in characters (max chars)
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If the user profile for hToken is not loaded, this api will fail.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
ExpandEnvironmentStringsForUserA(
    __in_opt                HANDLE      hToken,
    __in                    LPCSTR    lpSrc,
    __out_ecount(dwSize)    LPSTR     lpDest,
    __in                    DWORD       dwSize);
USERENVAPI
BOOL
WINAPI
ExpandEnvironmentStringsForUserW(
    __in_opt                HANDLE      hToken,
    __in                    LPCWSTR    lpSrc,
    __out_ecount(dwSize)    LPWSTR     lpDest,
    __in                    DWORD       dwSize);
#ifdef UNICODE
#define ExpandEnvironmentStringsForUser  ExpandEnvironmentStringsForUserW
#else
#define ExpandEnvironmentStringsForUser  ExpandEnvironmentStringsForUserA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// RefreshPolicy()
//
// Causes group policy to be applied immediately on the client machine
//
// bMachine  -  Refresh machine or user policy
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
RefreshPolicy(
    __in        BOOL bMachine);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// RefreshPolicyEx()
//
// Causes group policy to be applied immediately on the client machine. 
//
// bMachine  -  Refresh machine or user policy
// dwOptions -  Option specifying the kind of refresh that needs to be done.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

#if(WINVER >= 0x0500)

#define RP_FORCE            1      // Refresh policies without any optimisations.
#define RP_SYNC             2      // Refresh Policy sync; the call does not return till the time policy processing is completed

USERENVAPI
BOOL
WINAPI
RefreshPolicyEx(
    __in        BOOL    bMachine, 
    __in        DWORD   dwOptions);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// EnterCriticalPolicySection
//
// Pauses the background application of group policy to allow safe
// reading of the registry.  Applications that need to read multiple
// policy entries and ensure that the values are not changed while reading
// them should use this function.
//
// The maximum amount of time an application can hold a critical section
// is 10 minutes.  After 10 minutes, policy can be applied again.
//
// bMachine -  Pause machine or user policy
//
// Returns:  Handle if successful
//           NULL if not.  Call GetLastError() for more details
//
// Note 1:  The handle returned should be passed to LeaveCriticalPolicySection
// when finished.  Do not close this handle, LeaveCriticalPolicySection
// will do that.
//
// Note 2:  If both user and machine critical sections need to be acquired then
// they should be done in this order: first acquire user critical section and
// then acquire machine critical section.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
HANDLE
WINAPI
EnterCriticalPolicySection(
    __in        BOOL    bMachine);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// LeaveCriticalPolicySection
//
// Resumes the background application of group policy.  See
// EnterCriticalPolicySection for more details.
//
// hSection - Handle returned from EnterCriticalPolicySection
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:  This function will close the handle.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
LeaveCriticalPolicySection(
    __in        HANDLE  hSection);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// RegisterGPNotification
//
// Entry point for registering for Group Policy change notification.
//
// Parameters: hEvent     -   Event to be notified, by calling SetEvent(hEvent)
//             bMachine   -   If true, then register machine policy notification
//                                     else register user policy notification
//
// Returns:    True if successful
//             False if error occurs
//
// Notes:      Group Policy Notifications.  There are 2 ways an application can
//             be notify when Group Policy is finished being applied.
//
//             1) Using the RegisterGPNotifcation function and waiting for the
//                event to be signalled.
//
//             2) A WM_SETTINGCHANGE message is broadcast to all desktops.
//                wParam - 1 if machine policy was applied, 0 if user policy was applied.
//                lParam - Points to the string "Policy"
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
RegisterGPNotification(
    __in        HANDLE  hEvent,
    __in        BOOL    bMachine);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// UnregisterGPNotification
//
// Removes registration for a Group Policy change notification.
//
// Parameters: hEvent    -   Event to be removed
//
// Returns:    True if successful
//             False if error occurs
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
UnregisterGPNotification(
    __in        HANDLE  hEvent);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GPOptions flags
//
// These are the flags found in the GPOptions property of a DS object
//
// For a given DS object (Site, Domain, OU), the GPOptions property
// contains options that effect all the GPOs link to this SDOU.
//
// This is a DWORD type
//
//=============================================================================

#if(WINVER >= 0x0500)

#define GPC_BLOCK_POLICY        0x00000001  // Block all non-forced policy from above

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GPLink flags
//
// These are the flags found on the GPLink property of a DS object after
// the GPO path.
//
// For a given DS object (Site, Domain, OU), the GPLink property will
// be in this text format
//
// [LDAP://CN={E615A0E3-C4F1-11D1-A3A7-00AA00615092},CN=Policies,CN=System,DC=mydomain,DC=Microsoft,DC=Com;1]
//
// The GUID is the GPO name, and the number following the LDAP path are the options
// for that link from this DS object.  Note, there can be multiple GPOs
// each in their own square brackets in a prioritized list.
//
//=============================================================================

#if(WINVER >= 0x0500)

//
// Options for a GPO link
//

#define GPO_FLAG_DISABLE        0x00000001  // This GPO is disabled
#define GPO_FLAG_FORCE          0x00000002  // Don't override the settings in
                                            // this GPO with settings from
                                            // a GPO below it.
#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetGPOList
//
//
// Queries for the list of Group Policy Objects for the specified
// user or machine.  This function will return a link list
// of Group Policy Objects.  Call FreeGPOList to free the list.
//
// Note, most applications will not need to call this function.
// This will primarily be used by services acting on behalf of
// another user or machine.  The caller of this function will
// need to look in each GPO for their specific policy
//
// This function can be called in two different ways.  Either the hToken for
// a user or machine can be supplied and the correct name and domain
// controller name will be generated, or hToken is NULL and the caller
// must supply the name and the domain controller name.
//
// Calling this function with an hToken ensures the list of Group Policy
// Objects is correct for the user or machine since security access checking
// can be perfomed.  If hToken is not supplied, the security of the caller
// is used instead which means that list may or may not be 100% correct
// for the intended user / machine.  However, this is the fastest way
// to call this function.
//
// hToken           - User or machine token, if NULL, lpName and lpHostName must be supplied
// lpName           - User or machine name in DN format, if hToken is supplied, this must be NULL
// lpHostName       - Domain DN name or domain controller name. If hToken is supplied, this must be NULL
// lpComputerName   - Computer name to use to determine site location.  If NULL,
//                    the local computer is used as the reference. Format:  \\machinename
// dwFlags          - Flags field.  See flags definition below
// pGPOList         - Address of a pointer which receives the link list of GPOs
//
//
// Returns:  TRUE if successful
//           FALSE if not.  Use GetLastError() for more details.
//
// Examples:
//
// Here's how this function will typically be called for
// looking up the list of GPOs for a user:
//
//      LPGROUP_POLICY_OBJECT  pGPOList;
//
//      if (GetGPOList (hToken, NULL, NULL, NULL, 0, &pGPOList))
//      {
//          // do processing here...
//          FreeGPOList (pGPOList);
//      }
//
//
// Here's how this function will typically be called for
// looking up the list of GPOs for a machine:
//
//      LPGROUP_POLICY_OBJECT  pGPOList;
//
//      if (GetGPOList (NULL, lpMachineName, lpHostName, lpMachineName,
//                      GPO_LIST_FLAG_MACHINE, &pGPOList))
//      {
//          // do processing here...
//          FreeGPOList (pGPOList);
//      }
//
//=============================================================================

#if(WINVER >= 0x0500)

//
// Each Group Policy Object is associated (linked) with a site, domain,
// organizational unit, or machine.
//

typedef enum _GPO_LINK {
    GPLinkUnknown = 0,                     // No link information available
    GPLinkMachine,                         // GPO linked to a machine (local or remote)
    GPLinkSite,                            // GPO linked to a site
    GPLinkDomain,                          // GPO linked to a domain
    GPLinkOrganizationalUnit               // GPO linked to a organizational unit
} GPO_LINK, *PGPO_LINK;

typedef struct _GROUP_POLICY_OBJECTA {
    DWORD       dwOptions;                  // See GPLink option flags above
    DWORD       dwVersion;                  // Revision number of the GPO
    LPSTR       lpDSPath;                   // Path to the Active Directory portion of the GPO
    LPSTR       lpFileSysPath;              // Path to the file system portion of the GPO
    LPSTR       lpDisplayName;              // Friendly display name
    CHAR        szGPOName[50];              // Unique name
    GPO_LINK    GPOLink;                    // Link information
    LPARAM      lParam;                     // Free space for the caller to store GPO specific information
    struct _GROUP_POLICY_OBJECTA * pNext;   // Next GPO in the list
    struct _GROUP_POLICY_OBJECTA * pPrev;   // Previous GPO in the list
    LPSTR       lpExtensions;               // Extensions that are relevant for this GPO
    LPARAM      lParam2;                    // Free space for the caller to store GPO specific information
    LPSTR       lpLink;                     // Path to the Active Directory site, domain, or organizational unit this GPO is linked to
                                            // If this is the local GPO, this points to the word "Local"
} GROUP_POLICY_OBJECTA, *PGROUP_POLICY_OBJECTA;
typedef struct _GROUP_POLICY_OBJECTW {
    DWORD       dwOptions;                  // See GPLink option flags above
    DWORD       dwVersion;                  // Revision number of the GPO
    LPWSTR      lpDSPath;                   // Path to the Active Directory portion of the GPO
    LPWSTR      lpFileSysPath;              // Path to the file system portion of the GPO
    LPWSTR      lpDisplayName;              // Friendly display name
    WCHAR       szGPOName[50];              // Unique name
    GPO_LINK    GPOLink;                    // Link information
    LPARAM      lParam;                     // Free space for the caller to store GPO specific information
    struct _GROUP_POLICY_OBJECTW * pNext;   // Next GPO in the list
    struct _GROUP_POLICY_OBJECTW * pPrev;   // Previous GPO in the list
    LPWSTR      lpExtensions;               // Extensions that are relevant for this GPO
    LPARAM      lParam2;                    // Free space for the caller to store GPO specific information
    LPWSTR      lpLink;                     // Path to the Active Directory site, domain, or organizational unit this GPO is linked to
                                            // If this is the local GPO, this points to the word "Local"
} GROUP_POLICY_OBJECTW, *PGROUP_POLICY_OBJECTW;
#ifdef UNICODE
typedef GROUP_POLICY_OBJECTW GROUP_POLICY_OBJECT;
typedef PGROUP_POLICY_OBJECTW PGROUP_POLICY_OBJECT;
#else
typedef GROUP_POLICY_OBJECTA GROUP_POLICY_OBJECT;
typedef PGROUP_POLICY_OBJECTA PGROUP_POLICY_OBJECT;
#endif // UNICODE


//
// dwFlags for GetGPOList()
//

#define GPO_LIST_FLAG_MACHINE        0x00000001  // Return machine policy information
#define GPO_LIST_FLAG_SITEONLY       0x00000002  // Return site policy information only
#define GPO_LIST_FLAG_NO_WMIFILTERS  0x00000004  // Ignore WMI filters when filtering GPO's
#define GPO_LIST_FLAG_NO_SECURITYFILTERS 0x00000008 // Ignore security filters

USERENVAPI
BOOL
WINAPI
GetGPOListA (
    __in_opt    HANDLE      hToken,
    __in_opt    LPCSTR    lpName,
    __in_opt    LPCSTR    lpHostName,
    __in_opt    LPCSTR    lpComputerName,
    __in        DWORD       dwFlags,
    __deref_out PGROUP_POLICY_OBJECTA * pGPOList);
USERENVAPI
BOOL
WINAPI
GetGPOListW (
    __in_opt    HANDLE      hToken,
    __in_opt    LPCWSTR    lpName,
    __in_opt    LPCWSTR    lpHostName,
    __in_opt    LPCWSTR    lpComputerName,
    __in        DWORD       dwFlags,
    __deref_out PGROUP_POLICY_OBJECTW * pGPOList);
#ifdef UNICODE
#define GetGPOList  GetGPOListW
#else
#define GetGPOList  GetGPOListA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// FreeGPOList
//
//
// Frees the linked list returned from GetGPOList
//
// pGPOList - Pointer to the linked list of GPOs
//
//
// Returns:  TRUE if successful
//           FALSE if not
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
FreeGPOListA (
    __in        PGROUP_POLICY_OBJECTA   pGPOList);
USERENVAPI
BOOL
WINAPI
FreeGPOListW (
    __in        PGROUP_POLICY_OBJECTW   pGPOList);
#ifdef UNICODE
#define FreeGPOList  FreeGPOListW
#else
#define FreeGPOList  FreeGPOListA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetAppliedGPOList
//
// Queries for the list of applied Group Policy Objects for the specified
// user or machine and specified client side extension. This function will return
// a linked list of Group Policy Objects.  Call FreeGPOList to free the list.
//
// dwFlags          - User or machine policy, if it is GPO_LIST_FLAG_MACHINE then
//                    return machine policy information
// pMachineName     - Name of remote computer in the form \\computername. If null
//                    then local computer is used.
// pSidUser         - Security id of user (relevant for user policy). If pMachineName is
//                    null and pSidUser is null then it means current logged on user.
//                    If pMachine is null and pSidUser is non-null then it means user
//                    represented by pSidUser on local machine. If pMachineName is non-null
//                    then and if dwFlags specifies user policy, then pSidUser must be
//                    non-null.
// pGuidExtension   - Guid of the specified extension
// ppGPOList        - Address of a pointer which receives the link list of GPOs
//
// The return value is a Win32 error code. ERROR_SUCCESS means the GetAppliedGPOList
// function completed successfully. Otherwise it indicates that the function failed.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
DWORD
WINAPI
GetAppliedGPOListA (
    __in        DWORD       dwFlags,
    __in_opt    LPCSTR    pMachineName,
    __in_opt    PSID        pSidUser,
    __in        GUID        *pGuidExtension,
    __deref_out PGROUP_POLICY_OBJECTA   *ppGPOList);
USERENVAPI
DWORD
WINAPI
GetAppliedGPOListW (
    __in        DWORD       dwFlags,
    __in_opt    LPCWSTR    pMachineName,
    __in_opt    PSID        pSidUser,
    __in        GUID        *pGuidExtension,
    __deref_out PGROUP_POLICY_OBJECTW   *ppGPOList);
#ifdef UNICODE
#define GetAppliedGPOList  GetAppliedGPOListW
#else
#define GetAppliedGPOList  GetAppliedGPOListA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Group Policy Object client side extension support
//
// Flags, data structures and function prototype
//
// To register your extension, create a subkey under this key
//
// Software\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
//
// The subkey needs to be a guid so that it is unique. The noname value of the subkey
// can be the friendly name of the extension. Then add these values:
//
//     DllName                      REG_EXPAND_SZ  Path to your DLL
//     ProcessGroupPolicy           REG_SZ       Function name (see PFNPROCESSGROUPPOLICY prototype). This
//                                                 is obsolete, it has been superseded by ProcessGroupPolicyEx.
//                                                 It's here for backward compatibility reasons only.
//     ProcessGroupPolicyEx         REG_SZ       Function name (see PFNPROCESSGROUPPOLICYEX prototype)
//     GenerateGroupPolicy          REG_SZ       Function name for Rsop (see PFNGENERATEGROUPPOLICY prototype)
//     NoMachinePolicy              REG_DWORD    True, if extension does not have to be called when
//                                                 machine policies are being processed.
//     NoUserPolicy                 REG_DWORD    True, if extension does not have to be called when
//                                                 user policies are being processed.
//     NoSlowLink                   REG_DWORD    True, if extension does not have to be called on a slow link
//     NoBackgroundPolicy           REG_DWORD    True, if extension does not have to be called 
//                                                 for background policy processing.
//     NoGPOListChanges             REG_DWORD    True, if extension does not have to be called when
//                                                 there are no changes between cached and current GPO lists.
//     PerUserLocalSettings         REG_DWORD    True, if user policies have to be cached on a per user and
//                                                 per machine basis.
//     RequiresSuccessfulRegistry   REG_DWORD    True, if extension should be called only if registry extension
//                                                 was successfully processed.
//     EnableAsynchronousProcessing REG_DWORD    True, if registry extension will complete its processing
//                                                 asynchronously.
//     NotifyLinkTransition         REG_DWORD    True, if extension should be called when a change in link
//                                                 speed is detected between previous policy application and
//                                                 current policy application.
//
// The return value is a Win32 error code. ERROR_SUCCESS means the ProcessGroupPolicy
// function completed successfully. If return value is ERROR_OVERRIDE_NOCHANGES then it
// means that the extension will be called the next time even if NoGPOListChanges is set
// and there are no changes to the GPO list. Any other return value indicates that the
// ProcessGroupPolicy or ProcessGroupPolicyEx function failed.
//
//=============================================================================

#if(WINVER >= 0x0500)

#define GP_DLLNAME                         TEXT("DllName")
#define GP_ENABLEASYNCHRONOUSPROCESSING    TEXT("EnableAsynchronousProcessing")
#define GP_MAXNOGPOLISTCHANGESINTERVAL     TEXT("MaxNoGPOListChangesInterval")
#define GP_NOBACKGROUNDPOLICY              TEXT("NoBackgroundPolicy")
#define GP_NOGPOLISTCHANGES                TEXT("NoGPOListChanges")
#define GP_NOMACHINEPOLICY                 TEXT("NoMachinePolicy")
#define GP_NOSLOWLINK                      TEXT("NoSlowLink")
#define GP_NOTIFYLINKTRANSITION            TEXT("NotifyLinkTransition")
#define GP_NOUSERPOLICY                    TEXT("NoUserPolicy")
#define GP_PERUSERLOCALSETTINGS            TEXT("PerUserLocalSettings")
#define GP_PROCESSGROUPPOLICY              TEXT("ProcessGroupPolicy")
#define GP_REQUIRESSUCCESSFULREGISTRY      TEXT("RequiresSuccessfulRegistry")

#define GPO_INFO_FLAG_MACHINE              0x00000001  // Apply machine policy rather than user policy
#define GPO_INFO_FLAG_BACKGROUND           0x00000010  // Background refresh of policy (ok to do slow stuff)
#define GPO_INFO_FLAG_SLOWLINK             0x00000020  // Policy is being applied across a slow link
#define GPO_INFO_FLAG_VERBOSE              0x00000040  // Verbose output to the eventlog
#define GPO_INFO_FLAG_NOCHANGES            0x00000080  // No changes were detected to the Group Policy Objects
#define GPO_INFO_FLAG_LINKTRANSITION       0x00000100  // A change in link speed was detected between previous policy
                                                       // application and current policy application
#define GPO_INFO_FLAG_LOGRSOP_TRANSITION   0x00000200  // A Change in Rsop Logging was detected between previous policy
                                                       // application and current policy application, (new intf only)
#define GPO_INFO_FLAG_FORCED_REFRESH       0x00000400  // Forced Refresh is being applied. redo policies.
#define GPO_INFO_FLAG_SAFEMODE_BOOT        0x00000800  // windows safe mode boot flag
#define GPO_INFO_FLAG_ASYNC_FOREGROUND     0x00001000  // Asynchronous foreground refresh of policy

typedef UINT_PTR ASYNCCOMPLETIONHANDLE;
typedef DWORD (*PFNSTATUSMESSAGECALLBACK)(__in BOOL bVerbose, __in LPWSTR lpMessage);

typedef DWORD(*PFNPROCESSGROUPPOLICY)(
    __in DWORD dwFlags,                              // GPO_INFO_FLAGS
    __in HANDLE hToken,                              // User or machine token
    __in HKEY hKeyRoot,                              // Root of registry
    __in PGROUP_POLICY_OBJECT  pDeletedGPOList,      // Linked list of deleted GPOs
    __in PGROUP_POLICY_OBJECT  pChangedGPOList,      // Linked list of changed GPOs
    __in ASYNCCOMPLETIONHANDLE pHandle,              // For asynchronous completion
    __inout BOOL *pbAbort,                           // If true, then abort GPO processing
    __in_opt PFNSTATUSMESSAGECALLBACK pStatusCallback);  // Callback function for displaying status messages
                                                     // Note, this can be NULL

typedef DWORD(*PFNPROCESSGROUPPOLICYEX)(
    __in DWORD dwFlags,                              // GPO_INFO_FLAGS
    __in HANDLE hToken,                              // User or machine token
    __in HKEY hKeyRoot,                              // Root of registry
    __in PGROUP_POLICY_OBJECT  pDeletedGPOList,      // Linked list of deleted GPOs
    __in PGROUP_POLICY_OBJECT  pChangedGPOList,      // Linked list of changed GPOs
    __in ASYNCCOMPLETIONHANDLE pHandle,              // For asynchronous completion
    __inout BOOL *pbAbort,                           // If true, then abort GPO processing
    __in_opt PFNSTATUSMESSAGECALLBACK pStatusCallback,   // Callback function for displaying status messages
                                                     // Note, this can be NULL
    __in_opt IWbemServices *pWbemServices,           // Pointer to namespace to log diagnostic mode data
                                                     // Note, this will be NULL when Rsop logging is disabled
    __out HRESULT *pRsopStatus);                     // RSOP Logging succeeded or not.

typedef PVOID PRSOPTOKEN;

typedef struct _RSOP_TARGET {
    WCHAR *     pwszAccountName;                   // Account name
    WCHAR *     pwszNewSOM;                        // New domain or OU location for account
    SAFEARRAY * psaSecurityGroups;                 // New security groups
    PRSOPTOKEN  pRsopToken;                        // Rsop token for use with Rsop security Api's
    PGROUP_POLICY_OBJECT pGPOList;                 // Linked list of GPOs
    IWbemServices *      pWbemServices;            // Pointer to namespace to log planning mode data
} RSOP_TARGET, *PRSOP_TARGET;

typedef DWORD(*PFNGENERATEGROUPPOLICY)(
    __in DWORD dwFlags,                            // GPO_INFO_FLAGS
    __inout BOOL  *pbAbort,                        // If true, then abort GPO processing
    __in_opt WCHAR *pwszSite,                      // Site the target computer is in
    __in_opt PRSOP_TARGET pComputerTarget,         // Computer target info, can be null
    __in_opt PRSOP_TARGET pUserTarget );           // User target info, can be null

//
// GUID that identifies the registry extension
//

#define REGISTRY_EXTENSION_GUID  { 0x35378EAC, 0x683F, 0x11D2, 0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2 }

//
// UBPM trigger provider and event GUIDs
//
#define GROUP_POLICY_TRIGGER_EVENT_PROVIDER_GUID  { 0xBD2F4252, 0x5E1E, 0x49FC, 0x9A, 0x30, 0xF3, 0x97, 0x8A, 0xD8, 0x9E, 0xE2 }
#define MACHINE_POLICY_PRESENT_TRIGGER_GUID  { 0x659FCAE6, 0x5BDB, 0x4DA9, 0xB1, 0xFF, 0xCA, 0x2A, 0x17, 0x8D, 0x46, 0xE0 }
#define USER_POLICY_PRESENT_TRIGGER_GUID  { 0x54FB46C8, 0xF089, 0x464C, 0xB1, 0xFD, 0x59, 0xD1, 0xB6, 0x2C, 0x3B, 0x50 }

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Group Policy Object client side asynchronous extension processing
//
// extensionId    - Unique guid identifying the extension
// pAsyncHandle   - Asynchronous completion handle that was passed to extension in
//                  ProcessGroupPolicy call
// dwStatus       - Completion status of asynchronous processing
//
// The return value is a Win32 error code. ERROR_SUCCESS means the ProcessGroupPolicyCompleted
// function completed successfully. Otherwise it indicates that the function failed.
//
//=============================================================================

#if(WINVER >= 0x0500)

typedef GUID *REFGPEXTENSIONID;

USERENVAPI
DWORD
WINAPI
ProcessGroupPolicyCompleted(
    __in REFGPEXTENSIONID extensionId,
    __in ASYNCCOMPLETIONHANDLE pAsyncHandle,
    __in DWORD dwStatus);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Group Policy Object client side asynchronous extension processing
//
// extensionId    - Unique guid identifying the extension
// pAsyncHandle   - Asynchronous completion handle that was passed to extension in
//                  ProcessGroupPolicy call
// dwStatus       - Completion status of asynchronous processing
// RsopStatus     - RSoP Logging status
//
// The return value is a Win32 error code. ERROR_SUCCESS means the ProcessGroupPolicyCompleted
// function completed successfully. Otherwise it indicates that the function failed.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
DWORD
WINAPI
ProcessGroupPolicyCompletedEx(
    __in REFGPEXTENSIONID extensionId,
    __in ASYNCCOMPLETIONHANDLE pAsyncHandle,
    __in DWORD dwStatus,
    __in HRESULT RsopStatus);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Function:    RsopAccessCheckByType
//
// Description: Determines whether the security descriptor pointed to by pSecurityDescriptor
//                              grants the set of access rights specified in dwDesiredAccessMask
//                              to the client identified by the RSOPTOKEN pointed to by pRsopToken.
//
// pSecurityDescriptor  - Security Descriptor on the object
// pPrincipalSelfSid    - Principal Sid
// pRsopToken           - Pointer to a valid RSOPTOKEN against which access needs to be checked
// dwDesiredAccessMask  - Mask of requested generic and/or standard and or specific access rights
// pObjectTypeList      - Object Type List
// ObjectTypeListLength - Object Type List Length
// pGenericMapping      - Generic Mapping
// pPrivilegeSet        - privilege set
// pdwPrivilegeSetLength- privilege set length
// pdwGrantedAccessMask - On success, if pbAccessStatus is true, it contains
//                                         the mask of standard and specific rights granted.
//                                         If pbAccessStatus is false, it is set to 0.
//                                         On failure, it is not modified.
// pbAccessStatus       - On success, indicates wether the requested set
//                                    of access rights was granted.
//                                    On failure, it is not modified
//
// Returns S_OK on success or appropriate error code.
// For additional details, look at the documentation of AccessCheckByType
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
HRESULT 
WINAPI
RsopAccessCheckByType(  
    __in       PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in_opt   PSID pPrincipalSelfSid,
    __in       PRSOPTOKEN pRsopToken,
    __in       DWORD dwDesiredAccessMask,
    __in_ecount_opt(ObjectTypeListLength)   POBJECT_TYPE_LIST pObjectTypeList,
    __in       DWORD ObjectTypeListLength,
    __in       PGENERIC_MAPPING pGenericMapping,
    __in_bcount_opt(*pdwPrivilegeSetLength) PPRIVILEGE_SET pPrivilegeSet,
    __in_opt   LPDWORD pdwPrivilegeSetLength,
    __out LPDWORD pdwGrantedAccessMask,
    __out LPBOOL pbAccessStatus);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Function:    RsopFileAccessCheck
//
// Description: Determines whether the security descriptor on the file grants the set of file access 
//                              rights specified in dwDesiredAccessMask
//                              to the client identified by the RSOPTOKEN pointed to by pRsopToken.
//
// pszFileName          - Name of an existing filename
// pRsopToken           - Pointer to a valid RSOPTOKEN against which access needs to be checked
// dwDesiredAccessMask  - Mask of requested generic and/or standard and or specific access rights
// pdwGrantedAccessMask - On success, if pbAccessStatus is true, it contains
//                                         the mask of standard and specific rights granted.
//                                         If pbAccessStatus is false, it is set to 0.
//                                         On failure, it is not modified.
// pbAccessStatus       - On success, indicates wether the requested set
//                                    of access rights was granted.
//                                    On failure, it is not modified
//
// Returns S_OK on success or appropriate error code
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
HRESULT 
WINAPI
RsopFileAccessCheck(
    __in  LPWSTR pszFileName,
    __in  PRSOPTOKEN pRsopToken,
    __in  DWORD dwDesiredAccessMask,
    __out LPDWORD pdwGrantedAccessMask,
    __out LPBOOL pbAccessStatus);

#endif /* WINVER >= 0x0500 */

typedef enum _SETTINGSTATUS
{
        RSOPUnspecified = 0,
        RSOPApplied,
        RSOPIgnored,
        RSOPFailed,
        RSOPSubsettingFailed
} SETTINGSTATUS;

//=============================================================================
//
//  POLICYSETTINGSTATUSINFO
//
//  Describes the instance of RSOP_PolicySettingStatus
//
//  szKey               - OPTIONAL, if NULL, the key is generated on the fly
//  szEventSource       - name of the source generation event log messages
//  szEventLogName      - name of the event log database where the messages are logged
//  dwEventID           - event log message ID
//  status              - status of the policy setting
//  timeLogged          - time at which the event log message was logged
//
//=============================================================================

typedef struct _POLICYSETTINGSTATUSINFO
{
        LPWSTR                  szKey;
        LPWSTR                  szEventSource;
        LPWSTR                  szEventLogName;
        DWORD                   dwEventID;
        DWORD                   dwErrorCode;
        SETTINGSTATUS   status;
        SYSTEMTIME              timeLogged;
} POLICYSETTINGSTATUSINFO, *LPPOLICYSETTINGSTATUSINFO;

//=============================================================================
//
//  RsopSetPolicySettingStatus
//
//  Creates an instance of RSOP_PolicySettingStatus and RSOP_PolicySettingLink
//  and links RSOP_PolicySettingStatus to RSOP_PolicySetting
//
//  dwFlags             - flags
//  pServices           - RSOP namespace
//  pSettingInstance    - instance of RSOP_PolicySetting or its children
//  nInfo               - number of PolicySettingStatusInfo
//  pStatus             - array of PolicySettingStatusInfo
//
//  Return:     S_OK if successful, HRESULT otherwise
//
//=============================================================================

USERENVAPI
HRESULT
WINAPI
RsopSetPolicySettingStatus( __in DWORD                       dwFlags,
                            __in IWbemServices*              pServices,
                            __in IWbemClassObject*           pSettingInstance,
                            __in DWORD                       nInfo,
                            __in_ecount(nInfo) POLICYSETTINGSTATUSINFO*    pStatus );

//=============================================================================
//
//  RsopResetPolicySettingStatus
//
//  Unlinks RSOP_PolicySettingStatus from RSOP_PolicySetting,
//  deletes the instance of RSOP_PolicySettingStatus and RSOP_PolicySettingLink
//  and optionally deletes the instance of RSOP_PolicySetting
//
//  dwFlags             - flags
//  pServices           - RSOP namespace
//  pSettingInstance    - instance of RSOP_PolicySetting or its children
//
//  Return:     S_OK if successful, HRESULT otherwise
//
//=============================================================================

USERENVAPI
HRESULT
WINAPI
RsopResetPolicySettingStatus( __in DWORD               dwFlags,
                              __in IWbemServices*      pServices,
                              __in IWbemClassObject*   pSettingInstance );

//=============================================================================
//
// Flags for RSoP WMI providers
//
//=============================================================================

// planning mode provider flags
#define FLAG_NO_GPO_FILTER      0x80000000  // GPOs are not filtered, implies FLAG_NO_CSE_INVOKE
#define FLAG_NO_CSE_INVOKE      0x40000000  // only GP processing done for planning mode
#define FLAG_ASSUME_SLOW_LINK   0x20000000  // planning mode RSoP assumes slow link
#define FLAG_LOOPBACK_MERGE     0x10000000  // planning mode RSoP assumes merge loop back
#define FLAG_LOOPBACK_REPLACE   0x08000000  // planning mode RSoP assumes replace loop back

#define FLAG_ASSUME_USER_WQLFILTER_TRUE   0x04000000  // planning mode RSoP assumes all comp filters to be true
#define FLAG_ASSUME_COMP_WQLFILTER_TRUE   0x02000000  // planning mode RSoP assumes all user filters to be true

#define FLAG_PLANNING_MODE                0x01000000  // flag that indicates that a given namespace was created
                                                      // for planning mode. This flag cannot be passed in but the
                                                      // relevant subnamespace will be marked with this flag

// diagnostic mode provider flags
#define FLAG_NO_USER                      0x00000001  // Don't get any user data
#define FLAG_NO_COMPUTER                  0x00000002  // Don't get any machine data
#define FLAG_FORCE_CREATENAMESPACE        0x00000004  
                   // Delete and recreate the namespace for this snapshot.

//=============================================================================
//
// Extended Errors returned by RSoP WMI Providers
//
//=============================================================================

// User accessing the rsop provider doesn't have access to user data.
#define RSOP_USER_ACCESS_DENIED         0x00000001  

// User accessing the rsop provider doesn't have access to computer data.
#define RSOP_COMPUTER_ACCESS_DENIED     0x00000002  

// This user is an interactive non admin user, the temp snapshot namespace already exists
// and the FLAG_FORCE_CREATENAMESPACE was not passed in
#define RSOP_TEMPNAMESPACE_EXISTS        0x00000004



#ifdef __cplusplus
}
#endif


#endif // _INC_USERENV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\usp10.h ===
/*++

   Copyright (c) Microsoft Corporation. All rights reserved.

*/

#ifndef __usp10__
#define __usp10__
#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <specstrings.h>
#ifdef __cplusplus
extern "C" {
#endif


/////   USP - Unicode Complex Script processor
//
//      Copyright (c) Microsoft Corporation. All rights reserved.




/////   SCRIPT
//
//      The SCRIPT enum is an opaque type used internally to identify
//      which shaping engine functions are used to process a given run.
//
//
#define SCRIPT_UNDEFINED  0
//
//p     SCRIPT_UNDEFINED: This is the only public script ordinal. May be
//      forced into the eScript field of a SCRIPT_ANALYSIS to disable shaping.
//      SCRIPT_UNDEFINED is supported by all fonts - ScriptShape will display
//      whatever glyph is defined in the font CMAP table, or, if none, the
//      missing glyph.







/////   USP Status Codes
//
#define USP_E_SCRIPT_NOT_IN_FONT   \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x200)    // Script doesn't exist in font






/////   SCRIPT_CACHE
//
//      Many script APIs take a combination of HDC and SCRIPT_CACHE parameter.
//
//      A SCRIPT_CACHE is an opaque pointer to a Uniscribe font metric cache
//      structure.


typedef void *SCRIPT_CACHE;


//      The client must allocate and retain one SCRIPT_CACHE variable for each
//      character style used. It must be initialised by the client to NULL.
//
//      APIs are passed an HDC and the address of a SCRIPT_CACHE variable.
//      Uniscribe will first attempt to access font data via the SCRIPT_CACHE
//      and will only inspect the HDC if the required data is not already
//      cached.
//
//      The HDC may be passed as NULL. If data required by Uniscribe is
//      already cached, the HDC won't be accessed and operation continues
//      normally.
//
//      If the HDC is passed as NULL, and Uniscribe needs to access it for
//      any reason, Uniscribe will return E_PENDING.
//
//      E_PENDING is returned quickly, allowing the client to avoid time
//      consuming SelectObject calls. The following example applies to all
//      APIs that take a SCRIPT_CACHE and an optional HDC.
//
//c     hr = ScriptShape(NULL, &sc, ..);
//c     if (hr == E_PENDING) {
//c         ... select font into hdc ...
//c         hr = ScriptShape(hdc, &sc, ...);
//c     }






/////   ScriptFreeCache
//
//      The client may free a SCRIPT_CACHE at any time. Uniscribe maintains
//      reference counts in it's font and shaper caches, and frees font data
//      only when all sizes of the font are free, and shaper data only when
//      all fonts it supports are freed.
//
//      The client should free the SCRIPT_CACHE for a style when it discards
//      that style.
//
//      ScriptFreeCache always sets it's parameter to NULL to help avoid
//      mis-referencing.


__checkReturn HRESULT WINAPI ScriptFreeCache(
    __deref_inout_ecount(1) SCRIPT_CACHE   *psc);       //InOut  Cache handle






/////   SCRIPT_CONTROL
//
//      The SCRIPT_CONTROL structure provides itemization control flags to the
//      ScriptItemize function.
//
//
typedef struct tag_SCRIPT_CONTROL {
    DWORD   uDefaultLanguage    :16; // For NADS, also default for context
    DWORD   fContextDigits      :1;  // Means use previous script instead of uDefaultLanguage

    // The following flags provide legacy support for GetCharacterPlacement features
    DWORD   fInvertPreBoundDir  :1;  // Reading order of virtual item immediately prior to string
    DWORD   fInvertPostBoundDir :1;  // Reading order of virtual item immediately following string
    DWORD   fLinkStringBefore   :1;  // Equivalent to presence of ZWJ before string
    DWORD   fLinkStringAfter    :1;  // Equivalent to presence of ZWJ after string
    DWORD   fNeutralOverride    :1;  // Causes all neutrals to be strong in the current embedding direction
    DWORD   fNumericOverride    :1;  // Causes all numerals to be strong in the current embedding direction
    DWORD   fLegacyBidiClass    :1;  // Causes plus and minus to be reated as neutrals, slash as a common separator
    DWORD   fMergeNeutralItems  :1;  // Causes merging neutral characters into strong items, when possible
    DWORD   fReserved           :7;  
} SCRIPT_CONTROL;
//
//
//p     uDefaultLanguage: Language to use when Unicode values are ambiguous.
//              Used by numeric processing to select digit shape when
//              fDigitSubstitute (see SCRIPT_STATE) is in force.
//
//p     fContextDigits: Specifies that national digits are chosen according to
//              the nearest previous strong text, rather than using
//              uDefaultLanguage.
//
//p     fInvertPreBoundDir: By default text at the start of the string is
//              laid out as if it follows strong text of the same direction
//              as the base embedding level. Set fInvertPreBoundDir to change
//              the initial context to the opposite of the base embedding
//              level. This flag is for GetCharacterPlacement legacy support.
//
//p     fInvertPostBoundDir: By default text at the end of the string is
//              laid out as if it preceeds strong text of the same direction
//              as the base embedding level. Set fInvertPostBoundDir to change
//              the final context to the opposite of the base embedding
//              level. This flag is for GetCharacterPlacement legacy support.
//
//p     fLinkStringBefore: Causes the first character of the string to be
//              shaped as if were joined to a previous character.
//
//p     fLinkStringAfter: Causes the last character of the string to be
//              shaped as if were joined to a following character.
//
//p     fNeutralOverride: Causes all neutral characters in the string to be
//              treated as if they were strong characters of their enclosing
//              embedding level. This effectively locks neutrals in place,
//              reordering occuring only between neutrals.
//
//p     fNumericOverride: Causes all numeric characters in the string to be
//              treated as if they were strong characters of their enclosing
//              embedding level. This effectively locks numerics in place,
//              reordering occuring only between numerics.
//
//p     fReserved: Reserved. Always initialise to 0.






/////   SCRIPT_STATE
//
//      The SCRIPT_STATE structure is used both to initialise the unicode
//      algorithm state as an input parameter to ScriptItemize, and is also
//      a component of each item analysis returned by ScriptItemize.
//
//
typedef struct tag_SCRIPT_STATE {
    WORD    uBidiLevel         :5;  // Unicode Bidi algorithm embedding level (0-16)
    WORD    fOverrideDirection :1;  // Set when in LRO/RLO embedding
    WORD    fInhibitSymSwap    :1;  // Set by U+206A (ISS), cleared by U+206B (ASS)
    WORD    fCharShape         :1;  // Set by U+206D (AAFS), cleared by U+206C (IAFS)
    WORD    fDigitSubstitute   :1;  // Set by U+206E (NADS), cleared by U+206F (NODS)
    WORD    fInhibitLigate     :1;  // Equiv !GCP_Ligate, no Unicode control chars yet
    WORD    fDisplayZWG        :1;  // Equiv GCP_DisplayZWG, no Unicode control characters yet
    WORD    fArabicNumContext  :1;  // For EN->AN Unicode rule
    WORD    fGcpClusters       :1;  // For Generating Backward Compatible GCP Clusters (legacy Apps)
    WORD    fReserved          :1;
    WORD    fEngineReserved    :2;  // For use by shaping engine
} SCRIPT_STATE;
//
//
//p     uBidiLevel: The embedding level associated with all characters in this
//              run according to the Unicode bidi algorithm. When passed to
//              ScriptItemize, should be initialised to 0 for an LTR base
//              embedding level, or 1 for RTL.
//
//p     fOverrideDirection: TRUE if this level is an override level (LRO/RLO).
//              In an override level, characters are layed out purely
//              left to right, or purely right to left. No reordering of digits
//              or strong characters of opposing direction takes place.
//              Note that this initial value is reset by LRE, RLE, LRO or
//              RLO codes in the string.
//
//p     fInhibitSymSwap: TRUE if the shaping engine is to bypass mirroring of
//              Unicode Mirrored glyphs such as brackets. Set by Unicode
//              character ISS, cleared by ASS.
//
//p     fCharShape: TRUE if character codes in the Arabic Presentation Forms
//              areas of Unicode should be shaped. (Not implemented).
//
//p     fDigitSubstitute: TRUE if character codes U+0030 through U+0039
//              (European digits) are to be substituted by national digits.
//              Set by Unicode NADS, Cleared by NODS.
//
//p     fInhibitLigate: TRUE if ligatures are not to be used in the shaping
//              of Arabic or Hebrew characters.
//
//p     fDisplayZWG: TRUE if control characters are to be shaped as
//              representational glyphs. (Normally, control characters are
//              shaped to the blank glyph and given a width of zero).
//
//p     fArabicNumContext: TRUE indicates prior strong characters were Arabic
//              for the purposes of rule P0 on page 3-19 of 'The Unicode
//              Standard, version 2.0'. Should normally be set TRUE before
//              itemizing an RTL paragraph in an Arabic language, FALSE
//              otherwise.
//
//p     fGcpClusters: For GetCharaterPlacement legacy support only.
//              Initialise to TRUE to request ScriptShape to generate
//              the LogClust array the same way as GetCharacterPlacement
//              does in Arabic and Hebrew Windows95. Affects only Arabic
//              and Hebrew items.
//
//p     fReserved: Reserved. Always initialise to 0.
//
//p     fEngineReserved: Reserved. Always initialise to 0.






/////   SCRIPT_ANALYSIS
//
//      Each analysed item is described by a SCRIPT_ANALYSIS structure.
//      It also includes a copy of the Unicode algorithm state (SCRIPT_STATE).
//
//
typedef struct tag_SCRIPT_ANALYSIS {
    WORD    eScript         :10;    // Shaping engine
    WORD    fRTL            :1;     // Rendering direction
    WORD    fLayoutRTL      :1;     // Set for GCP classes ARABIC/HEBREW and LOCALNUMBER
    WORD    fLinkBefore     :1;     // Implies there was a ZWJ before this item
    WORD    fLinkAfter      :1;     // Implies there is a ZWJ following this item.
    WORD    fLogicalOrder   :1;     // Set by client as input to ScriptShape/Place
    WORD    fNoGlyphIndex   :1;     // Generated by ScriptShape/Place - this item does not use glyph indices
    SCRIPT_STATE s;
} SCRIPT_ANALYSIS;
//
//
//p     eScript: Opaque value identifying which engine Uniscribe will use to
//              Shape, Place and TextOut this item. The value of eScript is
//              undefined, and will change in future releases, but attributes
//              of eScript may be obtained by calling ScriptGetProperties.
//
//p     fRTL: Rendering direction. Normally identical to the parity of the
//              Unicode embedding level, but may differ if overridden by
//              GetCharacterPlacement legacy support.
//
//p     fLayoutRTL: Logical direction - whether conceptually part of a
//              left-to-right sequenece or a right-to-left sequence. Although
//              this is usually the same as fRTL, for a number in a
//              right-to-left run, fRTL is False (because digits are always
//              displayed LTR), but fLayoutRTL is True (because the number is
//              read as part of the right-to-left sequence).
//
//p     fLinkBefore: If set, the shaping engine will shape the first character
//              of this item as if it were joining with a previous character.
//              Set by ScriptItemize, may be overriden before calling ScriptShape.
//
//p     fLinkAfter: If set, the shaping engine will shape the last character
//              of this item as if it were joining with a subsequient character.
//              Set by ScriptItemize, may be overriden before calling ScriptShape.
//
//p     fLogicalOrder: If set, the shaping engine will generate all glyph
//              related arrays in logical order. By default glyph related
//              arrays are in visual order, the first array entry corresponding
//              to the leftmost glyph.
//              Set to FALSE by ScriptItemize, may be overriden before calling
//              ScriptShape.
//
//p     fNoGlyphIndex: May be set TRUE on input to ScriptShape to disable use
//              of glyphs for this item. Additionally, ScriptShape will set it
//              TRUE for hdcs containing symbolic, unrecognised and device fonts.
//              Disabling glyphing disables complex script shaping. When set,
//              shaping and placing for this item is implemented directly by
//              calls to GetTextExtentExPoint and ExtTextOut.
/////   SCRIPT_ITEM
//
//      The SCRIPT_ITEM structure includes a SCRIPT_ANALYSIS with the string
//      ofset of the first character of the item.
//
//
typedef struct tag_SCRIPT_ITEM {
    int              iCharPos;      // Logical offset to first character in this item
    SCRIPT_ANALYSIS  a;
} SCRIPT_ITEM;
//
//
//p     iCharPos: Offset from beginning of itemised string to first character
//              of this item, counted in Unicode codepoints (i.e. words).
//
//p     a: Script analysis structure containing analysis specific to this
//              item, to be passed to ScriptShape, ScriptPlace etc.






/////   ScriptItemize - break text into items
//
//      Breaks a run of unicode into individually shapeable items.
//      Items are delimited by
//
//      o Change of shaping engine
//      o Change of direction
//
//      The client may create multiple runs from each item returned by
//      ScriptItemize, but should not combine multiple items into a single run.
//
//      Later the client will call ScriptShape for each run (when measuring or
//      rendering), and must pass the SCRIPT_ANALYSIS that ScriptItemize
//      returned.


__checkReturn HRESULT WINAPI ScriptItemize(
    __in_ecount(cInChars) const WCHAR                   *pwcInChars,    // In   Unicode string to be itemized
    int                                                 cInChars,       // In   Codepoint count to itemize
    int                                                 cMaxItems,      // In   Max length of itemization array
    __in_ecount_opt(1) const SCRIPT_CONTROL             *psControl,     // In   Analysis control (optional)
    __in_ecount_opt(1) const SCRIPT_STATE               *psState,       // In   Initial bidi algorithm state (optional)
    __out_ecount_part(cMaxItems, *pcItems) SCRIPT_ITEM  *pItems,        // Out  Array to receive itemization
    __out_ecount(1) int                                 *pcItems);      // Out  Count of items processed (optional)






/////
//
//
//      Returns E_INVALIDARG if pwcInChars == NULL or cInChars == 0
//          or pItems == NULL or cMaxItems < 2.
//
//      Returns E_OUTOFMEMORY if the output buffer length (cMaxItems) is
//          insufficient. Note that in this case, as in all error cases, no
//          items have been fully processed so no part of the output array
//          contains defined values.
//
//      If psControl and psState are NULL on entry, ScriptItemize
//      breaks the unicode string purely by character code.  If they are all
//      non-null, it performs a full Unicode bidi analysis.
//
//      ScriptItemize always adds a terminal item to the item analysis array
//      (pItems) such that the length of an item at pItem is always available as:
//
//c     pItem[1].iCharPos - pItem[0].iCharPos
//
//      For this reason, it is invalid to call ScriptItemize with a buffer
//      of less than two SCRIPT_ANALYSIS items.
//
//      To perform a correct Unicode Bidi analysis, the SCRIPT_STATE should
//      be initialised according to the paragraph reading order at paragraph
//      start, and ScriptItemize should be passed the whole paragraph.
//
//      fRTL and fNumeric together provide the same classification as
//      the lpClass output from GetCharacterPlacement.
//
//      European digits U+0030 through U+0039 may be rendered as national
//      digits as follows:
//
//t     fDigitSubstitute | FContextDigits | Digit shapes displayed for Unicode U+0030 through U+0039
//t     ---------------- | -------------- | ------------------------------------
//t     False            | Any            | Western (European / American) digits
//t     True             | False          | As specified in SCRIPT_CONTROL.uDefaultLanguage
//t     True             | True           | As prior strong text, defaulting to SCRIPT_CONTROL.uDefaultLanguage
//
//
//      For fContextDigits, any Western digits (U+0030 - U+0039) encountered
//      before the first strongly directed character are substituted by the
//      traditional digits of the SCRIPT_CONTROL.uDefaultLanguage when that
//      language is written in the same direction as SCRIPT_STATE.uBidiLevel.
//
//      Thus, in a right-to-left string, if SCRIPT_CONTROL.uDefaultLanguage is
//      1 (LANG_ARABIC), then leading Western digits will be substituted by
//      traditional Arabic digits.
//
//      However, also in a right-to-left string, if SCRIPT_CONTROL.uDefaultLanguage
//      is 0x1e (LANG_THAI), then no substitution occurs on leading Western
//      digits because the Thai language is written left-to-right.
//
//      Following strongly directed characters, digits are substituted
//      by the traditional digits associated with the closest prior strongly
//      directed character.
//
//      The left-to-right mark (LRM) and right-to-left mark (RLM) are strong
//      characters whose language depends on the SCRIPT_CONTROL.uDefaultLangauge.
//
//      If SCRIPT_CONTROL.uDefaultLangauge is a left-to-right langauge, then
//      LRM causes subsequent Western digits to be substituted by the
//      traditional digits associated with that language, while Western
//      digits following RLM are not substituted.
//
//      Conversly, if SCRIPT_CONTROL.uDefaultLangauge is a right-to-left
//      langauge, then Western digits following LRM are not substituted, while
//      Western digits following RLM are substituted by the traditional digits
//      associated with that language.
//
//
//
//      Effect of Unicode control characters on SCRIPT_STATE:
//
//t     SCRIPT_STATE flag | Set by | Cleared by
//t     ----------------- | ------   ----------
//t     fDigitSubstitute  |  NADS  |   NODS
//t     fInhibitSymSwap   |  ISS   |   ASS
//t     fCharShape        |  AAFS  |   IAFS
//
//      SCRIPT_STATE.fArabicNumContext controls the Unicode EN->AN rule.
//      It should normally be initialised to TRUE
//      before itemizing an RTL paragraph in an Arabic language, FALSE
//      otherwise.
/////   ScriptLayout
//
//      The ScriptLayout function converts an array of run embedding levels to
//      a map of visual to logical position, and/or logical to visual position.
//
//      pbLevel must contain the embedding levels for all runs on the line,
//      ordered logically.
//
//      On output, piVisualToLogical[0] is the logical index of the run to
//      display at the far left. Subsequent entries should be displayed
//      progressing from left to right.
//
//      piLogicalToVisual[0] is the relative visual position where the first
//      logical run should be displayed - the leftmost display position being zero.
//
//      The caller may request either piLogicalToVisual or piVisualToLogical
//      or both.
//
//      Note: No other input is required since the embedding levels give all
//      necessary information for layout.


__checkReturn HRESULT WINAPI ScriptLayout(
    int                             cRuns,                  // In   Number of runs to process
    __in_ecount(cRuns) const BYTE   *pbLevel,               // In   Array of run embedding levels
    __out_ecount_full_opt(cRuns) int    *piVisualToLogical,     // Out  List of run indices in visual order
    __out_ecount_full_opt(cRuns) int    *piLogicalToVisual);    // Out  List of visual run positions






/////   SCRIPT_JUSTIFY
//
//      The script justification enumeration provides the client with the
//      glyph characteristic information it needs to implement justification.


typedef enum tag_SCRIPT_JUSTIFY {
    SCRIPT_JUSTIFY_NONE           = 0,   // Justification can't be applied at this glyph
    SCRIPT_JUSTIFY_ARABIC_BLANK   = 1,   // This glyph represents a blank in an Arabic run
    SCRIPT_JUSTIFY_CHARACTER      = 2,   // Inter-character justification point follows this glyph
    SCRIPT_JUSTIFY_RESERVED1      = 3,   // Reserved #1
    SCRIPT_JUSTIFY_BLANK          = 4,   // This glyph represents a blank outside an Arabic run
    SCRIPT_JUSTIFY_RESERVED2      = 5,   // Reserved #2
    SCRIPT_JUSTIFY_RESERVED3      = 6,   // Reserved #3
    SCRIPT_JUSTIFY_ARABIC_NORMAL  = 7,   // Normal Middle-Of-Word glyph that connects to the right (begin)
    SCRIPT_JUSTIFY_ARABIC_KASHIDA = 8,   // Kashida(U+640) in middle of word
    SCRIPT_JUSTIFY_ARABIC_ALEF    = 9,   // Final form of Alef-like (U+627, U+625, U+623, U+632)
    SCRIPT_JUSTIFY_ARABIC_HA      = 10,  // Final form of Ha (U+647)
    SCRIPT_JUSTIFY_ARABIC_RA      = 11,  // Final form of Ra (U+631)
    SCRIPT_JUSTIFY_ARABIC_BA      = 12,  // Middle-Of-Word form of Ba (U+628)
    SCRIPT_JUSTIFY_ARABIC_BARA    = 13,  // Ligature of alike (U+628,U+631)
    SCRIPT_JUSTIFY_ARABIC_SEEN    = 14,  // Highest priority: Initial shape of Seen(U+633) (end)
    SCRIPT_JUSTIFY_ARABIC_SEEN_M  = 15,  // Reserved #4
} SCRIPT_JUSTIFY;



/////   SCRIPT_VISATTR
//
//      The visual (glyph) attribute buffer generated by ScriptShape
//      identifies clusters and justification points:


typedef struct tag_SCRIPT_VISATTR {
    WORD           uJustification   :4;  // Justification class
    WORD           fClusterStart    :1;  // First glyph of representation of cluster
    WORD           fDiacritic       :1;  // Diacritic
    WORD           fZeroWidth       :1;  // Blank, ZWJ, ZWNJ etc, with no width
    WORD           fReserved        :1;  // General reserved
    WORD           fShapeReserved   :8;  // Reserved for use by shaping engines
} SCRIPT_VISATTR;
//
//
//p     uJustification: Justification class for this glyph. See SCRIPT_JUSTIFY.
//
//p     fClusterStart: Set for the logically first glyph in every cluster,
//          even for clusters containing just one glyph.
//
//p     fDiacritic: Set for glyphs that combine with base characters.
//
//p     fZeroWidth: Set by the shaping engine for some, but not all, zero
//          width characters.


/////   ScriptShape
//
//      The ScriptShape function takes a Unicode run and generates glyphs and
//      visual attributes.
//
//      The number of glyphs generated varies according to the script and the
//      font. Only for simple scripts and fonts does each Unicode code point
//      generates a single glyph.
//
//      There is no limit on the number of glyphs generated by a codepoint.
//      For example, a sophisticated complex script font might choose to
//      constuct characters from components, and so generate many times as
//      many glyphs as characters.
//
//      There are also special cases like invalid character representations,
//      where extra glyphs are added to represent the invalid sequence.
//
//      A reasonable guess might be to provide a glyph buffer 1.5 times the
//      length of the character buffer, plus a 16 glyph fixed addition for
//      rare cases like invalid sequenece representation.
//
//      If ScriptShape returns E_OUTOFMEMORY it will be necessary to recall
//      it, possibly more than once, until a large enough buffer is found.


__checkReturn HRESULT WINAPI ScriptShape(
    HDC                                                     hdc,            // In    Optional (see under caching)
    __deref_inout_ecount(1) SCRIPT_CACHE                    *psc,           // InOut Cache handle
    __in_ecount(cChars) const WCHAR                         *pwcChars,      // In    Logical unicode run
    int                                                     cChars,         // In    Length of unicode run
    int                                                     cMaxGlyphs,     // In    Max glyphs to generate
    __inout_ecount(1) SCRIPT_ANALYSIS                       *psa,           // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    __out_ecount_part(cMaxGlyphs, *pcGlyphs) WORD           *pwOutGlyphs,   // Out   Output glyph buffer
    __out_ecount_full(cChars) WORD                          *pwLogClust,    // Out   Logical clusters
    __out_ecount_part(cMaxGlyphs, *pcGlyphs) SCRIPT_VISATTR *psva,          // Out   Visual glyph attributes
    __out_ecount(1) int                                     *pcGlyphs);     // Out   Count of glyphs generated






/////
//
//      Returns E_OUTOFMEMORY if the output buffer length (cMaxGlyphs) is
//          insufficient. Note that in this case, as in all error cases, the
//          content of all output parameters are undefined.
//
//p     psa: Pass the SCRIPT_ANALYSIS field of the SCRIPT_ITEM entry for this
//          item. (The SCRIPT_ITEM array is returned by ScriptItemize.)
//
//      Clusters are sequenced uniformly within the run, as are glyphs within
//      the cluster - the fRTL item flag (from ScriptItemize) identifies
//      whether left to right, or right to left.
//
//p     pwLogClust: has cChars elements - each entry in pwLogClust corresponds
//          to a character in the input string (pwcChars). The value in each
//          pwLogCLust entry is the offset of the first glyph in the cluster
//          that contains this character.
//
//      Example: In the following example, there are four clusters:
//      1st cluster: one character represented by one glyph
//      2nd cluster: one character represented by 3 glyphs
//      3rd cluster: three characters represented by one glyph
//      4th cluster: 2 characters represented by three glyphs
//
//      Glyph array: (c<n>g<m> means cluster n glyph m)
//c        0      1    2    3      4      5    6    7
//c     -------------------------------------------------
//c     | c1g1 | c2g1 c2g2 c2g3 | c3g1 | c4g1 c4g2 c4g3 |
//c     -------------------------------------------------
//
//      Character array: (c<n>u<m> means cluster n Unicode codepoint m)
//c        0      1      2    3    4      5    6
//c     --------------------------------------------
//c     | c1u1 | c2u1 | c3u1 c3u2 c3u3 | c4u1 c4u2 |
//c     --------------------------------------------
//
//      LogClust: (one entry per character gives 1st glyph in cluster
//c     --------------------------------------------
//c     |   0  |   1  |   4    4    4  |   5    5  |
//c     --------------------------------------------
//
//      Note that for an RTL run (SCRIPT_ANALYSIS.a.fRTL == TRUE) and when
//      fLogicalOrder == FALSE (the default), glyphs are generated in visual
//      order - the reverse of the codepoint order, and the values in the
//      LogClust array will be descending.
//
//
//p     psva: has one visual attribute per glyph and so has maxGlyphs entries.
//
//
//      ScriptShape may set the fNoGlyphIndex flag in psa if the font or
//      OS cannot support glyph indices.
//
//      If fLogicalOrder is requested in psa, glyphs will be always be
//      generated in the same order as the original Unicode characters.
//
//      If fLogicalOrder is not set, right to left items are generated in
//      reverse order, so ScriptTextOut does not need to reverse them before
//      calling ExtTextOut.
/////   ScriptPlace
//
//      The ScriptPlace function takes the output of a ScriptShape call and
//      generates glyph advance width and 2D offset information.
//
//      The composite ABC width for the whole item identifies how much the
//      glyphs overhang to the left of the start position and to the right of
//      the length implied by the sum of the advance widths.
//
//      The total advance width of the line is exactly abcA + abcB + abcC.
//
//      abcA and abcC are maintained internally by Uniscribe as proportions
//      of the cell height represented in 8 bits and are thus roughly +/- 1%.
//      The total width returned (as the sum of piAdvance, and as the sum of
//      abcA+abcB+abcC) is accurate to the resolution of the TrueType shaping
//      engine.
//
//      All glyph related arrays are in visual order unless the fLogicalOrder
//      flag is set in psa.


#ifndef LSDEFS_DEFINED
typedef struct tagGOFFSET {
    LONG  du;
    LONG  dv;
} GOFFSET;
#endif


__checkReturn HRESULT WINAPI ScriptPlace(
    HDC                                         hdc,        // In    Optional (see under caching)
    __deref_inout_ecount(1) SCRIPT_CACHE        *psc,       // InOut Cache handle
    __in_ecount(cGlyphs) const WORD             *pwGlyphs,  // In    Glyph buffer from prior ScriptShape call
    int                                         cGlyphs,    // In    Number of glyphs
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,      // In    Visual glyph attributes
    __inout_ecount(1) SCRIPT_ANALYSIS           *psa,       // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    __out_ecount_full(cGlyphs) int              *piAdvance, // Out   Advance wdiths
    __out_ecount_full_opt(cGlyphs) GOFFSET      *pGoffset,  // Out   x,y offset for combining glyph
    __out_ecount(1) ABC                         *pABC);     // Out   Composite ABC for the whole run (Optional)






/////   ScriptTextOut
//
//      The ScriptTextOut function takes the output of both ScriptShape and
//      ScriptPlace calls and calls the operating system ExtTextOut function
//      appropriately. If the last parameter is not null, GDI's ExtTextOutW calls
//      are routed to this function.
//
//      All arrays are in visual order unless the fLogicalOrder flag is set in
//      psa.


__checkReturn HRESULT WINAPI ScriptTextOut(
    const HDC                               hdc,            // In     OS handle to device context (required)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,           // InOut  Cache handle
    int                                     x,              // In     x,y position for first glyph
    int                                     y,              // In
    UINT                                    fuOptions,      // In     ExtTextOut options
    __in_ecount_opt(1) const RECT           *lprc,          // In     optional clipping/opaquing rectangle
    __in_ecount(1) const SCRIPT_ANALYSIS    *psa,           // In     Result of ScriptItemize
    __reserved const WCHAR                  *pwcReserved,   // In     Reserved (requires NULL)
    __reserved int                          iReserved,      // In     Reserved (requires 0)
    __in_ecount(cGlyphs) const WORD         *pwGlyphs,      // In     Glyph buffer from prior ScriptShape call
    int                                     cGlyphs,        // In     Number of glyphs
    __in_ecount(cGlyphs) const int          *piAdvance,     // In     Advance widths from ScriptPlace
    __in_ecount_opt(cGlyphs) const int      *piJustify,     // In     Justified advance widths (optional)
    __in_ecount(cGlyphs) const GOFFSET      *pGoffset);     // In     x,y offset for combining glyph






/////
//
//      The caller should normally use SetTextAlign(hdc, TA_RIGHT) before
//      calling ScriptTextOut with an RTL item inlogical order.
//
//      The piJustify array provides requested cell widths for each glyph.
//      When the piJustify width of a glyph differs from the unjustified
//      width (in PiAdvance), space is added to or removed from the glyph
//      cell at it's trailing edge. The glyph is always aligned with the
//      leading edge of it's cell. (This rule applies even in visual order.)
//
//      When a glyph cell is extended the extra space is uaually made up by
//      the addition of white space, however for Arabic scripts, the extra
//      space is made up by one or more kashida glyphs, unless the extra space
//      is insufficient for the shortest kashida glyph in the font. (The
//      width of the shortest kashida is available by calling
//      ScriptGetFontProperties.)
//
//      piJustify should only be passed if re-justification of the string is
//      required. Normally pass NULL to this parameter.
//
//      fuOptions may contain ETO_CLIPPED or ETO_OPAQUE (or neither or both).
//
//      Do not use ScriptTextOut to write to a metafile unless you are sure
//      that the metafile will eventually be played back without any font
//      substitution. ScriptTextOut record glyph numbers in the metafile.
//      Since glyph numbers vary considerably from one font to another
//      such a metafile is unlikely to play back correctly when differant
//      fonts are substituted.
//
//      For example when a metafile is played back at a different scale
//      CreateFont requests recorded in the metafile may resolve to bitmap
//      instead of truetype fonts, or if the metafile is played back on
//      a different machine requested fonts may not be installed.//
//
//      To write complex scripts in a metafile in a font independant manner,
//      use ExtTextOut to write the logical characters directly, so that
//      glyph generation and placement does not occur until the text is
//      played back.
/////   ScriptJustify
//
//      ScriptJustify provides a simple minded implementation of multilingual
//      justification.
//
//      Sophisticated text formatters may prefer to generate their own delta
//      dx array by combining their own features with the information returned
//      by ScriptShape in the SCRIPT_VISATTR array.
//
//      ScriptJustify establishes how much adjustment to make at each glyph
//      position on the line. It interprets the SCRIPT_VISATTR array generated
//      by a call to ScriptShape, and gives top priority to kashida, then uses
//      inter word spacing if there's no kashida points, then uses
//      intercharacter spacing if there are no inter-word points.
//
//      The justified advance widths generated in ScriptJustify should be
//      passed to ScriptTextOut in the piJustify paramter.
//
//      ScriptJustify creates a justify array containing updated advance
//      widths for each glyph. Where a glyphs advance width is increased, it
//      is expected that the extra width will be rendered to the right of the
//      glyph, with as white space or, for Arabic text, as kashida.
/////
__checkReturn HRESULT WINAPI ScriptJustify(
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In   Collected visual attributes for entire line
    __in_ecount(cGlyphs) const int              *piAdvance,     // In   Advance widths from ScriptPlace
    int                                         cGlyphs,        // In   Size of all arrays
    int                                         iDx,            // In   Desired width change, either increase or descrease
    int                                         iMinKashida,    // In   Minimum length of continuous kashida glyph to generate
    __out_ecount_full(cGlyphs) int              *piJustify);    // Out  Updated advance widths to pass to ScriptTextOut






/////   SCRIPT_LOGATTR
//
//      The SCRIPT_LOGATTR structure describes attributes of logical
//      characters useful when editing and formatting text.
//
//      Note that for wordbreaking and linebreaking, if the first character of
//      the run passed in is not whitespace, the client needs to check whether
//      the last character of the previous run is whitespace to determine if
//      the first character of this run is the start of a word.
//
//
typedef struct tag_SCRIPT_LOGATTR {
    BYTE    fSoftBreak      :1;     // Potential linebreak point
    BYTE    fWhiteSpace     :1;     // A unicode whitespace character, except NBSP, ZWNBSP
    BYTE    fCharStop       :1;     // Valid cursor position (for left/right arrow)
    BYTE    fWordStop       :1;     // Valid cursor position (for ctrl + left/right arrow)
    BYTE    fInvalid        :1;     // Invalid character sequence
    BYTE    fReserved       :3;
} SCRIPT_LOGATTR;
//
//
//p     fSoftBreak: It would be valid to break the line in front of this
//              character. This flag is set on the first character of
//              South-East Asian words. Note that when linebreaking the
//              client would usually also treat any nonblank following a blank
//              as a softbreak position, by inspecting the fWhiteSPace flag
//              below.
//
//p     fWhiteSpace: This character is one of the many Unicode character
//              that are classified as breakable whitespace.
//
//p     fCharStop: Valid cursor position. Set on most characters, but not
//              on codepoints inside Indian and South East Asian character
//              clusters. May be used to implement left and right arrow
//              operation in editors.
//
//p     fWordStop: Valid position following word advance/retire commonly
//              implemented at ctrl/left-arrow and ctrl/right-arrow.
//              May be used to implement ctrl+left and ctrl+right arrow
//              operation in editors. As with fSoftBreak clients should
//              normally also inspect the fWhiteSpace flag and treat the
//              first character after a run of whitespace as the start of a
//              word.
//
//p     fInvalid: Marks characters which form an invalid or undisplayable
//              combination. Scripts which can set this flag have the flag
//              fInvalidLogAttr set in their SCRIPT_PROPERTIES.






/////   ScriptBreak
//
//      The ScriptBreak function returns cursor movement and formatting break
//      positions for an item as an array of SCRIPT_LOGATTRs. To support
//      mixed formatting within a single word correctly, ScriptBreak should
//      be passed whole items as returned by ScriptItemize.
//
//      ScriptBreak does not require an hdc and does not execute glyph shaping.
//
//      The fCharStop flag marks cluster boundaries for those scripts where
//      it is conventional to restrict from moving inside clusters. The same
//      boundaries could also be inferred by inspecting the pLogCLust array
//      returned by ScriptShape, however ScriptBreak is considerably faster in
//      implementation and does not require an hdc to be prepared.
//
//      The fWordStop, fSoftBreak and fWhiteSpace flags are only available
//      through ScriptBreak.
//
//      Most shaping engines that identify invalid sequences do so by setting
//      the fInvalid flag in ScriptBreak. The fInvalidLogAttr flag in
//      ScriptProperties identifies which scripts do this.


__checkReturn HRESULT WINAPI ScriptBreak(
    __in_ecount(cChars) const WCHAR             *pwcChars,  // In   Logical unicode item
    int                                         cChars,     // In   Length of unicode item
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,       // In   Result of earlier ScriptItemize call
    __out_ecount_full(cChars) SCRIPT_LOGATTR    *psla);     // Out  Logical character attributes






/////   ScriptCPtoX
//
//      The ScriptCPtoX function returns the x offset from the left end
//      (!fLogical) or leading edge (fLogical) of a run to either the leading
//      or the trailing edge of a logical character cluster.
//
//      iCP is the offset of any logical character in the cluster.
//
//      For scripts where the caret may conventionally be placed into the
//      middle of clusters (e.g. Arabic, Hebrew), the returned X may be
//      an interpolated position for any codepoint in the line.
//
//      For scripts where the caret is conventionally snapped to the boundaries
//      of clusters, (e.g. Thai, Indian), the resulting X position will be
//      snapped to the requested edge of the cluster containing CP.


__checkReturn HRESULT WINAPI ScriptCPtoX(
    int                                         iCP,            // In   Logical character position in run
    BOOL                                        fTrailing,      // In   Which edge (default - leading)
    int                                         cChars,         // In   Count of logical codepoints in run
    int                                         cGlyphs,        // In   Count of glyphs in run
    __in_ecount(cChars) const WORD              *pwLogClust,    // In   Logical clusters
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In   Visual glyph attributes array
    __in_ecount(cGlyphs) const int              *piAdvance,     // In   Advance widths
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,           // In   Script analysis from item attributes
    int                                         *piX);          // Out  Resulting X position






/////   ScriptXtoCP
//
//      The ScriptXtoCP function converts an x offset from the left end
//      (!fLogical) or leading edge (fLogical) of a run to a logical
//      character position and a flag that indicates whether the X position
//      fell in the leading or the trailing half of the character.
//
//      For scripts where the cursor may conventionally be placed into the
//      middle of clusters (e.g. Arabic, Hebrew), the returned CP may be
//      for any codepoint in the line, and fTrailing will be either zero
//      or one.
//
//      For scripts where the cursor is conventionally snapped to the
//      boundaries of a cluster, the returned CP is always the position of
//      the logically first codepoint in a cluster, and fTrailing is either
//      zero, or the number of codepoints in the cluster.
//
//      Thus the appropriate cursor position for a mouse hit is always the
//      returned CP plus the value of fTrailing.
//
//      If the X positition passed is not in the item at all, the resulting
//      position will be the trailing edge of character -1 (for X positions
//      before the item), or the leading edge of character 'cChars' (for
//      X positions following the item).


__checkReturn HRESULT WINAPI ScriptXtoCP(
    int                                         iX,             // In   X offset from left of run
    int                                         cChars,         // In   Count of logical codepoints in run
    int                                         cGlyphs,        // In   Count of glyphs in run
    __in_ecount(cChars) const WORD              *pwLogClust,    // In   Logical clusters
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In   Visual glyph attributes
    __in_ecount(cGlyphs) const int              *piAdvance,     // In   Advance widths
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,           // In   Script analysis from item attributes
    __out_ecount(1) int                         *piCP,          // Out  Resulting character position
    __out_ecount(1) int                         *piTrailing);   // Out  Leading or trailing half flag






/////   Relationship between caret positions, justifications points and clusters
//
//
//t     Job                              | Uniscribe support
//t     -------------------------------- | --------------------------------------------------------
//t     Caret move by character cluster  | LogClust or VISATTR.fClusterStart or LOGATTR.fCharStop
//t     Line breaking between characters | LogClust or VISATTR.fClusterStart or LOGATTR.fCharStop
//t     Caret move by word               | LOGATTR.fWordStop
//t     Line breaking between words      | LOGATTR.fWordStop
//t     Justification                    | VISATTR.uJustification
//
//
//
/////   Character clusters
//
//      Character clusters are glyph sequences that cannot be split between
//      lines.
//
//      Some languages (e.g. Thai, Indic) restrict caret placement to points
//      betwen clusters. This applies both to keyboard initiated caret
//      movement (e.g. cursor keys) and pointing and clicking with the mouse
//      (hit testing).
//
//      Uniscribe provides cluster information in both the visual and logical
//      attributes. If you've called ScriptShape you'll find the cluster
//      information represented both by sequences of the same value in the
//      pwLogClust array, and by the fClusterStart flag in the psva
//      SCRIPT_VISATTR array.
//
//      ScriptBreak also returns the fCharStop flag in the SCRIPT_LOGATTR
//      array to identify cluster positions.
//
//
//
/////   Word break points
//
//      Valid positions for moving the caret when moving in whole words are
//      marked by the fWordStop flag returned by ScriptBreak.
//
//      Valid positions for breaking lines between words are marked by the
//      fSoftBreak flag returned by ScriptBreak.
//
//
//
/////   Justification
//
//      Justification space or kashida should be inserted where identified by
//      the uJustificaion field of the SCRIPT_VISATTR.
//
//      When performing inter-character justification, insert extra space
//      only after glyphs marked with uJustify == SCRIPT_JUSTIFY_CHARACTER.
//
//
//
/////   Script specific processing
//
//      Uniscribe provides information about special processing for each
//      script in the SCRIPT_PROPERTIES array.
//
//      Use the following code during initialisation to get a pointer to
//      the SCRIPT_PROPERTIES array:
//
//c     const SCRIPT_PROPERTIES **g_ppScriptProperties; // Array of pointers to properties
//c     int iMaxScript;
//c     HRESULT hr;
//
//c     hr = ScriptGetProperties(&g_ppScriptProperties, &g_iMaxScript);
//
//      Then inspect the properties of the script of an item 'iItem' as follows:
//
//c     hr = ScriptItemize( ... , pItems, ... );
//c     ...
//c     if (g_ppScriptProperties[pItems[iItem].a.eScript]->fNeedsCaretInfo) {
//c         // Use ScriptBreak to restrict the caret from entering clusters (for example).
//c     }
//
//
//      SCRIPT_PROPERTIES.fNeedsCaretInfo
//
//      Caret placement should be restricted to cluster
//      edges for scripts such as Thai and Indian. The fNeedsCaretInfo flag
//      in SCRIPT_PROPERTIES identifies such languages.
//
//      Note that ScriptXtoCP and ScriptCPtoX automatically apply caret
//      placement restictions.
//
//
//      SCRIPT_PROPERTIES.fNeedsWordBreaking
//
//      For most scripts, word break placement  may be
//      identified by scanning for characters marked as fWhiteSpace in
//      SCRIPT_LOGATTR, or for glyphs marked as uJustify ==
//      SCRIPT_JUSTIFY_BLANK or SCRIPT_JUSTIFY_ARABIC_BLANK in SCRIPT_VISATTR.
//
//      For languages such as Thai, it is also necessary to call ScriptBreak,
//      and include character positions marked as fWordStop in SCRIPT_LOGATTR.
//      Such scripts are marked as fNeedsWordbreaking in SCRIPT_PROPERTIES.
//
//
//      SCRIPT_PROPERTIES.fNeedsCharacterJustify
//
//      Languages such as Thai also require inter-character spacing when
//      justifying (where uJustify == SCRIPT_JUSTIFY_CHARACTER in the
//      SCRIPT_VISATTR). Such languages are marked as fNeedsCharacterJustify
//      in SCRIPT_PROPERTIES.
//
//
//      SCRIPT_PROPERTIES.fAmbiguousCharSet
//
//      Many Uniscribe scripts do not correspond directly to 8 bit character
//      sets. For example Unicode characters in the range U+100 through U+024F
//      represent extended latin shapes used for many languages, including
//      those supported by EASTEUROPE_CHARSET, TURKISH_CHARSET and
//      VIETNAMESE_CHARSET. However many of these characters are supported by
//      more han one of thsese charsets.
//      fAmbiguousCharset is set for any script token which could contain
//      characters from a number of these charsets. In these cases the bCharSet
//      field may contain ANSI_CHARSET or DEFAULT_CHARSET. The Uniscribe client
//      will generally need to apply futher processing to determine which charset
//      to use when requesting a font suitable for this run. For example it
//      determine that the run consists of multiple languages and split it up
//      to use a different font for each language.






/////   Notes on ScriptXtoCP and ScriptCPtoX
//
//      Both functions work only within runs and require the results of a
//      previous ScriptShape call.
//
//      The client must establish which run a given cursor offset or x
//      position is within before passing it to ScriptCPtoX or ScriptXtoCP.
//
//      Cluster information in the logical cluster array is used to share
//      the width of a cluster of glyphs equally among the logical characters
//      they represent.
//
//      For example, the lam alif glyph is divided into four areas: the
//      leading half of the lam, the trailing half of the lam, the leading
//      half of the alif and the trailing half of the alif.
//
//      ScriptXtoCP Understands the caret position conventions of each script.
//      For Indian and Thai, caret positions are snapped to cluster boundaries,
//      for Arabic and Hebrew, caret positions are interpolated within clusters.
//
//
/////   Translating mouse hit 'x' offset to caret position
//
//      Conventionally, caret position 'cp' may be selected by clicking either
//      on the trailing half of character 'cp-1' or on the leading half of
//      character 'cp'. This may easily be implemented as follows:
//
//c     int iCharPos;
//c     int iCaretPos
//c     int fTrailing;
//
//c     ScriptXtoCP(iMouseX, ..., &iCharPos, &fTrailing);
//c     iCaretPos = iCharPos + fTrailing;
//
//      For scripts that snap the caret to cluster boundaries, ScriptXtoCP
//      returns ftrailing set to either 0, or the width of the cluster in
//      codepoints. Thus the above code correctly returns only valid
//      caret positions.
//
//
/////   Displaying the caret in bidi strings
//
//      In unidirectional text, the leading edge of a character is at the same
//      place as the trailing edge of the previous character, so there is no
//      ambiguity in placing the caret between characters.
//
//      In bidirectional text, the caret position between runs of opposing
//      direction may be ambiguous.
//
//      For example in the left to right paragraph 'helloMAALAS', the last
//      letter of 'hello' immediately preceeds the first letter of 'salaam'.
//      The best position to display the caret depends on whether it is
//      considered to follow the 'o' of 'hello', or to preceed the 's' of
//      'salaam'.
//
/////   Commonly used caret positioning conventions
//
//t     Situation       | Visual caret placement
//t     ---------       | -------------------------------------------
//t     Typing          | Trailing edge of last character typed
//t     Pasting         | Trailing edge of last character pasted
//t     Caret advancing | Trailing edge of last character passed over
//t     Caret retiring  | Leading edge of last character passed over
//t     Home            | Leading edge of line
//t     End             | Trailing edge of line
//
//      The caret may be positioned as follows:
//
//c     if (advancing) {
//c         ScriptCPtoX(iCharPos-1, TRUE, ..., &iCaretX);
//c     } else {
//c         ScriptCPtoX(iCharPos, FALSE, ..., &iCaretX);
//c     }
//
//      Or, more simply, given an fAdvancing BOOL restricted to TRUE or FALSE:
//
//c     ScriptCPtoX(iCharPos-fAdvancing, fAdvancing, ..., &iCaretX);
//
//      ScriptCPtoX handles out of range positions logically: it returns the
//      leading edge of the run for iCharPos <0, and the trailing edge of the
//      run for iCharPos >=length.
/////   ScriptGetLogicalWidths
//
//      Converts visual withs in piAdvance into logical widths,
//      one per original character, in logical order.
//
//      Ligature glyphs widths are divided evenly amongst the characters
//      they represent.


__checkReturn HRESULT WINAPI ScriptGetLogicalWidths(
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,           // In   Script analysis from item attributes
    int                                         cChars,         // In   Count of logical codepoints in run
    int                                         cGlyphs,        // In   Count of glyphs in run
    __in_ecount(cGlyphs) const int              *piGlyphWidth,  // In   Advance widths
    __in_ecount(cChars) const WORD              *pwLogClust,    // In   Logical clusters
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In   Visual glyph attributes
    __in_ecount(cChars) int                     *piDx);         // Out  Logical widths






/////
//      ScriptGetLogicalWidths is useful for recording widths in a
//      font independant manner. By passing the recorded logical widths
//      to ScriptApplyLogicalWidths, a block of text can be replayed in the
//      same boundaries with acceptable loss of quality even when the original
//      font is not available.
/////   ScriptApplyLogicalWidth
//
//      Accepts an array of advance widths in logical order, corresponding
//      one to one with codepoints, and generates an array of glyph widths
//      suitable for passing to the piJustify parameter of ScriptTextOut.
//
//      ScriptApplyLogicalWidth may be used to reapply logical widths
//      obtained with ScriptGetLogicalWidths. It may be useful in situations
//      such as metafiling, where it is necessary to record and reapply
//      advance width information in a font independant manner.



__checkReturn HRESULT WINAPI ScriptApplyLogicalWidth(
    __in_ecount(cChars) const int               *piDx,          // In     Logical dx array to apply
    int                                         cChars,         // In     Count of logical codepoints in run
    int                                         cGlyphs,        // In     Glyph count
    __in_ecount(cChars) const WORD              *pwLogClust,    // In     Logical clusters
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In     Visual attributes from ScriptShape/Place
    __in_ecount(cGlyphs) const int              *piAdvance,     // In     Glyph advance widths from ScriptPlace
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,           // In     Script analysis from item attributes
    __inout_ecount_opt(1) ABC                   *pABC,          // InOut  Updated item ABC width (optional)
    __out_ecount_full(cGlyphs) int              *piJustify);    // Out    Resulting glyph advance widths for ScriptTextOut






/////
//p     piDx: Pointer to an array of dx widths in logical order, one per codepoint.
//
//p     cChars: Count of the logical codepoints in the run.
//
//p     cGlyphs: Glyph count.
//
//p     pwLogClust: Pointer to an array of logical clusters from ScriptShape
//
//p     psva: Pointer to an array of visual attributes from ScriptShape and
//          updated by ScriptPlace.
//
//p     piAdvance: Pointer to an array of glyph advance widths from ScriptPlace.
//
//p     psa: Pointer to a SCRIPT_ANALYSIS structure from ScriptItemize and
//          updated by ScriptShape and SriptPlace..
//
//p     pABC: Pointer to the run overall ABC width (optional). If present,
//          when the function is called, it should contain the run ABC width
//          returned by ScriptPlace; when the function returns, the ABC width
//          has been updated to match the new widths.
//
//p     piJustify:Pointer to an array of the resulting glyph advance widths.
//          This is suitable for passing to the piJustify parameter of ScriptTextOut.
/////   ScriptGetCMap
//
//      ScriptGetCMap may be used to determine which characters in a run
//      are supported by the selected font.
//
//      It returns glyph indices of Unicode characters according to Truetype
//      Cmap table, or standard Cmap implemented for old style fonts. The
//      glyph indices are returned in the same order as the input string.
//
//      The caller may scan the returned glyph buffer looking for the default
//      glyph to determine which characters are not available. (The default
//      glyph index for the selected font should be determined by calling
//      ScriptGetFontProperties).
//
//      The return value indicates the presence of any missing glyphs.


#define SGCM_RTL  0x00000001      // Return mirrored glyph for mirrorable Unicode codepoints


__checkReturn HRESULT WINAPI ScriptGetCMap(
    HDC                                     hdc,            // In    Optional (see notes on caching)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,           // InOut Address of Cache handle
    __in_ecount(cChars) const WCHAR         *pwcInChars,    // In    Unicode codepoint(s) to look up
    int                                     cChars,         // In    Number of characters
    DWORD                                   dwFlags,        // In    Flags such as SGCM_RTL
    __out_ecount(cChars) WORD               *pwOutGlyphs);  // Out   Array of glyphs, one per input character






/////
//  returns S_OK     - All unicode codepoints were present in the font
//          S_FALSE  - Some of the Unicode codepoints were mapped to the default glyph
//          E_HANDLE - font or system does not support glyph indices
/////   ScriptGetGlyphABCWidth
//
//      Returns ABC width of a given glyph.
//      May be useful for drawing glyph charts. Should not be used for
//      run of the mill complex script text formatting.


__checkReturn HRESULT WINAPI ScriptGetGlyphABCWidth(
    HDC                                     hdc,        // In    Optional (see notes on caching)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,       // InOut Address of Cache handle
    WORD                                    wGlyph,     // In    Glyph
    __out_ecount(1) ABC                     *pABC);     // Out   ABC width






/////
//  returns S_OK     - Glyph width returned
//          E_HANDLE - font or system does not support glyph indices
/////   SCRIPT_PROPERTIES
//
typedef struct {
    DWORD   langid                 :16; // Primary and sublanguage associated with script
    DWORD   fNumeric               :1;
    DWORD   fComplex               :1;  // Script requires special shaping or layout
    DWORD   fNeedsWordBreaking     :1;  // Requires ScriptBreak for word breaking information
    DWORD   fNeedsCaretInfo        :1;  // Requires caret restriction to cluster boundaries
    DWORD   bCharSet               :8;  // Charset to use when creating font
    DWORD   fControl               :1;  // Contains only control characters
    DWORD   fPrivateUseArea        :1;  // This item is from the Unicode range U+E000 through U+F8FF
    DWORD   fNeedsCharacterJustify :1;  // Requires inter-character justification
    DWORD   fInvalidGlyph          :1;  // Invalid combinations generate glyph wgInvalid in the glyph buffer
    DWORD   fInvalidLogAttr        :1;  // Invalid combinations are marked by fInvalid in the logical attributes
    DWORD   fCDM                   :1;  // Contains Combining Diacritical Marks
    DWORD   fAmbiguousCharSet      :1;  // Script does not correspond 1:1 with a charset
    DWORD   fClusterSizeVaries     :1;  // Measured cluster width depends on adjacent clusters
    DWORD   fRejectInvalid         :1;  // Invalid combinations should be rejected
} SCRIPT_PROPERTIES;
//
//p     langid: Language associated with this script. When a script is used for many languages,
//          langid id represents a default language. For example, Western script is represented
//          by LANG_ENGLISH although it is also used for French, German, Spanish etc.
//
//p     fNumeric: Script contains numerics and characters used in conjunction with numerics
//          by the rules of the Unicode bidirectional algorithm. For example
//          dollar sign and period are classified as numeric when adjacent to or in between
//          digits.
//
//p     fComplex: Indicates a script that requires complex script handling. If fComplex is false
//          the script contains no combining characters and requires no contextual shaping or reordering.
//
//p     fNeedsWordBreaking: A script, such as Thai, which requires algorithmic wordbreaking.
//          Use ScriptBreak to obtain a wordbreak points using the standard system wordbreaker.
//
//p     fNeedsCaretInfo: A script, such as Thai and Indian, where the caret may not be placed
//          inside a cluster. To determine valid caret positions inspect the fCharStop flag in the
//          logical attributes returned by ScriptBreak, or compare adjacent values in the pwLogClust
//          array returned by ScriptShape.
//
//p     bCharSet: Nominal charset associated with script. May be used in a logfont when creating
//          a font suitable for displaying this script. Note that for new scripts where there
//          is no charset defined, bCharSet may be innapropriate and DEFAULT_CHARSET should
//          be used instead - see the description of fAmbiguousCharSet below.
//
//p     fControl: contains control characters.
//
//p     fPrivateUseArea: The Unicode range U+E000 through U+F8FF.
//
//p     fNeedsCharacterJustify: A script, such as Thai, where justification is conventionally
//          achieved by increasing the space between all letters, not just between words.
//
//p     fInvalidGlyph: A script for which ScriptShape generates an invalid glyph
//          to represent invalid sequences. The glyph index of the invalid glyph for
//          a particular font may be obtained by calling ScriptGetFontProperties.
//
//p     fInvalidLogAttr: A script for which ScriptBreak sets the fInvalid flag
//          in the logical attributes to mark invalid sequences.
//
//p     fCDM: Implies that an item analysed by ScriptItemize included combining
//          diacritical marks (U+0300 through U+36F).
//
//p     fAmbiguousCharSet: No single legacy charset supports this script.
//          For example the extended Latin Extended-A Unicode range includes
//          characters from the EASTUROPE_CHARSET, the TURKISH_CHARSET and the
//          BALTIC_CHARSET. It also contains characters that are not available
//          in any legacy charset. Use DEFAULT_CHARSET when creating fonts to
//          display parts of this run.
//
//p     fClusterSizeVaries: A script, such as Arabic, where contextual shaping
//          may cause a string to increase in size when removing characters.
//
//p     fRejectInvalid: A script, such as Thai, where invalid sequences conventionally
//          cause an editor such as notepad to beep, and ignore keypresses.


/////   ScriptGetProperties
//
//      ScriptGetProperties returns the address of a table that maps a
//      script in a SCRIPT_ANALYSIS uScript field to properties including
//      the primary language associated with that script, whether it's
//      numeric and whether it's complex.


__checkReturn HRESULT WINAPI ScriptGetProperties(
    __deref_out_ecount(1) const SCRIPT_PROPERTIES   ***ppSp,        // Out  Receives pointer to table of pointers to properties indexed by script
    __out_ecount(1) int                             *piNumScripts); // Out  Receives number of scripts (valid values are 0 through NumScripts-1)






/////   SCRIPT_FONTPROPERTIES
//
typedef struct {
    int     cBytes;         // Structure length
    WORD    wgBlank;        // Blank glyph
    WORD    wgDefault;      // Glyph used for Unicode values not present in the font
    WORD    wgInvalid;      // Glyph used for invalid character combinations (especially in Thai)
    WORD    wgKashida;      // Shortest continuous kashida glyph in the font, -1 if doesn't exist
    int     iKashidaWidth;  // Widths of shortest continuous kashida glyph in the font
} SCRIPT_FONTPROPERTIES;


/////   ScriptGetFontProperties
//
//      Returns information from the font cache


__checkReturn HRESULT WINAPI ScriptGetFontProperties(
    HDC                                     hdc,    // In    Optional (see notes on caching)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,   // InOut Address of Cache handle
    __out_ecount(1) SCRIPT_FONTPROPERTIES   *sfp);  // Out   Receives properties for this font






/////   ScriptCacheGetHeight
//
//


__checkReturn HRESULT WINAPI ScriptCacheGetHeight(
    HDC                                     hdc,        // In    Optional (see notes on caching)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,       // InOut Address of Cache handle
    __out_ecount(1) long                    *tmHeight); // Out   Receives font height in pixels






/////   ScriptStringAnalyse
//
//
#define SSA_PASSWORD         0x00000001  // Input string contains a single character to be duplicated iLength times
#define SSA_TAB              0x00000002  // Expand tabs
#define SSA_CLIP             0x00000004  // Clip string at iReqWidth
#define SSA_FIT              0x00000008  // Justify string to iReqWidth
#define SSA_DZWG             0x00000010  // Provide representation glyphs for control characters
#define SSA_FALLBACK         0x00000020  // Use fallback fonts
#define SSA_BREAK            0x00000040  // Return break flags (character and word stops)
#define SSA_GLYPHS           0x00000080  // Generate glyphs, positions and attributes
#define SSA_RTL              0x00000100  // Base embedding level 1
#define SSA_GCP              0x00000200  // Return missing glyphs and LogCLust with GetCharacterPlacement conventions
#define SSA_HOTKEY           0x00000400  // Replace '&' with underline on subsequent codepoint
#define SSA_METAFILE         0x00000800  // Write items with ExtTextOutW Unicode calls, not glyphs
#define SSA_LINK             0x00001000  // Apply FE font linking/association to non-complex text
#define SSA_HIDEHOTKEY       0x00002000  // Remove first '&' from displayed string
#define SSA_HOTKEYONLY       0x00002400  // Display underline only.

#define SSA_FULLMEASURE      0x04000000  // Internal - calculate full width and out the number of chars can fit in iReqWidth.
#define SSA_LPKANSIFALLBACK  0x08000000  // Internal - enable FallBack for all LPK Ansi calls Except BiDi hDC calls
#define SSA_PIDX             0x10000000  // Internal
#define SSA_LAYOUTRTL        0x20000000  // Internal - Used when DC is mirrored
#define SSA_DONTGLYPH        0x40000000  // Internal - Used only by GDI during metafiling - Use ExtTextOutA for positioning
#define SSA_NOKASHIDA        0x80000000  // Internal - Used by GCP to justify the non Arabic glyphs only.
//
//
//p     SSA_HOTKEY: Note that SSA_HOTKEY and SSA_HIDEHOTKEY remove the
//          hotkey '&' character from further processing, so functions
//          such as ScriptString_pLogAttr return arrays based on a string
//          which excludes the '&'.




/////   SCRIPT_TABDEF
//
//      Defines tabstop positions for ScriptStringAnalyse (ignored unless SSA_TAB passed)
//
typedef struct tag_SCRIPT_TABDEF {
    int   cTabStops;        // Number of entries in pTabStops array
    int   iScale;           // Scale factor for pTabStops (see below)
    int  *pTabStops;        // Pointer to array of one or more tab stops
    int   iTabOrigin;       // Initial offset for tab stops (logical units)
} SCRIPT_TABDEF;
//
//
//p     cTabStops: Number of entries in the pTabStops array. If zero, tabstops
//          are every 8 average character widths. If one, all tabstops are
//          the length of the first entry in pTabStops. If more than one,
//          the first cTabStops are as specified in the pTabStops array,
//          subsequent tabstops are every 8 average characters from the last
//          tabstop in the array.
//
//p     iScale: Scale factor for iTabOrigin and pTabStops entries. Values are
//          converted to device coordinates by multiplying by iScale then
//          dividing by 4. If values are already in device units, set iScale to
//          4. If values are in dialog units, set iScale to the average char
//          width of the dialog font. If values are multiples of the average
//          character width for the selected font, set iScale to 0.
//
//p     pTabStops: Array of cTabStops entries. Each entry specifies a
//          tabstop position. Positive values give nearedge alignment,
//          negative values give faredge alignment.
//
//p     iTabOrigin: Tabs are considered to start iTabOrigin before the
//          beginning of the string. Helps with multiple tabbed
//          outputs on the same line.






/////   ScriptStringAnalyse
//
//      cString - Input string must contain at least one character
//
//      hdc - required if SSA_GLYPH requested. Optional for SSA_BREAK.
//      If present the current font in the hdc is inspected and if a symbolic
//      font the character string is treated as a single neutral SCRIPT_UNDEFINED item.
//
//      Note that the uBidiLevel field in the initial SCRIPT_STATE value
//      is ignored - the uBidiLevel used is derived from the SSA_RTL
//      flag in combination with the layout of the hdc.


typedef void* SCRIPT_STRING_ANALYSIS;


__checkReturn HRESULT WINAPI ScriptStringAnalyse(
    HDC                                             hdc,        //In  Device context (required)
    const void                                      *pString,   //In  String in 8 or 16 bit characters
    int                                             cString,    //In  Length in characters (Must be at least 1)
    int                                             cGlyphs,    //In  Required glyph buffer size (default cString*1.5 + 16)
    int                                             iCharset,   //In  Charset if an ANSI string, -1 for a Unicode string
    DWORD                                           dwFlags,    //In  Analysis required
    int                                             iReqWidth,  //In  Required width for fit and/or clip
    __in_ecount_opt(1) SCRIPT_CONTROL               *psControl, //In  Analysis control (optional)
    __in_ecount_opt(1) SCRIPT_STATE                 *psState,   //In  Analysis initial state (optional)
    __in_ecount_opt(cString) const int              *piDx,      //In  Requested logical dx array
    __in_ecount_opt(1) SCRIPT_TABDEF                *pTabdef,   //In  Tab positions (optional)
    const BYTE                                      *pbInClass, //In  Legacy GetCharacterPlacement character classifications (deprecated)
    __deref_out_ecount(1) SCRIPT_STRING_ANALYSIS    *pssa);     //Out Analysis of string






/////   ScriptStringFree - free a string analysis
//
//


__checkReturn HRESULT WINAPI ScriptStringFree(
    __deref_inout_ecount(1) SCRIPT_STRING_ANALYSIS  *pssa);  //InOut Address of pointer to analysis






/////   ScriptStringSize
//
//      returns a pointer to the size (width and height) of an analysed string
//
//      Note that the SIZE pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.


const SIZE* WINAPI ScriptString_pSize(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptString_pcOutChars
//
//      returns pointer to length of string after clipping (requires SSA_CLIP set)
//
//      Note that the int pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.


const int* WINAPI ScriptString_pcOutChars(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptString_pLogAttr
//
//      returns pointer to logical attributes buffer in a SCRIPT_STRING_ANALYSIS
//
//      Note that the buffer pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.
//
//      The logical attribute array contains *ScriptString_pcOutChars(ssa)
//      entries.


const SCRIPT_LOGATTR* WINAPI ScriptString_pLogAttr(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptStringGetOrder
//
//      Creates an array mapping original character position to glyph position.
//
//      Treats clusters as they were in legacy systems - Unless a cluster
//      contains more glyphs than codepoints, each glyph is referenced at
//      least once from the puOrder array.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.
//
//      The puOrder parameter should address a buffer containing room for
//      at least *ScriptString_pcOutChars(ssa) ints.


__checkReturn HRESULT WINAPI ScriptStringGetOrder(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,
    UINT                                    *puOrder); 






/////   ScriptStringCPtoX
//
//      Return x coordinate for leading or trailing edge of character icp.


__checkReturn HRESULT WINAPI ScriptStringCPtoX(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,        //In  String analysis
    int                                     icp,        //In  Caret character position
    BOOL                                    fTrailing,  //In  Which edge of icp
    __out_ecount(1) int                     *pX);       //Out Corresponding x offset






/////   ScriptStringXtoCP
//
//


__checkReturn HRESULT WINAPI ScriptStringXtoCP(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,            // In
    int                                     iX,             // In
    __out_ecount(1) int                     *piCh,          // Out
    __out_ecount(1) int                     *piTrailing);   // Out






/////   ScriptStringGetLogicalWidths
//
//      Converts visual withs in psa->piAdvance into logical widths,
//      one per original character, in logical order.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.
//
//      The piDx parameter should address a buffer containing room for
//      at least *ScriptString_pcOutChars(ssa) ints.


__checkReturn HRESULT WINAPI ScriptStringGetLogicalWidths(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,
    int                                     *piDx); 






/////   ScriptStringValidate
//
//      Scans the string analysis for invalid glyphs.
//
//      Only glyphs generated by scripts that can generate invalid glyphs
//      are scanned.
//
//      returns S_OK    - no invalid glyphs are present
//              S_FALSE - one or more invalid glyphs are present


__checkReturn HRESULT WINAPI ScriptStringValidate(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptStringOut
//
//      Displays the string generated by a prior ScriptStringAnalyze call,
//      then optionally adds highlighting corresponding to a logical selection.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.


__checkReturn HRESULT WINAPI ScriptStringOut(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,            //In  Analysis with glyphs
    int                                     iX,             //In
    int                                     iY,             //In
    UINT                                    uOptions,       //In  ExtTextOut options
    __in_ecount_opt(1) const RECT           *prc,           //In  Clipping rectangle (iff ETO_CLIPPED)
    int                                     iMinSel,        //In  Logical selection. Set iMinSel>=iMaxSel for no selection
    int                                     iMaxSel,        //In
    BOOL                                    fDisabled);     //In  If disabled, only the background is highlighted.






/////
//      uOptions may nclude only ETO_CLIPPED or ETO_OPAQUE.
/////   ScriptIsComplex
//
//      Determines whether a Unicode string requires complex script processing
//
//      The dwFlags parameter may include the following requests
//
#define SIC_COMPLEX     1   // Treat complex script letters as complex
#define SIC_ASCIIDIGIT  2   // Treat digits U+0030 through U+0039 as complex
#define SIC_NEUTRAL     4   // Treat neutrals as complex
//
//      SIC_COMPLEX: Should normally set. Causes complex script letters to
//      be treated as complex.
//
//      SIC_ASCIIDIGIT: Set this flag if the string would be displayed with
//      digit substitution enabled. If you are following the users NLS
//      settings using the ScriptRecordDigitSubstitution API, you can pass
//      scriptDigitSubstitute.DigitSubstitute != SCRIPT_DIGITSUBSTITUTE_NONE.
//
//      SIC_NEUTRAL: Set this flag if you may be displaying the string with
//      right-to-left reading order. When this flag is set, neutral characters
//      are considered as complex.
//
//
//      Returns S_OK     if string requires complex script processing,
//              S_FALSE  if string contains only characters laid out side by
//                       side from left to right.


__checkReturn HRESULT WINAPI ScriptIsComplex(
    __in_ecount(cInChars) const WCHAR   *pwcInChars,    //In  String to be tested
    int                                 cInChars,       //In  Length in characters
    DWORD                               dwFlags);       //In  Flags (see above)






/////   ScriptRecordDigitSubstitution
//
//      Reads NLS native digit and digit substitution settings and records
//      them in the SCRIPT_DIGITSUBSTITUTE structure.
//
//
typedef struct tag_SCRIPT_DIGITSUBSTITUTE {
    DWORD  NationalDigitLanguage    :16;   // Language for native substitution
    DWORD  TraditionalDigitLanguage :16;   // Language for traditional substitution
    DWORD  DigitSubstitute          :8;    // Substitution type
    DWORD  dwReserved;                     // Reserved
} SCRIPT_DIGITSUBSTITUTE;
//
//
//p     NationalDigitLanguage: Standard digits for the selected locale as
//          defined by the countries standard setting authority.
//
//p     TraditionalDigitLangauge: Digits originally used with the locales
//          script.
//
//p     DigitSubstitute: Selects between None, Context, National and
//          Traditional. See ScriptApplyDigitSubstitution below for
//          constant definitions.
//
//      Although most complex scripts have their own associated digits, many
//      countries using those scripts use western (so called
//      'Arabic') digits as their standard. NationalDigitLanguage reflects the
//      digits used as standard, and is set from
//      the NLS data for the locale.
//      On Windows 2000 the national digit langauge can be
//      adjusted to any digit script with the control panel/regional
//      options/numbers/Standard digits listbox.
//
//      The TraditionalDigitLanguage for a locale is derived directly from the
//      script used by that locale.


__checkReturn HRESULT WINAPI ScriptRecordDigitSubstitution(
    LCID                                    Locale,     // In   LOCALE_USER_DEFAULT or desired locale
    __out_ecount(1) SCRIPT_DIGITSUBSTITUTE  *psds);     // Out  Digit substitution settings






/////
//p     Locale: NLS locale to be queried. Should usually be set to
//          LOCALE_USER_DEFAULT. Alternatively may be passed as a locale
//          combined with LOCALE_NOUSEROVERRIDE to obtain default settings
//          for a given locale. Note that context digit substitution is
//          supported only in ARABIC and FARSI locales. In other locales,
//          context digit is mapped to no substitution.
//
//p     psds: Pointer to SCRIPT_DIGITSUBSTITUTE. This structure may be passed
//          later to ScriptApplyDigitSubstitution.
//
//p     returns: E_INVALIDARG if Locale is invalid or not installed. E_POINTER
//          if psds is NULL. Otherwise S_OK.
//
//      For performance reasons, you should not call
//      ScriptRecordDigitSubstitution frequently. In particular it would be a
//      considerable overhead to call it every time you call ScriptItemize
//      or ScriptStringAnalyse.
//
//      Instead, you may choose to save the SCRIPT_DIGITSUBSTITUTE
//      structure, and update it only when you receive a
//      WM_SETTINGCHANGE message or when a RegNotifyChangeKeyValue
//      call in a dedicated thread indicates a change in the registry
//      under HKCU\Control Panel\\International.
//
//      The normal way to call this function is simply
//
//c     SCRIPT_DIGITSUBSTITUTE sds;
//c     ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &sds);
//
//      Then every time you itemize, you'd use the results like this:
//
//c     SCRIPT_CONTROL  sc = {0};
//c     SCRIPT_STATE    ss = {0};
//
//c     ScriptApplyDigitSubstitution(&sds, &sc, &ss);
//
//
/////   ScriptApplyDigitSubstitution
//
//      Aplies the digit substitution settings recorded in a
//      SCRIPT_DIGIT_SUBSTITUTE structure to the SCRIPT_CONTROL and
//      SCRIPT_STATE structures.
//
//      The DigitSubstitute field of the SCRIPT_DIGITSUBSTITUTE structure
//      is normally set by ScriptRecordDigitSubstitution, however it may
//      be replaced by any one of the following values:
//
//
#define SCRIPT_DIGITSUBSTITUTE_CONTEXT      0  // Substitute to match preceeding letters
#define SCRIPT_DIGITSUBSTITUTE_NONE         1  // No substitution
#define SCRIPT_DIGITSUBSTITUTE_NATIONAL     2  // Substitute with official national digits
#define SCRIPT_DIGITSUBSTITUTE_TRADITIONAL  3  // Substitute with traditional digits of the locale
//
//
//p     SCRIPT_DIGITSUBSTITUTE_CONTEXT: Digits U+0030 - U+0039 will be
//          substituted according to the language of prior letters. Before
//          any letters, digits will be substituted according to the
//          TraditionalDigitLangauge field of the SCRIPT_DIGIT_SUBSTITUTE
//          structure. This field is normally set to the primary language of
//          the Locale passed to ScriptRecordDigitSubstitution.
//
//p     SCRIPT_DIGITSUBSTITUTE_NONE: Digits will not be substituted. Unicode
//          values U+0030 to U+0039 will be displayed with Arabic (i.e.
//          Western) numerals.
//
//p     SCRIPT_DIGITSUBSTITUTE_NATIONAL: Digits U+0030 - U+0039 will be
//          substituted according to the NationalDigitLangauge field of
//          the SCRIPT_DIGIT_SUBSTITUTE structure. This field is normally
//          set to the national digits returned for the NLS LCTYPE
//          LOCALE_SNATIVEDIGITS by ScriptRecordDigitSubstitution.
//
//p     SCRIPT_DIGITSUBSTITUTE_TRADITIONAL: Digits U+0030 - U+0039 will be
//          substituted according to the TraditionalDigitLangauge field of
//          the SCRIPT_DIGIT_SUBSTITUTE structure. This field is normally
//          set to the primary language of the Locale passed to
//          ScriptRecordDigitSubstitution.


__checkReturn HRESULT WINAPI ScriptApplyDigitSubstitution(
    __in_ecount(1) const SCRIPT_DIGITSUBSTITUTE *psds,  // In   Digit substitution settings
    __out_ecount(1) SCRIPT_CONTROL              *psc,   // Out  Script control structure
    __out_ecount(1) SCRIPT_STATE                *pss);  // Out  Script state structure






/////
//p     psds: Pointer to SCRIPT_DIGITSUBSTITUTE structure recorded earlier.
//          If NULL, ScriptApplyDigitSubstitution calls
//          ScriptRecordDigitSubstitution with LOCALE_USER_DEFAULT.
//
//p     psc: SCRIPT_CONTROL structure. The fContextDigits and uDefaultLanguage
//          fields will be updated.
//
//p     pss: SCRIPT_CONTROL structure. The fDigitSubstitute field will be
//          updated.
//
//p     returns: E_INVALIDARG if the DigitSubstitute field of the
//          SCRIPT_DIGITSUBSTITUTE structure is unrecognised, else S_OK;



//******************************************************
//
//          OpenType enabled Uniscribe APIs
//
//******************************************************

#ifndef UNISCRIBE_OPENTYPE
#if (_WIN32_WINNT >= 0x0600)
#define UNISCRIBE_OPENTYPE 0x0100
#endif
#endif

#if (UNISCRIBE_OPENTYPE >= 0x0100)

// 4-byte OpenType tag used to identify Script, LangSys or Feature
typedef ULONG OPENTYPE_TAG;

// Undefined script tag.
#define SCRIPT_TAG_UNKNOWN   0x00000000

// Single OpenType feature
typedef struct opentype_feature_record{

    OPENTYPE_TAG    tagFeature;     // Feature tag
    LONG            lParameter;     // Feature parameter (0 - disabled)

} OPENTYPE_FEATURE_RECORD;

// Set of OpenType properties applied to the range of characters
typedef struct textrange_properties{

    OPENTYPE_FEATURE_RECORD   *potfRecords;
    int                        cotfRecords;

} TEXTRANGE_PROPERTIES;

//
// Character properties
//
// Used by shaping engines to pass shaping information between calls
//
typedef struct script_charprop{

    WORD           fCanGlyphAlone : 1;

    WORD           reserved       : 15; // Reserved

} SCRIPT_CHARPROP;

//
// Glyph properties
//
typedef struct script_glyphprop{

    SCRIPT_VISATTR sva;
    WORD           reserved; // Reserved

} SCRIPT_GLYPHPROP;

// 
// ScriptShapeOpenType
// 
// New parameters comparing to ScriptShape:
//
// tagScript            - script tag to be used by OpenType layout
// tagLangSys           - language system tag to be used by OpenType layout
// rcRangeChars         - Number of characters in each range
//                                          (total should be equal to cChars)
//
// rpRangeProperties     - Range properties for each range
//
// cRanges              - Number of ranges
//
//
// New output parameters:
//
// pCharProps           - array of character properties, generated by Uniscribe
//
// pGlyphProps          - array of glyph properties, replaces visual attributes (4 bytes now)
// pfCanGlyphAlone      - flag per character, indicate that char can be shaped independently 
//
__checkReturn HRESULT WINAPI ScriptShapeOpenType(
    __in_opt                   HDC                     hdc,            // In    Optional (see under caching)
    __inout                    SCRIPT_CACHE           *psc,            // InOut Cache handle
    __inout                    SCRIPT_ANALYSIS        *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)

    __in                       OPENTYPE_TAG            tagScript,      // In    Font script tag for shaping
    __in                       OPENTYPE_TAG            tagLangSys,     // In    Font language system tag for shaping
    __in_ecount_opt(cRanges)   int                    *rcRangeChars,      // In    Array of number of characters per range
    __in_ecount_opt(cRanges)   TEXTRANGE_PROPERTIES  **rpRangeProperties, // In    Array of range properties (for each range)
    __in                       int                     cRanges,           // In    Number of ranges

    __in_ecount(cChars)        const WCHAR            *pwcChars,       // In    Logical unicode run
    __in                       int                     cChars,         // In    Length of unicode run
    __in                       int                     cMaxGlyphs,     // In    Max glyphs to generate

    __out_ecount_full(cChars)  WORD                   *pwLogClust,     // Out   Logical clusters
    __out_ecount_full(cChars)  SCRIPT_CHARPROP        *pCharProps,     // Out   Output buffer for character properties
    
    __out_ecount_part(cMaxGlyphs, *pcGlyphs) WORD                   *pwOutGlyphs,    // Out   Output glyph buffer
    __out_ecount_part(cMaxGlyphs, *pcGlyphs) SCRIPT_GLYPHPROP       *pOutGlyphProps, // Out   Visual glyph attributes
    __out                                    int                    *pcGlyphs);      // Out   Count of glyphs generated

// 
// ScriptPlaceOpenType
// 
// New parameters comparing to ScriptPlace:
//
// tagScript            - script tag to be used by OpenType layout
// tagLangSys           - language system tag to be used by OpenType layout
// rcRangeChars         - Number of characters in each range
//                                          (total should be equal to cChars)
//
// rpRangeProperties    - Range properties for each range
//
// cRanges              - Number of ranges
//
//
// New output parameters:
//
// Character information - pwcChars, pwLogClust, pCharProps are now passed to ScriptPlace
// pGlyphProps           - array of glyph properties, replaces visual attributes (4 bytes now)
//
__checkReturn HRESULT WINAPI ScriptPlaceOpenType(
    __in_opt                   HDC                     hdc,            // In    Optional (see under caching)
    __inout                    SCRIPT_CACHE           *psc,            // InOut Cache handle
    __inout                    SCRIPT_ANALYSIS        *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)

    __in                       OPENTYPE_TAG            tagScript,      // In    Font script tag for shaping
    __in                       OPENTYPE_TAG            tagLangSys,     // In    Font language system tag for shaping
    __in_ecount_opt(cRanges)   int                    *rcRangeChars,      // In    Array of number of characters per range
    __in_ecount_opt(cRanges)   TEXTRANGE_PROPERTIES  **rpRangeProperties, // In    Array of range properties (for each range)
    __in                       int                     cRanges,           // In    Number of ranges

    __in_ecount(cChars)        const WCHAR            *pwcChars,       // In    Logical unicode run
    __in_ecount(cChars)        WORD                   *pwLogClust,     // In    Logical clusters
    __in_ecount(cChars)        SCRIPT_CHARPROP        *pCharProps,     // In    Output buffer for character properties
    __in                       int                     cChars,         // In    Length of unicode run
    
    __in_ecount(cGlyphs)       const WORD             *pwGlyphs,       // In    Glyph buffer from prior ScriptShape call
    __in_ecount(cGlyphs)       const SCRIPT_GLYPHPROP *pGlyphProps,    // In    Glyph properties
    __in                       int                     cGlyphs,        // In    Number of glyphs
    
    __out_ecount_full(cGlyphs) int                    *piAdvance,      // Out   Advance widths
    __out_ecount_full(cGlyphs) GOFFSET                *pGoffset,       // Out   x,y offset for combining glyph
    __out_opt                  ABC                    *pABC);          // Out   Composite ABC for the whole run (Optional)

//
// ScriptItemizeOpenType
//
// New parameter comapring to ScriptItemize:
//
// pScriptTags -- array parallel to items, contains script tags
//                                              to be passed to ScriptShapeOpenType.
//
__checkReturn HRESULT WINAPI ScriptItemizeOpenType(
    __in_ecount(cInChars) const WCHAR                   *pwcInChars,    // In   Unicode string to be itemized
    __in                  int                            cInChars,      // In   Codepoint count to itemize
    __in                  int                            cMaxItems,     // In   Max length of itemization array
    __in_opt              const SCRIPT_CONTROL          *psControl,     // In   Analysis control (optional)
    __in_opt              const SCRIPT_STATE            *psState,       // In   Initial bidi algorithm state (optional)
    __out_ecount_part(cMaxItems, *pcItems) SCRIPT_ITEM  *pItems,        // Out  Array to receive itemization
    __out_ecount_part(cMaxItems, *pcItems) OPENTYPE_TAG *pScriptTags,   // Out  Array of script tags - parallel to items
    __out                 int                           *pcItems);      // Out  Count of items processed (optional)


// ScriptGetFontScriptList
// 
// Returns list of script tags supported by layout tables. 
// Only scripts that can be shaped by eScript will be returned ( or full list if psa==NULL).
// Usually complex scripts return single tag and neutral (like digits) return all tags from the font
//
// Note: If tag coresponding to some script is present it does not guarantee
//       that font won't be rejected by particular shaping engine because 
//       shaping engine may require particular language system or feature
//       to be present.
//
__checkReturn HRESULT WINAPI ScriptGetFontScriptTags(
    __in_opt           HDC                              hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE                    *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS                 *psa,             // In    Result of ScriptItemize (can be NULL)
    __in               int                              cMaxTags,        // In    Length of pScriptTags array
    __out_ecount_part(cMaxTags, *pcTags) OPENTYPE_TAG  *pScriptTags,     // Out:  list of script tags in the font
    __out              int                             *pcTags           // Out:  Number of tags returned
);

//
// ScriptGetFontLanguageTags
// 
// Returns list of language system tags supported by layout tables for particular script.
//
__checkReturn HRESULT WINAPI ScriptGetFontLanguageTags(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    
    __in               int                    cMaxTags,        // In    Length of pLangsys tags array
    __out_ecount_part(cMaxTags, *pcTags) OPENTYPE_TAG *pLangsysTags,    // Out:  list of Langsys tags in the font
    __out              int                   *pcTags           // Out:  Number of tags returned
);

//
// ScriptGetFontFeatureTags
// 
// Returns list of feature tags supported by layout tables for particular language system.
//
// This method will hide features that are language specific, because they are 
// controlled by shaping engines and can not be switched on or off by the client.
// Example of such features are initial, medial and final forms for Arabic script
//
// If psa==NULL function returns unfiltered feature list
//
__checkReturn HRESULT WINAPI ScriptGetFontFeatureTags(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    __in               OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    
    __in               int                    cMaxTags,        // In    Length of pLangsys tags array
    __out_ecount_part(cMaxTags, *pcTags) OPENTYPE_TAG *pFeatureTags,   // Out:  list of feature tags in the font
    __out              int                   *pcTags           // Out:  Number of tags returned
);

//
//  ScriptGetFontAlternateGlyphs
// 
//  Returns list alternates for particular glyph. 
//
//  Original glyph is always added as a first element. Index in this array 
//  is exactly the feature parameter that should be passed to ScriptShape.
//
//  To get variants it is a good idea to reshape input without feature 
//  applied to current glyph so it will be always alternates for default 
//  glyph for this position. Original glyph could have variants, while 
//  variants may not. So UI will stick with this final form wihtout ability 
//  to choose another one.
//
//  Note: It theoretically can be emulated by ScriptSubstituteSingleGlyph. 
//        Just try parameters one by one while glyphs are substituted.
//
__checkReturn HRESULT WINAPI ScriptGetFontAlternateGlyphs(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    __in               OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    __in               OPENTYPE_TAG           tagFeature,      // In    Feature tag to test for alternates
    
    __in               WORD                   wGlyphId,        // In    Original glyph
    
    __in               int                    cMaxAlternates,  // In    Length of pAlternateGlyphs tags array
    __out_ecount_part(cMaxAlternates, *pcAlternates) WORD *pAlternateGlyphs, // Out:  list of feature tags in the font
    __out              int                   *pcAlternates     // Out:  Number of alternates returned
);

//
//  ScriptSubstituteSingleGlyph
//
//  Apply partcular feature to single glyph, assuming that 
//  expected result is one-to-one substitution
//
__checkReturn HRESULT WINAPI ScriptSubstituteSingleGlyph(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    __in               OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    __in               OPENTYPE_TAG           tagFeature,      // In    Feature tag to test for alternates
    __in               LONG                   lParameter,      // In    Feature parameter

    __in               WORD                   wGlyphId,         // In    Original glyph id
    __out              WORD                  *pwOutGlyphId      // Out   Substituted glyph id
);

//
//  ScriptPositionSingleGlyph
//
//  Apply particular feature to single glyph, assuming that 
//  expected result is single position adjustment.
//
__checkReturn HRESULT WINAPI ScriptPositionSingleGlyph(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    __in               OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    __in               OPENTYPE_TAG           tagFeature,      // In    Feature tag to test for alternates
    __in               LONG                   lParameter,      // In    Feature parameter

    __in               WORD                   wGlyphId,         // In    Glyph id to be moved
    __in               int                    iAdvance,         // In    Original glyph advance width
    __in               GOFFSET                GOffset,          // In    Original glyph offset
    
    __out              int                   *piOutAdvance,     // Out   Adjusted advance width
    __out              GOFFSET               *pOutGoffset       // Out   Adjusted offset
);

#endif // (UNISCRIBE_OPENTYPE >= 0x0100)

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Uxtheme.h ===
//---------------------------------------------------------------------------
//
// uxtheme.h - theming API header file.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//---------------------------------------------------------------------------

#ifndef _UXTHEME_H_
#define _UXTHEME_H_

#include <commctrl.h>
#include <SpecStrings.h>

#ifndef THEMEAPI
#if !defined(_UXTHEME_)
#define THEMEAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define THEMEAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define THEMEAPI          STDAPI
#define THEMEAPI_(type)   STDAPI_(type)
#endif /* _UXTHEME_ */
#endif /* THEMEAPI */

typedef HANDLE HTHEME;          // handle to a section of theme data for class

#if (_WIN32_WINNT >= 0x0600)
#define MAX_THEMECOLOR  64
#define MAX_THEMESIZE   64
#endif

#if (NTDDI_VERSION>= NTDDI_WIN7)
//---------------------------------------------------------------------------
// BeginPanningFeedback - Visual feedback init function related to pan gesture
//   - internally called by DefaultGestureHandler
//   - called by application
//
//  HWND hwnd - The handle to the Target window that will receive feedback
//                                                                                                 
//---------------------------------------------------------------------------
BOOL WINAPI 
BeginPanningFeedback(
__in HWND hwnd); 
//---------------------------------------------------------------------------
// UpdatePanningFeedback : Visual feedback function related to pan gesture
// Can Be called only after a BeginPanningFeedback call 
//   - internally called by DefaultGestureHandler
//   - called by application
//
// HWND hwnd                 - The handle to the Target window that will receive feedback                                                
//                             For the method to succeed this must be the same hwnd as provided in 
//                             BeginPanningFeedback
//  
// LONG lTotalOverpanOffsetX - The Total displacement that the window has moved in the horizontal direction
//                             since the end of scrollable region was reached. The API would move the window by the distance specified                                                  
//                             A maximum displacement of 30 pixels is allowed
//
// LONG lTotalOverpanOffsetY - The Total displacement that the window has moved in the horizontal direction
//                             since the end of scrollable
//                             region was reached. The API would move the window by the distance specified                                                
//                             A maximum displacement of 30 pixels is allowed
//           
// BOOL fInInertia           - Flag dictating whether the Application is handling a WM_GESTURE message with the 
//                             GF_INERTIA FLAG set 
//
//   Incremental calls to UpdatePanningFeedback should make sure they always pass
//   the sum of the increments and not just the increment themselves
//   Eg : If the initial displacement is 10 pixels and the next displacement 10 pixels
//        the second call would be with the parameter as 20 pixels as opposed to 10
//   Eg : UpdatePanningFeedback(hwnd, 10, 10, TRUE)
// 
BOOL WINAPI
UpdatePanningFeedback(
	__in HWND hwnd,
	__in LONG lTotalOverpanOffsetX, 
	__in LONG lTotalOverpanOffsetY, 
	__in BOOL fInInertia);

//---------------------------------------------------------------------------
//
// EndPanningFeedback :Visual feedback reset function related to pan gesture
//   - internally called by DefaultGestureHandler
//   - called by application
//   Terminates any existing animation that was in process or set up by BeginPanningFeedback and UpdatePanningFeedback
//   The EndPanningFeedBack needs to be called Prior to calling any BeginPanningFeedBack if we have already
//   called a BeginPanningFeedBack followed by one/ more UpdatePanningFeedback calls
//
//  HWND hwnd         - The handle to the Target window that will receive feedback
//
//  BOOL fAnimateBack - Flag to indicate whether you wish the displaced window to move back
//                      to the original position via animation or a direct jump.
//                      Either ways the method will try to restore the moved window.
//                      The latter case exists for compatibility with legacy apps. 
//
BOOL WINAPI
EndPanningFeedback(
	__in HWND hwnd, 
	__in BOOL fAnimateBack);
#endif

//---------------------------------------------------------------------------
// NOTE: PartId's and StateId's used in the theme API are defined in the 
//       hdr file <vssym32.h> using the TM_PART and TM_STATE macros.  For
//       example, "TM_PART(BP, PUSHBUTTON)" defines the PartId "BP_PUSHBUTTON".

//---------------------------------------------------------------------------
//  OpenThemeData()     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME)
OpenThemeData(
    HWND hwnd,
    LPCWSTR pszClassList
    );

#define OTD_FORCE_RECT_SIZING   0x00000001          // make all parts size to rect
#define OTD_NONCLIENT           0x00000002          // set if hTheme to be used for nonclient area
#define OTD_VALIDBITS           (OTD_FORCE_RECT_SIZING | \
                                 OTD_NONCLIENT)

//---------------------------------------------------------------------------
//  OpenThemeDataEx     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//
//  dwFlags              - allows certain overrides of std features
//                         (see OTD_XXX defines above)
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME)
OpenThemeDataEx(
    HWND hwnd,
    LPCWSTR pszClassList,
    DWORD dwFlags
    );

//---------------------------------------------------------------------------
//  CloseThemeData()    - closes the theme data handle.  This should be done 
//                        when the window being themed is destroyed or
//                        whenever a WM_THEMECHANGED msg is received 
//                        (followed by an attempt to create a new Theme data 
//                        handle).
//
//  hTheme              - open theme data handle (returned from prior call
//                        to OpenThemeData() API).
//---------------------------------------------------------------------------
THEMEAPI
CloseThemeData(
    HTHEME hTheme
    );

//---------------------------------------------------------------------------
//    functions for basic drawing support 
//---------------------------------------------------------------------------
// The following methods are the theme-aware drawing services.
// Controls/Windows are defined in drawable "parts" by their author: a 
// parent part and 0 or more child parts.  Each of the parts can be 
// described in "states" (ex: disabled, hot, pressed).  
//---------------------------------------------------------------------------
// For the list of all themed classes and the definition of all
// parts and states, see the file "tmschmea.h".
//---------------------------------------------------------------------------
// Each of the below methods takes a "iPartId" param to specify the 
// part and a "iStateId" to specify the state of the part.  
// "iStateId=0" refers to the root part.  "iPartId" = "0" refers to 
// the root class.  
//-----------------------------------------------------------------------
// Note: draw operations are always scaled to fit (and not to exceed)  
// the specified "Rect".
//-----------------------------------------------------------------------

//------------------------------------------------------------------------
//  DrawThemeBackground()   
//                      - draws the theme-specified border and fill for 
//                        the "iPartId" and "iStateId".  This could be 
//                        based on a bitmap file, a border and fill, or 
//                        other image description.  
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pRect               - defines the size/location of the part
//  pClipRect           - optional clipping rect (don't draw outside it)
//------------------------------------------------------------------------
THEMEAPI
DrawThemeBackground(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    __in_opt LPCRECT pClipRect
    );

//------------------------------------------------------------------------
//---- bits used in dwFlags of DTBGOPTS ----
#define DTBG_CLIPRECT           0x00000001  // rcClip has been specified
#define DTBG_DRAWSOLID          0x00000002  // DEPRECATED: draw transparent/alpha images as solid
#define DTBG_OMITBORDER         0x00000004  // don't draw border of part
#define DTBG_OMITCONTENT        0x00000008  // don't draw content area of part
#define DTBG_COMPUTINGREGION    0x00000010  // TRUE if calling to compute region
#define DTBG_MIRRORDC           0x00000020  // assume the hdc is mirrorred and
                                            // flip images as appropriate (currently 
                                            // only supported for bgtype=imagefile)
#define DTBG_NOMIRROR           0x00000040  // don't mirror the output, overrides everything else 
#define DTBG_VALIDBITS          (DTBG_CLIPRECT | \
                                 DTBG_DRAWSOLID | \
                                 DTBG_OMITBORDER | \
                                 DTBG_OMITCONTENT | \
                                 DTBG_COMPUTINGREGION | \
                                 DTBG_MIRRORDC | \
                                 DTBG_NOMIRROR)

typedef struct _DTBGOPTS
{
    DWORD dwSize;           // size of the struct
    DWORD dwFlags;          // which options have been specified
    RECT rcClip;            // clipping rectangle
} DTBGOPTS, *PDTBGOPTS;

//------------------------------------------------------------------------
//  DrawThemeBackgroundEx()   
//                      - draws the theme-specified border and fill for 
//                        the "iPartId" and "iStateId".  This could be 
//                        based on a bitmap file, a border and fill, or 
//                        other image description.  NOTE: This will be
//                        merged back into DrawThemeBackground() after 
//                        BETA 2.
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pRect               - defines the size/location of the part
//  pOptions            - ptr to optional params
//------------------------------------------------------------------------
THEMEAPI
DrawThemeBackgroundEx(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    __in_opt const DTBGOPTS *pOptions
    );

//---------------------------------------------------------------------------
//----- DrawThemeText() flags ----
#define DTT_GRAYED              0x00000001          // draw a grayed-out string (this is deprecated)
#define DTT_FLAGS2VALIDBITS     (DTT_GRAYED)

//-------------------------------------------------------------------------
//  DrawThemeText()     - draws the text using the theme-specified 
//                        color and font for the "iPartId" and 
//                        "iStateId".  
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pszText             - actual text to draw
//  dwCharCount         - number of chars to draw (-1 for all)
//  dwTextFlags         - same as DrawText() "uFormat" param
//  dwTextFlags2        - additional drawing options 
//  pRect               - defines the size/location of the part
//-------------------------------------------------------------------------
THEMEAPI
DrawThemeText(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __in_ecount(cchText) LPCWSTR pszText,
    int cchText,
    DWORD dwTextFlags,
    DWORD dwTextFlags2,
    LPCRECT pRect
    );

//-------------------------------------------------------------------------
//  GetThemeBackgroundContentRect()
//                      - gets the size of the content for the theme-defined 
//                        background.  This is usually the area inside
//                        the borders or Margins.  
//
//      hTheme          - theme data handle
//      hdc             - (optional) device content to be used for drawing
//      iPartId         - part number to draw
//      iStateId        - state number (of the part) to draw
//      pBoundingRect   - the outer RECT of the part being drawn
//      pContentRect    - RECT to receive the content area
//-------------------------------------------------------------------------
THEMEAPI
GetThemeBackgroundContentRect(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pBoundingRect,
    __out LPRECT pContentRect
    );

//-------------------------------------------------------------------------
//  GetThemeBackgroundExtent() - calculates the size/location of the theme-
//                               specified background based on the 
//                               "pContentRect".
//
//      hTheme          - theme data handle
//      hdc             - (optional) device content to be used for drawing
//      iPartId         - part number to draw
//      iStateId        - state number (of the part) to draw
//      pContentRect    - RECT that defines the content area
//      pBoundingRect   - RECT to receive the overall size/location of part
//-------------------------------------------------------------------------
THEMEAPI
GetThemeBackgroundExtent(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pContentRect,
    __out LPRECT pExtentRect
    );

//-------------------------------------------------------------------------
//  GetThemeBackgroundRegion()
//                      - computes the region for a regular or partially 
//                        transparent theme-specified background that is 
//                        bound by the specified "pRect".
//                        If the rectangle is empty, sets the HRGN to NULL 
//                        and return S_FALSE.
//
//  hTheme              - theme data handle
//  hdc                 - optional HDC to draw into (DPI scaling)
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  pRect               - the RECT used to draw the part
//  pRegion             - receives handle to calculated region
//-------------------------------------------------------------------------
THEMEAPI
GetThemeBackgroundRegion(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    __out HRGN *pRegion
    );

enum THEMESIZE
{
    TS_MIN,             // minimum size
    TS_TRUE,            // size without stretching
    TS_DRAW             // size that theme mgr will use to draw part
};

//-------------------------------------------------------------------------
//  GetThemePartSize() - returns the specified size of the theme part
//
//  hTheme              - theme data handle
//  hdc                 - HDC to select font into & measure against
//  iPartId             - part number to retrieve size for
//  iStateId            - state number (of the part) 
//  prc                 - (optional) rect for part drawing destination
//  eSize               - the type of size to be retreived
//  psz                 - receives the specified size of the part 
//-------------------------------------------------------------------------
THEMEAPI
GetThemePartSize(
    HTHEME hTheme,
    __in_opt HDC hdc,
    int iPartId,
    int iStateId,
    __in_opt LPCRECT prc,
    enum THEMESIZE eSize,
    __out SIZE *psz
    );

//-------------------------------------------------------------------------
//  GetThemeTextExtent() - calculates the size/location of the specified 
//                         text when rendered in the Theme Font. 
//
//  hTheme              - theme data handle
//  hdc                 - HDC to select font & measure into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  pszText             - the text to be measured
//  dwCharCount         - number of chars to draw (-1 for all)
//  dwTextFlags         - same as DrawText() "uFormat" param
//  pszBoundingRect     - optional: to control layout of text
//  pszExtentRect       - receives the RECT for text size/location
//-------------------------------------------------------------------------
THEMEAPI
GetThemeTextExtent(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __in_ecount(cchCharCount) LPCWSTR pszText,
    int cchCharCount,
    DWORD dwTextFlags,
    __in_opt LPCRECT pBoundingRect,
    __out LPRECT pExtentRect
    );

//-------------------------------------------------------------------------
//  GetThemeTextMetrics()
//                      - returns info about the theme-specified font
//                        for the part/state passed in.
//
//  hTheme              - theme data handle
//  hdc                 - optional: HDC for screen context
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  ptm                 - receives the font info
//-------------------------------------------------------------------------
THEMEAPI
GetThemeTextMetrics(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __out TEXTMETRICW *ptm
    );

//-------------------------------------------------------------------------
//----- HitTestThemeBackground, HitTestThemeBackgroundRegion flags ----

//  Theme background segment hit test flag (default). possible return values are:
//  HTCLIENT: hit test succeeded in the middle background segment
//  HTTOP, HTLEFT, HTTOPLEFT, etc:  // hit test succeeded in the the respective theme background segment.
#define HTTB_BACKGROUNDSEG          0x00000000
//  Fixed border hit test option.  possible return values are:
//  HTCLIENT: hit test succeeded in the middle background segment
//  HTBORDER: hit test succeeded in any other background segment
#define HTTB_FIXEDBORDER            0x00000002      // Return code may be either HTCLIENT or HTBORDER. 
//  Caption hit test option.  Possible return values are:
//  HTCAPTION: hit test succeeded in the top, top left, or top right background segments
//  HTNOWHERE or another return code, depending on absence or presence of accompanying flags, resp.
#define HTTB_CAPTION                0x00000004
//  Resizing border hit test flags.  Possible return values are:
//  HTCLIENT: hit test succeeded in middle background segment
//  HTTOP, HTTOPLEFT, HTLEFT, HTRIGHT, etc:    hit test succeeded in the respective system resizing zone
//  HTBORDER: hit test failed in middle segment and resizing zones, but succeeded in a background border segment
#define HTTB_RESIZINGBORDER_LEFT    0x00000010      // Hit test left resizing border, 
#define HTTB_RESIZINGBORDER_TOP     0x00000020      // Hit test top resizing border
#define HTTB_RESIZINGBORDER_RIGHT   0x00000040      // Hit test right resizing border
#define HTTB_RESIZINGBORDER_BOTTOM  0x00000080      // Hit test bottom resizing border
#define HTTB_RESIZINGBORDER         (HTTB_RESIZINGBORDER_LEFT | \
                                     HTTB_RESIZINGBORDER_TOP | \
                                     HTTB_RESIZINGBORDER_RIGHT | \
                                     HTTB_RESIZINGBORDER_BOTTOM)
// Resizing border is specified as a template, not just window edges.
// This option is mutually exclusive with HTTB_SYSTEMSIZINGWIDTH; HTTB_SIZINGTEMPLATE takes precedence  
#define HTTB_SIZINGTEMPLATE         0x00000100
// Use system resizing border width rather than theme content margins.   
// This option is mutually exclusive with HTTB_SIZINGTEMPLATE, which takes precedence.
#define HTTB_SYSTEMSIZINGMARGINS    0x00000200

//-------------------------------------------------------------------------
//  HitTestThemeBackground()
//                      - returns a HitTestCode (a subset of the values 
//                        returned by WM_NCHITTEST) for the point "ptTest" 
//                        within the theme-specified background
//                        (bound by pRect).  "pRect" and "ptTest" should 
//                        both be in the same coordinate system 
//                        (client, screen, etc).
//
//      hTheme          - theme data handle
//      hdc             - HDC to draw into
//      iPartId         - part number to test against
//      iStateId        - state number (of the part) 
//      pRect           - the RECT used to draw the part
//      hrgn            - optional region to use; must be in same coordinates as
//                      -    pRect and pTest.
//      ptTest          - the hit point to be tested
//      dwOptions       - HTTB_xxx constants
//      pwHitTestCode   - receives the returned hit test code - one of:
//  
//                        HTNOWHERE, HTLEFT, HTTOPLEFT, HTBOTTOMLEFT,
//                        HTRIGHT, HTTOPRIGHT, HTBOTTOMRIGHT,
//                        HTTOP, HTBOTTOM, HTCLIENT
//-------------------------------------------------------------------------
THEMEAPI
HitTestThemeBackground(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    DWORD dwOptions,
    LPCRECT pRect,
    HRGN hrgn,
    POINT ptTest,
    __out WORD *pwHitTestCode
    );

//------------------------------------------------------------------------
//  DrawThemeEdge()     - Similar to the DrawEdge() API, but uses part colors
//                        and is high-DPI aware
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number of part
//  pDestRect           - the RECT used to draw the line(s)
//  uEdge               - Same as DrawEdge() API
//  uFlags              - Same as DrawEdge() API
//  pContentRect        - Receives the interior rect if (uFlags & BF_ADJUST)
//------------------------------------------------------------------------
THEMEAPI
DrawThemeEdge(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pDestRect,
    UINT uEdge,
    UINT uFlags,
    __out_opt LPRECT pContentRect
    );

//------------------------------------------------------------------------
//  DrawThemeIcon()     - draws an image within an imagelist based on 
//                        a (possible) theme-defined effect. 
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number of part
//  pRect               - the RECT to draw the image within
//  himl                - handle to IMAGELIST 
//  iImageIndex         - index into IMAGELIST (which icon to draw)
//------------------------------------------------------------------------
THEMEAPI
DrawThemeIcon(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    HIMAGELIST himl,
    int iImageIndex
    );

//---------------------------------------------------------------------------
//  IsThemePartDefined() - returns TRUE if the theme has defined parameters
//                         for the specified "iPartId" and "iStateId".
//
//  hTheme              - theme data handle
//  iPartId             - part number to find definition for
//  iStateId            - state number of part
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemePartDefined(
    HTHEME hTheme,
    int iPartId,
    int iStateId
    );

//---------------------------------------------------------------------------
//  IsThemeBackgroundPartiallyTransparent()
//                      - returns TRUE if the theme specified background for 
//                        the part/state has transparent pieces or 
//                        alpha-blended pieces.
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemeBackgroundPartiallyTransparent(
    HTHEME hTheme,
    int iPartId,
    int iStateId
    );

//---------------------------------------------------------------------------
//    lower-level theme information services
//---------------------------------------------------------------------------
// The following methods are getter routines for each of the Theme Data types.
// Controls/Windows are defined in drawable "parts" by their author: a 
// parent part and 0 or more child parts.  Each of the parts can be 
// described in "states" (ex: disabled, hot, pressed).  
//---------------------------------------------------------------------------
// Each of the below methods takes a "iPartId" param to specify the 
// part and a "iStateId" to specify the state of the part.  
// "iStateId=0" refers to the root part.  "iPartId" = "0" refers to 
// the root class.  
//-----------------------------------------------------------------------
// Each method also take a "iPropId" param because multiple instances of 
// the same primitive type can be defined in the theme schema.
//-----------------------------------------------------------------------

//-----------------------------------------------------------------------
//  GetThemeColor()     - Get the value for the specified COLOR property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pColor              - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeColor(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out COLORREF *pColor
    );

//-----------------------------------------------------------------------
//  GetThemeMetric()    - Get the value for the specified metric/size
//                        property
//
//  hTheme              - theme data handle
//  hdc                 - (optional) hdc to be drawn into (DPI scaling)
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeMetric(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    __out int *piVal
    );

//-----------------------------------------------------------------------
//  GetThemeString()    - Get the value for the specified string property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pszBuff             - receives the string property value
//  cchMaxBuffChars     - max. number of chars allowed in pszBuff
//-----------------------------------------------------------------------
THEMEAPI
GetThemeString(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out_ecount(cchMaxBuffChars) LPWSTR pszBuff,
    int cchMaxBuffChars
    );

//-----------------------------------------------------------------------
//  GetThemeBool()      - Get the value for the specified BOOL property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pfVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeBool(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out BOOL *pfVal
    );

//-----------------------------------------------------------------------
//  GetThemeInt()       - Get the value for the specified int property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeInt(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out int *piVal
    );

//-----------------------------------------------------------------------
//  GetThemeEnumValue() - Get the value for the specified ENUM property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the enum (cast to int*)
//-----------------------------------------------------------------------
THEMEAPI
GetThemeEnumValue(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out int *piVal
    );

//-----------------------------------------------------------------------
//  GetThemePosition()  - Get the value for the specified position
//                        property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pPoint              - receives the value of the position property
//-----------------------------------------------------------------------
THEMEAPI
GetThemePosition(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out POINT *pPoint
    );

//-----------------------------------------------------------------------
//  GetThemeFont()      - Get the value for the specified font property
//
//  hTheme              - theme data handle
//  hdc                 - (optional) hdc to be drawn to (DPI scaling)
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pFont               - receives the value of the LOGFONT property
//                        (scaled for the current logical screen dpi) 
//-----------------------------------------------------------------------
THEMEAPI
GetThemeFont(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    __out LOGFONTW *pFont
    );

//-----------------------------------------------------------------------
//  GetThemeRect()      - Get the value for the specified RECT property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pRect               - receives the value of the RECT property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeRect(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out LPRECT pRect
    );

typedef struct _MARGINS
{
    int cxLeftWidth;      // width of left border that retains its size
    int cxRightWidth;     // width of right border that retains its size
    int cyTopHeight;      // height of top border that retains its size
    int cyBottomHeight;   // height of bottom border that retains its size
} MARGINS, *PMARGINS;

//-----------------------------------------------------------------------
//  GetThemeMargins()   - Get the value for the specified MARGINS property
//
//      hTheme          - theme data handle
//      hdc             - (optional) hdc to be used for drawing
//      iPartId         - part number 
//      iStateId        - state number of part
//      iPropId         - the property number to get the value for
//      prc             - RECT for area to be drawn into
//      pMargins        - receives the value of the MARGINS property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeMargins(
    HTHEME hTheme,
    __in_opt HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    __in_opt LPCRECT prc,
    __out MARGINS *pMargins
    );

#if (_WIN32_WINNT >= 0x0600)
#define MAX_INTLIST_COUNT 402
#else
#define MAX_INTLIST_COUNT 10
#endif

typedef struct _INTLIST
{
    int iValueCount;      // number of values in iValues
    int iValues[MAX_INTLIST_COUNT];
} INTLIST, *PINTLIST;

//-----------------------------------------------------------------------
//  GetThemeIntList()   - Get the value for the specified INTLIST struct
//
//      hTheme          - theme data handle
//      iPartId         - part number 
//      iStateId        - state number of part
//      iPropId         - the property number to get the value for
//      pIntList        - receives the value of the INTLIST property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeIntList(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out INTLIST *pIntList
    );

enum PROPERTYORIGIN
{
    PO_STATE,           // property was found in the state section
    PO_PART,            // property was found in the part section
    PO_CLASS,           // property was found in the class section
    PO_GLOBAL,          // property was found in [globals] section
    PO_NOTFOUND         // property was not found
};

//-----------------------------------------------------------------------
//  GetThemePropertyOrigin()
//                      - searches for the specified theme property
//                        and sets "pOrigin" to indicate where it was 
//                        found (or not found)
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to search for
//  pOrigin             - receives the value of the property origin
//-----------------------------------------------------------------------
THEMEAPI
GetThemePropertyOrigin(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out enum PROPERTYORIGIN *pOrigin
    );

//---------------------------------------------------------------------------
//  SetWindowTheme()
//                      - redirects an existing Window to use a different 
//                        section of the current theme information than its 
//                        class normally asks for.
//
//  hwnd                - the handle of the window (cannot be NULL)
//
//  pszSubAppName       - app (group) name to use in place of the calling
//                        app's name.  If NULL, the actual calling app 
//                        name will be used.
//
//  pszSubIdList        - semicolon separated list of class Id names to 
//                        use in place of actual list passed by the 
//                        window's class.  if NULL, the id list from the 
//                        calling class is used.
//---------------------------------------------------------------------------
// The Theme Manager will remember the "pszSubAppName" and the
// "pszSubIdList" associations thru the lifetime of the window (even 
// if themes are subsequently changed).  The window is sent a 
// "WM_THEMECHANGED" msg at the end of this call, so that the new
// theme can be found and applied.
//---------------------------------------------------------------------------
// When "pszSubAppName" or "pszSubIdList" are NULL, the Theme Manager 
// removes the previously remember association.  To turn off theme-ing for 
// the specified window, you can pass an empty string (L"") so it 
// won't match any section entries.
//---------------------------------------------------------------------------
THEMEAPI
SetWindowTheme(
    HWND hwnd,
    LPCWSTR pszSubAppName,
    LPCWSTR pszSubIdList
    );


//---------------------------------------------------------------------------
//  GetThemeFilename()  - Get the value for the specified FILENAME property.
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to search for
//  pszThemeFileName    - output buffer to receive the filename
//  cchMaxBuffChars     - the size of the return buffer, in chars
//---------------------------------------------------------------------------
THEMEAPI
GetThemeFilename(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out_ecount(cchMaxBuffChars) LPWSTR pszThemeFileName,
    int cchMaxBuffChars
    );

//---------------------------------------------------------------------------
//  GetThemeSysColor()  - Get the value of the specified System color. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        color from [SysMetrics] section of theme.
//                        if NULL, will return the global system color.
//
//  iColorId            - the system color index defined in winuser.h
//---------------------------------------------------------------------------
THEMEAPI_(COLORREF)
GetThemeSysColor(
    HTHEME hTheme,
    int iColorId
    );

//---------------------------------------------------------------------------
//  GetThemeSysColorBrush() 
//                      - Get the brush for the specified System color. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        brush matching color from [SysMetrics] section of 
//                        theme.  if NULL, will return the brush matching
//                        global system color.
//
//  iColorId            - the system color index defined in winuser.h
//---------------------------------------------------------------------------
THEMEAPI_(HBRUSH)
GetThemeSysColorBrush(
    HTHEME hTheme,
    int iColorId
    );

//---------------------------------------------------------------------------
//  GetThemeSysBool()   - Get the boolean value of specified System metric. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        BOOL from [SysMetrics] section of theme.
//                        if NULL, will return the specified system boolean.
//
//  iBoolId             - the TMT_XXX BOOL number (first BOOL
//                        is TMT_FLATMENUS)
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
GetThemeSysBool(
    HTHEME hTheme,
    int iBoolId
    );

//---------------------------------------------------------------------------
//  GetThemeSysSize()   - Get the value of the specified System size metric. 
//                        (scaled for the current logical screen dpi) 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        size from [SysMetrics] section of theme.
//                        if NULL, will return the global system metric.
//
//  iSizeId             - the following values are supported when 
//                        hTheme is non-NULL:
//
//                          SM_CXBORDER       (border width)
//                          SM_CXVSCROLL      (scrollbar width)
//                          SM_CYHSCROLL      (scrollbar height)
//                          SM_CXSIZE         (caption width)
//                          SM_CYSIZE         (caption height)
//                          SM_CXSMSIZE       (small caption width)
//                          SM_CYSMSIZE       (small caption height)
//                          SM_CXMENUSIZE     (menubar width)
//                          SM_CYMENUSIZE     (menubar height)
//                          SM_CXPADDEDBORDER (padded border width)
//
//                        when hTheme is NULL, iSizeId is passed directly
//                        to the GetSystemMetrics() function
//---------------------------------------------------------------------------
THEMEAPI_(int)
GetThemeSysSize(
    HTHEME hTheme,
    int iSizeId
    );

//---------------------------------------------------------------------------
//  GetThemeSysFont()   - Get the LOGFONT for the specified System font. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        font from [SysMetrics] section of theme.
//                        if NULL, will return the specified system font.
//
//  iFontId             - the TMT_XXX font number (first font
//                        is TMT_CAPTIONFONT)
//
//  plf                 - ptr to LOGFONT to receive the font value.
//                        (scaled for the current logical screen dpi) 
//---------------------------------------------------------------------------
THEMEAPI
GetThemeSysFont(
    HTHEME hTheme,
    int iFontId,
    __out LOGFONTW *plf
    );

//---------------------------------------------------------------------------
//  GetThemeSysString() - Get the value of specified System string metric. 
//
//  hTheme              - the theme data handle (required)
//
//  iStringId           - must be one of the following values:
//
//                          TMT_CSSNAME
//                          TMT_XMLNAME
//
//  pszStringBuff       - the buffer to receive the string value
//
//  cchMaxStringChars   - max. number of chars that pszStringBuff can hold
//---------------------------------------------------------------------------
THEMEAPI
GetThemeSysString(
    HTHEME hTheme,
    int iStringId,
    __out_ecount(cchMaxStringChars) LPWSTR pszStringBuff,
    int cchMaxStringChars
    );

//---------------------------------------------------------------------------
//  GetThemeSysInt() - Get the value of specified System int.
//
//  hTheme              - the theme data handle (required)
//
//  iIntId              - must be one of the following values:
//
//                          TMT_DPIX
//                          TMT_DPIY
//                          TMT_MINCOLORDEPTH
//
//  piValue             - ptr to int to receive value
//---------------------------------------------------------------------------
THEMEAPI
GetThemeSysInt(
    HTHEME hTheme,
    int iIntId,
    __out int *piValue
    );

//---------------------------------------------------------------------------
//  IsThemeActive()     - can be used to test if a system theme is active
//                        for the current user session.  
//
//                        use the API "IsAppThemed()" to test if a theme is
//                        active for the calling process.
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemeActive(
    VOID
    );

//---------------------------------------------------------------------------
//  IsAppThemed()       - returns TRUE if a theme is active and available to
//                        the current process
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsAppThemed(
    VOID
    );

//---------------------------------------------------------------------------
//  GetWindowTheme()    - if window is themed, returns its most recent
//                        HTHEME from OpenThemeData() - otherwise, returns
//                        NULL.
//
//      hwnd            - the window to get the HTHEME of
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME)
GetWindowTheme(
    HWND hwnd
    );

#define ETDT_DISABLE                    0x00000001
#define ETDT_ENABLE                     0x00000002
#define ETDT_USETABTEXTURE              0x00000004

#define ETDT_ENABLETAB              (ETDT_ENABLE | \
                                     ETDT_USETABTEXTURE)

#if (_WIN32_WINNT >= 0x0600)
#define ETDT_USEAEROWIZARDTABTEXTURE    0x00000008

#define ETDT_ENABLEAEROWIZARDTAB    (ETDT_ENABLE | \
                                     ETDT_USEAEROWIZARDTABTEXTURE)

#define ETDT_VALIDBITS              (ETDT_DISABLE | \
                                     ETDT_ENABLE | \
                                     ETDT_USETABTEXTURE | \
                                     ETDT_USEAEROWIZARDTABTEXTURE)
#endif

//---------------------------------------------------------------------------
//  EnableThemeDialogTexture() 
//
//  - Enables/disables dialog background theme.  This method can be used to 
//    tailor dialog compatibility with child windows and controls that 
//    may or may not coordinate the rendering of their client area backgrounds 
//    with that of their parent dialog in a manner that supports seamless 
//    background texturing.
//
//      hdlg         - the window handle of the target dialog
//      dwFlags      - ETDT_ENABLE to enable the theme-defined dialog background texturing,
//                     ETDT_DISABLE to disable background texturing,
//                     ETDT_ENABLETAB to enable the theme-defined background 
//                          texturing using the Tab texture
//---------------------------------------------------------------------------
THEMEAPI
EnableThemeDialogTexture(
    __in HWND hwnd,
    __in DWORD dwFlags
    );

//---------------------------------------------------------------------------
//  IsThemeDialogTextureEnabled() 
//
//  - Reports whether the dialog supports background texturing.
//
//      hdlg         - the window handle of the target dialog
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemeDialogTextureEnabled(
    __in HWND hwnd
    );

//---------------------------------------------------------------------------
//---- flags to control theming within an app ----

#define STAP_ALLOW_NONCLIENT    (1UL << 0)
#define STAP_ALLOW_CONTROLS     (1UL << 1)
#define STAP_ALLOW_WEBCONTENT   (1UL << 2)
#define STAP_VALIDBITS          (STAP_ALLOW_NONCLIENT | \
                                 STAP_ALLOW_CONTROLS | \
                                 STAP_ALLOW_WEBCONTENT)

//---------------------------------------------------------------------------
//  GetThemeAppProperties()
//                      - returns the app property flags that control theming
//---------------------------------------------------------------------------
THEMEAPI_(DWORD)
GetThemeAppProperties(
    VOID
    );

//---------------------------------------------------------------------------
//  SetThemeAppProperties()
//                      - sets the flags that control theming within the app
//
//      dwFlags         - the flag values to be set
//---------------------------------------------------------------------------
THEMEAPI_(void)
SetThemeAppProperties(
    DWORD dwFlags
    );

//---------------------------------------------------------------------------
//  GetCurrentThemeName()
//                      - Get the name of the current theme in-use.  
//                        Optionally, return the ColorScheme name and the 
//                        Size name of the theme.
//
//  pszThemeFileName    - receives the theme path & filename
//  cchMaxNameChars     - max chars allowed in pszNameBuff
//
//  pszColorBuff        - (optional) receives the canonical color scheme name
//                        (not the display name)
//  cchMaxColorChars    - max chars allowed in pszColorBuff
//
//  pszSizeBuff         - (optional) receives the canonical size name 
//                        (not the display name)
//  cchMaxSizeChars     - max chars allowed in pszSizeBuff
//---------------------------------------------------------------------------
THEMEAPI GetCurrentThemeName(
    __out_ecount(cchMaxNameChars) LPWSTR pszThemeFileName,
    int cchMaxNameChars,
    __out_ecount_opt(cchMaxColorChars) LPWSTR pszColorBuff,
    int cchMaxColorChars,
    __out_ecount_opt(cchMaxSizeChars) LPWSTR pszSizeBuff,
    int cchMaxSizeChars
    );

#define SZ_THDOCPROP_DISPLAYNAME    L"DisplayName"
#define SZ_THDOCPROP_CANONICALNAME  L"ThemeName"
#define SZ_THDOCPROP_TOOLTIP        L"ToolTip"
#define SZ_THDOCPROP_AUTHOR         L"author"

THEMEAPI
GetThemeDocumentationProperty(
    LPCWSTR pszThemeName,
    LPCWSTR pszPropertyName,
    __out_ecount(cchMaxValChars) LPWSTR pszValueBuff,
    int cchMaxValChars
    );

//---------------------------------------------------------------------------
//  Theme API Error Handling
//
//      All functions in the Theme API not returning an HRESULT (THEMEAPI_) 
//      use the WIN32 function "SetLastError()" to record any call failures.  
//
//      To retreive the error code of the last failure on the
//      current thread for these type of API's, use the WIN32 function 
//      "GetLastError()".
//
//      All Theme API error codes (HRESULT's and GetLastError() values)
//      should be normal win32 errors which can be formatted into
//      strings using the Win32 API FormatMessage().
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// DrawThemeParentBackground()
//                      - used by partially-transparent or alpha-blended
//                        child controls to draw the part of their parent
//                        that they appear in front of.
//
//  hwnd                - handle of the child control
//
//  hdc                 - hdc of the child control
//
//  prc                 - (optional) rect that defines the area to be 
//                        drawn (CHILD coordinates)
//---------------------------------------------------------------------------
THEMEAPI
DrawThemeParentBackground(
    HWND hwnd,
    HDC hdc,
    __in_opt const RECT* prc
    );


//---------------------------------------------------------------------------
//  EnableTheming()     - enables or disables themeing for the current user
//                        in the current and future sessions.
//
//  fEnable             - if FALSE, disable theming & turn themes off.
//                      - if TRUE, enable themeing and, if user previously
//                        had a theme active, make it active now.
//---------------------------------------------------------------------------
THEMEAPI
EnableTheming(
    BOOL fEnable
    );

#define GBF_DIRECT      0x00000001      // direct dereferencing.
#define GBF_COPY        0x00000002      // create a copy of the bitmap
#define GBF_VALIDBITS   (GBF_DIRECT | \
                         GBF_COPY)

#if (_WIN32_WINNT >= 0x0600)

#define DTPB_WINDOWDC           0x00000001
#define DTPB_USECTLCOLORSTATIC  0x00000002
#define DTPB_USEERASEBKGND      0x00000004

//---------------------------------------------------------------------------
// DrawThemeParentBackgroundEx()
//                      - used by partially-transparent or alpha-blended
//                        child controls to draw the part of their parent
//                        that they appear in front of.
//                        Sends a WM_ERASEBKGND message followed by a WM_PRINTCLIENT.
//
//  hwnd                - handle of the child control
//
//  hdc                 - hdc of the child control
//
//  dwFlags             - if 0, only returns S_OK if the parent handled 
//                        WM_PRINTCLIENT.
//                      - if DTPB_WINDOWDC is set, hdc is assumed to be a window DC,
//                        not a client DC.
//                      - if DTPB_USEERASEBKGND is set, the function will return S_OK 
//                        without sending a WM_CTLCOLORSTATIC message if the parent 
//                        actually painted on WM_ERASEBKGND.
//                      - if DTPB_CTLCOLORSTATIC is set, the function will send
//                        a WM_CTLCOLORSTATIC message to the parent and use the 
//                        brush if one is provided, else COLOR_BTNFACE.
//
//  prc                 - (optional) rect that defines the area to be 
//                        drawn (CHILD coordinates)
//
//  Return value        - S_OK if something was painted, S_FALSE if not.
//---------------------------------------------------------------------------
THEMEAPI
DrawThemeParentBackgroundEx(
    HWND hwnd,
    HDC hdc,
    DWORD dwFlags,
    __in_opt const RECT* prc
    );


enum WINDOWTHEMEATTRIBUTETYPE
{
    WTA_NONCLIENT = 1
};

typedef struct _WTA_OPTIONS
{
    DWORD dwFlags;          // values for each style option specified in the bitmask
    DWORD dwMask;           // bitmask for flags that are changing
                            // valid options are: WTNCA_NODRAWCAPTION, WTNCA_NODRAWICON, WTNCA_NOSYSMENU
} WTA_OPTIONS, *PWTA_OPTIONS;

#define WTNCA_NODRAWCAPTION       0x00000001    // don't draw the window caption
#define WTNCA_NODRAWICON          0x00000002    // don't draw the system icon
#define WTNCA_NOSYSMENU           0x00000004    // don't expose the system menu icon functionality
#define WTNCA_NOMIRRORHELP        0x00000008    // don't mirror the question mark, even in RTL layout
#define WTNCA_VALIDBITS           (WTNCA_NODRAWCAPTION | \
                                   WTNCA_NODRAWICON | \
                                   WTNCA_NOSYSMENU | \
                                   WTNCA_NOMIRRORHELP)

THEMEAPI
SetWindowThemeAttribute(
    HWND hwnd,
    enum WINDOWTHEMEATTRIBUTETYPE eAttribute,
    __in_bcount(cbAttribute) PVOID pvAttribute,
    DWORD cbAttribute
    );

__inline HRESULT SetWindowThemeNonClientAttributes(HWND hwnd, DWORD dwMask, DWORD dwAttributes)    
{
    WTA_OPTIONS wta;
    wta.dwFlags = dwAttributes;
    wta.dwMask = dwMask;
    return SetWindowThemeAttribute(hwnd, WTA_NONCLIENT, (void*)&(wta), sizeof(wta));
}

#endif // #if (_WIN32_WINNT >= 0x0600)

//---------------------------------------------------------------------------
//
// DrawThemeTextEx
//
// Note: DrawThemeTextEx only exists on Windows Vista and higher, but the 
// following declarations are provided to enable declaring its prototype when
// compiling for all platforms.

// Callback function used by DrawThemeTextEx, instead of DrawText
typedef 
int
(WINAPI *DTT_CALLBACK_PROC)
(
    __in HDC hdc,
    __inout_ecount(cchText) LPWSTR pszText,
    __in int cchText,
    __inout LPRECT prc,
    __in UINT dwFlags,
    __in LPARAM lParam);

//---- bits used in dwFlags of DTTOPTS ----
#define DTT_TEXTCOLOR       (1UL << 0)      // crText has been specified
#define DTT_BORDERCOLOR     (1UL << 1)      // crBorder has been specified
#define DTT_SHADOWCOLOR     (1UL << 2)      // crShadow has been specified
#define DTT_SHADOWTYPE      (1UL << 3)      // iTextShadowType has been specified
#define DTT_SHADOWOFFSET    (1UL << 4)      // ptShadowOffset has been specified
#define DTT_BORDERSIZE      (1UL << 5)      // iBorderSize has been specified
#define DTT_FONTPROP        (1UL << 6)      // iFontPropId has been specified
#define DTT_COLORPROP       (1UL << 7)      // iColorPropId has been specified
#define DTT_STATEID         (1UL << 8)      // IStateId has been specified
#define DTT_CALCRECT        (1UL << 9)      // Use pRect as and in/out parameter
#define DTT_APPLYOVERLAY    (1UL << 10)     // fApplyOverlay has been specified
#define DTT_GLOWSIZE        (1UL << 11)     // iGlowSize has been specified
#define DTT_CALLBACK        (1UL << 12)     // pfnDrawTextCallback has been specified
#define DTT_COMPOSITED      (1UL << 13)     // Draws text with antialiased alpha (needs a DIB section)
#define DTT_VALIDBITS       (DTT_TEXTCOLOR | \
                             DTT_BORDERCOLOR | \
                             DTT_SHADOWCOLOR | \
                             DTT_SHADOWTYPE | \
                             DTT_SHADOWOFFSET | \
                             DTT_BORDERSIZE | \
                             DTT_FONTPROP | \
                             DTT_COLORPROP | \
                             DTT_STATEID | \
                             DTT_CALCRECT | \
                             DTT_APPLYOVERLAY | \
                             DTT_GLOWSIZE | \
                             DTT_COMPOSITED)

typedef struct _DTTOPTS
{
    DWORD             dwSize;              // size of the struct
    DWORD             dwFlags;             // which options have been specified
    COLORREF          crText;              // color to use for text fill
    COLORREF          crBorder;            // color to use for text outline
    COLORREF          crShadow;            // color to use for text shadow
    int               iTextShadowType;     // TST_SINGLE or TST_CONTINUOUS
    POINT             ptShadowOffset;      // where shadow is drawn (relative to text)
    int               iBorderSize;         // Border radius around text
    int               iFontPropId;         // Font property to use for the text instead of TMT_FONT
    int               iColorPropId;        // Color property to use for the text instead of TMT_TEXTCOLOR
    int               iStateId;            // Alternate state id
    BOOL              fApplyOverlay;       // Overlay text on top of any text effect?
    int               iGlowSize;           // Glow radious around text
    DTT_CALLBACK_PROC pfnDrawTextCallback; // Callback for DrawText
    LPARAM            lParam;              // Parameter for callback
} DTTOPTS, *PDTTOPTS; 

#if (_WIN32_WINNT >= 0x0600)

THEMEAPI
DrawThemeTextEx(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __in_ecount(cchText) LPCWSTR pszText,
    int cchText,
    DWORD dwTextFlags,
    __inout LPRECT pRect,
    __in_opt const DTTOPTS *pOptions
    );


//-----------------------------------------------------------------------
//  GetThemeStream() - Get the value for the specified STREAM property
//
//      hTheme      - theme data handle
//      iPartId     - part number 
//      iStateId    - state number of part
//      iPropId     - the property number to get the value for
//      ppvStream   - if non-null receives the value of the STREAM property (not to be freed)
//      pcbStream   - if non-null receives the size of the STREAM property
//      hInst       - NULL when iPropId==TMT_STREAM, HINSTANCE of a loaded msstyles 
//                    file when iPropId==TMT_DISKSTREAM (use GetCurrentThemeName 
//                    and LoadLibraryEx(LOAD_LIBRARY_AS_DATAFILE)
//-----------------------------------------------------------------------
THEMEAPI
GetThemeBitmap(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    ULONG dwFlags,
    __out HBITMAP* phBitmap
    );

//-----------------------------------------------------------------------
//  GetThemeStream() - Get the value for the specified STREAM property
//
//      hTheme      - theme data handle
//      iPartId     - part number 
//      iStateId    - state number of part
//      iPropId     - the property number to get the value for
//      ppvStream   - if non-null receives the value of the STREAM property (not to be freed)
//      pcbStream   - if non-null receives the size of the STREAM property
//      hInst       - NULL when iPropId==TMT_STREAM, HINSTANCE of a loaded msstyles 
//                    file when iPropId==TMT_DISKSTREAM (use GetCurrentThemeName 
//                    and LoadLibraryEx(LOAD_LIBRARY_AS_DATAFILE)
//-----------------------------------------------------------------------
THEMEAPI
GetThemeStream(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out VOID **ppvStream,
    __out_opt DWORD *pcbStream,
    __in_opt HINSTANCE hInst
    );


//------------------------------------------------------------------------
//  BufferedPaintInit() - Initialize the Buffered Paint API.
//                        Should be called prior to BeginBufferedPaint,
//                        and should have a matching BufferedPaintUnInit.
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintInit(
    VOID
    );

//------------------------------------------------------------------------
//  BufferedPaintUnInit() - Uninitialize the Buffered Paint API.
//                          Should be called once for each call to BufferedPaintInit,
//                          when calls to BeginBufferedPaint are no longer needed.
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintUnInit(
    VOID
    );

//------------------------------------------------------------------------
//  BeginBufferedPaint() - Begins a buffered paint operation.
//
//    hdcTarget          - Target DC on which the buffer will be painted
//    rcTarget           - Rectangle specifying the area of the target DC to paint to
//    dwFormat           - Format of the buffer (see BP_BUFFERFORMAT)
//    pPaintParams       - Paint operation parameters (see BP_PAINTPARAMS)
//    phBufferedPaint    - Pointer to receive handle to new buffered paint context
//------------------------------------------------------------------------

// HPAINTBUFFER
typedef HANDLE HPAINTBUFFER;  // handle to a buffered paint context


// BP_BUFFERFORMAT
typedef enum _BP_BUFFERFORMAT
{
    BPBF_COMPATIBLEBITMAP,    // Compatible bitmap
    BPBF_DIB,                 // Device-independent bitmap
    BPBF_TOPDOWNDIB,          // Top-down device-independent bitmap
    BPBF_TOPDOWNMONODIB       // Top-down monochrome device-independent bitmap
} BP_BUFFERFORMAT;

#define BPBF_COMPOSITED BPBF_TOPDOWNDIB


// BP_ANIMATIONSTYLE
typedef enum _BP_ANIMATIONSTYLE
{
    BPAS_NONE,                // No animation
    BPAS_LINEAR,              // Linear fade animation
    BPAS_CUBIC,               // Cubic fade animation
    BPAS_SINE                 // Sinusoid fade animation
} BP_ANIMATIONSTYLE;


// BP_ANIMATIONPARAMS
typedef struct _BP_ANIMATIONPARAMS
{
    DWORD               cbSize;
    DWORD               dwFlags; // BPAF_ flags
    BP_ANIMATIONSTYLE   style;
    DWORD               dwDuration;
} BP_ANIMATIONPARAMS, *PBP_ANIMATIONPARAMS;

#define BPPF_ERASE               0x0001 // Empty the buffer during BeginBufferedPaint()
#define BPPF_NOCLIP              0x0002 // Don't apply the target DC's clip region to the double buffer
#define BPPF_NONCLIENT           0x0004 // Using a non-client DC

                                        
// BP_PAINTPARAMS
typedef struct _BP_PAINTPARAMS
{
    DWORD                       cbSize;
    DWORD                       dwFlags; // BPPF_ flags
    const RECT *                prcExclude;
    const BLENDFUNCTION *       pBlendFunction;
} BP_PAINTPARAMS, *PBP_PAINTPARAMS;

THEMEAPI_(__success(return != NULL) HPAINTBUFFER)
BeginBufferedPaint(
    HDC hdcTarget,
    const RECT* prcTarget,
    BP_BUFFERFORMAT dwFormat,
    __in_opt BP_PAINTPARAMS *pPaintParams,
    __out HDC *phdc
    );


//------------------------------------------------------------------------
//  EndBufferedPaint() - Ends a buffered paint operation.
//
//    hBufferedPaint   - handle to buffered paint context
//    fUpdateTarget    - update target DC
//------------------------------------------------------------------------
THEMEAPI
EndBufferedPaint(
    HPAINTBUFFER hBufferedPaint,
    BOOL fUpdateTarget
    );

//------------------------------------------------------------------------
//  GetBufferedPaintTargetRect() - Returns the target rectangle specified during BeginBufferedPaint
//
//    hBufferedPaint             - handle to buffered paint context
//    prc                        - pointer to receive target rectangle
//------------------------------------------------------------------------
THEMEAPI
GetBufferedPaintTargetRect(
    HPAINTBUFFER hBufferedPaint,
    __out RECT *prc
    );

//------------------------------------------------------------------------
//  GetBufferedPaintTargetDC() - Returns the target DC specified during BeginBufferedPaint
//
//    hBufferedPaint           - handle to buffered paint context
//------------------------------------------------------------------------
THEMEAPI_(HDC)
GetBufferedPaintTargetDC(
    HPAINTBUFFER hBufferedPaint
    );

//------------------------------------------------------------------------
//  GetBufferedPaintDC() - Returns the same paint DC returned by BeginBufferedPaint
//
//    hBufferedPaint     - handle to buffered paint context
//------------------------------------------------------------------------
THEMEAPI_(HDC)
GetBufferedPaintDC(
    HPAINTBUFFER hBufferedPaint
    );

//------------------------------------------------------------------------
//  GetBufferedPaintBits() - Obtains a pointer to the buffer bitmap, if the buffer is a DIB
//
//    hBufferedPaint       - handle to buffered paint context
//    ppbBuffer            - pointer to receive pointer to buffer bitmap pixels
//    pcxRow               - pointer to receive width of buffer bitmap, in pixels;
//                           this value may not necessarily be equal to the buffer width
//------------------------------------------------------------------------
THEMEAPI
GetBufferedPaintBits(
    HPAINTBUFFER hBufferedPaint,
    __out RGBQUAD **ppbBuffer,
    __out int *pcxRow
    );

//------------------------------------------------------------------------
//  BufferedPaintClear() - Clears given rectangle to ARGB = {0, 0, 0, 0}
//
//    hBufferedPaint     - handle to buffered paint context
//    prc                - rectangle to clear; NULL specifies entire buffer
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintClear(
    HPAINTBUFFER hBufferedPaint,
    __in_opt const RECT *prc
    );

//------------------------------------------------------------------------
//  BufferedPaintSetAlpha() - Set alpha to given value in given rectangle
//
//    hBufferedPaint        - handle to buffered paint context
//    prc                   - rectangle to set alpha in; NULL specifies entire buffer
//    alpha                 - alpha value to set in the given rectangle
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintSetAlpha(
    HPAINTBUFFER hBufferedPaint,
    __in_opt const RECT *prc,
    BYTE alpha
    );

// Macro for setting the buffer to opaque (alpha = 255)
#define BufferedPaintMakeOpaque(hBufferedPaint, prc) BufferedPaintSetAlpha(hBufferedPaint, prc, 255)

//------------------------------------------------------------------------
//  BufferedPaintStopAllAnimations() - Stop all buffer animations for the given window
//
//    hwnd                           - window on which to stop all animations
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintStopAllAnimations(
    HWND hwnd
    );

typedef HANDLE HANIMATIONBUFFER;  // handle to a buffered paint animation

THEMEAPI_(HANIMATIONBUFFER)
BeginBufferedAnimation(
    HWND hwnd,
    HDC hdcTarget,
    const RECT* prcTarget,
    BP_BUFFERFORMAT dwFormat,
    __in_opt BP_PAINTPARAMS *pPaintParams,
    __in BP_ANIMATIONPARAMS *pAnimationParams,
    __out HDC *phdcFrom,
    __out HDC *phdcTo
    );

THEMEAPI
EndBufferedAnimation(
    HANIMATIONBUFFER hbpAnimation,
    BOOL fUpdateTarget
    );

THEMEAPI_(BOOL)
BufferedPaintRenderAnimation(
    HWND hwnd,
    HDC hdcTarget
    );
    
//----------------------------------------------------------------------------
// Tells if the DWM is running, and composition effects are possible for this 
// process (themes are active). 
// Roughly equivalent to "DwmIsCompositionEnabled() && IsAppthemed()"
//----------------------------------------------------------------------------
THEMEAPI_(BOOL) IsCompositionActive();

//------------------------------------------------------------------------
//  GetThemeTransitionDuration()
//                      - Gets the duration for the specified transition
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateIdFrom        - starting state number of part
//  iStateIdTo          - ending state number of part
//  iPropId             - property id 
//  pdwDuration         - receives the transition duration
//------------------------------------------------------------------------
THEMEAPI
GetThemeTransitionDuration(
    HTHEME hTheme,
    int iPartId,
    int iStateIdFrom,
    int iStateIdTo,
    int iPropId,
    __out DWORD *pdwDuration
    );  

#endif // #if (_WIN32_WINNT >= 0x0600)

#endif /* _UXTHEME_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\uuids.h ===
//------------------------------------------------------------------------------
// File: uuids.h
//
// Desc: Contains the GUIDs for the MediaType type, subtype fields and format
//       types for standard media types, and also class ids for well-known
//       components.
//
// Copyright (c) 1992 - 2002, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


//
//  We want to use this list for generating strings for debugging too
//  so we redefine OUR_GUID_ENTRY depending on what we want to do
//
//  It is imperative that all entries in this file are declared using
//  OUR_GUID_ENTRY as that macro might have been defined in advance of
//  including this file.  See wxdebug.cpp in sdk\classes\base.
//

#ifndef OUR_GUID_ENTRY
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif


// -- to allow consistent labeling of Media types and subtypes --

#define MEDIATYPE_NULL       GUID_NULL
#define MEDIASUBTYPE_NULL    GUID_NULL

// -- Use this subtype if you don't have a use for a subtype for your type
// e436eb8e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_None
OUR_GUID_ENTRY(MEDIASUBTYPE_None,
0xe436eb8e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


// -- major types ---


// 73646976-0000-0010-8000-00AA00389B71  'vids' == MEDIATYPE_Video
OUR_GUID_ENTRY(MEDIATYPE_Video,
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73647561-0000-0010-8000-00AA00389B71  'auds' == MEDIATYPE_Audio
OUR_GUID_ENTRY(MEDIATYPE_Audio,
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73747874-0000-0010-8000-00AA00389B71  'txts' == MEDIATYPE_Text
OUR_GUID_ENTRY(MEDIATYPE_Text,
0x73747874, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 7364696D-0000-0010-8000-00AA00389B71  'mids' == MEDIATYPE_Midi
OUR_GUID_ENTRY(MEDIATYPE_Midi,
0x7364696D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb83-524f-11ce-9f53-0020af0ba770            MEDIATYPE_Stream
OUR_GUID_ENTRY(MEDIATYPE_Stream,
0xe436eb83, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 73(s)76(v)61(a)69(i)-0000-0010-8000-00AA00389B71  'iavs' == MEDIATYPE_Interleaved
OUR_GUID_ENTRY(MEDIATYPE_Interleaved,
0x73766169, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 656c6966-0000-0010-8000-00AA00389B71  'file' == MEDIATYPE_File
OUR_GUID_ENTRY(MEDIATYPE_File,
0x656c6966, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_ScriptCommand
OUR_GUID_ENTRY(MEDIATYPE_ScriptCommand,
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 670AEA80-3A82-11d0-B79B-00AA003767A7            MEDIATYPE_AUXLine21Data
OUR_GUID_ENTRY(MEDIATYPE_AUXLine21Data,
0x670aea80, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// {11264ACB-37DE-4eba-8C35-7F04A1A68332}
OUR_GUID_ENTRY(MEDIATYPE_AUXTeletextPage,
0x11264acb, 0x37de, 0x4eba, 0x8c, 0x35, 0x7f, 0x4, 0xa1, 0xa6, 0x83, 0x32)

// AEB312E9-3357-43ca-B701-97EC198E2B62            MEDIATYPE_CC_CONTAINER
OUR_GUID_ENTRY(MEDIATYPE_CC_CONTAINER,
0xaeb312e9, 0x3357, 0x43ca, 0xb7, 0x1, 0x97, 0xec, 0x19, 0x8e, 0x2b, 0x62)

// FB77E152-53B2-499c-B46B-509FC33EDFD7             MEDIATYPE_DTVCCData
OUR_GUID_ENTRY(MEDIATYPE_DTVCCData,
0xfb77e152, 0x53b2, 0x499c, 0xb4, 0x6b, 0x50, 0x9f, 0xc3, 0x3e, 0xdf, 0xd7)

// B88B8A89-B049-4C80-ADCF-5898985E22C1             MEDIATYPE_MSTVCaption
OUR_GUID_ENTRY(MEDIATYPE_MSTVCaption,
0xB88B8A89, 0xB049, 0x4C80, 0xAD, 0xCF, 0x58, 0x98, 0x98, 0x5E, 0x22, 0xC1)

// F72A76E1-EB0A-11D0-ACE4-0000C0CC16BA            MEDIATYPE_VBI
OUR_GUID_ENTRY(MEDIATYPE_VBI,
0xf72a76e1, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 34FFCBC3-D5B3-4171-9002-D4C60301697F             DVB_SUBTITLES
OUR_GUID_ENTRY(MEDIASUBTYPE_DVB_SUBTITLES,
0x34FFCBC3, 0xD5B3, 0x4171, 0x90, 0x02, 0xD4, 0xC6, 0x03, 0x01, 0x69, 0x7F)

// 059DD67D-2E55-4d41-8D1B-01F5E4F50607            ISDB_CAPTIONS
OUR_GUID_ENTRY(MEDIASUBTYPE_ISDB_CAPTIONS,
0x059dd67d, 0x2e55, 0x4d41, 0x8d, 0x1b, 0x01, 0xf5, 0xe4, 0xf5, 0x06, 0x07)

// 36dc6d28-f1a6-4216-9048-9cfcefeb5eba            ISDB_SUPERIMPOSE
OUR_GUID_ENTRY(MEDIASUBTYPE_ISDB_SUPERIMPOSE,
0x36dc6d28, 0xf1a6, 0x4216, 0x90, 0x48, 0x9c, 0xfc, 0xef, 0xeb, 0x5e, 0xba)

// 0482DEE3-7817-11cf-8a03-00aa006ecb65            MEDIATYPE_Timecode
OUR_GUID_ENTRY(MEDIATYPE_Timecode,
0x482dee3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 74726c6d-0000-0010-8000-00AA00389B71  'lmrt' == MEDIATYPE_LMRT
OUR_GUID_ENTRY(MEDIATYPE_LMRT,
0x74726c6d, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 74726c6d-0000-0010-8000-00AA00389B71  'urls' == MEDIATYPE_URL_STREAM
OUR_GUID_ENTRY(MEDIATYPE_URL_STREAM,
0x736c7275, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// -- sub types ---

// 4C504C43-0000-0010-8000-00AA00389B71  'CLPL' == MEDIASUBTYPE_CLPL
OUR_GUID_ENTRY(MEDIASUBTYPE_CLPL,
0x4C504C43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56595559-0000-0010-8000-00AA00389B71  'YUYV' == MEDIASUBTYPE_YUYV
OUR_GUID_ENTRY(MEDIASUBTYPE_YUYV,
0x56595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56555949-0000-0010-8000-00AA00389B71  'IYUV' == MEDIASUBTYPE_IYUV
OUR_GUID_ENTRY(MEDIASUBTYPE_IYUV,
0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9
OUR_GUID_ENTRY(MEDIASUBTYPE_YVU9,
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313459-0000-0010-8000-00AA00389B71  'Y411' == MEDIASUBTYPE_Y411
OUR_GUID_ENTRY(MEDIASUBTYPE_Y411,
0x31313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 50313459-0000-0010-8000-00AA00389B71  'Y41P' == MEDIASUBTYPE_Y41P
OUR_GUID_ENTRY(MEDIASUBTYPE_Y41P,
0x50313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2
OUR_GUID_ENTRY(MEDIASUBTYPE_YUY2,
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU
OUR_GUID_ENTRY(MEDIASUBTYPE_YVYU,
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY
OUR_GUID_ENTRY(MEDIASUBTYPE_UYVY,
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313259-0000-0010-8000-00AA00389B71  'Y211' ==  MEDIASUBTYPE_Y211
OUR_GUID_ENTRY(MEDIASUBTYPE_Y211,
0x31313259, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 524a4c43-0000-0010-8000-00AA00389B71  'CLJR' ==  MEDIASUBTYPE_CLJR
OUR_GUID_ENTRY(MEDIASUBTYPE_CLJR,
0x524a4c43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39304649-0000-0010-8000-00AA00389B71  'IF09' ==  MEDIASUBTYPE_IF09
OUR_GUID_ENTRY(MEDIASUBTYPE_IF09,
0x39304649, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 414c5043-0000-0010-8000-00AA00389B71  'CPLA' ==  MEDIASUBTYPE_CPLA
OUR_GUID_ENTRY(MEDIASUBTYPE_CPLA,
0x414c5043, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A4D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_MJPG,
0x47504A4D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 4A4D5654-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_TVMJ
OUR_GUID_ENTRY(MEDIASUBTYPE_TVMJ,
0x4A4D5654, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 454B4157-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_WAKE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAKE,
0x454B4157, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 43434643-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_CFCC
OUR_GUID_ENTRY(MEDIASUBTYPE_CFCC,
0x43434643, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A49-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_IJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_IJPG,
0x47504A49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6D756C50-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_Plum
OUR_GUID_ENTRY(MEDIASUBTYPE_Plum,
0x6D756C50, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 53435644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVCS
OUR_GUID_ENTRY(MEDIASUBTYPE_DVCS,
0x53435644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// H.264 compressed video stream
// 34363248-0000-0010-8000-00AA00389B71  'H264' == MEDIASUBTYPE_H264
OUR_GUID_ENTRY(MEDIASUBTYPE_H264,
0x34363248, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 44535644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVSD
OUR_GUID_ENTRY(MEDIASUBTYPE_DVSD,
0x44535644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// MIROVideo DV
// 4656444D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MDVF
OUR_GUID_ENTRY(MEDIASUBTYPE_MDVF,
0x4656444D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB1,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


//
// RGB surfaces that contain per pixel alpha values.
//

// 297C55AF-E209-4cb3-B757-C76D6B9C88A8            MEDIASUBTYPE_ARGB1555
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555,
0x297c55af, 0xe209, 0x4cb3, 0xb7, 0x57, 0xc7, 0x6d, 0x6b, 0x9c, 0x88, 0xa8)

// 6E6415E6-5C24-425f-93CD-80102B3D1CCA            MEDIASUBTYPE_ARGB4444
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444,
0x6e6415e6, 0x5c24, 0x425f, 0x93, 0xcd, 0x80, 0x10, 0x2b, 0x3d, 0x1c, 0xca)

// 773c9ac0-3274-11d0-B724-00aa006c1A01            MEDIASUBTYPE_ARGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32,
0x773c9ac0, 0x3274, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x0, 0x6c, 0x1a, 0x1 )


// 2f8bb76d-b644-4550-acf3-d30caa65d5c5            MEDIASUBTYPE_A2R10G10B10
OUR_GUID_ENTRY(MEDIASUBTYPE_A2R10G10B10,
0x2f8bb76d, 0xb644, 0x4550, 0xac, 0xf3, 0xd3, 0x0c, 0xaa, 0x65, 0xd5, 0xc5)

// 576f7893-bdf6-48c4-875f-ae7b81834567            MEDIASUBTYPE_A2B10G10R10
OUR_GUID_ENTRY(MEDIASUBTYPE_A2B10G10R10,
0x576f7893, 0xbdf6, 0x48c4, 0x87, 0x5f, 0xae, 0x7b, 0x81, 0x83, 0x45, 0x67)


// 56555941-0000-0010-8000-00AA00389B71  'AYUV' == MEDIASUBTYPE_AYUV
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_AYUV,
0x56555941, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344941-0000-0010-8000-00AA00389B71  'AI44' == MEDIASUBTYPE_AI44
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_AI44,
0x34344941, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344149-0000-0010-8000-00AA00389B71  'IA44' == MEDIASUBTYPE_IA44
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_IA44,
0x34344149, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


//
// DirectX7 D3D Render Target media subtypes.
//

// 32335237-0000-0010-8000-00AA00389B71  '7R32' == MEDIASUBTYPE_RGB32_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32_D3D_DX7_RT,
0x32335237, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 36315237-0000-0010-8000-00AA00389B71  '7R16' == MEDIASUBTYPE_RGB16_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB16_D3D_DX7_RT,
0x36315237, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38384137-0000-0010-8000-00AA00389B71  '7A88' == MEDIASUBTYPE_ARGB32_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32_D3D_DX7_RT,
0x38384137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344137-0000-0010-8000-00AA00389B71  '7A44' == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444_D3D_DX7_RT,
0x34344137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35314137-0000-0010-8000-00AA00389B71  '7A15' == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555_D3D_DX7_RT,
0x35314137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


//
// DirectX9 D3D Render Target media subtypes.
//

// 32335239-0000-0010-8000-00AA00389B71  '9R32' == MEDIASUBTYPE_RGB32_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32_D3D_DX9_RT,
0x32335239, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 36315239-0000-0010-8000-00AA00389B71  '9R16' == MEDIASUBTYPE_RGB16_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB16_D3D_DX9_RT,
0x36315239, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38384139-0000-0010-8000-00AA00389B71  '9A88' == MEDIASUBTYPE_ARGB32_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32_D3D_DX9_RT,
0x38384139, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344139-0000-0010-8000-00AA00389B71  '9A44' == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444_D3D_DX9_RT,
0x34344139, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35314139-0000-0010-8000-00AA00389B71  '9A15' == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555_D3D_DX9_RT,
0x35314139, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


#define MEDIASUBTYPE_HASALPHA(mt) ( ((mt).subtype == MEDIASUBTYPE_ARGB4444)            || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32)              || \
                                    ((mt).subtype == MEDIASUBTYPE_AYUV)                || \
                                    ((mt).subtype == MEDIASUBTYPE_AI44)                || \
                                    ((mt).subtype == MEDIASUBTYPE_IA44)                || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555)            || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX9_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) )

#define MEDIASUBTYPE_HASALPHA7(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) )

#define MEDIASUBTYPE_D3D_DX7_RT(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB32_D3D_DX7_RT)    || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB16_D3D_DX7_RT))

#define MEDIASUBTYPE_HASALPHA9(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX9_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) )


#define MEDIASUBTYPE_D3D_DX9_RT(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX9_RT)   || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB32_D3D_DX9_RT)    || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB16_D3D_DX9_RT))


//
// DX-VA uncompressed surface formats
//

// 32315659-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12
OUR_GUID_ENTRY(MEDIASUBTYPE_YV12,
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 3231564E-0000-0010-8000-00AA00389B71  'NV12' ==  MEDIASUBTYPE_NV12
OUR_GUID_ENTRY(MEDIASUBTYPE_NV12,
0x3231564E, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 3131564E-0000-0010-8000-00AA00389B71  'NV11' ==  MEDIASUBTYPE_NV11
#ifndef MEDIASUBTYPE_NV11_DEFINED
#define MEDIASUBTYPE_NV11_DEFINED
OUR_GUID_ENTRY(MEDIASUBTYPE_NV11,
0x3131564E, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)
#endif

// 38303250-0000-0010-8000-00AA00389B71  'P208' ==  MEDIASUBTYPE_P208
OUR_GUID_ENTRY(MEDIASUBTYPE_P208,
'802P', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303250-0000-0010-8000-00AA00389B71  'P210' ==  MEDIASUBTYPE_P210
OUR_GUID_ENTRY(MEDIASUBTYPE_P210,
'012P', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303250-0000-0010-8000-00AA00389B71  'P216' ==  MEDIASUBTYPE_P216
OUR_GUID_ENTRY(MEDIASUBTYPE_P216,
'612P', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303250-0000-0010-8000-00AA00389B71  'P010' ==  MEDIASUBTYPE_P010
OUR_GUID_ENTRY(MEDIASUBTYPE_P010,
'010P', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303250-0000-0010-8000-00AA00389B71  'P016' ==  MEDIASUBTYPE_P016
OUR_GUID_ENTRY(MEDIASUBTYPE_P016,
'610P', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303250-0000-0010-8000-00AA00389B71  'Y210' ==  MEDIASUBTYPE_Y210
OUR_GUID_ENTRY(MEDIASUBTYPE_Y210,
'012Y', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303250-0000-0010-8000-00AA00389B71  'Y216' ==  MEDIASUBTYPE_Y216
OUR_GUID_ENTRY(MEDIASUBTYPE_Y216,
'612Y', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303450-0000-0010-8000-00AA00389B71  'P408' ==  MEDIASUBTYPE_P408
OUR_GUID_ENTRY(MEDIASUBTYPE_P408,
'804P', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 3231564E-0000-0010-8000-00AA00389B71  'NV24' ==  MEDIASUBTYPE_NV24
OUR_GUID_ENTRY(MEDIASUBTYPE_NV24,
0x3432564E, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31434D49-0000-0010-8000-00AA00389B71  'IMC1' ==  MEDIASUBTYPE_IMC1
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC1,
0x31434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32434d49-0000-0010-8000-00AA00389B71  'IMC2' ==  MEDIASUBTYPE_IMC2
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC2,
0x32434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 33434d49-0000-0010-8000-00AA00389B71  'IMC3' ==  MEDIASUBTYPE_IMC3
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC3,
0x33434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34434d49-0000-0010-8000-00AA00389B71  'IMC4' ==  MEDIASUBTYPE_IMC4
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC4,
0x34434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 30343353-0000-0010-8000-00AA00389B71  'S340' ==  MEDIASUBTYPE_S340
OUR_GUID_ENTRY(MEDIASUBTYPE_S340,
0x30343353, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32343353-0000-0010-8000-00AA00389B71  'S342' ==  MEDIASUBTYPE_S342
OUR_GUID_ENTRY(MEDIASUBTYPE_S342,
0x32343353, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


// e436eb7f-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Overlay
OUR_GUID_ENTRY(MEDIASUBTYPE_Overlay,
0xe436eb7f, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb80-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEGPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Packet,
0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb81-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Payload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Payload,
0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000050-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_MPEG1AudioPayload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1AudioPayload,
0x00000050, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb82-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1SystemStream
OUR_GUID_ENTRY(MEDIATYPE_MPEG1SystemStream,
0xe436eb82, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// the next consecutive number is assigned to MEDIATYPE_Stream and appears higher up
// e436eb84-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1System
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1System,
0xe436eb84, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb85-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1VideoCD
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1VideoCD,
0xe436eb85, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb86-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Video
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Video,
0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb87-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Audio
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Audio,
0xe436eb87, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb88-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Avi
OUR_GUID_ENTRY(MEDIASUBTYPE_Avi,
0xe436eb88, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {3DB80F90-9412-11d1-ADED-0000F8754B99}          MEDIASUBTYPE_Asf
OUR_GUID_ENTRY(MEDIASUBTYPE_Asf,
0x3db80f90, 0x9412, 0x11d1, 0xad, 0xed, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99)

// e436eb89-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_QTMovie
OUR_GUID_ENTRY(MEDIASUBTYPE_QTMovie,
0xe436eb89, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 617a7072-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Rpza
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRpza,
0x617a7072, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20636d73-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Smc
OUR_GUID_ENTRY(MEDIASUBTYPE_QTSmc,
0x20636d73, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20656c72-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Rle
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRle,
0x20656c72, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6765706a-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Jpeg
OUR_GUID_ENTRY(MEDIASUBTYPE_QTJpeg,
0x6765706a, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb8a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_PCMAudio_Obsolete
OUR_GUID_ENTRY(MEDIASUBTYPE_PCMAudio_Obsolete,
0xe436eb8a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000001-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_PCM
OUR_GUID_ENTRY(MEDIASUBTYPE_PCM,
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb8b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_WAVE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAVE,
0xe436eb8b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AU
OUR_GUID_ENTRY(MEDIASUBTYPE_AU,
0xe436eb8c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AIFF
OUR_GUID_ENTRY(MEDIASUBTYPE_AIFF,
0xe436eb8d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 64(d)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsd' == MEDIASUBTYPE_dvsd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsd,
0x64737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 64(d)68(h)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvhd' == MEDIASUBTYPE_dvhd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvhd,
0x64687664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6c(l)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsl' == MEDIASUBTYPE_dvsl
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsl,
0x6c737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35(5)32(2)76(v)64(d)-0000-0010-8000-00AA00389B71  'dv25' ==  MEDIASUBTYPE_dv25
OUR_GUID_ENTRY(MEDIASUBTYPE_dv25,
0x35327664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 30(0)35(5)76(v)64(d)-0000-0010-8000-00AA00389B71  'dv50' ==  MEDIASUBTYPE_dv50
OUR_GUID_ENTRY(MEDIASUBTYPE_dv50,
0x30357664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31(1)68(h)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvh1' ==  MEDIASUBTYPE_dvh1
OUR_GUID_ENTRY(MEDIASUBTYPE_dvh1,
0x31687664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6E8D4A22-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_BytePair
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_BytePair,
0x6e8d4a22, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A23-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_GOPPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_GOPPacket,
0x6e8d4a23, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A24-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_VBIRawData
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_VBIRawData,
0x6e8d4a24, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

//0AF414BC-4ED2-445e-9839-8F095568AB3C          MEDIASUBTYPE_708_608Data
OUR_GUID_ENTRY(MEDIASUBTYPE_708_608Data,
0xaf414bc, 0x4ed2, 0x445e, 0x98, 0x39, 0x8f, 0x9, 0x55, 0x68, 0xab, 0x3c)

// F52ADDAA-36F0-43F5-95EA-6D866484262A         MEDIASUBTYPE_DtvCcData
OUR_GUID_ENTRY(MEDIASUBTYPE_DtvCcData,
0xF52ADDAA, 0x36F0, 0x43F5, 0x95, 0xEA, 0x6D, 0x86, 0x64, 0x84, 0x26, 0x2A)

// 7EA626DB-54DA-437b-BE9F-F73073ADFA3C         MEDIASUBTYPE_CC_CONTAINER
OUR_GUID_ENTRY(MEDIASUBTYPE_CC_CONTAINER,
0x7ea626db, 0x54da, 0x437b, 0xbe, 0x9f, 0xf7, 0x30, 0x73, 0xad, 0xfa, 0x3c)

// F72A76E3-EB0A-11D0-ACE4-0000C0CC16BA         MEDIASUBTYPE_TELETEXT
OUR_GUID_ENTRY(MEDIASUBTYPE_TELETEXT,
0xf72a76e3, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 663DA43C-03E8-4e9a-9CD5-BF11ED0DEF76         MEDIASUBTYPE_VBI
OUR_GUID_ENTRY(MEDIASUBTYPE_VBI,
0x663da43c, 0x3e8, 0x4e9a, 0x9c, 0xd5, 0xbf, 0x11, 0xed, 0xd, 0xef, 0x76)

// 2791D576-8E7A-466F-9E90-5D3F3083738B         MEDIASUBTYPE_WSS
OUR_GUID_ENTRY(MEDIASUBTYPE_WSS,
0x2791D576, 0x8E7A, 0x466F, 0x9E, 0x90, 0x5D, 0x3F, 0x30, 0x83, 0x73, 0x8B)

// 01CA73E3-DCE6-4575-AFE1-2BF1C902CAF3         MEDIASUBTYPE_XDS
OUR_GUID_ENTRY(MEDIASUBTYPE_XDS,
0x1ca73e3, 0xdce6, 0x4575, 0xaf, 0xe1, 0x2b, 0xf1, 0xc9, 0x2, 0xca, 0xf3)

// A1B3F620-9792-4d8d-81A4-86AF25772090         MEDIASUBTYPE_VPS
OUR_GUID_ENTRY(MEDIASUBTYPE_VPS,
0xa1b3f620, 0x9792, 0x4d8d, 0x81, 0xa4, 0x86, 0xaf, 0x25, 0x77, 0x20, 0x90)

// derived from WAVE_FORMAT_DRM
// 00000009-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_DRM_Audio,
0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_IEEE_FLOAT
// 00000003-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_IEEE_FLOAT,
0x00000003, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_DOLBY_AC3_SPDIF
// 00000092-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3_SPDIF,
0x00000092, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_RAW_SPORT
// 00000240-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_RAW_SPORT,
0x00000240, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from wave format tag 0x241, call it SPDIF_TAG_241h for now
// 00000241-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_SPDIF_TAG_241h,
0x00000241, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)



// DirectShow DSS definitions

// A0AF4F81-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssVideo,
0xa0af4f81, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// A0AF4F82-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssAudio,
0xa0af4f82, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A40-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVideo,
0x5a9b6a40, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A41-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVBI,
0x5a9b6a41, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// BF87B6E0-8C27-11d0-B3F0-00AA003761C5     Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder,
0xBF87B6E0, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// BF87B6E1-8C27-11d0-B3F0-00AA003761C5     New Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder2,
0xBF87B6E1, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// e436ebb0-524f-11ce-9f53-0020af0ba770            Prototype filtergraph
OUR_GUID_ENTRY(CLSID_ProtoFilterGraph,
0xe436ebb0, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb1-524f-11ce-9f53-0020af0ba770            Reference clock
OUR_GUID_ENTRY(CLSID_SystemClock,
0xe436ebb1, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb2-524f-11ce-9f53-0020af0ba770           Filter Mapper
OUR_GUID_ENTRY(CLSID_FilterMapper,
0xe436ebb2, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb3-524f-11ce-9f53-0020af0ba770           Filter Graph
OUR_GUID_ENTRY(CLSID_FilterGraph,
0xe436ebb3, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb8-524f-11ce-9f53-0020af0ba770           Filter Graph no thread
OUR_GUID_ENTRY(CLSID_FilterGraphNoThread,
0xe436ebb8, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// a3ecbc41-581a-4476-b693-a63340462d8b
OUR_GUID_ENTRY(CLSID_FilterGraphPrivateThread,
0xa3ecbc41, 0x581a, 0x4476, 0xb6, 0x93, 0xa6, 0x33, 0x40, 0x46, 0x2d, 0x8b)

// e4bbd160-4269-11ce-838d-00aa0055595a           MPEG System stream
OUR_GUID_ENTRY(CLSID_MPEG1Doc,
0xe4bbd160, 0x4269, 0x11ce, 0x83, 0x8d, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 701722e0-8ae3-11ce-a85c-00aa002feab5           MPEG file reader
OUR_GUID_ENTRY(CLSID_FileSource,
0x701722e0, 0x8ae3, 0x11ce, 0xa8, 0x5c, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// 26C25940-4CA9-11ce-A828-00AA002FEAB5           Takes MPEG1 packets as input
OUR_GUID_ENTRY(CLSID_MPEG1PacketPlayer,
0x26c25940, 0x4ca9, 0x11ce, 0xa8, 0x28, 0x0, 0xaa, 0x0, 0x2f, 0xea, 0xb5)

// 336475d0-942a-11ce-a870-00aa002feab5           MPEG splitter
OUR_GUID_ENTRY(CLSID_MPEG1Splitter,
0x336475d0, 0x942a, 0x11ce, 0xa8, 0x70, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// feb50740-7bef-11ce-9bd9-0000e202599c           MPEG video decoder
OUR_GUID_ENTRY(CLSID_CMpegVideoCodec,
0xfeb50740, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// 4a2286e0-7bef-11ce-9bd9-0000e202599c           MPEG audio decoder
OUR_GUID_ENTRY(CLSID_CMpegAudioCodec,
0x4a2286e0, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// e30629d3-27e5-11ce-875d-00608cb78066           Text renderer
OUR_GUID_ENTRY(CLSID_TextRender,
0xe30629d3, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)



// {F8388A40-D5BB-11d0-BE5A-0080C706568E}
OUR_GUID_ENTRY(CLSID_InfTee,
0xf8388a40, 0xd5bb, 0x11d0, 0xbe, 0x5a, 0x0, 0x80, 0xc7, 0x6, 0x56, 0x8e)

// 1b544c20-fd0b-11ce-8c63-00aa0044b51e           Avi Stream Splitter
OUR_GUID_ENTRY(CLSID_AviSplitter,
0x1b544c20, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c21-fd0b-11ce-8c63-00aa0044b51e           Avi File Reader
OUR_GUID_ENTRY(CLSID_AviReader,
0x1b544c21, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c22-fd0b-11ce-8c63-00aa0044b51e           Vfw 2.0 Capture Driver
OUR_GUID_ENTRY(CLSID_VfwCapture,
0x1b544c22, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

OUR_GUID_ENTRY(CLSID_CaptureProperties,
0x1B544c22, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x1F)

//e436ebb4-524f-11ce-9f53-0020af0ba770            Control Distributor
OUR_GUID_ENTRY(CLSID_FGControl,
0xe436ebb4, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 44584800-F8EE-11ce-B2D4-00DD01101B85           .MOV reader (old)
OUR_GUID_ENTRY(CLSID_MOVReader,
0x44584800, 0xf8ee, 0x11ce, 0xb2, 0xd4, 0x00, 0xdd, 0x1, 0x10, 0x1b, 0x85)

// D51BD5A0-7548-11cf-A520-0080C77EF58A           QT Splitter
OUR_GUID_ENTRY(CLSID_QuickTimeParser,
0xd51bd5a0, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// FDFE9681-74A3-11d0-AFA7-00AA00B67A42           QT Decoder
OUR_GUID_ENTRY(CLSID_QTDec,
0xfdfe9681, 0x74a3, 0x11d0, 0xaf, 0xa7, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// D3588AB0-0781-11ce-B03A-0020AF0BA770           AVIFile-based reader
OUR_GUID_ENTRY(CLSID_AVIDoc,
0xd3588ab0, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// 70e102b0-5556-11ce-97c0-00aa0055595a           Video renderer
OUR_GUID_ENTRY(CLSID_VideoRenderer,
0x70e102b0, 0x5556, 0x11ce, 0x97, 0xc0, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1643e180-90f5-11ce-97d5-00aa0055595a           Colour space convertor
OUR_GUID_ENTRY(CLSID_Colour,
0x1643e180, 0x90f5, 0x11ce, 0x97, 0xd5, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1da08500-9edc-11cf-bc10-00aa00ac74f6           VGA 16 color ditherer
OUR_GUID_ENTRY(CLSID_Dither,
0x1da08500, 0x9edc, 0x11cf, 0xbc, 0x10, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// 07167665-5011-11cf-BF33-00AA0055595A           Modex video renderer
OUR_GUID_ENTRY(CLSID_ModexRenderer,
0x7167665, 0x5011, 0x11cf, 0xbf, 0x33, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// e30629d1-27e5-11ce-875d-00608cb78066           Waveout audio renderer
OUR_GUID_ENTRY(CLSID_AudioRender,
0xe30629d1, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// 05589faf-c356-11ce-bf01-00aa0055595a           Audio Renderer Property Page
OUR_GUID_ENTRY(CLSID_AudioProperties,
0x05589faf, 0xc356, 0x11ce, 0xbf, 0x01, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 79376820-07D0-11cf-A24D-0020AFD79767           DSound audio renderer
OUR_GUID_ENTRY(CLSID_DSoundRender,
0x79376820, 0x07D0, 0x11CF, 0xA2, 0x4D, 0x0, 0x20, 0xAF, 0xD7, 0x97, 0x67)

// e30629d2-27e5-11ce-875d-00608cb78066           Wavein audio recorder
OUR_GUID_ENTRY(CLSID_AudioRecord,
0xe30629d2, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// {2CA8CA52-3C3F-11d2-B73D-00C04FB6BD3D}         IAMAudioInputMixer property page
OUR_GUID_ENTRY(CLSID_AudioInputMixerProperties,
0x2ca8ca52, 0x3c3f, 0x11d2, 0xb7, 0x3d, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d)

// {CF49D4E0-1115-11ce-B03A-0020AF0BA770}         AVI Decoder
OUR_GUID_ENTRY(CLSID_AVIDec,
0xcf49d4e0, 0x1115, 0x11ce, 0xb0, 0x3a, 0x0, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// {A888DF60-1E90-11cf-AC98-00AA004C0FA9}         AVI ICDraw* wrapper
OUR_GUID_ENTRY(CLSID_AVIDraw,
0xa888df60, 0x1e90, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// 6a08cf80-0e18-11cf-a24d-0020afd79767       ACM Wrapper
OUR_GUID_ENTRY(CLSID_ACMWrapper,
0x6a08cf80, 0x0e18, 0x11cf, 0xa2, 0x4d, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x67)

// {e436ebb5-524f-11ce-9f53-0020af0ba770}    Async File Reader
OUR_GUID_ENTRY(CLSID_AsyncReader,
0xe436ebb5, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb6-524f-11ce-9f53-0020af0ba770}    Async URL Reader
OUR_GUID_ENTRY(CLSID_URLReader,
0xe436ebb6, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb7-524f-11ce-9f53-0020af0ba770}    IPersistMoniker PID
OUR_GUID_ENTRY(CLSID_PersistMonikerPID,
0xe436ebb7, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {D76E2820-1563-11cf-AC98-00AA004C0FA9}
OUR_GUID_ENTRY(CLSID_AVICo,
0xd76e2820, 0x1563, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// {8596E5F0-0DA5-11d0-BD21-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_FileWriter,
0x8596e5f0, 0xda5, 0x11d0, 0xbd, 0x21, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {E2510970-F137-11CE-8B67-00AA00A3F1A6}     AVI mux filter
OUR_GUID_ENTRY(CLSID_AviDest,
0xe2510970, 0xf137, 0x11ce, 0x8b, 0x67, 0x0, 0xaa, 0x0, 0xa3, 0xf1, 0xa6)

// {C647B5C0-157C-11d0-BD23-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage,
0xc647b5c0, 0x157c, 0x11d0, 0xbd, 0x23, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {0A9AE910-85C0-11d0-BD42-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage1,
0xa9ae910, 0x85c0, 0x11d0, 0xbd, 0x42, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {07b65360-c445-11ce-afde-00aa006c14f4}
OUR_GUID_ENTRY(CLSID_AVIMIDIRender,
0x07b65360, 0xc445, 0x11ce, 0xaf, 0xde, 0x00, 0xaa, 0x00, 0x6c, 0x14, 0xf4)

// {187463A0-5BB7-11d3-ACBE-0080C75E246E}    WMSDK-based ASF reader
OUR_GUID_ENTRY(CLSID_WMAsfReader,
0x187463a0, 0x5bb7, 0x11d3, 0xac, 0xbe, 0x0, 0x80, 0xc7, 0x5e, 0x24, 0x6e)

// {7c23220e-55bb-11d3-8b16-00c04fb6bd3d}    WMSDK-based ASF writer
OUR_GUID_ENTRY(CLSID_WMAsfWriter,
0x7c23220e, 0x55bb, 0x11d3, 0x8b, 0x16, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d)

//  {afb6c280-2c41-11d3-8a60-0000f81e0e4a}
OUR_GUID_ENTRY(CLSID_MPEG2Demultiplexer,
0xafb6c280, 0x2c41, 0x11d3, 0x8a, 0x60, 0x00, 0x00, 0xf8, 0x1e, 0x0e, 0x4a)

// {687D3367-3644-467a-ADFE-6CD7A85C4A2C}
OUR_GUID_ENTRY(CLSID_MPEG2Demultiplexer_NoClock, 
0x687d3367, 0x3644, 0x467a, 0xad, 0xfe, 0x6c, 0xd7, 0xa8, 0x5c, 0x4a, 0x2c)

// {3ae86b20-7be8-11d1-abe6-00a0c905f375}
OUR_GUID_ENTRY(CLSID_MMSPLITTER,
0x3ae86b20, 0x7be8, 0x11d1, 0xab, 0xe6, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// {2DB47AE5-CF39-43c2-B4D6-0CD8D90946F4}
OUR_GUID_ENTRY(CLSID_StreamBufferSink,
0x2db47ae5, 0xcf39, 0x43c2, 0xb4, 0xd6, 0xc, 0xd8, 0xd9, 0x9, 0x46, 0xf4)

// {E2448508-95DA-4205-9A27-7EC81E723B1A}
OUR_GUID_ENTRY(CLSID_SBE2Sink,
0xe2448508, 0x95da, 0x4205, 0x9a, 0x27, 0x7e, 0xc8, 0x1e, 0x72, 0x3b, 0x1a)

// {C9F5FE02-F851-4eb5-99EE-AD602AF1E619}
OUR_GUID_ENTRY(CLSID_StreamBufferSource,
0xc9f5fe02, 0xf851, 0x4eb5, 0x99, 0xee, 0xad, 0x60, 0x2a, 0xf1, 0xe6, 0x19)

// {FA8A68B2-C864-4ba2-AD53-D3876A87494B}
OUR_GUID_ENTRY(CLSID_StreamBufferConfig,
0xfa8a68b2, 0xc864, 0x4ba2, 0xad, 0x53, 0xd3, 0x87, 0x6a, 0x87, 0x49, 0x4b)

// {E37A73F8-FB01-43dc-914E-AAEE76095AB9}
OUR_GUID_ENTRY(CLSID_StreamBufferPropertyHandler,
0xe37a73f8, 0xfb01, 0x43dc, 0x91, 0x4e, 0xaa, 0xee, 0x76, 0x9, 0x5a, 0xb9)

// {713790EE-5EE1-45ba-8070-A1337D2762FA}
OUR_GUID_ENTRY(CLSID_StreamBufferThumbnailHandler,
0x713790ee, 0x5ee1, 0x45ba, 0x80, 0x70, 0xa1, 0x33, 0x7d, 0x27, 0x62, 0xfa)

// {6CFAD761-735D-4aa5-8AFC-AF91A7D61EBA}
OUR_GUID_ENTRY(CLSID_Mpeg2VideoStreamAnalyzer,
0x6cfad761, 0x735d, 0x4aa5, 0x8a, 0xfc, 0xaf, 0x91, 0xa7, 0xd6, 0x1e, 0xba)

// {CCAA63AC-1057-4778-AE92-1206AB9ACEE6}
OUR_GUID_ENTRY(CLSID_StreamBufferRecordingAttributes,
0xccaa63ac, 0x1057, 0x4778, 0xae, 0x92, 0x12, 0x6, 0xab, 0x9a, 0xce, 0xe6)

// {D682C4BA-A90A-42fe-B9E1-03109849C423}
OUR_GUID_ENTRY(CLSID_StreamBufferComposeRecording,
0xd682c4ba, 0xa90a, 0x42fe, 0xb9, 0xe1, 0x3, 0x10, 0x98, 0x49, 0xc4, 0x23)

// {93A094D7-51E8-485b-904A-8D6B97DC6B39}
OUR_GUID_ENTRY(CLSID_SBE2File,
0x93a094d7, 0x51e8, 0x485b, 0x90, 0x4a, 0x8d, 0x6b, 0x97, 0xdc, 0x6b, 0x39)

// {B1B77C00-C3E4-11cf-AF79-00AA00B67A42}               DV video decoder
OUR_GUID_ENTRY(CLSID_DVVideoCodec,
0xb1b77c00, 0xc3e4, 0x11cf, 0xaf, 0x79, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {13AA3650-BB6F-11d0-AFB9-00AA00B67A42}               DV video encoder
OUR_GUID_ENTRY(CLSID_DVVideoEnc,
0x13aa3650, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4EB31670-9FC6-11cf-AF6E-00AA00B67A42}               DV splitter
OUR_GUID_ENTRY(CLSID_DVSplitter,
0x4eb31670, 0x9fc6, 0x11cf, 0xaf, 0x6e, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {129D7E40-C10D-11d0-AFB9-00AA00B67A42}               DV muxer
OUR_GUID_ENTRY(CLSID_DVMux,
0x129d7e40, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {060AF76C-68DD-11d0-8FC1-00C04FD9189D}
OUR_GUID_ENTRY(CLSID_SeekingPassThru,
0x60af76c, 0x68dd, 0x11d0, 0x8f, 0xc1, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d)

// 6E8D4A20-310C-11d0-B79A-00AA003767A7                 Line21 (CC) Decoder
OUR_GUID_ENTRY(CLSID_Line21Decoder,
0x6e8d4a20, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// E4206432-01A1-4BEE-B3E1-3702C8EDC574                 Line21 (CC) Decoder v2
OUR_GUID_ENTRY(CLSID_Line21Decoder2,
0xe4206432, 0x01a1, 0x4bee, 0xb3, 0xe1, 0x37, 0x02, 0xc8, 0xed, 0xc5, 0x74)

OUR_GUID_ENTRY(CLSID_CCAFilter,
0x3d07a539, 0x35ca, 0x447c, 0x9b, 0x5,  0x8d, 0x85, 0xce, 0x92,  0x4f,  0x9e)

// {CD8743A1-3736-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_OverlayMixer,
0xcd8743a1, 0x3736, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9800-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VBISurfaces,
0x814b9800, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {70BC06E0-5666-11d3-A184-00105AEF9F33}               WST Teletext Decoder
OUR_GUID_ENTRY(CLSID_WSTDecoder,
0x70bc06e0, 0x5666, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)

// {301056D0-6DFF-11d2-9EEB-006008039E37}
OUR_GUID_ENTRY(CLSID_MjpegDec,
0x301056d0, 0x6dff, 0x11d2, 0x9e, 0xeb, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37)

// {B80AB0A0-7416-11d2-9EEB-006008039E37}
OUR_GUID_ENTRY(CLSID_MJPGEnc,
0xb80ab0a0, 0x7416, 0x11d2, 0x9e, 0xeb, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37)



// pnp objects and categories
// 62BE5D10-60EB-11d0-BD3B-00A0C911CE86                 ICreateDevEnum
OUR_GUID_ENTRY(CLSID_SystemDeviceEnum,
0x62BE5D10,0x60EB,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 4315D437-5B8C-11d0-BD3B-00A0C911CE86
OUR_GUID_ENTRY(CLSID_CDeviceMoniker,
0x4315D437,0x5B8C,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 860BB310-5D01-11d0-BD3B-00A0C911CE86                 Video capture category
OUR_GUID_ENTRY(CLSID_VideoInputDeviceCategory,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CVidCapClassManager,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 083863F1-70DE-11d0-BD40-00A0C911CE86                 Filter category
OUR_GUID_ENTRY(CLSID_LegacyAmFilterCategory,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CQzFilterClassManager,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 33D9A760-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_VideoCompressorCategory,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CIcmCoClassManager,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A761-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_AudioCompressorCategory,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CAcmCoClassManager,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A762-90C8-11d0-BD43-00A0C911CE86                 Audio source cateogry
OUR_GUID_ENTRY(CLSID_AudioInputDeviceCategory,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveinClassManager,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// E0F158E1-CB04-11d0-BD4E-00A0C911CE86                 Audio renderer category
OUR_GUID_ENTRY(CLSID_AudioRendererCategory,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveOutClassManager,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 4EFE2452-168A-11d1-BC76-00C04FB9453B                 Midi renderer category
OUR_GUID_ENTRY(CLSID_MidiRendererCategory,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)
OUR_GUID_ENTRY(CLSID_CMidiOutClassManager,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)

// CC7BFB41-F175-11d1-A392-00E0291F3959     External Renderers Category
OUR_GUID_ENTRY(CLSID_TransmitCategory,
0xcc7bfb41, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59)

// CC7BFB46-F175-11d1-A392-00E0291F3959     Device Control Filters
OUR_GUID_ENTRY(CLSID_DeviceControlCategory,
0xcc7bfb46, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59)

// DA4E3DA0-D07D-11d0-BD50-00A0C911CE86
OUR_GUID_ENTRY(CLSID_ActiveMovieCategories,
0xda4e3da0, 0xd07d, 0x11d0, 0xbd, 0x50, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 2721AE20-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(CLSID_DVDHWDecodersCategory,
0x2721AE20, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// 7D22E920-5CA9-4787-8C2B-A6779BD11781     Encoder API encoder category
OUR_GUID_ENTRY(CLSID_MediaEncoderCategory,
0x7D22E920, 0x5CA9, 0x4787, 0x8C, 0x2B, 0xA6, 0x77, 0x9B, 0xD1, 0x17, 0x81)

// 236C9559-ADCE-4736-BF72-BAB34E392196     Encoder API multiplexer category
OUR_GUID_ENTRY(CLSID_MediaMultiplexerCategory,
0x236C9559, 0xADCE, 0x4736, 0xBF, 0x72, 0xBA, 0xB3, 0x4E, 0x39, 0x21, 0x96)

// CDA42200-BD88-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_FilterMapper2,
0xcda42200, 0xbd88, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)


// 1e651cc0-b199-11d0-8212-00c04fc32c45
OUR_GUID_ENTRY(CLSID_MemoryAllocator,
0x1e651cc0, 0xb199, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45)

// CDBD8D00-C193-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_MediaPropertyBag,
0xcdbd8d00, 0xc193, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// FCC152B7-F372-11d0-8E00-00C04FD7C08B
OUR_GUID_ENTRY(CLSID_DvdGraphBuilder,
0xFCC152B7, 0xF372, 0x11d0, 0x8E, 0x00, 0x00, 0xC0, 0x4F, 0xD7, 0xC0, 0x8B)

// 9B8C4620-2C1A-11d0-8493-00A02438AD48
OUR_GUID_ENTRY(CLSID_DVDNavigator,
0x9b8c4620, 0x2c1a, 0x11d0, 0x84, 0x93, 0x0, 0xa0, 0x24, 0x38, 0xad, 0x48)

// f963c5cf-a659-4a93-9638-caf3cd277d13
OUR_GUID_ENTRY(CLSID_DVDState,
0xf963c5cf, 0xa659, 0x4a93, 0x96, 0x38, 0xca, 0xf3, 0xcd, 0x27, 0x7d, 0x13)

// CC58E280-8AA1-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(CLSID_SmartTee,
0xcc58e280, 0x8aa1, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// FB056BA0-2502-45B9-8E86-2B40DE84AD29
OUR_GUID_ENTRY(CLSID_DtvCcFilter,
0xfb056ba0, 0x2502, 0x45b9, 0x8e, 0x86, 0x2b, 0x40, 0xde, 0x84, 0xad, 0x29)

// 2F7EE4B6-6FF5-4EB4-B24A-2BFC41117171
OUR_GUID_ENTRY(CLSID_CaptionsFilter,
0x2F7EE4B6, 0x6FF5, 0x4EB4, 0xB2, 0x4A, 0x2B, 0xFC, 0x41, 0x11, 0x71, 0x71)

// {9F22CFEA-CE07-41ab-8BA0-C7364AF90AF9}
OUR_GUID_ENTRY(CLSID_SubtitlesFilter,
0x9f22cfea, 0xce07, 0x41ab, 0x8b, 0xa0, 0xc7, 0x36, 0x4a, 0xf9, 0x0a, 0xf9)

// {8670C736-F614-427b-8ADA-BBADC587194B}
OUR_GUID_ENTRY(CLSID_DirectShowPluginControl, 
0x8670c736, 0xf614, 0x427b, 0x8a, 0xda, 0xbb, 0xad, 0xc5, 0x87, 0x19, 0x4b)


// -- format types ---

// 0F6417D6-C318-11D0-A43F-00A0C9223196        FORMAT_None
OUR_GUID_ENTRY(FORMAT_None,
0x0F6417D6, 0xc318, 0x11d0, 0xa4, 0x3f, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96)

// 05589f80-c356-11ce-bf01-00aa0055595a        FORMAT_VideoInfo
OUR_GUID_ENTRY(FORMAT_VideoInfo,
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA        FORMAT_VideoInfo2
OUR_GUID_ENTRY(FORMAT_VideoInfo2,
0xf72a76A0, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 05589f81-c356-11ce-bf01-00aa0055595a        FORMAT_WaveFormatEx
OUR_GUID_ENTRY(FORMAT_WaveFormatEx,
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f82-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGVideo
OUR_GUID_ENTRY(FORMAT_MPEGVideo,
0x05589f82, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f83-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGStreams
OUR_GUID_ENTRY(FORMAT_MPEGStreams,
0x05589f83, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f84-c356-11ce-bf01-00aa0055595a        FORMAT_DvInfo, DVINFO
OUR_GUID_ENTRY(FORMAT_DvInfo,
0x05589f84, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// C7ECF04D-4582-4869-9ABB-BFB523B62EDF       FORMAT_525WSS
OUR_GUID_ENTRY(FORMAT_525WSS,
0xc7ecf04d, 0x4582, 0x4869, 0x9a, 0xbb, 0xbf, 0xb5, 0x23, 0xb6, 0x2e, 0xdf)

// -- Video related GUIDs ---

// 944d4c00-dd52-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(CLSID_DirectDrawProperties,
0x944d4c00, 0xdd52, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 59ce6880-acf8-11cf-b56e-0080c7c4b68a
OUR_GUID_ENTRY(CLSID_PerformanceProperties,
0x59ce6880, 0xacf8, 0x11cf, 0xb5, 0x6e, 0x00, 0x80, 0xc7, 0xc4, 0xb6, 0x8a)

// 418afb70-f8b8-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(CLSID_QualityProperties,
0x418afb70, 0xf8b8, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// 61ded640-e912-11ce-a099-00aa00479a58
OUR_GUID_ENTRY(IID_IBaseVideoMixer,
0x61ded640, 0xe912, 0x11ce, 0xa0, 0x99, 0x00, 0xaa, 0x00, 0x47, 0x9a, 0x58)

// 36d39eb0-dd75-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(IID_IDirectDrawVideo,
0x36d39eb0, 0xdd75, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// bd0ecb0-f8e2-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(IID_IQualProp,
0x1bd0ecb0, 0xf8e2, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// {CE292861-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_VPObject,
0xce292861, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {CE292862-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPObject,
0xce292862, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {25DF12C1-3DE0-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPControl,
0x25df12c1, 0x3de0, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9801-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VPVBIObject,
0x814b9801, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {814B9802-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIObject,
0x814b9802, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {BC29A660-30E3-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPConfig,
0xbc29a660, 0x30e3, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {C76794A1-D6C5-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify,
0xc76794a1, 0xd6c5, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47183-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify2,
0xebf47183, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// {EC529B00-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIConfig,
0xec529b00, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {EC529B01-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBINotify,
0xec529b01, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {593CDDE1-0759-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig,
0x593cdde1, 0x759, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47182-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig2,
0xebf47182, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// This is a real pain in the neck. The OLE GUIDs are separated out into a
// different file from the main header files. The header files can then be
// included multiple times and are protected with the following statements,
//
//      #ifndef __SOMETHING_DEFINED__
//      #define __SOMETHING_DEFINED__
//          all the header contents
//      #endif // __SOMETHING_DEFINED__
//
// When the actual GUIDs are to be defined (using initguid) the GUID header
// file can then be included to really define them just once. Unfortunately
// DirectDraw has the GUIDs defined in the main header file. So if the base
// classes bring in ddraw.h to get at the DirectDraw structures and so on
// nobody would then be able to really include ddraw.h to allocate the GUID
// memory structures because of the aforementioned header file protection
// Therefore the DirectDraw GUIDs are defined and allocated for real here

#ifndef __DDRAW_INCLUDED__
OUR_GUID_ENTRY(CLSID_DirectDraw,            0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35)
OUR_GUID_ENTRY(CLSID_DirectDrawClipper,     0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDraw,             0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDraw2,            0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDrawSurface,      0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawSurface2,     0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27)
OUR_GUID_ENTRY(IID_IDirectDrawSurface3,     0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB)
OUR_GUID_ENTRY(IID_IDirectDrawSurface4,     0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B)
OUR_GUID_ENTRY(IID_IDirectDrawSurface7,     0x06675a80,0x3b9b,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b)
OUR_GUID_ENTRY(IID_IDirectDrawPalette,      0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawClipper,      0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawColorControl, 0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

#ifndef __DVP_INCLUDED__
OUR_GUID_ENTRY(IID_IDDVideoPortContainer,    0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
#endif

#ifndef __DDKM_INCLUDED__
OUR_GUID_ENTRY(IID_IDirectDrawKernel,        0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
OUR_GUID_ENTRY(IID_IDirectDrawSurfaceKernel, 0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

// 0618aa30-6bc4-11cf-bf36-00aa0055595a
OUR_GUID_ENTRY(CLSID_ModexProperties,
0x0618aa30, 0x6bc4, 0x11cf, 0xbf, 0x36, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// dd1d7110-7836-11cf-bf47-00aa0055595a
OUR_GUID_ENTRY(IID_IFullScreenVideo,
0xdd1d7110, 0x7836, 0x11cf, 0xbf, 0x47, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 53479470-f1dd-11cf-bc42-00aa00ac74f6
OUR_GUID_ENTRY(IID_IFullScreenVideoEx,
0x53479470, 0xf1dd, 0x11cf, 0xbc, 0x42, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// {101193C0-0BFE-11d0-AF91-00AA00B67A42}           DV decoder property
OUR_GUID_ENTRY(CLSID_DVDecPropertiesPage,
0x101193c0, 0xbfe, 0x11d0, 0xaf, 0x91, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4150F050-BB6F-11d0-AFB9-00AA00B67A42}           DV encoder property
OUR_GUID_ENTRY(CLSID_DVEncPropertiesPage,
0x4150f050, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4DB880E0-C10D-11d0-AFB9-00AA00B67A42}           DV Muxer property
OUR_GUID_ENTRY(CLSID_DVMuxPropertyPage,
0x4db880e0, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)


// -- Direct Sound Audio related GUID ---

// 546F4260-D53E-11cf-B3F0-00AA003761C5
OUR_GUID_ENTRY(IID_IAMDirectSound,
0x546f4260, 0xd53e, 0x11cf, 0xb3, 0xf0, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -- MPEG audio decoder properties

// {b45dd570-3c77-11d1-abe1-00a0c905f375}
OUR_GUID_ENTRY(IID_IMpegAudioDecoder,
0xb45dd570, 0x3c77, 0x11d1, 0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// --- Line21 Decoder interface GUID ---

// 6E8D4A21-310C-11d0-B79A-00AA003767A7            IID_IAMLine21Decoder
OUR_GUID_ENTRY(IID_IAMLine21Decoder,
0x6e8d4a21, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// --- WST Decoder interface GUID ---

// C056DE21-75C2-11d3-A184-00105AEF9F33            IID_IAMWstDecoder
OUR_GUID_ENTRY(IID_IAMWstDecoder,
0xc056de21, 0x75c2, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)

// --- WST Decoder Property Page ---

// 04E27F80-91E4-11d3-A184-00105AEF9F33            WST Decoder Property Page
OUR_GUID_ENTRY(CLSID_WstDecoderPropertyPage,
0x4e27f80, 0x91e4, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)


// -- Analog video related GUIDs ---


// -- format types ---
// 0482DDE0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(FORMAT_AnalogVideo,
0x482dde0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- major type, Analog Video

// 0482DDE1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIATYPE_AnalogVideo,
0x482dde1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- Analog Video subtypes, NTSC

// 0482DDE2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_NTSC_M,
0x482dde2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, PAL

// 0482DDE5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_B,
0x482dde5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_D,
0x482dde6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE7-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_G,
0x482dde7, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE8-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_H,
0x482dde8, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE9-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_I,
0x482dde9, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEA-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_M,
0x482ddea, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEB-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N,
0x482ddeb, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEC-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N_COMBO,
0x482ddec, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, SECAM

// 0482DDF0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_B,
0x482ddf0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_D,
0x482ddf1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_G,
0x482ddf2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF3-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_H,
0x482ddf3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF4-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K,
0x482ddf4, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K1,
0x482ddf5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_L,
0x482ddf6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// --  External audio related GUIDs ---

// -- major types, Analog Audio

// 0482DEE1-7817-11cf-8a03-00aa006ecb65
OUR_GUID_ENTRY(MEDIATYPE_AnalogAudio,
0x482dee1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// --  Video analysis related GUIDs ---

// -- format types used by VA -- H.264, captioning

// {A4EFC024-873E-4da3-898B-474DDBD79FD0}
OUR_GUID_ENTRY(FORMAT_CAPTIONED_H264VIDEO,
0xa4efc024, 0x873e, 0x4da3, 0x89, 0x8b, 0x47, 0x4d, 0xdb, 0xd7, 0x9f, 0xd0)

// -- media, media subtype, and format types, CC container

// {50997A4A-E508-4054-A2B2-10FF0AC1A69A}
OUR_GUID_ENTRY(FORMAT_CC_CONTAINER,
0x50997a4a, 0xe508, 0x4054, 0xa2, 0xb2, 0x10, 0xff, 0xa, 0xc1, 0xa6, 0x9a)

// {3ED9CB31-FD10-4ade-BCCC-FB9105D2F3EF}
OUR_GUID_ENTRY(CAPTION_FORMAT_ATSC,
0x3ed9cb31, 0xfd10, 0x4ade, 0xbc, 0xcc, 0xfb, 0x91, 0x5, 0xd2, 0xf3, 0xef)

// {12230DB4-FF2A-447e-BB88-6841C416D068}
OUR_GUID_ENTRY(CAPTION_FORMAT_DVB,
0x12230db4, 0xff2a, 0x447e, 0xbb, 0x88, 0x68, 0x41, 0xc4, 0x16, 0xd0, 0x68)

// {E9CA1CE7-915E-47be-9BB9-BF1D8A13A5EC}
OUR_GUID_ENTRY(CAPTION_FORMAT_DIRECTV,
0xe9ca1ce7, 0x915e, 0x47be, 0x9b, 0xb9, 0xbf, 0x1d, 0x8a, 0x13, 0xa5, 0xec)

// {EBB1A262-1158-4b99-AE80-92AC776952C4}
OUR_GUID_ENTRY(CAPTION_FORMAT_ECHOSTAR,
0xebb1a262, 0x1158, 0x4b99, 0xae, 0x80, 0x92, 0xac, 0x77, 0x69, 0x52, 0xc4)

// -- format types, MPEG-2

// {7AB2ADA2-81B6-4f14-B3C8-D0C486393B67}
OUR_GUID_ENTRY(FORMAT_CAPTIONED_MPEG2VIDEO,
0x7ab2ada2, 0x81b6, 0x4f14, 0xb3, 0xc8, 0xd0, 0xc4, 0x86, 0x39, 0x3b, 0x67)

//
// DirectShow's include file based on ksmedia.h from WDM DDK
//
#include "ksuuids.h"


// -- Well known time format GUIDs ---


// 00000000-0000-0000-0000-000000000000
OUR_GUID_ENTRY(TIME_FORMAT_NONE,
0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

// 7b785570-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FRAME,
0x7b785570, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785571-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_BYTE,
0x7b785571, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785572-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_SAMPLE,
0x7b785572, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785573-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FIELD,
0x7b785573, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// 7b785574-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_MEDIA_TIME,
0x7b785574, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// for IKsPropertySet

// 9B00F101-1567-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(AMPROPSETID_Pin,
0x9b00f101, 0x1567, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// fb6c4281-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CAPTURE,
0xfb6c4281, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4282-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_PREVIEW,
0xfb6c4282, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4283-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_ANALOGVIDEOIN,
0xfb6c4283, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4284-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VBI,
0xfb6c4284, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4285-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT,
0xfb6c4285, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4286-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_NABTS,
0xfb6c4286, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4287-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_EDS,
0xfb6c4287, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4288-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TELETEXT,
0xfb6c4288, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4289-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CC,
0xfb6c4289, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428a-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_STILL,
0xfb6c428a, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428b-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TIMECODE,
0xfb6c428b, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428c-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT_VBI,
0xfb6c428c, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)


// the following special GUIDS are used by ICaptureGraphBuilder::FindInterface

// {AC798BE0-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_UPSTREAM_ONLY,
0xac798be0, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// {AC798BE1-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_DOWNSTREAM_ONLY,
0xac798be1, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -------------------------------------------------------------------------
// KSProxy GUIDS
// -------------------------------------------------------------------------

// {266EEE41-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_TVTunerFilterPropertyPage,
0x266eee41, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// {71F96461-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage,
0x71f96461, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96463-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,
0x71f96463, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96464-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoProcAmpPropertyPage,
0x71f96464, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96465-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CameraControlPropertyPage,
0x71f96465, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96466-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_AnalogVideoDecoderPropertyPage,
0x71f96466, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96467-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoStreamConfigPropertyPage,
0x71f96467, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {37E92A92-D9AA-11d2-BF84-8EF2B1555AED} Audio Renderer Advanced Property Page
OUR_GUID_ENTRY(CLSID_AudioRendererAdvancedProperties,
0x37e92a92, 0xd9aa, 0x11d2, 0xbf, 0x84, 0x8e, 0xf2, 0xb1, 0x55, 0x5a, 0xed)


// -------------------------------------------------------------------------
// VMR GUIDS
// -------------------------------------------------------------------------

// {B87BEB7B-8D29-423f-AE4D-6582C10175AC}
OUR_GUID_ENTRY(CLSID_VideoMixingRenderer,
0xB87BEB7B, 0x8D29, 0x423f, 0xAE, 0x4D, 0x65, 0x82, 0xC1, 0x01, 0x75, 0xAC)

// {6BC1CFFA-8FC1-4261-AC22-CFB4CC38DB50}
OUR_GUID_ENTRY(CLSID_VideoRendererDefault,
0x6BC1CFFA, 0x8FC1, 0x4261, 0xAC, 0x22, 0xCF, 0xB4, 0xCC, 0x38, 0xDB, 0x50)

// {99d54f63-1a69-41ae-aa4d-c976eb3f0713}
OUR_GUID_ENTRY(CLSID_AllocPresenter,
0x99d54f63, 0x1a69, 0x41ae, 0xaa, 0x4d, 0xc9, 0x76, 0xeb, 0x3f, 0x07, 0x13)

// {4444ac9e-242e-471b-a3c7-45dcd46352bc}
OUR_GUID_ENTRY(CLSID_AllocPresenterDDXclMode,
0x4444ac9e, 0x242e, 0x471b, 0xa3, 0xc7, 0x45, 0xdc, 0xd4, 0x63, 0x52, 0xbc)

// {6f26a6cd-967b-47fd-874a-7aed2c9d25a2}
OUR_GUID_ENTRY(CLSID_VideoPortManager,
0x6f26a6cd, 0x967b, 0x47fd, 0x87, 0x4a, 0x7a, 0xed, 0x2c, 0x9d, 0x25, 0xa2)


// -------------------------------------------------------------------------
// VMR GUIDS for DX9
// -------------------------------------------------------------------------

// {51b4abf3-748f-4e3b-a276-c828330e926a}
OUR_GUID_ENTRY(CLSID_VideoMixingRenderer9,
0x51b4abf3, 0x748f, 0x4e3b, 0xa2, 0x76, 0xc8, 0x28, 0x33, 0x0e, 0x92, 0x6a)


// -------------------------------------------------------------------------
// EVR GUIDS
// -------------------------------------------------------------------------

// {FA10746C-9B63-4b6c-BC49-FC300EA5F256}
OUR_GUID_ENTRY(CLSID_EnhancedVideoRenderer,
0xfa10746c, 0x9b63, 0x4b6c, 0xbc, 0x49, 0xfc, 0x30, 0xe, 0xa5, 0xf2, 0x56)

// {E474E05A-AB65-4f6a-827C-218B1BAAF31F}
OUR_GUID_ENTRY(CLSID_MFVideoMixer9,
0xE474E05A, 0xAB65, 0x4f6a, 0x82, 0x7C, 0x21, 0x8B, 0x1B, 0xAA, 0xF3, 0x1F)

// {98455561-5136-4d28-AB08-4CEE40EA2781}
OUR_GUID_ENTRY(CLSID_MFVideoPresenter9,
0x98455561, 0x5136, 0x4d28, 0xab, 0x8, 0x4c, 0xee, 0x40, 0xea, 0x27, 0x81)

// {a0a7a57b-59b2-4919-a694-add0a526c373}
OUR_GUID_ENTRY(CLSID_EVRTearlessWindowPresenter9,
0xa0a7a57b, 0x59b2, 0x4919, 0xa6, 0x94, 0xad, 0xd0, 0xa5, 0x26, 0xc3, 0x73)

// {62079164-233b-41f8-a80f-f01705f514a8}
OUR_GUID_ENTRY(CLSID_EVRPlaybackPipelineOptimizer,
0x62079164, 0x233b, 0x41f8, 0xa8, 0x0f, 0xf0, 0x17, 0x05, 0xf5, 0x14, 0xa8)

// {e447df01-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df02-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df03-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df04-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df05-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df06-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df07-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df08-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df09-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df0a-10ca-4d17-b17e-6a840f8a3a4c}
OUR_GUID_ENTRY( EVRConfig_ForceBob,                0xe447df01,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_AllowDropToBob,          0xe447df02,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_ForceThrottle,           0xe447df03,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_AllowDropToThrottle,     0xe447df04,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_ForceHalfInterlace,      0xe447df05,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_AllowDropToHalfInterlace,0xe447df06,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_ForceScaling,            0xe447df07,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_AllowScaling,            0xe447df08,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_ForceBatching,           0xe447df09,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_AllowBatching,           0xe447df0a,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)


// -------------------------------------------------------------------------
// BDA Network Provider GUIDS
// -------------------------------------------------------------------------

// This is the GUID for the generic NP which would replace ATSC, DVBT, DVBS
// and DVBC NP. All the other GUIDs are still kept for backward compatibility
// {B2F3A67C-29DA-4c78-8831-091ED509A475}
OUR_GUID_ENTRY(CLSID_NetworkProvider,
0xb2f3a67c, 0x29da, 0x4c78, 0x88, 0x31, 0x9, 0x1e, 0xd5, 0x9, 0xa4, 0x75)

// {0DAD2FDD-5FD7-11D3-8F50-00C04F7971E2}
OUR_GUID_ENTRY(CLSID_ATSCNetworkProvider,
0x0dad2fdd, 0x5fd7, 0x11d3, 0x8f, 0x50, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2)

// {E3444D16-5AC4-4386-88DF-13FD230E1DDA}
OUR_GUID_ENTRY(CLSID_ATSCNetworkPropertyPage,
0xe3444d16, 0x5ac4, 0x4386, 0x88, 0xdf, 0x13, 0xfd, 0x23, 0x0e, 0x1d, 0xda)

// {FA4B375A-45B4-4d45-8440-263957B11623}
OUR_GUID_ENTRY(CLSID_DVBSNetworkProvider,
0xfa4b375a, 0x45b4, 0x4d45, 0x84, 0x40, 0x26, 0x39, 0x57, 0xb1, 0x16, 0x23)

// {216C62DF-6D7F-4e9a-8571-05F14EDB766A}
OUR_GUID_ENTRY(CLSID_DVBTNetworkProvider,
0x216c62df, 0x6d7f, 0x4e9a, 0x85, 0x71, 0x5, 0xf1, 0x4e, 0xdb, 0x76, 0x6a)

// {DC0C0FE7-0485-4266-B93F-68FBF80ED834}
OUR_GUID_ENTRY(CLSID_DVBCNetworkProvider,
0xdc0c0fe7, 0x485, 0x4266, 0xb9, 0x3f, 0x68, 0xfb, 0xf8, 0xe, 0xd8, 0x34)

// -------------------------------------------------------------------------
// attribute GUIDs
// -------------------------------------------------------------------------

// {EB7836CA-14FF-4919-BCE7-3AF12319E50C}
OUR_GUID_ENTRY(DSATTRIB_UDCRTag,
0xEB7836CA, 0x14FF, 0x4919, 0xbc, 0xe7, 0x3a, 0xf1, 0x23, 0x19, 0xe5, 0x0c)

// {2F5BAE02-7B8F-4f60-82D6-E4EA2F1F4C99}
OUR_GUID_ENTRY(DSATTRIB_PicSampleSeq,
0x2f5bae02, 0x7b8f, 0x4f60, 0x82, 0xd6, 0xe4, 0xea, 0x2f, 0x1f, 0x4c, 0x99)

// {5A5F08CA-55C2-4033-92AB-55DB8F781226}
OUR_GUID_ENTRY(DSATTRIB_OptionalVideoAttributes,
0x5A5F08CA, 0x55C2, 0x4033, 0x92, 0xAB, 0x55, 0xDB, 0x8F, 0x78, 0x12, 0x26)

// {e7e050fb-dd5d-40dd-9915-35dcb81bdc8a}
OUR_GUID_ENTRY(DSATTRIB_CC_CONTAINER_INFO,
0xe7e050fb, 0xdd5d, 0x40dd, 0x99, 0x15, 0x35, 0xDC, 0xB8, 0x1B, 0xDC, 0x8a)

// {B622F612-47AD-4671-AD6C-05A98E65DE3A}
OUR_GUID_ENTRY(DSATTRIB_TRANSPORT_PROPERTIES,
0xb622f612, 0x47ad, 0x4671, 0xad, 0x6c, 0x5, 0xa9, 0x8e, 0x65, 0xde, 0x3a)

// {e0b56679-12b9-43cc-b7df-578caa5a7b63}
OUR_GUID_ENTRY(DSATTRIB_PBDATAG_ATTRIBUTE,
0xe0b56679, 0x12b9, 0x43cc, 0xb7, 0xdf, 0x57, 0x8c, 0xaa, 0x5a, 0x7b, 0x63)

// {0c1a5614-30cd-4f40-bcbf-d03e52306207}
OUR_GUID_ENTRY( DSATTRIB_CAPTURE_STREAMTIME,
0x0c1a5614, 0x30cd, 0x4f40, 0xbc, 0xbf, 0xd0, 0x3e, 0x52, 0x30, 0x62, 0x07)

// {5FB5673B-0A2A-4565-827B-6853FD75E611}               DSATTRIB_DSHOW_STREAM_DESC
OUR_GUID_ENTRY(DSATTRIB_DSHOW_STREAM_DESC,
0x5fb5673b, 0xa2a, 0x4565, 0x82, 0x7b, 0x68, 0x53, 0xfd, 0x75, 0xe6, 0x11)

// {892CD111-72F3-411d-8B91-A9E9123AC29A}
OUR_GUID_ENTRY(DSATTRIB_SAMPLE_LIVE_STREAM_TIME,
0x892cd111, 0x72f3, 0x411d, 0x8b, 0x91, 0xa9, 0xe9, 0x12, 0x3a, 0xc2, 0x9a)

// UUID for supported UDRI TAG tables
OUR_GUID_ENTRY( UUID_UdriTagTables,
0xe1b98d74, 0x9778, 0x4878, 0xb6, 0x64, 0xeb, 0x20, 0x20, 0x36, 0x4d, 0x88)

// UUID for supported WMDRM TAG tables
OUR_GUID_ENTRY( UUID_WMDRMTagTables,
0x5DCD1101, 0x9263, 0x45bb, 0xa4, 0xd5, 0xc4, 0x15, 0xab, 0x8c, 0x58, 0x9c)

// -------------------------------------------------------------------------
// TVE Receiver filter guids
// -------------------------------------------------------------------------

// The CLSID used by the TVE Receiver filter
// {05500280-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_DShowTVEFilter,
0x05500280, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// {05500281-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterTuneProperties,
0x05500281, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)


// {05500282-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterCCProperties,
0x05500282, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// {05500283-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterStatsProperties,
0x05500283, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// -------------------------------------------------------------------------
// Defined ENCAPI parameter GUIDs
// -------------------------------------------------------------------------

// The CLSID for the original IVideoEncoder proxy plug-in
// {B43C4EEC-8C32-4791-9102-508ADA5EE8E7}
OUR_GUID_ENTRY(CLSID_IVideoEncoderProxy,
0xb43c4eec, 0x8c32, 0x4791, 0x91, 0x2, 0x50, 0x8a, 0xda, 0x5e, 0xe8, 0xe7)

// The CLSID for the ICodecAPI proxy plug-in
// {7ff0997a-1999-4286-a73c-622b8814e7eb}
OUR_GUID_ENTRY(CLSID_ICodecAPIProxy,
0x7ff0997a, 0x1999, 0x4286, 0xa7, 0x3c, 0x62, 0x2b, 0x88, 0x14, 0xe7, 0xeb )

// The CLSID for the combination ICodecAPI/IVideoEncoder proxy plug-in
// {b05dabd9-56e5-4fdc-afa4-8a47e91f1c9c}
OUR_GUID_ENTRY(CLSID_IVideoEncoderCodecAPIProxy,
0xb05dabd9, 0x56e5, 0x4fdc, 0xaf, 0xa4, 0x8a, 0x47, 0xe9, 0x1f, 0x1c, 0x9c )

#ifndef __ENCODER_API_GUIDS__
#define __ENCODER_API_GUIDS__

// {49CC4C43-CA83-4ad4-A9AF-F3696AF666DF}
OUR_GUID_ENTRY(ENCAPIPARAM_BITRATE,
0x49cc4c43, 0xca83, 0x4ad4, 0xa9, 0xaf, 0xf3, 0x69, 0x6a, 0xf6, 0x66, 0xdf)

// {703F16A9-3D48-44a1-B077-018DFF915D19}
OUR_GUID_ENTRY(ENCAPIPARAM_PEAK_BITRATE,
0x703f16a9, 0x3d48, 0x44a1, 0xb0, 0x77, 0x1, 0x8d, 0xff, 0x91, 0x5d, 0x19)

// {EE5FB25C-C713-40d1-9D58-C0D7241E250F}
OUR_GUID_ENTRY(ENCAPIPARAM_BITRATE_MODE,
0xee5fb25c, 0xc713, 0x40d1, 0x9d, 0x58, 0xc0, 0xd7, 0x24, 0x1e, 0x25, 0xf)

// {0C0171DB-FEFC-4af7-9991-A5657C191CD1}
OUR_GUID_ENTRY(ENCAPIPARAM_SAP_MODE,
0xc0171db, 0xfefc, 0x4af7, 0x99, 0x91, 0xa5, 0x65, 0x7c, 0x19, 0x1c, 0xd1)

// for kernel control

// {62b12acf-f6b0-47d9-9456-96f22c4e0b9d}
OUR_GUID_ENTRY(CODECAPI_CHANGELISTS,
0x62b12acf, 0xf6b0, 0x47d9, 0x94, 0x56, 0x96, 0xf2, 0x2c, 0x4e, 0x0b, 0x9d)

// {7112e8e1-3d03-47ef-8e60-03f1cf537301 }
OUR_GUID_ENTRY(CODECAPI_VIDEO_ENCODER,
0x7112e8e1, 0x3d03, 0x47ef, 0x8e, 0x60, 0x03, 0xf1, 0xcf, 0x53, 0x73, 0x01)

// {b9d19a3e-f897-429c-bc46-8138b7272b2d }
OUR_GUID_ENTRY(CODECAPI_AUDIO_ENCODER,
0xb9d19a3e, 0xf897, 0x429c, 0xbc, 0x46, 0x81, 0x38, 0xb7, 0x27, 0x2b, 0x2d)

// {6c5e6a7c-acf8-4f55-a999-1a628109051b }
OUR_GUID_ENTRY(CODECAPI_SETALLDEFAULTS,
0x6c5e6a7c, 0xacf8, 0x4f55, 0xa9, 0x99, 0x1a, 0x62, 0x81, 0x09, 0x05, 0x1b)

// {6a577e92-83e1-4113-adc2-4fcec32f83a1 }
OUR_GUID_ENTRY(CODECAPI_ALLSETTINGS,
0x6a577e92, 0x83e1, 0x4113, 0xad, 0xc2, 0x4f, 0xce, 0xc3, 0x2f, 0x83, 0xa1)

// {0581af97-7693-4dbd-9dca-3f9ebd6585a1 }
OUR_GUID_ENTRY(CODECAPI_SUPPORTSEVENTS,
0x0581af97, 0x7693, 0x4dbd, 0x9d, 0xca, 0x3f, 0x9e, 0xbd, 0x65, 0x85, 0xa1 )

// {1cb14e83-7d72-4657-83fd-47a2c5b9d13d }
OUR_GUID_ENTRY(CODECAPI_CURRENTCHANGELIST,
0x1cb14e83, 0x7d72, 0x4657, 0x83, 0xfd, 0x47, 0xa2, 0xc5, 0xb9, 0xd1, 0x3d )

// {1f26a602-2b5c-4b63-b8e8-9ea5c1a7dc2e}
OUR_GUID_ENTRY(CLSID_SBE2MediaTypeProfile,
0x1f26a602, 0x2b5c, 0x4b63, 0xb8, 0xe8, 0x9e, 0xa5, 0xc1, 0xa7, 0xdc, 0x2e )

// {3E458037-0CA6-41aa-A594-2AA6C02D709B}
OUR_GUID_ENTRY(CLSID_SBE2FileScan,
0x3e458037, 0xca6, 0x41aa, 0xa5, 0x94, 0x2a, 0xa6, 0xc0, 0x2d, 0x70, 0x9b) ;

// When generating strmiids.lib, include codecapi definitions
#ifdef INITGUID
#define UUID_GEN
#include <codecapi.h>
#endif

#endif // __ENCODER_API_GUIDS__

// -----------------------------------------------
// Used for decoders that exposing ICodecAPI
// -----------------------------------------------
OUR_GUID_ENTRY(CODECAPI_AVDecMmcssClass,
0xe0ad4828, 0xdf66, 0x4893, 0x9f, 0x33, 0x78, 0x8a, 0xa4, 0xec, 0x40, 0x82)

#undef OUR_GUID_ENTRY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vdslun.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vdslun.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __vdslun_h__
#define __vdslun_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vdslun_0000_0000 */
/* [local] */ 

typedef 
enum _VDS_STORAGE_IDENTIFIER_CODE_SET
    {	VDSStorageIdCodeSetReserved	= 0,
	VDSStorageIdCodeSetBinary	= 1,
	VDSStorageIdCodeSetAscii	= 2,
	VDSStorageIdCodeSetUtf8	= 3
    } 	VDS_STORAGE_IDENTIFIER_CODE_SET;

typedef 
enum _VDS_STORAGE_IDENTIFIER_TYPE
    {	VDSStorageIdTypeVendorSpecific	= 0,
	VDSStorageIdTypeVendorId	= 1,
	VDSStorageIdTypeEUI64	= 2,
	VDSStorageIdTypeFCPHName	= 3,
	VDSStorageIdTypePortRelative	= 4,
	VDSStorageIdTypeTargetPortGroup	= 5,
	VDSStorageIdTypeLogicalUnitGroup	= 6,
	VDSStorageIdTypeMD5LogicalUnitIdentifier	= 7,
	VDSStorageIdTypeScsiNameString	= 8
    } 	VDS_STORAGE_IDENTIFIER_TYPE;

typedef 
enum _VDS_STORAGE_BUS_TYPE
    {	VDSBusTypeUnknown	= 0,
	VDSBusTypeScsi	= 0x1,
	VDSBusTypeAtapi	= 0x2,
	VDSBusTypeAta	= 0x3,
	VDSBusType1394	= 0x4,
	VDSBusTypeSsa	= 0x5,
	VDSBusTypeFibre	= 0x6,
	VDSBusTypeUsb	= 0x7,
	VDSBusTypeRAID	= 0x8,
	VDSBusTypeiScsi	= 0x9,
	VDSBusTypeSas	= 0xa,
	VDSBusTypeSata	= 0xb,
	VDSBusTypeSd	= 0xc,
	VDSBusTypeMmc	= 0xd,
	VDSBusTypeMax	= 0xe,
	VDSBusTypeFileBackedVirtual	= 0xf,
	VDSBusTypeMaxReserved	= 0x7f
    } 	VDS_STORAGE_BUS_TYPE;

typedef struct _VDS_STORAGE_IDENTIFIER
    {
    VDS_STORAGE_IDENTIFIER_CODE_SET m_CodeSet;
    VDS_STORAGE_IDENTIFIER_TYPE m_Type;
    ULONG m_cbIdentifier;
    BYTE *m_rgbIdentifier;
    } 	VDS_STORAGE_IDENTIFIER;

typedef struct _VDS_STORAGE_DEVICE_ID_DESCRIPTOR
    {
    ULONG m_version;
    ULONG m_cIdentifiers;
    VDS_STORAGE_IDENTIFIER *m_rgIdentifiers;
    } 	VDS_STORAGE_DEVICE_ID_DESCRIPTOR;

typedef 
enum _VDS_INTERCONNECT_ADDRESS_TYPE
    {	VDS_IA_UNKNOWN	= 0,
	VDS_IA_FCFS	= 1,
	VDS_IA_FCPH	= 2,
	VDS_IA_FCPH3	= 3,
	VDS_IA_MAC	= 4,
	VDS_IA_SCSI	= 5
    } 	VDS_INTERCONNECT_ADDRESS_TYPE;

typedef struct _VDS_INTERCONNECT
    {
    VDS_INTERCONNECT_ADDRESS_TYPE m_addressType;
    ULONG m_cbPort;
    BYTE *m_pbPort;
    ULONG m_cbAddress;
    BYTE *m_pbAddress;
    } 	VDS_INTERCONNECT;

typedef struct _VDS_LUN_INFORMATION
    {
    ULONG m_version;
    BYTE m_DeviceType;
    BYTE m_DeviceTypeModifier;
    BOOL m_bCommandQueueing;
    VDS_STORAGE_BUS_TYPE m_BusType;
    char *m_szVendorId;
    char *m_szProductId;
    char *m_szProductRevision;
    char *m_szSerialNumber;
    GUID m_diskSignature;
    VDS_STORAGE_DEVICE_ID_DESCRIPTOR m_deviceIdDescriptor;
    ULONG m_cInterconnects;
    VDS_INTERCONNECT *m_rgInterconnects;
    } 	VDS_LUN_INFORMATION;

#define	VER_VDS_LUN_INFORMATION	( 1 )



extern RPC_IF_HANDLE __MIDL_itf_vdslun_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdslun_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\VdmDbg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1985-1999, Microsoft Corporation

Module Name:

    vdmdbg.h

Abstract:

    Prodecure declarations, constant definitions, type definition and macros
    for the VDMDBG.DLL VDM Debugger interface.

--*/

#ifndef _VDMDBG_
#define _VDMDBG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <pshpack4.h>

#define STATUS_VDM_EVENT    STATUS_SEGMENT_NOTIFICATION

#ifndef DBG_SEGLOAD
#define DBG_SEGLOAD     0
#define DBG_SEGMOVE     1
#define DBG_SEGFREE     2
#define DBG_MODLOAD     3
#define DBG_MODFREE     4
#define DBG_SINGLESTEP  5
#define DBG_BREAK       6
#define DBG_GPFAULT     7
#define DBG_DIVOVERFLOW 8
#define DBG_INSTRFAULT  9
#define DBG_TASKSTART   10
#define DBG_TASKSTOP    11
#define DBG_DLLSTART    12
#define DBG_DLLSTOP     13
#define DBG_ATTACH      14
#define DBG_TOOLHELP    15
#define DBG_STACKFAULT  16
#define DBG_WOWINIT     17
#define DBG_TEMPBP      18
#define DBG_MODMOVE     19
#define DBG_INIT        20
#define DBG_GPFAULT2    21
#endif

//
// These flags are set in the same WORD as the DBG_ event id's (above).
//
#define VDMEVENT_NEEDS_INTERACTIVE  0x8000
#define VDMEVENT_VERBOSE            0x4000
#define VDMEVENT_PE                 0x2000
#define VDMEVENT_ALLFLAGS           0xe000
//
// These flags are set in the second WORD of the exception event
// parameters.
//
#define VDMEVENT_V86                0x0001
#define VDMEVENT_PM16               0x0002

//
// The following flags control the contents of the CONTEXT structure.
//

#define VDMCONTEXT_i386    0x00010000    // this assumes that i386 and
#define VDMCONTEXT_i486    0x00010000    // i486 have identical context records

#define VDMCONTEXT_CONTROL         (VDMCONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define VDMCONTEXT_INTEGER         (VDMCONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define VDMCONTEXT_SEGMENTS        (VDMCONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define VDMCONTEXT_FLOATING_POINT  (VDMCONTEXT_i386 | 0x00000008L) // 387 state
#define VDMCONTEXT_DEBUG_REGISTERS (VDMCONTEXT_i386 | 0x00000010L) // DB 0-3,6,7
#define VDMCONTEXT_EXTENDED_REGISTERS  (VDMCONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define VDMCONTEXT_FULL (VDMCONTEXT_CONTROL | VDMCONTEXT_INTEGER |\
                      VDMCONTEXT_SEGMENTS)


#ifdef _X86_

// On x86 machines, just copy the definition of the CONTEXT and LDT_ENTRY
// structures.
typedef struct _CONTEXT VDMCONTEXT;
typedef struct _LDT_ENTRY VDMLDT_ENTRY;

#else // _X86_

//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

typedef struct _FLOATING_SAVE_AREA {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   TagWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    UCHAR   RegisterArea[SIZE_OF_80387_REGISTERS];
    ULONG   Cr0NpxState;
} FLOATING_SAVE_AREA;

//
// Simulated context structure for the 16-bit environment
//

typedef struct _VDMCONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //
    // CONTEXT_FULL on some systems (MIPS namely) does not contain the
    // CONTEXT_SEGMENTS definition.  VDMDBG assumes that CONTEXT_INTEGER also
    // includes CONTEXT_SEGMENTS to account for this.
    //

    ULONG ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;

} VDMCONTEXT;

//
//  LDT descriptor entry
//

typedef struct _VDMLDT_ENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} VDMLDT_ENTRY;

#endif // _X86_

typedef VDMCONTEXT *LPVDMCONTEXT;
typedef VDMLDT_ENTRY *LPVDMLDT_ENTRY;

#define VDMCONTEXT_TO_PROGRAM_COUNTER(Context) (PVOID)((Context)->Eip)

#define VDMCONTEXT_LENGTH  (sizeof(VDMCONTEXT))
#define VDMCONTEXT_ALIGN   (sizeof(ULONG))
#define VDMCONTEXT_ROUND   (VDMCONTEXT_ALIGN - 1)

#define V86FLAGS_CARRY      0x00001
#define V86FLAGS_PARITY     0x00004
#define V86FLAGS_AUXCARRY   0x00010
#define V86FLAGS_ZERO       0x00040
#define V86FLAGS_SIGN       0x00080
#define V86FLAGS_TRACE      0x00100
#define V86FLAGS_INTERRUPT  0x00200
#define V86FLAGS_DIRECTION  0x00400
#define V86FLAGS_OVERFLOW   0x00800
#define V86FLAGS_IOPL       0x03000
#define V86FLAGS_IOPL_BITS  0x12
#define V86FLAGS_RESUME     0x10000
#define V86FLAGS_V86        0x20000     // Used to detect RealMode v. ProtMode
#define V86FLAGS_ALIGNMENT  0x40000

#define MAX_MODULE_NAME  8 + 1
#define MAX_PATH16      255

typedef struct _SEGMENT_NOTE {
    WORD    Selector1;                      // Selector of operation
    WORD    Selector2;                      // Dest. Sel. for moving segments
    WORD    Segment;                        // Segment within Module
    CHAR    Module[MAX_MODULE_NAME+1];      // Module name
    CHAR    FileName[MAX_PATH16+1];         // PathName to executable image
    WORD    Type;                           // Code / Data, etc.
    DWORD   Length;                         // Length of image
} SEGMENT_NOTE;

typedef struct _IMAGE_NOTE {
    CHAR    Module[MAX_MODULE_NAME+1];      // Module
    CHAR    FileName[MAX_PATH16+1];         // Path to executable image
    WORD    hModule;                        // 16-bit hModule
    WORD    hTask;                          // 16-bit hTask
} IMAGE_NOTE;

typedef struct {
    DWORD   dwSize;
    char    szModule[MAX_MODULE_NAME+1];
    HANDLE  hModule;
    WORD    wcUsage;
    char    szExePath[MAX_PATH16+1];
    WORD    wNext;
} MODULEENTRY, *LPMODULEENTRY;


#define SN_CODE 0                           // Protect mode code segment
#define SN_DATA 1                           // Protect mode data segment
#define SN_V86  2                           // V86 mode segment

typedef struct _TEMP_BP_NOTE {
    WORD    Seg;                            // Dest. Segment or Selector
    DWORD   Offset;                         // Dest. Offset
    BOOL    bPM;                            // TRUE for PM, FALSE for V86
} TEMP_BP_NOTE;

typedef struct _VDM_SEGINFO {
    WORD    Selector;                       // Selector or RM segment
    WORD    SegNumber;                      // Logical segment number in executable
    DWORD   Length;                         // Length of segment
    WORD    Type;                           // Type (0=v86, 1=PM)
    CHAR    ModuleName[MAX_MODULE_NAME];    // Module
    CHAR    FileName[MAX_PATH16];           // Path to executable image
} VDM_SEGINFO;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

typedef struct {
    DWORD   dwSize;
    DWORD   dwAddress;
    DWORD   dwBlockSize;
    HANDLE  hBlock;
    WORD    wcLock;
    WORD    wcPageLock;
    WORD    wFlags;
    BOOL    wHeapPresent;
    HANDLE  hOwner;
    WORD    wType;
    WORD    wData;
    DWORD   dwNext;
    DWORD   dwNextAlt;
} GLOBALENTRY, *LPGLOBALENTRY;

typedef DWORD (CALLBACK* DEBUGEVENTPROC)( LPDEBUG_EVENT, LPVOID );

// Macros to access VDM_EVENT parameters
#define W1(x) ((USHORT)(x.ExceptionInformation[0]))
#define W2(x) ((USHORT)(x.ExceptionInformation[0] >> 16))
#define W3(x) ((USHORT)(x.ExceptionInformation[1]))
#define W4(x) ((USHORT)(x.ExceptionInformation[1] >> 16))
#define DW3(x) (x.ExceptionInformation[2])
#define DW4(x) (x.ExceptionInformation[3])

#include <poppack.h>


BOOL
WINAPI
VDMProcessException(
    LPDEBUG_EVENT   lpDebugEvent
    );

BOOL
WINAPI
VDMGetThreadSelectorEntry(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    LPVDMLDT_ENTRY  lpSelectorEntry
    );

ULONG
WINAPI
VDMGetPointer(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    DWORD           dwOffset,
    BOOL            fProtMode
    );

// VDMGetThreadContext, VDMSetThreadContext are obselete
// Use VDMGetContext, VDMSetContext
BOOL
WINAPI
VDMGetContext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPVDMCONTEXT    lpVDMContext
);

BOOL
WINAPI
VDMSetContext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPVDMCONTEXT    lpVDMContext
);

BOOL
WINAPI
VDMGetSelectorModule(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    PUINT           lpSegmentNumber,
    __in LPSTR      lpModuleName,
    UINT            nNameSize,
    __in LPSTR      lpModulePath,
    UINT            nPathSize
);

BOOL
WINAPI
VDMGetModuleSelector(
    HANDLE          hProcess,
    HANDLE          hThread,
    UINT            wSegmentNumber,
    __in LPSTR      lpModuleName,
    LPWORD          lpSelector
);

BOOL
WINAPI
VDMModuleFirst(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMModuleNext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMGlobalFirst(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMGlobalNext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

typedef BOOL (WINAPI *PROCESSENUMPROC)( DWORD dwProcessId, DWORD dwAttributes, LPARAM lpUserDefined );
typedef BOOL (WINAPI *TASKENUMPROC)( DWORD dwThreadId, WORD hMod16, WORD hTask16, LPARAM lpUserDefined );
typedef BOOL (WINAPI *TASKENUMPROCEX)( DWORD dwThreadId, WORD hMod16, WORD hTask16,
                                       PSZ pszModName, PSZ pszFileName, LPARAM lpUserDefined );

#define WOW_SYSTEM  (DWORD)0x0001

INT
WINAPI
VDMEnumProcessWOW(
    PROCESSENUMPROC fp,
    LPARAM          lparam
);

INT
WINAPI
VDMEnumTaskWOW(
    DWORD           dwProcessId,
    TASKENUMPROC    fp,
    LPARAM          lparam
);

//
// VDMEnumTaskWOWEx is the same as VDMEnumTaskWOW except
// the callback procedure gets two more parameters,
// the module name of the EXE and the full path to the
// EXE.
//

INT
WINAPI
VDMEnumTaskWOWEx(
    DWORD           dwProcessId,
    TASKENUMPROCEX  fp,
    LPARAM          lparam
);

//
// VDMTerminateTaskWOW rudely terminates a 16-bit WOW task
// similar to the way TerminateProcess kills a Win32
// process.
//

BOOL
WINAPI
VDMTerminateTaskWOW(
    DWORD           dwProcessId,
    WORD            htask
);

//
// VDMStartTaskInWOW launches a Win16 task in a pre-existing
// WOW VDM.  Note that the caller is responsible for ensuring
// the program is a 16-bit Windows program.  If it is a DOS
// or Win32 program, it will still be launched from within
// the target WOW VDM.
//
// The supplied command line and show command are passed
// unchanged to the 16-bit WinExec API in the target WOW VDM.
//
// Note this routine is ANSI-only.
//

BOOL
WINAPI
VDMStartTaskInWOW(
    DWORD           dwProcessId,
    __in LPSTR      lpCommandLine,
    WORD            wShow
);

//
// VDMKillWOW is not implemented.
//

BOOL
WINAPI
VDMKillWOW(
    VOID
);

//
// VDMDetectWOW is not implemented.
//

BOOL
WINAPI
VDMDetectWOW(
    VOID
);

BOOL
WINAPI
VDMBreakThread(
    HANDLE          hProcess,
    HANDLE          hThread
);

DWORD
WINAPI
VDMGetDbgFlags(
    HANDLE          hProcess
    );

BOOL
WINAPI
VDMSetDbgFlags(
    HANDLE          hProcess,
    DWORD           dwFlags
    );

#define VDMDBG_BREAK_DOSTASK      0x00000001
#define VDMDBG_BREAK_WOWTASK      0x00000002
#define VDMDBG_BREAK_LOADDLL      0x00000004
#define VDMDBG_BREAK_EXCEPTIONS   0x00000008
#define VDMDBG_BREAK_DEBUGGER     0x00000010
#define VDMDBG_TRACE_HISTORY      0x00000080
#define VDMDBG_BREAK_DIVIDEBYZERO 0x00000100

#define VDMDBG_INITIAL_FLAGS      VDMDBG_BREAK_DIVIDEBYZERO

//
// VDMIsModuleLoaded can be used to determine if the 16-bit
// executable referenced by the full path name parameter is
// loaded in ntvdm.
//
// Note that this function uses an internal table in vdmdbg.dll
// to determine a module's existence. One important usage of this
// function is to print a message when a particular module is
// loaded for the first time. To accomplish this, call this
// routine during a DBG_SEGLOAD notification BEFORE the entry
// point VDMProcessException has been called. If it returns FALSE,
// then the module has not yet been loaded.
//
BOOL
WINAPI
VDMIsModuleLoaded(
    __in LPSTR szPath
    );

BOOL
WINAPI
VDMGetSegmentInfo(
    WORD Selector,
    ULONG Offset,
    BOOL bProtectMode,
    VDM_SEGINFO *pSegInfo
    );

//
// VDMGetSymbol
//
// This routine reads the standard .SYM file format.
//
// szModule         - module name (max 9 chars)
// SegNumber        - logical segment number of segment (see VDM_SEGINFO)
// Offset           - offset in segment
// bProtectMode     - TRUE for PM, FALSE for V86 mode
// bNextSymbol      - FALSE to find nearest sym BEFORE offset, TRUE for AFTER
// szSymbolName     - receives symbol name (must point to 256 byte buffer)
// pDisplacement    - distance in bytes from nearest symbol
//

BOOL
WINAPI
VDMGetSymbol(
    __in LPSTR szModule,
    WORD SegNumber,
    DWORD Offset,
    BOOL bProtectMode,
    BOOL bNextSymbol,
    __out LPSTR szSymbolName,
    PDWORD pDisplacement
    );

BOOL
WINAPI
VDMGetAddrExpression(
    __in LPSTR  szModule,
    __in LPSTR  szSymbol,
    PWORD  Selector,
    PDWORD Offset,
    PWORD  Type
    );

#define VDMADDR_V86     2
#define VDMADDR_PM16    4
#define VDMADDR_PM32   16

//
// typedefs for main entry points
//

typedef BOOL  (WINAPI *VDMPROCESSEXCEPTIONPROC)(LPDEBUG_EVENT);
typedef BOOL  (WINAPI *VDMGETTHREADSELECTORENTRYPROC)(HANDLE,HANDLE,DWORD,LPVDMLDT_ENTRY);
typedef ULONG (WINAPI *VDMGETPOINTERPROC)(HANDLE,HANDLE,WORD,DWORD,BOOL);
typedef BOOL  (WINAPI *VDMGETCONTEXTPROC)(HANDLE,HANDLE,LPVDMCONTEXT);
typedef BOOL  (WINAPI *VDMSETCONTEXTPROC)(HANDLE,HANDLE,LPVDMCONTEXT);
typedef BOOL  (WINAPI *VDMKILLWOWPROC)(VOID);
typedef BOOL  (WINAPI *VDMDETECTWOWPROC)(VOID);
typedef BOOL  (WINAPI *VDMBREAKTHREADPROC)(HANDLE);
typedef BOOL  (WINAPI *VDMGETSELECTORMODULEPROC)(HANDLE,HANDLE,WORD,PUINT,LPSTR, UINT,LPSTR, UINT);
typedef BOOL  (WINAPI *VDMGETMODULESELECTORPROC)(HANDLE,HANDLE,UINT,LPSTR,LPWORD);
typedef BOOL  (WINAPI *VDMMODULEFIRSTPROC)(HANDLE,HANDLE,LPMODULEENTRY,DEBUGEVENTPROC,LPVOID);
typedef BOOL  (WINAPI *VDMMODULENEXTPROC)(HANDLE,HANDLE,LPMODULEENTRY,DEBUGEVENTPROC,LPVOID);
typedef BOOL  (WINAPI *VDMGLOBALFIRSTPROC)(HANDLE,HANDLE,LPGLOBALENTRY,WORD,DEBUGEVENTPROC,LPVOID);
typedef BOOL  (WINAPI *VDMGLOBALNEXTPROC)(HANDLE,HANDLE,LPGLOBALENTRY,WORD,DEBUGEVENTPROC,LPVOID);

typedef INT   (WINAPI *VDMENUMPROCESSWOWPROC)(PROCESSENUMPROC,LPARAM);
typedef INT   (WINAPI *VDMENUMTASKWOWPROC)(DWORD,TASKENUMPROC,LPARAM);
typedef INT   (WINAPI *VDMENUMTASKWOWEXPROC)(DWORD,TASKENUMPROCEX,LPARAM);
typedef BOOL  (WINAPI *VDMTERMINATETASKINWOWPROC)(DWORD,WORD);
typedef BOOL  (WINAPI *VDMSTARTTASKINWOWPROC)(DWORD,LPSTR,WORD);

typedef DWORD (WINAPI *VDMGETDBGFLAGSPROC)(HANDLE);
typedef BOOL  (WINAPI *VDMSETDBGFLAGSPROC)(HANDLE,DWORD);
typedef BOOL  (WINAPI *VDMISMODULELOADEDPROC)(LPSTR);
typedef BOOL  (WINAPI *VDMGETSEGMENTINFOPROC)(WORD,ULONG,BOOL,VDM_SEGINFO);
typedef BOOL  (WINAPI *VDMGETSYMBOLPROC)(LPSTR, WORD, DWORD, BOOL, BOOL, LPSTR, PDWORD);
typedef BOOL  (WINAPI *VDMGETADDREXPRESSIONPROC)(LPSTR, LPSTR, PWORD, PDWORD, PWORD);


#ifdef __cplusplus
}
#endif

#endif // _VDMDBG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Vcr.h ===
/***************************************************************************
 *                                                                         *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY  *
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE    *
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR  *
 *  PURPOSE.                                                               *
 *                                                                         *
 *  Copyright (c) 1993 - 1999 Microsoft Corporation.  All Rights Reserved. *
 *                                                                         *
 * File:  vcr.h                                                            *
 * Title:           VCR-MCI Command Table Include File                     *
 *                                                                         *
 ***************************************************************************/

#ifndef __VCR_H__
#define __VCR_H__

/* string resource base for vcr device type */
#define MCI_VCR_OFFSET                          1280

/* system MCI commands */
#define MCI_LIST                                0x0878
#define MCI_SETAUDIO                            0x0873 
#define MCI_SETVIDEO                            0x0876 
#define MCI_SIGNAL                              0x0875 

/* custom MCI commands for VCRs */
#define MCI_MARK                                (MCI_USER_MESSAGES + 0)
#define MCI_INDEX                               (MCI_USER_MESSAGES + 1)
#define MCI_SETTUNER                            (MCI_USER_MESSAGES + 2)
#define MCI_SETVCR                              (MCI_USER_MESSAGES + 3)
#define MCI_SETTIMECODE                         (MCI_USER_MESSAGES + 4)

/* Test is appplicable to all commands */
#define MCI_TEST                                0x00000020L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VCR_GETDEVCAPS_CAN_DETECT_LENGTH    0x00004001L
#define MCI_VCR_GETDEVCAPS_SEEK_ACCURACY        0x00004002L
#define MCI_VCR_GETDEVCAPS_HAS_CLOCK            0x00004003L
#define MCI_VCR_GETDEVCAPS_CAN_REVERSE          0x00004004L
#define MCI_VCR_GETDEVCAPS_NUMBER_OF_MARKS      0x00004005L
#define MCI_VCR_GETDEVCAPS_CAN_TEST             0x00004006L
#define MCI_VCR_GETDEVCAPS_CAN_PREROLL          0x00004007L
#define MCI_VCR_GETDEVCAPS_CAN_PREVIEW          0x00004008L
#define MCI_VCR_GETDEVCAPS_CAN_MONITOR_SOURCES  0x00004009L
#define MCI_VCR_GETDEVCAPS_HAS_TIMECODE         0x0000400AL
#define MCI_VCR_GETDEVCAPS_CAN_FREEZE           0x0000401BL
#define MCI_VCR_GETDEVCAPS_CLOCK_INCREMENT_RATE 0x0000401CL

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_VCR_INFO_VERSION                    0x00010000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VCR_PLAY_REVERSE                    0x00010000L
#define MCI_VCR_PLAY_AT                         0x00020000L
#define MCI_VCR_PLAY_SCAN                       0x00040000L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_VCR_RECORD_INITIALIZE               0x00010000L
#define MCI_VCR_RECORD_AT                       0x00020000L
#define MCI_VCR_RECORD_PREVIEW                  0x00040000L

/* flags for dwFlags parameter of MCI_CUE command message */
#define MCI_VCR_CUE_INPUT                       0x00010000L
#define MCI_VCR_CUE_OUTPUT                      0x00020000L
#define MCI_VCR_CUE_PREROLL                     0x00040000L
#define MCI_VCR_CUE_REVERSE                     0x00080000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_VCR_SEEK_REVERSE                    0x00010000L
#define MCI_VCR_SEEK_MARK                       0x00020000L
#define MCI_VCR_SEEK_AT                         0x00040000L
                                               
/* flags for dwFlags parameter of MCI_SETTUNER command message */
#define MCI_VCR_SETTUNER_CHANNEL                0x00010000L
#define MCI_VCR_SETTUNER_CHANNEL_UP             0x00020000L
#define MCI_VCR_SETTUNER_CHANNEL_DOWN           0x00040000L
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_UP        0x00080000L
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_DOWN      0x00100000L
#define MCI_VCR_SETTUNER_NUMBER                 0x00200000L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_VCR_SET_TIME_MODE                   0x00010000L
#define MCI_VCR_SET_POWER                       0x00020000L
#define MCI_VCR_SET_RECORD_FORMAT               0x00040000L
#define MCI_VCR_SET_COUNTER_FORMAT              0x00080000L
#define MCI_VCR_SET_INDEX                       0x00100000L
#define MCI_VCR_SET_ASSEMBLE_RECORD             0x00200000L
#define MCI_VCR_SET_TRACKING                    0x00400000L
#define MCI_VCR_SET_SPEED                       0x00800000L
#define MCI_VCR_SET_TAPE_LENGTH                 0x01000000L
#define MCI_VCR_SET_COUNTER_VALUE               0x02000000L
#define MCI_VCR_SET_CLOCK                       0x04000000L
#define MCI_VCR_SET_PAUSE_TIMEOUT               0x08000000L
#define MCI_VCR_SET_PREROLL_DURATION            0x10000000L
#define MCI_VCR_SET_POSTROLL_DURATION           0x20000000L

/* flags for dwItem parameter of MCI_SETTIMECODE commmand message */
#define MCI_VCR_SETTIMECODE_RECORD              0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VCR_STATUS_FRAME_RATE               0x00004001L /* Frame rate   */
#define MCI_VCR_STATUS_SPEED                    0x00004002L /* Speed        */
#define MCI_VCR_STATUS_MEDIA_TYPE               0x00004003L
#define MCI_VCR_STATUS_RECORD_FORMAT            0x00004004L
#define MCI_VCR_STATUS_PLAY_FORMAT              0x00004005L
#define MCI_VCR_STATUS_AUDIO_SOURCE             0x00004006L
#define MCI_VCR_STATUS_AUDIO_SOURCE_NUMBER      0x00004007L
#define MCI_VCR_STATUS_VIDEO_SOURCE             0x00004008L
#define MCI_VCR_STATUS_VIDEO_SOURCE_NUMBER      0x00004009L
#define MCI_VCR_STATUS_AUDIO_MONITOR            0x0000400AL
#define MCI_VCR_STATUS_AUDIO_MONITOR_NUMBER     0x0000400BL
#define MCI_VCR_STATUS_VIDEO_MONITOR            0x0000400CL
#define MCI_VCR_STATUS_VIDEO_MONITOR_NUMBER     0x0000400DL
#define MCI_VCR_STATUS_INDEX_ON                 0x0000400EL
#define MCI_VCR_STATUS_INDEX                    0x0000400FL
#define MCI_VCR_STATUS_COUNTER_FORMAT           0x00004010L
#define MCI_VCR_STATUS_COUNTER_RESOLUTION       0x00004011L
#define MCI_VCR_STATUS_TIMECODE_TYPE            0x00004012L
#define MCI_VCR_STATUS_COUNTER_VALUE            0x00004013L
#define MCI_VCR_STATUS_TUNER_CHANNEL            0x00004014L
#define MCI_VCR_STATUS_WRITE_PROTECTED          0x00004015L
#define MCI_VCR_STATUS_TIMECODE_RECORD          0x00004016L
#define MCI_VCR_STATUS_VIDEO_RECORD             0x00004017L
#define MCI_VCR_STATUS_AUDIO_RECORD             0x00004018L
#define MCI_VCR_STATUS_TIME_TYPE                0x00004019L
#define MCI_VCR_STATUS_TIME_MODE                0x0000401AL
#define MCI_VCR_STATUS_POWER_ON                 0x0000401BL
#define MCI_VCR_STATUS_CLOCK                    0x0000401CL
#define MCI_VCR_STATUS_ASSEMBLE_RECORD          0x0000401DL
#define MCI_VCR_STATUS_TIMECODE_PRESENT         0x0000401EL
#define MCI_VCR_STATUS_NUMBER_OF_VIDEO_TRACKS   0x0000401FL
#define MCI_VCR_STATUS_NUMBER_OF_AUDIO_TRACKS   0x00004020L
#define MCI_VCR_STATUS_CLOCK_ID                 0x00004021L
#define MCI_VCR_STATUS_PAUSE_TIMEOUT            0x00004022L
#define MCI_VCR_STATUS_PREROLL_DURATION         0x00004023L
#define MCI_VCR_STATUS_POSTROLL_DURATION        0x00004024L
#define MCI_VCR_STATUS_VIDEO                    0x00004025L
#define MCI_VCR_STATUS_AUDIO                    0x00004026L

#define MCI_VCR_STATUS_NUMBER                   0x00080000L

/* flags for dwFlags parameter of MCI_ESCAPE command message */
#define MCI_VCR_ESCAPE_STRING                   0x00000100L

/* flags for dwFlags parameter of MCI_LIST command message */
#define MCI_VCR_LIST_VIDEO_SOURCE               0x00010000L
#define MCI_VCR_LIST_AUDIO_SOURCE               0x00020000L
#define MCI_VCR_LIST_COUNT                      0x00040000L
#define MCI_VCR_LIST_NUMBER                     0x00080000L

/* flags for dwFlags parameter of MCI_MARK command message */
#define MCI_VCR_MARK_WRITE                      0x00010000L
#define MCI_VCR_MARK_ERASE                      0x00020000L

/* flags for dwFlags parameter for MCI_SETAUDIO command message */
#define MCI_VCR_SETAUDIO_RECORD                 0x00010000L
#define MCI_VCR_SETAUDIO_SOURCE                 0x00020000L
#define MCI_VCR_SETAUDIO_MONITOR                0x00040000L
#define MCI_VCR_SETAUDIO_TO                     0x00200000L
#define MCI_VCR_SETAUDIO_NUMBER                 0x00400000L

/* flags for dwFlags parameter for MCI_SETVIDEO command message */
#define MCI_VCR_SETVIDEO_RECORD                 0x00010000L
#define MCI_VCR_SETVIDEO_SOURCE                 0x00020000L
#define MCI_VCR_SETVIDEO_MONITOR                0x00040000L
#define MCI_VCR_SETVIDEO_TO                     0x00100000L
#define MCI_VCR_SETVIDEO_NUMBER                 0x00200000L

/* The following is the function digitalvideo drivers must use 
 * to signal when a frame marked by the SIGNAL command has been rendered:
 *
 *  SEND_VCRSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos )
 *
 * The following is a description of the parameters:
 *
 *  dwFlags    - the dwFlags parameter passed when the signal was set
 *  dwCallback - the dwCallback value from the MCI_VCR_SIGNAL_PARMS struct
 *               used to set the signal
 *  hDriver    - the handle assigned to the driver by MMSYSTEM when the 
 *               device was opened
 *  wDeviceID  - the device ID
 *  dwUser     - the dwUserParm value from the MCI_VCR_SIGNAL_PARMS struct
 *               used to set the signal
 *  dwPos      - the position at which the signal was sent, in the current
 *               time format.
 *
 * The window indicated by the handle in the dwCallback field is notified 
 * by means of a Windows message with the following form:
 *
 * msg    = MM_MCISIGNAL
 * wParam = wDeviceID of the sending driver 
 * lParam = the uservalue specified or the position the signal was sent
 *          at; the latter if the MCI_VCR_SIGNAL_POSITION flag was set 
 *          in the dwFlags parameter when the signal was created.
 */

#define SEND_VCRSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos ) \
  DriverCallback( (dwCallback), DCB_WINDOW, (HANDLE)(wDeviceID), MM_MCISIGNAL,\
  hDriver, ((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwPos):(dwUser),\
  ((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwUser):(dwPos))

/* Window message for signal notification */
#define MM_MCISIGNAL                            0x3CB

/* flags for dwFlags parameter of MCI_SIGNAL command message */
#define MCI_VCR_SIGNAL_AT                       0x00010000L
#define MCI_VCR_SIGNAL_EVERY                    0x00020000L
#define MCI_VCR_SIGNAL_USERVAL                  0x00040000L
#define MCI_VCR_SIGNAL_CANCEL                   0x00080000L
#define MCI_VCR_SIGNAL_POSITION                 0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_VCR_STEP_FRAMES                     0x00010000L
#define MCI_VCR_STEP_REVERSE                    0x00020000L

/* flags for dwFlags parameter of MCI_FREEZE command message */
#define MCI_VCR_FREEZE_INPUT                    0x00010000L
#define MCI_VCR_FREEZE_OUTPUT                   0x00020000L
#define MCI_VCR_FREEZE_FIELD                    0x00040000L
#define MCI_VCR_FREEZE_FRAME                    0x00080000L

/* flags for dwFlags parameter of MCI_UNFREEZE command message */
#define MCI_VCR_UNFREEZE_INPUT                  0x00010000L
#define MCI_VCR_UNFREEZE_OUTPUT                 0x00020000L

/* string resource values for vcr media types */
#define MCI_VCR_MEDIA_8MM                       (MCI_VCR_OFFSET + 1)
#define MCI_VCR_MEDIA_HI8                       (MCI_VCR_OFFSET + 2)
#define MCI_VCR_MEDIA_VHS                       (MCI_VCR_OFFSET + 3)
#define MCI_VCR_MEDIA_SVHS                      (MCI_VCR_OFFSET + 4)
#define MCI_VCR_MEDIA_BETA                      (MCI_VCR_OFFSET + 5)
#define MCI_VCR_MEDIA_EDBETA                    (MCI_VCR_OFFSET + 6)
#define MCI_VCR_MEDIA_OTHER                     (MCI_VCR_OFFSET + 7)

/* string resource values for vcr play/record formats */
#define MCI_VCR_FORMAT_SP                       (MCI_VCR_OFFSET + 8)
#define MCI_VCR_FORMAT_LP                       (MCI_VCR_OFFSET + 9)
#define MCI_VCR_FORMAT_EP                       (MCI_VCR_OFFSET + 10)
#define MCI_VCR_FORMAT_OTHER                    (MCI_VCR_OFFSET + 11)

/* string resource values for timecode types */
#define MCI_VCR_TIME_TIMECODE                   (MCI_VCR_OFFSET + 12)
#define MCI_VCR_TIME_COUNTER                    (MCI_VCR_OFFSET + 13)
#define MCI_VCR_TIME_DETECT                     (MCI_VCR_OFFSET + 14)

/* string resource values for src types */
#define MCI_VCR_SRC_TYPE_TUNER                  (MCI_VCR_OFFSET + 15)
#define MCI_VCR_SRC_TYPE_LINE                   (MCI_VCR_OFFSET + 16)
#define MCI_VCR_SRC_TYPE_SVIDEO                 (MCI_VCR_OFFSET + 17)
#define MCI_VCR_SRC_TYPE_RGB                    (MCI_VCR_OFFSET + 18)
#define MCI_VCR_SRC_TYPE_AUX                    (MCI_VCR_OFFSET + 19)
#define MCI_VCR_SRC_TYPE_GENERIC                (MCI_VCR_OFFSET + 20)
#define MCI_VCR_SRC_TYPE_MUTE                   (MCI_VCR_OFFSET + 21)
#define MCI_VCR_SRC_TYPE_OUTPUT                 (MCI_VCR_OFFSET + 22)

/* string resource values for vcr counters */
#define MCI_VCR_INDEX_TIMECODE                  (MCI_VCR_OFFSET + 23)         
#define MCI_VCR_INDEX_COUNTER                   (MCI_VCR_OFFSET + 24)   
#define MCI_VCR_INDEX_DATE                      (MCI_VCR_OFFSET + 25)
#define MCI_VCR_INDEX_TIME                      (MCI_VCR_OFFSET + 26)

/* string resources for timecode type and counter resolution */
#define MCI_VCR_COUNTER_RES_SECONDS             (MCI_VCR_OFFSET + 27)            
#define MCI_VCR_COUNTER_RES_FRAMES              (MCI_VCR_OFFSET + 28)

#define MCI_VCR_TIMECODE_TYPE_SMPTE             (MCI_VCR_OFFSET + 29)
#define MCI_VCR_TIMECODE_TYPE_SMPTE_DROP        (MCI_VCR_OFFSET + 30)
#define MCI_VCR_TIMECODE_TYPE_OTHER             (MCI_VCR_OFFSET + 31)
#define MCI_VCR_TIMECODE_TYPE_NONE              (MCI_VCR_OFFSET + 32)

#define MCI_VCR_PLUS                            (MCI_VCR_OFFSET + 33)
#define MCI_VCR_MINUS                           (MCI_VCR_OFFSET + 34)
#define MCI_VCR_RESET                           (MCI_VCR_OFFSET + 35)

#ifndef RC_INVOKED

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_VCR_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
    DWORD   dwMark;
    DWORD   dwAt;
} MCI_VCR_SEEK_PARMS;
typedef MCI_VCR_SEEK_PARMS FAR *LPMCI_VCR_SEEK_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_VCR_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTimeMode;
    DWORD   dwRecordFormat;
    DWORD   dwCounterFormat;
    DWORD   dwIndex;
    DWORD   dwTracking;
    DWORD   dwSpeed;
    DWORD   dwLength;
    DWORD   dwCounter;
    DWORD   dwClock;
    DWORD   dwPauseTimeout;
    DWORD   dwPrerollDuration;
    DWORD   dwPostrollDuration;
} MCI_VCR_SET_PARMS;
typedef MCI_VCR_SET_PARMS FAR *LPMCI_VCR_SET_PARMS;

/* parameter block for MCI_VCR_SETTUNER command message */
typedef struct tagMCI_VCR_SETTUNER_PARMS {
    DWORD   dwCallback;
    DWORD   dwChannel;
    DWORD   dwNumber;
} MCI_VCR_SETTUNER_PARMS;
typedef MCI_VCR_SETTUNER_PARMS FAR *LPMCI_VCR_SETTUNER_PARMS;

/* parameter block for MCI_ESCAPE command message */
typedef struct tagMCI_VCR_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VCR_ESCAPE_PARMS;
typedef MCI_VCR_ESCAPE_PARMS FAR *LPMCI_VCR_ESCAPE_PARMS;

/* parameter block for MCI_LIST command message */
typedef struct tagMCI_VCR_LIST_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwNumber;
} MCI_VCR_LIST_PARMS;
typedef MCI_VCR_LIST_PARMS FAR *LPMCI_VCR_LIST_PARMS;

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_VCR_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwAt;
} MCI_VCR_RECORD_PARMS;
typedef MCI_VCR_RECORD_PARMS FAR *LPMCI_VCR_RECORD_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VCR_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwAt;
} MCI_VCR_PLAY_PARMS;
typedef MCI_VCR_PLAY_PARMS FAR *LPMCI_VCR_PLAY_PARMS;

/* parameter block for MCI_SETAUDIO command message */
typedef struct tagMCI_VCR_SETAUDIO_PARMS {
    DWORD   dwCallback;
    DWORD   dwTrack;
    DWORD   dwTo;
    DWORD   dwNumber;
} MCI_VCR_SETAUDIO_PARMS;
typedef MCI_VCR_SETAUDIO_PARMS FAR *LPMCI_VCR_SETAUDIO_PARMS;

/* parameter block for MCI_SIGNAL command message */
typedef struct tagMCI_VCR_SIGNAL_PARMS {
    DWORD   dwCallback;
    DWORD   dwPosition;
    DWORD   dwPeriod;
    DWORD   dwUserParm;
} MCI_VCR_SIGNAL_PARMS;
typedef MCI_VCR_SIGNAL_PARMS FAR * LPMCI_VCR_SIGNAL_PARMS;

/* parameter block for MCI_VCR_STATUS command message */
typedef struct tagMCI_VCR_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
    DWORD   dwNumber;
} MCI_VCR_STATUS_PARMS;
typedef MCI_VCR_STATUS_PARMS FAR * LPMCI_VCR_STATUS_PARMS;

/* parameter block for MCI_SETVIDEO command message */
typedef struct tagMCI_VCR_SETVIDEO_PARMS {
    DWORD   dwCallback;
    DWORD   dwTrack;
    DWORD   dwTo;
    DWORD   dwNumber;
} MCI_VCR_SETVIDEO_PARMS;
typedef MCI_VCR_SETVIDEO_PARMS FAR *LPMCI_VCR_SETVIDEO_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VCR_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VCR_STEP_PARMS;
typedef MCI_VCR_STEP_PARMS FAR *LPMCI_VCR_STEP_PARMS;

/* parameter block for MCI_CUE command message */
typedef struct tagMCI_VCR_CUE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_VCR_CUE_PARMS;
typedef MCI_VCR_CUE_PARMS FAR *LPMCI_VCR_CUE_PARMS;

#endif /* NOT RC_INVOKED */

/* VCR error codes */
#define MCIERR_VCR_CANNOT_OPEN_COMM         (MCIERR_CUSTOM_DRIVER_BASE + 1)
#define MCIERR_VCR_CANNOT_WRITE_COMM        (MCIERR_CUSTOM_DRIVER_BASE + 2)
#define MCIERR_VCR_READ_TIMEOUT             (MCIERR_CUSTOM_DRIVER_BASE + 3)
#define MCIERR_VCR_COMMAND_BUFFER_FULL      (MCIERR_CUSTOM_DRIVER_BASE + 4)
#define MCIERR_VCR_COMMAND_CANCELLED        (MCIERR_CUSTOM_DRIVER_BASE + 5)
#define MCIERR_VCR_POWER_OFF                (MCIERR_CUSTOM_DRIVER_BASE + 6)
#define MCIERR_VCR_COMMAND_FAILED           (MCIERR_CUSTOM_DRIVER_BASE + 7)
#define MCIERR_VCR_SEARCH                   (MCIERR_CUSTOM_DRIVER_BASE + 8)
#define MCIERR_VCR_CONDITION                (MCIERR_CUSTOM_DRIVER_BASE + 9)
#define MCIERR_VCR_CAMERA_MODE              (MCIERR_CUSTOM_DRIVER_BASE + 10)
#define MCIERR_VCR_VCR_MODE                 (MCIERR_CUSTOM_DRIVER_BASE + 11)
#define MCIERR_VCR_COUNTER_TYPE             (MCIERR_CUSTOM_DRIVER_BASE + 12)
#define MCIERR_VCR_TUNER                    (MCIERR_CUSTOM_DRIVER_BASE + 13)
#define MCIERR_VCR_EMERGENCY_STOP           (MCIERR_CUSTOM_DRIVER_BASE + 14)
#define MCIERR_VCR_MEDIA_UNMOUNTED          (MCIERR_CUSTOM_DRIVER_BASE + 15)
#define MCIERR_VCR_REGISTER                 (MCIERR_CUSTOM_DRIVER_BASE + 16)
#define MCIERR_VCR_TRACK_FAILURE            (MCIERR_CUSTOM_DRIVER_BASE + 17)
#define MCIERR_VCR_CUE_FAILED_FLAGS         (MCIERR_CUSTOM_DRIVER_BASE + 18)
#define MCIERR_VCR_ISWRITEPROTECTED         (MCIERR_CUSTOM_DRIVER_BASE + 19)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vdserr.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    vdserr.h

Abstract:

    Constant definitions for the Virtual Disk Service error messages.

    Error code values:
    Added in Windows Server 2003:          0x2400-0x24FF
    Added in Windows Vista:                0x2500-0x26FF
    Added in VDS 1.1:                      0x2700-0x27FF
    Added in Windows Server 2008:          0x2800-0x28FF
    Added in Win7:                         0x2900-0x29FF

    NOTE:
    If porting over an error code which was added to Server 2003 SP make sure
    the error code's value is in the designated range for Windows Server 2003.
    If the value is not in the designated range make sure it does not conflict
    with any of the already defined errors and if it does change the value
    to the next available Vista value.

Author:

    Kevin Seng   [KSeng]    04/01/05

Revision History:

--*/
#pragma once
// HRESULT codes
//////////////////////////////////////////////////////////////////////////////
//
// Codes added in Windows Server 2003:           0x2400-0x24FF
//
//////////////////////////////////////////////////////////////////////////////
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: VDS_E_NOT_SUPPORTED
//
// MessageText:
//
// The operation is not supported by the object.
//
#define VDS_E_NOT_SUPPORTED              ((HRESULT)0x80042400L)

//
// MessageId: VDS_E_INITIALIZED_FAILED
//
// MessageText:
//
// The service failed to initialize.
//
#define VDS_E_INITIALIZED_FAILED         ((HRESULT)0x80042401L)

//
// MessageId: VDS_E_INITIALIZE_NOT_CALLED
//
// MessageText:
//
// The initialization method was not called.
//
#define VDS_E_INITIALIZE_NOT_CALLED      ((HRESULT)0x80042402L)

//
// MessageId: VDS_E_ALREADY_REGISTERED
//
// MessageText:
//
// The provider is already registered.
//
#define VDS_E_ALREADY_REGISTERED         ((HRESULT)0x80042403L)

//
// MessageId: VDS_E_ANOTHER_CALL_IN_PROGRESS
//
// MessageText:
//
// A concurrent second call is made on an object before the first is completed.
//
#define VDS_E_ANOTHER_CALL_IN_PROGRESS   ((HRESULT)0x80042404L)

//
// MessageId: VDS_E_OBJECT_NOT_FOUND
//
// MessageText:
//
// The object is not found.
//
#define VDS_E_OBJECT_NOT_FOUND           ((HRESULT)0x80042405L)

//
// MessageId: VDS_E_INVALID_SPACE
//
// MessageText:
//
// The specified space is not free or not valid.
//
#define VDS_E_INVALID_SPACE              ((HRESULT)0x80042406L)

//
// MessageId: VDS_E_PARTITION_LIMIT_REACHED
//
// MessageText:
//
// The number of partitions has reached the limit on a disk.
//
#define VDS_E_PARTITION_LIMIT_REACHED    ((HRESULT)0x80042407L)

//
// MessageId: VDS_E_PARTITION_NOT_EMPTY
//
// MessageText:
//
// The extended partition is not empty.
//
#define VDS_E_PARTITION_NOT_EMPTY        ((HRESULT)0x80042408L)

//
// MessageId: VDS_E_OPERATION_PENDING
//
// MessageText:
//
// The operation has not been completed yet.
//
#define VDS_E_OPERATION_PENDING          ((HRESULT)0x80042409L)

//
// MessageId: VDS_E_OPERATION_DENIED
//
// MessageText:
//
// This operation is not allowed on the current boot, system or pagefile 
// volume. It is also not allowed on any volume on a basic MBR disk that contains 
// the boot, system or pagefile volume. 
//
#define VDS_E_OPERATION_DENIED           ((HRESULT)0x8004240AL)

//
// MessageId: VDS_E_OBJECT_DELETED
//
// MessageText:
//
// The object has been deleted.
//
#define VDS_E_OBJECT_DELETED             ((HRESULT)0x8004240BL)

//
// MessageId: VDS_E_CANCEL_TOO_LATE
//
// MessageText:
//
// The operation cannot be cancelled.
//
#define VDS_E_CANCEL_TOO_LATE            ((HRESULT)0x8004240CL)

//
// MessageId: VDS_E_OPERATION_CANCELED
//
// MessageText:
//
// The operation has been cancelled.
//
#define VDS_E_OPERATION_CANCELED         ((HRESULT)0x8004240DL)

//
// MessageId: VDS_E_CANNOT_EXTEND
//
// MessageText:
//
// The volume cannot be extended because the file system does not support it.
//
#define VDS_E_CANNOT_EXTEND              ((HRESULT)0x8004240EL)

//
// MessageId: VDS_E_NOT_ENOUGH_SPACE
//
// MessageText:
//
// There is not enough usable space for this operation.
//
#define VDS_E_NOT_ENOUGH_SPACE           ((HRESULT)0x8004240FL)

//
// MessageId: VDS_E_NOT_ENOUGH_DRIVE
//
// MessageText:
//
// Not enough drives are specified to complete this operation.
//
#define VDS_E_NOT_ENOUGH_DRIVE           ((HRESULT)0x80042410L)

//
// MessageId: VDS_E_BAD_COOKIE
//
// MessageText:
//
// The cookie is not found.
//
#define VDS_E_BAD_COOKIE                 ((HRESULT)0x80042411L)

//
// MessageId: VDS_E_NO_MEDIA
//
// MessageText:
//
// There is no media in the device.
//
#define VDS_E_NO_MEDIA                   ((HRESULT)0x80042412L)

//
// MessageId: VDS_E_DEVICE_IN_USE
//
// MessageText:
//
// The device is in use.
//
#define VDS_E_DEVICE_IN_USE              ((HRESULT)0x80042413L)

//
// MessageId: VDS_E_DISK_NOT_EMPTY
//
// MessageText:
//
// The disk is not empty.
//
#define VDS_E_DISK_NOT_EMPTY             ((HRESULT)0x80042414L)

//
// MessageId: VDS_E_INVALID_OPERATION
//
// MessageText:
//
// Invalid operation.
//
#define VDS_E_INVALID_OPERATION          ((HRESULT)0x80042415L)

//
// MessageId: VDS_E_PATH_NOT_FOUND
//
// MessageText:
//
// The path is not found.
//
#define VDS_E_PATH_NOT_FOUND             ((HRESULT)0x80042416L)

//
// MessageId: VDS_E_DISK_NOT_INITIALIZED
//
// MessageText:
//
// The disk is not initialized.
//
#define VDS_E_DISK_NOT_INITIALIZED       ((HRESULT)0x80042417L)

//
// MessageId: VDS_E_NOT_AN_UNALLOCATED_DISK
//
// MessageText:
//
// The disk is not unallocated.
//
#define VDS_E_NOT_AN_UNALLOCATED_DISK    ((HRESULT)0x80042418L)

//
// MessageId: VDS_E_UNRECOVERABLE_ERROR
//
// MessageText:
//
// An unrecoverable error occurred. The service must shut down.
//
#define VDS_E_UNRECOVERABLE_ERROR        ((HRESULT)0x80042419L)

//
// MessageId: VDS_S_DISK_PARTIALLY_CLEANED
//
// MessageText:
//
// The disk is not fully cleaned due to I/O error.
//
#define VDS_S_DISK_PARTIALLY_CLEANED     ((HRESULT)0x0004241AL)

//
// MessageId: VDS_E_DMADMIN_SERVICE_CONNECTION_FAILED
//
// MessageText:
//
// The provider failed to connect to the Logical Disk Management 
// Administrative service.
//
#define VDS_E_DMADMIN_SERVICE_CONNECTION_FAILED ((HRESULT)0x8004241BL)

//
// MessageId: VDS_E_PROVIDER_INITIALIZATION_FAILED
//
// MessageText:
//
// The provider failed to initialize.
//
#define VDS_E_PROVIDER_INITIALIZATION_FAILED ((HRESULT)0x8004241CL)

//
// MessageId: VDS_E_OBJECT_EXISTS
//
// MessageText:
//
// The object already exists.
//
#define VDS_E_OBJECT_EXISTS              ((HRESULT)0x8004241DL)

//
// MessageId: VDS_E_NO_DISKS_FOUND
//
// MessageText:
//
// No disks were found on the target machine.
//
#define VDS_E_NO_DISKS_FOUND             ((HRESULT)0x8004241EL)

//
// MessageId: VDS_E_PROVIDER_CACHE_CORRUPT
//
// MessageText:
//
// The provider's cache has become corrupt.
//
#define VDS_E_PROVIDER_CACHE_CORRUPT     ((HRESULT)0x8004241FL)

//
// MessageId: VDS_E_DMADMIN_METHOD_CALL_FAILED
//
// MessageText:
//
// A method call to the Logical Disk Management Administrative service failed.
//
#define VDS_E_DMADMIN_METHOD_CALL_FAILED ((HRESULT)0x80042420L)

//
// MessageId: VDS_S_PROVIDER_ERROR_LOADING_CACHE
//
// MessageText:
//
// The provider encountered errors while loading the cache. 
// See the NT Event Log for more information.
//
#define VDS_S_PROVIDER_ERROR_LOADING_CACHE ((HRESULT)0x00042421L)

//
// MessageId: VDS_E_PROVIDER_VOL_DEVICE_NAME_NOT_FOUND
//
// MessageText:
//
// The device form of the volume pathname could not be retrieved.
//
#define VDS_E_PROVIDER_VOL_DEVICE_NAME_NOT_FOUND ((HRESULT)0x80042422L)

//
// MessageId: VDS_E_PROVIDER_VOL_OPEN
//
// MessageText:
//
// Failed to open the volume device.
//
#define VDS_E_PROVIDER_VOL_OPEN          ((HRESULT)0x80042423L)

//
// MessageId: VDS_E_DMADMIN_CORRUPT_NOTIFICATION
//
// MessageText:
//
// A corrupt notification was sent from the Logical Disk Manager 
// Administrative service.
//
#define VDS_E_DMADMIN_CORRUPT_NOTIFICATION ((HRESULT)0x80042424L)

//
// MessageId: VDS_E_INCOMPATIBLE_FILE_SYSTEM
//
// MessageText:
//
// The file system is incompatible.
//
#define VDS_E_INCOMPATIBLE_FILE_SYSTEM   ((HRESULT)0x80042425L)

//
// MessageId: VDS_E_INCOMPATIBLE_MEDIA
//
// MessageText:
//
// The media is incompatible.
//
#define VDS_E_INCOMPATIBLE_MEDIA         ((HRESULT)0x80042426L)

//
// MessageId: VDS_E_ACCESS_DENIED
//
// MessageText:
//
// Access is denied.
//
#define VDS_E_ACCESS_DENIED              ((HRESULT)0x80042427L)

//
// MessageId: VDS_E_MEDIA_WRITE_PROTECTED
//
// MessageText:
//
// The media is write protected.
//
#define VDS_E_MEDIA_WRITE_PROTECTED      ((HRESULT)0x80042428L)

//
// MessageId: VDS_E_BAD_LABEL
//
// MessageText:
//
// The label is illegal.
//
#define VDS_E_BAD_LABEL                  ((HRESULT)0x80042429L)

//
// MessageId: VDS_E_CANT_QUICK_FORMAT
//
// MessageText:
//
// Can not quick format the volume.
//
#define VDS_E_CANT_QUICK_FORMAT          ((HRESULT)0x8004242AL)

//
// MessageId: VDS_E_IO_ERROR
//
// MessageText:
//
// IO error occured during format.
//
#define VDS_E_IO_ERROR                   ((HRESULT)0x8004242BL)

//
// MessageId: VDS_E_VOLUME_TOO_SMALL
//
// MessageText:
//
// The volume size is too small.
//
#define VDS_E_VOLUME_TOO_SMALL           ((HRESULT)0x8004242CL)

//
// MessageId: VDS_E_VOLUME_TOO_BIG
//
// MessageText:
//
// The volume size is too big.
//
#define VDS_E_VOLUME_TOO_BIG             ((HRESULT)0x8004242DL)

//
// MessageId: VDS_E_CLUSTER_SIZE_TOO_SMALL
//
// MessageText:
//
// The cluster size is too small.
//
#define VDS_E_CLUSTER_SIZE_TOO_SMALL     ((HRESULT)0x8004242EL)

//
// MessageId: VDS_E_CLUSTER_SIZE_TOO_BIG
//
// MessageText:
//
// The cluster size is too big.
//
#define VDS_E_CLUSTER_SIZE_TOO_BIG       ((HRESULT)0x8004242FL)

//
// MessageId: VDS_E_CLUSTER_COUNT_BEYOND_32BITS
//
// MessageText:
//
// The number of clusters is too big for 32 bit integer.
//
#define VDS_E_CLUSTER_COUNT_BEYOND_32BITS ((HRESULT)0x80042430L)

//
// MessageId: VDS_E_OBJECT_STATUS_FAILED
//
// MessageText:
//
// The object is in failed status.
//
#define VDS_E_OBJECT_STATUS_FAILED       ((HRESULT)0x80042431L)

//
// MessageId: VDS_E_VOLUME_INCOMPLETE
//
// MessageText:
//
// All extents for the volume could not be found.
//
#define VDS_E_VOLUME_INCOMPLETE          ((HRESULT)0x80042432L)

//
// MessageId: VDS_E_EXTENT_SIZE_LESS_THAN_MIN
//
// MessageText:
//
// The size of the extent is less than the minimum.
//
#define VDS_E_EXTENT_SIZE_LESS_THAN_MIN  ((HRESULT)0x80042433L)

//
// MessageId: VDS_S_UPDATE_BOOTFILE_FAILED
//
// MessageText:
//
// Failed to update the boot configuration data.
//
#define VDS_S_UPDATE_BOOTFILE_FAILED     ((HRESULT)0x00042434L)

//
// MessageId: VDS_S_BOOT_PARTITION_NUMBER_CHANGE
//
// MessageText:
//
// The boot partition's partition number will change as a result of the operation.
//
#define VDS_S_BOOT_PARTITION_NUMBER_CHANGE ((HRESULT)0x00042436L)

//
// MessageId: VDS_E_BOOT_PARTITION_NUMBER_CHANGE
//
// MessageText:
//
// The boot partition's partition number will change as a result of the 
// migration operation.
//
#define VDS_E_BOOT_PARTITION_NUMBER_CHANGE ((HRESULT)0x80042436L)

//
// MessageId: VDS_E_NO_FREE_SPACE
//
// MessageText:
//
// The selected disk does not have enough free space to complete the operation.
//
#define VDS_E_NO_FREE_SPACE              ((HRESULT)0x80042437L)

//
// MessageId: VDS_E_ACTIVE_PARTITION
//
// MessageText:
//
// An active partition was detected on the selected disk, and it is not the active partition used to boot the currently running OS.
//
#define VDS_E_ACTIVE_PARTITION           ((HRESULT)0x80042438L)

//
// MessageId: VDS_E_PARTITION_OF_UNKNOWN_TYPE
//
// MessageText:
//
// Cannot read partition information.
//
#define VDS_E_PARTITION_OF_UNKNOWN_TYPE  ((HRESULT)0x80042439L)

//
// MessageId: VDS_E_LEGACY_VOLUME_FORMAT
//
// MessageText:
//
// A partition with an unknown type was detected on the selected disk.
//
#define VDS_E_LEGACY_VOLUME_FORMAT       ((HRESULT)0x8004243AL)

//
// MessageId: VDS_E_NON_CONTIGUOUS_DATA_PARTITIONS
//
// MessageText:
//
// The selected GPT formatted disk contains a partition which is not of type 
// 'PARTITION_BASIC_DATA_GUID', and is both preceeded and followed by a partition 
// of type 'PARTITION_BASIC_DATA_GUID'.
//
#define VDS_E_NON_CONTIGUOUS_DATA_PARTITIONS ((HRESULT)0x8004243BL)

//
// MessageId: VDS_E_MIGRATE_OPEN_VOLUME
//
// MessageText:
//
// A volume on the selected disk could not be opened.
//
#define VDS_E_MIGRATE_OPEN_VOLUME        ((HRESULT)0x8004243CL)

//
// MessageId: VDS_E_VOLUME_NOT_ONLINE
//
// MessageText:
//
// The volume is not online.
//
#define VDS_E_VOLUME_NOT_ONLINE          ((HRESULT)0x8004243DL)

//
// MessageId: VDS_E_VOLUME_NOT_HEALTHY
//
// MessageText:
//
// The volume is not healthy.
//
#define VDS_E_VOLUME_NOT_HEALTHY         ((HRESULT)0x8004243EL)

//
// MessageId: VDS_E_VOLUME_SPANS_DISKS
//
// MessageText:
//
// The volume spans multiple disks.
//
#define VDS_E_VOLUME_SPANS_DISKS         ((HRESULT)0x8004243FL)

//
// MessageId: VDS_E_REQUIRES_CONTIGUOUS_DISK_SPACE
//
// MessageText:
//
// The volume requires contiguous disk extents.
//
#define VDS_E_REQUIRES_CONTIGUOUS_DISK_SPACE ((HRESULT)0x80042440L)

//
// MessageId: VDS_E_BAD_PROVIDER_DATA
//
// MessageText:
//
// A provider returned bad data.
//
#define VDS_E_BAD_PROVIDER_DATA          ((HRESULT)0x80042441L)

//
// MessageId: VDS_E_PROVIDER_FAILURE
//
// MessageText:
//
// A provider failed to complete an operation.
//
#define VDS_E_PROVIDER_FAILURE           ((HRESULT)0x80042442L)

//
// MessageId: VDS_S_VOLUME_COMPRESS_FAILED
//
// MessageText:
//
// Failed to compress the volume.
//
#define VDS_S_VOLUME_COMPRESS_FAILED     ((HRESULT)0x00042443L)

//
// MessageId: VDS_E_PACK_OFFLINE
//
// MessageText:
//
// The pack is not online.
//
#define VDS_E_PACK_OFFLINE               ((HRESULT)0x80042444L)

//
// MessageId: VDS_E_VOLUME_NOT_A_MIRROR
//
// MessageText:
//
// The volume is not a mirror.
//
#define VDS_E_VOLUME_NOT_A_MIRROR        ((HRESULT)0x80042445L)

//
// MessageId: VDS_E_NO_EXTENTS_FOR_VOLUME
//
// MessageText:
//
// No extents were found for the volume.
//
#define VDS_E_NO_EXTENTS_FOR_VOLUME      ((HRESULT)0x80042446L)

//
// MessageId: VDS_E_DISK_NOT_LOADED_TO_CACHE
//
// MessageText:
//
// The disk failed to load to the cache.
//
#define VDS_E_DISK_NOT_LOADED_TO_CACHE   ((HRESULT)0x80042447L)

//
// MessageId: VDS_E_INTERNAL_ERROR
//
// MessageText:
//
// Check the event log for errors.
//
#define VDS_E_INTERNAL_ERROR             ((HRESULT)0x80042448L)

//
// MessageId: VDS_S_ACCESS_PATH_NOT_DELETED
//
// MessageText:
//
// The access paths on the volume may not be deleted.
//
#define VDS_S_ACCESS_PATH_NOT_DELETED    ((HRESULT)0x00044244L)

//
// MessageId: VDS_E_PROVIDER_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The method call is not supported for the specified provider type.
//
#define VDS_E_PROVIDER_TYPE_NOT_SUPPORTED ((HRESULT)0x8004244AL)

//
// MessageId: VDS_E_DISK_NOT_ONLINE
//
// MessageText:
//
// This disk is already offline. 
//
#define VDS_E_DISK_NOT_ONLINE            ((HRESULT)0x8004244BL)

//
// MessageId: VDS_E_DISK_IN_USE_BY_VOLUME
//
// MessageText:
//
// The disk is already in use by the volume.
//
#define VDS_E_DISK_IN_USE_BY_VOLUME      ((HRESULT)0x8004244CL)

//
// MessageId: VDS_S_IN_PROGRESS
//
// MessageText:
//
// The asynchronous operation is in progress.
//
#define VDS_S_IN_PROGRESS                ((HRESULT)0x0004244DL)

//
// MessageId: VDS_E_ASYNC_OBJECT_FAILURE
//
// MessageText:
//
// Failure initializing the asynchronous object.
//
#define VDS_E_ASYNC_OBJECT_FAILURE       ((HRESULT)0x8004244EL)

//
// MessageId: VDS_E_VOLUME_NOT_MOUNTED
//
// MessageText:
//
// A file system is not mounted on the volume.
//
#define VDS_E_VOLUME_NOT_MOUNTED         ((HRESULT)0x8004244FL)

//
// MessageId: VDS_E_PACK_NOT_FOUND
//
// MessageText:
//
// The pack was not found.
//
#define VDS_E_PACK_NOT_FOUND             ((HRESULT)0x80042450L)

//
// MessageId: VDS_E_IMPORT_SET_INCOMPLETE
//
// MessageText:
//
// Import failed. Attempt to import a subset of the disks in the foreign pack.
//
#define VDS_E_IMPORT_SET_INCOMPLETE      ((HRESULT)0x80042451L)

//
// MessageId: VDS_E_DISK_NOT_IMPORTED
//
// MessageText:
//
// A disk in the import's source pack was not imported.
//
#define VDS_E_DISK_NOT_IMPORTED          ((HRESULT)0x80042452L)

//
// MessageId: VDS_E_OBJECT_OUT_OF_SYNC
//
// MessageText:
//
// The system's information about the object may not be up to date.
//
#define VDS_E_OBJECT_OUT_OF_SYNC         ((HRESULT)0x80042453L)

//
// MessageId: VDS_E_MISSING_DISK
//
// MessageText:
//
// The disk is missing.
//
#define VDS_E_MISSING_DISK               ((HRESULT)0x80042454L)

//
// MessageId: VDS_E_DISK_PNP_REG_CORRUPT
//
// MessageText:
//
// The provider's list of Pnp registered disks has become corrupt.
//
#define VDS_E_DISK_PNP_REG_CORRUPT       ((HRESULT)0x80042455L)

//
// MessageId: VDS_E_LBN_REMAP_ENABLED_FLAG
//
// MessageText:
//
// The provider does not support the LBN REMAP ENABLED volume flag.
//
#define VDS_E_LBN_REMAP_ENABLED_FLAG     ((HRESULT)0x80042456L)

//
// MessageId: VDS_E_NO_DRIVELETTER_FLAG
//
// MessageText:
//
// The provider does not support the NO DRIVELETTER volume flag.
//
#define VDS_E_NO_DRIVELETTER_FLAG        ((HRESULT)0x80042457L)

//
// MessageId: VDS_E_REVERT_ON_CLOSE
//
// MessageText:
//
// REVERT ON CLOSE may only be used with GPT flags HIDDEN, READ ONLY, 
// NO DRIVE LETTER or SHADOW COPY.
//
#define VDS_E_REVERT_ON_CLOSE            ((HRESULT)0x80042458L)

//
// MessageId: VDS_E_REVERT_ON_CLOSE_SET
//
// MessageText:
//
// The REVERT ON CLOSE volume flag is already set for this volume.
//
#define VDS_E_REVERT_ON_CLOSE_SET        ((HRESULT)0x80042459L)

//
// MessageId: VDS_E_IA64_BOOT_MIRRORED_TO_MBR
//
// MessageText:
//
// Not used! You have mirrored your boot volume on a GPT disk, to an MBR disk. 
// You will not be able to boot your machine from the secondary plex.
//
#define VDS_E_IA64_BOOT_MIRRORED_TO_MBR  ((HRESULT)0x8004245AL)

//
// MessageId: VDS_S_IA64_BOOT_MIRRORED_TO_MBR
//
// MessageText:
//
// You have mirrored your boot volume on a GPT disk, to an MBR disk. 
// You will not be able to boot your machine from the secondary plex.
//
#define VDS_S_IA64_BOOT_MIRRORED_TO_MBR  ((HRESULT)0x0004245AL)

//
// MessageId: VDS_S_UNABLE_TO_GET_GPT_ATTRIBUTES
//
// MessageText:
//
// Unable to retrieve the GPT attributes for this volume, (hidden, read only 
// and no drive letter).
//
#define VDS_S_UNABLE_TO_GET_GPT_ATTRIBUTES ((HRESULT)0x0004245BL)

//
// MessageId: VDS_E_VOLUME_TEMPORARILY_DISMOUNTED
//
// MessageText:
//
// The volume is temporarily dismounted.
//
#define VDS_E_VOLUME_TEMPORARILY_DISMOUNTED ((HRESULT)0x8004245CL)

//
// MessageId: VDS_E_VOLUME_PERMANENTLY_DISMOUNTED
//
// MessageText:
//
// The volume is permanently dismounted.
//
#define VDS_E_VOLUME_PERMANENTLY_DISMOUNTED ((HRESULT)0x8004245DL)

//
// MessageId: VDS_E_VOLUME_HAS_PATH
//
// MessageText:
//
// The volume still has access path to it.
//
#define VDS_E_VOLUME_HAS_PATH            ((HRESULT)0x8004245EL)

//
// MessageId: VDS_E_TIMEOUT
//
// MessageText:
//
// The operation timed out.
//
#define VDS_E_TIMEOUT                    ((HRESULT)0x8004245FL)

//
// MessageId: VDS_E_REPAIR_VOLUMESTATE
//
// MessageText:
//
// To repair a volume, both the volume and plex must be online, and must not be 
// healthy or rebuilding.
//
#define VDS_E_REPAIR_VOLUMESTATE         ((HRESULT)0x80042460L)

//
// MessageId: VDS_E_LDM_TIMEOUT
//
// MessageText:
//
// The operation timed out in the Logical Disk Manager Administrative service. 
// Retry the operation.
//
#define VDS_E_LDM_TIMEOUT                ((HRESULT)0x80042461L)

//
// MessageId: VDS_E_REVERT_ON_CLOSE_MISMATCH
//
// MessageText:
//
// When clearing volume flags that have been set using revert on close, 
// the same combination of HIDDEN, READ ONLY, NO DRIVE LETTER or SHADOW COPY 
// flags must be passed to both the SetFlags and ClearFlags calls.
//
#define VDS_E_REVERT_ON_CLOSE_MISMATCH   ((HRESULT)0x80042462L)

//
// MessageId: VDS_E_RETRY
//
// MessageText:
//
// The operation failed. Retry the operation.
//
#define VDS_E_RETRY                      ((HRESULT)0x80042463L)

//
// MessageId: VDS_E_ONLINE_PACK_EXISTS
//
// MessageText:
//
// Create pack operation failed. An online pack already exists.
//
#define VDS_E_ONLINE_PACK_EXISTS         ((HRESULT)0x80042464L)

//
// MessageId: VDS_S_EXTEND_FILE_SYSTEM_FAILED
//
// MessageText:
//
// The volume was extended successfully but the file system failed to extend.
//
#define VDS_S_EXTEND_FILE_SYSTEM_FAILED  ((HRESULT)0x00042465L)

//
// MessageId: VDS_E_EXTEND_FILE_SYSTEM_FAILED
//
// MessageText:
//
// The file system failed to extend.
//
#define VDS_E_EXTEND_FILE_SYSTEM_FAILED  ((HRESULT)0x80042466L)

//
// MessageId: VDS_S_MBR_BOOT_MIRRORED_TO_GPT
//
// MessageText:
//
// You have mirrored your boot volume on an MBR disk, to a GPT disk. 
// You will not be able to boot your machine from the secondary plex.
//
#define VDS_S_MBR_BOOT_MIRRORED_TO_GPT   ((HRESULT)0x00042467L)

//
// MessageId: VDS_E_MAX_USABLE_MBR
//
// MessageText:
//
// Only the first 2TB are usable on large MBR disks. 
// Cannot create partitions beyond the 2TB mark, nor convert 
// the disk to dynamic.
//
#define VDS_E_MAX_USABLE_MBR             ((HRESULT)0x80042468L)

//
// MessageId: VDS_S_GPT_BOOT_MIRRORED_TO_MBR
//
// MessageText:
//
// You have mirrored your boot volume on a GPT disk, to an MBR disk. 
// You will not be able to boot your machine from the secondary plex.
//
#define VDS_S_GPT_BOOT_MIRRORED_TO_MBR   ((HRESULT)0x80042469L)

//////////////////////////////////////////////////////////////////////////////
//
// Codes added in Windows Vista:                 0x2500-0x26FF
//
//////////////////////////////////////////////////////////////////////////////
//
// MessageId: VDS_E_NO_SOFTWARE_PROVIDERS_LOADED
//
// MessageText:
//
// There are no software provders loaded.
//
#define VDS_E_NO_SOFTWARE_PROVIDERS_LOADED ((HRESULT)0x80042500L)

//
// MessageId: VDS_E_DISK_NOT_MISSING
//
// MessageText:
//
// The disk is not missing.
//
#define VDS_E_DISK_NOT_MISSING           ((HRESULT)0x80042501L)

//
// MessageId: VDS_E_NO_VOLUME_LAYOUT
//
// MessageText:
//
// Failed to retrieve the volume's layout. Operations on the volume will fail.
//
#define VDS_E_NO_VOLUME_LAYOUT           ((HRESULT)0x80042502L)

//
// MessageId: VDS_E_CORRUPT_VOLUME_INFO
//
// MessageText:
//
// The volume's driver information is corrupt. Operations on the volume will fail.
//
#define VDS_E_CORRUPT_VOLUME_INFO        ((HRESULT)0x80042503L)

//
// MessageId: VDS_E_INVALID_ENUMERATOR
//
// MessageText:
//
// The enumerator is corrupted.
//
#define VDS_E_INVALID_ENUMERATOR         ((HRESULT)0x80042504L)

//
// MessageId: VDS_E_DRIVER_INTERNAL_ERROR
//
// MessageText:
//
// Internal error in the volume management driver.
//
#define VDS_E_DRIVER_INTERNAL_ERROR      ((HRESULT)0x80042505L)

//
// MessageId: VDS_E_VOLUME_INVALID_NAME
//
// MessageText:
//
// The volume name is invalid.
//
#define VDS_E_VOLUME_INVALID_NAME        ((HRESULT)0x80042507L)

//
// MessageId: VDS_S_DISK_IS_MISSING
//
// MessageText:
//
// The disk is missing, not all information could be returned.
//
#define VDS_S_DISK_IS_MISSING            ((HRESULT)0x00042508L)

//
// MessageId: VDS_E_CORRUPT_PARTITION_INFO
//
// MessageText:
//
// The disk's partition information is corrupted.
//
#define VDS_E_CORRUPT_PARTITION_INFO     ((HRESULT)0x80042509L)

//
// MessageId: VDS_S_NONCONFORMANT_PARTITION_INFO
//
// MessageText:
//
// The disk's partition information is does not conform to that expected 
// on a dynamic disk.
//
#define VDS_S_NONCONFORMANT_PARTITION_INFO ((HRESULT)0x0004250AL)

//
// MessageId: VDS_E_CORRUPT_EXTENT_INFO
//
// MessageText:
//
// The disk's extent information is corrupted.
//
#define VDS_E_CORRUPT_EXTENT_INFO        ((HRESULT)0x8004250BL)

//
// MessageId: VDS_E_DUP_EMPTY_PACK_GUID
//
// MessageText:
//
// An empty pack already exists. Release the existing empty pack before 
// creating another empty pack.
//
#define VDS_E_DUP_EMPTY_PACK_GUID        ((HRESULT)0x8004250CL)

//
// MessageId: VDS_E_DRIVER_NO_PACK_NAME
//
// MessageText:
//
// The volume management driver did not return a pack name. 
// Internal driver error.
//
#define VDS_E_DRIVER_NO_PACK_NAME        ((HRESULT)0x8004250DL)

//
// MessageId: VDS_S_SYSTEM_PARTITION
//
// MessageText:
//
// Warning, there was a failure while checking for the system partition.
//
#define VDS_S_SYSTEM_PARTITION           ((HRESULT)0x0004250EL)

//
// MessageId: VDS_E_BAD_PNP_MESSAGE
//
// MessageText:
//
// The PNP service sent a corrupted notification to the provider.
//
#define VDS_E_BAD_PNP_MESSAGE            ((HRESULT)0x8004250FL)

//
// MessageId: VDS_E_NO_PNP_DISK_ARRIVE
//
// MessageText:
//
// No disk arrival notification was received.
//
#define VDS_E_NO_PNP_DISK_ARRIVE         ((HRESULT)0x80042510L)

//
// MessageId: VDS_E_NO_PNP_VOLUME_ARRIVE
//
// MessageText:
//
// No volume arrival notification was received.
//
#define VDS_E_NO_PNP_VOLUME_ARRIVE       ((HRESULT)0x80042511L)

//
// MessageId: VDS_E_NO_PNP_DISK_REMOVE
//
// MessageText:
//
// No disk removal notification was received.
//
#define VDS_E_NO_PNP_DISK_REMOVE         ((HRESULT)0x80042512L)

//
// MessageId: VDS_E_NO_PNP_VOLUME_REMOVE
//
// MessageText:
//
// No volume removal notification was received.
//
#define VDS_E_NO_PNP_VOLUME_REMOVE       ((HRESULT)0x80042513L)

//
// MessageId: VDS_E_PROVIDER_EXITING
//
// MessageText:
//
// The provider is exiting.
//
#define VDS_E_PROVIDER_EXITING           ((HRESULT)0x80042514L)

//
// MessageId: VDS_E_EXTENT_EXCEEDS_DISK_FREE_SPACE
//
// MessageText:
//
// The specified disk extent size exceeds the size of free disk space.
//
#define VDS_E_EXTENT_EXCEEDS_DISK_FREE_SPACE ((HRESULT)0x80042515L)

//
// MessageId: VDS_E_MEMBER_SIZE_INVALID
//
// MessageText:
//
// The size of the plex member is invalid.
//
#define VDS_E_MEMBER_SIZE_INVALID        ((HRESULT)0x80042516L)

//
// MessageId: VDS_S_NO_NOTIFICATION
//
// MessageText:
//
// No volume arrival notification was received. 
// Refresh the Disk Management display.
//
#define VDS_S_NO_NOTIFICATION            ((HRESULT)0x00042517L)

//
// MessageId: VDS_S_DEFAULT_PLEX_MEMBER_IDS
//
// MessageText:
//
// Defaults have been used for the member ids or plex ids.
//
#define VDS_S_DEFAULT_PLEX_MEMBER_IDS    ((HRESULT)0x00042518L)

//
// MessageId: VDS_E_INVALID_DISK
//
// MessageText:
//
// This operation is not allowed on an invalid disk. The disk may be 
// invalid because it is corrupted or failing, or it may be invalid 
// because it is OFFLINE.
//
#define VDS_E_INVALID_DISK               ((HRESULT)0x80042519L)

//
// MessageId: VDS_E_INVALID_PACK
//
// MessageText:
//
// This operation is not allowed on the invalid disk pack.
//
#define VDS_E_INVALID_PACK               ((HRESULT)0x8004251AL)

//
// MessageId: VDS_E_VOLUME_ON_DISK
//
// MessageText:
//
// This operation is not allowed on disks with volumes.
//
#define VDS_E_VOLUME_ON_DISK             ((HRESULT)0x8004251BL)

//
// MessageId: VDS_E_DRIVER_INVALID_PARAM
//
// MessageText:
//
// The driver returned an invalid parameter error.
//
#define VDS_E_DRIVER_INVALID_PARAM       ((HRESULT)0x8004251CL)

//
// MessageId: VDS_E_TARGET_PACK_NOT_EMPTY
//
// MessageText:
//
// The target pack is not empty.
//
#define VDS_E_TARGET_PACK_NOT_EMPTY      ((HRESULT)0x8004251DL)

//
// MessageId: VDS_E_CANNOT_SHRINK
//
// MessageText:
//
// The volume cannot be shrunk because the file system does not support it.
//
#define VDS_E_CANNOT_SHRINK              ((HRESULT)0x8004251EL)

//
// MessageId: VDS_E_MULTIPLE_PACKS
//
// MessageText:
//
// Specified disks are not all from the same pack.
//
#define VDS_E_MULTIPLE_PACKS             ((HRESULT)0x8004251FL)

//
// MessageId: VDS_E_PACK_ONLINE
//
// MessageText:
//
// This operation is not allowed on online packs. The pack must be offline.
//
#define VDS_E_PACK_ONLINE                ((HRESULT)0x80042520L)

//
// MessageId: VDS_E_INVALID_PLEX_COUNT
//
// MessageText:
//
// The plex count for the volume must be non-zero.
//
#define VDS_E_INVALID_PLEX_COUNT         ((HRESULT)0x80042521L)

//
// MessageId: VDS_E_INVALID_MEMBER_COUNT
//
// MessageText:
//
// The member count for the volume must be non-zero.
//
#define VDS_E_INVALID_MEMBER_COUNT       ((HRESULT)0x80042522L)

//
// MessageId: VDS_E_INVALID_PLEX_ORDER
//
// MessageText:
//
// The plex indexes must be monotonically increasing and begin with zero.
//
#define VDS_E_INVALID_PLEX_ORDER         ((HRESULT)0x80042523L)

//
// MessageId: VDS_E_INVALID_MEMBER_ORDER
//
// MessageText:
//
// The member indexes must be monotonically increasing and begin with zero.
//
#define VDS_E_INVALID_MEMBER_ORDER       ((HRESULT)0x80042524L)

//
// MessageId: VDS_E_INVALID_STRIPE_SIZE
//
// MessageText:
//
// The stripe size must be a multiple of 2, between 512 bytes and 1 MB, 
// for stripe and raid5 volumes. The stripe size must be zero for other 
// volume types.
//
#define VDS_E_INVALID_STRIPE_SIZE        ((HRESULT)0x80042525L)

//
// MessageId: VDS_E_INVALID_DISK_COUNT
//
// MessageText:
//
// The number of disks specified is invalid for this operation.
//
#define VDS_E_INVALID_DISK_COUNT         ((HRESULT)0x80042526L)

//
// MessageId: VDS_E_INVALID_EXTENT_COUNT
//
// MessageText:
//
// An invalid number of extents was specified for at least one disk.
//
#define VDS_E_INVALID_EXTENT_COUNT       ((HRESULT)0x80042527L)

//
// MessageId: VDS_E_SOURCE_IS_TARGET_PACK
//
// MessageText:
//
// The source and target packs must be distinct.
//
#define VDS_E_SOURCE_IS_TARGET_PACK      ((HRESULT)0x80042528L)

//
// MessageId: VDS_E_VOLUME_DISK_COUNT_MAX_EXCEEDED
//
// MessageText:
//
// The disk count for the volume exceeds the maximum.
//
#define VDS_E_VOLUME_DISK_COUNT_MAX_EXCEEDED ((HRESULT)0x80042529L)

//
// MessageId: VDS_E_CORRUPT_NOTIFICATION_INFO
//
// MessageText:
//
// The driver's notification info is corrupt.
//
#define VDS_E_CORRUPT_NOTIFICATION_INFO  ((HRESULT)0x8004252AL)

//
// MessageId: VDS_E_INVALID_PLEX_GUID
//
// MessageText:
//
// GUID_NULL is not a valid plex GUID.
//
#define VDS_E_INVALID_PLEX_GUID          ((HRESULT)0x8004252CL)

//
// MessageId: VDS_E_DISK_NOT_FOUND_IN_PACK
//
// MessageText:
//
// The specified disks do not belong to the same pack.
//
#define VDS_E_DISK_NOT_FOUND_IN_PACK     ((HRESULT)0x8004252DL)

//
// MessageId: VDS_E_DUPLICATE_DISK
//
// MessageText:
//
// The same disk was specified more than once.
//
#define VDS_E_DUPLICATE_DISK             ((HRESULT)0x8004252EL)

//
// MessageId: VDS_E_LAST_VALID_DISK
//
// MessageText:
//
// The operation cannot be completed because there is only one valid disk in the pack.
//
#define VDS_E_LAST_VALID_DISK            ((HRESULT)0x8004252FL)

//
// MessageId: VDS_E_INVALID_SECTOR_SIZE
//
// MessageText:
//
// All disks holding extents for a given volume must have the same 
// sector size, and the sector size must be valid.
//
#define VDS_E_INVALID_SECTOR_SIZE        ((HRESULT)0x80042530L)

//
// MessageId: VDS_E_ONE_EXTENT_PER_DISK
//
// MessageText:
//
// This call requires the parameters to specify one extent per disk. 
// A single disk cannot contribute to multiple members or plexes of the 
// same volume.
//
#define VDS_E_ONE_EXTENT_PER_DISK        ((HRESULT)0x80042531L)

//
// MessageId: VDS_E_INVALID_BLOCK_SIZE
//
// MessageText:
//
// Neither the volume stripe size or disk sector size was found to be non-zero.
//
#define VDS_E_INVALID_BLOCK_SIZE         ((HRESULT)0x80042532L)

//
// MessageId: VDS_E_PLEX_SIZE_INVALID
//
// MessageText:
//
// The size of the volume plex is invalid.
//
#define VDS_E_PLEX_SIZE_INVALID          ((HRESULT)0x80042533L)

//
// MessageId: VDS_E_NO_EXTENTS_FOR_PLEX
//
// MessageText:
//
// No extents were found for the plex.
//
#define VDS_E_NO_EXTENTS_FOR_PLEX        ((HRESULT)0x80042534L)

//
// MessageId: VDS_E_INVALID_PLEX_TYPE
//
// MessageText:
//
// The plex type is invalid.
//
#define VDS_E_INVALID_PLEX_TYPE          ((HRESULT)0x80042535L)

//
// MessageId: VDS_E_INVALID_PLEX_BLOCK_SIZE
//
// MessageText:
//
// The plex block size must be non-zero.
//
#define VDS_E_INVALID_PLEX_BLOCK_SIZE    ((HRESULT)0x80042536L)

//
// MessageId: VDS_E_NO_HEALTHY_DISKS
//
// MessageText:
//
// All of the disks involved in the operation are either missing or failed.
//
#define VDS_E_NO_HEALTHY_DISKS           ((HRESULT)0x80042537L)

//
// MessageId: VDS_E_CONFIG_LIMIT
//
// MessageText:
//
// The Logical Disk Manangement database is full, no more volumes or disks may be configured.
//
#define VDS_E_CONFIG_LIMIT               ((HRESULT)0x80042538L)

//
// MessageId: VDS_E_DISK_CONFIGURATION_CORRUPTED
//
// MessageText:
//
// The disk configuration data is corrupted.
//
#define VDS_E_DISK_CONFIGURATION_CORRUPTED ((HRESULT)0x80042539L)

//
// MessageId: VDS_E_DISK_CONFIGURATION_NOT_IN_SYNC
//
// MessageText:
//
// The disk configuration is not insync with the in-memory configuration.
//
#define VDS_E_DISK_CONFIGURATION_NOT_IN_SYNC ((HRESULT)0x8004253AL)

//
// MessageId: VDS_E_DISK_CONFIGURATION_UPDATE_FAILED
//
// MessageText:
//
// One or more disks failed to be updated with the new configuration.
//
#define VDS_E_DISK_CONFIGURATION_UPDATE_FAILED ((HRESULT)0x8004253BL)

//
// MessageId: VDS_E_DISK_DYNAMIC
//
// MessageText:
//
// The disk is already dynamic.
//
#define VDS_E_DISK_DYNAMIC               ((HRESULT)0x8004253CL)

//
// MessageId: VDS_E_DRIVER_OBJECT_NOT_FOUND
//
// MessageText:
//
// The object was not found in the driver cache.
//
#define VDS_E_DRIVER_OBJECT_NOT_FOUND    ((HRESULT)0x8004253DL)

//
// MessageId: VDS_E_PARTITION_NOT_CYLINDER_ALIGNED
//
// MessageText:
//
// The disk layout contains partitions which are not cylinder aligned.
//
#define VDS_E_PARTITION_NOT_CYLINDER_ALIGNED ((HRESULT)0x8004253EL)

//
// MessageId: VDS_E_DISK_LAYOUT_PARTITIONS_TOO_SMALL
//
// MessageText:
//
// The disk layout contains partitions which less than the minimum required size.
//
#define VDS_E_DISK_LAYOUT_PARTITIONS_TOO_SMALL ((HRESULT)0x8004253FL)

//
// MessageId: VDS_E_DISK_IO_FAILING
//
// MessageText:
//
// The IO to the disk is failing.
//
#define VDS_E_DISK_IO_FAILING            ((HRESULT)0x80042540L)

//
// MessageId: VDS_E_DYNAMIC_DISKS_NOT_SUPPORTED
//
// MessageText:
//
// Dynamic disks are not supported by this operating system or server configuration. Dynamic disks are not supported on clusters.
//
#define VDS_E_DYNAMIC_DISKS_NOT_SUPPORTED ((HRESULT)0x80042541L)

//
// MessageId: VDS_E_FAULT_TOLERANT_DISKS_NOT_SUPPORTED
//
// MessageText:
//
// The fault tolerant disks are not supported by this operating system.
//
#define VDS_E_FAULT_TOLERANT_DISKS_NOT_SUPPORTED ((HRESULT)0x80042542L)

//
// MessageId: VDS_E_GPT_ATTRIBUTES_INVALID
//
// MessageText:
//
// Invalid GPT attributes were specified.
//
#define VDS_E_GPT_ATTRIBUTES_INVALID     ((HRESULT)0x80042543L)

//
// MessageId: VDS_E_MEMBER_IS_HEALTHY
//
// MessageText:
//
// The member is not stale or detached.
//
#define VDS_E_MEMBER_IS_HEALTHY          ((HRESULT)0x80042544L)

//
// MessageId: VDS_E_MEMBER_REGENERATING
//
// MessageText:
//
// The member is regenerating.
//
#define VDS_E_MEMBER_REGENERATING        ((HRESULT)0x80042545L)

//
// MessageId: VDS_E_PACK_NAME_INVALID
//
// MessageText:
//
// The pack name is invalid.
//
#define VDS_E_PACK_NAME_INVALID          ((HRESULT)0x80042546L)

//
// MessageId: VDS_E_PLEX_IS_HEALTHY
//
// MessageText:
//
// The plex is not stale or detached.
//
#define VDS_E_PLEX_IS_HEALTHY            ((HRESULT)0x80042547L)

//
// MessageId: VDS_E_PLEX_LAST_ACTIVE
//
// MessageText:
//
// The last healthy plex cannot be removed.
//
#define VDS_E_PLEX_LAST_ACTIVE           ((HRESULT)0x80042548L)

//
// MessageId: VDS_E_PLEX_MISSING
//
// MessageText:
//
// The plex is missing.
//
#define VDS_E_PLEX_MISSING               ((HRESULT)0x80042549L)

//
// MessageId: VDS_E_MEMBER_MISSING
//
// MessageText:
//
// The member is missing.
//
#define VDS_E_MEMBER_MISSING             ((HRESULT)0x8004254AL)

//
// MessageId: VDS_E_PLEX_REGENERATING
//
// MessageText:
//
// The plex is regenerating.
//
#define VDS_E_PLEX_REGENERATING          ((HRESULT)0x8004254BL)

//
// MessageId: VDS_E_UNEXPECTED_DISK_LAYOUT_CHANGE
//
// MessageText:
//
// An unexpected layout change occurred external to the volume manager.
//
#define VDS_E_UNEXPECTED_DISK_LAYOUT_CHANGE ((HRESULT)0x8004254DL)

//
// MessageId: VDS_E_INVALID_VOLUME_LENGTH
//
// MessageText:
//
// The volume length is invalid.
//
#define VDS_E_INVALID_VOLUME_LENGTH      ((HRESULT)0x8004254EL)

//
// MessageId: VDS_E_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE
//
// MessageText:
//
// The volume length is not a multiple of the sector size.
//
#define VDS_E_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE ((HRESULT)0x8004254FL)

//
// MessageId: VDS_E_VOLUME_NOT_RETAINED
//
// MessageText:
//
// The volume does not have a retained partition association.
//
#define VDS_E_VOLUME_NOT_RETAINED        ((HRESULT)0x80042550L)

//
// MessageId: VDS_E_VOLUME_RETAINED
//
// MessageText:
//
// The volume already has a retained partition association.
//
#define VDS_E_VOLUME_RETAINED            ((HRESULT)0x80042551L)

//
// MessageId: VDS_E_ALIGN_BEYOND_FIRST_CYLINDER
//
// MessageText:
//
// The specified alignment is beyond the first cylinder.
//
#define VDS_E_ALIGN_BEYOND_FIRST_CYLINDER ((HRESULT)0x80042553L)

//
// MessageId: VDS_E_ALIGN_NOT_SECTOR_SIZE_MULTIPLE
//
// MessageText:
//
// The specified alignment is not a multiple of the sector size.
//
#define VDS_E_ALIGN_NOT_SECTOR_SIZE_MULTIPLE ((HRESULT)0x80042554L)

//
// MessageId: VDS_E_ALIGN_NOT_ZERO
//
// MessageText:
//
// The specified partition type cannot be created with a non-zero alignment.
//
#define VDS_E_ALIGN_NOT_ZERO             ((HRESULT)0x80042555L)

//
// MessageId: VDS_E_CACHE_CORRUPT
//
// MessageText:
//
// The service's cache has become corrupt.
//
#define VDS_E_CACHE_CORRUPT              ((HRESULT)0x80042556L)

//
// MessageId: VDS_E_CANNOT_CLEAR_VOLUME_FLAG
//
// MessageText:
//
// The specified volume flag cannot be cleared.
//
#define VDS_E_CANNOT_CLEAR_VOLUME_FLAG   ((HRESULT)0x80042557L)

//
// MessageId: VDS_E_DISK_BEING_CLEANED
//
// MessageText:
//
// The operation is not allowed on a disk that is in the process of being cleaned.
//
#define VDS_E_DISK_BEING_CLEANED         ((HRESULT)0x80042558L)

//
// MessageId: VDS_E_DISK_NOT_CONVERTIBLE
//
// MessageText:
//
// The specified disk is not convertible. CDROMs and DVDs 
// are examples of disks that are not convertable.
//
#define VDS_E_DISK_NOT_CONVERTIBLE       ((HRESULT)0x80042559L)

//
// MessageId: VDS_E_DISK_REMOVEABLE
//
// MessageText:
//
// The operation is not supported on removable media.
//
#define VDS_E_DISK_REMOVEABLE            ((HRESULT)0x8004255AL)

//
// MessageId: VDS_E_DISK_REMOVEABLE_NOT_EMPTY
//
// MessageText:
//
// The operation is not supported on a non-empty removable disk.
//
#define VDS_E_DISK_REMOVEABLE_NOT_EMPTY  ((HRESULT)0x8004255BL)

//
// MessageId: VDS_E_DRIVE_LETTER_NOT_FREE
//
// MessageText:
//
// The specified drive letter is not free to be assigned.
//
#define VDS_E_DRIVE_LETTER_NOT_FREE      ((HRESULT)0x8004255CL)

//
// MessageId: VDS_E_EXTEND_MULTIPLE_DISKS_NOT_SUPPORTED
//
// MessageText:
//
// Extending the volume onto multiple disks is not supported by this provider.
//
#define VDS_E_EXTEND_MULTIPLE_DISKS_NOT_SUPPORTED ((HRESULT)0x8004255DL)

//
// MessageId: VDS_E_INVALID_DRIVE_LETTER
//
// MessageText:
//
// The specified drive letter is invalid.
//
#define VDS_E_INVALID_DRIVE_LETTER       ((HRESULT)0x8004255EL)

//
// MessageId: VDS_E_INVALID_DRIVE_LETTER_COUNT
//
// MessageText:
//
// The specified number of drive letters to retrieve is invalid.
//
#define VDS_E_INVALID_DRIVE_LETTER_COUNT ((HRESULT)0x8004255FL)

//
// MessageId: VDS_E_INVALID_FS_FLAG
//
// MessageText:
//
// The specified file system flag is invalid.
//
#define VDS_E_INVALID_FS_FLAG            ((HRESULT)0x80042560L)

//
// MessageId: VDS_E_INVALID_FS_TYPE
//
// MessageText:
//
// The specified file system is invalid.
//
#define VDS_E_INVALID_FS_TYPE            ((HRESULT)0x80042561L)

//
// MessageId: VDS_E_INVALID_OBJECT_TYPE
//
// MessageText:
//
// The specified object type is invalid.
//
#define VDS_E_INVALID_OBJECT_TYPE        ((HRESULT)0x80042562L)

//
// MessageId: VDS_E_INVALID_PARTITION_LAYOUT
//
// MessageText:
//
// The specified partition layout is invalid.
//
#define VDS_E_INVALID_PARTITION_LAYOUT   ((HRESULT)0x80042563L)

//
// MessageId: VDS_E_INVALID_PARTITION_STYLE
//
// MessageText:
//
// The specified disk's partition style is INVALID.  
// VDS only supports MBR or GPT partition style disks.
//
#define VDS_E_INVALID_PARTITION_STYLE    ((HRESULT)0x80042564L)

//
// MessageId: VDS_E_INVALID_PARTITION_TYPE
//
// MessageText:
//
// The specified partition type is not valid for this operation.
//
#define VDS_E_INVALID_PARTITION_TYPE     ((HRESULT)0x80042565L)

//
// MessageId: VDS_E_INVALID_PROVIDER_CLSID
//
// MessageText:
//
// The specified provider clsid cannot be a NULL GUID.
//
#define VDS_E_INVALID_PROVIDER_CLSID     ((HRESULT)0x80042566L)

//
// MessageId: VDS_E_INVALID_PROVIDER_ID
//
// MessageText:
//
// The specified provider id cannot be a NULL GUID.
//
#define VDS_E_INVALID_PROVIDER_ID        ((HRESULT)0x80042567L)

//
// MessageId: VDS_E_INVALID_PROVIDER_NAME
//
// MessageText:
//
// The specified provider name is invalid.
//
#define VDS_E_INVALID_PROVIDER_NAME      ((HRESULT)0x80042568L)

//
// MessageId: VDS_E_INVALID_PROVIDER_TYPE
//
// MessageText:
//
// The specified provider type is invalid.
//
#define VDS_E_INVALID_PROVIDER_TYPE      ((HRESULT)0x80042569L)

//
// MessageId: VDS_E_INVALID_PROVIDER_VERSION_GUID
//
// MessageText:
//
// The specified provider version GUID cannot be a NULL GUID.
//
#define VDS_E_INVALID_PROVIDER_VERSION_GUID ((HRESULT)0x8004256AL)

//
// MessageId: VDS_E_INVALID_PROVIDER_VERSION_STRING
//
// MessageText:
//
// The specified provider version string is invalid.
//
#define VDS_E_INVALID_PROVIDER_VERSION_STRING ((HRESULT)0x8004256BL)

//
// MessageId: VDS_E_INVALID_QUERY_PROVIDER_FLAG
//
// MessageText:
//
// The specified query provider flag is invalid.
//
#define VDS_E_INVALID_QUERY_PROVIDER_FLAG ((HRESULT)0x8004256CL)

//
// MessageId: VDS_E_INVALID_SERVICE_FLAG
//
// MessageText:
//
// The specified service flag is invalid.
//
#define VDS_E_INVALID_SERVICE_FLAG       ((HRESULT)0x8004256DL)

//
// MessageId: VDS_E_INVALID_VOLUME_FLAG
//
// MessageText:
//
// The specified volume flag is invalid.
//
#define VDS_E_INVALID_VOLUME_FLAG        ((HRESULT)0x8004256EL)

//
// MessageId: VDS_E_PARTITION_NOT_OEM
//
// MessageText:
//
// The operation is not supported on non-OEM partitions.
//
#define VDS_E_PARTITION_NOT_OEM          ((HRESULT)0x8004256FL)

//
// MessageId: VDS_E_PARTITION_PROTECTED
//
// MessageText:
//
// Cannot delete a protected partition without the force protected parameter set.
//
#define VDS_E_PARTITION_PROTECTED        ((HRESULT)0x80042570L)

//
// MessageId: VDS_E_PARTITION_STYLE_MISMATCH
//
// MessageText:
//
// The specified partition style does not match that of the disk.
//
#define VDS_E_PARTITION_STYLE_MISMATCH   ((HRESULT)0x80042571L)

//
// MessageId: VDS_E_PROVIDER_INTERNAL_ERROR
//
// MessageText:
//
// An internal error has occurred in the provider.
//
#define VDS_E_PROVIDER_INTERNAL_ERROR    ((HRESULT)0x80042572L)

//
// MessageId: VDS_E_SHRINK_SIZE_LESS_THAN_MIN
//
// MessageText:
//
// The specified shrink size is less than then minimum shrink size allowed.
//
#define VDS_E_SHRINK_SIZE_LESS_THAN_MIN  ((HRESULT)0x80042573L)

//
// MessageId: VDS_E_SHRINK_SIZE_TOO_BIG
//
// MessageText:
//
// The specified shrink size is too big and will cause the volume to be 
// smaller than the minimum volume size.
//
#define VDS_E_SHRINK_SIZE_TOO_BIG        ((HRESULT)0x80042574L)

//
// MessageId: VDS_E_UNRECOVERABLE_PROVIDER_ERROR
//
// MessageText:
//
// An unrecoverable error occurred in a provider.  
// The service must be shut down to regain full functionality.
//
#define VDS_E_UNRECOVERABLE_PROVIDER_ERROR ((HRESULT)0x80042575L)

//
// MessageId: VDS_E_VOLUME_HIDDEN
//
// MessageText:
//
// Cannot assign a mount point to a hidden volume.
//
#define VDS_E_VOLUME_HIDDEN              ((HRESULT)0x80042576L)

//
// MessageId: VDS_S_DISMOUNT_FAILED
//
// MessageText:
//
// Failed to dismount the volume after setting the volume flags.
//
#define VDS_S_DISMOUNT_FAILED            ((HRESULT)0x00042577L)

//
// MessageId: VDS_S_REMOUNT_FAILED
//
// MessageText:
//
// Failed to remount the volume after setting the volume flags.
//
#define VDS_S_REMOUNT_FAILED             ((HRESULT)0x00042578L)

//
// MessageId: VDS_E_FLAG_ALREADY_SET
//
// MessageText:
//
// Can't set the specified flag as revert-on-close, because it is already set.
//
#define VDS_E_FLAG_ALREADY_SET           ((HRESULT)0x80042579L)

//
// MessageId: VDS_S_RESYNC_NOTIFICATION_TASK_FAILED
//
// MessageText:
//
// Failure. If the volume is a mirror volume or a raid5 volume, no 
// resynchronization notifications will be sent.
//
#define VDS_S_RESYNC_NOTIFICATION_TASK_FAILED ((HRESULT)0x0004257AL)

//
// MessageId: VDS_E_DISTINCT_VOLUME
//
// MessageText:
//
// The input volume id cannot be the id of the volume that is the target of 
// the operation.
//
#define VDS_E_DISTINCT_VOLUME            ((HRESULT)0x8004257BL)

//
// MessageId: VDS_E_VOLUME_NOT_FOUND_IN_PACK
//
// MessageText:
//
// The specified volumes do not belong to the same pack.
//
#define VDS_E_VOLUME_NOT_FOUND_IN_PACK   ((HRESULT)0x8004257CL)

//
// MessageId: VDS_E_PARTITION_NON_DATA
//
// MessageText:
//
// The specified partition is a not a primary or logical volume.
//
#define VDS_E_PARTITION_NON_DATA         ((HRESULT)0x8004257DL)

//
// MessageId: VDS_E_CRITICAL_PLEX
//
// MessageText:
//
// The specified plex is a the current system or boot plex.
//
#define VDS_E_CRITICAL_PLEX              ((HRESULT)0x8004257EL)

//
// MessageId: VDS_E_VOLUME_SYNCHRONIZING
//
// MessageText:
//
// The operation cannot be completed because the volume is synchronizing.
//
#define VDS_E_VOLUME_SYNCHRONIZING       ((HRESULT)0x8004257FL)

//
// MessageId: VDS_E_VOLUME_REGENERATING
//
// MessageText:
//
// The operation cannot be completed because the volume is regenerating.
//
#define VDS_E_VOLUME_REGENERATING        ((HRESULT)0x80042580L)

//
// MessageId: VDS_S_VSS_FLUSH_AND_HOLD_WRITES
//
// MessageText:
//
// Failed to flush and hold Volume Snapshot Service writes.
//
#define VDS_S_VSS_FLUSH_AND_HOLD_WRITES  ((HRESULT)0x00042581L)

//
// MessageId: VDS_S_VSS_RELEASE_WRITES
//
// MessageText:
//
// Failed to release Volume Snapshot Service writes.
//
#define VDS_S_VSS_RELEASE_WRITES         ((HRESULT)0x00042582L)

//
// MessageId: VDS_S_FS_LOCK
//
// MessageText:
//
// Failed to obtain a file system lock.
//
#define VDS_S_FS_LOCK                    ((HRESULT)0x00042583L)

//
// MessageId: VDS_E_READONLY
//
// MessageText:
//
// The volume is read only.
//
#define VDS_E_READONLY                   ((HRESULT)0x80042584L)

//
// MessageId: VDS_E_INVALID_VOLUME_TYPE
//
// MessageText:
//
// The volume type is invalid for this operation.
//
#define VDS_E_INVALID_VOLUME_TYPE        ((HRESULT)0x80042585L)

//
// MessageId: VDS_E_BAD_BOOT_DISK
//
// MessageText:
//
// The boot disk experienced failures when the driver attempted to online 
// the pack.
//
#define VDS_E_BAD_BOOT_DISK              ((HRESULT)0x80042586L)

//
// MessageId: VDS_E_LOG_UPDATE
//
// MessageText:
//
// The driver failed to update the log on at least one disk.
//
#define VDS_E_LOG_UPDATE                 ((HRESULT)0x80042587L)

//
// MessageId: VDS_E_VOLUME_MIRRORED
//
// MessageText:
//
// This operation is not supported on a mirrored volume.
//
#define VDS_E_VOLUME_MIRRORED            ((HRESULT)0x80042588L)

//
// MessageId: VDS_E_VOLUME_SIMPLE_SPANNED
//
// MessageText:
//
// This operation is only supported on simple or spanned volumes.
//
#define VDS_E_VOLUME_SIMPLE_SPANNED      ((HRESULT)0x80042589L)

//
// MessageId: VDS_E_NO_VALID_LOG_COPIES
//
// MessageText:
//
// This pack has no valid log copies.
//
#define VDS_E_NO_VALID_LOG_COPIES        ((HRESULT)0x8004258AL)

//
// MessageId: VDS_S_PLEX_NOT_LOADED_TO_CACHE
//
// MessageText:
//
// This plex is present in the driver, but has not yet been loaded to the 
// provider cache. A volume modified notification will be sent by the service 
// once the plex has been loaded to the provider cache.
//
#define VDS_S_PLEX_NOT_LOADED_TO_CACHE   ((HRESULT)0x0004258BL)

//
// MessageId: VDS_E_PLEX_NOT_LOADED_TO_CACHE
//
// MessageText:
//
// This plex is present in the driver, but has not yet been loaded to the 
// provider cache. A volume modified notification will be sent by the service 
// once the plex has been loaded to the provider cache.
//
#define VDS_E_PLEX_NOT_LOADED_TO_CACHE   ((HRESULT)0x8004258BL)

//
// MessageId: VDS_E_PARTITION_MSR
//
// MessageText:
//
// This operation is not supported on MSR partitions.
//
#define VDS_E_PARTITION_MSR              ((HRESULT)0x8004258CL)

//
// MessageId: VDS_E_PARTITION_LDM
//
// MessageText:
//
// This operation is not supported on LDM partitions.
//
#define VDS_E_PARTITION_LDM              ((HRESULT)0x8004258DL)

//
// MessageId: VDS_S_WINPE_BOOTENTRY
//
// MessageText:
//
// The boot entries cannot be updated automatically on WinPE. You may need 
// to manually update the boot entry for any installed operating systems.
//
#define VDS_S_WINPE_BOOTENTRY            ((HRESULT)0x0004258EL)

//
// MessageId: VDS_E_ALIGN_NOT_A_POWER_OF_TWO
//
// MessageText:
//
// The specified alignment is not a power of two.
//
#define VDS_E_ALIGN_NOT_A_POWER_OF_TWO   ((HRESULT)0x8004258FL)

//
// MessageId: VDS_E_ALIGN_IS_ZERO
//
// MessageText:
//
// The specified alignment is zero.
//
#define VDS_E_ALIGN_IS_ZERO              ((HRESULT)0x80042590L)

//
// MessageId: VDS_E_SHRINK_IN_PROGRESS
//
// MessageText:
//
// A defragmentation or volume shrink operation is already in progress. 
// Only one of these operations can run at a time.
//
#define VDS_E_SHRINK_IN_PROGRESS         ((HRESULT)0x80042591L)

//
// MessageId: VDS_E_CANT_INVALIDATE_FVE
//
// MessageText:
//
// BitLocker encryption on the volume could not be removed.
//
#define VDS_E_CANT_INVALIDATE_FVE        ((HRESULT)0x80042592L)

//
// MessageId: VDS_E_FS_NOT_DETERMINED
//
// MessageText:
//
// The default file system could not be determined.
//
#define VDS_E_FS_NOT_DETERMINED          ((HRESULT)0x80042593L)

//
// MessageId: VDS_E_DISK_NOT_OFFLINE
//
// MessageText:
//
// This disk is already online. 
//
#define VDS_E_DISK_NOT_OFFLINE           ((HRESULT)0x80042595L)

//
// MessageId: VDS_E_FAILED_TO_ONLINE_DISK
//
// MessageText:
//
// The online operation failed.
//
#define VDS_E_FAILED_TO_ONLINE_DISK      ((HRESULT)0x80042596L)

//
// MessageId: VDS_E_FAILED_TO_OFFLINE_DISK
//
// MessageText:
//
// The offline operation failed.
//
#define VDS_E_FAILED_TO_OFFLINE_DISK     ((HRESULT)0x80042597L)

//
// MessageId: VDS_E_BAD_REVISION_NUMBER
//
// MessageText:
//
// The operation could not be completed because the specified revision number 
// is not supported.
//
#define VDS_E_BAD_REVISION_NUMBER        ((HRESULT)0x80042598L)

//
// MessageId: VDS_E_SHRINK_USER_CANCELLED
//
// MessageText:
//
// The shrink operation was cancelled by the user.
//
#define VDS_E_SHRINK_USER_CANCELLED      ((HRESULT)0x80042599L)

//
// MessageId: VDS_E_SHRINK_DIRTY_VOLUME
//
// MessageText:
//
// The volume you have selected to shrink may be corrupted. 
// Use Chkdsk to fix the corruption problem, and then try to shrink the 
// volume again.
//
#define VDS_E_SHRINK_DIRTY_VOLUME        ((HRESULT)0x8004259AL)

//////////////////////////////////////////////////////////////////////////////
//
// Codes added in VDS 1.1:                       0x2700-0x27FF
//
//////////////////////////////////////////////////////////////////////////////
//
// MessageId: VDS_S_NAME_TRUNCATED
//
// MessageText:
//
// The name was accepted but had to be truncated.
//
#define VDS_S_NAME_TRUNCATED             ((HRESULT)0x00042700L)

//
// MessageId: VDS_E_NAME_NOT_UNIQUE
//
// MessageText:
//
// The name is not unique.
//
#define VDS_E_NAME_NOT_UNIQUE            ((HRESULT)0x80042701L)

//
// MessageId: VDS_S_STATUSES_INCOMPLETELY_SET
//
// MessageText:
//
// At least one path status is not set successfully due to a non-fatal error, 
// for example the status conflicts with the current load balance policy.
//
#define VDS_S_STATUSES_INCOMPLETELY_SET  ((HRESULT)0x00042702L)

//
// MessageId: VDS_E_ADDRESSES_INCOMPLETELY_SET
//
// MessageText:
//
// At least one portal's tunnel address is not set successfully.
//
#define VDS_E_ADDRESSES_INCOMPLETELY_SET ((HRESULT)0x80042703L)

//
// MessageId: VDS_E_SECURITY_INCOMPLETELY_SET
//
// MessageText:
//
// At least one portal's security settings are not set successfully.
//
#define VDS_E_SECURITY_INCOMPLETELY_SET  ((HRESULT)0x80042705L)

//
// MessageId: VDS_E_TARGET_SPECIFIC_NOT_SUPPORTED
//
// MessageText:
//
// The initiator does not support setting target-specific shared secrets.
//
#define VDS_E_TARGET_SPECIFIC_NOT_SUPPORTED ((HRESULT)0x80042706L)

//
// MessageId: VDS_E_INITIATOR_SPECIFIC_NOT_SUPPORTED
//
// MessageText:
//
// The target does not support setting initiator-specific shared secrets.
//
#define VDS_E_INITIATOR_SPECIFIC_NOT_SUPPORTED ((HRESULT)0x80042707L)

//
// MessageId: VDS_E_ISCSI_LOGIN_FAILED
//
// MessageText:
//
// An iSCSI login session could not be established.
//
#define VDS_E_ISCSI_LOGIN_FAILED         ((HRESULT)0x80042708L)

//
// MessageId: VDS_E_ISCSI_LOGOUT_FAILED
//
// MessageText:
//
// The attempt to log out from the specified iSCSI session failed.
//
#define VDS_E_ISCSI_LOGOUT_FAILED        ((HRESULT)0x80042709L)

//
// MessageId: VDS_E_ISCSI_SESSION_NOT_FOUND
//
// MessageText:
//
// The specified iSCSI session with a connection matching the specified target, 
// target portal, and/or initiator portal could not be found.
//
#define VDS_E_ISCSI_SESSION_NOT_FOUND    ((HRESULT)0x8004270AL)

//
// MessageId: VDS_E_ASSOCIATED_LUNS_EXIST
//
// MessageText:
//
// LUNs are associated with the specified target and must first be 
// deassociated before the target can be deleted.
//
#define VDS_E_ASSOCIATED_LUNS_EXIST      ((HRESULT)0x8004270BL)

//
// MessageId: VDS_E_ASSOCIATED_PORTALS_EXIST
//
// MessageText:
//
// Portals are associated with the specified portal group and must first be 
// deassociated before the portal group can be deleted.
//
#define VDS_E_ASSOCIATED_PORTALS_EXIST   ((HRESULT)0x8004270CL)

//
// MessageId: VDS_E_NO_DISCOVERY_DOMAIN
//
// MessageText:
//
// The initiator does not exist in a iSNS discovery domain.
//
#define VDS_E_NO_DISCOVERY_DOMAIN        ((HRESULT)0x8004270DL)

//
// MessageId: VDS_E_MULTIPLE_DISCOVERY_DOMAINS
//
// MessageText:
//
// The initiator exists in more than one iSNS discovery domain.
//
#define VDS_E_MULTIPLE_DISCOVERY_DOMAINS ((HRESULT)0x8004270EL)

//
// MessageId: VDS_E_NO_DISK_PATHNAME
//
// MessageText:
//
// Failed to retrieve the disk's pathname. Some operations on the disk may fail.
//
#define VDS_E_NO_DISK_PATHNAME           ((HRESULT)0x8004270FL)

//
// MessageId: VDS_E_ISCSI_LOGOUT_INCOMPLETE
//
// MessageText:
//
// At least one session did not logout successfully.
//
#define VDS_E_ISCSI_LOGOUT_INCOMPLETE    ((HRESULT)0x80042710L)

//
// MessageId: VDS_E_NO_VOLUME_PATHNAME
//
// MessageText:
//
// Failed to retrieve the volume's pathname.
//
#define VDS_E_NO_VOLUME_PATHNAME         ((HRESULT)0x80042711L)

//
// MessageId: VDS_E_PROVIDER_CACHE_OUTOFSYNC
//
// MessageText:
//
// The provider's cache is not in-sync with the driver cache.
//
#define VDS_E_PROVIDER_CACHE_OUTOFSYNC   ((HRESULT)0x80042712L)

//
// MessageId: VDS_E_NO_IMPORT_TARGET
//
// MessageText:
//
// No import target was set for this subsystem in the registry.
//
#define VDS_E_NO_IMPORT_TARGET           ((HRESULT)0x80042713L)

//
// MessageId: VDS_S_ALREADY_EXISTS
//
// MessageText:
//
// The object already exists and does not need to be further created or added.
//
#define VDS_S_ALREADY_EXISTS             ((HRESULT)0x00042714L)

//
// MessageId: VDS_S_PROPERTIES_INCOMPLETE
//
// MessageText:
//
// Unable to retrieve all properties for this object. 
// Some attributes may be incomplete or missing.
//
#define VDS_S_PROPERTIES_INCOMPLETE      ((HRESULT)0x00042715L)

//////////////////////////////////////////////////////////////////////////////
//
// Codes added in Windows Server 2008:     0x2800-0x28FF
//
//////////////////////////////////////////////////////////////////////////////
//
// MessageId: VDS_S_ISCSI_SESSION_NOT_FOUND_PERSISTENT_LOGIN_REMOVED
//
// MessageText:
//
// No iSCSI sessions to the target were found, but the persistent login 
// setup to the target was removed.
//
#define VDS_S_ISCSI_SESSION_NOT_FOUND_PERSISTENT_LOGIN_REMOVED ((HRESULT)0x00042800L)

//
// MessageId: VDS_S_ISCSI_PERSISTENT_LOGIN_MAY_NOT_BE_REMOVED
//
// MessageText:
//
// If a persistent login was set up for the target, it may not have been 
// removed. Check the iSCSI Initiator Control Panel to remove it if necessary.
//
#define VDS_S_ISCSI_PERSISTENT_LOGIN_MAY_NOT_BE_REMOVED ((HRESULT)0x00042801L)

//
// MessageId: VDS_S_ISCSI_LOGIN_ALREAD_EXISTS
//
// MessageText:
//
// Login failed because the target is already logged in.
//
#define VDS_S_ISCSI_LOGIN_ALREAD_EXISTS  ((HRESULT)0x00042802L)

//
// MessageId: VDS_E_UNABLE_TO_FIND_BOOT_DISK
//
// MessageText:
//
// A system error occurred while retrieving the boot disk information.
//
#define VDS_E_UNABLE_TO_FIND_BOOT_DISK   ((HRESULT)0x80042803L)

//
// MessageId: VDS_E_INCORRECT_BOOT_VOLUME_EXTENT_INFO
//
// MessageText:
//
// Multiple disk extents reported for the boot volume - system error.
//
#define VDS_E_INCORRECT_BOOT_VOLUME_EXTENT_INFO ((HRESULT)0x80042804L)

//
// MessageId: VDS_E_GET_SAN_POLICY
//
// MessageText:
//
// A driver error was reported when getting the SAN policy.
//
#define VDS_E_GET_SAN_POLICY             ((HRESULT)0x80042805L)

//
// MessageId: VDS_E_SET_SAN_POLICY
//
// MessageText:
//
// A driver error was reported when setting the SAN policy.
//
#define VDS_E_SET_SAN_POLICY             ((HRESULT)0x80042806L)

//
// MessageId: VDS_E_BOOT_DISK
//
// MessageText:
//
// Disk attributes may not be changed on the boot disk.
//
#define VDS_E_BOOT_DISK                  ((HRESULT)0x80042807L)

//
// MessageId: VDS_S_DISK_MOUNT_FAILED
//
// MessageText:
//
// Failed to mount one or more of the volumes on the disk.
//
#define VDS_S_DISK_MOUNT_FAILED          ((HRESULT)0x00042808L)

//
// MessageId: VDS_S_DISK_DISMOUNT_FAILED
//
// MessageText:
//
// Failed to dismount one or more of the volumes on the disk.
//
#define VDS_S_DISK_DISMOUNT_FAILED       ((HRESULT)0x00042809L)

//
// MessageId: VDS_E_DISK_IS_OFFLINE
//
// MessageText:
//
// The operation is not allowed on a disk that is offline.
//
#define VDS_E_DISK_IS_OFFLINE            ((HRESULT)0x8004280AL)

//
// MessageId: VDS_E_DISK_IS_READ_ONLY
//
// MessageText:
//
// The operation is not allowed on a disk that is read only.
//
#define VDS_E_DISK_IS_READ_ONLY          ((HRESULT)0x8004280BL)

//
// MessageId: VDS_E_PAGEFILE_DISK
//
// MessageText:
//
// The operation is not allowed on a disk that contains a pagefile volume.
//
#define VDS_E_PAGEFILE_DISK              ((HRESULT)0x8004280CL)

//
// MessageId: VDS_E_HIBERNATION_FILE_DISK
//
// MessageText:
//
// The operation is not allowed on a disk that contains a hibernation file volume.
//
#define VDS_E_HIBERNATION_FILE_DISK      ((HRESULT)0x8004280DL)

//
// MessageId: VDS_E_CRASHDUMP_DISK
//
// MessageText:
//
// The operation is not allowed on a disk that contains a crashdump file volume.
//
#define VDS_E_CRASHDUMP_DISK             ((HRESULT)0x8004280EL)

//
// MessageId: VDS_E_UNABLE_TO_FIND_SYSTEM_DISK
//
// MessageText:
//
// A system error occurred while retrieving the system disk information.
//
#define VDS_E_UNABLE_TO_FIND_SYSTEM_DISK ((HRESULT)0x8004280FL)

//
// MessageId: VDS_E_INCORRECT_SYSTEM_VOLUME_EXTENT_INFO
//
// MessageText:
//
// Multiple disk extents reported for the system volume - system error.
//
#define VDS_E_INCORRECT_SYSTEM_VOLUME_EXTENT_INFO ((HRESULT)0x80042810L)

//
// MessageId: VDS_E_SYSTEM_DISK
//
// MessageText:
//
// Disk attributes may not be changed on the current system disk or BIOS disk 0.
//
#define VDS_E_SYSTEM_DISK                ((HRESULT)0x80042811L)

//
// MessageId: VDS_E_VOLUME_SHRINK_FVE_LOCKED
//
// MessageText:
//
// The volume could not be shrunk because it is locked by BitLocker. 
// Unlock the volume and try again.
//
#define VDS_E_VOLUME_SHRINK_FVE_LOCKED   ((HRESULT)0x80042812L)

//
// MessageId: VDS_E_VOLUME_SHRINK_FVE_CORRUPT
//
// MessageText:
//
// The volume could not be shrunk because it is locked due to a BitLocker error. 
// Use BitLocker tools to recover the volume and try again.
//
#define VDS_E_VOLUME_SHRINK_FVE_CORRUPT  ((HRESULT)0x80042813L)

//
// MessageId: VDS_E_VOLUME_SHRINK_FVE_RECOVERY
//
// MessageText:
//
// The volume could not be shrunk because it is marked for BitLocker recovery. 
// Use BitLocker tools to recover the volume and try again.
//
#define VDS_E_VOLUME_SHRINK_FVE_RECOVERY ((HRESULT)0x80042814L)

//
// MessageId: VDS_E_VOLUME_SHRINK_FVE
//
// MessageText:
//
// The volume could not be shrunk because it is encrypted by BitLocker and 
// Fveapi.dll could not be loaded to determine its status. For this operation to 
// succeed, Fveapi.dll must be available in %SystemRoot%\System32\.
//
#define VDS_E_VOLUME_SHRINK_FVE          ((HRESULT)0x80042815L)

//
// MessageId: VDS_E_SHRINK_OVER_DATA
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// Completing the operation using the specified parameters will 
// overwrite volumes containing user data.
//
#define VDS_E_SHRINK_OVER_DATA           ((HRESULT)0x80042816L)

//
// MessageId: VDS_E_INVALID_SHRINK_SIZE
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The specified size is greater than the size of the LUN.
//
#define VDS_E_INVALID_SHRINK_SIZE        ((HRESULT)0x80042817L)

//
// MessageId: VDS_E_LUN_DISK_MISSING
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The current state of the disk associated with the LUN is MISSING.
//
#define VDS_E_LUN_DISK_MISSING           ((HRESULT)0x80042818L)

//
// MessageId: VDS_E_LUN_DISK_FAILED
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The current state of the disk associated with the LUN is FAILED.
//
#define VDS_E_LUN_DISK_FAILED            ((HRESULT)0x80042819L)

//
// MessageId: VDS_E_LUN_DISK_NOT_READY
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The current state of the disk associated with the LUN is NOT READY.
//
#define VDS_E_LUN_DISK_NOT_READY         ((HRESULT)0x8004281AL)

//
// MessageId: VDS_E_LUN_DISK_NO_MEDIA
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The current state of the disk associated with the LUN is NO MEDIA.
//
#define VDS_E_LUN_DISK_NO_MEDIA          ((HRESULT)0x8004281BL)

//
// MessageId: VDS_E_LUN_NOT_READY
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The current state of the LUN is NOT READY.
//
#define VDS_E_LUN_NOT_READY              ((HRESULT)0x8004281CL)

//
// MessageId: VDS_E_LUN_OFFLINE
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The current state of the LUN is OFFLINE.
//
#define VDS_E_LUN_OFFLINE                ((HRESULT)0x8004281DL)

//
// MessageId: VDS_E_LUN_FAILED
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The current state of the LUN is FAILED.
//
#define VDS_E_LUN_FAILED                 ((HRESULT)0x8004281EL)

//
// MessageId: VDS_E_VOLUME_EXTEND_FVE_LOCKED
//
// MessageText:
//
// The volume could not be extended because it is locked by BitLocker. 
// Unlock the volume and retry the operation.
//
#define VDS_E_VOLUME_EXTEND_FVE_LOCKED   ((HRESULT)0x8004281FL)

//
// MessageId: VDS_E_VOLUME_EXTEND_FVE_CORRUPT
//
// MessageText:
//
// The volume could not be extended because it is locked due to a BitLocker 
// error. Use BitLocker tools to recover the volume and retry the operation.
//
#define VDS_E_VOLUME_EXTEND_FVE_CORRUPT  ((HRESULT)0x80042820L)

//
// MessageId: VDS_E_VOLUME_EXTEND_FVE_RECOVERY
//
// MessageText:
//
// The volume could not be extended because it is marked for BitLocker 
// recovery. Use BitLocker tools to recover the volume and retry the operation.
//
#define VDS_E_VOLUME_EXTEND_FVE_RECOVERY ((HRESULT)0x80042821L)

//
// MessageId: VDS_E_VOLUME_EXTEND_FVE
//
// MessageText:
//
// The volume could not be extended because it is encrypted by BitLocker and 
// Fveapi.dll could not be loaded to determine its status. For this operation to 
// succeed, Fveapi.dll must be available in %SystemRoot%\System32\.
//
#define VDS_E_VOLUME_EXTEND_FVE          ((HRESULT)0x80042822L)

//
// MessageId: VDS_E_SECTOR_SIZE_ERROR
//
// MessageText:
//
// The sector size must be non-zero, a power of 2, and less than the 
// maximum sector size.
//
#define VDS_E_SECTOR_SIZE_ERROR          ((HRESULT)0x80042823L)

//////////////////////////////////////////////////////////////////////////////
//
// Codes added in Win7:     0x2900-0x29FF
//
//////////////////////////////////////////////////////////////////////////////
//
// MessageId: VDS_E_INITIATOR_ADAPTER_NOT_FOUND
//
// MessageText:
//
// The initiator adapter was not found. For calls to GetPathInfo(), the 
// initiator adapater is associated with the path end point.
//
#define VDS_E_INITIATOR_ADAPTER_NOT_FOUND ((HRESULT)0x80042900L)

//
// MessageId: VDS_E_TARGET_PORTAL_NOT_FOUND
//
// MessageText:
//
// The target portal was not found. For calls to GetPathInfo(), the target portal 
// is associated with the path end point.
//
#define VDS_E_TARGET_PORTAL_NOT_FOUND    ((HRESULT)0x80042901L)

//
// MessageId: VDS_E_INVALID_PORT_PATH
//
// MessageText:
//
// The path returned for the port is invalid. Either it has an incorrect port type 
// specified, or, the HBA port properties structure is NULL.
//
#define VDS_E_INVALID_PORT_PATH          ((HRESULT)0x80042902L)

//
// MessageId: VDS_E_INVALID_ISCSI_TARGET_NAME
//
// MessageText:
//
// An invalid iSCSI target name was returned from the provider.
//
#define VDS_E_INVALID_ISCSI_TARGET_NAME  ((HRESULT)0x80042903L)

//
// MessageId: VDS_E_SET_TUNNEL_MODE_OUTER_ADDRESS
//
// MessageText:
//
// Call to set the iSCSI tunnel mode outer address failed.
//
#define VDS_E_SET_TUNNEL_MODE_OUTER_ADDRESS ((HRESULT)0x80042904L)

//
// MessageId: VDS_E_ISCSI_GET_IKE_INFO
//
// MessageText:
//
// Call to get the iSCSI IKE info failed.
//
#define VDS_E_ISCSI_GET_IKE_INFO         ((HRESULT)0x80042905L)

//
// MessageId: VDS_E_ISCSI_SET_IKE_INFO
//
// MessageText:
//
// Call to set the iSCSI IKE info failed.
//
#define VDS_E_ISCSI_SET_IKE_INFO         ((HRESULT)0x80042906L)

//
// MessageId: VDS_E_SUBSYSTEM_ID_IS_NULL
//
// MessageText:
//
// The provider returned a NULL subsystem identification string.
//
#define VDS_E_SUBSYSTEM_ID_IS_NULL       ((HRESULT)0x80042907L)

//
// MessageId: VDS_E_ISCSI_INITIATOR_NODE_NAME
//
// MessageText:
//
// Failed to get the iSCSI initiator node name.
//
#define VDS_E_ISCSI_INITIATOR_NODE_NAME  ((HRESULT)0x80042908L)

//
// MessageId: VDS_E_ISCSI_GROUP_PRESHARE_KEY
//
// MessageText:
//
// Failed to set iSCSI group preshared key.
//
#define VDS_E_ISCSI_GROUP_PRESHARE_KEY   ((HRESULT)0x80042909L)

//
// MessageId: VDS_E_ISCSI_CHAP_SECRET
//
// MessageText:
//
// Failed to set iSCSI initiator CHAP secret.
//
#define VDS_E_ISCSI_CHAP_SECRET          ((HRESULT)0x8004290AL)

//
// MessageId: VDS_E_INVALID_IP_ADDRESS
//
// MessageText:
//
// An invalid IP address was encountered.
//
#define VDS_E_INVALID_IP_ADDRESS         ((HRESULT)0x8004290BL)

//
// MessageId: VDS_E_REBOOT_REQUIRED
//
// MessageText:
//
// A reboot is required before any further operations may be initiated. 
// If you do not reboot, machine behavior and machine state, are undefined 
// for any further operations.
//
#define VDS_E_REBOOT_REQUIRED            ((HRESULT)0x8004290CL)

//
// MessageId: VDS_E_VOLUME_GUID_PATHNAME_NOT_ALLOWED
//
// MessageText:
//
// Volume GUID pathnames are not valid input to this method.
//
#define VDS_E_VOLUME_GUID_PATHNAME_NOT_ALLOWED ((HRESULT)0x8004290DL)

//
// MessageId: VDS_E_BOOT_PAGEFILE_DRIVE_LETTER
//
// MessageText:
//
// Assigning or removing drive letters on the current boot or pagefile 
// volume is not allowed. 
//
#define VDS_E_BOOT_PAGEFILE_DRIVE_LETTER ((HRESULT)0x8004290EL)

//
// MessageId: VDS_E_DELETE_WITH_CRITICAL
//
// MessageText:
//
// Delete is not allowed on the current boot, system, pagefile,
// crashdump or hibernation volume. 
//
#define VDS_E_DELETE_WITH_CRITICAL       ((HRESULT)0x8004290FL)

//
// MessageId: VDS_E_CLEAN_WITH_DATA
//
// MessageText:
//
// The FORCE parameter must be set to TRUE in order to clean a disk
// that contains a data volume. 
//
#define VDS_E_CLEAN_WITH_DATA            ((HRESULT)0x80042910L)

//
// MessageId: VDS_E_CLEAN_WITH_OEM
//
// MessageText:
//
// The FORCE parameter must be set to TRUE in order to clean a disk
// that contains an OEM volume. 
//
#define VDS_E_CLEAN_WITH_OEM             ((HRESULT)0x80042911L)

//
// MessageId: VDS_E_CLEAN_WITH_CRITICAL
//
// MessageText:
//
// Clean is not allowed on the disk containing the current boot,
// system, pagefile, crashdump or hibernation volume. 
//
#define VDS_E_CLEAN_WITH_CRITICAL        ((HRESULT)0x80042912L)

//
// MessageId: VDS_E_FORMAT_CRITICAL
//
// MessageText:
//
// Format is not allowed on the current boot, system, pagefile,
// crashdump or hibernation volume. 
//
#define VDS_E_FORMAT_CRITICAL            ((HRESULT)0x80042913L)

//
// MessageId: VDS_E_NTFS_FORMAT_NOT_SUPPORTED
//
// MessageText:
//
// The NTFS file system format is not supported on this volume. 
//
#define VDS_E_NTFS_FORMAT_NOT_SUPPORTED  ((HRESULT)0x80042914L)

//
// MessageId: VDS_E_FAT32_FORMAT_NOT_SUPPORTED
//
// MessageText:
//
// The FAT32 file system format is not supported on this volume. 
//
#define VDS_E_FAT32_FORMAT_NOT_SUPPORTED ((HRESULT)0x80042915L)

//
// MessageId: VDS_E_FAT_FORMAT_NOT_SUPPORTED
//
// MessageText:
//
// The FAT file system format is not supported on this volume. 
//
#define VDS_E_FAT_FORMAT_NOT_SUPPORTED   ((HRESULT)0x80042916L)

//
// MessageId: VDS_E_FORMAT_NOT_SUPPORTED
//
// MessageText:
//
// The volume is not formattable.
//
#define VDS_E_FORMAT_NOT_SUPPORTED       ((HRESULT)0x80042917L)

//
// MessageId: VDS_E_COMPRESSION_NOT_SUPPORTED
//
// MessageText:
//
// The specified file system does not support compression.
//
#define VDS_E_COMPRESSION_NOT_SUPPORTED  ((HRESULT)0x80042918L)

//
// MessageId: VDS_E_VDISK_NOT_OPEN
//
// MessageText:
//
// The virtual disk object has not been open yet.
//
#define VDS_E_VDISK_NOT_OPEN             ((HRESULT)0x80042919L)

//
// MessageId: VDS_E_VDISK_INVALID_OP_STATE
//
// MessageText:
//
// The requested operation cannot be performed on the virtual disk 
// object, because it is not in a state that permits it.
//
#define VDS_E_VDISK_INVALID_OP_STATE     ((HRESULT)0x8004291AL)

//
// MessageId: VDS_E_INVALID_PATH
//
// MessageText:
//
// The path returned for the LUN is invalid. It has an incorrect path type 
// specified.
//
#define VDS_E_INVALID_PATH               ((HRESULT)0x8004291BL)

//
// MessageId: VDS_E_INVALID_ISCSI_PATH
//
// MessageText:
//
// The path returned for the LUN is invalid. Either it has an incorrect 
// path type specified, or, the initiator portal properties structure 
// is NULL.
//
#define VDS_E_INVALID_ISCSI_PATH         ((HRESULT)0x8004291CL)

//
// MessageId: VDS_E_SHRINK_LUN_NOT_UNMASKED
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The LUN is not unmasked to the local server.
//
#define VDS_E_SHRINK_LUN_NOT_UNMASKED    ((HRESULT)0x8004291DL)

//
// MessageId: VDS_E_LUN_DISK_READ_ONLY
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The current state of the disk associated with the LUN is READ ONLY.
//
#define VDS_E_LUN_DISK_READ_ONLY         ((HRESULT)0x8004291EL)

//
// MessageId: VDS_E_LUN_UPDATE_DISK
//
// MessageText:
//
// The operation against the selected LUN completed, but there was 
// a failure updating the status of the disk associated with the lun. 
// Call REFRESH to retry the status update for the disk.
//
#define VDS_E_LUN_UPDATE_DISK            ((HRESULT)0x8004291FL)

//
// MessageId: VDS_E_LUN_DYNAMIC
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The current state of the disk associated with the LUN is DYNAMIC.
//
#define VDS_E_LUN_DYNAMIC                ((HRESULT)0x80042920L)

//
// MessageId: VDS_E_LUN_DYNAMIC_OFFLINE
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The current state of the disk associated with the LUN is DYNAMIC 
// OFFLINE.
//
#define VDS_E_LUN_DYNAMIC_OFFLINE        ((HRESULT)0x80042921L)

//
// MessageId: VDS_E_LUN_SHRINK_GPT_HEADER
//
// MessageText:
//
// The SHRINK operation against the selected LUN cannot be completed. 
// The disk has the GPT partitioning format. The specified new lun 
// size does not allow space for a new GPT backup header to be created.
// Please increase the resulting lun size.
//
#define VDS_E_LUN_SHRINK_GPT_HEADER      ((HRESULT)0x80042922L)

//
// MessageId: VDS_E_MIRROR_NOT_SUPPORTED
//
// MessageText:
//
// Mirrored volumes are not supported by this operating system.
//
#define VDS_E_MIRROR_NOT_SUPPORTED       ((HRESULT)0x80042923L)

//
// MessageId: VDS_E_RAID5_NOT_SUPPORTED
//
// MessageText:
//
// RAID-5 volumes are not supported by this operating system.
//
#define VDS_E_RAID5_NOT_SUPPORTED        ((HRESULT)0x80042924L)

//
// MessageId: VDS_E_DISK_NOT_CONVERTIBLE_SIZE
//
// MessageText:
//
// The specified disk is not convertible because the size is less than
// the minimum size required for GPT disks.
//
#define VDS_E_DISK_NOT_CONVERTIBLE_SIZE  ((HRESULT)0x80042925L)

//
// MessageId: VDS_E_OFFLINE_NOT_SUPPORTED
//
// MessageText:
//
// The volume does not support offlining.
//
#define VDS_E_OFFLINE_NOT_SUPPORTED      ((HRESULT)0x80042926L)

//
// MessageId: VDS_E_VDISK_PATHNAME_INVALID
//
// MessageText:
//
// The pathname for a virtual disk must be fully qualified.
//
#define VDS_E_VDISK_PATHNAME_INVALID     ((HRESULT)0x80042927L)

//
// MessageId: VDS_E_EXTEND_TOO_MANY_CLUSTERS
//
// MessageText:
//
// The volume cannot be extended because the number of clusters will
// exceed the maximum number of clusters supported by the file system.
//
#define VDS_E_EXTEND_TOO_MANY_CLUSTERS   ((HRESULT)0x80042928L)

//
// MessageId: VDS_E_EXTEND_UNKNOWN_FILESYSTEM
//
// MessageText:
//
// The volume cannot be extended because the volume does not contain
// a recognized file system.
//
#define VDS_E_EXTEND_UNKNOWN_FILESYSTEM  ((HRESULT)0x80042929L)

//
// MessageId: VDS_E_SHRINK_UNKNOWN_FILESYSTEM
//
// MessageText:
//
// The volume cannot be shrunk because the volume does not contain
// a recognized file system.
//
#define VDS_E_SHRINK_UNKNOWN_FILESYSTEM  ((HRESULT)0x8004292AL)

//
// MessageId: VDS_E_VD_DISK_NOT_OPEN
//
// MessageText:
//
// The requested operation requires that the virtual disk be opened.
//
#define VDS_E_VD_DISK_NOT_OPEN           ((HRESULT)0x8004292BL)

//
// MessageId: VDS_E_VD_DISK_IS_EXPANDING
//
// MessageText:
//
// The requested operation cannot be performed while the virtual disk
// is expanding.
//
#define VDS_E_VD_DISK_IS_EXPANDING       ((HRESULT)0x8004292CL)

//
// MessageId: VDS_E_VD_DISK_IS_COMPACTING
//
// MessageText:
//
// The requested operation cannot be performed while the virtual disk
// is compacting.
//
#define VDS_E_VD_DISK_IS_COMPACTING      ((HRESULT)0x8004292DL)

//
// MessageId: VDS_E_VD_DISK_IS_MERGING
//
// MessageText:
//
// The requested operation cannot be performed while the virtual disk
// is merging.
//
#define VDS_E_VD_DISK_IS_MERGING         ((HRESULT)0x8004292EL)

//
// MessageId: VDS_E_VD_IS_ATTACHED
//
// MessageText:
//
// The requested operation cannot be performed while the virtual disk
// is attached.
//
#define VDS_E_VD_IS_ATTACHED             ((HRESULT)0x8004292FL)

//
// MessageId: VDS_E_VD_DISK_ALREADY_OPEN
//
// MessageText:
//
// The virtual disk is already open and cannot be opened
// a second time. Please close all clients that may have opened
// the virtual disk and retry.
//
#define VDS_E_VD_DISK_ALREADY_OPEN       ((HRESULT)0x80042930L)

//
// MessageId: VDS_E_VD_DISK_ALREADY_EXPANDING
//
// MessageText:
//
// The virtual disk is already in the process of expanding.
//
#define VDS_E_VD_DISK_ALREADY_EXPANDING  ((HRESULT)0x80042931L)

//
// MessageId: VDS_E_VD_ALREADY_COMPACTING
//
// MessageText:
//
// The virtual disk is already in the process of compacting.
//
#define VDS_E_VD_ALREADY_COMPACTING      ((HRESULT)0x80042932L)

//
// MessageId: VDS_E_VD_ALREADY_MERGING
//
// MessageText:
//
// The virtual disk is already in the process of merging.
//
#define VDS_E_VD_ALREADY_MERGING         ((HRESULT)0x80042933L)

//
// MessageId: VDS_E_VD_ALREADY_ATTACHED
//
// MessageText:
//
// The virtual disk is already attached.
//
#define VDS_E_VD_ALREADY_ATTACHED        ((HRESULT)0x80042934L)

//
// MessageId: VDS_E_VD_ALREADY_DETACHED
//
// MessageText:
//
// The virtual disk is already detached.
//
#define VDS_E_VD_ALREADY_DETACHED        ((HRESULT)0x80042935L)

//
// MessageId: VDS_E_VD_NOT_ATTACHED_READONLY
//
// MessageText:
//
// The requested operation requires that the virtual disk be
// attached read only.
//
#define VDS_E_VD_NOT_ATTACHED_READONLY   ((HRESULT)0x80042936L)

//
// MessageId: VDS_E_VD_IS_BEING_ATTACHED
//
// MessageText:
//
// The requested operation cannot be performed while the virtual disk
// is being attached.
//
#define VDS_E_VD_IS_BEING_ATTACHED       ((HRESULT)0x80042937L)

//
// MessageId: VDS_E_VD_IS_BEING_DETACHED
//
// MessageText:
//
// The requested operation cannot be performed while the virtual disk
// is being detached.
//
#define VDS_E_VD_IS_BEING_DETACHED       ((HRESULT)0x80042938L)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vds.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vds.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vds_h__
#define __vds_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumVdsObject_FWD_DEFINED__
#define __IEnumVdsObject_FWD_DEFINED__
typedef interface IEnumVdsObject IEnumVdsObject;
#endif 	/* __IEnumVdsObject_FWD_DEFINED__ */


#ifndef __IVdsAsync_FWD_DEFINED__
#define __IVdsAsync_FWD_DEFINED__
typedef interface IVdsAsync IVdsAsync;
#endif 	/* __IVdsAsync_FWD_DEFINED__ */


#ifndef __IVdsAdviseSink_FWD_DEFINED__
#define __IVdsAdviseSink_FWD_DEFINED__
typedef interface IVdsAdviseSink IVdsAdviseSink;
#endif 	/* __IVdsAdviseSink_FWD_DEFINED__ */


#ifndef __IVdsProvider_FWD_DEFINED__
#define __IVdsProvider_FWD_DEFINED__
typedef interface IVdsProvider IVdsProvider;
#endif 	/* __IVdsProvider_FWD_DEFINED__ */


#ifndef __IVdsProviderSupport_FWD_DEFINED__
#define __IVdsProviderSupport_FWD_DEFINED__
typedef interface IVdsProviderSupport IVdsProviderSupport;
#endif 	/* __IVdsProviderSupport_FWD_DEFINED__ */


#ifndef __IVdsSwProvider_FWD_DEFINED__
#define __IVdsSwProvider_FWD_DEFINED__
typedef interface IVdsSwProvider IVdsSwProvider;
#endif 	/* __IVdsSwProvider_FWD_DEFINED__ */


#ifndef __IVdsPack_FWD_DEFINED__
#define __IVdsPack_FWD_DEFINED__
typedef interface IVdsPack IVdsPack;
#endif 	/* __IVdsPack_FWD_DEFINED__ */


#ifndef __IVdsPack2_FWD_DEFINED__
#define __IVdsPack2_FWD_DEFINED__
typedef interface IVdsPack2 IVdsPack2;
#endif 	/* __IVdsPack2_FWD_DEFINED__ */


#ifndef __IVdsDisk_FWD_DEFINED__
#define __IVdsDisk_FWD_DEFINED__
typedef interface IVdsDisk IVdsDisk;
#endif 	/* __IVdsDisk_FWD_DEFINED__ */


#ifndef __IVdsDisk2_FWD_DEFINED__
#define __IVdsDisk2_FWD_DEFINED__
typedef interface IVdsDisk2 IVdsDisk2;
#endif 	/* __IVdsDisk2_FWD_DEFINED__ */


#ifndef __IVdsDiskOnline_FWD_DEFINED__
#define __IVdsDiskOnline_FWD_DEFINED__
typedef interface IVdsDiskOnline IVdsDiskOnline;
#endif 	/* __IVdsDiskOnline_FWD_DEFINED__ */


#ifndef __IVdsAdvancedDisk_FWD_DEFINED__
#define __IVdsAdvancedDisk_FWD_DEFINED__
typedef interface IVdsAdvancedDisk IVdsAdvancedDisk;
#endif 	/* __IVdsAdvancedDisk_FWD_DEFINED__ */


#ifndef __IVdsAdvancedDisk2_FWD_DEFINED__
#define __IVdsAdvancedDisk2_FWD_DEFINED__
typedef interface IVdsAdvancedDisk2 IVdsAdvancedDisk2;
#endif 	/* __IVdsAdvancedDisk2_FWD_DEFINED__ */


#ifndef __IVdsCreatePartitionEx_FWD_DEFINED__
#define __IVdsCreatePartitionEx_FWD_DEFINED__
typedef interface IVdsCreatePartitionEx IVdsCreatePartitionEx;
#endif 	/* __IVdsCreatePartitionEx_FWD_DEFINED__ */


#ifndef __IVdsRemovable_FWD_DEFINED__
#define __IVdsRemovable_FWD_DEFINED__
typedef interface IVdsRemovable IVdsRemovable;
#endif 	/* __IVdsRemovable_FWD_DEFINED__ */


#ifndef __IVdsVolume_FWD_DEFINED__
#define __IVdsVolume_FWD_DEFINED__
typedef interface IVdsVolume IVdsVolume;
#endif 	/* __IVdsVolume_FWD_DEFINED__ */


#ifndef __IVdsVolume2_FWD_DEFINED__
#define __IVdsVolume2_FWD_DEFINED__
typedef interface IVdsVolume2 IVdsVolume2;
#endif 	/* __IVdsVolume2_FWD_DEFINED__ */


#ifndef __IVdsVolumeOnline_FWD_DEFINED__
#define __IVdsVolumeOnline_FWD_DEFINED__
typedef interface IVdsVolumeOnline IVdsVolumeOnline;
#endif 	/* __IVdsVolumeOnline_FWD_DEFINED__ */


#ifndef __IVdsVolumePlex_FWD_DEFINED__
#define __IVdsVolumePlex_FWD_DEFINED__
typedef interface IVdsVolumePlex IVdsVolumePlex;
#endif 	/* __IVdsVolumePlex_FWD_DEFINED__ */


#ifndef __IVdsDisk3_FWD_DEFINED__
#define __IVdsDisk3_FWD_DEFINED__
typedef interface IVdsDisk3 IVdsDisk3;
#endif 	/* __IVdsDisk3_FWD_DEFINED__ */


#ifndef __IVdsHwProvider_FWD_DEFINED__
#define __IVdsHwProvider_FWD_DEFINED__
typedef interface IVdsHwProvider IVdsHwProvider;
#endif 	/* __IVdsHwProvider_FWD_DEFINED__ */


#ifndef __IVdsHwProviderType_FWD_DEFINED__
#define __IVdsHwProviderType_FWD_DEFINED__
typedef interface IVdsHwProviderType IVdsHwProviderType;
#endif 	/* __IVdsHwProviderType_FWD_DEFINED__ */


#ifndef __IVdsHwProviderType2_FWD_DEFINED__
#define __IVdsHwProviderType2_FWD_DEFINED__
typedef interface IVdsHwProviderType2 IVdsHwProviderType2;
#endif 	/* __IVdsHwProviderType2_FWD_DEFINED__ */


#ifndef __IVdsHwProviderStoragePools_FWD_DEFINED__
#define __IVdsHwProviderStoragePools_FWD_DEFINED__
typedef interface IVdsHwProviderStoragePools IVdsHwProviderStoragePools;
#endif 	/* __IVdsHwProviderStoragePools_FWD_DEFINED__ */


#ifndef __IVdsSubSystem_FWD_DEFINED__
#define __IVdsSubSystem_FWD_DEFINED__
typedef interface IVdsSubSystem IVdsSubSystem;
#endif 	/* __IVdsSubSystem_FWD_DEFINED__ */


#ifndef __IVdsSubSystem2_FWD_DEFINED__
#define __IVdsSubSystem2_FWD_DEFINED__
typedef interface IVdsSubSystem2 IVdsSubSystem2;
#endif 	/* __IVdsSubSystem2_FWD_DEFINED__ */


#ifndef __IVdsSubSystemNaming_FWD_DEFINED__
#define __IVdsSubSystemNaming_FWD_DEFINED__
typedef interface IVdsSubSystemNaming IVdsSubSystemNaming;
#endif 	/* __IVdsSubSystemNaming_FWD_DEFINED__ */


#ifndef __IVdsSubSystemIscsi_FWD_DEFINED__
#define __IVdsSubSystemIscsi_FWD_DEFINED__
typedef interface IVdsSubSystemIscsi IVdsSubSystemIscsi;
#endif 	/* __IVdsSubSystemIscsi_FWD_DEFINED__ */


#ifndef __IVdsSubSystemInterconnect_FWD_DEFINED__
#define __IVdsSubSystemInterconnect_FWD_DEFINED__
typedef interface IVdsSubSystemInterconnect IVdsSubSystemInterconnect;
#endif 	/* __IVdsSubSystemInterconnect_FWD_DEFINED__ */


#ifndef __IVdsControllerPort_FWD_DEFINED__
#define __IVdsControllerPort_FWD_DEFINED__
typedef interface IVdsControllerPort IVdsControllerPort;
#endif 	/* __IVdsControllerPort_FWD_DEFINED__ */


#ifndef __IVdsController_FWD_DEFINED__
#define __IVdsController_FWD_DEFINED__
typedef interface IVdsController IVdsController;
#endif 	/* __IVdsController_FWD_DEFINED__ */


#ifndef __IVdsControllerControllerPort_FWD_DEFINED__
#define __IVdsControllerControllerPort_FWD_DEFINED__
typedef interface IVdsControllerControllerPort IVdsControllerControllerPort;
#endif 	/* __IVdsControllerControllerPort_FWD_DEFINED__ */


#ifndef __IVdsDrive_FWD_DEFINED__
#define __IVdsDrive_FWD_DEFINED__
typedef interface IVdsDrive IVdsDrive;
#endif 	/* __IVdsDrive_FWD_DEFINED__ */


#ifndef __IVdsDrive2_FWD_DEFINED__
#define __IVdsDrive2_FWD_DEFINED__
typedef interface IVdsDrive2 IVdsDrive2;
#endif 	/* __IVdsDrive2_FWD_DEFINED__ */


#ifndef __IVdsLun_FWD_DEFINED__
#define __IVdsLun_FWD_DEFINED__
typedef interface IVdsLun IVdsLun;
#endif 	/* __IVdsLun_FWD_DEFINED__ */


#ifndef __IVdsLun2_FWD_DEFINED__
#define __IVdsLun2_FWD_DEFINED__
typedef interface IVdsLun2 IVdsLun2;
#endif 	/* __IVdsLun2_FWD_DEFINED__ */


#ifndef __IVdsLunNaming_FWD_DEFINED__
#define __IVdsLunNaming_FWD_DEFINED__
typedef interface IVdsLunNaming IVdsLunNaming;
#endif 	/* __IVdsLunNaming_FWD_DEFINED__ */


#ifndef __IVdsLunNumber_FWD_DEFINED__
#define __IVdsLunNumber_FWD_DEFINED__
typedef interface IVdsLunNumber IVdsLunNumber;
#endif 	/* __IVdsLunNumber_FWD_DEFINED__ */


#ifndef __IVdsLunControllerPorts_FWD_DEFINED__
#define __IVdsLunControllerPorts_FWD_DEFINED__
typedef interface IVdsLunControllerPorts IVdsLunControllerPorts;
#endif 	/* __IVdsLunControllerPorts_FWD_DEFINED__ */


#ifndef __IVdsLunMpio_FWD_DEFINED__
#define __IVdsLunMpio_FWD_DEFINED__
typedef interface IVdsLunMpio IVdsLunMpio;
#endif 	/* __IVdsLunMpio_FWD_DEFINED__ */


#ifndef __IVdsLunIscsi_FWD_DEFINED__
#define __IVdsLunIscsi_FWD_DEFINED__
typedef interface IVdsLunIscsi IVdsLunIscsi;
#endif 	/* __IVdsLunIscsi_FWD_DEFINED__ */


#ifndef __IVdsLunPlex_FWD_DEFINED__
#define __IVdsLunPlex_FWD_DEFINED__
typedef interface IVdsLunPlex IVdsLunPlex;
#endif 	/* __IVdsLunPlex_FWD_DEFINED__ */


#ifndef __IVdsIscsiPortal_FWD_DEFINED__
#define __IVdsIscsiPortal_FWD_DEFINED__
typedef interface IVdsIscsiPortal IVdsIscsiPortal;
#endif 	/* __IVdsIscsiPortal_FWD_DEFINED__ */


#ifndef __IVdsIscsiTarget_FWD_DEFINED__
#define __IVdsIscsiTarget_FWD_DEFINED__
typedef interface IVdsIscsiTarget IVdsIscsiTarget;
#endif 	/* __IVdsIscsiTarget_FWD_DEFINED__ */


#ifndef __IVdsIscsiPortalGroup_FWD_DEFINED__
#define __IVdsIscsiPortalGroup_FWD_DEFINED__
typedef interface IVdsIscsiPortalGroup IVdsIscsiPortalGroup;
#endif 	/* __IVdsIscsiPortalGroup_FWD_DEFINED__ */


#ifndef __IVdsStoragePool_FWD_DEFINED__
#define __IVdsStoragePool_FWD_DEFINED__
typedef interface IVdsStoragePool IVdsStoragePool;
#endif 	/* __IVdsStoragePool_FWD_DEFINED__ */


#ifndef __IVdsMaintenance_FWD_DEFINED__
#define __IVdsMaintenance_FWD_DEFINED__
typedef interface IVdsMaintenance IVdsMaintenance;
#endif 	/* __IVdsMaintenance_FWD_DEFINED__ */


#ifndef __IVdsVdProvider_FWD_DEFINED__
#define __IVdsVdProvider_FWD_DEFINED__
typedef interface IVdsVdProvider IVdsVdProvider;
#endif 	/* __IVdsVdProvider_FWD_DEFINED__ */


#ifndef __IVdsVDisk_FWD_DEFINED__
#define __IVdsVDisk_FWD_DEFINED__
typedef interface IVdsVDisk IVdsVDisk;
#endif 	/* __IVdsVDisk_FWD_DEFINED__ */


#ifndef __IVdsOpenVDisk_FWD_DEFINED__
#define __IVdsOpenVDisk_FWD_DEFINED__
typedef interface IVdsOpenVDisk IVdsOpenVDisk;
#endif 	/* __IVdsOpenVDisk_FWD_DEFINED__ */


#ifndef __IVdsServiceLoader_FWD_DEFINED__
#define __IVdsServiceLoader_FWD_DEFINED__
typedef interface IVdsServiceLoader IVdsServiceLoader;
#endif 	/* __IVdsServiceLoader_FWD_DEFINED__ */


#ifndef __IVdsService_FWD_DEFINED__
#define __IVdsService_FWD_DEFINED__
typedef interface IVdsService IVdsService;
#endif 	/* __IVdsService_FWD_DEFINED__ */


#ifndef __IVdsServiceUninstallDisk_FWD_DEFINED__
#define __IVdsServiceUninstallDisk_FWD_DEFINED__
typedef interface IVdsServiceUninstallDisk IVdsServiceUninstallDisk;
#endif 	/* __IVdsServiceUninstallDisk_FWD_DEFINED__ */


#ifndef __IVdsServiceHba_FWD_DEFINED__
#define __IVdsServiceHba_FWD_DEFINED__
typedef interface IVdsServiceHba IVdsServiceHba;
#endif 	/* __IVdsServiceHba_FWD_DEFINED__ */


#ifndef __IVdsServiceIscsi_FWD_DEFINED__
#define __IVdsServiceIscsi_FWD_DEFINED__
typedef interface IVdsServiceIscsi IVdsServiceIscsi;
#endif 	/* __IVdsServiceIscsi_FWD_DEFINED__ */


#ifndef __IVdsServiceInitialization_FWD_DEFINED__
#define __IVdsServiceInitialization_FWD_DEFINED__
typedef interface IVdsServiceInitialization IVdsServiceInitialization;
#endif 	/* __IVdsServiceInitialization_FWD_DEFINED__ */


#ifndef __IVdsHbaPort_FWD_DEFINED__
#define __IVdsHbaPort_FWD_DEFINED__
typedef interface IVdsHbaPort IVdsHbaPort;
#endif 	/* __IVdsHbaPort_FWD_DEFINED__ */


#ifndef __IVdsIscsiInitiatorAdapter_FWD_DEFINED__
#define __IVdsIscsiInitiatorAdapter_FWD_DEFINED__
typedef interface IVdsIscsiInitiatorAdapter IVdsIscsiInitiatorAdapter;
#endif 	/* __IVdsIscsiInitiatorAdapter_FWD_DEFINED__ */


#ifndef __IVdsIscsiInitiatorPortal_FWD_DEFINED__
#define __IVdsIscsiInitiatorPortal_FWD_DEFINED__
typedef interface IVdsIscsiInitiatorPortal IVdsIscsiInitiatorPortal;
#endif 	/* __IVdsIscsiInitiatorPortal_FWD_DEFINED__ */


#ifndef __IVdsDiskPartitionMF_FWD_DEFINED__
#define __IVdsDiskPartitionMF_FWD_DEFINED__
typedef interface IVdsDiskPartitionMF IVdsDiskPartitionMF;
#endif 	/* __IVdsDiskPartitionMF_FWD_DEFINED__ */


#ifndef __IVdsVolumeMF_FWD_DEFINED__
#define __IVdsVolumeMF_FWD_DEFINED__
typedef interface IVdsVolumeMF IVdsVolumeMF;
#endif 	/* __IVdsVolumeMF_FWD_DEFINED__ */


#ifndef __IVdsVolumeMF2_FWD_DEFINED__
#define __IVdsVolumeMF2_FWD_DEFINED__
typedef interface IVdsVolumeMF2 IVdsVolumeMF2;
#endif 	/* __IVdsVolumeMF2_FWD_DEFINED__ */


#ifndef __IVdsVolumeShrink_FWD_DEFINED__
#define __IVdsVolumeShrink_FWD_DEFINED__
typedef interface IVdsVolumeShrink IVdsVolumeShrink;
#endif 	/* __IVdsVolumeShrink_FWD_DEFINED__ */


#ifndef __IVdsSubSystemImportTarget_FWD_DEFINED__
#define __IVdsSubSystemImportTarget_FWD_DEFINED__
typedef interface IVdsSubSystemImportTarget IVdsSubSystemImportTarget;
#endif 	/* __IVdsSubSystemImportTarget_FWD_DEFINED__ */


#ifndef __IVdsIscsiPortalLocal_FWD_DEFINED__
#define __IVdsIscsiPortalLocal_FWD_DEFINED__
typedef interface IVdsIscsiPortalLocal IVdsIscsiPortalLocal;
#endif 	/* __IVdsIscsiPortalLocal_FWD_DEFINED__ */


#ifndef __IVdsServiceSAN_FWD_DEFINED__
#define __IVdsServiceSAN_FWD_DEFINED__
typedef interface IVdsServiceSAN IVdsServiceSAN;
#endif 	/* __IVdsServiceSAN_FWD_DEFINED__ */


#ifndef __IVdsVolumeMF3_FWD_DEFINED__
#define __IVdsVolumeMF3_FWD_DEFINED__
typedef interface IVdsVolumeMF3 IVdsVolumeMF3;
#endif 	/* __IVdsVolumeMF3_FWD_DEFINED__ */


#ifndef __IVdsDiskPartitionMF2_FWD_DEFINED__
#define __IVdsDiskPartitionMF2_FWD_DEFINED__
typedef interface IVdsDiskPartitionMF2 IVdsDiskPartitionMF2;
#endif 	/* __IVdsDiskPartitionMF2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "vdssys.h"
#include "vdserr.h"
#include "vdslun.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vds_0000_0000 */
/* [local] */ 

//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) 2008 Microsoft Corporation.
//
//---------------------------------------------------------------





typedef GUID VDS_OBJECT_ID;

typedef 
enum _VDS_OBJECT_TYPE
    {	VDS_OT_UNKNOWN	= 0,
	VDS_OT_PROVIDER	= 1,
	VDS_OT_PACK	= 10,
	VDS_OT_VOLUME	= 11,
	VDS_OT_VOLUME_PLEX	= 12,
	VDS_OT_DISK	= 13,
	VDS_OT_SUB_SYSTEM	= 30,
	VDS_OT_CONTROLLER	= 31,
	VDS_OT_DRIVE	= 32,
	VDS_OT_LUN	= 33,
	VDS_OT_LUN_PLEX	= 34,
	VDS_OT_PORT	= 35,
	VDS_OT_PORTAL	= 36,
	VDS_OT_TARGET	= 37,
	VDS_OT_PORTAL_GROUP	= 38,
	VDS_OT_STORAGE_POOL	= 39,
	VDS_OT_HBAPORT	= 90,
	VDS_OT_INIT_ADAPTER	= 91,
	VDS_OT_INIT_PORTAL	= 92,
	VDS_OT_ASYNC	= 100,
	VDS_OT_ENUM	= 101,
	VDS_OT_VDISK	= 200,
	VDS_OT_OPEN_VDISK	= 201
    } 	VDS_OBJECT_TYPE;

typedef 
enum _VDS_PROVIDER_TYPE
    {	VDS_PT_UNKNOWN	= 0,
	VDS_PT_SOFTWARE	= 1,
	VDS_PT_HARDWARE	= 2,
	VDS_PT_VIRTUALDISK	= 3,
	VDS_PT_MAX	= 4
    } 	VDS_PROVIDER_TYPE;

typedef 
enum _VDS_PROVIDER_FLAG
    {	VDS_PF_DYNAMIC	= 0x1,
	VDS_PF_INTERNAL_HARDWARE_PROVIDER	= 0x2,
	VDS_PF_ONE_DISK_ONLY_PER_PACK	= 0x4,
	VDS_PF_ONE_PACK_ONLINE_ONLY	= 0x8,
	VDS_PF_VOLUME_SPACE_MUST_BE_CONTIGUOUS	= 0x10,
	VDS_PF_SUPPORT_DYNAMIC	= 0x80000000,
	VDS_PF_SUPPORT_FAULT_TOLERANT	= 0x40000000,
	VDS_PF_SUPPORT_DYNAMIC_1394	= 0x20000000,
	VDS_PF_SUPPORT_MIRROR	= 0x20,
	VDS_PF_SUPPORT_RAID5	= 0x40
    } 	VDS_PROVIDER_FLAG;

typedef 
enum _VDS_RECOVER_ACTION
    {	VDS_RA_UNKNOWN	= 0,
	VDS_RA_REFRESH	= 1,
	VDS_RA_RESTART	= 2
    } 	VDS_RECOVER_ACTION;

typedef 
enum _VDS_NOTIFICATION_TARGET_TYPE
    {	VDS_NTT_UNKNOWN	= 0,
	VDS_NTT_PACK	= VDS_OT_PACK,
	VDS_NTT_VOLUME	= VDS_OT_VOLUME,
	VDS_NTT_DISK	= VDS_OT_DISK,
	VDS_NTT_PARTITION	= 60,
	VDS_NTT_DRIVE_LETTER	= 61,
	VDS_NTT_FILE_SYSTEM	= 62,
	VDS_NTT_MOUNT_POINT	= 63,
	VDS_NTT_SUB_SYSTEM	= VDS_OT_SUB_SYSTEM,
	VDS_NTT_CONTROLLER	= VDS_OT_CONTROLLER,
	VDS_NTT_DRIVE	= VDS_OT_DRIVE,
	VDS_NTT_LUN	= VDS_OT_LUN,
	VDS_NTT_PORT	= VDS_OT_PORT,
	VDS_NTT_PORTAL	= VDS_OT_PORTAL,
	VDS_NTT_TARGET	= VDS_OT_TARGET,
	VDS_NTT_PORTAL_GROUP	= VDS_OT_PORTAL_GROUP,
	VDS_NTT_SERVICE	= 200
    } 	VDS_NOTIFICATION_TARGET_TYPE;

#define	VDS_NF_PACK_ARRIVE	( 1 )

#define	VDS_NF_PACK_DEPART	( 2 )

#define	VDS_NF_PACK_MODIFY	( 3 )

#define	VDS_NF_VOLUME_ARRIVE	( 4 )

#define	VDS_NF_VOLUME_DEPART	( 5 )

#define	VDS_NF_VOLUME_MODIFY	( 6 )

#define	VDS_NF_VOLUME_REBUILDING_PROGRESS	( 7 )

#define	VDS_NF_DISK_ARRIVE	( 8 )

#define	VDS_NF_DISK_DEPART	( 9 )

#define	VDS_NF_DISK_MODIFY	( 10 )

#define	VDS_NF_PARTITION_ARRIVE	( 11 )

#define	VDS_NF_PARTITION_DEPART	( 12 )

#define	VDS_NF_PARTITION_MODIFY	( 13 )

#define	VDS_NF_SUB_SYSTEM_ARRIVE	( 101 )

#define	VDS_NF_SUB_SYSTEM_DEPART	( 102 )

#define	VDS_NF_CONTROLLER_ARRIVE	( 103 )

#define	VDS_NF_CONTROLLER_DEPART	( 104 )

#define	VDS_NF_DRIVE_ARRIVE	( 105 )

#define	VDS_NF_DRIVE_DEPART	( 106 )

#define	VDS_NF_DRIVE_MODIFY	( 107 )

#define	VDS_NF_LUN_ARRIVE	( 108 )

#define	VDS_NF_LUN_DEPART	( 109 )

#define	VDS_NF_LUN_MODIFY	( 110 )

#define	VDS_NF_PORT_ARRIVE	( 121 )

#define	VDS_NF_PORT_DEPART	( 122 )

#define	VDS_NF_PORTAL_ARRIVE	( 123 )

#define	VDS_NF_PORTAL_DEPART	( 124 )

#define	VDS_NF_PORTAL_MODIFY	( 125 )

#define	VDS_NF_TARGET_ARRIVE	( 126 )

#define	VDS_NF_TARGET_DEPART	( 127 )

#define	VDS_NF_TARGET_MODIFY	( 128 )

#define	VDS_NF_PORTAL_GROUP_ARRIVE	( 129 )

#define	VDS_NF_PORTAL_GROUP_DEPART	( 130 )

#define	VDS_NF_PORTAL_GROUP_MODIFY	( 131 )

#define	VDS_NF_SUB_SYSTEM_MODIFY	( 151 )

#define	VDS_NF_DRIVE_LETTER_FREE	( 201 )

#define	VDS_NF_DRIVE_LETTER_ASSIGN	( 202 )

#define	VDS_NF_FILE_SYSTEM_MODIFY	( 203 )

#define	VDS_NF_FILE_SYSTEM_FORMAT_PROGRESS	( 204 )

#define	VDS_NF_MOUNT_POINTS_CHANGE	( 205 )

#define	VDS_NF_FILE_SYSTEM_SHRINKING_PROGRESS	( 206 )

#define	VDS_NF_SERVICE_OUT_OF_SYNC	( 301 )

#define	VDS_NF_CONTROLLER_MODIFY	( 350 )

#define	VDS_NF_CONTROLLER_REMOVED	( 351 )

#define	VDS_NF_PORT_MODIFY	( 352 )

#define	VDS_NF_PORT_REMOVED	( 353 )

#define	VDS_NF_DRIVE_REMOVED	( 354 )

typedef struct _VDS_PACK_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID packId;
    } 	VDS_PACK_NOTIFICATION;

typedef struct _VDS_DISK_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID diskId;
    } 	VDS_DISK_NOTIFICATION;

typedef struct _VDS_VOLUME_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID volumeId;
    VDS_OBJECT_ID plexId;
    ULONG ulPercentCompleted;
    } 	VDS_VOLUME_NOTIFICATION;

typedef struct _VDS_PARTITION_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID diskId;
    ULONGLONG ullOffset;
    } 	VDS_PARTITION_NOTIFICATION;

typedef struct _VDS_SERVICE_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_RECOVER_ACTION action;
    } 	VDS_SERVICE_NOTIFICATION;

typedef struct _VDS_DRIVE_LETTER_NOTIFICATION
    {
    ULONG ulEvent;
    WCHAR wcLetter;
    VDS_OBJECT_ID volumeId;
    } 	VDS_DRIVE_LETTER_NOTIFICATION;

typedef struct _VDS_FILE_SYSTEM_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID volumeId;
    DWORD dwPercentCompleted;
    } 	VDS_FILE_SYSTEM_NOTIFICATION;

typedef struct _VDS_MOUNT_POINT_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID volumeId;
    } 	VDS_MOUNT_POINT_NOTIFICATION;

typedef struct _VDS_SUB_SYSTEM_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID subSystemId;
    } 	VDS_SUB_SYSTEM_NOTIFICATION;

typedef struct _VDS_CONTROLLER_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID controllerId;
    } 	VDS_CONTROLLER_NOTIFICATION;

typedef struct _VDS_DRIVE_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID driveId;
    } 	VDS_DRIVE_NOTIFICATION;

typedef struct _VDS_LUN_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID LunId;
    } 	VDS_LUN_NOTIFICATION;

typedef struct _VDS_PORT_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID portId;
    } 	VDS_PORT_NOTIFICATION;

typedef struct _VDS_PORTAL_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID portalId;
    } 	VDS_PORTAL_NOTIFICATION;

typedef struct _VDS_TARGET_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID targetId;
    } 	VDS_TARGET_NOTIFICATION;

typedef struct _VDS_PORTAL_GROUP_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID portalGroupId;
    } 	VDS_PORTAL_GROUP_NOTIFICATION;

typedef struct _VDS_NOTIFICATION
    {
    VDS_NOTIFICATION_TARGET_TYPE objectType;
    /* [switch_type] */ union 
        {
        VDS_PACK_NOTIFICATION Pack;
        VDS_DISK_NOTIFICATION Disk;
        VDS_VOLUME_NOTIFICATION Volume;
        VDS_PARTITION_NOTIFICATION Partition;
        VDS_DRIVE_LETTER_NOTIFICATION Letter;
        VDS_FILE_SYSTEM_NOTIFICATION FileSystem;
        VDS_MOUNT_POINT_NOTIFICATION MountPoint;
        VDS_SUB_SYSTEM_NOTIFICATION SubSystem;
        VDS_CONTROLLER_NOTIFICATION Controller;
        VDS_DRIVE_NOTIFICATION Drive;
        VDS_LUN_NOTIFICATION Lun;
        VDS_PORT_NOTIFICATION Port;
        VDS_PORTAL_NOTIFICATION Portal;
        VDS_TARGET_NOTIFICATION Target;
        VDS_PORTAL_GROUP_NOTIFICATION PortalGroup;
        VDS_SERVICE_NOTIFICATION Service;
         /* Empty union arm */ 
        } 	;
    } 	VDS_NOTIFICATION;

typedef 
enum _VDS_ASYNC_OUTPUT_TYPE
    {	VDS_ASYNCOUT_UNKNOWN	= 0,
	VDS_ASYNCOUT_CREATEVOLUME	= 1,
	VDS_ASYNCOUT_EXTENDVOLUME	= 2,
	VDS_ASYNCOUT_SHRINKVOLUME	= 3,
	VDS_ASYNCOUT_ADDVOLUMEPLEX	= 4,
	VDS_ASYNCOUT_BREAKVOLUMEPLEX	= 5,
	VDS_ASYNCOUT_REMOVEVOLUMEPLEX	= 6,
	VDS_ASYNCOUT_REPAIRVOLUMEPLEX	= 7,
	VDS_ASYNCOUT_RECOVERPACK	= 8,
	VDS_ASYNCOUT_REPLACEDISK	= 9,
	VDS_ASYNCOUT_CREATEPARTITION	= 10,
	VDS_ASYNCOUT_CLEAN	= 11,
	VDS_ASYNCOUT_CREATELUN	= 50,
	VDS_ASYNCOUT_ADDLUNPLEX	= 52,
	VDS_ASYNCOUT_REMOVELUNPLEX	= 53,
	VDS_ASYNCOUT_EXTENDLUN	= 54,
	VDS_ASYNCOUT_SHRINKLUN	= 55,
	VDS_ASYNCOUT_RECOVERLUN	= 56,
	VDS_ASYNCOUT_LOGINTOTARGET	= 60,
	VDS_ASYNCOUT_LOGOUTFROMTARGET	= 61,
	VDS_ASYNCOUT_CREATETARGET	= 62,
	VDS_ASYNCOUT_CREATEPORTALGROUP	= 63,
	VDS_ASYNCOUT_DELETETARGET	= 64,
	VDS_ASYNCOUT_ADDPORTAL	= 65,
	VDS_ASYNCOUT_REMOVEPORTAL	= 66,
	VDS_ASYNCOUT_DELETEPORTALGROUP	= 67,
	VDS_ASYNCOUT_FORMAT	= 101,
	VDS_ASYNCOUT_CREATE_VDISK	= 200,
	VDS_ASYNCOUT_ATTACH_VDISK	= 201,
	VDS_ASYNCOUT_COMPACT_VDISK	= 202,
	VDS_ASYNCOUT_MERGE_VDISK	= 203,
	VDS_ASYNCOUT_EXPAND_VDISK	= 204
    } 	VDS_ASYNC_OUTPUT_TYPE;

typedef struct _VDS_ASYNC_OUTPUT
    {
    VDS_ASYNC_OUTPUT_TYPE type;
    /* [switch_type] */ union 
        {
        struct _cp
            {
            ULONGLONG ullOffset;
            VDS_OBJECT_ID volumeId;
            } 	cp;
        struct _cv
            {
            IUnknown *pVolumeUnk;
            } 	cv;
        struct _bvp
            {
            IUnknown *pVolumeUnk;
            } 	bvp;
        struct _sv
            {
            ULONGLONG ullReclaimedBytes;
            } 	sv;
        struct _cl
            {
            IUnknown *pLunUnk;
            } 	cl;
        struct _ct
            {
            IUnknown *pTargetUnk;
            } 	ct;
        struct _cpg
            {
            IUnknown *pPortalGroupUnk;
            } 	cpg;
        struct _cvd
            {
            IUnknown *pVDiskUnk;
            } 	cvd;
         /* Empty union arm */ 
        } 	;
    } 	VDS_ASYNC_OUTPUT;

typedef USHORT VDS_ISCSI_PORTALGROUP_TAG;

typedef 
enum VDS_IPADDRESS_TYPE
    {	VDS_IPT_TEXT	= 0,
	VDS_IPT_IPV4	= 1,
	VDS_IPT_IPV6	= 2,
	VDS_IPT_EMPTY	= 3
    } 	VDS_IPADDRESS_TYPE;

typedef 
enum _VDS_HEALTH
    {	VDS_H_UNKNOWN	= 0,
	VDS_H_HEALTHY	= 1,
	VDS_H_REBUILDING	= 2,
	VDS_H_STALE	= 3,
	VDS_H_FAILING	= 4,
	VDS_H_FAILING_REDUNDANCY	= 5,
	VDS_H_FAILED_REDUNDANCY	= 6,
	VDS_H_FAILED_REDUNDANCY_FAILING	= 7,
	VDS_H_FAILED	= 8,
	VDS_H_REPLACED	= 9,
	VDS_H_PENDING_FAILURE	= 10,
	VDS_H_DEGRADED	= 11
    } 	VDS_HEALTH;

typedef 
enum _VDS_TRANSITION_STATE
    {	VDS_TS_UNKNOWN	= 0,
	VDS_TS_STABLE	= 1,
	VDS_TS_EXTENDING	= 2,
	VDS_TS_SHRINKING	= 3,
	VDS_TS_RECONFIGING	= 4,
	VDS_TS_RESTRIPING	= 5
    } 	VDS_TRANSITION_STATE;

typedef 
enum _VDS_FILE_SYSTEM_TYPE
    {	VDS_FST_UNKNOWN	= 0,
	VDS_FST_RAW	= ( VDS_FST_UNKNOWN + 1 ) ,
	VDS_FST_FAT	= ( VDS_FST_RAW + 1 ) ,
	VDS_FST_FAT32	= ( VDS_FST_FAT + 1 ) ,
	VDS_FST_NTFS	= ( VDS_FST_FAT32 + 1 ) ,
	VDS_FST_CDFS	= ( VDS_FST_NTFS + 1 ) ,
	VDS_FST_UDF	= ( VDS_FST_CDFS + 1 ) ,
	VDS_FST_EXFAT	= ( VDS_FST_UDF + 1 ) 
    } 	VDS_FILE_SYSTEM_TYPE;

typedef 
enum _VDS_HBAPORT_TYPE
    {	VDS_HPT_UNKNOWN	= 1,
	VDS_HPT_OTHER	= 2,
	VDS_HPT_NOTPRESENT	= 3,
	VDS_HPT_NPORT	= 5,
	VDS_HPT_NLPORT	= 6,
	VDS_HPT_FLPORT	= 7,
	VDS_HPT_FPORT	= 8,
	VDS_HPT_EPORT	= 9,
	VDS_HPT_GPORT	= 10,
	VDS_HPT_LPORT	= 20,
	VDS_HPT_PTP	= 21
    } 	VDS_HBAPORT_TYPE;

typedef 
enum _VDS_HBAPORT_STATUS
    {	VDS_HPS_UNKNOWN	= 1,
	VDS_HPS_ONLINE	= 2,
	VDS_HPS_OFFLINE	= 3,
	VDS_HPS_BYPASSED	= 4,
	VDS_HPS_DIAGNOSTICS	= 5,
	VDS_HPS_LINKDOWN	= 6,
	VDS_HPS_ERROR	= 7,
	VDS_HPS_LOOPBACK	= 8
    } 	VDS_HBAPORT_STATUS;

typedef 
enum _VDS_HBAPORT_SPEED_FLAG
    {	VDS_HSF_UNKNOWN	= 0,
	VDS_HSF_1GBIT	= 0x1,
	VDS_HSF_2GBIT	= 0x2,
	VDS_HSF_10GBIT	= 0x4,
	VDS_HSF_4GBIT	= 0x8,
	VDS_HSF_NOT_NEGOTIATED	= ( 1 << 15 ) 
    } 	VDS_HBAPORT_SPEED_FLAG;

typedef 
enum _VDS_PATH_STATUS
    {	VDS_MPS_UNKNOWN	= 0,
	VDS_MPS_ONLINE	= 1,
	VDS_MPS_FAILED	= 5,
	VDS_MPS_STANDBY	= 7
    } 	VDS_PATH_STATUS;

typedef 
enum _VDS_LOADBALANCE_POLICY_ENUM
    {	VDS_LBP_UNKNOWN	= 0,
	VDS_LBP_FAILOVER	= 1,
	VDS_LBP_ROUND_ROBIN	= 2,
	VDS_LBP_ROUND_ROBIN_WITH_SUBSET	= 3,
	VDS_LBP_DYN_LEAST_QUEUE_DEPTH	= 4,
	VDS_LBP_WEIGHTED_PATHS	= 5,
	VDS_LBP_LEAST_BLOCKS	= 6,
	VDS_LBP_VENDOR_SPECIFIC	= 7
    } 	VDS_LOADBALANCE_POLICY_ENUM;

typedef 
enum _VDS_PROVIDER_LBSUPPORT_FLAG
    {	VDS_LBF_FAILOVER	= 0x1,
	VDS_LBF_ROUND_ROBIN	= 0x2,
	VDS_LBF_ROUND_ROBIN_WITH_SUBSET	= 0x4,
	VDS_LBF_DYN_LEAST_QUEUE_DEPTH	= 0x8,
	VDS_LBF_WEIGHTED_PATHS	= 0x10,
	VDS_LBF_LEAST_BLOCKS	= 0x20,
	VDS_LBF_VENDOR_SPECIFIC	= 0x40
    } 	VDS_PROVIDER_LBSUPPORT_FLAG;

typedef 
enum _VDS_VERSION_SUPPORT_FLAG
    {	VDS_VSF_1_0	= 0x1,
	VDS_VSF_1_1	= 0x2,
	VDS_VSF_2_0	= 0x4,
	VDS_VSF_2_1	= 0x8,
	VDS_VSF_3_0	= 0x10
    } 	VDS_VERSION_SUPPORT_FLAG;

typedef 
enum _VDS_HWPROVIDER_TYPE
    {	VDS_HWT_UNKNOWN	= 0,
	VDS_HWT_PCI_RAID	= 1,
	VDS_HWT_FIBRE_CHANNEL	= 2,
	VDS_HWT_ISCSI	= 3,
	VDS_HWT_SAS	= 4,
	VDS_HWT_HYBRID	= 5
    } 	VDS_HWPROVIDER_TYPE;

typedef 
enum _VDS_ISCSI_LOGIN_TYPE
    {	VDS_ILT_MANUAL	= 0,
	VDS_ILT_PERSISTENT	= 1,
	VDS_ILT_BOOT	= 2
    } 	VDS_ISCSI_LOGIN_TYPE;

typedef 
enum _VDS_ISCSI_AUTH_TYPE
    {	VDS_IAT_NONE	= 0,
	VDS_IAT_CHAP	= 1,
	VDS_IAT_MUTUAL_CHAP	= 2
    } 	VDS_ISCSI_AUTH_TYPE;

typedef 
enum _VDS_ISCSI_IPSEC_FLAG
    {	VDS_IIF_VALID	= 0x1,
	VDS_IIF_IKE	= 0x2,
	VDS_IIF_MAIN_MODE	= 0x4,
	VDS_IIF_AGGRESSIVE_MODE	= 0x8,
	VDS_IIF_PFS_ENABLE	= 0x10,
	VDS_IIF_TRANSPORT_MODE_PREFERRED	= 0x20,
	VDS_IIF_TUNNEL_MODE_PREFERRED	= 0x40
    } 	VDS_ISCSI_IPSEC_FLAG;

typedef 
enum _VDS_ISCSI_LOGIN_FLAG
    {	VDS_ILF_REQUIRE_IPSEC	= 0x1,
	VDS_ILF_MULTIPATH_ENABLED	= 0x2
    } 	VDS_ISCSI_LOGIN_FLAG;

typedef struct _VDS_PATH_ID
    {
    ULONGLONG ullSourceId;
    ULONGLONG ullPathId;
    } 	VDS_PATH_ID;

typedef struct _VDS_WWN
    {
    UCHAR rguchWwn[ 8 ];
    } 	VDS_WWN;

typedef struct _VDS_IPADDRESS
    {
    VDS_IPADDRESS_TYPE type;
    ULONG ipv4Address;
    UCHAR ipv6Address[ 16 ];
    ULONG ulIpv6FlowInfo;
    ULONG ulIpv6ScopeId;
    WCHAR wszTextAddress[ 257 ];
    ULONG ulPort;
    } 	VDS_IPADDRESS;

typedef struct _VDS_ISCSI_IPSEC_KEY
    {
    UCHAR *pKey;
    ULONG ulKeySize;
    } 	VDS_ISCSI_IPSEC_KEY;

typedef struct _VDS_ISCSI_SHARED_SECRET
    {
    UCHAR *pSharedSecret;
    ULONG ulSharedSecretSize;
    } 	VDS_ISCSI_SHARED_SECRET;

typedef struct _VDS_HBAPORT_PROP
    {
    VDS_OBJECT_ID id;
    VDS_WWN wwnNode;
    VDS_WWN wwnPort;
    VDS_HBAPORT_TYPE type;
    VDS_HBAPORT_STATUS status;
    ULONG ulPortSpeed;
    ULONG ulSupportedPortSpeed;
    } 	VDS_HBAPORT_PROP;

typedef struct _VDS_ISCSI_INITIATOR_ADAPTER_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszName;
    } 	VDS_ISCSI_INITIATOR_ADAPTER_PROP;

typedef struct _VDS_ISCSI_INITIATOR_PORTAL_PROP
    {
    VDS_OBJECT_ID id;
    VDS_IPADDRESS address;
    ULONG ulPortIndex;
    } 	VDS_ISCSI_INITIATOR_PORTAL_PROP;

typedef struct _VDS_PROVIDER_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszName;
    GUID guidVersionId;
    LPWSTR pwszVersion;
    VDS_PROVIDER_TYPE type;
    ULONG ulFlags;
    ULONG ulStripeSizeFlags;
    SHORT sRebuildPriority;
    } 	VDS_PROVIDER_PROP;

typedef struct _VDS_PATH_INFO
    {
    VDS_PATH_ID pathId;
    VDS_HWPROVIDER_TYPE type;
    VDS_PATH_STATUS status;
    /* [switch_type] */ union 
        {
        VDS_OBJECT_ID controllerPortId;
        VDS_OBJECT_ID targetPortalId;
         /* Empty union arm */ 
        } 	;
    /* [switch_type] */ union 
        {
        VDS_OBJECT_ID hbaPortId;
        VDS_OBJECT_ID initiatorAdapterId;
         /* Empty union arm */ 
        } 	;
    /* [switch_type] */ union 
        {
        VDS_HBAPORT_PROP *pHbaPortProp;
        VDS_IPADDRESS *pInitiatorPortalIpAddr;
         /* Empty union arm */ 
        } 	;
    } 	VDS_PATH_INFO;

typedef struct _VDS_PATH_POLICY
    {
    VDS_PATH_ID pathId;
    BOOL bPrimaryPath;
    ULONG ulWeight;
    } 	VDS_PATH_POLICY;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0000_v0_0_s_ifspec;

#ifndef __IEnumVdsObject_INTERFACE_DEFINED__
#define __IEnumVdsObject_INTERFACE_DEFINED__

/* interface IEnumVdsObject */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumVdsObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("118610b7-8d94-4030-b5b8-500889788e4e")
    IEnumVdsObject : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pcFetched) IUnknown **ppObjectArray,
            /* [out] */ __RPC__out ULONG *pcFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumVdsObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumVdsObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumVdsObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumVdsObject * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumVdsObject * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pcFetched) IUnknown **ppObjectArray,
            /* [out] */ __RPC__out ULONG *pcFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumVdsObject * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumVdsObject * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumVdsObject * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IEnumVdsObjectVtbl;

    interface IEnumVdsObject
    {
        CONST_VTBL struct IEnumVdsObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumVdsObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumVdsObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumVdsObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumVdsObject_Next(This,celt,ppObjectArray,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppObjectArray,pcFetched) ) 

#define IEnumVdsObject_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumVdsObject_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumVdsObject_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumVdsObject_INTERFACE_DEFINED__ */


#ifndef __IVdsAsync_INTERFACE_DEFINED__
#define __IVdsAsync_INTERFACE_DEFINED__

/* interface IVdsAsync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5d23b6d-5a55-4492-9889-397a3c2d2dbc")
    IVdsAsync : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Wait( 
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out VDS_ASYNC_OUTPUT *pAsyncOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out ULONG *pulPercentCompleted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsAsync * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in IVdsAsync * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Wait )( 
            __RPC__in IVdsAsync * This,
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out VDS_ASYNC_OUTPUT *pAsyncOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            __RPC__in IVdsAsync * This,
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out ULONG *pulPercentCompleted);
        
        END_INTERFACE
    } IVdsAsyncVtbl;

    interface IVdsAsync
    {
        CONST_VTBL struct IVdsAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAsync_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IVdsAsync_Wait(This,pHrResult,pAsyncOut)	\
    ( (This)->lpVtbl -> Wait(This,pHrResult,pAsyncOut) ) 

#define IVdsAsync_QueryStatus(This,pHrResult,pulPercentCompleted)	\
    ( (This)->lpVtbl -> QueryStatus(This,pHrResult,pulPercentCompleted) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAsync_INTERFACE_DEFINED__ */


#ifndef __IVdsAdviseSink_INTERFACE_DEFINED__
#define __IVdsAdviseSink_INTERFACE_DEFINED__

/* interface IVdsAdviseSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAdviseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8326cd1d-cf59-4936-b786-5efc08798e25")
    IVdsAdviseSink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnNotify( 
            /* [range][in] */ __RPC__in_range(1,100) LONG lNumberOfNotifications,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfNotifications) VDS_NOTIFICATION *pNotificationArray) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAdviseSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsAdviseSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsAdviseSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsAdviseSink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnNotify )( 
            __RPC__in IVdsAdviseSink * This,
            /* [range][in] */ __RPC__in_range(1,100) LONG lNumberOfNotifications,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfNotifications) VDS_NOTIFICATION *pNotificationArray);
        
        END_INTERFACE
    } IVdsAdviseSinkVtbl;

    interface IVdsAdviseSink
    {
        CONST_VTBL struct IVdsAdviseSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAdviseSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAdviseSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAdviseSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAdviseSink_OnNotify(This,lNumberOfNotifications,pNotificationArray)	\
    ( (This)->lpVtbl -> OnNotify(This,lNumberOfNotifications,pNotificationArray) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAdviseSink_INTERFACE_DEFINED__ */


#ifndef __IVdsProvider_INTERFACE_DEFINED__
#define __IVdsProvider_INTERFACE_DEFINED__

/* interface IVdsProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10c5e575-7984-4e81-a56b-431f5f92ae42")
    IVdsProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_PROVIDER_PROP *pProviderProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsProvider * This,
            /* [out] */ __RPC__out VDS_PROVIDER_PROP *pProviderProp);
        
        END_INTERFACE
    } IVdsProviderVtbl;

    interface IVdsProvider
    {
        CONST_VTBL struct IVdsProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsProvider_GetProperties(This,pProviderProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pProviderProp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsProvider_INTERFACE_DEFINED__ */


#ifndef __IVdsProviderSupport_INTERFACE_DEFINED__
#define __IVdsProviderSupport_INTERFACE_DEFINED__

/* interface IVdsProviderSupport */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsProviderSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1732be13-e8f9-4a03-bfbc-5f616aa66ce1")
    IVdsProviderSupport : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVersionSupport( 
            /* [out] */ __RPC__out ULONG *ulVersionSupport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsProviderSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsProviderSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsProviderSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsProviderSupport * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVersionSupport )( 
            __RPC__in IVdsProviderSupport * This,
            /* [out] */ __RPC__out ULONG *ulVersionSupport);
        
        END_INTERFACE
    } IVdsProviderSupportVtbl;

    interface IVdsProviderSupport
    {
        CONST_VTBL struct IVdsProviderSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsProviderSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsProviderSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsProviderSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsProviderSupport_GetVersionSupport(This,ulVersionSupport)	\
    ( (This)->lpVtbl -> GetVersionSupport(This,ulVersionSupport) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsProviderSupport_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0005 */
/* [local] */ 
















typedef 
enum _VDS_PACK_STATUS
    {	VDS_PS_UNKNOWN	= 0,
	VDS_PS_ONLINE	= 1,
	VDS_PS_OFFLINE	= 4
    } 	VDS_PACK_STATUS;

typedef 
enum _VDS_PACK_FLAG
    {	VDS_PKF_FOREIGN	= 0x1,
	VDS_PKF_NOQUORUM	= 0x2,
	VDS_PKF_POLICY	= 0x4,
	VDS_PKF_CORRUPTED	= 0x8,
	VDS_PKF_ONLINE_ERROR	= 0x10
    } 	VDS_PACK_FLAG;

typedef 
enum _VDS_DISK_STATUS
    {	VDS_DS_UNKNOWN	= 0,
	VDS_DS_ONLINE	= 1,
	VDS_DS_NOT_READY	= 2,
	VDS_DS_NO_MEDIA	= 3,
	VDS_DS_FAILED	= 5,
	VDS_DS_MISSING	= 6,
	VDS_DS_OFFLINE	= 4
    } 	VDS_DISK_STATUS;

typedef 
enum _VDS_PARTITION_STYLE
    {	VDS_PST_UNKNOWN	= 0,
	VDS_PST_MBR	= 1,
	VDS_PST_GPT	= 2
    } 	VDS_PARTITION_STYLE;

typedef 
enum _VDS_DISK_FLAG
    {	VDS_DF_AUDIO_CD	= 0x1,
	VDS_DF_HOTSPARE	= 0x2,
	VDS_DF_RESERVE_CAPABLE	= 0x4,
	VDS_DF_MASKED	= 0x8,
	VDS_DF_STYLE_CONVERTIBLE	= 0x10,
	VDS_DF_CLUSTERED	= 0x20,
	VDS_DF_READ_ONLY	= 0x40,
	VDS_DF_SYSTEM_DISK	= 0x80,
	VDS_DF_BOOT_DISK	= 0x100,
	VDS_DF_PAGEFILE_DISK	= 0x200,
	VDS_DF_HIBERNATIONFILE_DISK	= 0x400,
	VDS_DF_CRASHDUMP_DISK	= 0x800,
	VDS_DF_HAS_ARC_PATH	= 0x1000,
	VDS_DF_DYNAMIC	= 0x2000,
	VDS_DF_BOOT_FROM_DISK	= 0x4000,
	VDS_DF_CURRENT_READ_ONLY	= 0x8000
    } 	VDS_DISK_FLAG;

typedef 
enum _VDS_PARTITION_FLAG
    {	VDS_PTF_SYSTEM	= 0x1
    } 	VDS_PARTITION_FLAG;

typedef 
enum _VDS_LUN_RESERVE_MODE
    {	VDS_LRM_NONE	= 0,
	VDS_LRM_EXCLUSIVE_RW	= 1,
	VDS_LRM_EXCLUSIVE_RO	= 2,
	VDS_LRM_SHARED_RO	= 3,
	VDS_LRM_SHARED_RW	= 4
    } 	VDS_LUN_RESERVE_MODE;

typedef 
enum _VDS_VOLUME_STATUS
    {	VDS_VS_UNKNOWN	= 0,
	VDS_VS_ONLINE	= 1,
	VDS_VS_NO_MEDIA	= 3,
	VDS_VS_FAILED	= 5,
	VDS_VS_OFFLINE	= 4
    } 	VDS_VOLUME_STATUS;

typedef 
enum _VDS_VOLUME_TYPE
    {	VDS_VT_UNKNOWN	= 0,
	VDS_VT_SIMPLE	= 10,
	VDS_VT_SPAN	= 11,
	VDS_VT_STRIPE	= 12,
	VDS_VT_MIRROR	= 13,
	VDS_VT_PARITY	= 14
    } 	VDS_VOLUME_TYPE;

typedef 
enum _VDS_VOLUME_FLAG
    {	VDS_VF_SYSTEM_VOLUME	= 0x1,
	VDS_VF_BOOT_VOLUME	= 0x2,
	VDS_VF_ACTIVE	= 0x4,
	VDS_VF_READONLY	= 0x8,
	VDS_VF_HIDDEN	= 0x10,
	VDS_VF_CAN_EXTEND	= 0x20,
	VDS_VF_CAN_SHRINK	= 0x40,
	VDS_VF_PAGEFILE	= 0x80,
	VDS_VF_HIBERNATION	= 0x100,
	VDS_VF_CRASHDUMP	= 0x200,
	VDS_VF_INSTALLABLE	= 0x400,
	VDS_VF_LBN_REMAP_ENABLED	= 0x800,
	VDS_VF_FORMATTING	= 0x1000,
	VDS_VF_NOT_FORMATTABLE	= 0x2000,
	VDS_VF_NTFS_NOT_SUPPORTED	= 0x4000,
	VDS_VF_FAT32_NOT_SUPPORTED	= 0x8000,
	VDS_VF_FAT_NOT_SUPPORTED	= 0x10000,
	VDS_VF_NO_DEFAULT_DRIVE_LETTER	= 0x20000,
	VDS_VF_PERMANENTLY_DISMOUNTED	= 0x40000,
	VDS_VF_PERMANENT_DISMOUNT_SUPPORTED	= 0x80000,
	VDS_VF_SHADOW_COPY	= 0x100000,
	VDS_VF_FVE_ENABLED	= 0x200000,
	VDS_VF_DIRTY	= 0x400000
    } 	VDS_VOLUME_FLAG;

typedef 
enum _VDS_VOLUME_PLEX_TYPE
    {	VDS_VPT_UNKNOWN	= 0,
	VDS_VPT_SIMPLE	= VDS_VT_SIMPLE,
	VDS_VPT_SPAN	= VDS_VT_SPAN,
	VDS_VPT_STRIPE	= VDS_VT_STRIPE,
	VDS_VPT_PARITY	= VDS_VT_PARITY
    } 	VDS_VOLUME_PLEX_TYPE;

typedef 
enum _VDS_VOLUME_PLEX_STATUS
    {	VDS_VPS_UNKNOWN	= 0,
	VDS_VPS_ONLINE	= 1,
	VDS_VPS_NO_MEDIA	= 3,
	VDS_VPS_FAILED	= 5
    } 	VDS_VOLUME_PLEX_STATUS;

typedef 
enum _VDS_DISK_EXTENT_TYPE
    {	VDS_DET_UNKNOWN	= 0,
	VDS_DET_FREE	= 1,
	VDS_DET_DATA	= 2,
	VDS_DET_OEM	= 3,
	VDS_DET_ESP	= 4,
	VDS_DET_MSR	= 5,
	VDS_DET_LDM	= 6,
	VDS_DET_CLUSTER	= 7,
	VDS_DET_UNUSABLE	= 0x7fff
    } 	VDS_DISK_EXTENT_TYPE;

typedef struct _VDS_PACK_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszName;
    VDS_PACK_STATUS status;
    ULONG ulFlags;
    } 	VDS_PACK_PROP;

typedef struct _VDS_PACK_PROP *PVDS_PACK_PROP;

typedef struct _VDS_DISK_PROP
    {
    VDS_OBJECT_ID id;
    VDS_DISK_STATUS status;
    VDS_LUN_RESERVE_MODE ReserveMode;
    VDS_HEALTH health;
    DWORD dwDeviceType;
    DWORD dwMediaType;
    ULONGLONG ullSize;
    ULONG ulBytesPerSector;
    ULONG ulSectorsPerTrack;
    ULONG ulTracksPerCylinder;
    ULONG ulFlags;
    VDS_STORAGE_BUS_TYPE BusType;
    VDS_PARTITION_STYLE PartitionStyle;
    /* [switch_type] */ union 
        {
        DWORD dwSignature;
        GUID DiskGuid;
         /* Empty union arm */ 
        } 	;
    LPWSTR pwszDiskAddress;
    LPWSTR pwszName;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszAdaptorName;
    LPWSTR pwszDevicePath;
    } 	VDS_DISK_PROP;

typedef struct _VDS_DISK_PROP *PVDS_DISK_PROP;

typedef 
enum _VDS_DISK_OFFLINE_REASON
    {	VDSDiskOfflineReasonNone	= 0,
	VDSDiskOfflineReasonPolicy	= 1,
	VDSDiskOfflineReasonRedundantPath	= 2,
	VDSDiskOfflineReasonSnapshot	= 3,
	VDSDiskOfflineReasonCollision	= 4
    } 	VDS_DISK_OFFLINE_REASON;

typedef struct _VDS_DISK_PROP2
    {
    VDS_OBJECT_ID id;
    VDS_DISK_STATUS status;
    VDS_DISK_OFFLINE_REASON OfflineReason;
    VDS_LUN_RESERVE_MODE ReserveMode;
    VDS_HEALTH health;
    DWORD dwDeviceType;
    DWORD dwMediaType;
    ULONGLONG ullSize;
    ULONG ulBytesPerSector;
    ULONG ulSectorsPerTrack;
    ULONG ulTracksPerCylinder;
    ULONG ulFlags;
    VDS_STORAGE_BUS_TYPE BusType;
    VDS_PARTITION_STYLE PartitionStyle;
    /* [switch_type] */ union 
        {
        DWORD dwSignature;
        GUID DiskGuid;
         /* Empty union arm */ 
        } 	;
    LPWSTR pwszDiskAddress;
    LPWSTR pwszName;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszAdaptorName;
    LPWSTR pwszDevicePath;
    LPWSTR pwszLocationPath;
    } 	VDS_DISK_PROP2;

typedef struct _VDS_DISK_PROP2 *PVDS_DISK_PROP2;

typedef struct _VDS_VOLUME_PROP
    {
    VDS_OBJECT_ID id;
    VDS_VOLUME_TYPE type;
    VDS_VOLUME_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    ULONGLONG ullSize;
    ULONG ulFlags;
    VDS_FILE_SYSTEM_TYPE RecommendedFileSystemType;
    LPWSTR pwszName;
    } 	VDS_VOLUME_PROP;

typedef struct _VDS_VOLUME_PROP *PVDS_VOLUME_PROP;

typedef struct _VDS_VOLUME_PROP2
    {
    VDS_OBJECT_ID id;
    VDS_VOLUME_TYPE type;
    VDS_VOLUME_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    ULONGLONG ullSize;
    ULONG ulFlags;
    VDS_FILE_SYSTEM_TYPE RecommendedFileSystemType;
    ULONG cbUniqueId;
    LPWSTR pwszName;
    BYTE *pUniqueId;
    } 	VDS_VOLUME_PROP2;

typedef struct _VDS_VOLUME_PROP2 *PVDS_VOLUME_PROP2;

typedef struct _VDS_VOLUME_PLEX_PROP
    {
    VDS_OBJECT_ID id;
    VDS_VOLUME_PLEX_TYPE type;
    VDS_VOLUME_PLEX_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    ULONGLONG ullSize;
    ULONG ulStripeSize;
    ULONG ulNumberOfMembers;
    } 	VDS_VOLUME_PLEX_PROP;

typedef struct _VDS_VOLUME_PLEX_PROP *PVDS_VOLUME_PLEX_PROP;

typedef struct _VDS_DISK_EXTENT
    {
    VDS_OBJECT_ID diskId;
    VDS_DISK_EXTENT_TYPE type;
    ULONGLONG ullOffset;
    ULONGLONG ullSize;
    VDS_OBJECT_ID volumeId;
    VDS_OBJECT_ID plexId;
    ULONG memberIdx;
    } 	VDS_DISK_EXTENT;

typedef struct _VDS_DISK_EXTENT *PVDS_DISK_EXTENT;

typedef struct _VDS_DISK_FREE_EXTENT
    {
    VDS_OBJECT_ID diskId;
    ULONGLONG ullOffset;
    ULONGLONG ullSize;
    } 	VDS_DISK_FREE_EXTENT;

typedef struct _VDS_DISK_FREE_EXTENT *PVDS_DISK_FREE_EXTENT;

typedef struct _VDS_INPUT_DISK
    {
    VDS_OBJECT_ID diskId;
    ULONGLONG ullSize;
    VDS_OBJECT_ID plexId;
    ULONG memberIdx;
    } 	VDS_INPUT_DISK;

#define GPT_PARTITION_NAME_LENGTH    36
typedef struct _VDS_PARTITION_INFO_GPT
    {
    GUID partitionType;
    GUID partitionId;
    ULONGLONG attributes;
    WCHAR name[ 36 ];
    } 	VDS_PARTITION_INFO_GPT;

typedef struct _VDS_PARTITION_INFO_MBR
    {
    BYTE partitionType;
    BOOLEAN bootIndicator;
    BOOLEAN recognizedPartition;
    DWORD hiddenSectors;
    } 	VDS_PARTITION_INFO_MBR;

typedef struct _VDS_PARTITION_PROP
    {
    VDS_PARTITION_STYLE PartitionStyle;
    ULONG ulFlags;
    ULONG ulPartitionNumber;
    ULONGLONG ullOffset;
    ULONGLONG ullSize;
    /* [switch_type] */ union 
        {
        VDS_PARTITION_INFO_MBR Mbr;
        VDS_PARTITION_INFO_GPT Gpt;
         /* Empty union arm */ 
        } 	;
    } 	VDS_PARTITION_PROP;

typedef 
enum tag_VDS_PARTITION_STYLE
    {	VDS_PARTITION_STYLE_MBR	= 0,
	VDS_PARTITION_STYLE_GPT	= ( VDS_PARTITION_STYLE_MBR + 1 ) ,
	VDS_PARTITION_STYLE_RAW	= ( VDS_PARTITION_STYLE_GPT + 1 ) 
    } 	__VDS_PARTITION_STYLE;

typedef struct _VDS_PARTITION_INFORMATION_EX
    {
    __VDS_PARTITION_STYLE dwPartitionStyle;
    ULONGLONG ullStartingOffset;
    ULONGLONG ullPartitionLength;
    DWORD dwPartitionNumber;
    BOOLEAN bRewritePartition;
    /* [switch_type] */ union 
        {
        VDS_PARTITION_INFO_MBR Mbr;
        VDS_PARTITION_INFO_GPT Gpt;
        } 	;
    } 	VDS_PARTITION_INFORMATION_EX;

typedef struct _CREATE_PARTITION_PARAMETERS
    {
    VDS_PARTITION_STYLE style;
    /* [switch_type] */ union 
        {
        struct 
            {
            BYTE partitionType;
            BOOLEAN bootIndicator;
            } 	MbrPartInfo;
        struct 
            {
            GUID partitionType;
            GUID partitionId;
            ULONGLONG attributes;
            WCHAR name[ 36 ];
            } 	GptPartInfo;
         /* Empty union arm */ 
        } 	;
    } 	CREATE_PARTITION_PARAMETERS;

typedef struct _CHANGE_ATTRIBUTES_PARAMETERS
    {
    VDS_PARTITION_STYLE style;
    /* [switch_type] */ union 
        {
        struct 
            {
            BOOLEAN bootIndicator;
            } 	MbrPartInfo;
        struct 
            {
            ULONGLONG attributes;
            } 	GptPartInfo;
         /* Empty union arm */ 
        } 	;
    } 	CHANGE_ATTRIBUTES_PARAMETERS;

typedef struct _CHANGE_PARTITION_TYPE_PARAMETERS
    {
    VDS_PARTITION_STYLE style;
    /* [switch_type] */ union 
        {
        struct 
            {
            BYTE partitionType;
            } 	MbrPartInfo;
        struct 
            {
            GUID partitionType;
            } 	GptPartInfo;
         /* Empty union arm */ 
        } 	;
    } 	CHANGE_PARTITION_TYPE_PARAMETERS;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0005_v0_0_s_ifspec;

#ifndef __IVdsSwProvider_INTERFACE_DEFINED__
#define __IVdsSwProvider_INTERFACE_DEFINED__

/* interface IVdsSwProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSwProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9aa58360-ce33-4f92-b658-ed24b14425b8")
    IVdsSwProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPacks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePack( 
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSwProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSwProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSwProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSwProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPacks )( 
            __RPC__in IVdsSwProvider * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePack )( 
            __RPC__in IVdsSwProvider * This,
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack);
        
        END_INTERFACE
    } IVdsSwProviderVtbl;

    interface IVdsSwProvider
    {
        CONST_VTBL struct IVdsSwProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSwProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSwProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSwProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSwProvider_QueryPacks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPacks(This,ppEnum) ) 

#define IVdsSwProvider_CreatePack(This,ppPack)	\
    ( (This)->lpVtbl -> CreatePack(This,ppPack) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSwProvider_INTERFACE_DEFINED__ */


#ifndef __IVdsPack_INTERFACE_DEFINED__
#define __IVdsPack_INTERFACE_DEFINED__

/* interface IVdsPack */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsPack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3b69d7f5-9d94-4648-91ca-79939ba263bf")
    IVdsPack : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_PACK_PROP *pPackProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryVolumes( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDisks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateVolume( 
            /* [in] */ VDS_VOLUME_TYPE type,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ ULONG ulStripeSize,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddDisk( 
            /* [in] */ VDS_OBJECT_ID DiskId,
            /* [in] */ VDS_PARTITION_STYLE PartitionStyle,
            /* [in] */ BOOL bAsHotSpare) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MigrateDisks( 
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_OBJECT_ID *pDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ VDS_OBJECT_ID TargetPack,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQueryOnly,
            /* [size_is][out] */ __RPC__out_ecount_full(lNumberOfDisks) HRESULT *pResults,
            /* [out] */ __RPC__out BOOL *pbRebootNeeded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReplaceDisk( 
            /* [in] */ VDS_OBJECT_ID OldDiskId,
            /* [in] */ VDS_OBJECT_ID NewDiskId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveMissingDisk( 
            /* [in] */ VDS_OBJECT_ID DiskId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Recover( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsPackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsPack * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsPack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsPack * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsPack * This,
            /* [out] */ __RPC__out VDS_PACK_PROP *pPackProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProvider )( 
            __RPC__in IVdsPack * This,
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryVolumes )( 
            __RPC__in IVdsPack * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDisks )( 
            __RPC__in IVdsPack * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateVolume )( 
            __RPC__in IVdsPack * This,
            /* [in] */ VDS_VOLUME_TYPE type,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ ULONG ulStripeSize,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddDisk )( 
            __RPC__in IVdsPack * This,
            /* [in] */ VDS_OBJECT_ID DiskId,
            /* [in] */ VDS_PARTITION_STYLE PartitionStyle,
            /* [in] */ BOOL bAsHotSpare);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MigrateDisks )( 
            __RPC__in IVdsPack * This,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_OBJECT_ID *pDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ VDS_OBJECT_ID TargetPack,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQueryOnly,
            /* [size_is][out] */ __RPC__out_ecount_full(lNumberOfDisks) HRESULT *pResults,
            /* [out] */ __RPC__out BOOL *pbRebootNeeded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReplaceDisk )( 
            __RPC__in IVdsPack * This,
            /* [in] */ VDS_OBJECT_ID OldDiskId,
            /* [in] */ VDS_OBJECT_ID NewDiskId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveMissingDisk )( 
            __RPC__in IVdsPack * This,
            /* [in] */ VDS_OBJECT_ID DiskId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Recover )( 
            __RPC__in IVdsPack * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsPackVtbl;

    interface IVdsPack
    {
        CONST_VTBL struct IVdsPackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsPack_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsPack_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsPack_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsPack_GetProperties(This,pPackProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPackProp) ) 

#define IVdsPack_GetProvider(This,ppProvider)	\
    ( (This)->lpVtbl -> GetProvider(This,ppProvider) ) 

#define IVdsPack_QueryVolumes(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryVolumes(This,ppEnum) ) 

#define IVdsPack_QueryDisks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryDisks(This,ppEnum) ) 

#define IVdsPack_CreateVolume(This,type,pInputDiskArray,lNumberOfDisks,ulStripeSize,ppAsync)	\
    ( (This)->lpVtbl -> CreateVolume(This,type,pInputDiskArray,lNumberOfDisks,ulStripeSize,ppAsync) ) 

#define IVdsPack_AddDisk(This,DiskId,PartitionStyle,bAsHotSpare)	\
    ( (This)->lpVtbl -> AddDisk(This,DiskId,PartitionStyle,bAsHotSpare) ) 

#define IVdsPack_MigrateDisks(This,pDiskArray,lNumberOfDisks,TargetPack,bForce,bQueryOnly,pResults,pbRebootNeeded)	\
    ( (This)->lpVtbl -> MigrateDisks(This,pDiskArray,lNumberOfDisks,TargetPack,bForce,bQueryOnly,pResults,pbRebootNeeded) ) 

#define IVdsPack_ReplaceDisk(This,OldDiskId,NewDiskId,ppAsync)	\
    ( (This)->lpVtbl -> ReplaceDisk(This,OldDiskId,NewDiskId,ppAsync) ) 

#define IVdsPack_RemoveMissingDisk(This,DiskId)	\
    ( (This)->lpVtbl -> RemoveMissingDisk(This,DiskId) ) 

#define IVdsPack_Recover(This,ppAsync)	\
    ( (This)->lpVtbl -> Recover(This,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsPack_INTERFACE_DEFINED__ */


#ifndef __IVdsPack2_INTERFACE_DEFINED__
#define __IVdsPack2_INTERFACE_DEFINED__

/* interface IVdsPack2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsPack2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("13B50BFF-290A-47DD-8558-B7C58DB1A71A")
    IVdsPack2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateVolume2( 
            /* [in] */ VDS_VOLUME_TYPE type,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ ULONG ulStripeSize,
            /* [in] */ ULONG ulAlign,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsPack2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsPack2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsPack2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsPack2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateVolume2 )( 
            __RPC__in IVdsPack2 * This,
            /* [in] */ VDS_VOLUME_TYPE type,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ ULONG ulStripeSize,
            /* [in] */ ULONG ulAlign,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsPack2Vtbl;

    interface IVdsPack2
    {
        CONST_VTBL struct IVdsPack2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsPack2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsPack2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsPack2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsPack2_CreateVolume2(This,type,pInputDiskArray,lNumberOfDisks,ulStripeSize,ulAlign,ppAsync)	\
    ( (This)->lpVtbl -> CreateVolume2(This,type,pInputDiskArray,lNumberOfDisks,ulStripeSize,ulAlign,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsPack2_INTERFACE_DEFINED__ */


#ifndef __IVdsDisk_INTERFACE_DEFINED__
#define __IVdsDisk_INTERFACE_DEFINED__

/* interface IVdsDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07e5c822-f00c-47a1-8fce-b244da56fd06")
    IVdsDisk : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_DISK_PROP *pDiskProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPack( 
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIdentificationData( 
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DISK_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ConvertStyle( 
            /* [in] */ VDS_PARTITION_STYLE NewStyle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDisk * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsDisk * This,
            /* [out] */ __RPC__out VDS_DISK_PROP *pDiskProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPack )( 
            __RPC__in IVdsDisk * This,
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIdentificationData )( 
            __RPC__in IVdsDisk * This,
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            __RPC__in IVdsDisk * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DISK_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ConvertStyle )( 
            __RPC__in IVdsDisk * This,
            /* [in] */ VDS_PARTITION_STYLE NewStyle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in IVdsDisk * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            __RPC__in IVdsDisk * This,
            /* [in] */ ULONG ulFlags);
        
        END_INTERFACE
    } IVdsDiskVtbl;

    interface IVdsDisk
    {
        CONST_VTBL struct IVdsDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDisk_GetProperties(This,pDiskProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pDiskProperties) ) 

#define IVdsDisk_GetPack(This,ppPack)	\
    ( (This)->lpVtbl -> GetPack(This,ppPack) ) 

#define IVdsDisk_GetIdentificationData(This,pLunInfo)	\
    ( (This)->lpVtbl -> GetIdentificationData(This,pLunInfo) ) 

#define IVdsDisk_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsDisk_ConvertStyle(This,NewStyle)	\
    ( (This)->lpVtbl -> ConvertStyle(This,NewStyle) ) 

#define IVdsDisk_SetFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags) ) 

#define IVdsDisk_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDisk_INTERFACE_DEFINED__ */


#ifndef __IVdsDisk2_INTERFACE_DEFINED__
#define __IVdsDisk2_INTERFACE_DEFINED__

/* interface IVdsDisk2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDisk2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40F73C8B-687D-4a13-8D96-3D7F2E683936")
    IVdsDisk2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSANMode( 
            /* [in] */ BOOL bEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDisk2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDisk2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDisk2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDisk2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSANMode )( 
            __RPC__in IVdsDisk2 * This,
            /* [in] */ BOOL bEnable);
        
        END_INTERFACE
    } IVdsDisk2Vtbl;

    interface IVdsDisk2
    {
        CONST_VTBL struct IVdsDisk2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDisk2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDisk2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDisk2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDisk2_SetSANMode(This,bEnable)	\
    ( (This)->lpVtbl -> SetSANMode(This,bEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDisk2_INTERFACE_DEFINED__ */


#ifndef __IVdsDiskOnline_INTERFACE_DEFINED__
#define __IVdsDiskOnline_INTERFACE_DEFINED__

/* interface IVdsDiskOnline */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDiskOnline;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("90681B1D-6A7F-48e8-9061-31B7AA125322")
    IVdsDiskOnline : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Online( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Offline( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDiskOnlineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDiskOnline * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDiskOnline * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDiskOnline * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Online )( 
            __RPC__in IVdsDiskOnline * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Offline )( 
            __RPC__in IVdsDiskOnline * This);
        
        END_INTERFACE
    } IVdsDiskOnlineVtbl;

    interface IVdsDiskOnline
    {
        CONST_VTBL struct IVdsDiskOnlineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDiskOnline_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDiskOnline_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDiskOnline_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDiskOnline_Online(This)	\
    ( (This)->lpVtbl -> Online(This) ) 

#define IVdsDiskOnline_Offline(This)	\
    ( (This)->lpVtbl -> Offline(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDiskOnline_INTERFACE_DEFINED__ */


#ifndef __IVdsAdvancedDisk_INTERFACE_DEFINED__
#define __IVdsAdvancedDisk_INTERFACE_DEFINED__

/* interface IVdsAdvancedDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAdvancedDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e6f6b40-977c-4069-bddd-ac710059f8c0")
    IVdsAdvancedDisk : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPartitionProperties( 
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out VDS_PARTITION_PROP *pPartitionProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPartitions( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPartitions) VDS_PARTITION_PROP **ppPartitionPropArray,
            /* [out] */ __RPC__out LONG *plNumberOfPartitions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePartition( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ ULONGLONG ullSize,
            /* [in] */ __RPC__in CREATE_PARTITION_PARAMETERS *para,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeletePartition( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bForceProtected) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ChangeAttributes( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ __RPC__in CHANGE_ATTRIBUTES_PARAMETERS *para) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssignDriveLetter( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ WCHAR wcLetter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteDriveLetter( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ WCHAR wcLetter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDriveLetter( 
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out WCHAR *pwcLetter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatPartition( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ VDS_FILE_SYSTEM_TYPE type,
            /* [string][in] */ __RPC__in_string LPWSTR pwszLabel,
            /* [in] */ DWORD dwUnitAllocationSize,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clean( 
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bForceOEM,
            /* [in] */ BOOL bFullClean,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAdvancedDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsAdvancedDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsAdvancedDisk * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionProperties )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out VDS_PARTITION_PROP *pPartitionProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPartitions )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPartitions) VDS_PARTITION_PROP **ppPartitionPropArray,
            /* [out] */ __RPC__out LONG *plNumberOfPartitions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePartition )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ ULONGLONG ullSize,
            /* [in] */ __RPC__in CREATE_PARTITION_PARAMETERS *para,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeletePartition )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bForceProtected);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ChangeAttributes )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ __RPC__in CHANGE_ATTRIBUTES_PARAMETERS *para);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssignDriveLetter )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ WCHAR wcLetter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteDriveLetter )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ WCHAR wcLetter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDriveLetter )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out WCHAR *pwcLetter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatPartition )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ VDS_FILE_SYSTEM_TYPE type,
            /* [string][in] */ __RPC__in_string LPWSTR pwszLabel,
            /* [in] */ DWORD dwUnitAllocationSize,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Clean )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bForceOEM,
            /* [in] */ BOOL bFullClean,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsAdvancedDiskVtbl;

    interface IVdsAdvancedDisk
    {
        CONST_VTBL struct IVdsAdvancedDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAdvancedDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAdvancedDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAdvancedDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAdvancedDisk_GetPartitionProperties(This,ullOffset,pPartitionProp)	\
    ( (This)->lpVtbl -> GetPartitionProperties(This,ullOffset,pPartitionProp) ) 

#define IVdsAdvancedDisk_QueryPartitions(This,ppPartitionPropArray,plNumberOfPartitions)	\
    ( (This)->lpVtbl -> QueryPartitions(This,ppPartitionPropArray,plNumberOfPartitions) ) 

#define IVdsAdvancedDisk_CreatePartition(This,ullOffset,ullSize,para,ppAsync)	\
    ( (This)->lpVtbl -> CreatePartition(This,ullOffset,ullSize,para,ppAsync) ) 

#define IVdsAdvancedDisk_DeletePartition(This,ullOffset,bForce,bForceProtected)	\
    ( (This)->lpVtbl -> DeletePartition(This,ullOffset,bForce,bForceProtected) ) 

#define IVdsAdvancedDisk_ChangeAttributes(This,ullOffset,para)	\
    ( (This)->lpVtbl -> ChangeAttributes(This,ullOffset,para) ) 

#define IVdsAdvancedDisk_AssignDriveLetter(This,ullOffset,wcLetter)	\
    ( (This)->lpVtbl -> AssignDriveLetter(This,ullOffset,wcLetter) ) 

#define IVdsAdvancedDisk_DeleteDriveLetter(This,ullOffset,wcLetter)	\
    ( (This)->lpVtbl -> DeleteDriveLetter(This,ullOffset,wcLetter) ) 

#define IVdsAdvancedDisk_GetDriveLetter(This,ullOffset,pwcLetter)	\
    ( (This)->lpVtbl -> GetDriveLetter(This,ullOffset,pwcLetter) ) 

#define IVdsAdvancedDisk_FormatPartition(This,ullOffset,type,pwszLabel,dwUnitAllocationSize,bForce,bQuickFormat,bEnableCompression,ppAsync)	\
    ( (This)->lpVtbl -> FormatPartition(This,ullOffset,type,pwszLabel,dwUnitAllocationSize,bForce,bQuickFormat,bEnableCompression,ppAsync) ) 

#define IVdsAdvancedDisk_Clean(This,bForce,bForceOEM,bFullClean,ppAsync)	\
    ( (This)->lpVtbl -> Clean(This,bForce,bForceOEM,bFullClean,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAdvancedDisk_INTERFACE_DEFINED__ */


#ifndef __IVdsAdvancedDisk2_INTERFACE_DEFINED__
#define __IVdsAdvancedDisk2_INTERFACE_DEFINED__

/* interface IVdsAdvancedDisk2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAdvancedDisk2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9723f420-9355-42de-ab66-e31bb15beeac")
    IVdsAdvancedDisk2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ChangePartitionType( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ BOOL bForce,
            /* [in] */ __RPC__in CHANGE_PARTITION_TYPE_PARAMETERS *para) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAdvancedDisk2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsAdvancedDisk2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsAdvancedDisk2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsAdvancedDisk2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ChangePartitionType )( 
            __RPC__in IVdsAdvancedDisk2 * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ BOOL bForce,
            /* [in] */ __RPC__in CHANGE_PARTITION_TYPE_PARAMETERS *para);
        
        END_INTERFACE
    } IVdsAdvancedDisk2Vtbl;

    interface IVdsAdvancedDisk2
    {
        CONST_VTBL struct IVdsAdvancedDisk2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAdvancedDisk2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAdvancedDisk2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAdvancedDisk2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAdvancedDisk2_ChangePartitionType(This,ullOffset,bForce,para)	\
    ( (This)->lpVtbl -> ChangePartitionType(This,ullOffset,bForce,para) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAdvancedDisk2_INTERFACE_DEFINED__ */


#ifndef __IVdsCreatePartitionEx_INTERFACE_DEFINED__
#define __IVdsCreatePartitionEx_INTERFACE_DEFINED__

/* interface IVdsCreatePartitionEx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsCreatePartitionEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9882f547-cfc3-420b-9750-00dfbec50662")
    IVdsCreatePartitionEx : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePartitionEx( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ ULONGLONG ullSize,
            /* [in] */ ULONG ulAlign,
            /* [in] */ __RPC__in CREATE_PARTITION_PARAMETERS *para,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsCreatePartitionExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsCreatePartitionEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsCreatePartitionEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsCreatePartitionEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePartitionEx )( 
            __RPC__in IVdsCreatePartitionEx * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ ULONGLONG ullSize,
            /* [in] */ ULONG ulAlign,
            /* [in] */ __RPC__in CREATE_PARTITION_PARAMETERS *para,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsCreatePartitionExVtbl;

    interface IVdsCreatePartitionEx
    {
        CONST_VTBL struct IVdsCreatePartitionExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsCreatePartitionEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsCreatePartitionEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsCreatePartitionEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsCreatePartitionEx_CreatePartitionEx(This,ullOffset,ullSize,ulAlign,para,ppAsync)	\
    ( (This)->lpVtbl -> CreatePartitionEx(This,ullOffset,ullSize,ulAlign,para,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsCreatePartitionEx_INTERFACE_DEFINED__ */


#ifndef __IVdsRemovable_INTERFACE_DEFINED__
#define __IVdsRemovable_INTERFACE_DEFINED__

/* interface IVdsRemovable */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsRemovable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0316560b-5db4-4ed9-bbb5-213436ddc0d9")
    IVdsRemovable : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMedia( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Eject( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsRemovableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsRemovable * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsRemovable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsRemovable * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMedia )( 
            __RPC__in IVdsRemovable * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Eject )( 
            __RPC__in IVdsRemovable * This);
        
        END_INTERFACE
    } IVdsRemovableVtbl;

    interface IVdsRemovable
    {
        CONST_VTBL struct IVdsRemovableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsRemovable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsRemovable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsRemovable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsRemovable_QueryMedia(This)	\
    ( (This)->lpVtbl -> QueryMedia(This) ) 

#define IVdsRemovable_Eject(This)	\
    ( (This)->lpVtbl -> Eject(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsRemovable_INTERFACE_DEFINED__ */


#ifndef __IVdsVolume_INTERFACE_DEFINED__
#define __IVdsVolume_INTERFACE_DEFINED__

/* interface IVdsVolume */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolume;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88306bb2-e71f-478c-86a2-79da200a0f11")
    IVdsVolume : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_VOLUME_PROP *pVolumeProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPack( 
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPlexes( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Extend( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shrink( 
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPlex( 
            /* [in] */ VDS_OBJECT_ID VolumeId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BreakPlex( 
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePlex( 
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ BOOL bForce) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags,
            /* [in] */ BOOL bRevertOnClose) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolume * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolume * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsVolume * This,
            /* [out] */ __RPC__out VDS_VOLUME_PROP *pVolumeProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPack )( 
            __RPC__in IVdsVolume * This,
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPlexes )( 
            __RPC__in IVdsVolume * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Extend )( 
            __RPC__in IVdsVolume * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shrink )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPlex )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ VDS_OBJECT_ID VolumeId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BreakPlex )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePlex )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ BOOL bForce);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ ULONG ulFlags,
            /* [in] */ BOOL bRevertOnClose);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ ULONG ulFlags);
        
        END_INTERFACE
    } IVdsVolumeVtbl;

    interface IVdsVolume
    {
        CONST_VTBL struct IVdsVolumeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolume_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolume_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolume_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolume_GetProperties(This,pVolumeProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pVolumeProperties) ) 

#define IVdsVolume_GetPack(This,ppPack)	\
    ( (This)->lpVtbl -> GetPack(This,ppPack) ) 

#define IVdsVolume_QueryPlexes(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPlexes(This,ppEnum) ) 

#define IVdsVolume_Extend(This,pInputDiskArray,lNumberOfDisks,ppAsync)	\
    ( (This)->lpVtbl -> Extend(This,pInputDiskArray,lNumberOfDisks,ppAsync) ) 

#define IVdsVolume_Shrink(This,ullNumberOfBytesToRemove,ppAsync)	\
    ( (This)->lpVtbl -> Shrink(This,ullNumberOfBytesToRemove,ppAsync) ) 

#define IVdsVolume_AddPlex(This,VolumeId,ppAsync)	\
    ( (This)->lpVtbl -> AddPlex(This,VolumeId,ppAsync) ) 

#define IVdsVolume_BreakPlex(This,plexId,ppAsync)	\
    ( (This)->lpVtbl -> BreakPlex(This,plexId,ppAsync) ) 

#define IVdsVolume_RemovePlex(This,plexId,ppAsync)	\
    ( (This)->lpVtbl -> RemovePlex(This,plexId,ppAsync) ) 

#define IVdsVolume_Delete(This,bForce)	\
    ( (This)->lpVtbl -> Delete(This,bForce) ) 

#define IVdsVolume_SetFlags(This,ulFlags,bRevertOnClose)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags,bRevertOnClose) ) 

#define IVdsVolume_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolume_INTERFACE_DEFINED__ */


#ifndef __IVdsVolume2_INTERFACE_DEFINED__
#define __IVdsVolume2_INTERFACE_DEFINED__

/* interface IVdsVolume2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolume2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72AE6713-DCBB-4a03-B36B-371F6AC6B53D")
    IVdsVolume2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties2( 
            /* [out] */ __RPC__out VDS_VOLUME_PROP2 *pVolumeProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolume2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolume2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolume2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolume2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties2 )( 
            __RPC__in IVdsVolume2 * This,
            /* [out] */ __RPC__out VDS_VOLUME_PROP2 *pVolumeProperties);
        
        END_INTERFACE
    } IVdsVolume2Vtbl;

    interface IVdsVolume2
    {
        CONST_VTBL struct IVdsVolume2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolume2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolume2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolume2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolume2_GetProperties2(This,pVolumeProperties)	\
    ( (This)->lpVtbl -> GetProperties2(This,pVolumeProperties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolume2_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeOnline_INTERFACE_DEFINED__
#define __IVdsVolumeOnline_INTERFACE_DEFINED__

/* interface IVdsVolumeOnline */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeOnline;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1BE2275A-B315-4f70-9E44-879B3A2A53F2")
    IVdsVolumeOnline : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Online( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeOnlineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolumeOnline * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolumeOnline * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolumeOnline * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Online )( 
            __RPC__in IVdsVolumeOnline * This);
        
        END_INTERFACE
    } IVdsVolumeOnlineVtbl;

    interface IVdsVolumeOnline
    {
        CONST_VTBL struct IVdsVolumeOnlineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeOnline_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeOnline_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeOnline_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeOnline_Online(This)	\
    ( (This)->lpVtbl -> Online(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeOnline_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumePlex_INTERFACE_DEFINED__
#define __IVdsVolumePlex_INTERFACE_DEFINED__

/* interface IVdsVolumePlex */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumePlex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4daa0135-e1d1-40f1-aaa5-3cc1e53221c3")
    IVdsVolumePlex : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_VOLUME_PLEX_PROP *pPlexProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVolume( 
            /* [out] */ __RPC__deref_out_opt IVdsVolume **ppVolume) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DISK_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Repair( 
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumePlexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolumePlex * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolumePlex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolumePlex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsVolumePlex * This,
            /* [out] */ __RPC__out VDS_VOLUME_PLEX_PROP *pPlexProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVolume )( 
            __RPC__in IVdsVolumePlex * This,
            /* [out] */ __RPC__deref_out_opt IVdsVolume **ppVolume);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            __RPC__in IVdsVolumePlex * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DISK_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Repair )( 
            __RPC__in IVdsVolumePlex * This,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsVolumePlexVtbl;

    interface IVdsVolumePlex
    {
        CONST_VTBL struct IVdsVolumePlexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumePlex_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumePlex_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumePlex_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumePlex_GetProperties(This,pPlexProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pPlexProperties) ) 

#define IVdsVolumePlex_GetVolume(This,ppVolume)	\
    ( (This)->lpVtbl -> GetVolume(This,ppVolume) ) 

#define IVdsVolumePlex_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsVolumePlex_Repair(This,pInputDiskArray,lNumberOfDisks,ppAsync)	\
    ( (This)->lpVtbl -> Repair(This,pInputDiskArray,lNumberOfDisks,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumePlex_INTERFACE_DEFINED__ */


#ifndef __IVdsDisk3_INTERFACE_DEFINED__
#define __IVdsDisk3_INTERFACE_DEFINED__

/* interface IVdsDisk3 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDisk3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8F4B2F5D-EC15-4357-992F-473EF10975B9")
    IVdsDisk3 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties2( 
            /* [out] */ __RPC__out VDS_DISK_PROP2 *pDiskProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryFreeExtents( 
            /* [in] */ ULONG ulAlign,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFreeExtents) VDS_DISK_FREE_EXTENT **ppFreeExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfFreeExtents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDisk3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDisk3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDisk3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDisk3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties2 )( 
            __RPC__in IVdsDisk3 * This,
            /* [out] */ __RPC__out VDS_DISK_PROP2 *pDiskProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryFreeExtents )( 
            __RPC__in IVdsDisk3 * This,
            /* [in] */ ULONG ulAlign,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFreeExtents) VDS_DISK_FREE_EXTENT **ppFreeExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfFreeExtents);
        
        END_INTERFACE
    } IVdsDisk3Vtbl;

    interface IVdsDisk3
    {
        CONST_VTBL struct IVdsDisk3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDisk3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDisk3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDisk3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDisk3_GetProperties2(This,pDiskProperties)	\
    ( (This)->lpVtbl -> GetProperties2(This,pDiskProperties) ) 

#define IVdsDisk3_QueryFreeExtents(This,ulAlign,ppFreeExtentArray,plNumberOfFreeExtents)	\
    ( (This)->lpVtbl -> QueryFreeExtents(This,ulAlign,ppFreeExtentArray,plNumberOfFreeExtents) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDisk3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0020 */
/* [local] */ 



























typedef 
enum _VDS_SUB_SYSTEM_STATUS
    {	VDS_SSS_UNKNOWN	= 0,
	VDS_SSS_ONLINE	= 1,
	VDS_SSS_NOT_READY	= 2,
	VDS_SSS_OFFLINE	= 4,
	VDS_SSS_FAILED	= 5,
	VDS_SSS_PARTIALLY_MANAGED	= 9
    } 	VDS_SUB_SYSTEM_STATUS;

typedef 
enum _VDS_SUB_SYSTEM_FLAG
    {	VDS_SF_LUN_MASKING_CAPABLE	= 0x1,
	VDS_SF_LUN_PLEXING_CAPABLE	= 0x2,
	VDS_SF_LUN_REMAPPING_CAPABLE	= 0x4,
	VDS_SF_DRIVE_EXTENT_CAPABLE	= 0x8,
	VDS_SF_HARDWARE_CHECKSUM_CAPABLE	= 0x10,
	VDS_SF_RADIUS_CAPABLE	= 0x20,
	VDS_SF_READ_BACK_VERIFY_CAPABLE	= 0x40,
	VDS_SF_WRITE_THROUGH_CACHING_CAPABLE	= 0x80,
	VDS_SF_SUPPORTS_FAULT_TOLERANT_LUNS	= 0x200,
	VDS_SF_SUPPORTS_NON_FAULT_TOLERANT_LUNS	= 0x400,
	VDS_SF_SUPPORTS_SIMPLE_LUNS	= 0x800,
	VDS_SF_SUPPORTS_SPAN_LUNS	= 0x1000,
	VDS_SF_SUPPORTS_STRIPE_LUNS	= 0x2000,
	VDS_SF_SUPPORTS_MIRROR_LUNS	= 0x4000,
	VDS_SF_SUPPORTS_PARITY_LUNS	= 0x8000,
	VDS_SF_SUPPORTS_AUTH_CHAP	= 0x10000,
	VDS_SF_SUPPORTS_AUTH_MUTUAL_CHAP	= 0x20000,
	VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG	= 0x40000,
	VDS_SF_SUPPORTS_LUN_NUMBER	= 0x80000,
	VDS_SF_SUPPORTS_MIRRORED_CACHE	= 0x100000,
	VDS_SF_READ_CACHING_CAPABLE	= 0x200000,
	VDS_SF_WRITE_CACHING_CAPABLE	= 0x400000,
	VDS_SF_MEDIA_SCAN_CAPABLE	= 0x800000,
	VDS_SF_CONSISTENCY_CHECK_CAPABLE	= 0x1000000
    } 	VDS_SUB_SYSTEM_FLAG;

typedef 
enum _VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG
    {	VDS_SF_SUPPORTS_RAID2_LUNS	= 0x1,
	VDS_SF_SUPPORTS_RAID3_LUNS	= 0x2,
	VDS_SF_SUPPORTS_RAID4_LUNS	= 0x4,
	VDS_SF_SUPPORTS_RAID5_LUNS	= 0x8,
	VDS_SF_SUPPORTS_RAID6_LUNS	= 0x10,
	VDS_SF_SUPPORTS_RAID01_LUNS	= 0x20,
	VDS_SF_SUPPORTS_RAID03_LUNS	= 0x40,
	VDS_SF_SUPPORTS_RAID05_LUNS	= 0x80,
	VDS_SF_SUPPORTS_RAID10_LUNS	= 0x100,
	VDS_SF_SUPPORTS_RAID15_LUNS	= 0x200,
	VDS_SF_SUPPORTS_RAID30_LUNS	= 0x400,
	VDS_SF_SUPPORTS_RAID50_LUNS	= 0x800,
	VDS_SF_SUPPORTS_RAID51_LUNS	= 0x1000,
	VDS_SF_SUPPORTS_RAID53_LUNS	= 0x2000,
	VDS_SF_SUPPORTS_RAID60_LUNS	= 0x4000,
	VDS_SF_SUPPORTS_RAID61_LUNS	= 0x8000
    } 	VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG;

typedef 
enum _VDS_INTERCONNECT_FLAG
    {	VDS_ITF_PCI_RAID	= 0x1,
	VDS_ITF_FIBRE_CHANNEL	= 0x2,
	VDS_ITF_ISCSI	= 0x4,
	VDS_ITF_SAS	= 0x8
    } 	VDS_INTERCONNECT_FLAG;

typedef 
enum _VDS_CONTROLLER_STATUS
    {	VDS_CS_UNKNOWN	= 0,
	VDS_CS_ONLINE	= 1,
	VDS_CS_NOT_READY	= 2,
	VDS_CS_OFFLINE	= 4,
	VDS_CS_FAILED	= 5,
	VDS_CS_REMOVED	= 8
    } 	VDS_CONTROLLER_STATUS;

typedef 
enum _VDS_PORT_STATUS
    {	VDS_PRS_UNKNOWN	= 0,
	VDS_PRS_ONLINE	= 1,
	VDS_PRS_NOT_READY	= 2,
	VDS_PRS_OFFLINE	= 4,
	VDS_PRS_FAILED	= 5,
	VDS_PRS_REMOVED	= 8
    } 	VDS_PORT_STATUS;

typedef 
enum _VDS_DRIVE_STATUS
    {	VDS_DRS_UNKNOWN	= 0,
	VDS_DRS_ONLINE	= 1,
	VDS_DRS_NOT_READY	= 2,
	VDS_DRS_OFFLINE	= 4,
	VDS_DRS_FAILED	= 5,
	VDS_DRS_REMOVED	= 8
    } 	VDS_DRIVE_STATUS;

typedef 
enum _VDS_DRIVE_FLAG
    {	VDS_DRF_HOTSPARE	= 0x1,
	VDS_DRF_ASSIGNED	= 0x2,
	VDS_DRF_UNASSIGNED	= 0x4,
	VDS_DRF_HOTSPARE_IN_USE	= 0x8,
	VDS_DRF_HOTSPARE_STANDBY	= 0x10
    } 	VDS_DRIVE_FLAG;

typedef 
enum _VDS_LUN_TYPE
    {	VDS_LT_UNKNOWN	= 0,
	VDS_LT_DEFAULT	= 1,
	VDS_LT_FAULT_TOLERANT	= 2,
	VDS_LT_NON_FAULT_TOLERANT	= 3,
	VDS_LT_SIMPLE	= 10,
	VDS_LT_SPAN	= 11,
	VDS_LT_STRIPE	= 12,
	VDS_LT_MIRROR	= 13,
	VDS_LT_PARITY	= 14,
	VDS_LT_RAID2	= 15,
	VDS_LT_RAID3	= 16,
	VDS_LT_RAID4	= 17,
	VDS_LT_RAID5	= 18,
	VDS_LT_RAID6	= 19,
	VDS_LT_RAID01	= 20,
	VDS_LT_RAID03	= 21,
	VDS_LT_RAID05	= 22,
	VDS_LT_RAID10	= 23,
	VDS_LT_RAID15	= 24,
	VDS_LT_RAID30	= 25,
	VDS_LT_RAID50	= 26,
	VDS_LT_RAID51	= 27,
	VDS_LT_RAID53	= 28,
	VDS_LT_RAID60	= 29,
	VDS_LT_RAID61	= 30
    } 	VDS_LUN_TYPE;

typedef 
enum _VDS_LUN_STATUS
    {	VDS_LS_UNKNOWN	= 0,
	VDS_LS_ONLINE	= 1,
	VDS_LS_NOT_READY	= 2,
	VDS_LS_OFFLINE	= 4,
	VDS_LS_FAILED	= 5
    } 	VDS_LUN_STATUS;

typedef 
enum _VDS_LUN_FLAG
    {	VDS_LF_LBN_REMAP_ENABLED	= 0x1,
	VDS_LF_READ_BACK_VERIFY_ENABLED	= 0x2,
	VDS_LF_WRITE_THROUGH_CACHING_ENABLED	= 0x4,
	VDS_LF_HARDWARE_CHECKSUM_ENABLED	= 0x8,
	VDS_LF_READ_CACHE_ENABLED	= 0x10,
	VDS_LF_WRITE_CACHE_ENABLED	= 0x20,
	VDS_LF_MEDIA_SCAN_ENABLED	= 0x40,
	VDS_LF_CONSISTENCY_CHECK_ENABLED	= 0x80,
	VDS_LF_SNAPSHOT	= 0x100
    } 	VDS_LUN_FLAG;

typedef 
enum _VDS_LUN_PLEX_TYPE
    {	VDS_LPT_UNKNOWN	= 0,
	VDS_LPT_SIMPLE	= VDS_LT_SIMPLE,
	VDS_LPT_SPAN	= VDS_LT_SPAN,
	VDS_LPT_STRIPE	= VDS_LT_STRIPE,
	VDS_LPT_PARITY	= VDS_LT_PARITY,
	VDS_LPT_RAID2	= VDS_LT_RAID2,
	VDS_LPT_RAID3	= VDS_LT_RAID3,
	VDS_LPT_RAID4	= VDS_LT_RAID4,
	VDS_LPT_RAID5	= VDS_LT_RAID5,
	VDS_LPT_RAID6	= VDS_LT_RAID6,
	VDS_LPT_RAID03	= VDS_LT_RAID03,
	VDS_LPT_RAID05	= VDS_LT_RAID05,
	VDS_LPT_RAID10	= VDS_LT_RAID10,
	VDS_LPT_RAID15	= VDS_LT_RAID15,
	VDS_LPT_RAID30	= VDS_LT_RAID30,
	VDS_LPT_RAID50	= VDS_LT_RAID50,
	VDS_LPT_RAID53	= VDS_LT_RAID53,
	VDS_LPT_RAID60	= VDS_LT_RAID60
    } 	VDS_LUN_PLEX_TYPE;

typedef 
enum _VDS_LUN_PLEX_STATUS
    {	VDS_LPS_UNKNOWN	= 0,
	VDS_LPS_ONLINE	= 1,
	VDS_LPS_NOT_READY	= 2,
	VDS_LPS_OFFLINE	= 4,
	VDS_LPS_FAILED	= 5
    } 	VDS_LUN_PLEX_STATUS;

typedef 
enum _VDS_LUN_PLEX_FLAG
    {	VDS_LPF_LBN_REMAP_ENABLED	= VDS_LF_LBN_REMAP_ENABLED
    } 	VDS_LUN_PLEX_FLAG;

typedef 
enum _VDS_ISCSI_PORTAL_STATUS
    {	VDS_IPS_UNKNOWN	= 0,
	VDS_IPS_ONLINE	= 1,
	VDS_IPS_NOT_READY	= 2,
	VDS_IPS_OFFLINE	= 4,
	VDS_IPS_FAILED	= 5
    } 	VDS_ISCSI_PORTAL_STATUS;

typedef 
enum _VDS_STORAGE_POOL_STATUS
    {	VDS_SPS_UNKNOWN	= 0,
	VDS_SPS_ONLINE	= 1,
	VDS_SPS_NOT_READY	= 2,
	VDS_SPS_OFFLINE	= 4
    } 	VDS_STORAGE_POOL_STATUS;

typedef 
enum _VDS_STORAGE_POOL_TYPE
    {	VDS_SPT_UNKNOWN	= 0,
	VDS_SPT_PRIMORDIAL	= 0x1,
	VDS_SPT_CONCRETE	= 0x2
    } 	VDS_STORAGE_POOL_TYPE;

typedef 
enum _VDS_MAINTENANCE_OPERATION
    {	BlinkLight	= 1,
	BeepAlarm	= 2,
	SpinDown	= 3,
	SpinUp	= 4,
	Ping	= 5
    } 	VDS_MAINTENANCE_OPERATION;

typedef struct _VDS_HINTS
    {
    ULONGLONG ullHintMask;
    ULONGLONG ullExpectedMaximumSize;
    ULONG ulOptimalReadSize;
    ULONG ulOptimalReadAlignment;
    ULONG ulOptimalWriteSize;
    ULONG ulOptimalWriteAlignment;
    ULONG ulMaximumDriveCount;
    ULONG ulStripeSize;
    BOOL bFastCrashRecoveryRequired;
    BOOL bMostlyReads;
    BOOL bOptimizeForSequentialReads;
    BOOL bOptimizeForSequentialWrites;
    BOOL bRemapEnabled;
    BOOL bReadBackVerifyEnabled;
    BOOL bWriteThroughCachingEnabled;
    BOOL bHardwareChecksumEnabled;
    BOOL bIsYankable;
    SHORT sRebuildPriority;
    } 	VDS_HINTS;

typedef struct _VDS_HINTS *PVDS_HINTS;

#define	VDS_HINT_FASTCRASHRECOVERYREQUIRED	( 0x1L )

#define	VDS_HINT_MOSTLYREADS	( 0x2L )

#define	VDS_HINT_OPTIMIZEFORSEQUENTIALREADS	( 0x4L )

#define	VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES	( 0x8L )

#define	VDS_HINT_READBACKVERIFYENABLED	( 0x10L )

#define	VDS_HINT_REMAPENABLED	( 0x20L )

#define	VDS_HINT_WRITETHROUGHCACHINGENABLED	( 0x40L )

#define	VDS_HINT_HARDWARECHECKSUMENABLED	( 0x80L )

#define	VDS_HINT_ISYANKABLE	( 0x100L )

typedef struct _VDS_HINTS2
    {
    ULONGLONG ullHintMask;
    ULONGLONG ullExpectedMaximumSize;
    ULONG ulOptimalReadSize;
    ULONG ulOptimalReadAlignment;
    ULONG ulOptimalWriteSize;
    ULONG ulOptimalWriteAlignment;
    ULONG ulMaximumDriveCount;
    ULONG ulStripeSize;
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONG ulReserved3;
    BOOL bFastCrashRecoveryRequired;
    BOOL bMostlyReads;
    BOOL bOptimizeForSequentialReads;
    BOOL bOptimizeForSequentialWrites;
    BOOL bRemapEnabled;
    BOOL bReadBackVerifyEnabled;
    BOOL bWriteThroughCachingEnabled;
    BOOL bHardwareChecksumEnabled;
    BOOL bIsYankable;
    BOOL bAllocateHotSpare;
    BOOL bUseMirroredCache;
    BOOL bReadCachingEnabled;
    BOOL bWriteCachingEnabled;
    BOOL bMediaScanEnabled;
    BOOL bConsistencyCheckEnabled;
    VDS_STORAGE_BUS_TYPE BusType;
    BOOL bReserved1;
    BOOL bReserved2;
    BOOL bReserved3;
    SHORT sRebuildPriority;
    } 	VDS_HINTS2;

typedef struct _VDS_HINTS2 *PVDS_HINTS2;

#define	VDS_HINT_ALLOCATEHOTSPARE	( 0x200L )

#define	VDS_HINT_BUSTYPE	( 0x400L )

#define	VDS_HINT_USEMIRROREDCACHE	( 0x800L )

#define	VDS_HINT_READCACHINGENABLED	( 0x1000L )

#define	VDS_HINT_WRITECACHINGENABLED	( 0x2000L )

#define	VDS_HINT_MEDIASCANENABLED	( 0x4000L )

#define	VDS_HINT_CONSISTENCYCHECKENABLED	( 0x8000L )

typedef struct _VDS_SUB_SYSTEM_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    ULONG ulStripeSizeFlags;
    VDS_SUB_SYSTEM_STATUS status;
    VDS_HEALTH health;
    SHORT sNumberOfInternalBuses;
    SHORT sMaxNumberOfSlotsEachBus;
    SHORT sMaxNumberOfControllers;
    SHORT sRebuildPriority;
    } 	VDS_SUB_SYSTEM_PROP;

typedef struct _VDS_SUB_SYSTEM_PROP2
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    ULONG ulStripeSizeFlags;
    ULONG ulSupportedRaidTypeFlags;
    VDS_SUB_SYSTEM_STATUS status;
    VDS_HEALTH health;
    SHORT sNumberOfInternalBuses;
    SHORT sMaxNumberOfSlotsEachBus;
    SHORT sMaxNumberOfControllers;
    SHORT sRebuildPriority;
    ULONG ulNumberOfEnclosures;
    } 	VDS_SUB_SYSTEM_PROP2;

typedef struct _VDS_CONTROLLER_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    VDS_CONTROLLER_STATUS status;
    VDS_HEALTH health;
    SHORT sNumberOfPorts;
    } 	VDS_CONTROLLER_PROP;

typedef struct _VDS_DRIVE_PROP
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    VDS_DRIVE_STATUS status;
    VDS_HEALTH health;
    SHORT sInternalBusNumber;
    SHORT sSlotNumber;
    } 	VDS_DRIVE_PROP;

typedef struct _VDS_DRIVE_PROP2
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    VDS_DRIVE_STATUS status;
    VDS_HEALTH health;
    SHORT sInternalBusNumber;
    SHORT sSlotNumber;
    ULONG ulEnclosureNumber;
    VDS_STORAGE_BUS_TYPE busType;
    ULONG ulSpindleSpeed;
    } 	VDS_DRIVE_PROP2;

typedef struct _VDS_DRIVE_EXTENT
    {
    VDS_OBJECT_ID id;
    VDS_OBJECT_ID LunId;
    ULONGLONG ullSize;
    BOOL bUsed;
    } 	VDS_DRIVE_EXTENT;

#define VDS_REBUILD_PRIORITY_MIN        0
#define VDS_REBUILD_PRIORITY_MAX        16
typedef struct _VDS_LUN_PROP
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    LPWSTR pwszUnmaskingList;
    ULONG ulFlags;
    VDS_LUN_TYPE type;
    VDS_LUN_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    SHORT sRebuildPriority;
    } 	VDS_LUN_PROP;

typedef struct _VDS_LUN_PROP *PVDS_LUN_PROP;

typedef struct _VDS_LUN_PLEX_PROP
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    VDS_LUN_PLEX_TYPE type;
    VDS_LUN_PLEX_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    ULONG ulFlags;
    ULONG ulStripeSize;
    SHORT sRebuildPriority;
    } 	VDS_LUN_PLEX_PROP;

typedef struct _VDS_PORT_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    VDS_PORT_STATUS status;
    } 	VDS_PORT_PROP;

typedef struct _VDS_ISCSI_PORTAL_PROP
    {
    VDS_OBJECT_ID id;
    VDS_IPADDRESS address;
    VDS_ISCSI_PORTAL_STATUS status;
    } 	VDS_ISCSI_PORTAL_PROP;

typedef struct _VDS_ISCSI_TARGET_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszIscsiName;
    LPWSTR pwszFriendlyName;
    BOOL bChapEnabled;
    } 	VDS_ISCSI_TARGET_PROP;

typedef struct _VDS_ISCSI_PORTALGROUP_PROP
    {
    VDS_OBJECT_ID id;
    VDS_ISCSI_PORTALGROUP_TAG tag;
    } 	VDS_ISCSI_PORTALGROUP_PROP;

typedef 
enum _VDS_RAID_TYPE
    {	VDS_RT_UNKNOWN	= 0,
	VDS_RT_RAID0	= 10,
	VDS_RT_RAID1	= 11,
	VDS_RT_RAID2	= 12,
	VDS_RT_RAID3	= 13,
	VDS_RT_RAID4	= 14,
	VDS_RT_RAID5	= 15,
	VDS_RT_RAID6	= 16,
	VDS_RT_RAID01	= 17,
	VDS_RT_RAID03	= 18,
	VDS_RT_RAID05	= 19,
	VDS_RT_RAID10	= 20,
	VDS_RT_RAID15	= 21,
	VDS_RT_RAID30	= 22,
	VDS_RT_RAID50	= 23,
	VDS_RT_RAID51	= 24,
	VDS_RT_RAID53	= 25,
	VDS_RT_RAID60	= 26,
	VDS_RT_RAID61	= 27
    } 	VDS_RAID_TYPE;

typedef struct _VDS_POOL_CUSTOM_ATTRIBUTES
    {
    LPWSTR pwszName;
    LPWSTR pwszValue;
    } 	VDS_POOL_CUSTOM_ATTRIBUTES;

typedef struct _VDS_POOL_CUSTOM_ATTRIBUTES *PVDS_POOL_CUSTOM_ATTRIBUTES;

typedef struct _VDS_POOL_ATTRIBUTES
    {
    ULONGLONG ullAttributeMask;
    VDS_RAID_TYPE raidType;
    VDS_STORAGE_BUS_TYPE busType;
    LPWSTR pwszIntendedUsage;
    BOOL bSpinDown;
    BOOL bIsThinProvisioned;
    ULONGLONG ullProvisionedSpace;
    BOOL bNoSinglePointOfFailure;
    ULONG ulDataRedundancyMax;
    ULONG ulDataRedundancyMin;
    ULONG ulDataRedundancyDefault;
    ULONG ulPackageRedundancyMax;
    ULONG ulPackageRedundancyMin;
    ULONG ulPackageRedundancyDefault;
    ULONG ulStripeSize;
    ULONG ulStripeSizeMax;
    ULONG ulStripeSizeMin;
    ULONG ulDefaultStripeSize;
    ULONG ulNumberOfColumns;
    ULONG ulNumberOfColumnsMax;
    ULONG ulNumberOfColumnsMin;
    ULONG ulDefaultNumberofColumns;
    ULONG ulDataAvailabilityHint;
    ULONG ulAccessRandomnessHint;
    ULONG ulAccessDirectionHint;
    ULONG ulAccessSizeHint;
    ULONG ulAccessLatencyHint;
    ULONG ulAccessBandwidthWeightHint;
    ULONG ulStorageCostHint;
    ULONG ulStorageEfficiencyHint;
    ULONG ulNumOfCustomAttributes;
    VDS_POOL_CUSTOM_ATTRIBUTES *pPoolCustomAttributes;
    BOOL bReserved1;
    BOOL bReserved2;
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONGLONG ullReserved1;
    ULONGLONG ullReserved2;
    } 	VDS_POOL_ATTRIBUTES;

typedef struct _VDS_POOL_ATTRIBUTES *PVDS_POOL_ATTRIBUTES;

#define	VDS_POOL_ATTRIB_RAIDTYPE	( 0x1L )

#define	VDS_POOL_ATTRIB_BUSTYPE	( 0x2L )

#define	VDS_POOL_ATTRIB_ALLOW_SPINDOWN	( 0x4L )

#define	VDS_POOL_ATTRIB_THIN_PROVISION	( 0x8L )

#define	VDS_POOL_ATTRIB_NO_SINGLE_POF	( 0x10L )

#define	VDS_POOL_ATTRIB_DATA_RDNCY_MAX	( 0x20L )

#define	VDS_POOL_ATTRIB_DATA_RDNCY_MIN	( 0x40L )

#define	VDS_POOL_ATTRIB_DATA_RDNCY_DEF	( 0x80L )

#define	VDS_POOL_ATTRIB_PKG_RDNCY_MAX	( 0x100L )

#define	VDS_POOL_ATTRIB_PKG_RDNCY_MIN	( 0x200L )

#define	VDS_POOL_ATTRIB_PKG_RDNCY_DEF	( 0x400L )

#define	VDS_POOL_ATTRIB_STRIPE_SIZE	( 0x800L )

#define	VDS_POOL_ATTRIB_STRIPE_SIZE_MAX	( 0x1000L )

#define	VDS_POOL_ATTRIB_STRIPE_SIZE_MIN	( 0x2000L )

#define	VDS_POOL_ATTRIB_STRIPE_SIZE_DEF	( 0x4000L )

#define	VDS_POOL_ATTRIB_NUM_CLMNS	( 0x8000L )

#define	VDS_POOL_ATTRIB_NUM_CLMNS_MAX	( 0x10000L )

#define	VDS_POOL_ATTRIB_NUM_CLMNS_MIN	( 0x20000L )

#define	VDS_POOL_ATTRIB_NUM_CLMNS_DEF	( 0x40000L )

#define	VDS_POOL_ATTRIB_DATA_AVL_HINT	( 0x80000L )

#define	VDS_POOL_ATTRIB_ACCS_RNDM_HINT	( 0x100000L )

#define	VDS_POOL_ATTRIB_ACCS_DIR_HINT	( 0x200000L )

#define	VDS_POOL_ATTRIB_ACCS_SIZE_HINT	( 0x400000L )

#define	VDS_POOL_ATTRIB_ACCS_LTNCY_HINT	( 0x800000L )

#define	VDS_POOL_ATTRIB_ACCS_BDW_WT_HINT	( 0x1000000L )

#define	VDS_POOL_ATTRIB_STOR_COST_HINT	( 0x2000000L )

#define	VDS_POOL_ATTRIB_STOR_EFFCY_HINT	( 0x4000000L )

#define	VDS_POOL_ATTRIB_CUSTOM_ATTRIB	( 0x8000000L )

typedef struct _VDS_STORAGE_POOL_PROP
    {
    VDS_OBJECT_ID id;
    VDS_STORAGE_POOL_STATUS status;
    VDS_HEALTH health;
    VDS_STORAGE_POOL_TYPE type;
    LPWSTR pwszName;
    LPWSTR pwszDescription;
    ULONGLONG ullTotalConsumedSpace;
    ULONGLONG ullTotalManagedSpace;
    ULONGLONG ullRemainingFreeSpace;
    } 	VDS_STORAGE_POOL_PROP;

typedef struct _VDS_STORAGE_POOL_PROP *PVDS_STORAGE_POOL_PROP;

typedef struct _VDS_STORAGE_POOL_DRIVE_EXTENT
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    BOOL bUsed;
    } 	VDS_STORAGE_POOL_DRIVE_EXTENT;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0020_v0_0_s_ifspec;

#ifndef __IVdsHwProvider_INTERFACE_DEFINED__
#define __IVdsHwProvider_INTERFACE_DEFINED__

/* interface IVdsHwProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d99bdaae-b13a-4178-9fdb-e27f16b4603e")
    IVdsHwProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QuerySubSystems( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reenumerate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QuerySubSystems )( 
            __RPC__in IVdsHwProvider * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reenumerate )( 
            __RPC__in IVdsHwProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IVdsHwProvider * This);
        
        END_INTERFACE
    } IVdsHwProviderVtbl;

    interface IVdsHwProvider
    {
        CONST_VTBL struct IVdsHwProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProvider_QuerySubSystems(This,ppEnum)	\
    ( (This)->lpVtbl -> QuerySubSystems(This,ppEnum) ) 

#define IVdsHwProvider_Reenumerate(This)	\
    ( (This)->lpVtbl -> Reenumerate(This) ) 

#define IVdsHwProvider_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProvider_INTERFACE_DEFINED__ */


#ifndef __IVdsHwProviderType_INTERFACE_DEFINED__
#define __IVdsHwProviderType_INTERFACE_DEFINED__

/* interface IVdsHwProviderType */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProviderType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3e0f5166-542d-4fc6-947a-012174240b7e")
    IVdsHwProviderType : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProviderType( 
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProviderType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProviderType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProviderType * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProviderType )( 
            __RPC__in IVdsHwProviderType * This,
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType);
        
        END_INTERFACE
    } IVdsHwProviderTypeVtbl;

    interface IVdsHwProviderType
    {
        CONST_VTBL struct IVdsHwProviderTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProviderType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProviderType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProviderType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProviderType_GetProviderType(This,pType)	\
    ( (This)->lpVtbl -> GetProviderType(This,pType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProviderType_INTERFACE_DEFINED__ */


#ifndef __IVdsHwProviderType2_INTERFACE_DEFINED__
#define __IVdsHwProviderType2_INTERFACE_DEFINED__

/* interface IVdsHwProviderType2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProviderType2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8190236f-c4d0-4e81-8011-d69512fcc984")
    IVdsHwProviderType2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProviderType2( 
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderType2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProviderType2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProviderType2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProviderType2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProviderType2 )( 
            __RPC__in IVdsHwProviderType2 * This,
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType);
        
        END_INTERFACE
    } IVdsHwProviderType2Vtbl;

    interface IVdsHwProviderType2
    {
        CONST_VTBL struct IVdsHwProviderType2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProviderType2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProviderType2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProviderType2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProviderType2_GetProviderType2(This,pType)	\
    ( (This)->lpVtbl -> GetProviderType2(This,pType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProviderType2_INTERFACE_DEFINED__ */


#ifndef __IVdsHwProviderStoragePools_INTERFACE_DEFINED__
#define __IVdsHwProviderStoragePools_INTERFACE_DEFINED__

/* interface IVdsHwProviderStoragePools */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProviderStoragePools;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5b5937a-f188-4c79-b86c-11c920ad11b8")
    IVdsHwProviderStoragePools : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryStoragePools( 
            /* [in] */ ULONG ulFlags,
            /* [in] */ ULONGLONG ullRemainingFreeSpace,
            /* [unique][in] */ __RPC__in_opt VDS_POOL_ATTRIBUTES *pPoolAttributes,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateLunInStoragePool( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [in] */ VDS_OBJECT_ID StoragePoolId,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunCreateSizeInStoragePool( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ VDS_OBJECT_ID StoragePoolId,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderStoragePoolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProviderStoragePools * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProviderStoragePools * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProviderStoragePools * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryStoragePools )( 
            __RPC__in IVdsHwProviderStoragePools * This,
            /* [in] */ ULONG ulFlags,
            /* [in] */ ULONGLONG ullRemainingFreeSpace,
            /* [unique][in] */ __RPC__in_opt VDS_POOL_ATTRIBUTES *pPoolAttributes,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateLunInStoragePool )( 
            __RPC__in IVdsHwProviderStoragePools * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [in] */ VDS_OBJECT_ID StoragePoolId,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunCreateSizeInStoragePool )( 
            __RPC__in IVdsHwProviderStoragePools * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ VDS_OBJECT_ID StoragePoolId,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize);
        
        END_INTERFACE
    } IVdsHwProviderStoragePoolsVtbl;

    interface IVdsHwProviderStoragePools
    {
        CONST_VTBL struct IVdsHwProviderStoragePoolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProviderStoragePools_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProviderStoragePools_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProviderStoragePools_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProviderStoragePools_QueryStoragePools(This,ulFlags,ullRemainingFreeSpace,pPoolAttributes,ppEnum)	\
    ( (This)->lpVtbl -> QueryStoragePools(This,ulFlags,ullRemainingFreeSpace,pPoolAttributes,ppEnum) ) 

#define IVdsHwProviderStoragePools_CreateLunInStoragePool(This,type,ullSizeInBytes,StoragePoolId,pwszUnmaskingList,pHints2,ppAsync)	\
    ( (This)->lpVtbl -> CreateLunInStoragePool(This,type,ullSizeInBytes,StoragePoolId,pwszUnmaskingList,pHints2,ppAsync) ) 

#define IVdsHwProviderStoragePools_QueryMaxLunCreateSizeInStoragePool(This,type,StoragePoolId,pHints2,pullMaxLunSize)	\
    ( (This)->lpVtbl -> QueryMaxLunCreateSizeInStoragePool(This,type,StoragePoolId,pHints2,pullMaxLunSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProviderStoragePools_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystem_INTERFACE_DEFINED__
#define __IVdsSubSystem_INTERFACE_DEFINED__

/* interface IVdsSubSystem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6fcee2d3-6d90-4f91-80e2-a5c7caaca9d8")
    IVdsSubSystem : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP *pSubSystemProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryControllers( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDrives( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDrive( 
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reenumerate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControllerStatus( 
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOnlineControllers) VDS_OBJECT_ID *pOnlineControllerIdArray,
            /* [in] */ LONG lNumberOfOnlineControllers,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOfflineControllers) VDS_OBJECT_ID *pOfflineControllerIdArray,
            /* [in] */ LONG lNumberOfOfflineControllers) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateLun( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReplaceDrive( 
            /* [in] */ VDS_OBJECT_ID DriveToBeReplaced,
            /* [in] */ VDS_OBJECT_ID ReplacementDrive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_SUB_SYSTEM_STATUS status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunCreateSize( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP *pSubSystemProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProvider )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryControllers )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryLuns )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDrives )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDrive )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reenumerate )( 
            __RPC__in IVdsSubSystem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetControllerStatus )( 
            __RPC__in IVdsSubSystem * This,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOnlineControllers) VDS_OBJECT_ID *pOnlineControllerIdArray,
            /* [in] */ LONG lNumberOfOnlineControllers,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOfflineControllers) VDS_OBJECT_ID *pOfflineControllerIdArray,
            /* [in] */ LONG lNumberOfOfflineControllers);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateLun )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReplaceDrive )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ VDS_OBJECT_ID DriveToBeReplaced,
            /* [in] */ VDS_OBJECT_ID ReplacementDrive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ VDS_SUB_SYSTEM_STATUS status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunCreateSize )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize);
        
        END_INTERFACE
    } IVdsSubSystemVtbl;

    interface IVdsSubSystem
    {
        CONST_VTBL struct IVdsSubSystemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystem_GetProperties(This,pSubSystemProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pSubSystemProp) ) 

#define IVdsSubSystem_GetProvider(This,ppProvider)	\
    ( (This)->lpVtbl -> GetProvider(This,ppProvider) ) 

#define IVdsSubSystem_QueryControllers(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryControllers(This,ppEnum) ) 

#define IVdsSubSystem_QueryLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryLuns(This,ppEnum) ) 

#define IVdsSubSystem_QueryDrives(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryDrives(This,ppEnum) ) 

#define IVdsSubSystem_GetDrive(This,sBusNumber,sSlotNumber,ppDrive)	\
    ( (This)->lpVtbl -> GetDrive(This,sBusNumber,sSlotNumber,ppDrive) ) 

#define IVdsSubSystem_Reenumerate(This)	\
    ( (This)->lpVtbl -> Reenumerate(This) ) 

#define IVdsSubSystem_SetControllerStatus(This,pOnlineControllerIdArray,lNumberOfOnlineControllers,pOfflineControllerIdArray,lNumberOfOfflineControllers)	\
    ( (This)->lpVtbl -> SetControllerStatus(This,pOnlineControllerIdArray,lNumberOfOnlineControllers,pOfflineControllerIdArray,lNumberOfOfflineControllers) ) 

#define IVdsSubSystem_CreateLun(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints,ppAsync)	\
    ( (This)->lpVtbl -> CreateLun(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints,ppAsync) ) 

#define IVdsSubSystem_ReplaceDrive(This,DriveToBeReplaced,ReplacementDrive)	\
    ( (This)->lpVtbl -> ReplaceDrive(This,DriveToBeReplaced,ReplacementDrive) ) 

#define IVdsSubSystem_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#define IVdsSubSystem_QueryMaxLunCreateSize(This,type,pDriveIdArray,lNumberOfDrives,pHints,pullMaxLunSize)	\
    ( (This)->lpVtbl -> QueryMaxLunCreateSize(This,type,pDriveIdArray,lNumberOfDrives,pHints,pullMaxLunSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystem_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystem2_INTERFACE_DEFINED__
#define __IVdsSubSystem2_INTERFACE_DEFINED__

/* interface IVdsSubSystem2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("be666735-7800-4a77-9d9c-40f85b87e292")
    IVdsSubSystem2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties2( 
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP2 *pSubSystemProp2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDrive2( 
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [in] */ ULONG ulEnclosureNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateLun2( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunCreateSize2( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystem2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties2 )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP2 *pSubSystemProp2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDrive2 )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [in] */ ULONG ulEnclosureNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateLun2 )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunCreateSize2 )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize);
        
        END_INTERFACE
    } IVdsSubSystem2Vtbl;

    interface IVdsSubSystem2
    {
        CONST_VTBL struct IVdsSubSystem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystem2_GetProperties2(This,pSubSystemProp2)	\
    ( (This)->lpVtbl -> GetProperties2(This,pSubSystemProp2) ) 

#define IVdsSubSystem2_GetDrive2(This,sBusNumber,sSlotNumber,ulEnclosureNumber,ppDrive)	\
    ( (This)->lpVtbl -> GetDrive2(This,sBusNumber,sSlotNumber,ulEnclosureNumber,ppDrive) ) 

#define IVdsSubSystem2_CreateLun2(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints2,ppAsync)	\
    ( (This)->lpVtbl -> CreateLun2(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints2,ppAsync) ) 

#define IVdsSubSystem2_QueryMaxLunCreateSize2(This,type,pDriveIdArray,lNumberOfDrives,pHints2,pullMaxLunSize)	\
    ( (This)->lpVtbl -> QueryMaxLunCreateSize2(This,type,pDriveIdArray,lNumberOfDrives,pHints2,pullMaxLunSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystem2_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemNaming_INTERFACE_DEFINED__
#define __IVdsSubSystemNaming_INTERFACE_DEFINED__

/* interface IVdsSubSystemNaming */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemNaming;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d70faa3-9cd4-4900-aa20-6981b6aafc75")
    IVdsSubSystemNaming : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemNamingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystemNaming * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystemNaming * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystemNaming * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            __RPC__in IVdsSubSystemNaming * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName);
        
        END_INTERFACE
    } IVdsSubSystemNamingVtbl;

    interface IVdsSubSystemNaming
    {
        CONST_VTBL struct IVdsSubSystemNamingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemNaming_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemNaming_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemNaming_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemNaming_SetFriendlyName(This,pwszFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwszFriendlyName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemNaming_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemIscsi_INTERFACE_DEFINED__
#define __IVdsSubSystemIscsi_INTERFACE_DEFINED__

/* interface IVdsSubSystemIscsi */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemIscsi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0027346f-40d0-4b45-8cec-5906dc0380c8")
    IVdsSubSystemIscsi : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryTargets( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPortals( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateTarget( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszIscsiName,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecGroupPresharedKey( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemIscsiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystemIscsi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystemIscsi * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryTargets )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPortals )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateTarget )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszIscsiName,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecGroupPresharedKey )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsSubSystemIscsiVtbl;

    interface IVdsSubSystemIscsi
    {
        CONST_VTBL struct IVdsSubSystemIscsiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemIscsi_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemIscsi_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemIscsi_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemIscsi_QueryTargets(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryTargets(This,ppEnum) ) 

#define IVdsSubSystemIscsi_QueryPortals(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPortals(This,ppEnum) ) 

#define IVdsSubSystemIscsi_CreateTarget(This,pwszIscsiName,pwszFriendlyName,ppAsync)	\
    ( (This)->lpVtbl -> CreateTarget(This,pwszIscsiName,pwszFriendlyName,ppAsync) ) 

#define IVdsSubSystemIscsi_SetIpsecGroupPresharedKey(This,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecGroupPresharedKey(This,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemIscsi_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemInterconnect_INTERFACE_DEFINED__
#define __IVdsSubSystemInterconnect_INTERFACE_DEFINED__

/* interface IVdsSubSystemInterconnect */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemInterconnect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e6fa560-c141-477b-83ba-0b6c38f7febf")
    IVdsSubSystemInterconnect : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSupportedInterconnects( 
            /* [out] */ __RPC__out ULONG *pulSupportedInterconnectsFlag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemInterconnectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystemInterconnect * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystemInterconnect * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystemInterconnect * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedInterconnects )( 
            __RPC__in IVdsSubSystemInterconnect * This,
            /* [out] */ __RPC__out ULONG *pulSupportedInterconnectsFlag);
        
        END_INTERFACE
    } IVdsSubSystemInterconnectVtbl;

    interface IVdsSubSystemInterconnect
    {
        CONST_VTBL struct IVdsSubSystemInterconnectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemInterconnect_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemInterconnect_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemInterconnect_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemInterconnect_GetSupportedInterconnects(This,pulSupportedInterconnectsFlag)	\
    ( (This)->lpVtbl -> GetSupportedInterconnects(This,pulSupportedInterconnectsFlag) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemInterconnect_INTERFACE_DEFINED__ */


#ifndef __IVdsControllerPort_INTERFACE_DEFINED__
#define __IVdsControllerPort_INTERFACE_DEFINED__

/* interface IVdsControllerPort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsControllerPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18691d0d-4e7f-43e8-92e4-cf44beeed11c")
    IVdsControllerPort : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetController( 
            /* [out] */ __RPC__deref_out_opt IVdsController **ppController) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_PORT_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsControllerPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsControllerPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsControllerPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsControllerPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsControllerPort * This,
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetController )( 
            __RPC__in IVdsControllerPort * This,
            /* [out] */ __RPC__deref_out_opt IVdsController **ppController);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedLuns )( 
            __RPC__in IVdsControllerPort * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IVdsControllerPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsControllerPort * This,
            /* [in] */ VDS_PORT_STATUS status);
        
        END_INTERFACE
    } IVdsControllerPortVtbl;

    interface IVdsControllerPort
    {
        CONST_VTBL struct IVdsControllerPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsControllerPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsControllerPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsControllerPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsControllerPort_GetProperties(This,pPortProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPortProp) ) 

#define IVdsControllerPort_GetController(This,ppController)	\
    ( (This)->lpVtbl -> GetController(This,ppController) ) 

#define IVdsControllerPort_QueryAssociatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedLuns(This,ppEnum) ) 

#define IVdsControllerPort_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IVdsControllerPort_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsControllerPort_INTERFACE_DEFINED__ */


#ifndef __IVdsController_INTERFACE_DEFINED__
#define __IVdsController_INTERFACE_DEFINED__

/* interface IVdsController */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsController;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cb53d96e-dffb-474a-a078-790d1e2bc082")
    IVdsController : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_CONTROLLER_PROP *pControllerProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPortProperties( 
            /* [in] */ SHORT sPortNumber,
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FlushCache( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvalidateCache( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_CONTROLLER_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsControllerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsController * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsController * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsController * This,
            /* [out] */ __RPC__out VDS_CONTROLLER_PROP *pControllerProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsController * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPortProperties )( 
            __RPC__in IVdsController * This,
            /* [in] */ SHORT sPortNumber,
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FlushCache )( 
            __RPC__in IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InvalidateCache )( 
            __RPC__in IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedLuns )( 
            __RPC__in IVdsController * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsController * This,
            /* [in] */ VDS_CONTROLLER_STATUS status);
        
        END_INTERFACE
    } IVdsControllerVtbl;

    interface IVdsController
    {
        CONST_VTBL struct IVdsControllerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsController_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsController_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsController_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsController_GetProperties(This,pControllerProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pControllerProp) ) 

#define IVdsController_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsController_GetPortProperties(This,sPortNumber,pPortProp)	\
    ( (This)->lpVtbl -> GetPortProperties(This,sPortNumber,pPortProp) ) 

#define IVdsController_FlushCache(This)	\
    ( (This)->lpVtbl -> FlushCache(This) ) 

#define IVdsController_InvalidateCache(This)	\
    ( (This)->lpVtbl -> InvalidateCache(This) ) 

#define IVdsController_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IVdsController_QueryAssociatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedLuns(This,ppEnum) ) 

#define IVdsController_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsController_INTERFACE_DEFINED__ */


#ifndef __IVdsControllerControllerPort_INTERFACE_DEFINED__
#define __IVdsControllerControllerPort_INTERFACE_DEFINED__

/* interface IVdsControllerControllerPort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsControllerControllerPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ca5d735f-6bae-42c0-b30e-f2666045ce71")
    IVdsControllerControllerPort : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryControllerPorts( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsControllerControllerPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsControllerControllerPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsControllerControllerPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsControllerControllerPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryControllerPorts )( 
            __RPC__in IVdsControllerControllerPort * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsControllerControllerPortVtbl;

    interface IVdsControllerControllerPort
    {
        CONST_VTBL struct IVdsControllerControllerPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsControllerControllerPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsControllerControllerPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsControllerControllerPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsControllerControllerPort_QueryControllerPorts(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryControllerPorts(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsControllerControllerPort_INTERFACE_DEFINED__ */


#ifndef __IVdsDrive_INTERFACE_DEFINED__
#define __IVdsDrive_INTERFACE_DEFINED__

/* interface IVdsDrive */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDrive;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ff24efa4-aade-4b6b-898b-eaa6a20887c7")
    IVdsDrive : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_DRIVE_PROP *pDriveProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_DRIVE_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDriveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDrive * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDrive * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDrive * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsDrive * This,
            /* [out] */ __RPC__out VDS_DRIVE_PROP *pDriveProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsDrive * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            __RPC__in IVdsDrive * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in IVdsDrive * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            __RPC__in IVdsDrive * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsDrive * This,
            /* [in] */ VDS_DRIVE_STATUS status);
        
        END_INTERFACE
    } IVdsDriveVtbl;

    interface IVdsDrive
    {
        CONST_VTBL struct IVdsDriveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDrive_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDrive_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDrive_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDrive_GetProperties(This,pDriveProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pDriveProp) ) 

#define IVdsDrive_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsDrive_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsDrive_SetFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags) ) 

#define IVdsDrive_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#define IVdsDrive_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDrive_INTERFACE_DEFINED__ */


#ifndef __IVdsDrive2_INTERFACE_DEFINED__
#define __IVdsDrive2_INTERFACE_DEFINED__

/* interface IVdsDrive2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDrive2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60b5a730-addf-4436-8ca7-5769e2d1ffa4")
    IVdsDrive2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties2( 
            /* [out] */ __RPC__out VDS_DRIVE_PROP2 *pDriveProp2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDrive2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDrive2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDrive2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDrive2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties2 )( 
            __RPC__in IVdsDrive2 * This,
            /* [out] */ __RPC__out VDS_DRIVE_PROP2 *pDriveProp2);
        
        END_INTERFACE
    } IVdsDrive2Vtbl;

    interface IVdsDrive2
    {
        CONST_VTBL struct IVdsDrive2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDrive2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDrive2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDrive2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDrive2_GetProperties2(This,pDriveProp2)	\
    ( (This)->lpVtbl -> GetProperties2(This,pDriveProp2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDrive2_INTERFACE_DEFINED__ */


#ifndef __IVdsLun_INTERFACE_DEFINED__
#define __IVdsLun_INTERFACE_DEFINED__

/* interface IVdsLun */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLun;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3540a9c7-e60f-4111-a840-8bba6c2c83d8")
    IVdsLun : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_LUN_PROP *pLunProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIdentificationData( 
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryActiveControllers( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Extend( 
            /* [in] */ ULONGLONG ullNumberOfBytesToAdd,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shrink( 
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPlexes( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPlex( 
            /* [in] */ VDS_OBJECT_ID lunId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePlex( 
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Recover( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMask( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssociateControllers( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllers) VDS_OBJECT_ID *pActiveControllerIdArray,
            /* [in] */ LONG lNumberOfActiveControllers,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllers) VDS_OBJECT_ID *pInactiveControllerIdArray,
            /* [in] */ LONG lNumberOfInactiveControllers) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHints( 
            /* [out] */ __RPC__out VDS_HINTS *pHints) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ApplyHints( 
            /* [in] */ __RPC__in VDS_HINTS *pHints) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_LUN_STATUS status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunExtendSize( 
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__out ULONGLONG *pullMaxBytesToBeAdded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLun * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLun * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLun * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__out VDS_LUN_PROP *pLunProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIdentificationData )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryActiveControllers )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Extend )( 
            __RPC__in IVdsLun * This,
            /* [in] */ ULONGLONG ullNumberOfBytesToAdd,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shrink )( 
            __RPC__in IVdsLun * This,
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPlexes )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPlex )( 
            __RPC__in IVdsLun * This,
            /* [in] */ VDS_OBJECT_ID lunId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePlex )( 
            __RPC__in IVdsLun * This,
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Recover )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMask )( 
            __RPC__in IVdsLun * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IVdsLun * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssociateControllers )( 
            __RPC__in IVdsLun * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllers) VDS_OBJECT_ID *pActiveControllerIdArray,
            /* [in] */ LONG lNumberOfActiveControllers,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllers) VDS_OBJECT_ID *pInactiveControllerIdArray,
            /* [in] */ LONG lNumberOfInactiveControllers);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHints )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__out VDS_HINTS *pHints);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ApplyHints )( 
            __RPC__in IVdsLun * This,
            /* [in] */ __RPC__in VDS_HINTS *pHints);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsLun * This,
            /* [in] */ VDS_LUN_STATUS status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunExtendSize )( 
            __RPC__in IVdsLun * This,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__out ULONGLONG *pullMaxBytesToBeAdded);
        
        END_INTERFACE
    } IVdsLunVtbl;

    interface IVdsLun
    {
        CONST_VTBL struct IVdsLunVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLun_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLun_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLun_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLun_GetProperties(This,pLunProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pLunProp) ) 

#define IVdsLun_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsLun_GetIdentificationData(This,pLunInfo)	\
    ( (This)->lpVtbl -> GetIdentificationData(This,pLunInfo) ) 

#define IVdsLun_QueryActiveControllers(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryActiveControllers(This,ppEnum) ) 

#define IVdsLun_Extend(This,ullNumberOfBytesToAdd,pDriveIdArray,lNumberOfDrives,ppAsync)	\
    ( (This)->lpVtbl -> Extend(This,ullNumberOfBytesToAdd,pDriveIdArray,lNumberOfDrives,ppAsync) ) 

#define IVdsLun_Shrink(This,ullNumberOfBytesToRemove,ppAsync)	\
    ( (This)->lpVtbl -> Shrink(This,ullNumberOfBytesToRemove,ppAsync) ) 

#define IVdsLun_QueryPlexes(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPlexes(This,ppEnum) ) 

#define IVdsLun_AddPlex(This,lunId,ppAsync)	\
    ( (This)->lpVtbl -> AddPlex(This,lunId,ppAsync) ) 

#define IVdsLun_RemovePlex(This,plexId,ppAsync)	\
    ( (This)->lpVtbl -> RemovePlex(This,plexId,ppAsync) ) 

#define IVdsLun_Recover(This,ppAsync)	\
    ( (This)->lpVtbl -> Recover(This,ppAsync) ) 

#define IVdsLun_SetMask(This,pwszUnmaskingList)	\
    ( (This)->lpVtbl -> SetMask(This,pwszUnmaskingList) ) 

#define IVdsLun_Delete(This)	\
    ( (This)->lpVtbl -> Delete(This) ) 

#define IVdsLun_AssociateControllers(This,pActiveControllerIdArray,lNumberOfActiveControllers,pInactiveControllerIdArray,lNumberOfInactiveControllers)	\
    ( (This)->lpVtbl -> AssociateControllers(This,pActiveControllerIdArray,lNumberOfActiveControllers,pInactiveControllerIdArray,lNumberOfInactiveControllers) ) 

#define IVdsLun_QueryHints(This,pHints)	\
    ( (This)->lpVtbl -> QueryHints(This,pHints) ) 

#define IVdsLun_ApplyHints(This,pHints)	\
    ( (This)->lpVtbl -> ApplyHints(This,pHints) ) 

#define IVdsLun_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#define IVdsLun_QueryMaxLunExtendSize(This,pDriveIdArray,lNumberOfDrives,pullMaxBytesToBeAdded)	\
    ( (This)->lpVtbl -> QueryMaxLunExtendSize(This,pDriveIdArray,lNumberOfDrives,pullMaxBytesToBeAdded) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLun_INTERFACE_DEFINED__ */


#ifndef __IVdsLun2_INTERFACE_DEFINED__
#define __IVdsLun2_INTERFACE_DEFINED__

/* interface IVdsLun2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLun2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e5b3a735-9efb-499a-8071-4394d9ee6fcb")
    IVdsLun2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHints2( 
            /* [out] */ __RPC__out VDS_HINTS2 *pHints2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ApplyHints2( 
            /* [in] */ __RPC__in VDS_HINTS2 *pHints2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLun2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLun2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLun2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLun2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHints2 )( 
            __RPC__in IVdsLun2 * This,
            /* [out] */ __RPC__out VDS_HINTS2 *pHints2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ApplyHints2 )( 
            __RPC__in IVdsLun2 * This,
            /* [in] */ __RPC__in VDS_HINTS2 *pHints2);
        
        END_INTERFACE
    } IVdsLun2Vtbl;

    interface IVdsLun2
    {
        CONST_VTBL struct IVdsLun2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLun2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLun2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLun2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLun2_QueryHints2(This,pHints2)	\
    ( (This)->lpVtbl -> QueryHints2(This,pHints2) ) 

#define IVdsLun2_ApplyHints2(This,pHints2)	\
    ( (This)->lpVtbl -> ApplyHints2(This,pHints2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLun2_INTERFACE_DEFINED__ */


#ifndef __IVdsLunNaming_INTERFACE_DEFINED__
#define __IVdsLunNaming_INTERFACE_DEFINED__

/* interface IVdsLunNaming */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunNaming;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("907504cb-6b4e-4d88-a34d-17ba661fbb06")
    IVdsLunNaming : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunNamingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunNaming * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunNaming * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunNaming * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            __RPC__in IVdsLunNaming * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName);
        
        END_INTERFACE
    } IVdsLunNamingVtbl;

    interface IVdsLunNaming
    {
        CONST_VTBL struct IVdsLunNamingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunNaming_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunNaming_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunNaming_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunNaming_SetFriendlyName(This,pwszFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwszFriendlyName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunNaming_INTERFACE_DEFINED__ */


#ifndef __IVdsLunNumber_INTERFACE_DEFINED__
#define __IVdsLunNumber_INTERFACE_DEFINED__

/* interface IVdsLunNumber */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunNumber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d3f95e46-54b3-41f9-b678-0f1871443a08")
    IVdsLunNumber : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLunNumber( 
            /* [out] */ __RPC__out ULONG *pulLunNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunNumberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunNumber * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunNumber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunNumber * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLunNumber )( 
            __RPC__in IVdsLunNumber * This,
            /* [out] */ __RPC__out ULONG *pulLunNumber);
        
        END_INTERFACE
    } IVdsLunNumberVtbl;

    interface IVdsLunNumber
    {
        CONST_VTBL struct IVdsLunNumberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunNumber_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunNumber_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunNumber_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunNumber_GetLunNumber(This,pulLunNumber)	\
    ( (This)->lpVtbl -> GetLunNumber(This,pulLunNumber) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunNumber_INTERFACE_DEFINED__ */


#ifndef __IVdsLunControllerPorts_INTERFACE_DEFINED__
#define __IVdsLunControllerPorts_INTERFACE_DEFINED__

/* interface IVdsLunControllerPorts */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunControllerPorts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("451fe266-da6d-406a-bb60-82e534f85aeb")
    IVdsLunControllerPorts : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssociateControllerPorts( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllerPorts) VDS_OBJECT_ID *pActiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfActiveControllerPorts,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllerPorts) VDS_OBJECT_ID *pInactiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfInactiveControllerPorts) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryActiveControllerPorts( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunControllerPortsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunControllerPorts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunControllerPorts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunControllerPorts * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssociateControllerPorts )( 
            __RPC__in IVdsLunControllerPorts * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllerPorts) VDS_OBJECT_ID *pActiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfActiveControllerPorts,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllerPorts) VDS_OBJECT_ID *pInactiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfInactiveControllerPorts);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryActiveControllerPorts )( 
            __RPC__in IVdsLunControllerPorts * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsLunControllerPortsVtbl;

    interface IVdsLunControllerPorts
    {
        CONST_VTBL struct IVdsLunControllerPortsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunControllerPorts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunControllerPorts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunControllerPorts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunControllerPorts_AssociateControllerPorts(This,pActiveControllerPortIdArray,lNumberOfActiveControllerPorts,pInactiveControllerPortIdArray,lNumberOfInactiveControllerPorts)	\
    ( (This)->lpVtbl -> AssociateControllerPorts(This,pActiveControllerPortIdArray,lNumberOfActiveControllerPorts,pInactiveControllerPortIdArray,lNumberOfInactiveControllerPorts) ) 

#define IVdsLunControllerPorts_QueryActiveControllerPorts(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryActiveControllerPorts(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunControllerPorts_INTERFACE_DEFINED__ */


#ifndef __IVdsLunMpio_INTERFACE_DEFINED__
#define __IVdsLunMpio_INTERFACE_DEFINED__

/* interface IVdsLunMpio */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunMpio;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c5fbae3-333a-48a1-a982-33c15788cde3")
    IVdsLunMpio : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPathInfo( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_INFO **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLoadBalancePolicy( 
            /* [out] */ __RPC__out VDS_LOADBALANCE_POLICY_ENUM *pPolicy,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_POLICY **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetLoadBalancePolicy( 
            /* [in] */ VDS_LOADBALANCE_POLICY_ENUM policy,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfPaths) VDS_PATH_POLICY *pPaths,
            /* [in] */ LONG lNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSupportedLbPolicies( 
            /* [out] */ __RPC__out ULONG *pulLbFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunMpioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunMpio * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunMpio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunMpio * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPathInfo )( 
            __RPC__in IVdsLunMpio * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_INFO **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLoadBalancePolicy )( 
            __RPC__in IVdsLunMpio * This,
            /* [out] */ __RPC__out VDS_LOADBALANCE_POLICY_ENUM *pPolicy,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_POLICY **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetLoadBalancePolicy )( 
            __RPC__in IVdsLunMpio * This,
            /* [in] */ VDS_LOADBALANCE_POLICY_ENUM policy,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfPaths) VDS_PATH_POLICY *pPaths,
            /* [in] */ LONG lNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSupportedLbPolicies )( 
            __RPC__in IVdsLunMpio * This,
            /* [out] */ __RPC__out ULONG *pulLbFlags);
        
        END_INTERFACE
    } IVdsLunMpioVtbl;

    interface IVdsLunMpio
    {
        CONST_VTBL struct IVdsLunMpioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunMpio_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunMpio_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunMpio_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunMpio_GetPathInfo(This,ppPaths,plNumberOfPaths)	\
    ( (This)->lpVtbl -> GetPathInfo(This,ppPaths,plNumberOfPaths) ) 

#define IVdsLunMpio_GetLoadBalancePolicy(This,pPolicy,ppPaths,plNumberOfPaths)	\
    ( (This)->lpVtbl -> GetLoadBalancePolicy(This,pPolicy,ppPaths,plNumberOfPaths) ) 

#define IVdsLunMpio_SetLoadBalancePolicy(This,policy,pPaths,lNumberOfPaths)	\
    ( (This)->lpVtbl -> SetLoadBalancePolicy(This,policy,pPaths,lNumberOfPaths) ) 

#define IVdsLunMpio_GetSupportedLbPolicies(This,pulLbFlags)	\
    ( (This)->lpVtbl -> GetSupportedLbPolicies(This,pulLbFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunMpio_INTERFACE_DEFINED__ */


#ifndef __IVdsLunIscsi_INTERFACE_DEFINED__
#define __IVdsLunIscsi_INTERFACE_DEFINED__

/* interface IVdsLunIscsi */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunIscsi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d7c1e64-b59b-45ae-b86a-2c2cc6a42067")
    IVdsLunIscsi : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssociateTargets( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfTargets) VDS_OBJECT_ID *pTargetIdArray,
            /* [in] */ LONG lNumberOfTargets) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedTargets( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunIscsiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunIscsi * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunIscsi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunIscsi * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssociateTargets )( 
            __RPC__in IVdsLunIscsi * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfTargets) VDS_OBJECT_ID *pTargetIdArray,
            /* [in] */ LONG lNumberOfTargets);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedTargets )( 
            __RPC__in IVdsLunIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsLunIscsiVtbl;

    interface IVdsLunIscsi
    {
        CONST_VTBL struct IVdsLunIscsiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunIscsi_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunIscsi_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunIscsi_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunIscsi_AssociateTargets(This,pTargetIdArray,lNumberOfTargets)	\
    ( (This)->lpVtbl -> AssociateTargets(This,pTargetIdArray,lNumberOfTargets) ) 

#define IVdsLunIscsi_QueryAssociatedTargets(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedTargets(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunIscsi_INTERFACE_DEFINED__ */


#ifndef __IVdsLunPlex_INTERFACE_DEFINED__
#define __IVdsLunPlex_INTERFACE_DEFINED__

/* interface IVdsLunPlex */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunPlex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0ee1a790-5d2e-4abb-8c99-c481e8be2138")
    IVdsLunPlex : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_LUN_PLEX_PROP *pPlexProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLun( 
            /* [out] */ __RPC__deref_out_opt IVdsLun **ppLun) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHints( 
            /* [out] */ __RPC__out VDS_HINTS *pHints) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ApplyHints( 
            /* [in] */ __RPC__in VDS_HINTS *pHints) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunPlexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunPlex * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunPlex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunPlex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsLunPlex * This,
            /* [out] */ __RPC__out VDS_LUN_PLEX_PROP *pPlexProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLun )( 
            __RPC__in IVdsLunPlex * This,
            /* [out] */ __RPC__deref_out_opt IVdsLun **ppLun);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            __RPC__in IVdsLunPlex * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHints )( 
            __RPC__in IVdsLunPlex * This,
            /* [out] */ __RPC__out VDS_HINTS *pHints);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ApplyHints )( 
            __RPC__in IVdsLunPlex * This,
            /* [in] */ __RPC__in VDS_HINTS *pHints);
        
        END_INTERFACE
    } IVdsLunPlexVtbl;

    interface IVdsLunPlex
    {
        CONST_VTBL struct IVdsLunPlexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunPlex_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunPlex_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunPlex_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunPlex_GetProperties(This,pPlexProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPlexProp) ) 

#define IVdsLunPlex_GetLun(This,ppLun)	\
    ( (This)->lpVtbl -> GetLun(This,ppLun) ) 

#define IVdsLunPlex_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsLunPlex_QueryHints(This,pHints)	\
    ( (This)->lpVtbl -> QueryHints(This,pHints) ) 

#define IVdsLunPlex_ApplyHints(This,pHints)	\
    ( (This)->lpVtbl -> ApplyHints(This,pHints) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunPlex_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiPortal_INTERFACE_DEFINED__
#define __IVdsIscsiPortal_INTERFACE_DEFINED__

/* interface IVdsIscsiPortal */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiPortal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7fa1499d-ec85-4a8a-a47b-ff69201fcd34")
    IVdsIscsiPortal : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_PORTAL_PROP *pPortalProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedPortalGroups( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_ISCSI_PORTAL_STATUS status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecTunnelAddress( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIpsecSecurity( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecSecurity( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiPortalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiPortal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiPortal * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [out] */ __RPC__out VDS_ISCSI_PORTAL_PROP *pPortalProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedPortalGroups )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ VDS_ISCSI_PORTAL_STATUS status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecTunnelAddress )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIpsecSecurity )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecSecurity )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsIscsiPortalVtbl;

    interface IVdsIscsiPortal
    {
        CONST_VTBL struct IVdsIscsiPortalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiPortal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiPortal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiPortal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiPortal_GetProperties(This,pPortalProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPortalProp) ) 

#define IVdsIscsiPortal_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsIscsiPortal_QueryAssociatedPortalGroups(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedPortalGroups(This,ppEnum) ) 

#define IVdsIscsiPortal_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#define IVdsIscsiPortal_SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress)	\
    ( (This)->lpVtbl -> SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress) ) 

#define IVdsIscsiPortal_GetIpsecSecurity(This,pInitiatorPortalAddress,pullSecurityFlags)	\
    ( (This)->lpVtbl -> GetIpsecSecurity(This,pInitiatorPortalAddress,pullSecurityFlags) ) 

#define IVdsIscsiPortal_SetIpsecSecurity(This,pInitiatorPortalAddress,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecSecurity(This,pInitiatorPortalAddress,ullSecurityFlags,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiPortal_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiTarget_INTERFACE_DEFINED__
#define __IVdsIscsiTarget_INTERFACE_DEFINED__

/* interface IVdsIscsiTarget */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa8f5055-83e5-4bcc-aa73-19851a36a849")
    IVdsIscsiTarget : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_TARGET_PROP *pTargetProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPortalGroups( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePortalGroup( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSharedSecret( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszInitiatorName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RememberInitiatorSharedSecret( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszInitiatorName,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetConnectedInitiators( 
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfInitiators) LPWSTR **pppwszInitiatorList,
            /* [out] */ __RPC__out LONG *plNumberOfInitiators) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiTarget * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__out VDS_ISCSI_TARGET_PROP *pTargetProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPortalGroups )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedLuns )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePortalGroup )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSharedSecret )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszInitiatorName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RememberInitiatorSharedSecret )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszInitiatorName,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetConnectedInitiators )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfInitiators) LPWSTR **pppwszInitiatorList,
            /* [out] */ __RPC__out LONG *plNumberOfInitiators);
        
        END_INTERFACE
    } IVdsIscsiTargetVtbl;

    interface IVdsIscsiTarget
    {
        CONST_VTBL struct IVdsIscsiTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiTarget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiTarget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiTarget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiTarget_GetProperties(This,pTargetProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pTargetProp) ) 

#define IVdsIscsiTarget_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsIscsiTarget_QueryPortalGroups(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPortalGroups(This,ppEnum) ) 

#define IVdsIscsiTarget_QueryAssociatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedLuns(This,ppEnum) ) 

#define IVdsIscsiTarget_CreatePortalGroup(This,ppAsync)	\
    ( (This)->lpVtbl -> CreatePortalGroup(This,ppAsync) ) 

#define IVdsIscsiTarget_Delete(This,ppAsync)	\
    ( (This)->lpVtbl -> Delete(This,ppAsync) ) 

#define IVdsIscsiTarget_SetFriendlyName(This,pwszFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwszFriendlyName) ) 

#define IVdsIscsiTarget_SetSharedSecret(This,pTargetSharedSecret,pwszInitiatorName)	\
    ( (This)->lpVtbl -> SetSharedSecret(This,pTargetSharedSecret,pwszInitiatorName) ) 

#define IVdsIscsiTarget_RememberInitiatorSharedSecret(This,pwszInitiatorName,pInitiatorSharedSecret)	\
    ( (This)->lpVtbl -> RememberInitiatorSharedSecret(This,pwszInitiatorName,pInitiatorSharedSecret) ) 

#define IVdsIscsiTarget_GetConnectedInitiators(This,pppwszInitiatorList,plNumberOfInitiators)	\
    ( (This)->lpVtbl -> GetConnectedInitiators(This,pppwszInitiatorList,plNumberOfInitiators) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiTarget_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiPortalGroup_INTERFACE_DEFINED__
#define __IVdsIscsiPortalGroup_INTERFACE_DEFINED__

/* interface IVdsIscsiPortalGroup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiPortalGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fef5f89d-a3dd-4b36-bf28-e7dde045c593")
    IVdsIscsiPortalGroup : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_PORTALGROUP_PROP *pPortalGroupProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTarget( 
            /* [out] */ __RPC__deref_out_opt IVdsIscsiTarget **ppTarget) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedPortals( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPortal( 
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePortal( 
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiPortalGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiPortalGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiPortalGroup * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__out VDS_ISCSI_PORTALGROUP_PROP *pPortalGroupProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTarget )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__deref_out_opt IVdsIscsiTarget **ppTarget);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedPortals )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPortal )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePortal )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsIscsiPortalGroupVtbl;

    interface IVdsIscsiPortalGroup
    {
        CONST_VTBL struct IVdsIscsiPortalGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiPortalGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiPortalGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiPortalGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiPortalGroup_GetProperties(This,pPortalGroupProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPortalGroupProp) ) 

#define IVdsIscsiPortalGroup_GetTarget(This,ppTarget)	\
    ( (This)->lpVtbl -> GetTarget(This,ppTarget) ) 

#define IVdsIscsiPortalGroup_QueryAssociatedPortals(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedPortals(This,ppEnum) ) 

#define IVdsIscsiPortalGroup_AddPortal(This,portalId,ppAsync)	\
    ( (This)->lpVtbl -> AddPortal(This,portalId,ppAsync) ) 

#define IVdsIscsiPortalGroup_RemovePortal(This,portalId,ppAsync)	\
    ( (This)->lpVtbl -> RemovePortal(This,portalId,ppAsync) ) 

#define IVdsIscsiPortalGroup_Delete(This,ppAsync)	\
    ( (This)->lpVtbl -> Delete(This,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiPortalGroup_INTERFACE_DEFINED__ */


#ifndef __IVdsStoragePool_INTERFACE_DEFINED__
#define __IVdsStoragePool_INTERFACE_DEFINED__

/* interface IVdsStoragePool */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsStoragePool;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("932ca8cf-0eb3-4ba8-9620-22665d7f8450")
    IVdsStoragePool : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_STORAGE_POOL_PROP *pStoragePoolProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ __RPC__out VDS_POOL_ATTRIBUTES *pStoragePoolAttributes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDriveExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_STORAGE_POOL_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAllocatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAllocatedStoragePools( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsStoragePoolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsStoragePool * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsStoragePool * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsStoragePool * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProvider )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__out VDS_STORAGE_POOL_PROP *pStoragePoolProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__out VDS_POOL_ATTRIBUTES *pStoragePoolAttributes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDriveExtents )( 
            __RPC__in IVdsStoragePool * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_STORAGE_POOL_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAllocatedLuns )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAllocatedStoragePools )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsStoragePoolVtbl;

    interface IVdsStoragePool
    {
        CONST_VTBL struct IVdsStoragePoolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsStoragePool_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsStoragePool_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsStoragePool_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsStoragePool_GetProvider(This,ppProvider)	\
    ( (This)->lpVtbl -> GetProvider(This,ppProvider) ) 

#define IVdsStoragePool_GetProperties(This,pStoragePoolProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pStoragePoolProp) ) 

#define IVdsStoragePool_GetAttributes(This,pStoragePoolAttributes)	\
    ( (This)->lpVtbl -> GetAttributes(This,pStoragePoolAttributes) ) 

#define IVdsStoragePool_QueryDriveExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryDriveExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsStoragePool_QueryAllocatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAllocatedLuns(This,ppEnum) ) 

#define IVdsStoragePool_QueryAllocatedStoragePools(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAllocatedStoragePools(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsStoragePool_INTERFACE_DEFINED__ */


#ifndef __IVdsMaintenance_INTERFACE_DEFINED__
#define __IVdsMaintenance_INTERFACE_DEFINED__

/* interface IVdsMaintenance */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsMaintenance;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("daebeef3-8523-47ed-a2b9-05cecce2a1ae")
    IVdsMaintenance : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartMaintenance( 
            /* [in] */ VDS_MAINTENANCE_OPERATION operation) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StopMaintenance( 
            /* [in] */ VDS_MAINTENANCE_OPERATION operation) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PulseMaintenance( 
            /* [in] */ VDS_MAINTENANCE_OPERATION operation,
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsMaintenanceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsMaintenance * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsMaintenance * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsMaintenance * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StartMaintenance )( 
            __RPC__in IVdsMaintenance * This,
            /* [in] */ VDS_MAINTENANCE_OPERATION operation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StopMaintenance )( 
            __RPC__in IVdsMaintenance * This,
            /* [in] */ VDS_MAINTENANCE_OPERATION operation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PulseMaintenance )( 
            __RPC__in IVdsMaintenance * This,
            /* [in] */ VDS_MAINTENANCE_OPERATION operation,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IVdsMaintenanceVtbl;

    interface IVdsMaintenance
    {
        CONST_VTBL struct IVdsMaintenanceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsMaintenance_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsMaintenance_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsMaintenance_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsMaintenance_StartMaintenance(This,operation)	\
    ( (This)->lpVtbl -> StartMaintenance(This,operation) ) 

#define IVdsMaintenance_StopMaintenance(This,operation)	\
    ( (This)->lpVtbl -> StopMaintenance(This,operation) ) 

#define IVdsMaintenance_PulseMaintenance(This,operation,ulCount)	\
    ( (This)->lpVtbl -> PulseMaintenance(This,operation,ulCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsMaintenance_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0047 */
/* [local] */ 

#if (WINVER >= _WIN32_WINNT_WIN7)



typedef struct _VDS_CREATE_VDISK_PARAMETERS
    {
    GUID UniqueId;
    ULONGLONG MaximumSize;
    ULONG BlockSizeInBytes;
    ULONG SectorSizeInBytes;
    LPWSTR pParentPath;
    LPWSTR pSourcePath;
    } 	VDS_CREATE_VDISK_PARAMETERS;

typedef struct _VDS_CREATE_VDISK_PARAMETERS *PVDS_CREATE_VDISK_PARAMETERS;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0047_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0047_v0_0_s_ifspec;

#ifndef __IVdsVdProvider_INTERFACE_DEFINED__
#define __IVdsVdProvider_INTERFACE_DEFINED__

/* interface IVdsVdProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVdProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b481498c-8354-45f9-84a0-0bdd2832a91f")
    IVdsVdProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryVDisks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateVDisk( 
            /* [in] */ __RPC__in PVIRTUAL_STORAGE_TYPE VirtualDeviceType,
            /* [string][in] */ __RPC__in_string LPWSTR pPath,
            /* [unique][string][in] */ __RPC__in_opt_string LPWSTR pStringSecurityDescriptor,
            /* [in] */ CREATE_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags,
            /* [in] */ ULONG Reserved,
            /* [in] */ __RPC__in PVDS_CREATE_VDISK_PARAMETERS pCreateDiskParameters,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddVDisk( 
            /* [in] */ __RPC__in PVIRTUAL_STORAGE_TYPE VirtualDeviceType,
            /* [string][in] */ __RPC__in_string LPWSTR pPath,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IVdsVDisk **ppVDisk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDiskFromVDisk( 
            /* [in] */ __RPC__in_opt IVdsVDisk *pVDisk,
            /* [out] */ __RPC__deref_out_opt IVdsDisk **ppDisk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVDiskFromDisk( 
            /* [in] */ __RPC__in_opt IVdsDisk *pDisk,
            /* [out] */ __RPC__deref_out_opt IVdsVDisk **ppVDisk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVdProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVdProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVdProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVdProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryVDisks )( 
            __RPC__in IVdsVdProvider * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateVDisk )( 
            __RPC__in IVdsVdProvider * This,
            /* [in] */ __RPC__in PVIRTUAL_STORAGE_TYPE VirtualDeviceType,
            /* [string][in] */ __RPC__in_string LPWSTR pPath,
            /* [unique][string][in] */ __RPC__in_opt_string LPWSTR pStringSecurityDescriptor,
            /* [in] */ CREATE_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags,
            /* [in] */ ULONG Reserved,
            /* [in] */ __RPC__in PVDS_CREATE_VDISK_PARAMETERS pCreateDiskParameters,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddVDisk )( 
            __RPC__in IVdsVdProvider * This,
            /* [in] */ __RPC__in PVIRTUAL_STORAGE_TYPE VirtualDeviceType,
            /* [string][in] */ __RPC__in_string LPWSTR pPath,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IVdsVDisk **ppVDisk);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiskFromVDisk )( 
            __RPC__in IVdsVdProvider * This,
            /* [in] */ __RPC__in_opt IVdsVDisk *pVDisk,
            /* [out] */ __RPC__deref_out_opt IVdsDisk **ppDisk);
        
        HRESULT ( STDMETHODCALLTYPE *GetVDiskFromDisk )( 
            __RPC__in IVdsVdProvider * This,
            /* [in] */ __RPC__in_opt IVdsDisk *pDisk,
            /* [out] */ __RPC__deref_out_opt IVdsVDisk **ppVDisk);
        
        END_INTERFACE
    } IVdsVdProviderVtbl;

    interface IVdsVdProvider
    {
        CONST_VTBL struct IVdsVdProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVdProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVdProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVdProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVdProvider_QueryVDisks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryVDisks(This,ppEnum) ) 

#define IVdsVdProvider_CreateVDisk(This,VirtualDeviceType,pPath,pStringSecurityDescriptor,Flags,ProviderSpecificFlags,Reserved,pCreateDiskParameters,ppAsync)	\
    ( (This)->lpVtbl -> CreateVDisk(This,VirtualDeviceType,pPath,pStringSecurityDescriptor,Flags,ProviderSpecificFlags,Reserved,pCreateDiskParameters,ppAsync) ) 

#define IVdsVdProvider_AddVDisk(This,VirtualDeviceType,pPath,ppVDisk)	\
    ( (This)->lpVtbl -> AddVDisk(This,VirtualDeviceType,pPath,ppVDisk) ) 

#define IVdsVdProvider_GetDiskFromVDisk(This,pVDisk,ppDisk)	\
    ( (This)->lpVtbl -> GetDiskFromVDisk(This,pVDisk,ppDisk) ) 

#define IVdsVdProvider_GetVDiskFromDisk(This,pDisk,ppVDisk)	\
    ( (This)->lpVtbl -> GetVDiskFromDisk(This,pDisk,ppVDisk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVdProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0048 */
/* [local] */ 

typedef 
enum _VDS_VDISK_STATE
    {	VDS_VST_UNKNOWN	= 0,
	VDS_VST_ADDED	= ( VDS_VST_UNKNOWN + 1 ) ,
	VDS_VST_OPEN	= ( VDS_VST_ADDED + 1 ) ,
	VDS_VST_ATTACH_PENDING	= ( VDS_VST_OPEN + 1 ) ,
	VDS_VST_ATTACHED_NOT_OPEN	= ( VDS_VST_ATTACH_PENDING + 1 ) ,
	VDS_VST_ATTACHED	= ( VDS_VST_ATTACHED_NOT_OPEN + 1 ) ,
	VDS_VST_DETACH_PENDING	= ( VDS_VST_ATTACHED + 1 ) ,
	VDS_VST_COMPACTING	= ( VDS_VST_DETACH_PENDING + 1 ) ,
	VDS_VST_MERGING	= ( VDS_VST_COMPACTING + 1 ) ,
	VDS_VST_EXPANDING	= ( VDS_VST_MERGING + 1 ) ,
	VDS_VST_DELETED	= ( VDS_VST_EXPANDING + 1 ) ,
	VDS_VST_MAX	= ( VDS_VST_DELETED + 1 ) 
    } 	VDS_VDISK_STATE;

typedef struct _VDS_VDISK_PROPERTIES
    {
    VDS_OBJECT_ID Id;
    VDS_VDISK_STATE State;
    VIRTUAL_STORAGE_TYPE VirtualDeviceType;
    ULONGLONG VirtualSize;
    ULONGLONG PhysicalSize;
    LPWSTR pPath;
    LPWSTR pDeviceName;
    DEPENDENT_DISK_FLAG DiskFlag;
    BOOL bIsChild;
    LPWSTR pParentPath;
    } 	VDS_VDISK_PROPERTIES;

typedef struct _VDS_VDISK_PROPERTIES *PVDS_VDISK_PROPERTIES;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0048_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0048_v0_0_s_ifspec;

#ifndef __IVdsVDisk_INTERFACE_DEFINED__
#define __IVdsVDisk_INTERFACE_DEFINED__

/* interface IVdsVDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1e062b84-e5e6-4b4b-8a25-67b81e8f13e8")
    IVdsVDisk : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ VIRTUAL_DISK_ACCESS_MASK AccessMask,
            /* [in] */ OPEN_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ReadWriteDepth,
            /* [out] */ __RPC__deref_out_opt IVdsOpenVDisk **ppOpenVDisk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out PVDS_VDISK_PROPERTIES pDiskProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostVolume( 
            /* [out] */ __RPC__deref_out_opt IVdsVolume **ppVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppDeviceName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVDisk * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            __RPC__in IVdsVDisk * This,
            /* [in] */ VIRTUAL_DISK_ACCESS_MASK AccessMask,
            /* [in] */ OPEN_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ReadWriteDepth,
            /* [out] */ __RPC__deref_out_opt IVdsOpenVDisk **ppOpenVDisk);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsVDisk * This,
            /* [out] */ __RPC__out PVDS_VDISK_PROPERTIES pDiskProperties);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostVolume )( 
            __RPC__in IVdsVDisk * This,
            /* [out] */ __RPC__deref_out_opt IVdsVolume **ppVolume);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceName )( 
            __RPC__in IVdsVDisk * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppDeviceName);
        
        END_INTERFACE
    } IVdsVDiskVtbl;

    interface IVdsVDisk
    {
        CONST_VTBL struct IVdsVDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVDisk_Open(This,AccessMask,Flags,ReadWriteDepth,ppOpenVDisk)	\
    ( (This)->lpVtbl -> Open(This,AccessMask,Flags,ReadWriteDepth,ppOpenVDisk) ) 

#define IVdsVDisk_GetProperties(This,pDiskProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pDiskProperties) ) 

#define IVdsVDisk_GetHostVolume(This,ppVolume)	\
    ( (This)->lpVtbl -> GetHostVolume(This,ppVolume) ) 

#define IVdsVDisk_GetDeviceName(This,ppDeviceName)	\
    ( (This)->lpVtbl -> GetDeviceName(This,ppDeviceName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVDisk_INTERFACE_DEFINED__ */


#ifndef __IVdsOpenVDisk_INTERFACE_DEFINED__
#define __IVdsOpenVDisk_INTERFACE_DEFINED__

/* interface IVdsOpenVDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsOpenVDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75c8f324-f715-4fe3-a28e-f9011b61a4a1")
    IVdsOpenVDisk : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [unique][in] */ __RPC__in_opt LPWSTR pStringSecurityDescriptor,
            /* [in] */ ATTACH_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags,
            /* [in] */ ULONG TimeoutInMs,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( 
            /* [in] */ DETACH_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DetachAndDelete( 
            /* [in] */ DETACH_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compact( 
            /* [in] */ COMPACT_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG Reserved,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Merge( 
            /* [in] */ MERGE_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG MergeDepth,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Expand( 
            /* [in] */ EXPAND_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONGLONG NewSize,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsOpenVDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsOpenVDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsOpenVDisk * This);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [unique][in] */ __RPC__in_opt LPWSTR pStringSecurityDescriptor,
            /* [in] */ ATTACH_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags,
            /* [in] */ ULONG TimeoutInMs,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [in] */ DETACH_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DetachAndDelete )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [in] */ DETACH_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Compact )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [in] */ COMPACT_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG Reserved,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Merge )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [in] */ MERGE_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG MergeDepth,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Expand )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [in] */ EXPAND_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONGLONG NewSize,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsOpenVDiskVtbl;

    interface IVdsOpenVDisk
    {
        CONST_VTBL struct IVdsOpenVDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsOpenVDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsOpenVDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsOpenVDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsOpenVDisk_Attach(This,pStringSecurityDescriptor,Flags,ProviderSpecificFlags,TimeoutInMs,ppAsync)	\
    ( (This)->lpVtbl -> Attach(This,pStringSecurityDescriptor,Flags,ProviderSpecificFlags,TimeoutInMs,ppAsync) ) 

#define IVdsOpenVDisk_Detach(This,Flags,ProviderSpecificFlags)	\
    ( (This)->lpVtbl -> Detach(This,Flags,ProviderSpecificFlags) ) 

#define IVdsOpenVDisk_DetachAndDelete(This,Flags,ProviderSpecificFlags)	\
    ( (This)->lpVtbl -> DetachAndDelete(This,Flags,ProviderSpecificFlags) ) 

#define IVdsOpenVDisk_Compact(This,Flags,Reserved,ppAsync)	\
    ( (This)->lpVtbl -> Compact(This,Flags,Reserved,ppAsync) ) 

#define IVdsOpenVDisk_Merge(This,Flags,MergeDepth,ppAsync)	\
    ( (This)->lpVtbl -> Merge(This,Flags,MergeDepth,ppAsync) ) 

#define IVdsOpenVDisk_Expand(This,Flags,NewSize,ppAsync)	\
    ( (This)->lpVtbl -> Expand(This,Flags,NewSize,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsOpenVDisk_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0050 */
/* [local] */ 

#define	VDS_ATTACH_VIRTUAL_DISK_FLAG_USE_FILE_ACL	( 0x1 )

#endif // _WIN32_WINNT_WIN7


















// {9C38ED61-D565-4728-AEEE-C80952F0ECDE}
DEFINE_GUID(CLSID_VdsLoader, 
 0X9C38ED61,0xD565,0x4728,0xAE,0xEE,0xC8,0x09,0x52,0xF0,0xEC,0xDE);

// {7D1933CB-86F6-4A98-8628-01BE94C9A575}
DEFINE_GUID(CLSID_VdsService, 
 0x7D1933CB,0x86F6,0x4A98,0x86,0x28,0x01,0xBE,0x94,0xC9,0xA5,0x75);

#define	MAX_FS_NAME_SIZE	( 8 )

#define	MAX_FS_FORMAT_SUPPORT_NAME_SIZE	( 32 )

#define	MAX_FS_ALLOWED_CLUSTER_SIZES_SIZE	( 32 )

typedef 
enum _VDS_SERVICE_FLAG
    {	VDS_SVF_SUPPORT_DYNAMIC	= 0x1,
	VDS_SVF_SUPPORT_FAULT_TOLERANT	= 0x2,
	VDS_SVF_SUPPORT_GPT	= 0x4,
	VDS_SVF_SUPPORT_DYNAMIC_1394	= 0x8,
	VDS_SVF_CLUSTER_SERVICE_CONFIGURED	= 0x10,
	VDS_SVF_AUTO_MOUNT_OFF	= 0x20,
	VDS_SVF_OS_UNINSTALL_VALID	= 0x40,
	VDS_SVF_EFI	= 0x80,
	VDS_SVF_SUPPORT_MIRROR	= 0x100L,
	VDS_SVF_SUPPORT_RAID5	= 0x200L
    } 	VDS_SERVICE_FLAG;

typedef struct _VDS_SERVICE_PROP
    {
    LPWSTR pwszVersion;
    ULONG ulFlags;
    } 	VDS_SERVICE_PROP;

typedef 
enum _VDS_SAN_POLICY
    {	VDS_SP_UNKNOWN	= 0,
	VDS_SP_ONLINE	= 0x1,
	VDS_SP_OFFLINE_SHARED	= 0x2,
	VDS_SP_OFFLINE	= 0x3
    } 	VDS_SAN_POLICY;

typedef struct VDS_REPARSE_POINT_PROP
    {
    VDS_OBJECT_ID SourceVolumeId;
    LPWSTR pwszPath;
    } 	VDS_REPARSE_POINT_PROP;

typedef struct VDS_REPARSE_POINT_PROP *PVDS_REPARSE_POINT_PROP;

typedef 
enum _VDS_DRIVE_LETTER_FLAG
    {	VDS_DLF_NON_PERSISTENT	= 0x1
    } 	VDS_DRIVE_LETTER_FLAG;

typedef struct _VDS_DRIVE_LETTER_PROP
    {
    WCHAR wcLetter;
    VDS_OBJECT_ID volumeId;
    ULONG ulFlags;
    BOOL bUsed;
    } 	VDS_DRIVE_LETTER_PROP;

typedef struct _VDS_DRIVE_LETTER_PROP *PVDS_DRIVE_LETTER_PROP;

typedef 
enum _VDS_FILE_SYSTEM_FLAG
    {	VDS_FSF_SUPPORT_FORMAT	= 0x1,
	VDS_FSF_SUPPORT_QUICK_FORMAT	= 0x2,
	VDS_FSF_SUPPORT_COMPRESS	= 0x4,
	VDS_FSF_SUPPORT_SPECIFY_LABEL	= 0x8,
	VDS_FSF_SUPPORT_MOUNT_POINT	= 0x10,
	VDS_FSF_SUPPORT_REMOVABLE_MEDIA	= 0x20,
	VDS_FSF_SUPPORT_EXTEND	= 0x40,
	VDS_FSF_ALLOCATION_UNIT_512	= 0x10000,
	VDS_FSF_ALLOCATION_UNIT_1K	= 0x20000,
	VDS_FSF_ALLOCATION_UNIT_2K	= 0x40000,
	VDS_FSF_ALLOCATION_UNIT_4K	= 0x80000,
	VDS_FSF_ALLOCATION_UNIT_8K	= 0x100000,
	VDS_FSF_ALLOCATION_UNIT_16K	= 0x200000,
	VDS_FSF_ALLOCATION_UNIT_32K	= 0x400000,
	VDS_FSF_ALLOCATION_UNIT_64K	= 0x800000,
	VDS_FSF_ALLOCATION_UNIT_128K	= 0x1000000,
	VDS_FSF_ALLOCATION_UNIT_256K	= 0x2000000
    } 	VDS_FILE_SYSTEM_FLAG;

typedef struct _VDS_FILE_SYSTEM_TYPE_PROP
    {
    VDS_FILE_SYSTEM_TYPE type;
    WCHAR wszName[ 8 ];
    ULONG ulFlags;
    ULONG ulCompressionFlags;
    ULONG ulMaxLableLength;
    LPWSTR pwszIllegalLabelCharSet;
    } 	VDS_FILE_SYSTEM_TYPE_PROP;

typedef struct _VDS_FILE_SYSTEM_TYPE_PROP *PVDS_FILE_SYSTEM_TYPE_PROP;

typedef 
enum _VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG
    {	VDS_FSS_DEFAULT	= 0x1,
	VDS_FSS_PREVIOUS_REVISION	= 0x2,
	VDS_FSS_RECOMMENDED	= 0x4
    } 	VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG;

typedef struct _VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP
    {
    ULONG ulFlags;
    USHORT usRevision;
    ULONG ulDefaultUnitAllocationSize;
    ULONG rgulAllowedUnitAllocationSizes[ 32 ];
    WCHAR wszName[ 32 ];
    } 	VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP;

typedef struct _VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP *PVDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP;

typedef 
enum _VDS_FILE_SYSTEM_PROP_FLAG
    {	VDS_FPF_COMPRESSED	= 0x1
    } 	VDS_FILE_SYSTEM_PROP_FLAG;

typedef 
enum _VDS_FORMAT_OPTION_FLAGS
    {	VDS_FSOF_NONE	= 0,
	VDS_FSOF_FORCE	= 0x1,
	VDS_FSOF_QUICK	= 0x2,
	VDS_FSOF_COMPRESSION	= 0x4,
	VDS_FSOF_DUPLICATE_METADATA	= 0x8
    } 	VDS_FORMAT_OPTION_FLAGS;

typedef struct _VDS_FILE_SYSTEM_PROP
    {
    VDS_FILE_SYSTEM_TYPE type;
    VDS_OBJECT_ID volumeId;
    ULONG ulFlags;
    ULONGLONG ullTotalAllocationUnits;
    ULONGLONG ullAvailableAllocationUnits;
    ULONG ulAllocationUnitSize;
    LPWSTR pwszLabel;
    } 	VDS_FILE_SYSTEM_PROP;

typedef struct _VDS_FILE_SYSTEM_PROP *PVDS_FILE_SYSTEM_PROP;

typedef 
enum _VDS_QUERY_PROVIDER_FLAG
    {	VDS_QUERY_SOFTWARE_PROVIDERS	= 0x1,
	VDS_QUERY_HARDWARE_PROVIDERS	= 0x2,
	VDS_QUERY_VIRTUALDISK_PROVIDERS	= 0x4
    } 	VDS_QUERY_PROVIDER_FLAG;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0050_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0050_v0_0_s_ifspec;

#ifndef __IVdsServiceLoader_INTERFACE_DEFINED__
#define __IVdsServiceLoader_INTERFACE_DEFINED__

/* interface IVdsServiceLoader */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceLoader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e0393303-90d4-4a97-ab71-e9b671ee2729")
    IVdsServiceLoader : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoadService( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszMachineName,
            /* [out] */ __RPC__deref_out_opt IVdsService **ppService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceLoaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsServiceLoader * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsServiceLoader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsServiceLoader * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LoadService )( 
            __RPC__in IVdsServiceLoader * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszMachineName,
            /* [out] */ __RPC__deref_out_opt IVdsService **ppService);
        
        END_INTERFACE
    } IVdsServiceLoaderVtbl;

    interface IVdsServiceLoader
    {
        CONST_VTBL struct IVdsServiceLoaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceLoader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceLoader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceLoader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceLoader_LoadService(This,pwszMachineName,ppService)	\
    ( (This)->lpVtbl -> LoadService(This,pwszMachineName,ppService) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceLoader_INTERFACE_DEFINED__ */


#ifndef __IVdsService_INTERFACE_DEFINED__
#define __IVdsService_INTERFACE_DEFINED__

/* interface IVdsService */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0818a8ef-9ba9-40d8-a6f9-e22833cc771e")
    IVdsService : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsServiceReady( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WaitForServiceReady( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_SERVICE_PROP *pServiceProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryProviders( 
            /* [in] */ DWORD masks,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaskedDisks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryUnallocatedDisks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ VDS_OBJECT_ID ObjectId,
            /* [in] */ VDS_OBJECT_TYPE type,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppObjectUnk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDriveLetters( 
            /* [in] */ WCHAR wcFirstLetter,
            /* [in] */ DWORD count,
            /* [size_is][out] */ __RPC__out_ecount_full(count) VDS_DRIVE_LETTER_PROP *pDriveLetterPropArray) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryFileSystemTypes( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_TYPE_PROP **ppFileSystemTypeProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reenumerate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CleanupObsoleteMountPoints( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ __RPC__in_opt IVdsAdviseSink *pSink,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reboot( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsServiceReady )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WaitForServiceReady )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsService * This,
            /* [out] */ __RPC__out VDS_SERVICE_PROP *pServiceProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryProviders )( 
            __RPC__in IVdsService * This,
            /* [in] */ DWORD masks,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaskedDisks )( 
            __RPC__in IVdsService * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryUnallocatedDisks )( 
            __RPC__in IVdsService * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            __RPC__in IVdsService * This,
            /* [in] */ VDS_OBJECT_ID ObjectId,
            /* [in] */ VDS_OBJECT_TYPE type,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppObjectUnk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDriveLetters )( 
            __RPC__in IVdsService * This,
            /* [in] */ WCHAR wcFirstLetter,
            /* [in] */ DWORD count,
            /* [size_is][out] */ __RPC__out_ecount_full(count) VDS_DRIVE_LETTER_PROP *pDriveLetterPropArray);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryFileSystemTypes )( 
            __RPC__in IVdsService * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_TYPE_PROP **ppFileSystemTypeProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reenumerate )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CleanupObsoleteMountPoints )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Advise )( 
            __RPC__in IVdsService * This,
            /* [in] */ __RPC__in_opt IVdsAdviseSink *pSink,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            __RPC__in IVdsService * This,
            /* [in] */ DWORD dwCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reboot )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in IVdsService * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            __RPC__in IVdsService * This,
            /* [in] */ ULONG ulFlags);
        
        END_INTERFACE
    } IVdsServiceVtbl;

    interface IVdsService
    {
        CONST_VTBL struct IVdsServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsService_IsServiceReady(This)	\
    ( (This)->lpVtbl -> IsServiceReady(This) ) 

#define IVdsService_WaitForServiceReady(This)	\
    ( (This)->lpVtbl -> WaitForServiceReady(This) ) 

#define IVdsService_GetProperties(This,pServiceProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pServiceProp) ) 

#define IVdsService_QueryProviders(This,masks,ppEnum)	\
    ( (This)->lpVtbl -> QueryProviders(This,masks,ppEnum) ) 

#define IVdsService_QueryMaskedDisks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryMaskedDisks(This,ppEnum) ) 

#define IVdsService_QueryUnallocatedDisks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryUnallocatedDisks(This,ppEnum) ) 

#define IVdsService_GetObject(This,ObjectId,type,ppObjectUnk)	\
    ( (This)->lpVtbl -> GetObject(This,ObjectId,type,ppObjectUnk) ) 

#define IVdsService_QueryDriveLetters(This,wcFirstLetter,count,pDriveLetterPropArray)	\
    ( (This)->lpVtbl -> QueryDriveLetters(This,wcFirstLetter,count,pDriveLetterPropArray) ) 

#define IVdsService_QueryFileSystemTypes(This,ppFileSystemTypeProps,plNumberOfFileSystems)	\
    ( (This)->lpVtbl -> QueryFileSystemTypes(This,ppFileSystemTypeProps,plNumberOfFileSystems) ) 

#define IVdsService_Reenumerate(This)	\
    ( (This)->lpVtbl -> Reenumerate(This) ) 

#define IVdsService_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IVdsService_CleanupObsoleteMountPoints(This)	\
    ( (This)->lpVtbl -> CleanupObsoleteMountPoints(This) ) 

#define IVdsService_Advise(This,pSink,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pSink,pdwCookie) ) 

#define IVdsService_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IVdsService_Reboot(This)	\
    ( (This)->lpVtbl -> Reboot(This) ) 

#define IVdsService_SetFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags) ) 

#define IVdsService_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsService_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceUninstallDisk_INTERFACE_DEFINED__
#define __IVdsServiceUninstallDisk_INTERFACE_DEFINED__

/* interface IVdsServiceUninstallDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceUninstallDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6B22DA8-F903-4be7-B492-C09D875AC9DA")
    IVdsServiceUninstallDisk : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDiskIdFromLunInfo( 
            /* [in] */ __RPC__in VDS_LUN_INFORMATION *pLunInfo,
            /* [out] */ __RPC__out VDS_OBJECT_ID *pDiskId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UninstallDisks( 
            /* [size_is][in] */ __RPC__in_ecount_full(ulCount) VDS_OBJECT_ID *pDiskIdArray,
            /* [in] */ ULONG ulCount,
            /* [in] */ BOOLEAN bForce,
            /* [out] */ __RPC__out BOOLEAN *pbReboot,
            /* [size_is][out] */ __RPC__out_ecount_full(ulCount) HRESULT *pResults) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceUninstallDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsServiceUninstallDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsServiceUninstallDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsServiceUninstallDisk * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDiskIdFromLunInfo )( 
            __RPC__in IVdsServiceUninstallDisk * This,
            /* [in] */ __RPC__in VDS_LUN_INFORMATION *pLunInfo,
            /* [out] */ __RPC__out VDS_OBJECT_ID *pDiskId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UninstallDisks )( 
            __RPC__in IVdsServiceUninstallDisk * This,
            /* [size_is][in] */ __RPC__in_ecount_full(ulCount) VDS_OBJECT_ID *pDiskIdArray,
            /* [in] */ ULONG ulCount,
            /* [in] */ BOOLEAN bForce,
            /* [out] */ __RPC__out BOOLEAN *pbReboot,
            /* [size_is][out] */ __RPC__out_ecount_full(ulCount) HRESULT *pResults);
        
        END_INTERFACE
    } IVdsServiceUninstallDiskVtbl;

    interface IVdsServiceUninstallDisk
    {
        CONST_VTBL struct IVdsServiceUninstallDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceUninstallDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceUninstallDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceUninstallDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceUninstallDisk_GetDiskIdFromLunInfo(This,pLunInfo,pDiskId)	\
    ( (This)->lpVtbl -> GetDiskIdFromLunInfo(This,pLunInfo,pDiskId) ) 

#define IVdsServiceUninstallDisk_UninstallDisks(This,pDiskIdArray,ulCount,bForce,pbReboot,pResults)	\
    ( (This)->lpVtbl -> UninstallDisks(This,pDiskIdArray,ulCount,bForce,pbReboot,pResults) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceUninstallDisk_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceHba_INTERFACE_DEFINED__
#define __IVdsServiceHba_INTERFACE_DEFINED__

/* interface IVdsServiceHba */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceHba;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0ac13689-3134-47c6-a17c-4669216801be")
    IVdsServiceHba : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHbaPorts( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceHbaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsServiceHba * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsServiceHba * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsServiceHba * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHbaPorts )( 
            __RPC__in IVdsServiceHba * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsServiceHbaVtbl;

    interface IVdsServiceHba
    {
        CONST_VTBL struct IVdsServiceHbaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceHba_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceHba_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceHba_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceHba_QueryHbaPorts(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryHbaPorts(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceHba_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceIscsi_INTERFACE_DEFINED__
#define __IVdsServiceIscsi_INTERFACE_DEFINED__

/* interface IVdsServiceIscsi */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceIscsi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14fbe036-3ed7-4e10-90e9-a5ff991aff01")
    IVdsServiceIscsi : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInitiatorName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIscsiName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryInitiatorAdapters( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecGroupPresharedKey( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAllIpsecTunnelAddresses( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAllIpsecSecurity( 
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInitiatorSharedSecret( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret,
            /* [in] */ VDS_OBJECT_ID targetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RememberTargetSharedSecret( 
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceIscsiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsServiceIscsi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsServiceIscsi * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetInitiatorName )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIscsiName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryInitiatorAdapters )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecGroupPresharedKey )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAllIpsecTunnelAddresses )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAllIpsecSecurity )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetInitiatorSharedSecret )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret,
            /* [in] */ VDS_OBJECT_ID targetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RememberTargetSharedSecret )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret);
        
        END_INTERFACE
    } IVdsServiceIscsiVtbl;

    interface IVdsServiceIscsi
    {
        CONST_VTBL struct IVdsServiceIscsiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceIscsi_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceIscsi_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceIscsi_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceIscsi_GetInitiatorName(This,ppwszIscsiName)	\
    ( (This)->lpVtbl -> GetInitiatorName(This,ppwszIscsiName) ) 

#define IVdsServiceIscsi_QueryInitiatorAdapters(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryInitiatorAdapters(This,ppEnum) ) 

#define IVdsServiceIscsi_SetIpsecGroupPresharedKey(This,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecGroupPresharedKey(This,pIpsecKey) ) 

#define IVdsServiceIscsi_SetAllIpsecTunnelAddresses(This,pTunnelAddress,pDestinationAddress)	\
    ( (This)->lpVtbl -> SetAllIpsecTunnelAddresses(This,pTunnelAddress,pDestinationAddress) ) 

#define IVdsServiceIscsi_SetAllIpsecSecurity(This,targetPortalId,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetAllIpsecSecurity(This,targetPortalId,ullSecurityFlags,pIpsecKey) ) 

#define IVdsServiceIscsi_SetInitiatorSharedSecret(This,pInitiatorSharedSecret,targetId)	\
    ( (This)->lpVtbl -> SetInitiatorSharedSecret(This,pInitiatorSharedSecret,targetId) ) 

#define IVdsServiceIscsi_RememberTargetSharedSecret(This,targetId,pTargetSharedSecret)	\
    ( (This)->lpVtbl -> RememberTargetSharedSecret(This,targetId,pTargetSharedSecret) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceIscsi_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceInitialization_INTERFACE_DEFINED__
#define __IVdsServiceInitialization_INTERFACE_DEFINED__

/* interface IVdsServiceInitialization */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceInitialization;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4afc3636-db01-4052-80c3-03bbcb8d3c69")
    IVdsServiceInitialization : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszMachineName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceInitializationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsServiceInitialization * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsServiceInitialization * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsServiceInitialization * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IVdsServiceInitialization * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszMachineName);
        
        END_INTERFACE
    } IVdsServiceInitializationVtbl;

    interface IVdsServiceInitialization
    {
        CONST_VTBL struct IVdsServiceInitializationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceInitialization_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceInitialization_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceInitialization_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceInitialization_Initialize(This,pwszMachineName)	\
    ( (This)->lpVtbl -> Initialize(This,pwszMachineName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceInitialization_INTERFACE_DEFINED__ */


#ifndef __IVdsHbaPort_INTERFACE_DEFINED__
#define __IVdsHbaPort_INTERFACE_DEFINED__

/* interface IVdsHbaPort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHbaPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2abd757f-2851-4997-9a13-47d2a885d6ca")
    IVdsHbaPort : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_HBAPORT_PROP *pHbaPortProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAllPathStatuses( 
            /* [in] */ VDS_PATH_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHbaPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHbaPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHbaPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHbaPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsHbaPort * This,
            /* [out] */ __RPC__out VDS_HBAPORT_PROP *pHbaPortProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAllPathStatuses )( 
            __RPC__in IVdsHbaPort * This,
            /* [in] */ VDS_PATH_STATUS status);
        
        END_INTERFACE
    } IVdsHbaPortVtbl;

    interface IVdsHbaPort
    {
        CONST_VTBL struct IVdsHbaPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHbaPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHbaPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHbaPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHbaPort_GetProperties(This,pHbaPortProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pHbaPortProp) ) 

#define IVdsHbaPort_SetAllPathStatuses(This,status)	\
    ( (This)->lpVtbl -> SetAllPathStatuses(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHbaPort_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiInitiatorAdapter_INTERFACE_DEFINED__
#define __IVdsIscsiInitiatorAdapter_INTERFACE_DEFINED__

/* interface IVdsIscsiInitiatorAdapter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiInitiatorAdapter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b07fedd4-1682-4440-9189-a39b55194dc5")
    IVdsIscsiInitiatorAdapter : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_INITIATOR_ADAPTER_PROP *pInitiatorAdapterProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryInitiatorPortals( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoginToTarget( 
            /* [in] */ VDS_ISCSI_LOGIN_TYPE loginType,
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ VDS_OBJECT_ID initiatorPortalId,
            /* [in] */ ULONG ulLoginFlags,
            /* [in] */ BOOL bHeaderDigest,
            /* [in] */ BOOL bDataDigest,
            /* [in] */ VDS_ISCSI_AUTH_TYPE authType,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LogoutFromTarget( 
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiInitiatorAdapterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This,
            /* [out] */ __RPC__out VDS_ISCSI_INITIATOR_ADAPTER_PROP *pInitiatorAdapterProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryInitiatorPortals )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LoginToTarget )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This,
            /* [in] */ VDS_ISCSI_LOGIN_TYPE loginType,
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ VDS_OBJECT_ID initiatorPortalId,
            /* [in] */ ULONG ulLoginFlags,
            /* [in] */ BOOL bHeaderDigest,
            /* [in] */ BOOL bDataDigest,
            /* [in] */ VDS_ISCSI_AUTH_TYPE authType,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LogoutFromTarget )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This,
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsIscsiInitiatorAdapterVtbl;

    interface IVdsIscsiInitiatorAdapter
    {
        CONST_VTBL struct IVdsIscsiInitiatorAdapterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiInitiatorAdapter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiInitiatorAdapter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiInitiatorAdapter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiInitiatorAdapter_GetProperties(This,pInitiatorAdapterProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pInitiatorAdapterProp) ) 

#define IVdsIscsiInitiatorAdapter_QueryInitiatorPortals(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryInitiatorPortals(This,ppEnum) ) 

#define IVdsIscsiInitiatorAdapter_LoginToTarget(This,loginType,targetId,targetPortalId,initiatorPortalId,ulLoginFlags,bHeaderDigest,bDataDigest,authType,ppAsync)	\
    ( (This)->lpVtbl -> LoginToTarget(This,loginType,targetId,targetPortalId,initiatorPortalId,ulLoginFlags,bHeaderDigest,bDataDigest,authType,ppAsync) ) 

#define IVdsIscsiInitiatorAdapter_LogoutFromTarget(This,targetId,ppAsync)	\
    ( (This)->lpVtbl -> LogoutFromTarget(This,targetId,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiInitiatorAdapter_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiInitiatorPortal_INTERFACE_DEFINED__
#define __IVdsIscsiInitiatorPortal_INTERFACE_DEFINED__

/* interface IVdsIscsiInitiatorPortal */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiInitiatorPortal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("38a0a9ab-7cc8-4693-ac07-1f28bd03c3da")
    IVdsIscsiInitiatorPortal : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_INITIATOR_PORTAL_PROP *pInitiatorPortalProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInitiatorAdapter( 
            /* [out] */ __RPC__deref_out_opt IVdsIscsiInitiatorAdapter **ppInitiatorAdapter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecTunnelAddress( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIpsecSecurity( 
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecSecurity( 
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiInitiatorPortalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiInitiatorPortal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiInitiatorPortal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiInitiatorPortal * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiInitiatorPortal * This,
            /* [out] */ __RPC__out VDS_ISCSI_INITIATOR_PORTAL_PROP *pInitiatorPortalProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetInitiatorAdapter )( 
            __RPC__in IVdsIscsiInitiatorPortal * This,
            /* [out] */ __RPC__deref_out_opt IVdsIscsiInitiatorAdapter **ppInitiatorAdapter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecTunnelAddress )( 
            __RPC__in IVdsIscsiInitiatorPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIpsecSecurity )( 
            __RPC__in IVdsIscsiInitiatorPortal * This,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecSecurity )( 
            __RPC__in IVdsIscsiInitiatorPortal * This,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsIscsiInitiatorPortalVtbl;

    interface IVdsIscsiInitiatorPortal
    {
        CONST_VTBL struct IVdsIscsiInitiatorPortalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiInitiatorPortal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiInitiatorPortal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiInitiatorPortal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiInitiatorPortal_GetProperties(This,pInitiatorPortalProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pInitiatorPortalProp) ) 

#define IVdsIscsiInitiatorPortal_GetInitiatorAdapter(This,ppInitiatorAdapter)	\
    ( (This)->lpVtbl -> GetInitiatorAdapter(This,ppInitiatorAdapter) ) 

#define IVdsIscsiInitiatorPortal_SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress)	\
    ( (This)->lpVtbl -> SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress) ) 

#define IVdsIscsiInitiatorPortal_GetIpsecSecurity(This,targetPortalId,pullSecurityFlags)	\
    ( (This)->lpVtbl -> GetIpsecSecurity(This,targetPortalId,pullSecurityFlags) ) 

#define IVdsIscsiInitiatorPortal_SetIpsecSecurity(This,targetPortalId,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecSecurity(This,targetPortalId,ullSecurityFlags,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiInitiatorPortal_INTERFACE_DEFINED__ */


#ifndef __IVdsDiskPartitionMF_INTERFACE_DEFINED__
#define __IVdsDiskPartitionMF_INTERFACE_DEFINED__

/* interface IVdsDiskPartitionMF */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDiskPartitionMF;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("538684e0-ba3d-4bc0-aca9-164aff85c2a9")
    IVdsDiskPartitionMF : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPartitionFileSystemProperties( 
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out VDS_FILE_SYSTEM_PROP *pFileSystemProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPartitionFileSystemTypeName( 
            /* [in] */ ULONGLONG ullOffset,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszFileSystemTypeName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPartitionFileSystemFormatSupport( 
            /* [in] */ ULONGLONG ullOffset,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP **ppFileSystemSupportProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatPartitionEx( 
            /* [in] */ ULONGLONG ullOffset,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDiskPartitionMFVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDiskPartitionMF * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDiskPartitionMF * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDiskPartitionMF * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionFileSystemProperties )( 
            __RPC__in IVdsDiskPartitionMF * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out VDS_FILE_SYSTEM_PROP *pFileSystemProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionFileSystemTypeName )( 
            __RPC__in IVdsDiskPartitionMF * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszFileSystemTypeName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPartitionFileSystemFormatSupport )( 
            __RPC__in IVdsDiskPartitionMF * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP **ppFileSystemSupportProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatPartitionEx )( 
            __RPC__in IVdsDiskPartitionMF * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsDiskPartitionMFVtbl;

    interface IVdsDiskPartitionMF
    {
        CONST_VTBL struct IVdsDiskPartitionMFVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDiskPartitionMF_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDiskPartitionMF_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDiskPartitionMF_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDiskPartitionMF_GetPartitionFileSystemProperties(This,ullOffset,pFileSystemProp)	\
    ( (This)->lpVtbl -> GetPartitionFileSystemProperties(This,ullOffset,pFileSystemProp) ) 

#define IVdsDiskPartitionMF_GetPartitionFileSystemTypeName(This,ullOffset,ppwszFileSystemTypeName)	\
    ( (This)->lpVtbl -> GetPartitionFileSystemTypeName(This,ullOffset,ppwszFileSystemTypeName) ) 

#define IVdsDiskPartitionMF_QueryPartitionFileSystemFormatSupport(This,ullOffset,ppFileSystemSupportProps,plNumberOfFileSystems)	\
    ( (This)->lpVtbl -> QueryPartitionFileSystemFormatSupport(This,ullOffset,ppFileSystemSupportProps,plNumberOfFileSystems) ) 

#define IVdsDiskPartitionMF_FormatPartitionEx(This,ullOffset,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,bForce,bQuickFormat,bEnableCompression,ppAsync)	\
    ( (This)->lpVtbl -> FormatPartitionEx(This,ullOffset,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,bForce,bQuickFormat,bEnableCompression,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDiskPartitionMF_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeMF_INTERFACE_DEFINED__
#define __IVdsVolumeMF_INTERFACE_DEFINED__

/* interface IVdsVolumeMF */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeMF;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ee2d5ded-6236-4169-931d-b9778ce03dc6")
    IVdsVolumeMF : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFileSystemProperties( 
            /* [out] */ __RPC__out VDS_FILE_SYSTEM_PROP *pFileSystemProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Format( 
            /* [in] */ VDS_FILE_SYSTEM_TYPE type,
            /* [string][in] */ __RPC__in_string LPWSTR pwszLabel,
            /* [in] */ DWORD dwUnitAllocationSize,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddAccessPath( 
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( ( 260 - 1 )  + 1 ) ) LPWSTR pwszPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAccessPaths( 
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfAccessPaths) LPWSTR **pwszPathArray,
            /* [out] */ __RPC__out LONG *plNumberOfAccessPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryReparsePoints( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfReparsePointProps) VDS_REPARSE_POINT_PROP **ppReparsePointProps,
            /* [out] */ __RPC__out LONG *plNumberOfReparsePointProps) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteAccessPath( 
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( ( 260 - 1 )  + 1 ) ) LPWSTR pwszPath,
            /* [in] */ BOOL bForce) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Mount( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Dismount( 
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bPermanent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFileSystemFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFileSystemFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeMFVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolumeMF * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolumeMF * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolumeMF * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFileSystemProperties )( 
            __RPC__in IVdsVolumeMF * This,
            /* [out] */ __RPC__out VDS_FILE_SYSTEM_PROP *pFileSystemProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Format )( 
            __RPC__in IVdsVolumeMF * This,
            /* [in] */ VDS_FILE_SYSTEM_TYPE type,
            /* [string][in] */ __RPC__in_string LPWSTR pwszLabel,
            /* [in] */ DWORD dwUnitAllocationSize,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddAccessPath )( 
            __RPC__in IVdsVolumeMF * This,
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( ( 260 - 1 )  + 1 ) ) LPWSTR pwszPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAccessPaths )( 
            __RPC__in IVdsVolumeMF * This,
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfAccessPaths) LPWSTR **pwszPathArray,
            /* [out] */ __RPC__out LONG *plNumberOfAccessPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryReparsePoints )( 
            __RPC__in IVdsVolumeMF * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfReparsePointProps) VDS_REPARSE_POINT_PROP **ppReparsePointProps,
            /* [out] */ __RPC__out LONG *plNumberOfReparsePointProps);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteAccessPath )( 
            __RPC__in IVdsVolumeMF * This,
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( ( 260 - 1 )  + 1 ) ) LPWSTR pwszPath,
            /* [in] */ BOOL bForce);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Mount )( 
            __RPC__in IVdsVolumeMF * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Dismount )( 
            __RPC__in IVdsVolumeMF * This,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bPermanent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFileSystemFlags )( 
            __RPC__in IVdsVolumeMF * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFileSystemFlags )( 
            __RPC__in IVdsVolumeMF * This,
            /* [in] */ ULONG ulFlags);
        
        END_INTERFACE
    } IVdsVolumeMFVtbl;

    interface IVdsVolumeMF
    {
        CONST_VTBL struct IVdsVolumeMFVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeMF_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeMF_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeMF_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeMF_GetFileSystemProperties(This,pFileSystemProp)	\
    ( (This)->lpVtbl -> GetFileSystemProperties(This,pFileSystemProp) ) 

#define IVdsVolumeMF_Format(This,type,pwszLabel,dwUnitAllocationSize,bForce,bQuickFormat,bEnableCompression,ppAsync)	\
    ( (This)->lpVtbl -> Format(This,type,pwszLabel,dwUnitAllocationSize,bForce,bQuickFormat,bEnableCompression,ppAsync) ) 

#define IVdsVolumeMF_AddAccessPath(This,pwszPath)	\
    ( (This)->lpVtbl -> AddAccessPath(This,pwszPath) ) 

#define IVdsVolumeMF_QueryAccessPaths(This,pwszPathArray,plNumberOfAccessPaths)	\
    ( (This)->lpVtbl -> QueryAccessPaths(This,pwszPathArray,plNumberOfAccessPaths) ) 

#define IVdsVolumeMF_QueryReparsePoints(This,ppReparsePointProps,plNumberOfReparsePointProps)	\
    ( (This)->lpVtbl -> QueryReparsePoints(This,ppReparsePointProps,plNumberOfReparsePointProps) ) 

#define IVdsVolumeMF_DeleteAccessPath(This,pwszPath,bForce)	\
    ( (This)->lpVtbl -> DeleteAccessPath(This,pwszPath,bForce) ) 

#define IVdsVolumeMF_Mount(This)	\
    ( (This)->lpVtbl -> Mount(This) ) 

#define IVdsVolumeMF_Dismount(This,bForce,bPermanent)	\
    ( (This)->lpVtbl -> Dismount(This,bForce,bPermanent) ) 

#define IVdsVolumeMF_SetFileSystemFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFileSystemFlags(This,ulFlags) ) 

#define IVdsVolumeMF_ClearFileSystemFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFileSystemFlags(This,ulFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeMF_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeMF2_INTERFACE_DEFINED__
#define __IVdsVolumeMF2_INTERFACE_DEFINED__

/* interface IVdsVolumeMF2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeMF2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4dbcee9a-6343-4651-b85f-5e75d74d983c")
    IVdsVolumeMF2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFileSystemTypeName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszFileSystemTypeName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryFileSystemFormatSupport( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP **ppFileSystemSupportProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatEx( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeMF2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolumeMF2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolumeMF2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolumeMF2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFileSystemTypeName )( 
            __RPC__in IVdsVolumeMF2 * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszFileSystemTypeName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryFileSystemFormatSupport )( 
            __RPC__in IVdsVolumeMF2 * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP **ppFileSystemSupportProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatEx )( 
            __RPC__in IVdsVolumeMF2 * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsVolumeMF2Vtbl;

    interface IVdsVolumeMF2
    {
        CONST_VTBL struct IVdsVolumeMF2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeMF2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeMF2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeMF2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeMF2_GetFileSystemTypeName(This,ppwszFileSystemTypeName)	\
    ( (This)->lpVtbl -> GetFileSystemTypeName(This,ppwszFileSystemTypeName) ) 

#define IVdsVolumeMF2_QueryFileSystemFormatSupport(This,ppFileSystemSupportProps,plNumberOfFileSystems)	\
    ( (This)->lpVtbl -> QueryFileSystemFormatSupport(This,ppFileSystemSupportProps,plNumberOfFileSystems) ) 

#define IVdsVolumeMF2_FormatEx(This,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,bForce,bQuickFormat,bEnableCompression,ppAsync)	\
    ( (This)->lpVtbl -> FormatEx(This,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,bForce,bQuickFormat,bEnableCompression,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeMF2_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeShrink_INTERFACE_DEFINED__
#define __IVdsVolumeShrink_INTERFACE_DEFINED__

/* interface IVdsVolumeShrink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeShrink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d68168c9-82a2-4f85-b6e9-74707c49a58f")
    IVdsVolumeShrink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxReclaimableBytes( 
            /* [out] */ __RPC__out ULONGLONG *pullMaxNumberOfReclaimableBytes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shrink( 
            /* [in] */ ULONGLONG ullDesiredNumberOfReclaimableBytes,
            /* [in] */ ULONGLONG ullMinNumberOfReclaimableBytes,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeShrinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolumeShrink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolumeShrink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolumeShrink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxReclaimableBytes )( 
            __RPC__in IVdsVolumeShrink * This,
            /* [out] */ __RPC__out ULONGLONG *pullMaxNumberOfReclaimableBytes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shrink )( 
            __RPC__in IVdsVolumeShrink * This,
            /* [in] */ ULONGLONG ullDesiredNumberOfReclaimableBytes,
            /* [in] */ ULONGLONG ullMinNumberOfReclaimableBytes,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsVolumeShrinkVtbl;

    interface IVdsVolumeShrink
    {
        CONST_VTBL struct IVdsVolumeShrinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeShrink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeShrink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeShrink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeShrink_QueryMaxReclaimableBytes(This,pullMaxNumberOfReclaimableBytes)	\
    ( (This)->lpVtbl -> QueryMaxReclaimableBytes(This,pullMaxNumberOfReclaimableBytes) ) 

#define IVdsVolumeShrink_Shrink(This,ullDesiredNumberOfReclaimableBytes,ullMinNumberOfReclaimableBytes,ppAsync)	\
    ( (This)->lpVtbl -> Shrink(This,ullDesiredNumberOfReclaimableBytes,ullMinNumberOfReclaimableBytes,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeShrink_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemImportTarget_INTERFACE_DEFINED__
#define __IVdsSubSystemImportTarget_INTERFACE_DEFINED__

/* interface IVdsSubSystemImportTarget */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemImportTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83bfb87f-43fb-4903-baa6-127f01029eec")
    IVdsSubSystemImportTarget : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetImportTarget( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIscsiName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetImportTarget( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszIscsiName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemImportTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystemImportTarget * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystemImportTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystemImportTarget * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetImportTarget )( 
            __RPC__in IVdsSubSystemImportTarget * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIscsiName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetImportTarget )( 
            __RPC__in IVdsSubSystemImportTarget * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszIscsiName);
        
        END_INTERFACE
    } IVdsSubSystemImportTargetVtbl;

    interface IVdsSubSystemImportTarget
    {
        CONST_VTBL struct IVdsSubSystemImportTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemImportTarget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemImportTarget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemImportTarget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemImportTarget_GetImportTarget(This,ppwszIscsiName)	\
    ( (This)->lpVtbl -> GetImportTarget(This,ppwszIscsiName) ) 

#define IVdsSubSystemImportTarget_SetImportTarget(This,pwszIscsiName)	\
    ( (This)->lpVtbl -> SetImportTarget(This,pwszIscsiName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemImportTarget_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiPortalLocal_INTERFACE_DEFINED__
#define __IVdsIscsiPortalLocal_INTERFACE_DEFINED__

/* interface IVdsIscsiPortalLocal */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiPortalLocal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ad837c28-52c1-421d-bf04-fae7da665396")
    IVdsIscsiPortalLocal : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecSecurityLocal( 
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiPortalLocalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiPortalLocal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiPortalLocal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiPortalLocal * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecSecurityLocal )( 
            __RPC__in IVdsIscsiPortalLocal * This,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsIscsiPortalLocalVtbl;

    interface IVdsIscsiPortalLocal
    {
        CONST_VTBL struct IVdsIscsiPortalLocalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiPortalLocal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiPortalLocal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiPortalLocal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiPortalLocal_SetIpsecSecurityLocal(This,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecSecurityLocal(This,ullSecurityFlags,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiPortalLocal_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceSAN_INTERFACE_DEFINED__
#define __IVdsServiceSAN_INTERFACE_DEFINED__

/* interface IVdsServiceSAN */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceSAN;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FC5D23E8-A88B-41a5-8DE0-2D2F73C5A630")
    IVdsServiceSAN : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSANPolicy( 
            /* [out] */ __RPC__out VDS_SAN_POLICY *pSanPolicy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSANPolicy( 
            /* [in] */ VDS_SAN_POLICY SanPolicy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceSANVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsServiceSAN * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsServiceSAN * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsServiceSAN * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSANPolicy )( 
            __RPC__in IVdsServiceSAN * This,
            /* [out] */ __RPC__out VDS_SAN_POLICY *pSanPolicy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSANPolicy )( 
            __RPC__in IVdsServiceSAN * This,
            /* [in] */ VDS_SAN_POLICY SanPolicy);
        
        END_INTERFACE
    } IVdsServiceSANVtbl;

    interface IVdsServiceSAN
    {
        CONST_VTBL struct IVdsServiceSANVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceSAN_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceSAN_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceSAN_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceSAN_GetSANPolicy(This,pSanPolicy)	\
    ( (This)->lpVtbl -> GetSANPolicy(This,pSanPolicy) ) 

#define IVdsServiceSAN_SetSANPolicy(This,SanPolicy)	\
    ( (This)->lpVtbl -> SetSANPolicy(This,SanPolicy) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceSAN_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeMF3_INTERFACE_DEFINED__
#define __IVdsVolumeMF3_INTERFACE_DEFINED__

/* interface IVdsVolumeMF3 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeMF3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6788FAF9-214E-4b85-BA59-266953616E09")
    IVdsVolumeMF3 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryVolumeGuidPathnames( 
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*pulNumberOfPaths) LPWSTR **pwszPathArray,
            /* [out] */ __RPC__out ULONG *pulNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatEx2( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ DWORD Options,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OfflineVolume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeMF3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolumeMF3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolumeMF3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolumeMF3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryVolumeGuidPathnames )( 
            __RPC__in IVdsVolumeMF3 * This,
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*pulNumberOfPaths) LPWSTR **pwszPathArray,
            /* [out] */ __RPC__out ULONG *pulNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatEx2 )( 
            __RPC__in IVdsVolumeMF3 * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ DWORD Options,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OfflineVolume )( 
            __RPC__in IVdsVolumeMF3 * This);
        
        END_INTERFACE
    } IVdsVolumeMF3Vtbl;

    interface IVdsVolumeMF3
    {
        CONST_VTBL struct IVdsVolumeMF3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeMF3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeMF3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeMF3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeMF3_QueryVolumeGuidPathnames(This,pwszPathArray,pulNumberOfPaths)	\
    ( (This)->lpVtbl -> QueryVolumeGuidPathnames(This,pwszPathArray,pulNumberOfPaths) ) 

#define IVdsVolumeMF3_FormatEx2(This,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,Options,ppAsync)	\
    ( (This)->lpVtbl -> FormatEx2(This,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,Options,ppAsync) ) 

#define IVdsVolumeMF3_OfflineVolume(This)	\
    ( (This)->lpVtbl -> OfflineVolume(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeMF3_INTERFACE_DEFINED__ */


#ifndef __IVdsDiskPartitionMF2_INTERFACE_DEFINED__
#define __IVdsDiskPartitionMF2_INTERFACE_DEFINED__

/* interface IVdsDiskPartitionMF2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDiskPartitionMF2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9CBE50CA-F2D2-4bf4-ACE1-96896B729625")
    IVdsDiskPartitionMF2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatPartitionEx2( 
            /* [in] */ ULONGLONG ullOffset,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ DWORD Options,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDiskPartitionMF2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDiskPartitionMF2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDiskPartitionMF2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDiskPartitionMF2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatPartitionEx2 )( 
            __RPC__in IVdsDiskPartitionMF2 * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ DWORD Options,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsDiskPartitionMF2Vtbl;

    interface IVdsDiskPartitionMF2
    {
        CONST_VTBL struct IVdsDiskPartitionMF2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDiskPartitionMF2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDiskPartitionMF2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDiskPartitionMF2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDiskPartitionMF2_FormatPartitionEx2(This,ullOffset,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,Options,ppAsync)	\
    ( (This)->lpVtbl -> FormatPartitionEx2(This,ullOffset,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,Options,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDiskPartitionMF2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\VerRsrc.h ===
/*****************************************************************************\
*                                                                             *
* verrsrc.h -   Version Resource definitions                                  *
*                                                                             *
*               Include file declaring version resources in rc files          *
*                                                                             *
*               Copyright (c) Microsoft Corporation. All rights reserved.     *
*                                                                             *
\*****************************************************************************/

/* ----- Symbols ----- */
#define VS_FILE_INFO            RT_VERSION
#define VS_VERSION_INFO         1
#define VS_USER_DEFINED         100

/* ----- VS_VERSION.dwFileFlags ----- */
#ifndef _MAC
#define VS_FFI_SIGNATURE        0xFEEF04BDL
#else
#define VS_FFI_SIGNATURE        0xBD04EFFEL
#endif
#define VS_FFI_STRUCVERSION     0x00010000L
#define VS_FFI_FILEFLAGSMASK    0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FF_DEBUG             0x00000001L
#define VS_FF_PRERELEASE        0x00000002L
#define VS_FF_PATCHED           0x00000004L
#define VS_FF_PRIVATEBUILD      0x00000008L
#define VS_FF_INFOINFERRED      0x00000010L
#define VS_FF_SPECIALBUILD      0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define VOS_UNKNOWN             0x00000000L
#define VOS_DOS                 0x00010000L
#define VOS_OS216               0x00020000L
#define VOS_OS232               0x00030000L
#define VOS_NT                  0x00040000L
#define VOS_WINCE               0x00050000L

#define VOS__BASE               0x00000000L
#define VOS__WINDOWS16          0x00000001L
#define VOS__PM16               0x00000002L
#define VOS__PM32               0x00000003L
#define VOS__WINDOWS32          0x00000004L

#define VOS_DOS_WINDOWS16       0x00010001L
#define VOS_DOS_WINDOWS32       0x00010004L
#define VOS_OS216_PM16          0x00020002L
#define VOS_OS232_PM32          0x00030003L
#define VOS_NT_WINDOWS32        0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define VFT_UNKNOWN             0x00000000L
#define VFT_APP                 0x00000001L
#define VFT_DLL                 0x00000002L
#define VFT_DRV                 0x00000003L
#define VFT_FONT                0x00000004L
#define VFT_VXD                 0x00000005L
#define VFT_STATIC_LIB          0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define VFT2_UNKNOWN            0x00000000L
#define VFT2_DRV_PRINTER        0x00000001L
#define VFT2_DRV_KEYBOARD       0x00000002L
#define VFT2_DRV_LANGUAGE       0x00000003L
#define VFT2_DRV_DISPLAY        0x00000004L
#define VFT2_DRV_MOUSE          0x00000005L
#define VFT2_DRV_NETWORK        0x00000006L
#define VFT2_DRV_SYSTEM         0x00000007L
#define VFT2_DRV_INSTALLABLE    0x00000008L
#define VFT2_DRV_SOUND          0x00000009L
#define VFT2_DRV_COMM           0x0000000AL
#define VFT2_DRV_INPUTMETHOD    0x0000000BL
#define VFT2_DRV_VERSIONED_PRINTER    0x0000000CL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER        0x00000001L
#define VFT2_FONT_VECTOR        0x00000002L
#define VFT2_FONT_TRUETYPE      0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE       0x0001

#define VFF_CURNEDEST           0x0001
#define VFF_FILEINUSE           0x0002
#define VFF_BUFFTOOSMALL        0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL       0x0001
#define VIFF_DONTDELETEOLD      0x0002

#define VIF_TEMPFILE            0x00000001L
#define VIF_MISMATCH            0x00000002L
#define VIF_SRCOLD              0x00000004L

#define VIF_DIFFLANG            0x00000008L
#define VIF_DIFFCODEPG          0x00000010L
#define VIF_DIFFTYPE            0x00000020L

#define VIF_WRITEPROT           0x00000040L
#define VIF_FILEINUSE           0x00000080L
#define VIF_OUTOFSPACE          0x00000100L
#define VIF_ACCESSVIOLATION     0x00000200L
#define VIF_SHARINGVIOLATION    0x00000400L
#define VIF_CANNOTCREATE        0x00000800L
#define VIF_CANNOTDELETE        0x00001000L
#define VIF_CANNOTRENAME        0x00002000L
#define VIF_CANNOTDELETECUR     0x00004000L
#define VIF_OUTOFMEMORY         0x00008000L

#define VIF_CANNOTREADSRC       0x00010000L
#define VIF_CANNOTREADDST       0x00020000L

#define VIF_BUFFTOOSMALL        0x00040000L
#define VIF_CANNOTLOADLZ32      0x00080000L
#define VIF_CANNOTLOADCABINET   0x00100000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

#ifdef __cplusplus
extern "C" {
#endif
    
/* 
    FILE_VER_GET_... flags are for use by 
    GetFileVersionInfoSizeEx
    GetFileVersionInfoExW
*/
#define FILE_VER_GET_LOCALISED  0x01
#define FILE_VER_GET_NEUTRAL    0x02
#define FILE_VER_GET_PREFETCHED 0x04

/* ----- Types and structures ----- */

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

#ifdef __cplusplus
}
#endif

#endif  /* !RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vdssys.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vdssys.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __vdssys_h__
#define __vdssys_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vdssys_0000_0000 */
/* [local] */ 

#if (WINVER >= _WIN32_WINNT_WIN7)
#if defined(VDS_MIDL_PASS)
typedef LPWSTR PWSTR;

typedef LPCWSTR PCWSTR;

typedef DWORD ACCESS_MASK;

#pragma warning(push)
#pragma warning(disable:4001) 
#pragma once
#pragma warning(pop)
typedef PVOID PSECURITY_DESCRIPTOR;

typedef PVOID LPOVERLAPPED;

typedef ULONG *PULONG;

typedef HANDLE *PHANDLE;

#pragma once
#pragma once
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4200)
#pragma warning(disable : 4201)
typedef struct _VIRTUAL_STORAGE_TYPE
    {
    ULONG DeviceId;
    GUID VendorId;
    } 	VIRTUAL_STORAGE_TYPE;

typedef struct _VIRTUAL_STORAGE_TYPE *PVIRTUAL_STORAGE_TYPE;

typedef 
enum _CREATE_VIRTUAL_DISK_VERSION
    {	CREATE_VIRTUAL_DISK_VERSION_UNSPECIFIED	= 0,
	CREATE_VIRTUAL_DISK_VERSION_1	= 1
    } 	CREATE_VIRTUAL_DISK_VERSION;

typedef struct _CREATE_VIRTUAL_DISK_PARAMETERS
    {
    CREATE_VIRTUAL_DISK_VERSION Version;
    union 
        {
        struct 
            {
            GUID UniqueId;
            ULONGLONG MaximumSize;
            ULONG BlockSizeInBytes;
            ULONG SectorSizeInBytes;
            PCWSTR ParentPath;
            PCWSTR SourcePath;
            } 	Version1;
        } 	;
    } 	CREATE_VIRTUAL_DISK_PARAMETERS;

typedef struct _CREATE_VIRTUAL_DISK_PARAMETERS *PCREATE_VIRTUAL_DISK_PARAMETERS;

typedef 
enum _CREATE_VIRTUAL_DISK_FLAG
    {	CREATE_VIRTUAL_DISK_FLAG_NONE	= 0,
	CREATE_VIRTUAL_DISK_FLAG_FULL_PHYSICAL_ALLOCATION	= 0x1
    } 	CREATE_VIRTUAL_DISK_FLAG;

typedef 
enum _OPEN_VIRTUAL_DISK_VERSION
    {	OPEN_VIRTUAL_DISK_VERSION_UNSPECIFIED	= 0,
	OPEN_VIRTUAL_DISK_VERSION_1	= 1
    } 	OPEN_VIRTUAL_DISK_VERSION;

typedef struct _OPEN_VIRTUAL_DISK_PARAMETERS
    {
    OPEN_VIRTUAL_DISK_VERSION Version;
    union 
        {
        struct 
            {
            ULONG RWDepth;
            } 	Version1;
        } 	;
    } 	OPEN_VIRTUAL_DISK_PARAMETERS;

typedef struct _OPEN_VIRTUAL_DISK_PARAMETERS *POPEN_VIRTUAL_DISK_PARAMETERS;

typedef /* [v1_enum] */ 
enum _VIRTUAL_DISK_ACCESS_MASK
    {	VIRTUAL_DISK_ACCESS_ATTACH_RO	= 0x10000,
	VIRTUAL_DISK_ACCESS_ATTACH_RW	= 0x20000,
	VIRTUAL_DISK_ACCESS_DETACH	= 0x40000,
	VIRTUAL_DISK_ACCESS_GET_INFO	= 0x80000,
	VIRTUAL_DISK_ACCESS_CREATE	= 0x100000,
	VIRTUAL_DISK_ACCESS_METAOPS	= 0x200000,
	VIRTUAL_DISK_ACCESS_READ	= 0xd0000,
	VIRTUAL_DISK_ACCESS_ALL	= 0x3f0000,
	VIRTUAL_DISK_ACCESS_WRITABLE	= 0x320000
    } 	VIRTUAL_DISK_ACCESS_MASK;

typedef 
enum _OPEN_VIRTUAL_DISK_FLAG
    {	OPEN_VIRTUAL_DISK_FLAG_NONE	= 0,
	OPEN_VIRTUAL_DISK_FLAG_NO_PARENTS	= 0x1,
	OPEN_VIRTUAL_DISK_FLAG_BLANK_FILE	= 0x2,
	OPEN_VIRTUAL_DISK_FLAG_BOOT_DRIVE	= 0x4
    } 	OPEN_VIRTUAL_DISK_FLAG;

DWORD __stdcall OpenVirtualDisk( 
    PVIRTUAL_STORAGE_TYPE VirtualStorageType,
    PCWSTR Path,
    VIRTUAL_DISK_ACCESS_MASK VirtualDiskAccessMask,
    OPEN_VIRTUAL_DISK_FLAG Flags,
    POPEN_VIRTUAL_DISK_PARAMETERS Parameters,
    PHANDLE Handle);

DWORD __stdcall CreateVirtualDisk( 
    PVIRTUAL_STORAGE_TYPE VirtualStorageType,
    PCWSTR Path,
    VIRTUAL_DISK_ACCESS_MASK VirtualDiskAccessMask,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    CREATE_VIRTUAL_DISK_FLAG Flags,
    ULONG ProviderSpecificFlags,
    PCREATE_VIRTUAL_DISK_PARAMETERS Parameters,
    LPOVERLAPPED Overlapped,
    PHANDLE Handle);

typedef 
enum _ATTACH_VIRTUAL_DISK_VERSION
    {	ATTACH_VIRTUAL_DISK_VERSION_UNSPECIFIED	= 0,
	ATTACH_VIRTUAL_DISK_VERSION_1	= 1
    } 	ATTACH_VIRTUAL_DISK_VERSION;

typedef struct _ATTACH_VIRTUAL_DISK_PARAMETERS
    {
    ATTACH_VIRTUAL_DISK_VERSION Version;
    union 
        {
        struct 
            {
            ULONG Reserved;
            } 	Version1;
        } 	;
    } 	ATTACH_VIRTUAL_DISK_PARAMETERS;

typedef struct _ATTACH_VIRTUAL_DISK_PARAMETERS *PATTACH_VIRTUAL_DISK_PARAMETERS;

typedef 
enum _ATTACH_VIRTUAL_DISK_FLAG
    {	ATTACH_VIRTUAL_DISK_FLAG_NONE	= 0,
	ATTACH_VIRTUAL_DISK_FLAG_READ_ONLY	= 0x1,
	ATTACH_VIRTUAL_DISK_FLAG_NO_DRIVE_LETTER	= 0x2,
	ATTACH_VIRTUAL_DISK_FLAG_PERMANENT_LIFETIME	= 0x4,
	ATTACH_VIRTUAL_DISK_FLAG_NO_LOCAL_HOST	= 0x8
    } 	ATTACH_VIRTUAL_DISK_FLAG;

DWORD __stdcall AttachVirtualDisk( 
    HANDLE VirtualDiskHandle,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ATTACH_VIRTUAL_DISK_FLAG Flags,
    ULONG ProviderSpecificFlags,
    PATTACH_VIRTUAL_DISK_PARAMETERS Parameters,
    LPOVERLAPPED Overlapped);

typedef 
enum _DETACH_VIRTUAL_DISK_FLAG
    {	DETACH_VIRTUAL_DISK_FLAG_NONE	= 0
    } 	DETACH_VIRTUAL_DISK_FLAG;

DWORD __stdcall DetachVirtualDisk( 
    HANDLE VirtualDiskHandle,
    DETACH_VIRTUAL_DISK_FLAG Flags,
    ULONG ProviderSpecificFlags);

DWORD __stdcall GetVirtualDiskPhysicalPath( 
    HANDLE VirtualDiskHandle,
    PULONG DiskPathSizeInBytes,
    PWSTR DiskPath);

typedef 
enum _DEPENDENT_DISK_FLAG
    {	DEPENDENT_DISK_FLAG_NONE	= 0,
	DEPENDENT_DISK_FLAG_MULT_BACKING_FILES	= 0x1,
	DEPENDENT_DISK_FLAG_FULLY_ALLOCATED	= 0x2,
	DEPENDENT_DISK_FLAG_READ_ONLY	= 0x4,
	DEPENDENT_DISK_FLAG_REMOTE	= 0x8,
	DEPENDENT_DISK_FLAG_SYSTEM_VOLUME	= 0x10,
	DEPENDENT_DISK_FLAG_SYSTEM_VOLUME_PARENT	= 0x20,
	DEPENDENT_DISK_FLAG_REMOVABLE	= 0x40,
	DEPENDENT_DISK_FLAG_NO_DRIVE_LETTER	= 0x80,
	DEPENDENT_DISK_FLAG_PARENT	= 0x100,
	DEPENDENT_DISK_FLAG_NO_HOST_DISK	= 0x200,
	DEPENDENT_DISK_FLAG_PERMANENT_LIFETIME	= 0x400
    } 	DEPENDENT_DISK_FLAG;

typedef 
enum _STORAGE_DEPENDENCY_INFO_VERSION
    {	STORAGE_DEPENDENCY_INFO_VERSION_UNSPECIFIED	= 0,
	STORAGE_DEPENDENCY_INFO_VERSION_1	= 1,
	STORAGE_DEPENDENCY_INFO_VERSION_2	= 2
    } 	STORAGE_DEPENDENCY_INFO_VERSION;

typedef struct _STORAGE_DEPENDENCY_INFO_TYPE_1
    {
    DEPENDENT_DISK_FLAG DependencyTypeFlags;
    ULONG ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
    } 	STORAGE_DEPENDENCY_INFO_TYPE_1;

typedef struct _STORAGE_DEPENDENCY_INFO_TYPE_1 *PSTORAGE_DEPENDENCY_INFO_TYPE_1;

typedef struct _STORAGE_DEPENDENCY_INFO_TYPE_2
    {
    DEPENDENT_DISK_FLAG DependencyTypeFlags;
    ULONG ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
    ULONG AncestorLevel;
    PWSTR DependencyDeviceName;
    PWSTR HostVolumeName;
    PWSTR DependentVolumeName;
    PWSTR DependentVolumeRelativePath;
    } 	STORAGE_DEPENDENCY_INFO_TYPE_2;

typedef struct _STORAGE_DEPENDENCY_INFO_TYPE_2 *PSTORAGE_DEPENDENCY_INFO_TYPE_2;

typedef struct _STORAGE_DEPENDENCY_INFO
    {
    STORAGE_DEPENDENCY_INFO_VERSION Version;
    ULONG NumberEntries;
    union 
        {
        STORAGE_DEPENDENCY_INFO_TYPE_1 Version1Entries[ 1 ];
        STORAGE_DEPENDENCY_INFO_TYPE_2 Version2Entries[ 1 ];
        } 	;
    } 	STORAGE_DEPENDENCY_INFO;

typedef struct _STORAGE_DEPENDENCY_INFO *PSTORAGE_DEPENDENCY_INFO;

typedef 
enum _GET_STORAGE_DEPENDENCY_FLAG
    {	GET_STORAGE_DEPENDENCY_FLAG_NONE	= 0,
	GET_STORAGE_DEPENDENCY_FLAG_HOST_VOLUMES	= 0x1,
	GET_STORAGE_DEPENDENCY_FLAG_DISK_HANDLE	= 0x2
    } 	GET_STORAGE_DEPENDENCY_FLAG;

DWORD __stdcall GetStorageDependencyInformation( 
    HANDLE ObjectHandle,
    GET_STORAGE_DEPENDENCY_FLAG Flags,
    ULONG StorageDependencyInfoSize,
    PSTORAGE_DEPENDENCY_INFO StorageDependencyInfo,
    PULONG SizeUsed);

typedef 
enum _GET_VIRTUAL_DISK_INFO_VERSION
    {	GET_VIRTUAL_DISK_INFO_UNSPECIFIED	= 0,
	GET_VIRTUAL_DISK_INFO_SIZE	= 1,
	GET_VIRTUAL_DISK_INFO_IDENTIFIER	= 2,
	GET_VIRTUAL_DISK_INFO_PARENT_LOCATION	= 3,
	GET_VIRTUAL_DISK_INFO_PARENT_IDENTIFIER	= 4,
	GET_VIRTUAL_DISK_INFO_PARENT_TIMESTAMP	= 5,
	GET_VIRTUAL_DISK_INFO_VIRTUAL_STORAGE_TYPE	= 6,
	GET_VIRTUAL_DISK_INFO_PROVIDER_SUBTYPE	= 7
    } 	GET_VIRTUAL_DISK_INFO_VERSION;

typedef struct _GET_VIRTUAL_DISK_INFO
    {
    GET_VIRTUAL_DISK_INFO_VERSION Version;
    union 
        {
        struct 
            {
            ULONGLONG VirtualSize;
            ULONGLONG PhysicalSize;
            ULONG BlockSize;
            ULONG SectorSize;
            } 	Size;
        GUID Identifier;
        struct 
            {
            BOOL ParentResolved;
            WCHAR ParentLocationBuffer[ 1 ];
            } 	ParentLocation;
        GUID ParentIdentifier;
        ULONG ParentTimestamp;
        VIRTUAL_STORAGE_TYPE VirtualStorageType;
        ULONG ProviderSubtype;
        } 	;
    } 	GET_VIRTUAL_DISK_INFO;

typedef struct _GET_VIRTUAL_DISK_INFO *PGET_VIRTUAL_DISK_INFO;

DWORD __stdcall GetVirtualDiskInformation( 
    HANDLE VirtualDiskHandle,
    PULONG VirtualDiskInfoSize,
    PGET_VIRTUAL_DISK_INFO VirtualDiskInfo,
    PULONG SizeUsed);

typedef 
enum _SET_VIRTUAL_DISK_INFO_VERSION
    {	SET_VIRTUAL_DISK_INFO_UNSPECIFIED	= 0,
	SET_VIRTUAL_DISK_INFO_PARENT_PATH	= 1,
	SET_VIRTUAL_DISK_INFO_IDENTIFIER	= 2
    } 	SET_VIRTUAL_DISK_INFO_VERSION;

typedef struct _SET_VIRTUAL_DISK_INFO
    {
    SET_VIRTUAL_DISK_INFO_VERSION Version;
    union 
        {
        PCWSTR ParentFilePath;
        GUID UniqueIdentifier;
        } 	;
    } 	SET_VIRTUAL_DISK_INFO;

typedef struct _SET_VIRTUAL_DISK_INFO *PSET_VIRTUAL_DISK_INFO;

DWORD __stdcall SetVirtualDiskInformation( 
    HANDLE VirtualDiskHandle,
    PSET_VIRTUAL_DISK_INFO VirtualDiskInfo);

typedef struct _VIRTUAL_DISK_PROGRESS
    {
    DWORD OperationStatus;
    ULONGLONG CurrentValue;
    ULONGLONG CompletionValue;
    } 	VIRTUAL_DISK_PROGRESS;

typedef struct _VIRTUAL_DISK_PROGRESS *PVIRTUAL_DISK_PROGRESS;

DWORD __stdcall GetVirtualDiskOperationProgress( 
    HANDLE VirtualDiskHandle,
    LPOVERLAPPED Overlapped,
    PVIRTUAL_DISK_PROGRESS Progress);

typedef 
enum _COMPACT_VIRTUAL_DISK_VERSION
    {	COMPACT_VIRTUAL_DISK_VERSION_UNSPECIFIED	= 0,
	COMPACT_VIRTUAL_DISK_VERSION_1	= 1
    } 	COMPACT_VIRTUAL_DISK_VERSION;

typedef struct _COMPACT_VIRTUAL_DISK_PARAMETERS
    {
    COMPACT_VIRTUAL_DISK_VERSION Version;
    union 
        {
        struct 
            {
            ULONG Reserved;
            } 	Version1;
        } 	;
    } 	COMPACT_VIRTUAL_DISK_PARAMETERS;

typedef struct _COMPACT_VIRTUAL_DISK_PARAMETERS *PCOMPACT_VIRTUAL_DISK_PARAMETERS;

typedef 
enum _COMPACT_VIRTUAL_DISK_FLAG
    {	COMPACT_VIRTUAL_DISK_FLAG_NONE	= 0
    } 	COMPACT_VIRTUAL_DISK_FLAG;

DWORD __stdcall CompactVirtualDisk( 
    HANDLE VirtualDiskHandle,
    COMPACT_VIRTUAL_DISK_FLAG Flags,
    PCOMPACT_VIRTUAL_DISK_PARAMETERS Parameters,
    LPOVERLAPPED Overlapped);

typedef 
enum _MERGE_VIRTUAL_DISK_VERSION
    {	MERGE_VIRTUAL_DISK_VERSION_UNSPECIFIED	= 0,
	MERGE_VIRTUAL_DISK_VERSION_1	= 1
    } 	MERGE_VIRTUAL_DISK_VERSION;

typedef struct _MERGE_VIRTUAL_DISK_PARAMETERS
    {
    MERGE_VIRTUAL_DISK_VERSION Version;
    union 
        {
        struct 
            {
            ULONG MergeDepth;
            } 	Version1;
        } 	;
    } 	MERGE_VIRTUAL_DISK_PARAMETERS;

typedef struct _MERGE_VIRTUAL_DISK_PARAMETERS *PMERGE_VIRTUAL_DISK_PARAMETERS;

typedef 
enum _MERGE_VIRTUAL_DISK_FLAG
    {	MERGE_VIRTUAL_DISK_FLAG_NONE	= 0
    } 	MERGE_VIRTUAL_DISK_FLAG;

DWORD __stdcall MergeVirtualDisk( 
    HANDLE VirtualDiskHandle,
    MERGE_VIRTUAL_DISK_FLAG Flags,
    PMERGE_VIRTUAL_DISK_PARAMETERS Parameters,
    LPOVERLAPPED Overlapped);

typedef 
enum _EXPAND_VIRTUAL_DISK_VERSION
    {	EXPAND_VIRTUAL_DISK_VERSION_UNSPECIFIED	= 0,
	EXPAND_VIRTUAL_DISK_VERSION_1	= 1
    } 	EXPAND_VIRTUAL_DISK_VERSION;

typedef struct _EXPAND_VIRTUAL_DISK_PARAMETERS
    {
    EXPAND_VIRTUAL_DISK_VERSION Version;
    union 
        {
        struct 
            {
            ULONGLONG NewSize;
            } 	Version1;
        } 	;
    } 	EXPAND_VIRTUAL_DISK_PARAMETERS;

typedef struct _EXPAND_VIRTUAL_DISK_PARAMETERS *PEXPAND_VIRTUAL_DISK_PARAMETERS;

typedef 
enum _EXPAND_VIRTUAL_DISK_FLAG
    {	EXPAND_VIRTUAL_DISK_FLAG_NONE	= 0
    } 	EXPAND_VIRTUAL_DISK_FLAG;

DWORD __stdcall ExpandVirtualDisk( 
    HANDLE VirtualDiskHandle,
    EXPAND_VIRTUAL_DISK_FLAG Flags,
    PEXPAND_VIRTUAL_DISK_PARAMETERS Parameters,
    LPOVERLAPPED Overlapped);

typedef 
enum _SURFACE_VIRTUAL_DISK_FLAG
    {	SURFACE_VIRTUAL_DISK_FLAG_NONE	= 0,
	SURFACE_VIRTUAL_DISK_FLAG_READ_ONLY	= 0x1,
	SURFACE_VIRTUAL_DISK_FLAG_NO_DRIVE_LETTER	= 0x2,
	SURFACE_VIRTUAL_DISK_FLAG_PERMANENT_LIFETIME	= 0x4,
	SURFACE_VIRTUAL_DISK_FLAG_NO_LOCAL_HOST	= 0x8
    } 	SURFACE_VIRTUAL_DISK_FLAG;

typedef 
enum _UNSURFACE_VIRTUAL_DISK_FLAG
    {	UNSURFACE_VIRTUAL_DISK_FLAG_NONE	= 0
    } 	UNSURFACE_VIRTUAL_DISK_FLAG;

#pragma warning(pop)
#else //defined(VDS_MIDL_PASS)
#include "virtdisk.h"
#endif //defined(VDS_MIDL_PASS)
#endif // _WIN32_WINNT_WIN7


extern RPC_IF_HANDLE __MIDL_itf_vdssys_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdssys_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Vfw.h ===
/****************************************************************************
 *
 *      VfW.H - Video for windows include file for WIN32
 *
 *      Copyright (c) 1991-1995, Microsoft Corp.  All rights reserved.
 *
 *      This include files defines interfaces to the following
 *      video components
 *
 *          COMPMAN         - Installable Compression Manager.
 *          DRAWDIB         - Routines for drawing to the display.
 *          VIDEO           - Video Capture Driver Interface
 *
 *          AVIFMT          - AVI File Format structure definitions.
 *          MMREG           - FOURCC and other things
 *
 *          AVIFile         - Interface for reading AVI Files and AVI Streams
 *          MCIWND          - MCI/AVI window class
 *          AVICAP          - AVI Capture Window class
 *
 *          MSACM           - Audio compression manager.
 *
 *      The following symbols control inclusion of various parts of this file:
 *
 *          NOCOMPMAN       - dont include COMPMAN
 *          NODRAWDIB       - dont include DRAWDIB
 *          NOVIDEO         - dont include video capture interface
 *
 *          NOAVIFMT        - dont include AVI file format structs
 *          NOMMREG         - dont include MMREG
 *
 *          NOAVIFILE       - dont include AVIFile interface
 *          NOMCIWND        - dont include AVIWnd class.
 *          NOAVICAP        - dont include AVICap class.
 *
 *          NOMSACM         - dont include ACM stuff.
 *
 ****************************************************************************/

#ifndef _INC_VFW
#define _INC_VFW

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****************************************************************************
 *
 *  types
 *
 ***************************************************************************/

#define VFWAPI  WINAPI
#define VFWAPIV WINAPIV
#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
#define VFWAPI_INLINE  WINAPI_INLINE
#else
#define VFWAPI_INLINE  WINAPI
#endif

/****************************************************************************
 *
 *  VideoForWindowsVersion() - returns version of VfW
 *
 ***************************************************************************/

DWORD FAR PASCAL VideoForWindowsVersion(void);

/****************************************************************************
 *
 *  call these to start stop using VfW from your app.
 *
 ***************************************************************************/

LONG VFWAPI InitVFW(void);
LONG VFWAPI TermVFW(void);

#ifdef __cplusplus
} // extern "C"
#endif  /* __cplusplus */


/****************************************************************************
 *
 *  do we need MMSYSTEM?
 *
 ****************************************************************************/

#if !defined(_INC_MMSYSTEM) && (!defined(NOVIDEO) || !defined(NOAVICAP))
    #include <mmsystem.h>
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****************************************************************************/
/*                                                                          */
/*        Macros                                                            */
/*                                                                          */
/*  should we define this??                                                 */
/*                                                                          */
/****************************************************************************/

#ifndef MKFOURCC
#define MKFOURCC( ch0, ch1, ch2, ch3 )                                    \
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#if !defined(_INC_MMSYSTEM)
    #define mmioFOURCC MKFOURCC
#endif

/****************************************************************************
 *
 *  COMPMAN - Installable Compression Manager.
 *
 ****************************************************************************/

#ifndef NOCOMPMAN

#define ICVERSION       0x0104

DECLARE_HANDLE(HIC);     /* Handle to a Installable Compressor */

//
// this code in biCompression means the DIB must be accesed via
// 48 bit pointers! using *ONLY* the selector given.
//
#define BI_1632  0x32333631     // '1632'

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO    mmioFOURCC('v', 'i', 'd', 'c')
#define ICTYPE_AUDIO    mmioFOURCC('a', 'u', 'd', 'c')
#endif

#ifndef ICERR_OK
#define ICERR_OK                0L
#define ICERR_DONTDRAW          1L
#define ICERR_NEWPALETTE        2L
#define ICERR_GOTOKEYFRAME	3L
#define ICERR_STOPDRAWING 	4L

#define ICERR_UNSUPPORTED      -1L
#define ICERR_BADFORMAT        -2L
#define ICERR_MEMORY           -3L
#define ICERR_INTERNAL         -4L
#define ICERR_BADFLAGS         -5L
#define ICERR_BADPARAM         -6L
#define ICERR_BADSIZE          -7L
#define ICERR_BADHANDLE        -8L
#define ICERR_CANTUPDATE       -9L
#define ICERR_ABORT	       -10L
#define ICERR_ERROR            -100L
#define ICERR_BADBITDEPTH      -200L
#define ICERR_BADIMAGESIZE     -201L

#define ICERR_CUSTOM           -400L    // errors less than ICERR_CUSTOM...
#endif

/* Values for dwFlags of ICOpen() */
#ifndef ICMODE_COMPRESS
#define ICMODE_COMPRESS		1
#define ICMODE_DECOMPRESS	2
#define ICMODE_FASTDECOMPRESS   3
#define ICMODE_QUERY            4
#define ICMODE_FASTCOMPRESS     5
#define ICMODE_DRAW             8
#endif
#ifndef _WIN32					// ;Internal
#define ICMODE_INTERNALF_FUNCTION32	0x8000	// ;Internal
#define ICMODE_INTERNALF_MASK		0x8000	// ;Internal
#endif						// ;Internal

/* Flags for AVI file index */
#define AVIIF_LIST	0x00000001L
#define AVIIF_TWOCC	0x00000002L
#define AVIIF_KEYFRAME	0x00000010L

/* quality flags */
#define ICQUALITY_LOW       0
#define ICQUALITY_HIGH      10000
#define ICQUALITY_DEFAULT   -1

/************************************************************************
************************************************************************/

#define ICM_USER          (DRV_USER+0x0000)

#define ICM_RESERVED      ICM_RESERVED_LOW
#define ICM_RESERVED_LOW  (DRV_USER+0x1000)
#define ICM_RESERVED_HIGH (DRV_USER+0x2000)

/************************************************************************

    messages.

************************************************************************/

#define ICM_GETSTATE                (ICM_RESERVED+0)    // Get compressor state
#define ICM_SETSTATE                (ICM_RESERVED+1)    // Set compressor state
#define ICM_GETINFO                 (ICM_RESERVED+2)    // Query info about the compressor

#define ICM_CONFIGURE               (ICM_RESERVED+10)   // show the configure dialog
#define ICM_ABOUT                   (ICM_RESERVED+11)   // show the about box

#define ICM_GETERRORTEXT            (ICM_RESERVED+12)   // get error text TBD ;Internal
#define ICM_GETFORMATNAME	    (ICM_RESERVED+20)	// get a name for a format ;Internal
#define ICM_ENUMFORMATS		    (ICM_RESERVED+21)	// cycle through formats ;Internal

#define ICM_GETDEFAULTQUALITY       (ICM_RESERVED+30)   // get the default value for quality
#define ICM_GETQUALITY              (ICM_RESERVED+31)   // get the current value for quality
#define ICM_SETQUALITY              (ICM_RESERVED+32)   // set the default value for quality

#define ICM_SET			    (ICM_RESERVED+40)	// Tell the driver something
#define ICM_GET			    (ICM_RESERVED+41)	// Ask the driver something

// Constants for ICM_SET:
#define ICM_FRAMERATE       mmioFOURCC('F','r','m','R')
#define ICM_KEYFRAMERATE    mmioFOURCC('K','e','y','R')

/************************************************************************

    ICM specific messages.

************************************************************************/

#define ICM_COMPRESS_GET_FORMAT     (ICM_USER+4)    // get compress format or size
#define ICM_COMPRESS_GET_SIZE       (ICM_USER+5)    // get output size
#define ICM_COMPRESS_QUERY          (ICM_USER+6)    // query support for compress
#define ICM_COMPRESS_BEGIN          (ICM_USER+7)    // begin a series of compress calls.
#define ICM_COMPRESS                (ICM_USER+8)    // compress a frame
#define ICM_COMPRESS_END            (ICM_USER+9)    // end of a series of compress calls.

#define ICM_DECOMPRESS_GET_FORMAT   (ICM_USER+10)   // get decompress format or size
#define ICM_DECOMPRESS_QUERY        (ICM_USER+11)   // query support for dempress
#define ICM_DECOMPRESS_BEGIN        (ICM_USER+12)   // start a series of decompress calls
#define ICM_DECOMPRESS              (ICM_USER+13)   // decompress a frame
#define ICM_DECOMPRESS_END          (ICM_USER+14)   // end a series of decompress calls
#define ICM_DECOMPRESS_SET_PALETTE  (ICM_USER+29)   // fill in the DIB color table
#define ICM_DECOMPRESS_GET_PALETTE  (ICM_USER+30)   // fill in the DIB color table

#define ICM_DRAW_QUERY              (ICM_USER+31)   // query support for dempress
#define ICM_DRAW_BEGIN              (ICM_USER+15)   // start a series of draw calls
#define ICM_DRAW_GET_PALETTE        (ICM_USER+16)   // get the palette needed for drawing
#define ICM_DRAW_UPDATE             (ICM_USER+17)   // update screen with current frame ;Internal
#define ICM_DRAW_START              (ICM_USER+18)   // start decompress clock
#define ICM_DRAW_STOP               (ICM_USER+19)   // stop decompress clock
#define ICM_DRAW_BITS               (ICM_USER+20)   // decompress a frame to screen ;Internal
#define ICM_DRAW_END                (ICM_USER+21)   // end a series of draw calls
#define ICM_DRAW_GETTIME            (ICM_USER+32)   // get value of decompress clock
#define ICM_DRAW                    (ICM_USER+33)   // generalized "render" message
#define ICM_DRAW_WINDOW             (ICM_USER+34)   // drawing window has moved or hidden
#define ICM_DRAW_SETTIME            (ICM_USER+35)   // set correct value for decompress clock
#define ICM_DRAW_REALIZE            (ICM_USER+36)   // realize palette for drawing
#define ICM_DRAW_FLUSH	            (ICM_USER+37)   // clear out buffered frames
#define ICM_DRAW_RENDERBUFFER       (ICM_USER+38)   // draw undrawn things in queue

#define ICM_DRAW_START_PLAY         (ICM_USER+39)   // start of a play
#define ICM_DRAW_STOP_PLAY          (ICM_USER+40)   // end of a play

#define ICM_DRAW_SUGGESTFORMAT      (ICM_USER+50)   // Like ICGetDisplayFormat
#define ICM_DRAW_CHANGEPALETTE      (ICM_USER+51)   // for animating palette

#define ICM_DRAW_IDLE               (ICM_USER+52)   // send each frame time ;Internal

#define ICM_GETBUFFERSWANTED        (ICM_USER+41)   // ask about prebuffering

#define ICM_GETDEFAULTKEYFRAMERATE  (ICM_USER+42)   // get the default value for key frames


#define ICM_DECOMPRESSEX_BEGIN      (ICM_USER+60)   // start a series of decompress calls
#define ICM_DECOMPRESSEX_QUERY      (ICM_USER+61)   // start a series of decompress calls
#define ICM_DECOMPRESSEX            (ICM_USER+62)   // decompress a frame
#define ICM_DECOMPRESSEX_END        (ICM_USER+63)   // end a series of decompress calls

#define ICM_COMPRESS_FRAMES_INFO    (ICM_USER+70)   // tell about compress to come
#define ICM_COMPRESS_FRAMES         (ICM_USER+71)   // compress a bunch of frames ;Internal
#define ICM_SET_STATUS_PROC	        (ICM_USER+72)   // set status callback

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwSize;         // sizeof(ICOPEN)
    DWORD               fccType;        // 'vidc'
    DWORD               fccHandler;     //
    DWORD               dwVersion;      // version of compman opening you
    DWORD               dwFlags;        // LOWORD is type specific
    LRESULT             dwError;        // error return.
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} ICOPEN;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD   dwSize;                 // sizeof(ICINFO)
    DWORD   fccType;                // compressor type     'vidc' 'audc'
    DWORD   fccHandler;             // compressor sub-type 'rle ' 'jpeg' 'pcm '
    DWORD   dwFlags;                // flags LOWORD is type specific
    DWORD   dwVersion;              // version of the driver
    DWORD   dwVersionICM;           // version of the ICM used
    //
    // under Win32, the driver always returns UNICODE strings.
    //
    WCHAR   szName[16];             // short name
    WCHAR   szDescription[128];     // long name
    WCHAR   szDriver[128];          // driver that contains compressor
}   ICINFO;

/* Flags for the <dwFlags> field of the <ICINFO> structure. */
#define VIDCF_QUALITY        0x0001  // supports quality
#define VIDCF_CRUNCH         0x0002  // supports crunching to a frame size
#define VIDCF_TEMPORAL       0x0004  // supports inter-frame compress
#define VIDCF_COMPRESSFRAMES 0x0008  // wants the compress all frames message
#define VIDCF_DRAW           0x0010  // supports drawing
#define VIDCF_FASTTEMPORALC  0x0020  // does not need prev frame on compress
#define VIDCF_FASTTEMPORALD  0x0080  // does not need prev frame on decompress
//#define VIDCF_QUALITYTIME    0x0040  // supports temporal quality

//#define VIDCF_FASTTEMPORAL   (VIDCF_FASTTEMPORALC|VIDCF_FASTTEMPORALD)

/************************************************************************
************************************************************************/

#define ICCOMPRESS_KEYFRAME	0x00000001L

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    __field_bcount(lpbiOutput->biSizeImage) LPVOID              lpOutput;       // output data

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    __field_bcount(lpbiInput->biSizeImage) LPVOID              lpInput;        // frame data to compress

    LPDWORD             lpckid;         // ckid for data in AVI file
    LPDWORD             lpdwFlags;      // flags in the AVI index.
    LONG                lFrameNum;      // frame number of seq.
    DWORD               dwFrameSize;    // reqested size in bytes. (if non zero)

    DWORD               dwQuality;      // quality

    // these are new fields
    LPBITMAPINFOHEADER  lpbiPrev;       // format of previous frame
    __field_bcount(lpbiPrev->biSizeImage) LPVOID              lpPrev;         // previous frame

} ICCOMPRESS;

/************************************************************************
************************************************************************/

#define ICCOMPRESSFRAMES_PADDING	0x00000001

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPARAM              lOutput;        // output identifier

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPARAM              lInput;         // input identifier

    LONG                lStartFrame;    // start frame
    LONG                lFrameCount;    // # of frames

    LONG                lQuality;       // quality
    LONG                lDataRate;      // data rate
    LONG                lKeyRate;       // key frame rate

    DWORD		dwRate;		// frame rate, as always
    DWORD		dwScale;

    DWORD		dwOverheadPerFrame;
    DWORD		dwReserved2;

    LONG (CALLBACK *GetData)(__in LPARAM lInput, __in LONG lFrame, __out_bcount(len) LPVOID lpBits, __in LONG len);
    LONG (CALLBACK *PutData)(__in LPARAM lOutput, __in LONG lFrame, __in_bcount(len) LPVOID lpBits, __in LONG len);
} ICCOMPRESSFRAMES;

typedef struct {
    DWORD		dwFlags;
    LPARAM		lParam;

    // messages for Status callback
    #define ICSTATUS_START	    0
    #define ICSTATUS_STATUS	    1	    // l == % done
    #define ICSTATUS_END	    2
    #define ICSTATUS_ERROR	    3	    // l == error string (LPSTR)
    #define ICSTATUS_YIELD	    4
    // return nonzero means abort operation in progress

    LONG (CALLBACK *Status) (__in LPARAM lParam, __in UINT message, __in LONG l);
} ICSETSTATUSPROC;

/************************************************************************
************************************************************************/

#define ICDECOMPRESS_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDECOMPRESS_UPDATE       0x40000000L   // don't draw just update screen
#define ICDECOMPRESS_PREROLL      0x20000000L   // this frame is before real start
#define ICDECOMPRESS_NULLFRAME    0x10000000L   // repeat last frame
#define ICDECOMPRESS_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)

    LPBITMAPINFOHEADER  lpbiInput;  // BITMAPINFO of compressed data
                                    // biSizeImage has the chunk size
    __field_bcount(lpbiInput->biSizeImage) 
    LPVOID              lpInput;    // compressed data

    LPBITMAPINFOHEADER  lpbiOutput; // DIB to decompress to
    __field_bcount(lpbiOutput->biSizeImage)
    LPVOID              lpOutput;
    DWORD		ckid;	    // ckid from AVI file
} ICDECOMPRESS;

typedef struct {
    //
    // same as ICM_DECOMPRESS
    //
    DWORD               dwFlags;

    LPBITMAPINFOHEADER  lpbiSrc;    // BITMAPINFO of compressed data
    LPVOID              lpSrc;      // compressed data

    LPBITMAPINFOHEADER  lpbiDst;    // DIB to decompress to
    LPVOID              lpDst;      // output data

    //
    // new for ICM_DECOMPRESSEX
    //
    int                 xDst;       // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    int                 xSrc;       // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

} ICDECOMPRESSEX;

/************************************************************************
************************************************************************/

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND
#define ICDRAW_ANIMATE	    0x00000008L	  // expect palette animation
#define ICDRAW_CONTINUE	    0x00000010L	  // draw is a continuation of previous draw
#define ICDRAW_MEMORYDC	    0x00000020L	  // DC is offscreen, by the way
#define ICDRAW_UPDATING	    0x00000040L	  // We're updating, as opposed to playing
#define ICDRAW_RENDER       0x00000080L   // used to render data not draw it
#define ICDRAW_BUFFER       0x00000100L   // please buffer this data offscreen, we will need to update it

typedef struct {
    DWORD               dwFlags;        // flags

    HPALETTE            hpal;           // palette to draw with
    HWND                hwnd;           // window to draw to
    HDC                 hdc;            // HDC to draw to

    int                 xDst;           // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    LPBITMAPINFOHEADER  lpbi;           // format of frame to draw

    int                 xSrc;           // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

    DWORD               dwRate;         // frames/second = (dwRate/dwScale)
    DWORD               dwScale;

} ICDRAWBEGIN;

/************************************************************************
************************************************************************/

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen
#define ICDRAW_PREROLL	    0x20000000L	  // this frame is before real start
#define ICDRAW_NULLFRAME    0x10000000L	  // repeat last frame
#define ICDRAW_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;        // flags
    LPVOID		lpFormat;       // format of frame to decompress
    LPVOID              lpData;         // frame data to decompress
    DWORD               cbData;
    LONG                lTime;          // time in drawbegin units (see dwRate and dwScale)
} ICDRAW;

typedef struct {
    LPBITMAPINFOHEADER	lpbiIn;		// format to be drawn
    LPBITMAPINFOHEADER	lpbiSuggest;	// location for suggested format (or NULL to get size)
    int			dxSrc;		// source extent or 0
    int			dySrc;
    int			dxDst;		// dest extent or 0
    int			dyDst;
    HIC			hicDecompressor;// decompressor you can talk to
} ICDRAWSUGGEST;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)
    int                 iStart;     // first palette to change
    int                 iLen;       // count of entries to change.
    LPPALETTEENTRY      lppe;       // palette
} ICPALETTE;


/************************************************************************

    ICM function declarations
	
************************************************************************/

BOOL
VFWAPI
ICInfo(
    __in DWORD fccType,
    __in DWORD fccHandler,
    __out ICINFO FAR * lpicinfo
    );

BOOL
VFWAPI
ICInstall(
    __in DWORD fccType,
    __in DWORD fccHandler,
    __in LPARAM lParam,
    __in LPSTR szDesc,
    __in UINT wFlags
    );

BOOL
VFWAPI
ICRemove(
    __in DWORD fccType,
    __in DWORD fccHandler,
    __in UINT wFlags
    );

__success(return != 0)
LRESULT
VFWAPI
ICGetInfo(
    __in HIC hic,
    __out_bcount_part(cb,return) ICINFO FAR *picinfo,
    __in DWORD cb
    );

HIC
VFWAPI
ICOpen(
    __in DWORD fccType,
    __in DWORD fccHandler,
    __in UINT wMode
    );

HIC
VFWAPI
ICOpenFunction(
    __in DWORD fccType,
    __in DWORD fccHandler,
    __in UINT wMode,
    __in FARPROC lpfnHandler
    );

LRESULT
VFWAPI
ICClose(
    __in HIC hic
    );

LRESULT
VFWAPI
ICSendMessage(
    __in HIC hic,
    __in UINT msg,
    __in DWORD_PTR dw1,
    __in DWORD_PTR dw2
    );
#ifndef _WIN32
//this function is unsupported on Win32 as it is non-portable.
LRESULT VFWAPIV ICMessage(HIC hic, UINT msg, UINT cb, ...);
#endif


/* Values for wFlags of ICInstall() */
#define ICINSTALL_UNICODE       0x8000

#define ICINSTALL_FUNCTION      0x0001  // lParam is a DriverProc (function ptr)
#define ICINSTALL_DRIVER        0x0002  // lParam is a driver name (string)
#define ICINSTALL_HDRV          0x0004  // lParam is a HDRVR (driver handle)

#define ICINSTALL_DRIVERW       0x8002  // lParam is a unicode driver name

/************************************************************************

    query macros

************************************************************************/
#define ICMF_CONFIGURE_QUERY     0x00000001
#define ICMF_ABOUT_QUERY         0x00000001

#define ICQueryAbout(hic) \
    (ICSendMessage(hic, ICM_ABOUT, (DWORD_PTR) -1, ICMF_ABOUT_QUERY) == ICERR_OK)

#define ICAbout(hic, hwnd) \
    ICSendMessage(hic, ICM_ABOUT, (DWORD_PTR)(UINT_PTR)(hwnd), 0)

#define ICQueryConfigure(hic) \
    (ICSendMessage(hic, ICM_CONFIGURE, (DWORD_PTR) -1, ICMF_CONFIGURE_QUERY) == ICERR_OK)

#define ICConfigure(hic, hwnd) \
    ICSendMessage(hic, ICM_CONFIGURE, (DWORD_PTR)(UINT_PTR)(hwnd), 0)

/************************************************************************

    get/set state macros
	
************************************************************************/

#define ICGetState(hic, pv, cb) \
    ICSendMessage(hic, ICM_GETSTATE, (DWORD_PTR)(LPVOID)(pv), (DWORD_PTR)(cb))

#define ICSetState(hic, pv, cb) \
    ICSendMessage(hic, ICM_SETSTATE, (DWORD_PTR)(LPVOID)(pv), (DWORD_PTR)(cb))

#define ICGetStateSize(hic) \
    (DWORD) ICGetState(hic, NULL, 0)

/************************************************************************

    get value macros

************************************************************************/
static DWORD dwICValue;

#define ICGetDefaultQuality(hic) \
    (ICSendMessage(hic, ICM_GETDEFAULTQUALITY, (DWORD_PTR)(LPVOID)&dwICValue, sizeof(DWORD)), dwICValue)

#define ICGetDefaultKeyFrameRate(hic) \
    (ICSendMessage(hic, ICM_GETDEFAULTKEYFRAMERATE, (DWORD_PTR)(LPVOID)&dwICValue, sizeof(DWORD)), dwICValue)

/************************************************************************

    draw window macro
	
************************************************************************/
#define ICDrawWindow(hic, prc) \
    ICSendMessage(hic, ICM_DRAW_WINDOW, (DWORD_PTR)(LPVOID)(prc), sizeof(RECT))

/************************************************************************

    compression functions

************************************************************************/
/*
 *  ICCompress()
 *
 *  compress a single frame
 *
 */
DWORD
VFWAPIV
ICCompress(
    __in       HIC                 hic,
    __in       DWORD               dwFlags,        // flags
    __in       LPBITMAPINFOHEADER  lpbiOutput,     // output format
    __out_bcount(lpbiOutput->biSizeImage)      LPVOID              lpData,         // output data
    __in       LPBITMAPINFOHEADER  lpbiInput,      // format of frame to compress
    __in_bcount(lpbiInput->biSizeImage)       LPVOID              lpBits,         // frame data to compress
    __out_opt  LPDWORD             lpckid,         // ckid for data in AVI file
    __out_opt  LPDWORD             lpdwFlags,      // flags in the AVI index.
    __in       LONG                lFrameNum,      // frame number of seq.
    __in       DWORD               dwFrameSize,    // reqested size in bytes. (if non zero)
    __in       DWORD               dwQuality,      // quality within one frame
    __in_opt   LPBITMAPINFOHEADER  lpbiPrev,       // format of previous frame
    __in_bcount_opt(lpbiPrev->biSizeImage)   LPVOID              lpPrev          // previous frame
    );

/*
 *  ICCompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICCompressBegin(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_BEGIN, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

/*
 *  ICCompressQuery()
 *
 *  determines if compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICCompressQuery(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_QUERY, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

/*
 *  ICCompressGetFormat()
 *
 *  get the output format, (format of compressed data)
 *  if lpbiOutput is NULL return the size in bytes needed for format.
 *
 */
#define ICCompressGetFormat(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_GET_FORMAT, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

#define ICCompressGetFormatSize(hic, lpbi) \
    (DWORD) ICCompressGetFormat(hic, lpbi, NULL)

/*
 *  ICCompressSize()
 *
 *  return the maximal size of a compressed frame
 *
 */
#define ICCompressGetSize(hic, lpbiInput, lpbiOutput) \
    (DWORD) ICSendMessage(hic, ICM_COMPRESS_GET_SIZE, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

#define ICCompressEnd(hic) \
    ICSendMessage(hic, ICM_COMPRESS_END, 0, 0)

/************************************************************************

    decompression functions

************************************************************************/

/*
 *  ICDecompress()
 *
 *  decompress a single frame
 *
 */
#define ICDECOMPRESS_HURRYUP    0x80000000L     // don't draw just buffer (hurry up!)

DWORD
VFWAPIV
ICDecompress(
    __in  HIC                 hic,
    __in  DWORD               dwFlags,    // flags (from AVI index...)
    __in  LPBITMAPINFOHEADER  lpbiFormat, // BITMAPINFO of compressed data
                                        // biSizeImage has the chunk size
    __in_bcount(lpbiFormat->biSizeImage)  LPVOID              lpData,     // data
    __in  LPBITMAPINFOHEADER  lpbi,       // DIB to decompress to
    __out_bcount(lpbi->biSizeImage) LPVOID  lpBits
    );

/*
 *  ICDecompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
#define ICDecompressBegin(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_BEGIN, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

/*
 *  ICDecompressQuery()
 *
 *  determines if compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
#define ICDecompressQuery(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_QUERY, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

/*
 *  ICDecompressGetFormat()
 *
 *  get the output format, (format of un-compressed data)
 *  if lpbiOutput is NULL return the size in bytes needed for format.
 *
 */
#define ICDecompressGetFormat(hic, lpbiInput, lpbiOutput) \
    ((LONG) ICSendMessage(hic, ICM_DECOMPRESS_GET_FORMAT, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput)))

#define ICDecompressGetFormatSize(hic, lpbi) \
    ICDecompressGetFormat(hic, lpbi, NULL)

/*
 *  ICDecompressGetPalette()
 *
 *  get the output palette
 *
 */
#define ICDecompressGetPalette(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_GET_PALETTE, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

#define ICDecompressSetPalette(hic, lpbiPalette) \
    ICSendMessage(hic, ICM_DECOMPRESS_SET_PALETTE, (DWORD_PTR)(LPVOID)(lpbiPalette), 0)

#define ICDecompressEnd(hic) \
    ICSendMessage(hic, ICM_DECOMPRESS_END, 0, 0)

/************************************************************************

    decompression (ex) functions

************************************************************************/


//
// on Win16 these functions are macros that call ICMessage. ICMessage will
// not work on NT. rather than add new entrypoints we have given
// them as static inline functions
//

/*
 *  ICDecompressEx()
 *
 *  decompress a single frame
 *
 */
static __inline LRESULT VFWAPI_INLINE
ICDecompressEx(
            __in HIC hic,
            __in DWORD dwFlags,
            __in LPBITMAPINFOHEADER lpbiSrc,
            __in_bcount(lpbiSrc->biSizeImage) LPVOID lpSrc,
            __in int xSrc,
            __in int ySrc,
            __in int dxSrc,
            __in int dySrc,
            __in LPBITMAPINFOHEADER lpbiDst,
            __out_bcount(lpbiDst->biSizeImage) LPVOID lpDst,
            __in int xDst,
            __in int yDst,
            __in int dxDst,
            __in int dyDst)
{
    ICDECOMPRESSEX ic;

    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DECOMPRESSEX, (DWORD_PTR)&ic, sizeof(ic));
}


/*
 *  ICDecompressExBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
static __inline LRESULT VFWAPI_INLINE
ICDecompressExBegin(
            __in      HIC hic,
            __in      DWORD dwFlags,
            __in      LPBITMAPINFOHEADER lpbiSrc,
            __in_opt  LPVOID lpSrc,
            __in      int xSrc,
            __in      int ySrc,
            __in      int dxSrc,
            __in      int dySrc,
            __in      LPBITMAPINFOHEADER lpbiDst,
            __out_opt LPVOID lpDst,
            __in      int xDst,
            __in      int yDst,
            __in      int dxDst,
            __in      int dyDst)
{
    ICDECOMPRESSEX ic;

    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DECOMPRESSEX_BEGIN, (DWORD_PTR)&ic, sizeof(ic));
}

/*
 *  ICDecompressExQuery()
 *
 */
static __inline LRESULT VFWAPI_INLINE
ICDecompressExQuery(
            __in       HIC hic,
            __in       DWORD dwFlags,
            __in       LPBITMAPINFOHEADER lpbiSrc,
            __reserved LPVOID lpSrc,
            __in       int xSrc,
            __in       int ySrc,
            __in       int dxSrc,
            __in       int dySrc,
            __in_opt   LPBITMAPINFOHEADER lpbiDst,
            __out_opt  LPVOID lpDst,
            __in       int xDst,
            __in       int yDst,
            __in       int dxDst,
            __in       int dyDst)
{
    ICDECOMPRESSEX ic;

    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DECOMPRESSEX_QUERY, (DWORD_PTR)&ic, sizeof(ic));
}


#define ICDecompressExEnd(hic) \
    ICSendMessage(hic, ICM_DECOMPRESSEX_END, 0, 0)

/************************************************************************

    drawing functions

************************************************************************/

/*
 *  ICDrawBegin()
 *
 *  start decompressing data with format (lpbiInput) directly to the screen
 *
 *  return zero if the decompressor supports drawing.
 *
 */

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND

DWORD
VFWAPIV
ICDrawBegin(
    __in     HIC                 hic,
    __in     DWORD               dwFlags,        // flags
    __in_opt HPALETTE            hpal,           // palette to draw with
    __in_opt HWND                hwnd,           // window to draw to
    __in_opt HDC                 hdc,            // HDC to draw to
    __in int                     xDst,           // destination rectangle
    __in int                     yDst,
    __in int                     dxDst,
    __in int                     dyDst,
    __in LPBITMAPINFOHEADER      lpbi,           // format of frame to draw
    __in int                     xSrc,           // source rectangle
    __in int                     ySrc,
    __in int                     dxSrc,
    __in int                     dySrc,
    __in DWORD                   dwRate,         // frames/second = (dwRate/dwScale)
    __in DWORD                   dwScale
    );

/*
 *  ICDraw()
 *
 *  decompress data directly to the screen
 *
 */

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen

DWORD
VFWAPIV
ICDraw(
    __in HIC                        hic,
    __in DWORD                      dwFlags,                  // flags
    __in LPVOID                     lpFormat,                 // format of frame to decompress
    __in_bcount_opt(cbData) LPVOID  lpData,                   // frame data to decompress
    __in DWORD                      cbData,                   // size of data
    __in LONG                       lTime                     // time to draw this frame
    );


// ICMessage is not supported on Win32, so provide a static inline function
// to do the same job
static __inline LRESULT VFWAPI_INLINE
ICDrawSuggestFormat(
            __in  HIC hic,
            __in  LPBITMAPINFOHEADER lpbiIn,
            __out LPBITMAPINFOHEADER lpbiOut,
            __in  int dxSrc,
            __in  int dySrc,
            __in  int dxDst,
            __in  int dyDst,
            __in  HIC hicDecomp)
{
    ICDRAWSUGGEST ic;

    ic.lpbiIn = lpbiIn;
    ic.lpbiSuggest = lpbiOut;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;
    ic.hicDecompressor = hicDecomp;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DRAW_SUGGESTFORMAT, (DWORD_PTR)&ic, sizeof(ic));
}


/*
 *  ICDrawQuery()
 *
 *  determines if the compressor is willing to render the specified format.
 *
 */
#define ICDrawQuery(hic, lpbiInput) \
    ICSendMessage(hic, ICM_DRAW_QUERY, (DWORD_PTR)(LPVOID)(lpbiInput), 0L)

#define ICDrawChangePalette(hic, lpbiInput) \
    ICSendMessage(hic, ICM_DRAW_CHANGEPALETTE, (DWORD_PTR)(LPVOID)(lpbiInput), 0L)

#define ICGetBuffersWanted(hic, lpdwBuffers) \
    ICSendMessage(hic, ICM_GETBUFFERSWANTED, (DWORD_PTR)(LPVOID)(lpdwBuffers), 0)

#define ICDrawEnd(hic) \
    ICSendMessage(hic, ICM_DRAW_END, 0, 0)

#define ICDrawStart(hic) \
    ICSendMessage(hic, ICM_DRAW_START, 0, 0)

#define ICDrawStartPlay(hic, lFrom, lTo) \
    ICSendMessage(hic, ICM_DRAW_START_PLAY, (DWORD_PTR)(lFrom), (DWORD_PTR)(lTo))

#define ICDrawStop(hic) \
    ICSendMessage(hic, ICM_DRAW_STOP, 0, 0)

#define ICDrawStopPlay(hic) \
    ICSendMessage(hic, ICM_DRAW_STOP_PLAY, 0, 0)

#define ICDrawGetTime(hic, lplTime) \
    ICSendMessage(hic, ICM_DRAW_GETTIME, (DWORD_PTR)(LPVOID)(lplTime), 0)

#define ICDrawSetTime(hic, lTime) \
    ICSendMessage(hic, ICM_DRAW_SETTIME, (DWORD_PTR)lTime, 0)

#define ICDrawRealize(hic, hdc, fBackground) \
    ICSendMessage(hic, ICM_DRAW_REALIZE, (DWORD_PTR)(UINT_PTR)(HDC)(hdc), (DWORD_PTR)(BOOL)(fBackground))

#define ICDrawFlush(hic) \
    ICSendMessage(hic, ICM_DRAW_FLUSH, 0, 0)

#define ICDrawRenderBuffer(hic) \
    ICSendMessage(hic, ICM_DRAW_RENDERBUFFER, 0, 0)

/************************************************************************

    Status callback functions

************************************************************************/

/*
 *  ICSetStatusProc()
 *
 *  Set the status callback function
 *
 */


// ICMessage is not supported on NT
static __inline LRESULT VFWAPI_INLINE
ICSetStatusProc(
            __in HIC hic,
            __in DWORD dwFlags,
            __in LRESULT lParam,
            __in LONG (CALLBACK *fpfnStatus)(__in LPARAM, __in UINT, __in LONG) )
{
    ICSETSTATUSPROC ic;

    ic.dwFlags = dwFlags;
    ic.lParam = lParam;
    ic.Status = fpfnStatus;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_SET_STATUS_PROC, (DWORD_PTR)&ic, sizeof(ic));
}


/************************************************************************

helper routines for DrawDib and MCIAVI...

************************************************************************/

#define ICDecompressOpen(fccType, fccHandler, lpbiIn, lpbiOut) \
    ICLocate(fccType, fccHandler, lpbiIn, lpbiOut, ICMODE_DECOMPRESS)

#define ICDrawOpen(fccType, fccHandler, lpbiIn) \
    ICLocate(fccType, fccHandler, lpbiIn, NULL, ICMODE_DRAW)

HIC
VFWAPI
ICLocate(
    __in     DWORD fccType,
    __in     DWORD fccHandler,
    __in     LPBITMAPINFOHEADER lpbiIn,
    __in_opt LPBITMAPINFOHEADER lpbiOut,
    __in     WORD wFlags
    );

HIC
VFWAPI
ICGetDisplayFormat(
    __in_opt  HIC hic,
    __in      LPBITMAPINFOHEADER lpbiIn,
    __out     LPBITMAPINFOHEADER lpbiOut,
    __in      int BitDepth,
    __in      int dx,
    __in      int dy
    );

/************************************************************************
Higher level functions
************************************************************************/

HANDLE
VFWAPI
ICImageCompress(
    __in         HIC                 hic,        // compressor to use
    __in         UINT                uiFlags,    // flags (none yet)
    __in         LPBITMAPINFO        lpbiIn,     // format to compress from
    __in         LPVOID              lpBits,     // data to compress
    __in_opt     LPBITMAPINFO        lpbiOut,    // compress to this (NULL ==> default)
    __in         LONG                lQuality,   // quality to use
    __inout_opt  LONG FAR *          plSize      // compress to this size (0=whatever)
    );

HANDLE
VFWAPI
ICImageDecompress(
    __in_opt HIC                 hic,        // compressor to use
    __in     UINT                uiFlags,    // flags (none yet)
    __in     LPBITMAPINFO        lpbiIn,     // format to decompress from
    __in     LPVOID              lpBits,     // data to decompress
    __in_opt LPBITMAPINFO        lpbiOut     // decompress to this (NULL ==> default)
    );

//
// Structure used by ICSeqCompressFrame and ICCompressorChoose routines
// Make sure this matches the autodoc in icm.c!
//
typedef struct {
    LONG		cbSize;		// set to sizeof(COMPVARS) before
					// calling ICCompressorChoose
    DWORD		dwFlags;	// see below...
    HIC			hic;		// HIC of chosen compressor
    DWORD               fccType;	// basically ICTYPE_VIDEO
    DWORD               fccHandler;	// handler of chosen compressor or
					// "" or "DIB "
    LPBITMAPINFO	lpbiIn;		// input format
    LPBITMAPINFO	lpbiOut;	// output format - will compress to this
    LPVOID		lpBitsOut;
    LPVOID		lpBitsPrev;
    LONG		lFrame;
    LONG		lKey;		// key frames how often?
    LONG		lDataRate;	// desired data rate KB/Sec
    LONG		lQ;		// desired quality
    LONG		lKeyCount;
    LPVOID		lpState;	// state of compressor
    LONG		cbState;	// size of the state
} COMPVARS, FAR *PCOMPVARS;

// FLAGS for dwFlags element of COMPVARS structure:
// set this flag if you initialize COMPVARS before calling ICCompressorChoose
#define ICMF_COMPVARS_VALID	0x00000001	// COMPVARS contains valid data

//
//  allows user to choose compressor, quality etc...
//
BOOL
VFWAPI
ICCompressorChoose(
    __in_opt  HWND        hwnd,               // parent window for dialog
    __in      UINT        uiFlags,            // flags
    __in_opt  LPVOID      pvIn,               // input format (optional)
    __in_opt  LPVOID      lpData,             // input data (optional)
    __inout   PCOMPVARS   pc,                 // data about the compressor/dlg
    __in_opt  LPSTR       lpszTitle           // dialog title (optional)
    );

// defines for uiFlags
#define ICMF_CHOOSE_KEYFRAME	0x0001	// show KeyFrame Every box
#define ICMF_CHOOSE_DATARATE	0x0002	// show DataRate box
#define ICMF_CHOOSE_PREVIEW	0x0004	// allow expanded preview dialog
#define ICMF_CHOOSE_ALLCOMPRESSORS	0x0008	// don't only show those that
						// can handle the input format
						// or input data

BOOL
VFWAPI
ICSeqCompressFrameStart(
    __in PCOMPVARS pc,
    __in LPBITMAPINFO lpbiIn
    );

void
VFWAPI
ICSeqCompressFrameEnd(
    __in PCOMPVARS pc
    );

LPVOID
VFWAPI
ICSeqCompressFrame(
    __in        PCOMPVARS               pc,         // set by ICCompressorChoose
    __reserved  UINT                    uiFlags,    // flags
    __in        LPVOID                  lpBits,     // input DIB bits
    __out       BOOL FAR               *pfKey,     // did it end up being a key frame?
    __inout_opt LONG FAR               *plSize     // size to compress to/of returned image
    );

void
VFWAPI
ICCompressorFree(
    __in PCOMPVARS pc
    );

#endif  /* NOCOMPMAN */

/**************************************************************************
 *
 *  DRAWDIB - Routines for drawing to the display.
 *
 *************************************************************************/

#ifndef NODRAWDIB

typedef HANDLE HDRAWDIB; /* hdd */

/*********************************************************************

  DrawDib Flags

**********************************************************************/
#define DDF_0001            0x0001          /* ;Internal */
#define DDF_UPDATE          0x0002          /* re-draw the last DIB */
#define DDF_SAME_HDC        0x0004          /* HDC same as last call (all setup) */
#define DDF_SAME_DRAW       0x0008          /* draw params are the same */
#define DDF_DONTDRAW        0x0010          /* dont draw frame, just decompress */
#define DDF_ANIMATE         0x0020          /* allow palette animation */
#define DDF_BUFFER          0x0040          /* always buffer image */
#define DDF_JUSTDRAWIT      0x0080          /* just draw it with GDI */
#define DDF_FULLSCREEN      0x0100          /* use DisplayDib */
#define DDF_BACKGROUNDPAL   0x0200	    /* Realize palette in background */
#define DDF_NOTKEYFRAME     0x0400          /* this is a partial frame update, hint */
#define DDF_HURRYUP         0x0800          /* hurry up please! */
#define DDF_HALFTONE        0x1000          /* always halftone */
#define DDF_2000            0x2000          /* ;Internal */

#define DDF_PREROLL         DDF_DONTDRAW    /* Builing up a non-keyframe */
#define DDF_SAME_DIB        DDF_SAME_DRAW
#define DDF_SAME_SIZE       DDF_SAME_DRAW

/*********************************************************************

    DrawDib functions
	
*********************************************************************/
/*							// ;Internal
**  DrawDibInit()					// ;Internal
**							// ;Internal
*/							// ;Internal
extern BOOL VFWAPI DrawDibInit(void);			// ;Internal
							// ;Internal
/*
**  DrawDibOpen()
**
*/
extern HDRAWDIB VFWAPI DrawDibOpen(void);

/*
**  DrawDibClose()
**
*/
extern
BOOL
VFWAPI
DrawDibClose(
    __in HDRAWDIB hdd
    );

/*
** DrawDibGetBuffer()
**
*/
extern
LPVOID
VFWAPI
DrawDibGetBuffer(
    __in HDRAWDIB hdd,
    __out LPBITMAPINFOHEADER lpbi,
    __in DWORD dwSize,
    __in DWORD dwFlags
    );

/*							// ;Internal
**  DrawDibError()					// ;Internal
*/							// ;Internal
extern UINT VFWAPI DrawDibError(HDRAWDIB hdd);		// ;Internal
							// ;Internal
/*
**  DrawDibGetPalette()
**
**  get the palette used for drawing DIBs
**
*/
extern
HPALETTE
VFWAPI
DrawDibGetPalette(
    __in HDRAWDIB hdd
    );


/*
**  DrawDibSetPalette()
**
**  get the palette used for drawing DIBs
**
*/
extern
BOOL
VFWAPI
DrawDibSetPalette(
    __in     HDRAWDIB hdd,
    __in_opt HPALETTE hpal
    );

/*
**  DrawDibChangePalette()
*/
extern
BOOL
VFWAPI
DrawDibChangePalette(
    __in HDRAWDIB hdd,
    __in int iStart,
    __in int iLen,
    __in_ecount(iLen) LPPALETTEENTRY lppe
    );

/*
**  DrawDibRealize()
**
**  realize the palette in a HDD
**
*/
extern
UINT
VFWAPI
DrawDibRealize(
    __in HDRAWDIB hdd,
    __in HDC hdc,
    __in BOOL fBackground
    );

/*
**  DrawDibStart()
**
**  start of streaming playback
**
*/
extern
BOOL
VFWAPI
DrawDibStart(
    __in HDRAWDIB hdd,
    __in DWORD rate
    );

/*
**  DrawDibStop()
**
**  start of streaming playback
**
*/
extern
BOOL
VFWAPI
DrawDibStop(
    __in HDRAWDIB hdd
    );

/*
**  DrawDibBegin()
**
**  prepare to draw
**
*/
extern
BOOL
VFWAPI
DrawDibBegin(
    __in     HDRAWDIB hdd,
    __in_opt HDC      hdc,
    __in     int      dxDst,
    __in     int      dyDst,
    __in     LPBITMAPINFOHEADER lpbi,
    __in     int      dxSrc,
    __in     int      dySrc,
    __in     UINT     wFlags
    );

/*
**  DrawDibDraw()
**
**  actualy draw a DIB to the screen.
**
*/
extern
BOOL
VFWAPI
DrawDibDraw(
    __in     HDRAWDIB hdd,
    __in     HDC      hdc,
    __in     int      xDst,
    __in     int      yDst,
    __in     int      dxDst,
    __in     int      dyDst,
    __in_opt LPBITMAPINFOHEADER lpbi,
    __in_opt LPVOID   lpBits,
    __in     int      xSrc,
    __in     int      ySrc,
    __in     int      dxSrc,
    __in     int      dySrc,
    __in     UINT     wFlags
    );

/*
**  DrawDibUpdate()
**
**  redraw the last image (may only be valid with DDF_BUFFER)
*/
#define DrawDibUpdate(hdd, hdc, x, y) \
        DrawDibDraw(hdd, hdc, x, y, 0, 0, NULL, NULL, 0, 0, 0, 0, DDF_UPDATE)

/*
**  DrawDibEnd()
*/
extern
BOOL
VFWAPI
DrawDibEnd(
    __in HDRAWDIB hdd
    );

/*
**  DrawDibTime()  [for debugging purposes only]
*/
typedef struct {
    LONG    timeCount;
    LONG    timeDraw;
    LONG    timeDecompress;
    LONG    timeDither;
    LONG    timeStretch;
    LONG    timeBlt;
    LONG    timeSetDIBits;
}   DRAWDIBTIME, FAR *LPDRAWDIBTIME;

BOOL
VFWAPI
DrawDibTime(
    __in  HDRAWDIB hdd,
    __out LPDRAWDIBTIME lpddtime
    );

/* display profiling */
#define PD_CAN_DRAW_DIB         0x0001      /* if you can draw at all */
#define PD_CAN_STRETCHDIB       0x0002      /* basicly RC_STRETCHDIB */
#define PD_STRETCHDIB_1_1_OK    0x0004      /* is it fast? */
#define PD_STRETCHDIB_1_2_OK    0x0008      /* ... */
#define PD_STRETCHDIB_1_N_OK    0x0010      /* ... */

LRESULT
VFWAPI
DrawDibProfileDisplay(
    __in LPBITMAPINFOHEADER lpbi
    );


#ifdef DRAWDIB_INCLUDE_STRETCHDIB
void WINAPI StretchDIB(
	__in  LPBITMAPINFOHEADER biDst,
	__out LPVOID	lpDst,		
	__in  int	DstX,		
	__in  int	DstY,		
	__in  int	DstXE,		
	__in  int	DstYE,		
	__in  LPBITMAPINFOHEADER biSrc,
	__in  LPVOID	lpSrc,		
	__in  int	SrcX,		
	__in  int	SrcY,		
	__in  int	SrcXE,		
	__in  int	SrcYE); 	
#endif

#endif  /* NODRAWDIB */

/****************************************************************************
 *
 *  AVIFMT - AVI file format definitions
 *
 ****************************************************************************/

#ifndef NOAVIFMT
    #ifndef _INC_MMSYSTEM
        typedef DWORD FOURCC;
    #endif
#ifdef _MSC_VER
#pragma warning(disable:4200)
#endif

/* The following is a short description of the AVI file format.  Please
 * see the accompanying documentation for a full explanation.
 *
 * An AVI file is the following RIFF form:
 *
 *	RIFF('AVI'
 *	      LIST('hdrl'
 *		    avih(<MainAVIHeader>)
 *                  LIST ('strl'
 *                      strh(<Stream header>)
 *                      strf(<Stream format>)
 *                      ... additional header data
 *            LIST('movi'	
 *      	  { LIST('rec'
 *      		      SubChunk...
 *      		   )
 *      	      | SubChunk } ....	
 *            )
 *            [ <AVIIndex> ]
 *      )
 *
 *	The main file header specifies how many streams are present.  For
 *	each one, there must be a stream header chunk and a stream format
 *	chunk, enlosed in a 'strl' LIST chunk.  The 'strf' chunk contains
 *	type-specific format information; for a video stream, this should
 *	be a BITMAPINFO structure, including palette.  For an audio stream,
 *	this should be a WAVEFORMAT (or PCMWAVEFORMAT) structure.
 *
 *	The actual data is contained in subchunks within the 'movi' LIST
 *	chunk.  The first two characters of each data chunk are the
 *	stream number with which that data is associated.
 *
 *	Some defined chunk types:
 *           Video Streams:
 *                  ##db:	RGB DIB bits
 *                  ##dc:	RLE8 compressed DIB bits
 *                  ##pc:	Palette Change
 *
 *           Audio Streams:
 *                  ##wb:	waveform audio bytes
 *
 * The grouping into LIST 'rec' chunks implies only that the contents of
 *   the chunk should be read into memory at the same time.  This
 *   grouping is used for files specifically intended to be played from
 *   CD-ROM.
 *
 * The index chunk at the end of the file should contain one entry for
 *   each data chunk in the file.
 *
 * Limitations for the current software:
 *	Only one video stream and one audio stream are allowed.
 *	The streams must start at the beginning of the file.
 *
 *
 * To register codec types please obtain a copy of the Multimedia
 * Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 */


#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

/* Macro to make a TWOCC out of two characters */
#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

typedef WORD TWOCC;

/* form types, list types, and chunk types */
#define formtypeAVI             mmioFOURCC('A', 'V', 'I', ' ')
#define listtypeAVIHEADER       mmioFOURCC('h', 'd', 'r', 'l')
#define ckidAVIMAINHDR          mmioFOURCC('a', 'v', 'i', 'h')
#define listtypeSTREAMHEADER    mmioFOURCC('s', 't', 'r', 'l')
#define ckidSTREAMHEADER        mmioFOURCC('s', 't', 'r', 'h')
#define ckidSTREAMFORMAT        mmioFOURCC('s', 't', 'r', 'f')
#define ckidSTREAMHANDLERDATA   mmioFOURCC('s', 't', 'r', 'd')
#define ckidSTREAMNAME		mmioFOURCC('s', 't', 'r', 'n')

#define listtypeAVIMOVIE        mmioFOURCC('m', 'o', 'v', 'i')
#define listtypeAVIRECORD       mmioFOURCC('r', 'e', 'c', ' ')

#define ckidAVINEWINDEX         mmioFOURCC('i', 'd', 'x', '1')

/*
** Stream types for the <fccType> field of the stream header.
*/
#define streamtypeVIDEO         mmioFOURCC('v', 'i', 'd', 's')
#define streamtypeAUDIO         mmioFOURCC('a', 'u', 'd', 's')
#define streamtypeMIDI		mmioFOURCC('m', 'i', 'd', 's')
#define streamtypeTEXT          mmioFOURCC('t', 'x', 't', 's')

/* Basic chunk types */
#define cktypeDIBbits           aviTWOCC('d', 'b')
#define cktypeDIBcompressed     aviTWOCC('d', 'c')
#define cktypePALchange         aviTWOCC('p', 'c')
#define cktypeWAVEbytes         aviTWOCC('w', 'b')

/* Chunk id to use for extra chunks for padding. */
#define ckidAVIPADDING          mmioFOURCC('J', 'U', 'N', 'K')


/*
** Useful macros
**
** Warning: These are nasty macro, and MS C 6.0 compiles some of them
** incorrectly if optimizations are on.  Ack.
*/

/* Macro to get stream number out of a FOURCC ckid */
#define FromHex(n)	(((n) >= 'A') ? ((n) + 10 - 'A') : ((n) - '0'))
#define StreamFromFOURCC(fcc) ((WORD) ((FromHex(LOBYTE(LOWORD(fcc))) << 4) + \
                                             (FromHex(HIBYTE(LOWORD(fcc))))))

/* Macro to get TWOCC chunk type out of a FOURCC ckid */
#define TWOCCFromFOURCC(fcc)    HIWORD(fcc)

/* Macro to make a ckid for a chunk out of a TWOCC and a stream number
** from 0-255.
*/
#define ToHex(n)	((BYTE) (((n) > 9) ? ((n) - 10 + 'A') : ((n) + '0')))
#define MAKEAVICKID(tcc, stream) \
        MAKELONG((ToHex((stream) & 0x0f) << 8) | \
			    (ToHex(((stream) & 0xf0) >> 4)), tcc)


/*
** Main AVI File Header
*/	
		
/* flags for use in <dwFlags> in AVIFileHdr */
#define AVIF_HASINDEX		0x00000010	// Index at end of file?
#define AVIF_MUSTUSEINDEX	0x00000020
#define AVIF_ISINTERLEAVED	0x00000100
#define AVIF_WASCAPTUREFILE	0x00010000
#define AVIF_COPYRIGHTED	0x00020000

/* The AVI File Header LIST chunk should be padded to this size */
#define AVI_HEADERSIZE  2048                    // size of AVI header list

typedef struct
{
    DWORD		dwMicroSecPerFrame;	// frame display rate (or 0L)
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwPaddingGranularity;	// pad to multiples of this
                                                // size; normally 2K.
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwTotalFrames;		// # frames in file
    DWORD		dwInitialFrames;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwReserved[4];
} MainAVIHeader;


/*
** Stream header
*/

#define AVISF_DISABLED			0x00000001

#define AVISF_VIDEO_PALCHANGES		0x00010000

typedef struct {
    FOURCC		fccType;
    FOURCC		fccHandler;
    DWORD		dwFlags;	/* Contains AVITF_* flags */
    WORD		wPriority;
    WORD		wLanguage;
    DWORD		dwInitialFrames;
    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwStart;
    DWORD		dwLength; /* In units above... */
    DWORD		dwSuggestedBufferSize;
    DWORD		dwQuality;
    DWORD		dwSampleSize;
    RECT		rcFrame;
} AVIStreamHeader;

/* Flags for index */
#define AVIIF_LIST          0x00000001L // chunk is a 'LIST'
#define AVIIF_KEYFRAME      0x00000010L // this frame is a key frame.
#define AVIIF_FIRSTPART     0x00000020L // this frame is the start of a partial frame.
#define AVIIF_LASTPART      0x00000040L // this frame is the end of a partial frame.
#define AVIIF_MIDPART       (AVIIF_LASTPART|AVIIF_FIRSTPART)

#define AVIIF_NOTIME	    0x00000100L // this frame doesn't take any time
#define AVIIF_COMPUSE       0x0FFF0000L // these bits are for compressor use

typedef struct
{
    DWORD		ckid;
    DWORD		dwFlags;
    DWORD		dwChunkOffset;		// Position of chunk
    DWORD		dwChunkLength;		// Length of chunk
} AVIINDEXENTRY;


/*
** Palette change chunk
**
** Used in video streams.
*/
typedef struct
{
    BYTE		bFirstEntry;	/* first entry to change */
    BYTE		bNumEntries;	/* # entries to change (0 if 256) */
    WORD		wFlags;		/* Mostly to preserve alignment... */
    PALETTEENTRY	peNew[];	/* New color specifications */
} AVIPALCHANGE;

#endif /* NOAVIFMT */

#ifdef __cplusplus
} // extern "C"
#endif  /* __cplusplus */

/****************************************************************************
 *
 *  MMREG.H (standard include file for MM defines, like FOURCC and things)
 *
 ***************************************************************************/

#ifndef RC_INVOKED
#include "pshpack8.h"
#endif
#ifndef NOMMREG
    #include <mmreg.h>
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****************************************************************************
 *
 *  AVIFile - routines for reading/writing standard AVI files
 *
 ***************************************************************************/

#ifndef NOAVIFILE

/*
 * Ansi - Unicode thunking.
 *
 * Unicode or Ansi-only apps can call the avifile APIs.
 * any Win32 app who wants to use
 * any of the AVI COM interfaces must be UNICODE - the AVISTREAMINFO and
 * AVIFILEINFO structures used in the Info methods of these interfaces are
 * the unicode variants, and no thunking to or from ansi takes place
 * except in the AVIFILE api entrypoints.
 *
 * For Ansi/Unicode thunking: for each entrypoint or structure that
 * uses chars or strings, two versions are declared in the Win32 version,
 * ApiNameW and ApiNameA. The default name ApiName is #defined to one or
 * other of these depending on whether UNICODE is defined (during
 * compilation of the app that is including this header). The source will
 * contain ApiName and ApiNameA (with ApiName being the Win16 implementation,
 * and also #defined to ApiNameW, and ApiNameA being the thunk entrypoint).
 *
 */

#ifndef mmioFOURCC
    #define mmioFOURCC( ch0, ch1, ch2, ch3 ) \
	( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
	( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifndef streamtypeVIDEO
#define streamtypeVIDEO		mmioFOURCC('v', 'i', 'd', 's')
#define streamtypeAUDIO		mmioFOURCC('a', 'u', 'd', 's')
#define streamtypeMIDI		mmioFOURCC('m', 'i', 'd', 's')
#define streamtypeTEXT		mmioFOURCC('t', 'x', 't', 's')
#endif

#ifndef AVIIF_KEYFRAME
#define AVIIF_KEYFRAME      0x00000010L // this frame is a key frame.
#endif

// For GetFrame::SetFormat - use the best format for the display
#define AVIGETFRAMEF_BESTDISPLAYFMT	1

//
// Structures used by AVIStreamInfo & AVIFileInfo.
//
// These are related to, but not identical to, the header chunks
// in an AVI file.
//

/*
 *
 * --- AVISTREAMINFO ------------------------------------------------
 *
 * for Unicode/Ansi thunking we need to declare three versions of this!
 */
typedef struct _AVISTREAMINFOW {
    DWORD		fccType;
    DWORD               fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    DWORD		dwCaps;
    WORD		wPriority;
    WORD		wLanguage;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */
    DWORD		dwInitialFrames;
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    RECT                rcFrame;
    DWORD		dwEditCount;
    DWORD		dwFormatChangeCount;
    WCHAR		szName[64];
} AVISTREAMINFOW, FAR * LPAVISTREAMINFOW;

typedef struct _AVISTREAMINFOA {
    DWORD		fccType;
    DWORD               fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    DWORD		dwCaps;
    WORD		wPriority;
    WORD		wLanguage;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */
    DWORD		dwInitialFrames;
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    RECT                rcFrame;
    DWORD		dwEditCount;
    DWORD		dwFormatChangeCount;
    char		szName[64];
} AVISTREAMINFOA, FAR * LPAVISTREAMINFOA;

#ifdef UNICODE
#define AVISTREAMINFO	AVISTREAMINFOW
#define LPAVISTREAMINFO	LPAVISTREAMINFOW
#else
#define AVISTREAMINFO	AVISTREAMINFOA
#define LPAVISTREAMINFO	LPAVISTREAMINFOA
#endif


#define AVISTREAMINFO_DISABLED			0x00000001
#define AVISTREAMINFO_FORMATCHANGES		0x00010000

/*
 * --- AVIFILEINFO ----------------------------------------------------
 *
 */


typedef struct _AVIFILEINFOW {
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwCaps;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwLength;

    DWORD		dwEditCount;

    WCHAR		szFileType[64];		// descriptive string for file type?
} AVIFILEINFOW, FAR * LPAVIFILEINFOW;

typedef struct _AVIFILEINFOA {
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwCaps;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwLength;

    DWORD		dwEditCount;

    char		szFileType[64];		// descriptive string for file type?
} AVIFILEINFOA, FAR * LPAVIFILEINFOA;

#ifdef UNICODE
#define AVIFILEINFO	AVIFILEINFOW
#define LPAVIFILEINFO	LPAVIFILEINFOW
#else
#define AVIFILEINFO	AVIFILEINFOA
#define LPAVIFILEINFO	LPAVIFILEINFOA
#endif


// Flags for dwFlags
#define AVIFILEINFO_HASINDEX		0x00000010
#define AVIFILEINFO_MUSTUSEINDEX	0x00000020
#define AVIFILEINFO_ISINTERLEAVED	0x00000100
#define AVIFILEINFO_WASCAPTUREFILE	0x00010000
#define AVIFILEINFO_COPYRIGHTED		0x00020000

// Flags for dwCaps
#define AVIFILECAPS_CANREAD		0x00000001
#define AVIFILECAPS_CANWRITE		0x00000002
#define AVIFILECAPS_ALLKEYFRAMES	0x00000010
#define AVIFILECAPS_NOCOMPRESSION	0x00000020

typedef BOOL (FAR PASCAL * AVISAVECALLBACK)(int);

/************************************************************************/
/* Declaration for the AVICOMPRESSOPTIONS structure.  Make sure it 	*/
/* matches the AutoDoc in avisave.c !!!                            	*/
/************************************************************************/

typedef struct {
    DWORD	fccType;		    /* stream type, for consistency */
    DWORD       fccHandler;                 /* compressor */
    DWORD       dwKeyFrameEvery;            /* keyframe rate */
    DWORD       dwQuality;                  /* compress quality 0-10,000 */
    DWORD       dwBytesPerSecond;           /* bytes per second */
    DWORD       dwFlags;                    /* flags... see below */
    LPVOID      lpFormat;                   /* save format */
    DWORD       cbFormat;
    LPVOID      lpParms;                    /* compressor options */
    DWORD       cbParms;
    DWORD       dwInterleaveEvery;          /* for non-video streams only */
} AVICOMPRESSOPTIONS, FAR *LPAVICOMPRESSOPTIONS;

//
// Defines for the dwFlags field of the AVICOMPRESSOPTIONS struct
// Each of these flags determines if the appropriate field in the structure
// (dwInterleaveEvery, dwBytesPerSecond, and dwKeyFrameEvery) is payed
// attention to.  See the autodoc in avisave.c for details.
//
#define AVICOMPRESSF_INTERLEAVE		0x00000001    // interleave
#define AVICOMPRESSF_DATARATE		0x00000002    // use a data rate
#define AVICOMPRESSF_KEYFRAMES		0x00000004    // use keyframes
#define AVICOMPRESSF_VALID		0x00000008    // has valid data?

#ifdef __cplusplus
} // extern "C"
#endif  /* __cplusplus */

#include <ole2.h>

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*	-	-	-	-	-	-	-	-	*/


/****** AVI Stream Interface *******************************************/

#undef  INTERFACE
#define INTERFACE   IAVIStream

DECLARE_INTERFACE_(IAVIStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __deref_out LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIStream methods ***
    STDMETHOD(Create)      (THIS_ LPARAM lParam1, LPARAM lParam2) PURE ;
    STDMETHOD(Info)        (THIS_ __out_bcount(lSize) AVISTREAMINFOW FAR * psi, __in LONG lSize) PURE ;
    STDMETHOD_(LONG, FindSample)(THIS_ __in LONG lPos, __in LONG lFlags) PURE ;
    STDMETHOD(ReadFormat)  (THIS_ __in LONG lPos,
			    __out_bcount_part_opt(*lpcbFormat, *lpcbFormat) LPVOID lpFormat, __inout LONG FAR *lpcbFormat) PURE ;
    STDMETHOD(SetFormat)   (THIS_ __in LONG lPos,
			    __in_bcount(cbFormat) LPVOID lpFormat, __in LONG cbFormat) PURE ;
    STDMETHOD(Read)        (THIS_ __in LONG lStart, __in LONG lSamples,
			    __out_bcount_opt(cbBuffer) LPVOID lpBuffer, __in LONG cbBuffer,
			    __out_opt LONG FAR * plBytes, __out_opt LONG FAR * plSamples) PURE ;
    STDMETHOD(Write)       (THIS_ __in LONG lStart, __in LONG lSamples,
			    __in_bcount(cbBuffer) LPVOID lpBuffer, __in LONG cbBuffer,
			    __in DWORD dwFlags,
			    __out_opt LONG FAR *plSampWritten,
			    __out_opt LONG FAR *plBytesWritten) PURE ;
    STDMETHOD(Delete)      (THIS_ __in LONG lStart, __in LONG lSamples) PURE;
    STDMETHOD(ReadData)    (THIS_ __in DWORD fcc, __out_bcount_part_opt(*lpcb, *lpcb) LPVOID lp, __inout LONG FAR *lpcb) PURE ;
    STDMETHOD(WriteData)   (THIS_ __in DWORD fcc, __in_bcount(cb) LPVOID lp, __in LONG cb) PURE ;
#ifdef _WIN32
    STDMETHOD(SetInfo) (THIS_ __in_bcount(cbInfo) AVISTREAMINFOW FAR * lpInfo,
			    __in LONG cbInfo) PURE;
#else
    STDMETHOD(Reserved1)            (THIS) PURE;
    STDMETHOD(Reserved2)            (THIS) PURE;
    STDMETHOD(Reserved3)            (THIS) PURE;
    STDMETHOD(Reserved4)            (THIS) PURE;
    STDMETHOD(Reserved5)            (THIS) PURE;
#endif
};

typedef       IAVIStream FAR* PAVISTREAM;


#undef  INTERFACE
#define INTERFACE   IAVIStreaming

DECLARE_INTERFACE_(IAVIStreaming, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __deref_out LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIStreaming methods ***
    STDMETHOD(Begin) (THIS_
		      __in LONG  lStart,	    // start of what we expect
						    // to play
		      __in LONG  lEnd,		    // expected end, or -1
		      __in LONG  lRate) PURE;	    // Should this be a float?
    STDMETHOD(End)   (THIS) PURE;
};

typedef       IAVIStreaming FAR* PAVISTREAMING;


#undef  INTERFACE
#define INTERFACE   IAVIEditStream

DECLARE_INTERFACE_(IAVIEditStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __deref_out LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIEditStream methods ***
    STDMETHOD(Cut) (THIS_ __inout LONG FAR *plStart,
			  __inout LONG FAR *plLength,
			  __deref_out PAVISTREAM FAR * ppResult) PURE;
    STDMETHOD(Copy) (THIS_ __inout LONG FAR *plStart,
			   __inout LONG FAR *plLength,
			   __deref_out PAVISTREAM FAR * ppResult) PURE;
    STDMETHOD(Paste) (THIS_ __inout LONG FAR *plPos,
			    __inout LONG FAR *plLength,
			    __inout PAVISTREAM pstream,
			    __in LONG lStart,
			    __in LONG lEnd) PURE;
    STDMETHOD(Clone) (THIS_ __deref_out PAVISTREAM FAR *ppResult) PURE;
    STDMETHOD(SetInfo) (THIS_ __in_bcount(cbInfo) AVISTREAMINFOW FAR * lpInfo,
			    __in LONG cbInfo) PURE;
};

typedef       IAVIEditStream FAR* PAVIEDITSTREAM;


/****** AVI File Interface *******************************************/

#undef  INTERFACE
#define INTERFACE   IAVIPersistFile

DECLARE_INTERFACE_(IAVIPersistFile, IPersistFile)
{
    STDMETHOD(Reserved1)(THIS) PURE;
};

typedef IAVIPersistFile FAR* PAVIPERSISTFILE;

#undef  INTERFACE
#define INTERFACE   IAVIFile
#define PAVIFILE IAVIFile FAR*

DECLARE_INTERFACE_(IAVIFile, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __deref_out LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIFile methods ***
    STDMETHOD(Info)                 (THIS_
                                     __out_bcount(lSize) AVIFILEINFOW FAR * pfi,
                                     __in LONG lSize) PURE;
    STDMETHOD(GetStream)            (THIS_
                                     __deref_out PAVISTREAM FAR * ppStream,
				     __in DWORD fccType,
                                     __in LONG lParam) PURE;
    STDMETHOD(CreateStream)         (THIS_
                                     __deref_out PAVISTREAM FAR * ppStream,
                                     __in AVISTREAMINFOW FAR * psi) PURE;
    STDMETHOD(WriteData)            (THIS_
                                     __in DWORD ckid,
                                     __in_bcount(cbData) LPVOID lpData,
                                     __in LONG cbData) PURE;
    STDMETHOD(ReadData)             (THIS_
                                     __in DWORD ckid,
                                     __out_bcount_part(*lpcbData, *lpcbData) LPVOID lpData,
                                     __inout LONG FAR *lpcbData) PURE;
    STDMETHOD(EndRecord)            (THIS) PURE;
    STDMETHOD(DeleteStream)         (THIS_
				     __in DWORD fccType,
                                     __in LONG lParam) PURE;
};

#undef PAVIFILE
typedef       IAVIFile FAR* PAVIFILE;

/****** GetFrame Interface *******************************************/

#undef  INTERFACE
#define INTERFACE   IGetFrame
#define PGETFRAME   IGetFrame FAR*

DECLARE_INTERFACE_(IGetFrame, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __deref_out LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IGetFrame methods ***

    STDMETHOD_(LPVOID,GetFrame) (THIS_ __in LONG lPos) PURE;
//  STDMETHOD_(LPVOID,GetFrameData) (THIS_ __in LONG lPos) PURE;

    STDMETHOD(Begin) (THIS_ __in LONG lStart, __in LONG lEnd, __in LONG lRate) PURE;
    STDMETHOD(End) (THIS) PURE;

    STDMETHOD(SetFormat) (THIS_ __in LPBITMAPINFOHEADER lpbi, __in_opt LPVOID lpBits, __in int x, __in int y, __in int dx, __in int dy) PURE;

//  STDMETHOD(DrawFrameStart) (THIS) PURE;
//  STDMETHOD(DrawFrame) (THIS_ __in LONG lPos, HDC hdc, __in int x, __in int y, __in int dx, __in int dy) PURE;
//  STDMETHOD(DrawFrameEnd) (THIS) PURE;
};

#undef PGETFRAME
typedef IGetFrame FAR* PGETFRAME;

/****** GUIDs *******************************************/

#define DEFINE_AVIGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_AVIGUID(IID_IAVIFile,            0x00020020, 0, 0);
DEFINE_AVIGUID(IID_IAVIStream,          0x00020021, 0, 0);
DEFINE_AVIGUID(IID_IAVIStreaming,       0x00020022, 0, 0);
DEFINE_AVIGUID(IID_IGetFrame,           0x00020023, 0, 0);
DEFINE_AVIGUID(IID_IAVIEditStream,      0x00020024, 0, 0);
DEFINE_AVIGUID(IID_IAVIPersistFile,     0x00020025, 0, 0);
#ifndef UNICODE
DEFINE_AVIGUID(CLSID_AVISimpleUnMarshal,        0x00020009, 0, 0);
#endif

DEFINE_AVIGUID(CLSID_AVIFile,           0x00020000, 0, 0);

#define	AVIFILEHANDLER_CANREAD		0x0001
#define	AVIFILEHANDLER_CANWRITE		0x0002
#define	AVIFILEHANDLER_CANACCEPTNONRGB	0x0004

//
// functions
//

STDAPI_(void) AVIFileInit(void);   // Call this first!
STDAPI_(void) AVIFileExit(void);

STDAPI_(ULONG) AVIFileAddRef       (PAVIFILE pfile);
STDAPI_(ULONG) AVIFileRelease      (PAVIFILE pfile);

#ifdef _WIN32
STDAPI AVIFileOpenA       (__deref_out PAVIFILE FAR * ppfile, __in LPCSTR szFile,
			  UINT uMode, __in_opt LPCLSID lpHandler);
STDAPI AVIFileOpenW       (__deref_out PAVIFILE FAR * ppfile, __in LPCWSTR szFile,
			  UINT uMode, __in_opt LPCLSID lpHandler);
#ifdef UNICODE
#define AVIFileOpen	  AVIFileOpenW	
#else
#define AVIFileOpen	  AVIFileOpenA	
#endif
#else // win16
STDAPI AVIFileOpen       (PAVIFILE FAR * ppfile, LPCSTR szFile,
			  UINT uMode, LPCLSID lpHandler);
#define AVIFileOpenW	AVIFileOpen	    /* ;Internal */
#endif

#ifdef _WIN32
STDAPI AVIFileInfoW (__in PAVIFILE pfile, __out_bcount(lSize) LPAVIFILEINFOW pfi, __in LONG lSize);
STDAPI AVIFileInfoA (__in PAVIFILE pfile, __out_bcount(lSize) LPAVIFILEINFOA pfi, __in LONG lSize);
#ifdef UNICODE
#define AVIFileInfo	AVIFileInfoW
#else
#define AVIFileInfo	AVIFileInfoA
#endif
#else //win16 version
STDAPI AVIFileInfo (PAVIFILE pfile, LPAVIFILEINFO pfi, LONG lSize);
#define AVIFileInfoW AVIFileInfo	    /* ;Internal */
#endif


STDAPI AVIFileGetStream     (__in PAVIFILE pfile, __deref_out PAVISTREAM FAR * ppavi, __in DWORD fccType, __in LONG lParam);


#ifdef _WIN32
STDAPI AVIFileCreateStreamW (__in PAVIFILE pfile, __deref_out PAVISTREAM FAR *ppavi, __in AVISTREAMINFOW FAR * psi);
STDAPI AVIFileCreateStreamA (__in PAVIFILE pfile, __deref_out PAVISTREAM FAR *ppavi, __in AVISTREAMINFOA FAR * psi);
#ifdef UNICODE
#define AVIFileCreateStream	AVIFileCreateStreamW
#else
#define AVIFileCreateStream	AVIFileCreateStreamA
#endif
#else //win16 version
STDAPI AVIFileCreateStream(PAVIFILE pfile, PAVISTREAM FAR *ppavi, AVISTREAMINFO FAR * psi);
#define AVIFileCreateStreamW AVIFileCreateStream	    /* ;Internal */
#endif

STDAPI AVIFileWriteData	(__in PAVIFILE pfile,
					 __in DWORD ckid,
					 __in_bcount(cbData) LPVOID lpData,
					 __in LONG cbData);
STDAPI AVIFileReadData	(__in PAVIFILE pfile,
					 __in DWORD ckid,
					 __out_bcount_part(*lpcbData, *lpcbData) LPVOID lpData,
					 __inout LONG FAR *lpcbData);
STDAPI AVIFileEndRecord	(__in PAVIFILE pfile);

STDAPI_(ULONG) AVIStreamAddRef       (PAVISTREAM pavi);
STDAPI_(ULONG) AVIStreamRelease      (PAVISTREAM pavi);

STDAPI AVIStreamInfoW (__in PAVISTREAM pavi, __out_bcount(lSize) LPAVISTREAMINFOW psi, __in LONG lSize);
STDAPI AVIStreamInfoA (__in PAVISTREAM pavi, __out_bcount(lSize) LPAVISTREAMINFOA psi, __in LONG lSize);
#ifdef UNICODE
#define AVIStreamInfo	AVIStreamInfoW
#else
#define AVIStreamInfo	AVIStreamInfoA
#endif

STDAPI_(LONG) AVIStreamFindSample(__in PAVISTREAM pavi, __in LONG lPos, __in LONG lFlags);
STDAPI AVIStreamReadFormat   (__in PAVISTREAM pavi, __in LONG lPos,__out_bcount_part_opt(*lpcbFormat,*lpcbFormat) LPVOID lpFormat,__inout LONG FAR *lpcbFormat);
STDAPI AVIStreamSetFormat    (__in PAVISTREAM pavi, __in LONG lPos,__in_bcount(cbFormat) LPVOID lpFormat, __in LONG cbFormat);
STDAPI AVIStreamReadData     (__in PAVISTREAM pavi, __in DWORD fcc, __out_bcount_part_opt(*lpcb, *lpcb) LPVOID lp, __inout LONG FAR *lpcb);
STDAPI AVIStreamWriteData    (__in PAVISTREAM pavi, __in DWORD fcc, __in_bcount(cb) LPVOID lp, __in LONG cb);

STDAPI AVIStreamRead         (__in PAVISTREAM pavi,
			      __in LONG lStart,
			      __in LONG lSamples,
			      __out_bcount_opt(cbBuffer) LPVOID lpBuffer,
			      __in LONG cbBuffer,
			      __out_opt LONG FAR * plBytes,
			      __out_opt LONG FAR * plSamples);
#define AVISTREAMREAD_CONVENIENT	(-1L)

STDAPI AVIStreamWrite        (__in PAVISTREAM pavi,
			      __in LONG lStart, __in LONG lSamples,
			      __in_bcount(cbBuffer) LPVOID lpBuffer, __in LONG cbBuffer, __in DWORD dwFlags,
			      __out_opt LONG FAR *plSampWritten,
			      __out_opt LONG FAR *plBytesWritten);

// Right now, these just use AVIStreamInfo() to get information, then
// return some of it.  Can they be more efficient?
STDAPI_(LONG) AVIStreamStart        (__in PAVISTREAM pavi);
STDAPI_(LONG) AVIStreamLength       (__in PAVISTREAM pavi);
STDAPI_(LONG) AVIStreamTimeToSample (__in PAVISTREAM pavi, __in LONG lTime);
STDAPI_(LONG) AVIStreamSampleToTime (__in PAVISTREAM pavi, __in LONG lSample);


STDAPI AVIStreamBeginStreaming(__in PAVISTREAM pavi, __in LONG lStart, __in LONG lEnd, __in LONG lRate);
STDAPI AVIStreamEndStreaming(__in PAVISTREAM pavi);

//
// helper functions for using IGetFrame
//
STDAPI_(PGETFRAME) AVIStreamGetFrameOpen(__in PAVISTREAM pavi,
					 __in_opt LPBITMAPINFOHEADER lpbiWanted);
STDAPI_(LPVOID) AVIStreamGetFrame(__in PGETFRAME pg, __in LONG lPos);
STDAPI AVIStreamGetFrameClose(__in PGETFRAME pg);


// !!! We need some way to place an advise on a stream....
// STDAPI AVIStreamHasChanged   (PAVISTREAM pavi);



// Shortcut function
STDAPI AVIStreamOpenFromFileA(__deref_out PAVISTREAM FAR *ppavi, __in LPCSTR szFile,
			     __in DWORD fccType, __in LONG lParam,
			     __in UINT mode, __in_opt CLSID FAR *pclsidHandler);
STDAPI AVIStreamOpenFromFileW(__deref_out PAVISTREAM FAR *ppavi, LPCWSTR szFile,
			     __in DWORD fccType, __in LONG lParam,
			     __in UINT mode, __in_opt CLSID FAR *pclsidHandler);
#ifdef UNICODE
#define AVIStreamOpenFromFile	AVIStreamOpenFromFileW
#else
#define AVIStreamOpenFromFile	AVIStreamOpenFromFileA
#endif

// Use to create disembodied streams
STDAPI AVIStreamCreate(__deref_out PAVISTREAM FAR *ppavi, __in LONG lParam1, __in LONG lParam2,
		       __in_opt CLSID FAR *pclsidHandler);



// PHANDLER    AVIAPI AVIGetHandler         (PAVISTREAM pavi, PAVISTREAMHANDLER psh);
// PAVISTREAM  AVIAPI AVIGetStream          (PHANDLER p);

//
// flags for AVIStreamFindSample
//
#define FIND_DIR        0x0000000FL     // direction
#define FIND_NEXT       0x00000001L     // go forward
#define FIND_PREV       0x00000004L     // go backward
#define FIND_FROM_START 0x00000008L     // start at the logical beginning

#define FIND_TYPE       0x000000F0L     // type mask
#define FIND_KEY        0x00000010L     // find key frame.
#define FIND_ANY        0x00000020L     // find any (non-empty) sample
#define FIND_FORMAT     0x00000040L     // find format change

#define FIND_RET        0x0000F000L     // return mask
#define FIND_POS        0x00000000L     // return logical position
#define FIND_LENGTH     0x00001000L     // return logical size
#define FIND_OFFSET     0x00002000L     // return physical position
#define FIND_SIZE       0x00003000L     // return physical size
#define FIND_INDEX      0x00004000L     // return physical index position


//
//  stuff to support backward compat.
//
#define AVIStreamFindKeyFrame AVIStreamFindSample
#define FindKeyFrame	FindSample

#define AVIStreamClose AVIStreamRelease
#define AVIFileClose   AVIFileRelease
#define AVIStreamInit  AVIFileInit
#define AVIStreamExit  AVIFileExit

#define SEARCH_NEAREST  FIND_PREV
#define SEARCH_BACKWARD FIND_PREV
#define SEARCH_FORWARD  FIND_NEXT
#define SEARCH_KEY      FIND_KEY
#define SEARCH_ANY      FIND_ANY

//
//  helper macros.
//
#define     AVIStreamSampleToSample(pavi1, pavi2, l) \
            AVIStreamTimeToSample(pavi1,AVIStreamSampleToTime(pavi2, l))

#define     AVIStreamNextSample(pavi, l) \
            AVIStreamFindSample(pavi,l+1,FIND_NEXT|FIND_ANY)

#define     AVIStreamPrevSample(pavi, l) \
            AVIStreamFindSample(pavi,l-1,FIND_PREV|FIND_ANY)

#define     AVIStreamNearestSample(pavi, l) \
            AVIStreamFindSample(pavi,l,FIND_PREV|FIND_ANY)

#define     AVIStreamNextKeyFrame(pavi,l) \
            AVIStreamFindSample(pavi,l+1,FIND_NEXT|FIND_KEY)

#define     AVIStreamPrevKeyFrame(pavi, l) \
            AVIStreamFindSample(pavi,l-1,FIND_PREV|FIND_KEY)

#define     AVIStreamNearestKeyFrame(pavi, l) \
            AVIStreamFindSample(pavi,l,FIND_PREV|FIND_KEY)

#define     AVIStreamIsKeyFrame(pavi, l) \
            (AVIStreamNearestKeyFrame(pavi,l) == l)

#define     AVIStreamPrevSampleTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamPrevSample(pavi,AVIStreamTimeToSample(pavi,t)))

#define     AVIStreamNextSampleTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNextSample(pavi,AVIStreamTimeToSample(pavi,t)))

#define     AVIStreamNearestSampleTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNearestSample(pavi,AVIStreamTimeToSample(pavi,t)))

#define     AVIStreamNextKeyFrameTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNextKeyFrame(pavi,AVIStreamTimeToSample(pavi, t)))

#define     AVIStreamPrevKeyFrameTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamPrevKeyFrame(pavi,AVIStreamTimeToSample(pavi, t)))

#define     AVIStreamNearestKeyFrameTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNearestKeyFrame(pavi,AVIStreamTimeToSample(pavi, t)))

#define     AVIStreamStartTime(pavi) \
            AVIStreamSampleToTime(pavi, AVIStreamStart(pavi))

#define     AVIStreamLengthTime(pavi) \
            AVIStreamSampleToTime(pavi, AVIStreamLength(pavi))

#define     AVIStreamEnd(pavi) \
            (AVIStreamStart(pavi) + AVIStreamLength(pavi))

#define     AVIStreamEndTime(pavi) \
            AVIStreamSampleToTime(pavi, AVIStreamEnd(pavi))

#define     AVIStreamSampleSize(pavi, lPos, plSize) \
	    AVIStreamRead(pavi,lPos,1,NULL,0,plSize,NULL)

#define     AVIStreamFormatSize(pavi, lPos, plSize) \
            AVIStreamReadFormat(pavi,lPos,NULL,plSize)

#define     AVIStreamDataSize(pavi, fcc, plSize) \
            AVIStreamReadData(pavi,fcc,NULL,plSize)

/****************************************************************************
 *
 *  AVISave routines and structures
 *
 ***************************************************************************/

#ifndef comptypeDIB
#define comptypeDIB         mmioFOURCC('D', 'I', 'B', ' ')
#endif

STDAPI AVIMakeCompressedStream(
		__deref_out PAVISTREAM FAR *	    ppsCompressed,
		__in PAVISTREAM		    ppsSource,
		__in AVICOMPRESSOPTIONS FAR *    lpOptions,
		__in_opt CLSID FAR *pclsidHandler);

EXTERN_C HRESULT CDECL AVISaveA (LPCSTR               szFile,
		__in_opt CLSID FAR *pclsidHandler,
		__in AVISAVECALLBACK     lpfnCallback,
		__in int                 nStreams,
		__in PAVISTREAM	    pfile,
		__in LPAVICOMPRESSOPTIONS lpOptions,
		...);

STDAPI AVISaveVA(LPCSTR               szFile,
		__in_opt CLSID FAR *pclsidHandler,
		__in AVISAVECALLBACK     lpfnCallback,
		__in int                 nStreams,
		__in_ecount(nStreams) PAVISTREAM FAR *    ppavi,
		__in_ecount(nStreams) LPAVICOMPRESSOPTIONS FAR *plpOptions);
EXTERN_C HRESULT CDECL AVISaveW (LPCWSTR               szFile,
		__in_opt CLSID FAR *pclsidHandler,
		__in AVISAVECALLBACK     lpfnCallback,
		__in int                 nStreams,
		__in PAVISTREAM	    pfile,
		__in LPAVICOMPRESSOPTIONS lpOptions,
		...);

STDAPI AVISaveVW(LPCWSTR               szFile,
		__in_opt CLSID FAR *pclsidHandler,
		__in AVISAVECALLBACK     lpfnCallback,
		__in int                 nStreams,
		__in_ecount(nStreams) PAVISTREAM FAR *    ppavi,
		__in_ecount(nStreams) LPAVICOMPRESSOPTIONS FAR *plpOptions);
#ifdef UNICODE
#define AVISave		AVISaveW
#define AVISaveV	AVISaveVW
#else
#define AVISave		AVISaveA
#define AVISaveV	AVISaveVA
#endif



STDAPI_(INT_PTR) AVISaveOptions(__in HWND hwnd,
			     __in UINT	uiFlags,
			     __in int	nStreams,
			     __in_ecount(nStreams) PAVISTREAM FAR *ppavi,
			     __inout_ecount(nStreams) LPAVICOMPRESSOPTIONS FAR *plpOptions);

STDAPI AVISaveOptionsFree(int nStreams,
			     __in_ecount(nStreams) LPAVICOMPRESSOPTIONS FAR *plpOptions);

// FLAGS FOR uiFlags:
//
// Same as the flags for ICCompressorChoose (see compman.h)
// These determine what the compression options dialog for video streams
// will look like.

STDAPI AVIBuildFilterW(__out_ecount(cbFilter) LPWSTR lpszFilter, __in LONG cbFilter, __in BOOL fSaving);
STDAPI AVIBuildFilterA(__out_ecount(cbFilter) LPSTR lpszFilter, __in LONG cbFilter, __in BOOL fSaving);
#ifdef UNICODE
#define AVIBuildFilter	AVIBuildFilterW
#else
#define AVIBuildFilter	AVIBuildFilterA
#endif
STDAPI AVIMakeFileFromStreams(__deref_out PAVIFILE FAR *	ppfile,
			       __in int		nStreams,
			       __in_ecount(nStreams) PAVISTREAM FAR *	papStreams);

STDAPI AVIMakeStreamFromClipboard(UINT cfFormat, __in HANDLE hGlobal, __deref_out PAVISTREAM FAR *ppstream);

/****************************************************************************
 *
 *  Clipboard routines
 *
 ***************************************************************************/

STDAPI AVIPutFileOnClipboard(__in PAVIFILE pf);

STDAPI AVIGetFromClipboard(__deref_out PAVIFILE FAR * lppf);

STDAPI AVIClearClipboard(void);

/****************************************************************************
 *
 *  Editing routines
 *
 ***************************************************************************/
STDAPI CreateEditableStream(
		__deref_out PAVISTREAM FAR *	    ppsEditable,
		__in PAVISTREAM		    psSource);

STDAPI EditStreamCut(__in PAVISTREAM pavi, __inout LONG FAR *plStart, __inout LONG FAR *plLength, __deref_out PAVISTREAM FAR * ppResult);

STDAPI EditStreamCopy(__in PAVISTREAM pavi, __inout LONG FAR *plStart, __inout LONG FAR *plLength, __deref_out PAVISTREAM FAR * ppResult);

STDAPI EditStreamPaste(__in PAVISTREAM pavi, __inout LONG FAR *plPos, __inout LONG FAR *plLength, __in PAVISTREAM pstream, __in LONG lStart, __in LONG lEnd);

STDAPI EditStreamClone(__in PAVISTREAM pavi, __deref_out PAVISTREAM FAR *ppResult);


STDAPI EditStreamSetNameA(__in PAVISTREAM pavi, __in LPCSTR lpszName);
STDAPI EditStreamSetNameW(__in PAVISTREAM pavi, __in LPCWSTR lpszName);
STDAPI EditStreamSetInfoW(__in PAVISTREAM pavi, __in_bcount(cbInfo) LPAVISTREAMINFOW lpInfo, __in LONG cbInfo);
STDAPI EditStreamSetInfoA(__in PAVISTREAM pavi, __in_bcount(cbInfo) LPAVISTREAMINFOA lpInfo, __in LONG cbInfo);
#ifdef UNICODE
#define EditStreamSetInfo	EditStreamSetInfoW
#define EditStreamSetName	EditStreamSetNameW
#else
#define EditStreamSetInfo	EditStreamSetInfoA
#define EditStreamSetName	EditStreamSetNameA
#endif

/*	-	-	-	-	-	-	-	-	*/

#ifndef AVIERR_OK
#define AVIERR_OK               0L

#define MAKE_AVIERR(error)	MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x4000 + error)

// !!! Questions to be answered:
// How can you get a string form of these errors?
// Which of these errors should be replaced by errors in SCODE.H?
#define AVIERR_UNSUPPORTED      MAKE_AVIERR(101)
#define AVIERR_BADFORMAT        MAKE_AVIERR(102)
#define AVIERR_MEMORY           MAKE_AVIERR(103)
#define AVIERR_INTERNAL         MAKE_AVIERR(104)
#define AVIERR_BADFLAGS         MAKE_AVIERR(105)
#define AVIERR_BADPARAM         MAKE_AVIERR(106)
#define AVIERR_BADSIZE          MAKE_AVIERR(107)
#define AVIERR_BADHANDLE        MAKE_AVIERR(108)
#define AVIERR_FILEREAD         MAKE_AVIERR(109)
#define AVIERR_FILEWRITE        MAKE_AVIERR(110)
#define AVIERR_FILEOPEN         MAKE_AVIERR(111)
#define AVIERR_COMPRESSOR       MAKE_AVIERR(112)
#define AVIERR_NOCOMPRESSOR     MAKE_AVIERR(113)
#define AVIERR_READONLY		MAKE_AVIERR(114)
#define AVIERR_NODATA		MAKE_AVIERR(115)
#define AVIERR_BUFFERTOOSMALL	MAKE_AVIERR(116)
#define AVIERR_CANTCOMPRESS	MAKE_AVIERR(117)
#define AVIERR_USERABORT        MAKE_AVIERR(198)
#define AVIERR_ERROR            MAKE_AVIERR(199)
#endif
#endif  /* NOAVIFILE */

/****************************************************************************
 *
 *  MCIWnd - Window class for MCI objects
 *
 ***************************************************************************/
#ifndef NOMCIWND
/*----------------------------------------------------------------------------*\
 *
 *  MCIWnd
 *
 *    MCIWnd window class header file.
 *
 *    the MCIWnd window class is a window class for controling MCI devices
 *    MCI devices include, wave files, midi files, AVI Video, cd audio,
 *    vcr, video disc, and others..
 *
 *    to learn more about MCI and mci command sets see the
 *    "Microsoft Multimedia Programmers's guide" in the Win31 SDK
 *
 *    the easiest use of the MCIWnd class is like so:
 *
 *          hwnd = MCIWndCreate(hwndParent, hInstance, 0, "chimes.wav");
 *          ...
 *          MCIWndPlay(hwnd);
 *          MCIWndStop(hwnd);
 *          MCIWndPause(hwnd);
 *          ....
 *          MCIWndDestroy(hwnd);
 *
 *    this will create a window with a play/pause, stop and a playbar
 *    and start the wave file playing.
 *
 *    mciwnd.h defines macros for all the most common MCI commands, but
 *    any string command can be used if needed.
 *
 *    Note: unlike the mciSendString() API, no alias or file name needs
 *    to be specifed, since the device to use is implied by the window handle.
 *
 *          MCIWndSendString(hwnd, "setaudio stream to 2");
 *
 *    (C) Copyright Microsoft Corp. 1991-1995.  All rights reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files.
 *
 *    If you did not get this from Microsoft Sources, then it may not be the
 *    most current version.  This sample code in particular will be updated
 *    and include more documentation.
 *
 *    Sources are:
 *       CompuServe: WINSDK forum, MDK section.
 *       Anonymous FTP from ftp.uu.net vendor\microsoft\multimedia
 *
 * WIN32:
 *
 *    MCIWnd supports both ansi and unicode interfaces. For any message that
 *    takes or returns a text string, two versions of the message are defined,
 *    appended with A or W for Ansi or Wide Char. The message or api itself
 *    is defined to be one or other of these depending on whether you have
 *    UNICODE defined in your application.
 *    Thus for the api MCIWndCreate, there are in fact two apis,
 *    MCIWndCreateA and MCIWndCreateW. If you call MCIWndCreate, this will be
 *    re-routed to MCIWndCreateA unless UNICODE is defined when building your
 *    application. In any one application, you can mix calls to the
 *    Ansi and Unicode entrypoints.
 *
 *    If you use SendMessage instead of the macros below such as MCIWndOpen(),
 *    you will see that the messages have changed for WIN32, to support Ansi
 *    and Unicode entrypoints. In particular, MCI_OPEN has been replaced by
 *    MCWNDM_OPENA, or MCIWNDM_OPENW (MCIWNDM_OPEN is defined to be one or
 *    other of these).
 *
 *    Also, note that the WIN32 implementation of MCIWnd uses UNICODE
 *    so all apis and messages supporting ANSI strings do so by mapping them
 *    UNICODE strings and then calling the corresponding UNICODE entrypoint.
 *
 *----------------------------------------------------------------------------*/

#ifdef __cplusplus
// MFC Redefines SendMessage, so make sure we get the global one....
#define MCIWndSM ::SendMessage  /* SendMessage in C++*/
#else
#define MCIWndSM SendMessage    /* SendMessage in C */
#endif  /* __cplusplus */
#define MCIWND_WINDOW_CLASS TEXT("MCIWndClass")
HWND
VFWAPIV
MCIWndCreateA(
    __in_opt HWND hwndParent,
    __in_opt HINSTANCE hInstance,
    __in     DWORD dwStyle,
    __in_opt LPCSTR szFile
    );

HWND
VFWAPIV
MCIWndCreateW(
    __in_opt HWND hwndParent,
    __in_opt HINSTANCE hInstance,
    __in     DWORD dwStyle,
    __in_opt LPCWSTR szFile
    );

#ifdef UNICODE
#define MCIWndCreate    MCIWndCreateW
#else
#define MCIWndCreate    MCIWndCreateA
#endif
BOOL VFWAPIV MCIWndRegisterClass(void);

// Flags for the MCIWndOpen command
#define MCIWNDOPENF_NEW	            0x0001  // open a new file

// window styles
#define MCIWNDF_NOAUTOSIZEWINDOW    0x0001  // when movie size changes
#define MCIWNDF_NOPLAYBAR           0x0002  // no toolbar
#define MCIWNDF_NOAUTOSIZEMOVIE     0x0004  // when window size changes
#define MCIWNDF_NOMENU              0x0008  // no popup menu from RBUTTONDOWN
#define MCIWNDF_SHOWNAME            0x0010  // show name in caption
#define MCIWNDF_SHOWPOS             0x0020  // show position in caption
#define MCIWNDF_SHOWMODE            0x0040  // show mode in caption
#define MCIWNDF_SHOWALL             0x0070  // show all

#define MCIWNDF_NOTIFYMODE         0x0100  // tell parent of mode change
#define MCIWNDF_NOTIFYPOS          0x0200  // tell parent of pos change
#define MCIWNDF_NOTIFYSIZE         0x0400  // tell parent of size change
#define MCIWNDF_NOTIFYERROR        0x1000  // tell parent of an error
#define MCIWNDF_NOTIFYALL          0x1F00  // tell all

#define MCIWNDF_NOTIFYANSI	   0x0080


// The MEDIA notification includes a text string.
// To receive notifications in ANSI instead of unicode set the
// MCIWNDF_NOTIFYANSI style bit. The macro below includes this bit
// by default unless you define UNICODE in your application.

#define MCIWNDF_NOTIFYMEDIAA       0x0880  // tell parent of media change
#define MCIWNDF_NOTIFYMEDIAW       0x0800  // tell parent of media change

#ifdef UNICODE
#define MCIWNDF_NOTIFYMEDIA         MCIWNDF_NOTIFYMEDIAW
#else
#define MCIWNDF_NOTIFYMEDIA         MCIWNDF_NOTIFYMEDIAA
#endif



#define MCIWNDF_RECORD              0x2000  // Give a record button
#define MCIWNDF_NOERRORDLG          0x4000  // Show Error Dlgs for MCI cmds?
#define MCIWNDF_NOOPEN		    0x8000  // Don't allow user to open things




// can macros

#define MCIWndCanPlay(hwnd)         (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_PLAY,0,0)
#define MCIWndCanRecord(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_RECORD,0,0)
#define MCIWndCanSave(hwnd)         (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_SAVE,0,0)
#define MCIWndCanWindow(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_WINDOW,0,0)
#define MCIWndCanEject(hwnd)        (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_EJECT,0,0)
#define MCIWndCanConfig(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_CONFIG,0,0)
#define MCIWndPaletteKick(hwnd)     (BOOL)MCIWndSM(hwnd,MCIWNDM_PALETTEKICK,0,0)

#define MCIWndSave(hwnd, szFile)    (LONG)MCIWndSM(hwnd, MCI_SAVE, 0, (LPARAM)(LPVOID)(szFile))
#define MCIWndSaveDialog(hwnd)      MCIWndSave(hwnd, -1)

// if you dont give a device it will use the current device....
#define MCIWndNew(hwnd, lp)         (LONG)MCIWndSM(hwnd, MCIWNDM_NEW, 0, (LPARAM)(LPVOID)(lp))

#define MCIWndRecord(hwnd)          (LONG)MCIWndSM(hwnd, MCI_RECORD, 0, 0)
#define MCIWndOpen(hwnd, sz, f)     (LONG)MCIWndSM(hwnd, MCIWNDM_OPEN, (WPARAM)(UINT)(f),(LPARAM)(LPVOID)(sz))
#define MCIWndOpenDialog(hwnd)      MCIWndOpen(hwnd, -1, 0)
#define MCIWndClose(hwnd)           (LONG)MCIWndSM(hwnd, MCI_CLOSE, 0, 0)
#define MCIWndPlay(hwnd)            (LONG)MCIWndSM(hwnd, MCI_PLAY, 0, 0)
#define MCIWndStop(hwnd)            (LONG)MCIWndSM(hwnd, MCI_STOP, 0, 0)
#define MCIWndPause(hwnd)           (LONG)MCIWndSM(hwnd, MCI_PAUSE, 0, 0)
#define MCIWndResume(hwnd)          (LONG)MCIWndSM(hwnd, MCI_RESUME, 0, 0)
#define MCIWndSeek(hwnd, lPos)      (LONG)MCIWndSM(hwnd, MCI_SEEK, 0, (LPARAM)(LONG)(lPos))
#define MCIWndEject(hwnd)           (LONG)MCIWndSM(hwnd, MCIWNDM_EJECT, 0, 0)

#define MCIWndHome(hwnd)            MCIWndSeek(hwnd, MCIWND_START)
#define MCIWndEnd(hwnd)             MCIWndSeek(hwnd, MCIWND_END)

#define MCIWndGetSource(hwnd, prc)  (LONG)MCIWndSM(hwnd, MCIWNDM_GET_SOURCE, 0, (LPARAM)(LPRECT)(prc))
#define MCIWndPutSource(hwnd, prc)  (LONG)MCIWndSM(hwnd, MCIWNDM_PUT_SOURCE, 0, (LPARAM)(LPRECT)(prc))

#define MCIWndGetDest(hwnd, prc)    (LONG)MCIWndSM(hwnd, MCIWNDM_GET_DEST, 0, (LPARAM)(LPRECT)(prc))
#define MCIWndPutDest(hwnd, prc)    (LONG)MCIWndSM(hwnd, MCIWNDM_PUT_DEST, 0, (LPARAM)(LPRECT)(prc))

#define MCIWndPlayReverse(hwnd)     (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYREVERSE, 0, 0)
#define MCIWndPlayFrom(hwnd, lPos)  (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYFROM, 0, (LPARAM)(LONG)(lPos))
#define MCIWndPlayTo(hwnd, lPos)    (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYTO,   0, (LPARAM)(LONG)(lPos))
#define MCIWndPlayFromTo(hwnd, lStart, lEnd) (MCIWndSeek(hwnd, lStart), MCIWndPlayTo(hwnd, lEnd))

#define MCIWndGetDeviceID(hwnd)     (UINT)MCIWndSM(hwnd, MCIWNDM_GETDEVICEID, 0, 0)
#define MCIWndGetAlias(hwnd)        (UINT)MCIWndSM(hwnd, MCIWNDM_GETALIAS, 0, 0)
#define MCIWndGetMode(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETMODE, (WPARAM)(UINT)(len), (LPARAM)(LPTSTR)(lp))
#define MCIWndGetPosition(hwnd)     (LONG)MCIWndSM(hwnd, MCIWNDM_GETPOSITION, 0, 0)
#define MCIWndGetPositionString(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETPOSITION, (WPARAM)(UINT)(len), (LPARAM)(LPTSTR)(lp))
#define MCIWndGetStart(hwnd)        (LONG)MCIWndSM(hwnd, MCIWNDM_GETSTART, 0, 0)
#define MCIWndGetLength(hwnd)       (LONG)MCIWndSM(hwnd, MCIWNDM_GETLENGTH, 0, 0)
#define MCIWndGetEnd(hwnd)          (LONG)MCIWndSM(hwnd, MCIWNDM_GETEND, 0, 0)

#define MCIWndStep(hwnd, n)         (LONG)MCIWndSM(hwnd, MCI_STEP, 0,(LPARAM)(long)(n))

#define MCIWndDestroy(hwnd)         (VOID)MCIWndSM(hwnd, WM_CLOSE, 0, 0)
#define MCIWndSetZoom(hwnd,iZoom)   (VOID)MCIWndSM(hwnd, MCIWNDM_SETZOOM, 0, (LPARAM)(UINT)(iZoom))
#define MCIWndGetZoom(hwnd)         (UINT)MCIWndSM(hwnd, MCIWNDM_GETZOOM, 0, 0)
#define MCIWndSetVolume(hwnd,iVol)  (LONG)MCIWndSM(hwnd, MCIWNDM_SETVOLUME, 0, (LPARAM)(UINT)(iVol))
#define MCIWndGetVolume(hwnd)       (LONG)MCIWndSM(hwnd, MCIWNDM_GETVOLUME, 0, 0)
#define MCIWndSetSpeed(hwnd,iSpeed) (LONG)MCIWndSM(hwnd, MCIWNDM_SETSPEED, 0, (LPARAM)(UINT)(iSpeed))
#define MCIWndGetSpeed(hwnd)        (LONG)MCIWndSM(hwnd, MCIWNDM_GETSPEED, 0, 0)
#define MCIWndSetTimeFormat(hwnd, lp) (LONG)MCIWndSM(hwnd, MCIWNDM_SETTIMEFORMAT, 0, (LPARAM)(LPTSTR)(lp))
#define MCIWndGetTimeFormat(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETTIMEFORMAT, (WPARAM)(UINT)(len), (LPARAM)(LPTSTR)(lp))
#define MCIWndValidateMedia(hwnd)   (VOID)MCIWndSM(hwnd, MCIWNDM_VALIDATEMEDIA, 0, 0)

#define MCIWndSetRepeat(hwnd,f)     (void)MCIWndSM(hwnd, MCIWNDM_SETREPEAT, 0, (LPARAM)(BOOL)(f))
#define MCIWndGetRepeat(hwnd)       (BOOL)MCIWndSM(hwnd, MCIWNDM_GETREPEAT, 0, 0)

#define MCIWndUseFrames(hwnd)       MCIWndSetTimeFormat(hwnd, TEXT("frames"))
#define MCIWndUseTime(hwnd)         MCIWndSetTimeFormat(hwnd, TEXT("ms"))

#define MCIWndSetActiveTimer(hwnd, active)				\
	(VOID)MCIWndSM(hwnd, MCIWNDM_SETACTIVETIMER,			\
	(WPARAM)(UINT)(active), 0L)
#define MCIWndSetInactiveTimer(hwnd, inactive)				\
	(VOID)MCIWndSM(hwnd, MCIWNDM_SETINACTIVETIMER,		\
	(WPARAM)(UINT)(inactive), 0L)
#define MCIWndSetTimers(hwnd, active, inactive)				      \
	    (VOID)MCIWndSM(hwnd, MCIWNDM_SETTIMERS,(WPARAM)(UINT)(active), \
	    (LPARAM)(UINT)(inactive))
#define MCIWndGetActiveTimer(hwnd)					\
	(UINT)MCIWndSM(hwnd, MCIWNDM_GETACTIVETIMER,	0, 0L);
#define MCIWndGetInactiveTimer(hwnd)					\
	(UINT)MCIWndSM(hwnd, MCIWNDM_GETINACTIVETIMER, 0, 0L);

#define MCIWndRealize(hwnd, fBkgnd) (LONG)MCIWndSM(hwnd, MCIWNDM_REALIZE,(WPARAM)(BOOL)(fBkgnd),0)

#define MCIWndSendString(hwnd, sz)  (LONG)MCIWndSM(hwnd, MCIWNDM_SENDSTRING, 0, (LPARAM)(LPTSTR)(sz))
#define MCIWndReturnString(hwnd, lp, len)  (LONG)MCIWndSM(hwnd, MCIWNDM_RETURNSTRING, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))
#define MCIWndGetError(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETERROR, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))

//#define MCIWndActivate(hwnd, f)     (void)MCIWndSM(hwnd, WM_ACTIVATE, (WPARAM)(BOOL)(f), 0)

#define MCIWndGetPalette(hwnd)      (HPALETTE)MCIWndSM(hwnd, MCIWNDM_GETPALETTE, 0, 0)
#define MCIWndSetPalette(hwnd, hpal) (LONG)MCIWndSM(hwnd, MCIWNDM_SETPALETTE, (WPARAM)(HPALETTE)(hpal), 0)

#define MCIWndGetFileName(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETFILENAME, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))
#define MCIWndGetDevice(hwnd, lp, len)   (LONG)MCIWndSM(hwnd, MCIWNDM_GETDEVICE, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))

#define MCIWndGetStyles(hwnd) (UINT)MCIWndSM(hwnd, MCIWNDM_GETSTYLES, 0, 0L)
#define MCIWndChangeStyles(hwnd, mask, value) (LONG)MCIWndSM(hwnd, MCIWNDM_CHANGESTYLES, (WPARAM)(UINT)(mask), (LPARAM)(LONG)(value))

#define MCIWndOpenInterface(hwnd, pUnk)  (LONG)MCIWndSM(hwnd, MCIWNDM_OPENINTERFACE, 0, (LPARAM)(LPUNKNOWN)(pUnk))

#define MCIWndSetOwner(hwnd, hwndP)  (LONG)MCIWndSM(hwnd, MCIWNDM_SETOWNER, (WPARAM)(hwndP), 0)


// Messages an app will send to MCIWND

// all the text-related messages are defined out of order above (they need
// to be defined before the MCIWndOpen() macros

#define MCIWNDM_GETDEVICEID	(WM_USER + 100)
#define MCIWNDM_GETSTART	(WM_USER + 103)
#define MCIWNDM_GETLENGTH	(WM_USER + 104)
#define MCIWNDM_GETEND		(WM_USER + 105)
#define MCIWNDM_EJECT		(WM_USER + 107)
#define MCIWNDM_SETZOOM		(WM_USER + 108)
#define MCIWNDM_GETZOOM         (WM_USER + 109)
#define MCIWNDM_SETVOLUME	(WM_USER + 110)
#define MCIWNDM_GETVOLUME	(WM_USER + 111)
#define MCIWNDM_SETSPEED	(WM_USER + 112)
#define MCIWNDM_GETSPEED	(WM_USER + 113)
#define MCIWNDM_SETREPEAT	(WM_USER + 114)
#define MCIWNDM_GETREPEAT	(WM_USER + 115)
#define MCIWNDM_REALIZE         (WM_USER + 118)
#define MCIWNDM_VALIDATEMEDIA   (WM_USER + 121)
#define MCIWNDM_PLAYFROM	(WM_USER + 122)
#define MCIWNDM_PLAYTO          (WM_USER + 123)
#define MCIWNDM_GETPALETTE      (WM_USER + 126)
#define MCIWNDM_SETPALETTE      (WM_USER + 127)
#define MCIWNDM_SETTIMERS	(WM_USER + 129)
#define MCIWNDM_SETACTIVETIMER	(WM_USER + 130)
#define MCIWNDM_SETINACTIVETIMER (WM_USER + 131)
#define MCIWNDM_GETACTIVETIMER	(WM_USER + 132)
#define MCIWNDM_GETINACTIVETIMER (WM_USER + 133)
#define MCIWNDM_CHANGESTYLES	(WM_USER + 135)
#define MCIWNDM_GETSTYLES	(WM_USER + 136)
#define MCIWNDM_GETALIAS	(WM_USER + 137)
#define MCIWNDM_PLAYREVERSE	(WM_USER + 139)
#define MCIWNDM_GET_SOURCE      (WM_USER + 140)
#define MCIWNDM_PUT_SOURCE      (WM_USER + 141)
#define MCIWNDM_GET_DEST        (WM_USER + 142)
#define MCIWNDM_PUT_DEST        (WM_USER + 143)
#define MCIWNDM_CAN_PLAY        (WM_USER + 144)
#define MCIWNDM_CAN_WINDOW      (WM_USER + 145)
#define MCIWNDM_CAN_RECORD      (WM_USER + 146)
#define MCIWNDM_CAN_SAVE        (WM_USER + 147)
#define MCIWNDM_CAN_EJECT       (WM_USER + 148)
#define MCIWNDM_CAN_CONFIG      (WM_USER + 149)
#define MCIWNDM_PALETTEKICK     (WM_USER + 150)
#define MCIWNDM_OPENINTERFACE	(WM_USER + 151)
#define MCIWNDM_SETOWNER	(WM_USER + 152)



//define both A and W messages
#define MCIWNDM_SENDSTRINGA	(WM_USER + 101)
#define MCIWNDM_GETPOSITIONA	(WM_USER + 102)
#define MCIWNDM_GETMODEA	(WM_USER + 106)
#define MCIWNDM_SETTIMEFORMATA  (WM_USER + 119)
#define MCIWNDM_GETTIMEFORMATA  (WM_USER + 120)
#define MCIWNDM_GETFILENAMEA    (WM_USER + 124)
#define MCIWNDM_GETDEVICEA      (WM_USER + 125)
#define MCIWNDM_GETERRORA       (WM_USER + 128)
#define MCIWNDM_NEWA		(WM_USER + 134)
#define MCIWNDM_RETURNSTRINGA	(WM_USER + 138)
#define MCIWNDM_OPENA		(WM_USER + 153)

#define MCIWNDM_SENDSTRINGW	(WM_USER + 201)
#define MCIWNDM_GETPOSITIONW	(WM_USER + 202)
#define MCIWNDM_GETMODEW	(WM_USER + 206)
#define MCIWNDM_SETTIMEFORMATW  (WM_USER + 219)
#define MCIWNDM_GETTIMEFORMATW  (WM_USER + 220)
#define MCIWNDM_GETFILENAMEW    (WM_USER + 224)
#define MCIWNDM_GETDEVICEW      (WM_USER + 225)
#define MCIWNDM_GETERRORW       (WM_USER + 228)
#define MCIWNDM_NEWW		(WM_USER + 234)
#define MCIWNDM_RETURNSTRINGW	(WM_USER + 238)
#define MCIWNDM_OPENW		(WM_USER + 252)

// map defaults to A or W depending on app's UNICODE setting
#ifdef UNICODE
#define MCIWNDM_SENDSTRING      MCIWNDM_SENDSTRINGW
#define MCIWNDM_GETPOSITION     MCIWNDM_GETPOSITIONW
#define MCIWNDM_GETMODE         MCIWNDM_GETMODEW
#define MCIWNDM_SETTIMEFORMAT   MCIWNDM_SETTIMEFORMATW
#define MCIWNDM_GETTIMEFORMAT   MCIWNDM_GETTIMEFORMATW
#define MCIWNDM_GETFILENAME     MCIWNDM_GETFILENAMEW
#define MCIWNDM_GETDEVICE       MCIWNDM_GETDEVICEW
#define MCIWNDM_GETERROR        MCIWNDM_GETERRORW
#define MCIWNDM_NEW             MCIWNDM_NEWW
#define MCIWNDM_RETURNSTRING    MCIWNDM_RETURNSTRINGW
#define MCIWNDM_OPEN		MCIWNDM_OPENW
#else
#define MCIWNDM_SENDSTRING      MCIWNDM_SENDSTRINGA
#define MCIWNDM_GETPOSITION     MCIWNDM_GETPOSITIONA
#define MCIWNDM_GETMODE         MCIWNDM_GETMODEA
#define MCIWNDM_SETTIMEFORMAT   MCIWNDM_SETTIMEFORMATA
#define MCIWNDM_GETTIMEFORMAT   MCIWNDM_GETTIMEFORMATA
#define MCIWNDM_GETFILENAME     MCIWNDM_GETFILENAMEA
#define MCIWNDM_GETDEVICE       MCIWNDM_GETDEVICEA
#define MCIWNDM_GETERROR        MCIWNDM_GETERRORA
#define MCIWNDM_NEW             MCIWNDM_NEWA
#define MCIWNDM_RETURNSTRING    MCIWNDM_RETURNSTRINGA
#define MCIWNDM_OPEN		MCIWNDM_OPENA
#endif

// note that the source text for MCIWND will thus contain
// support for eg MCIWNDM_SENDSTRING (both the 16-bit entrypoint and
// in win32 mapped to MCIWNDM_SENDSTRINGW), and MCIWNDM_SENDSTRINGA (the
// win32 ansi thunk).







// Messages MCIWND will send to an app
// !!! Use less messages and use a code instead to indicate the type of notify? /* ;Internal */
#define MCIWNDM_NOTIFYMODE      (WM_USER + 200)  // wp = hwnd, lp = mode
#define MCIWNDM_NOTIFYPOS	(WM_USER + 201)  // wp = hwnd, lp = pos
#define MCIWNDM_NOTIFYSIZE	(WM_USER + 202)  // wp = hwnd
#define MCIWNDM_NOTIFYMEDIA     (WM_USER + 203)  // wp = hwnd, lp = fn
#define MCIWNDM_NOTIFYERROR     (WM_USER + 205)  // wp = hwnd, lp = error

// special seek values for START and END
#define MCIWND_START                -1
#define MCIWND_END                  -2

#ifndef MCI_PLAY
    /* MCI command message identifiers */
#ifndef _WIN32
    // win32 apps send MCIWNDM_OPEN
    #define MCI_OPEN                        0x0803
#endif
    #define MCI_CLOSE                       0x0804
    #define MCI_PLAY                        0x0806
    #define MCI_SEEK                        0x0807
    #define MCI_STOP                        0x0808
    #define MCI_PAUSE                       0x0809
    #define MCI_STEP                        0x080E
    #define MCI_RECORD                      0x080F
    #define MCI_SAVE                        0x0813
    #define MCI_CUT                         0x0851
    #define MCI_COPY                        0x0852
    #define MCI_PASTE                       0x0853
    #define MCI_RESUME                      0x0855
    #define MCI_DELETE                      0x0856
#endif

#ifndef MCI_MODE_NOT_READY
    /* return values for 'status mode' command */
    #define MCI_MODE_NOT_READY      (524)
    #define MCI_MODE_STOP           (525)
    #define MCI_MODE_PLAY           (526)
    #define MCI_MODE_RECORD         (527)
    #define MCI_MODE_SEEK           (528)
    #define MCI_MODE_PAUSE          (529)
    #define MCI_MODE_OPEN           (530)
#endif

#endif  /* NOAVIFILE */
/****************************************************************************
 *
 *  VIDEO - Video Capture Driver Interface
 *
 ****************************************************************************/

#if !defined(NOAVICAP) || !defined(NOVIDEO)

#ifndef _RCINVOKED


/* video data types */
DECLARE_HANDLE(HVIDEO);                 // generic handle
typedef HVIDEO FAR * LPHVIDEO;
#endif                                  // ifndef RCINVOKED

/****************************************************************************

                        version api

****************************************************************************/

DWORD FAR PASCAL VideoForWindowsVersion(void);

/****************************************************************************

                            Error Return Values

****************************************************************************/
#define DV_ERR_OK               (0)                  /* No error */
#define DV_ERR_BASE             (1)                  /* Error Base */
#define DV_ERR_NONSPECIFIC      (DV_ERR_BASE)
#define DV_ERR_BADFORMAT        (DV_ERR_BASE + 1)
				/* unsupported video format */
#define DV_ERR_STILLPLAYING     (DV_ERR_BASE + 2)
				/* still something playing */
#define DV_ERR_UNPREPARED       (DV_ERR_BASE + 3)
				/* header not prepared */
#define DV_ERR_SYNC             (DV_ERR_BASE + 4)
				/* device is synchronous */
#define DV_ERR_TOOMANYCHANNELS  (DV_ERR_BASE + 5)
				/* number of channels exceeded */
#define DV_ERR_NOTDETECTED	(DV_ERR_BASE + 6)    /* HW not detected */
#define DV_ERR_BADINSTALL	(DV_ERR_BASE + 7)    /* Can not get Profile */
#define DV_ERR_CREATEPALETTE	(DV_ERR_BASE + 8)
#define DV_ERR_SIZEFIELD	(DV_ERR_BASE + 9)
#define DV_ERR_PARAM1		(DV_ERR_BASE + 10)
#define DV_ERR_PARAM2		(DV_ERR_BASE + 11)
#define DV_ERR_CONFIG1		(DV_ERR_BASE + 12)
#define DV_ERR_CONFIG2		(DV_ERR_BASE + 13)
#define DV_ERR_FLAGS		(DV_ERR_BASE + 14)
#define DV_ERR_13		(DV_ERR_BASE + 15)

#define DV_ERR_NOTSUPPORTED     (DV_ERR_BASE + 16)   /* function not suported */
#define DV_ERR_NOMEM            (DV_ERR_BASE + 17)   /* out of memory */
#define DV_ERR_ALLOCATED        (DV_ERR_BASE + 18)   /* device is allocated */
#define DV_ERR_BADDEVICEID      (DV_ERR_BASE + 19)
#define DV_ERR_INVALHANDLE      (DV_ERR_BASE + 20)
#define DV_ERR_BADERRNUM        (DV_ERR_BASE + 21)
#define DV_ERR_NO_BUFFERS       (DV_ERR_BASE + 22)   /* out of buffers */

#define DV_ERR_MEM_CONFLICT     (DV_ERR_BASE + 23)   /* Mem conflict detected */
#define DV_ERR_IO_CONFLICT      (DV_ERR_BASE + 24)   /* I/O conflict detected */
#define DV_ERR_DMA_CONFLICT     (DV_ERR_BASE + 25)   /* DMA conflict detected */
#define DV_ERR_INT_CONFLICT     (DV_ERR_BASE + 26)   /* Interrupt conflict detected */
#define DV_ERR_PROTECT_ONLY     (DV_ERR_BASE + 27)   /* Can not run in standard mode */
#define DV_ERR_LASTERROR        (DV_ERR_BASE + 27)

//#define DV_IDS_PROFILING        (DV_ERR_BASE + 900)
//#define DV_IDS_LISTBOX          (DV_ERR_BASE + 901)

#define DV_ERR_USER_MSG         (DV_ERR_BASE + 1000) /* Hardware specific errors */

/****************************************************************************

                         Callback Messages

Note that the values for all installable driver callback messages are
identical, (ie. MM_DRVM_DATA has the same value for capture drivers,
installable video codecs, and the audio compression manager).
****************************************************************************/
#ifndef _RCINVOKED

#ifndef MM_DRVM_OPEN
#define MM_DRVM_OPEN       0x3D0
#define MM_DRVM_CLOSE      0x3D1
#define MM_DRVM_DATA       0x3D2
#define MM_DRVM_ERROR      0x3D3
#endif

#define DV_VM_OPEN         MM_DRVM_OPEN         // Obsolete messages
#define DV_VM_CLOSE        MM_DRVM_CLOSE
#define DV_VM_DATA         MM_DRVM_DATA
#define DV_VM_ERROR        MM_DRVM_ERROR

/****************************************************************************

                         Structures

****************************************************************************/
/* video data block header */
typedef struct videohdr_tag {
    LPBYTE      lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* Length of data buffer */
    DWORD       dwBytesUsed;            /* Bytes actually used */
    DWORD       dwTimeCaptured;         /* Milliseconds from start of stream */
    DWORD_PTR   dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD_PTR   dwReserved[4];          /* reserved for driver */
} VIDEOHDR, NEAR *PVIDEOHDR, FAR * LPVIDEOHDR;

/* dwFlags field of VIDEOHDR */
#define VHDR_DONE       0x00000001  /* Done bit */
#define VHDR_PREPARED   0x00000002  /* Set if this header has been prepared */
#define VHDR_INQUEUE    0x00000004  /* Reserved for driver */
#define VHDR_KEYFRAME   0x00000008  /* Key Frame */
#define VHDR_VALID      0x0000000F  /* valid flags */     /* ;Internal */

/* Channel capabilities structure */
typedef struct channel_caps_tag {
    DWORD       dwFlags;                /* Capability flags*/
    DWORD       dwSrcRectXMod;          /* Granularity of src rect in x */
    DWORD       dwSrcRectYMod;          /* Granularity of src rect in y */
    DWORD       dwSrcRectWidthMod;      /* Granularity of src rect width */
    DWORD       dwSrcRectHeightMod;     /* Granularity of src rect height */
    DWORD       dwDstRectXMod;          /* Granularity of dst rect in x */
    DWORD       dwDstRectYMod;          /* Granularity of dst rect in y */
    DWORD       dwDstRectWidthMod;      /* Granularity of dst rect width */
    DWORD       dwDstRectHeightMod;     /* Granularity of dst rect height */
} CHANNEL_CAPS, NEAR *PCHANNEL_CAPS, FAR * LPCHANNEL_CAPS;

/* dwFlags of CHANNEL_CAPS */
#define VCAPS_OVERLAY       0x00000001      /* overlay channel */
#define VCAPS_SRC_CAN_CLIP  0x00000002      /* src rect can clip */
#define VCAPS_DST_CAN_CLIP  0x00000004      /* dst rect can clip */
#define VCAPS_CAN_SCALE     0x00000008      /* allows src != dst */


/****************************************************************************

			API Flags

****************************************************************************/

// Types of channels to open with the videoOpen function
#define VIDEO_EXTERNALIN		0x0001
#define VIDEO_EXTERNALOUT		0x0002
#define VIDEO_IN			0x0004
#define VIDEO_OUT			0x0008

// Is a driver dialog available for this channel?
#define VIDEO_DLG_QUERY			0x0010

// videoConfigure (both GET and SET)
#define VIDEO_CONFIGURE_QUERY   	0x8000

// videoConfigure (SET only)
#define VIDEO_CONFIGURE_SET		0x1000

// videoConfigure (GET only)
#define VIDEO_CONFIGURE_GET		0x2000
#define VIDEO_CONFIGURE_QUERYSIZE	0x0001

#define VIDEO_CONFIGURE_CURRENT		0x0010
#define VIDEO_CONFIGURE_NOMINAL		0x0020
#define VIDEO_CONFIGURE_MIN		0x0040
#define VIDEO_CONFIGURE_MAX		0x0080

/****************************************************************************

			CONFIGURE MESSAGES

****************************************************************************/
#define DVM_USER                        0X4000

#define DVM_CONFIGURE_START		0x1000
#define DVM_CONFIGURE_END		0x1FFF

#define DVM_PALETTE			(DVM_CONFIGURE_START + 1)
#define DVM_FORMAT			(DVM_CONFIGURE_START + 2)
#define DVM_PALETTERGB555		(DVM_CONFIGURE_START + 3)
#define DVM_SRC_RECT    		(DVM_CONFIGURE_START + 4)
#define DVM_DST_RECT    		(DVM_CONFIGURE_START + 5)

#endif  /* ifndef _RCINVOKED */

#endif  /* NOVIDEO */

/****************************************************************************
 *
 *  AVICAP - Window class for AVI capture
 *
 ***************************************************************************/

#ifndef NOAVICAP
#ifdef __cplusplus
/* SendMessage in C++*/
#define AVICapSM(hwnd,m,w,l) ( (::IsWindow(hwnd)) ? ::SendMessage(hwnd,m,w,l) : 0)
#else
/* SendMessage in C */
#define AVICapSM(hwnd,m,w,l) ( (IsWindow(hwnd)) ?   SendMessage(hwnd,m,w,l) : 0)
#endif  /* __cplusplus */

#ifndef RC_INVOKED

// ------------------------------------------------------------------
//  Window Messages  WM_CAP... which can be sent to an AVICAP window
// ------------------------------------------------------------------



// UNICODE
//
// The Win32 version of AVICAP on NT supports UNICODE applications:
// for each API or message that takes a char or string parameter, there are
// two versions, ApiNameA and ApiNameW. The default name ApiName is #defined
// to one or other depending on whether UNICODE is defined. Apps can call
// the A and W apis directly, and mix them.
//
// The 32-bit AVICAP on NT uses unicode exclusively internally.
// ApiNameA() will be implemented as a call to ApiNameW() together with
// translation of strings.




// Defines start of the message range
#define WM_CAP_START                    WM_USER

// start of unicode messages
#define WM_CAP_UNICODE_START            WM_USER+100

#define WM_CAP_GET_CAPSTREAMPTR         (WM_CAP_START+  1)

#define WM_CAP_SET_CALLBACK_ERRORW     (WM_CAP_UNICODE_START+  2)
#define WM_CAP_SET_CALLBACK_STATUSW    (WM_CAP_UNICODE_START+  3)
#define WM_CAP_SET_CALLBACK_ERRORA     (WM_CAP_START+  2)
#define WM_CAP_SET_CALLBACK_STATUSA    (WM_CAP_START+  3)
#ifdef UNICODE
#define WM_CAP_SET_CALLBACK_ERROR       WM_CAP_SET_CALLBACK_ERRORW
#define WM_CAP_SET_CALLBACK_STATUS      WM_CAP_SET_CALLBACK_STATUSW
#else
#define WM_CAP_SET_CALLBACK_ERROR       WM_CAP_SET_CALLBACK_ERRORA
#define WM_CAP_SET_CALLBACK_STATUS      WM_CAP_SET_CALLBACK_STATUSA
#endif


#define WM_CAP_SET_CALLBACK_YIELD       (WM_CAP_START+  4)
#define WM_CAP_SET_CALLBACK_FRAME       (WM_CAP_START+  5)
#define WM_CAP_SET_CALLBACK_VIDEOSTREAM (WM_CAP_START+  6)
#define WM_CAP_SET_CALLBACK_WAVESTREAM  (WM_CAP_START+  7)
#define WM_CAP_GET_USER_DATA		(WM_CAP_START+  8)
#define WM_CAP_SET_USER_DATA		(WM_CAP_START+  9)

#define WM_CAP_DRIVER_CONNECT           (WM_CAP_START+  10)
#define WM_CAP_DRIVER_DISCONNECT        (WM_CAP_START+  11)

#define WM_CAP_DRIVER_GET_NAMEA        (WM_CAP_START+  12)
#define WM_CAP_DRIVER_GET_VERSIONA     (WM_CAP_START+  13)
#define WM_CAP_DRIVER_GET_NAMEW        (WM_CAP_UNICODE_START+  12)
#define WM_CAP_DRIVER_GET_VERSIONW     (WM_CAP_UNICODE_START+  13)
#ifdef UNICODE
#define WM_CAP_DRIVER_GET_NAME          WM_CAP_DRIVER_GET_NAMEW
#define WM_CAP_DRIVER_GET_VERSION       WM_CAP_DRIVER_GET_VERSIONW
#else
#define WM_CAP_DRIVER_GET_NAME          WM_CAP_DRIVER_GET_NAMEA
#define WM_CAP_DRIVER_GET_VERSION       WM_CAP_DRIVER_GET_VERSIONA
#endif

#define WM_CAP_DRIVER_GET_CAPS          (WM_CAP_START+  14)

#define WM_CAP_FILE_SET_CAPTURE_FILEA  (WM_CAP_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILEA  (WM_CAP_START+  21)
#define WM_CAP_FILE_SAVEASA            (WM_CAP_START+  23)
#define WM_CAP_FILE_SAVEDIBA           (WM_CAP_START+  25)
#define WM_CAP_FILE_SET_CAPTURE_FILEW  (WM_CAP_UNICODE_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILEW  (WM_CAP_UNICODE_START+  21)
#define WM_CAP_FILE_SAVEASW            (WM_CAP_UNICODE_START+  23)
#define WM_CAP_FILE_SAVEDIBW           (WM_CAP_UNICODE_START+  25)
#ifdef UNICODE
#define WM_CAP_FILE_SET_CAPTURE_FILE    WM_CAP_FILE_SET_CAPTURE_FILEW
#define WM_CAP_FILE_GET_CAPTURE_FILE    WM_CAP_FILE_GET_CAPTURE_FILEW
#define WM_CAP_FILE_SAVEAS              WM_CAP_FILE_SAVEASW
#define WM_CAP_FILE_SAVEDIB             WM_CAP_FILE_SAVEDIBW
#else
#define WM_CAP_FILE_SET_CAPTURE_FILE    WM_CAP_FILE_SET_CAPTURE_FILEA
#define WM_CAP_FILE_GET_CAPTURE_FILE    WM_CAP_FILE_GET_CAPTURE_FILEA
#define WM_CAP_FILE_SAVEAS              WM_CAP_FILE_SAVEASA
#define WM_CAP_FILE_SAVEDIB             WM_CAP_FILE_SAVEDIBA
#endif

// out of order to save on ifdefs
#define WM_CAP_FILE_ALLOCATE            (WM_CAP_START+  22)
#define WM_CAP_FILE_SET_INFOCHUNK       (WM_CAP_START+  24)

#define WM_CAP_EDIT_COPY                (WM_CAP_START+  30)

#define WM_CAP_SET_AUDIOFORMAT          (WM_CAP_START+  35)
#define WM_CAP_GET_AUDIOFORMAT          (WM_CAP_START+  36)

#define WM_CAP_DLG_VIDEOFORMAT          (WM_CAP_START+  41)
#define WM_CAP_DLG_VIDEOSOURCE          (WM_CAP_START+  42)
#define WM_CAP_DLG_VIDEODISPLAY         (WM_CAP_START+  43)
#define WM_CAP_GET_VIDEOFORMAT          (WM_CAP_START+  44)
#define WM_CAP_SET_VIDEOFORMAT          (WM_CAP_START+  45)
#define WM_CAP_DLG_VIDEOCOMPRESSION     (WM_CAP_START+  46)

#define WM_CAP_SET_PREVIEW              (WM_CAP_START+  50)
#define WM_CAP_SET_OVERLAY              (WM_CAP_START+  51)
#define WM_CAP_SET_PREVIEWRATE          (WM_CAP_START+  52)
#define WM_CAP_SET_SCALE                (WM_CAP_START+  53)
#define WM_CAP_GET_STATUS               (WM_CAP_START+  54)
#define WM_CAP_SET_SCROLL               (WM_CAP_START+  55)

#define WM_CAP_GRAB_FRAME               (WM_CAP_START+  60)
#define WM_CAP_GRAB_FRAME_NOSTOP        (WM_CAP_START+  61)

#define WM_CAP_SEQUENCE                 (WM_CAP_START+  62)
#define WM_CAP_SEQUENCE_NOFILE          (WM_CAP_START+  63)
#define WM_CAP_SET_SEQUENCE_SETUP       (WM_CAP_START+  64)
#define WM_CAP_GET_SEQUENCE_SETUP       (WM_CAP_START+  65)

#define WM_CAP_SET_MCI_DEVICEA         (WM_CAP_START+  66)
#define WM_CAP_GET_MCI_DEVICEA         (WM_CAP_START+  67)
#define WM_CAP_SET_MCI_DEVICEW         (WM_CAP_UNICODE_START+  66)
#define WM_CAP_GET_MCI_DEVICEW         (WM_CAP_UNICODE_START+  67)
#ifdef UNICODE
#define WM_CAP_SET_MCI_DEVICE           WM_CAP_SET_MCI_DEVICEW
#define WM_CAP_GET_MCI_DEVICE           WM_CAP_GET_MCI_DEVICEW
#else
#define WM_CAP_SET_MCI_DEVICE           WM_CAP_SET_MCI_DEVICEA
#define WM_CAP_GET_MCI_DEVICE           WM_CAP_GET_MCI_DEVICEA
#endif



#define WM_CAP_STOP                     (WM_CAP_START+  68)
#define WM_CAP_ABORT                    (WM_CAP_START+  69)

#define WM_CAP_SINGLE_FRAME_OPEN        (WM_CAP_START+  70)
#define WM_CAP_SINGLE_FRAME_CLOSE       (WM_CAP_START+  71)
#define WM_CAP_SINGLE_FRAME             (WM_CAP_START+  72)

#define WM_CAP_PAL_OPENA               (WM_CAP_START+  80)
#define WM_CAP_PAL_SAVEA               (WM_CAP_START+  81)
#define WM_CAP_PAL_OPENW               (WM_CAP_UNICODE_START+  80)
#define WM_CAP_PAL_SAVEW               (WM_CAP_UNICODE_START+  81)
#ifdef UNICODE
#define WM_CAP_PAL_OPEN                 WM_CAP_PAL_OPENW
#define WM_CAP_PAL_SAVE                 WM_CAP_PAL_SAVEW
#else
#define WM_CAP_PAL_OPEN                 WM_CAP_PAL_OPENA
#define WM_CAP_PAL_SAVE                 WM_CAP_PAL_SAVEA
#endif

#define WM_CAP_PAL_PASTE                (WM_CAP_START+  82)
#define WM_CAP_PAL_AUTOCREATE           (WM_CAP_START+  83)
#define WM_CAP_PAL_MANUALCREATE         (WM_CAP_START+  84)

// Following added post VFW 1.1
#define WM_CAP_SET_CALLBACK_CAPCONTROL  (WM_CAP_START+  85)


// Defines end of the message range
#define WM_CAP_UNICODE_END              WM_CAP_PAL_SAVEW
#define WM_CAP_END                      WM_CAP_UNICODE_END

// ------------------------------------------------------------------
//  Message crackers for above
// ------------------------------------------------------------------

// message wrapper macros are defined for the default messages only. Apps
// that wish to mix Ansi and UNICODE message sending will have to
// reference the _A and _W messages directly

#define capSetCallbackOnError(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_ERROR, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnStatus(hwnd, fpProc)       ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_STATUS, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnYield(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_YIELD, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnFrame(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_FRAME, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnVideoStream(hwnd, fpProc)  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_VIDEOSTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnWaveStream(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_WAVESTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnCapControl(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_CAPCONTROL, 0, (LPARAM)(LPVOID)(fpProc)))

#define capSetUserData(hwnd, lUser)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_USER_DATA, 0, (LPARAM)lUser))
#define capGetUserData(hwnd)               (AVICapSM(hwnd, WM_CAP_GET_USER_DATA, 0, 0))

#define capDriverConnect(hwnd, i)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_CONNECT, (WPARAM)(i), 0L))
#define capDriverDisconnect(hwnd)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_DISCONNECT, (WPARAM)0, 0L))
#define capDriverGetName(hwnd, szName, wSize)      ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_NAME, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capDriverGetVersion(hwnd, szVer, wSize)    ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_VERSION, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szVer)))
#define capDriverGetCaps(hwnd, s, wSize)           ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_CAPS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPDRIVERCAPS)(s)))

#define capFileSetCaptureFile(hwnd, szName)        ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_CAPTURE_FILE, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileGetCaptureFile(hwnd, szName, wSize) ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_GET_CAPTURE_FILE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileAlloc(hwnd, dwSize)                 ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_ALLOCATE, 0, (LPARAM)(DWORD)(dwSize)))
#define capFileSaveAs(hwnd, szName)                ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEAS, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileSetInfoChunk(hwnd, lpInfoChunk)     ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_INFOCHUNK, (WPARAM)0, (LPARAM)(LPCAPINFOCHUNK)(lpInfoChunk)))
#define capFileSaveDIB(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEDIB, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))

#define capEditCopy(hwnd)                          ((BOOL)AVICapSM(hwnd, WM_CAP_EDIT_COPY, 0, 0L))

#define capSetAudioFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormatSize(hwnd)                ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)0, (LPARAM)0L))

#define capDlgVideoFormat(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOFORMAT, 0, 0L))
#define capDlgVideoSource(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOSOURCE, 0, 0L))
#define capDlgVideoDisplay(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEODISPLAY, 0, 0L))
#define capDlgVideoCompression(hwnd)               ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOCOMPRESSION, 0, 0L))

#define capGetVideoFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))
#define capGetVideoFormatSize(hwnd)            ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, 0, 0L))
#define capSetVideoFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))

#define capPreview(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEW, (WPARAM)(BOOL)(f), 0L))
#define capPreviewRate(hwnd, wMS)                  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEWRATE, (WPARAM)(wMS), 0))
#define capOverlay(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_OVERLAY, (WPARAM)(BOOL)(f), 0L))
#define capPreviewScale(hwnd, f)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCALE, (WPARAM)(BOOL)f, 0L))
#define capGetStatus(hwnd, s, wSize)               ((BOOL)AVICapSM(hwnd, WM_CAP_GET_STATUS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPSTATUS)(s)))
#define capSetScrollPos(hwnd, lpP)                 ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCROLL, (WPARAM)0, (LPARAM)(LPPOINT)(lpP)))

#define capGrabFrame(hwnd)                         ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME, (WPARAM)0, (LPARAM)0L))
#define capGrabFrameNoStop(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME_NOSTOP, (WPARAM)0, (LPARAM)0L))

#define capCaptureSequence(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSequenceNoFile(hwnd)             ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE_NOFILE, (WPARAM)0, (LPARAM)0L))
#define capCaptureStop(hwnd)                       ((BOOL)AVICapSM(hwnd, WM_CAP_STOP, (WPARAM)0, (LPARAM)0L))
#define capCaptureAbort(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_ABORT, (WPARAM)0, (LPARAM)0L))

#define capCaptureSingleFrameOpen(hwnd)            ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_OPEN, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrameClose(hwnd)           ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_CLOSE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrame(hwnd)                ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME, (WPARAM)0, (LPARAM)0L))

#define capCaptureGetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_GET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))
#define capCaptureSetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))

#define capSetMCIDeviceName(hwnd, szName)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_MCI_DEVICE, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capGetMCIDeviceName(hwnd, szName, wSize)   ((BOOL)AVICapSM(hwnd, WM_CAP_GET_MCI_DEVICE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szName)))

#define capPaletteOpen(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_OPEN, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capPaletteSave(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_SAVE, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capPalettePaste(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_PASTE, (WPARAM) 0, (LPARAM)0L))
#define capPaletteAuto(hwnd, iFrames, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_AUTOCREATE, (WPARAM)(iFrames), (LPARAM)(DWORD)(iColors)))
#define capPaletteManual(hwnd, fGrab, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_MANUALCREATE, (WPARAM)(fGrab), (LPARAM)(DWORD)(iColors)))

// ------------------------------------------------------------------
//  Structures
// ------------------------------------------------------------------

typedef struct tagCapDriverCaps {
    UINT        wDeviceIndex;               // Driver index in system.ini
    BOOL        fHasOverlay;                // Can device overlay?
    BOOL        fHasDlgVideoSource;         // Has Video source dlg?
    BOOL        fHasDlgVideoFormat;         // Has Format dlg?
    BOOL        fHasDlgVideoDisplay;        // Has External out dlg?
    BOOL        fCaptureInitialized;        // Driver ready to capture?
    BOOL        fDriverSuppliesPalettes;    // Can driver make palettes?

// following always NULL on Win32.
    HANDLE      hVideoIn;                   // Driver In channel
    HANDLE      hVideoOut;                  // Driver Out channel
    HANDLE      hVideoExtIn;                // Driver Ext In channel
    HANDLE      hVideoExtOut;               // Driver Ext Out channel
} CAPDRIVERCAPS, *PCAPDRIVERCAPS, FAR *LPCAPDRIVERCAPS;

typedef struct tagCapStatus {
    UINT        uiImageWidth;               // Width of the image
    UINT        uiImageHeight;              // Height of the image
    BOOL        fLiveWindow;                // Now Previewing video?
    BOOL        fOverlayWindow;             // Now Overlaying video?
    BOOL        fScale;                     // Scale image to client?
    POINT       ptScroll;                   // Scroll position
    BOOL        fUsingDefaultPalette;       // Using default driver palette?
    BOOL        fAudioHardware;             // Audio hardware present?
    BOOL        fCapFileExists;             // Does capture file exist?
    DWORD       dwCurrentVideoFrame;        // # of video frames cap'td
    DWORD       dwCurrentVideoFramesDropped;// # of video frames dropped
    DWORD       dwCurrentWaveSamples;       // # of wave samples cap'td
    DWORD       dwCurrentTimeElapsedMS;     // Elapsed capture duration
    HPALETTE    hPalCurrent;                // Current palette in use
    BOOL        fCapturingNow;              // Capture in progress?
    DWORD       dwReturn;                   // Error value after any operation
    UINT        wNumVideoAllocated;         // Actual number of video buffers
    UINT        wNumAudioAllocated;         // Actual number of audio buffers
} CAPSTATUS, *PCAPSTATUS, FAR *LPCAPSTATUS;

                                            // Default values in parenthesis
typedef struct tagCaptureParms {
    DWORD       dwRequestMicroSecPerFrame;  // Requested capture rate
    BOOL        fMakeUserHitOKToCapture;    // Show "Hit OK to cap" dlg?
    UINT        wPercentDropForError;       // Give error msg if > (10%)
    BOOL        fYield;                     // Capture via background task?
    DWORD       dwIndexSize;                // Max index size in frames (32K)
    UINT        wChunkGranularity;          // Junk chunk granularity (2K)
    BOOL        fUsingDOSMemory;            // Use DOS buffers?
    UINT        wNumVideoRequested;         // # video buffers, If 0, autocalc
    BOOL        fCaptureAudio;              // Capture audio?
    UINT        wNumAudioRequested;         // # audio buffers, If 0, autocalc
    UINT        vKeyAbort;                  // Virtual key causing abort
    BOOL        fAbortLeftMouse;            // Abort on left mouse?
    BOOL        fAbortRightMouse;           // Abort on right mouse?
    BOOL        fLimitEnabled;              // Use wTimeLimit?
    UINT        wTimeLimit;                 // Seconds to capture
    BOOL        fMCIControl;                // Use MCI video source?
    BOOL        fStepMCIDevice;             // Step MCI device?
    DWORD       dwMCIStartTime;             // Time to start in MS
    DWORD       dwMCIStopTime;              // Time to stop in MS
    BOOL        fStepCaptureAt2x;           // Perform spatial averaging 2x
    UINT        wStepCaptureAverageFrames;  // Temporal average n Frames
    DWORD       dwAudioBufferSize;          // Size of audio bufs (0 = default)
    BOOL        fDisableWriteCache;         // Attempt to disable write cache
    UINT        AVStreamMaster;             // Which stream controls length?
} CAPTUREPARMS, *PCAPTUREPARMS, FAR *LPCAPTUREPARMS;

// ------------------------------------------------------------------
//  AVStreamMaster
//  Since Audio and Video streams generally use non-synchronized capture
//  clocks, this flag determines whether the audio stream is to be considered
//  the master or controlling clock when writing the AVI file:
//
//  AVSTREAMMASTER_AUDIO  - Audio is master, video frame duration is forced
//                          to match audio duration (VFW 1.0, 1.1 default)
//  AVSTREAMMASTER_NONE   - No master, audio and video streams may be of
//                          different lengths
// ------------------------------------------------------------------
#define AVSTREAMMASTER_AUDIO            0 /* Audio master (VFW 1.0, 1.1) */
#define AVSTREAMMASTER_NONE             1 /* No master */

typedef struct tagCapInfoChunk {
    FOURCC      fccInfoID;                  // Chunk ID, "ICOP" for copyright
    LPVOID      lpData;                     // pointer to data
    LONG        cbData;                     // size of lpData
} CAPINFOCHUNK, *PCAPINFOCHUNK, FAR *LPCAPINFOCHUNK;


// ------------------------------------------------------------------
//  Callback Definitions
// ------------------------------------------------------------------

typedef LRESULT (CALLBACK* CAPYIELDCALLBACK)  (__in HWND hWnd);
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACKW) (__in HWND hWnd, __in int nID, LPCWSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACKW)  (__in HWND hWnd, __in int nID, LPCWSTR lpsz);
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACKA) (__in HWND hWnd, __in int nID, LPCSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACKA)  (__in HWND hWnd, __in int nID, LPCSTR lpsz);
#ifdef UNICODE
#define CAPSTATUSCALLBACK  CAPSTATUSCALLBACKW
#define CAPERRORCALLBACK   CAPERRORCALLBACKW
#else
#define CAPSTATUSCALLBACK  CAPSTATUSCALLBACKA
#define CAPERRORCALLBACK   CAPERRORCALLBACKA
#endif
typedef LRESULT (CALLBACK* CAPVIDEOCALLBACK)  (__in HWND hWnd, __in LPVIDEOHDR lpVHdr);
typedef LRESULT (CALLBACK* CAPWAVECALLBACK)   (__in HWND hWnd, __in LPWAVEHDR lpWHdr);
typedef LRESULT (CALLBACK* CAPCONTROLCALLBACK)(__in HWND hWnd, __in int nState);

// ------------------------------------------------------------------
//  CapControlCallback states
// ------------------------------------------------------------------
#define CONTROLCALLBACK_PREROLL         1 /* Waiting to start capture */
#define CONTROLCALLBACK_CAPTURING       2 /* Now capturing */

// ------------------------------------------------------------------
//  The only exported functions from AVICAP.DLL
// ------------------------------------------------------------------

HWND VFWAPI capCreateCaptureWindowA (
        LPCSTR lpszWindowName,
        __in DWORD dwStyle,
        __in int x, __in int y, __in int nWidth, __in int nHeight,
        __in_opt HWND hwndParent, __in int nID);

BOOL VFWAPI capGetDriverDescriptionA (UINT wDriverIndex,
        __out_ecount(cbName) LPSTR lpszName, __in int cbName,
        __out_ecount(cbVer) LPSTR lpszVer, __in int cbVer);

HWND VFWAPI capCreateCaptureWindowW (
        LPCWSTR lpszWindowName,
        DWORD dwStyle,
        __in int x, __in int y, __in int nWidth, __in int nHeight,
        __in_opt HWND hwndParent, __in int nID);

BOOL VFWAPI capGetDriverDescriptionW (UINT wDriverIndex,
        __out_ecount(cbName) LPWSTR lpszName, __in int cbName,
        __out_ecount(cbVer) LPWSTR lpszVer, __in int cbVer);
#ifdef UNICODE
#define capCreateCaptureWindow  capCreateCaptureWindowW
#define capGetDriverDescription capGetDriverDescriptionW
#else
#define capCreateCaptureWindow  capCreateCaptureWindowA
#define capGetDriverDescription capGetDriverDescriptionA
#endif

#endif  /* RC_INVOKED */

// ------------------------------------------------------------------
// New Information chunk IDs
// ------------------------------------------------------------------
#define infotypeDIGITIZATION_TIME  mmioFOURCC ('I','D','I','T')
#define infotypeSMPTE_TIME         mmioFOURCC ('I','S','M','P')

// ------------------------------------------------------------------
// String IDs from status and error callbacks
// ------------------------------------------------------------------

#define IDS_CAP_BEGIN               300  /* "Capture Start" */
#define IDS_CAP_END                 301  /* "Capture End" */

#define IDS_CAP_INFO                401  /* "%s" */
#define IDS_CAP_OUTOFMEM            402  /* "Out of memory" */
#define IDS_CAP_FILEEXISTS          403  /* "File '%s' exists -- overwrite it?" */
#define IDS_CAP_ERRORPALOPEN        404  /* "Error opening palette '%s'" */
#define IDS_CAP_ERRORPALSAVE        405  /* "Error saving palette '%s'" */
#define IDS_CAP_ERRORDIBSAVE        406  /* "Error saving frame '%s'" */
#define IDS_CAP_DEFAVIEXT           407  /* "avi" */
#define IDS_CAP_DEFPALEXT           408  /* "pal" */
#define IDS_CAP_CANTOPEN            409  /* "Cannot open '%s'" */
#define IDS_CAP_SEQ_MSGSTART        410  /* "Select OK to start capture\nof video sequence\nto %s." */
#define IDS_CAP_SEQ_MSGSTOP         411  /* "Hit ESCAPE or click to end capture" */

#define IDS_CAP_VIDEDITERR          412  /* "An error occurred while trying to run VidEdit." */
#define IDS_CAP_READONLYFILE        413  /* "The file '%s' is a read-only file." */
#define IDS_CAP_WRITEERROR          414  /* "Unable to write to file '%s'.\nDisk may be full." */
#define IDS_CAP_NODISKSPACE         415  /* "There is no space to create a capture file on the specified device." */
#define IDS_CAP_SETFILESIZE         416  /* "Set File Size" */
#define IDS_CAP_SAVEASPERCENT       417  /* "SaveAs: %2ld%%  Hit Escape to abort." */

#define IDS_CAP_DRIVER_ERROR        418  /* Driver specific error message */

#define IDS_CAP_WAVE_OPEN_ERROR     419  /* "Error: Cannot open the wave input device.\nCheck sample size, frequency, and channels." */
#define IDS_CAP_WAVE_ALLOC_ERROR    420  /* "Error: Out of memory for wave buffers." */
#define IDS_CAP_WAVE_PREPARE_ERROR  421  /* "Error: Cannot prepare wave buffers." */
#define IDS_CAP_WAVE_ADD_ERROR      422  /* "Error: Cannot add wave buffers." */
#define IDS_CAP_WAVE_SIZE_ERROR     423  /* "Error: Bad wave size." */

#define IDS_CAP_VIDEO_OPEN_ERROR    424  /* "Error: Cannot open the video input device." */
#define IDS_CAP_VIDEO_ALLOC_ERROR   425  /* "Error: Out of memory for video buffers." */
#define IDS_CAP_VIDEO_PREPARE_ERROR 426  /* "Error: Cannot prepare video buffers." */
#define IDS_CAP_VIDEO_ADD_ERROR     427  /* "Error: Cannot add video buffers." */
#define IDS_CAP_VIDEO_SIZE_ERROR    428  /* "Error: Bad video size." */

#define IDS_CAP_FILE_OPEN_ERROR     429  /* "Error: Cannot open capture file." */
#define IDS_CAP_FILE_WRITE_ERROR    430  /* "Error: Cannot write to capture file.  Disk may be full." */
#define IDS_CAP_RECORDING_ERROR     431  /* "Error: Cannot write to capture file.  Data rate too high or disk full." */
#define IDS_CAP_RECORDING_ERROR2    432  /* "Error while recording" */
#define IDS_CAP_AVI_INIT_ERROR      433  /* "Error: Unable to initialize for capture." */
#define IDS_CAP_NO_FRAME_CAP_ERROR  434  /* "Warning: No frames captured.\nConfirm that vertical sync interrupts\nare configured and enabled." */
#define IDS_CAP_NO_PALETTE_WARN     435  /* "Warning: Using default palette." */
#define IDS_CAP_MCI_CONTROL_ERROR   436  /* "Error: Unable to access MCI device." */
#define IDS_CAP_MCI_CANT_STEP_ERROR 437  /* "Error: Unable to step MCI device." */
#define IDS_CAP_NO_AUDIO_CAP_ERROR  438  /* "Error: No audio data captured.\nCheck audio card settings." */
#define IDS_CAP_AVI_DRAWDIB_ERROR   439  /* "Error: Unable to draw this data format." */
#define IDS_CAP_COMPRESSOR_ERROR    440  /* "Error: Unable to initialize compressor." */
#define IDS_CAP_AUDIO_DROP_ERROR    441  /* "Error: Audio data was lost during capture, reduce capture rate." */
#define IDS_CAP_AUDIO_DROP_COMPERROR 442  /* "Error: Audio data was lost during capture.  Try capturing without compressing." */

/* status string IDs */
#define IDS_CAP_STAT_LIVE_MODE      500  /* "Live window" */
#define IDS_CAP_STAT_OVERLAY_MODE   501  /* "Overlay window" */
#define IDS_CAP_STAT_CAP_INIT       502  /* "Setting up for capture - Please wait" */
#define IDS_CAP_STAT_CAP_FINI       503  /* "Finished capture, now writing frame %ld" */
#define IDS_CAP_STAT_PALETTE_BUILD  504  /* "Building palette map" */
#define IDS_CAP_STAT_OPTPAL_BUILD   505  /* "Computing optimal palette" */
#define IDS_CAP_STAT_I_FRAMES       506  /* "%d frames" */
#define IDS_CAP_STAT_L_FRAMES       507  /* "%ld frames" */
#define IDS_CAP_STAT_CAP_L_FRAMES   508  /* "Captured %ld frames" */
#define IDS_CAP_STAT_CAP_AUDIO      509  /* "Capturing audio" */
#define IDS_CAP_STAT_VIDEOCURRENT   510  /* "Captured %ld frames (%ld dropped) %d.%03d sec." */
#define IDS_CAP_STAT_VIDEOAUDIO     511  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps).  %ld audio bytes (%d,%03d sps)" */
#define IDS_CAP_STAT_VIDEOONLY      512  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps)" */
#define IDS_CAP_STAT_FRAMESDROPPED  513  /* "Dropped %ld of %ld frames (%d.%02d%%) during capture." */
#endif  /* NOAVIFILE */

#ifdef __cplusplus
} // extern "C"
#endif  /* __cplusplus */

/****************************************************************************
 *
 *  ACM (Audio compression manager)
 *
 ***************************************************************************/

#ifndef NOMSACM
    #include <msacm.h>
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****************************************************************************
 *
 *  FilePreview dialog.
 *
 ***************************************************************************/
#ifdef OFN_READONLY

    BOOL
    VFWAPI
    GetOpenFileNamePreviewA(
        __inout LPOPENFILENAMEA lpofn
        );

    BOOL
    VFWAPI
    GetSaveFileNamePreviewA(
        __inout LPOPENFILENAMEA lpofn
        );

    BOOL
    VFWAPI
    GetOpenFileNamePreviewW(
        __inout LPOPENFILENAMEW lpofn
        );

    BOOL
    VFWAPI
    GetSaveFileNamePreviewW(
        __inout LPOPENFILENAMEW lpofn
        );

    #ifdef UNICODE
        #define GetOpenFileNamePreview          GetOpenFileNamePreviewW
        #define GetSaveFileNamePreview          GetSaveFileNamePreviewW
    #else
        #define GetOpenFileNamePreview          GetOpenFileNamePreviewA
        #define GetSaveFileNamePreview          GetSaveFileNamePreviewA
    #endif

#endif // OFN_READONLY

#ifndef RC_INVOKED
#include "poppack.h"
#endif

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_VFW */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vdshwprv.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vdshwprv.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vdshwprv_h__
#define __vdshwprv_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumVdsObject_FWD_DEFINED__
#define __IEnumVdsObject_FWD_DEFINED__
typedef interface IEnumVdsObject IEnumVdsObject;
#endif 	/* __IEnumVdsObject_FWD_DEFINED__ */


#ifndef __IVdsAsync_FWD_DEFINED__
#define __IVdsAsync_FWD_DEFINED__
typedef interface IVdsAsync IVdsAsync;
#endif 	/* __IVdsAsync_FWD_DEFINED__ */


#ifndef __IVdsAdviseSink_FWD_DEFINED__
#define __IVdsAdviseSink_FWD_DEFINED__
typedef interface IVdsAdviseSink IVdsAdviseSink;
#endif 	/* __IVdsAdviseSink_FWD_DEFINED__ */


#ifndef __IVdsProvider_FWD_DEFINED__
#define __IVdsProvider_FWD_DEFINED__
typedef interface IVdsProvider IVdsProvider;
#endif 	/* __IVdsProvider_FWD_DEFINED__ */


#ifndef __IVdsProviderSupport_FWD_DEFINED__
#define __IVdsProviderSupport_FWD_DEFINED__
typedef interface IVdsProviderSupport IVdsProviderSupport;
#endif 	/* __IVdsProviderSupport_FWD_DEFINED__ */


#ifndef __IVdsProviderPrivate_FWD_DEFINED__
#define __IVdsProviderPrivate_FWD_DEFINED__
typedef interface IVdsProviderPrivate IVdsProviderPrivate;
#endif 	/* __IVdsProviderPrivate_FWD_DEFINED__ */


#ifndef __IVdsHwProvider_FWD_DEFINED__
#define __IVdsHwProvider_FWD_DEFINED__
typedef interface IVdsHwProvider IVdsHwProvider;
#endif 	/* __IVdsHwProvider_FWD_DEFINED__ */


#ifndef __IVdsHwProviderType_FWD_DEFINED__
#define __IVdsHwProviderType_FWD_DEFINED__
typedef interface IVdsHwProviderType IVdsHwProviderType;
#endif 	/* __IVdsHwProviderType_FWD_DEFINED__ */


#ifndef __IVdsHwProviderType2_FWD_DEFINED__
#define __IVdsHwProviderType2_FWD_DEFINED__
typedef interface IVdsHwProviderType2 IVdsHwProviderType2;
#endif 	/* __IVdsHwProviderType2_FWD_DEFINED__ */


#ifndef __IVdsHwProviderStoragePools_FWD_DEFINED__
#define __IVdsHwProviderStoragePools_FWD_DEFINED__
typedef interface IVdsHwProviderStoragePools IVdsHwProviderStoragePools;
#endif 	/* __IVdsHwProviderStoragePools_FWD_DEFINED__ */


#ifndef __IVdsSubSystem_FWD_DEFINED__
#define __IVdsSubSystem_FWD_DEFINED__
typedef interface IVdsSubSystem IVdsSubSystem;
#endif 	/* __IVdsSubSystem_FWD_DEFINED__ */


#ifndef __IVdsSubSystem2_FWD_DEFINED__
#define __IVdsSubSystem2_FWD_DEFINED__
typedef interface IVdsSubSystem2 IVdsSubSystem2;
#endif 	/* __IVdsSubSystem2_FWD_DEFINED__ */


#ifndef __IVdsSubSystemNaming_FWD_DEFINED__
#define __IVdsSubSystemNaming_FWD_DEFINED__
typedef interface IVdsSubSystemNaming IVdsSubSystemNaming;
#endif 	/* __IVdsSubSystemNaming_FWD_DEFINED__ */


#ifndef __IVdsSubSystemIscsi_FWD_DEFINED__
#define __IVdsSubSystemIscsi_FWD_DEFINED__
typedef interface IVdsSubSystemIscsi IVdsSubSystemIscsi;
#endif 	/* __IVdsSubSystemIscsi_FWD_DEFINED__ */


#ifndef __IVdsSubSystemInterconnect_FWD_DEFINED__
#define __IVdsSubSystemInterconnect_FWD_DEFINED__
typedef interface IVdsSubSystemInterconnect IVdsSubSystemInterconnect;
#endif 	/* __IVdsSubSystemInterconnect_FWD_DEFINED__ */


#ifndef __IVdsControllerPort_FWD_DEFINED__
#define __IVdsControllerPort_FWD_DEFINED__
typedef interface IVdsControllerPort IVdsControllerPort;
#endif 	/* __IVdsControllerPort_FWD_DEFINED__ */


#ifndef __IVdsController_FWD_DEFINED__
#define __IVdsController_FWD_DEFINED__
typedef interface IVdsController IVdsController;
#endif 	/* __IVdsController_FWD_DEFINED__ */


#ifndef __IVdsControllerControllerPort_FWD_DEFINED__
#define __IVdsControllerControllerPort_FWD_DEFINED__
typedef interface IVdsControllerControllerPort IVdsControllerControllerPort;
#endif 	/* __IVdsControllerControllerPort_FWD_DEFINED__ */


#ifndef __IVdsDrive_FWD_DEFINED__
#define __IVdsDrive_FWD_DEFINED__
typedef interface IVdsDrive IVdsDrive;
#endif 	/* __IVdsDrive_FWD_DEFINED__ */


#ifndef __IVdsDrive2_FWD_DEFINED__
#define __IVdsDrive2_FWD_DEFINED__
typedef interface IVdsDrive2 IVdsDrive2;
#endif 	/* __IVdsDrive2_FWD_DEFINED__ */


#ifndef __IVdsLun_FWD_DEFINED__
#define __IVdsLun_FWD_DEFINED__
typedef interface IVdsLun IVdsLun;
#endif 	/* __IVdsLun_FWD_DEFINED__ */


#ifndef __IVdsLun2_FWD_DEFINED__
#define __IVdsLun2_FWD_DEFINED__
typedef interface IVdsLun2 IVdsLun2;
#endif 	/* __IVdsLun2_FWD_DEFINED__ */


#ifndef __IVdsLunNaming_FWD_DEFINED__
#define __IVdsLunNaming_FWD_DEFINED__
typedef interface IVdsLunNaming IVdsLunNaming;
#endif 	/* __IVdsLunNaming_FWD_DEFINED__ */


#ifndef __IVdsLunNumber_FWD_DEFINED__
#define __IVdsLunNumber_FWD_DEFINED__
typedef interface IVdsLunNumber IVdsLunNumber;
#endif 	/* __IVdsLunNumber_FWD_DEFINED__ */


#ifndef __IVdsLunControllerPorts_FWD_DEFINED__
#define __IVdsLunControllerPorts_FWD_DEFINED__
typedef interface IVdsLunControllerPorts IVdsLunControllerPorts;
#endif 	/* __IVdsLunControllerPorts_FWD_DEFINED__ */


#ifndef __IVdsLunMpio_FWD_DEFINED__
#define __IVdsLunMpio_FWD_DEFINED__
typedef interface IVdsLunMpio IVdsLunMpio;
#endif 	/* __IVdsLunMpio_FWD_DEFINED__ */


#ifndef __IVdsLunIscsi_FWD_DEFINED__
#define __IVdsLunIscsi_FWD_DEFINED__
typedef interface IVdsLunIscsi IVdsLunIscsi;
#endif 	/* __IVdsLunIscsi_FWD_DEFINED__ */


#ifndef __IVdsLunPlex_FWD_DEFINED__
#define __IVdsLunPlex_FWD_DEFINED__
typedef interface IVdsLunPlex IVdsLunPlex;
#endif 	/* __IVdsLunPlex_FWD_DEFINED__ */


#ifndef __IVdsIscsiPortal_FWD_DEFINED__
#define __IVdsIscsiPortal_FWD_DEFINED__
typedef interface IVdsIscsiPortal IVdsIscsiPortal;
#endif 	/* __IVdsIscsiPortal_FWD_DEFINED__ */


#ifndef __IVdsIscsiTarget_FWD_DEFINED__
#define __IVdsIscsiTarget_FWD_DEFINED__
typedef interface IVdsIscsiTarget IVdsIscsiTarget;
#endif 	/* __IVdsIscsiTarget_FWD_DEFINED__ */


#ifndef __IVdsIscsiPortalGroup_FWD_DEFINED__
#define __IVdsIscsiPortalGroup_FWD_DEFINED__
typedef interface IVdsIscsiPortalGroup IVdsIscsiPortalGroup;
#endif 	/* __IVdsIscsiPortalGroup_FWD_DEFINED__ */


#ifndef __IVdsStoragePool_FWD_DEFINED__
#define __IVdsStoragePool_FWD_DEFINED__
typedef interface IVdsStoragePool IVdsStoragePool;
#endif 	/* __IVdsStoragePool_FWD_DEFINED__ */


#ifndef __IVdsMaintenance_FWD_DEFINED__
#define __IVdsMaintenance_FWD_DEFINED__
typedef interface IVdsMaintenance IVdsMaintenance;
#endif 	/* __IVdsMaintenance_FWD_DEFINED__ */


#ifndef __IVdsHwProviderPrivate_FWD_DEFINED__
#define __IVdsHwProviderPrivate_FWD_DEFINED__
typedef interface IVdsHwProviderPrivate IVdsHwProviderPrivate;
#endif 	/* __IVdsHwProviderPrivate_FWD_DEFINED__ */


#ifndef __IVdsHwProviderPrivateMpio_FWD_DEFINED__
#define __IVdsHwProviderPrivateMpio_FWD_DEFINED__
typedef interface IVdsHwProviderPrivateMpio IVdsHwProviderPrivateMpio;
#endif 	/* __IVdsHwProviderPrivateMpio_FWD_DEFINED__ */


#ifndef __IVdsAdmin_FWD_DEFINED__
#define __IVdsAdmin_FWD_DEFINED__
typedef interface IVdsAdmin IVdsAdmin;
#endif 	/* __IVdsAdmin_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "vdserr.h"
#include "vdslun.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vdshwprv_0000_0000 */
/* [local] */ 

//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) 2000 Microsoft Corporation.
//
//---------------------------------------------------------------





typedef GUID VDS_OBJECT_ID;

typedef 
enum _VDS_OBJECT_TYPE
    {	VDS_OT_UNKNOWN	= 0,
	VDS_OT_PROVIDER	= 1,
	VDS_OT_PACK	= 10,
	VDS_OT_VOLUME	= 11,
	VDS_OT_VOLUME_PLEX	= 12,
	VDS_OT_DISK	= 13,
	VDS_OT_SUB_SYSTEM	= 30,
	VDS_OT_CONTROLLER	= 31,
	VDS_OT_DRIVE	= 32,
	VDS_OT_LUN	= 33,
	VDS_OT_LUN_PLEX	= 34,
	VDS_OT_PORT	= 35,
	VDS_OT_PORTAL	= 36,
	VDS_OT_TARGET	= 37,
	VDS_OT_PORTAL_GROUP	= 38,
	VDS_OT_STORAGE_POOL	= 39,
	VDS_OT_HBAPORT	= 90,
	VDS_OT_INIT_ADAPTER	= 91,
	VDS_OT_INIT_PORTAL	= 92,
	VDS_OT_ASYNC	= 100,
	VDS_OT_ENUM	= 101,
	VDS_OT_VDISK	= 200,
	VDS_OT_OPEN_VDISK	= 201
    } 	VDS_OBJECT_TYPE;

typedef 
enum _VDS_PROVIDER_TYPE
    {	VDS_PT_UNKNOWN	= 0,
	VDS_PT_SOFTWARE	= 1,
	VDS_PT_HARDWARE	= 2,
	VDS_PT_VIRTUALDISK	= 3,
	VDS_PT_MAX	= 4
    } 	VDS_PROVIDER_TYPE;

typedef 
enum _VDS_PROVIDER_FLAG
    {	VDS_PF_DYNAMIC	= 0x1,
	VDS_PF_INTERNAL_HARDWARE_PROVIDER	= 0x2,
	VDS_PF_ONE_DISK_ONLY_PER_PACK	= 0x4,
	VDS_PF_ONE_PACK_ONLINE_ONLY	= 0x8,
	VDS_PF_VOLUME_SPACE_MUST_BE_CONTIGUOUS	= 0x10,
	VDS_PF_SUPPORT_DYNAMIC	= 0x80000000,
	VDS_PF_SUPPORT_FAULT_TOLERANT	= 0x40000000,
	VDS_PF_SUPPORT_DYNAMIC_1394	= 0x20000000,
	VDS_PF_SUPPORT_MIRROR	= 0x20,
	VDS_PF_SUPPORT_RAID5	= 0x40
    } 	VDS_PROVIDER_FLAG;

typedef 
enum _VDS_RECOVER_ACTION
    {	VDS_RA_UNKNOWN	= 0,
	VDS_RA_REFRESH	= 1,
	VDS_RA_RESTART	= 2
    } 	VDS_RECOVER_ACTION;

typedef 
enum _VDS_NOTIFICATION_TARGET_TYPE
    {	VDS_NTT_UNKNOWN	= 0,
	VDS_NTT_PACK	= VDS_OT_PACK,
	VDS_NTT_VOLUME	= VDS_OT_VOLUME,
	VDS_NTT_DISK	= VDS_OT_DISK,
	VDS_NTT_PARTITION	= 60,
	VDS_NTT_DRIVE_LETTER	= 61,
	VDS_NTT_FILE_SYSTEM	= 62,
	VDS_NTT_MOUNT_POINT	= 63,
	VDS_NTT_SUB_SYSTEM	= VDS_OT_SUB_SYSTEM,
	VDS_NTT_CONTROLLER	= VDS_OT_CONTROLLER,
	VDS_NTT_DRIVE	= VDS_OT_DRIVE,
	VDS_NTT_LUN	= VDS_OT_LUN,
	VDS_NTT_PORT	= VDS_OT_PORT,
	VDS_NTT_PORTAL	= VDS_OT_PORTAL,
	VDS_NTT_TARGET	= VDS_OT_TARGET,
	VDS_NTT_PORTAL_GROUP	= VDS_OT_PORTAL_GROUP,
	VDS_NTT_SERVICE	= 200
    } 	VDS_NOTIFICATION_TARGET_TYPE;

#define	VDS_NF_PACK_ARRIVE	( 1 )

#define	VDS_NF_PACK_DEPART	( 2 )

#define	VDS_NF_PACK_MODIFY	( 3 )

#define	VDS_NF_VOLUME_ARRIVE	( 4 )

#define	VDS_NF_VOLUME_DEPART	( 5 )

#define	VDS_NF_VOLUME_MODIFY	( 6 )

#define	VDS_NF_VOLUME_REBUILDING_PROGRESS	( 7 )

#define	VDS_NF_DISK_ARRIVE	( 8 )

#define	VDS_NF_DISK_DEPART	( 9 )

#define	VDS_NF_DISK_MODIFY	( 10 )

#define	VDS_NF_PARTITION_ARRIVE	( 11 )

#define	VDS_NF_PARTITION_DEPART	( 12 )

#define	VDS_NF_PARTITION_MODIFY	( 13 )

#define	VDS_NF_SUB_SYSTEM_ARRIVE	( 101 )

#define	VDS_NF_SUB_SYSTEM_DEPART	( 102 )

#define	VDS_NF_CONTROLLER_ARRIVE	( 103 )

#define	VDS_NF_CONTROLLER_DEPART	( 104 )

#define	VDS_NF_DRIVE_ARRIVE	( 105 )

#define	VDS_NF_DRIVE_DEPART	( 106 )

#define	VDS_NF_DRIVE_MODIFY	( 107 )

#define	VDS_NF_LUN_ARRIVE	( 108 )

#define	VDS_NF_LUN_DEPART	( 109 )

#define	VDS_NF_LUN_MODIFY	( 110 )

#define	VDS_NF_PORT_ARRIVE	( 121 )

#define	VDS_NF_PORT_DEPART	( 122 )

#define	VDS_NF_PORTAL_ARRIVE	( 123 )

#define	VDS_NF_PORTAL_DEPART	( 124 )

#define	VDS_NF_PORTAL_MODIFY	( 125 )

#define	VDS_NF_TARGET_ARRIVE	( 126 )

#define	VDS_NF_TARGET_DEPART	( 127 )

#define	VDS_NF_TARGET_MODIFY	( 128 )

#define	VDS_NF_PORTAL_GROUP_ARRIVE	( 129 )

#define	VDS_NF_PORTAL_GROUP_DEPART	( 130 )

#define	VDS_NF_PORTAL_GROUP_MODIFY	( 131 )

#define	VDS_NF_SUB_SYSTEM_MODIFY	( 151 )

#define	VDS_NF_DRIVE_LETTER_FREE	( 201 )

#define	VDS_NF_DRIVE_LETTER_ASSIGN	( 202 )

#define	VDS_NF_FILE_SYSTEM_MODIFY	( 203 )

#define	VDS_NF_FILE_SYSTEM_FORMAT_PROGRESS	( 204 )

#define	VDS_NF_MOUNT_POINTS_CHANGE	( 205 )

#define	VDS_NF_FILE_SYSTEM_SHRINKING_PROGRESS	( 206 )

#define	VDS_NF_SERVICE_OUT_OF_SYNC	( 301 )

#define	VDS_NF_CONTROLLER_MODIFY	( 350 )

#define	VDS_NF_CONTROLLER_REMOVED	( 351 )

#define	VDS_NF_PORT_MODIFY	( 352 )

#define	VDS_NF_PORT_REMOVED	( 353 )

#define	VDS_NF_DRIVE_REMOVED	( 354 )

typedef struct _VDS_PACK_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID packId;
    } 	VDS_PACK_NOTIFICATION;

typedef struct _VDS_DISK_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID diskId;
    } 	VDS_DISK_NOTIFICATION;

typedef struct _VDS_VOLUME_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID volumeId;
    VDS_OBJECT_ID plexId;
    ULONG ulPercentCompleted;
    } 	VDS_VOLUME_NOTIFICATION;

typedef struct _VDS_PARTITION_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID diskId;
    ULONGLONG ullOffset;
    } 	VDS_PARTITION_NOTIFICATION;

typedef struct _VDS_SERVICE_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_RECOVER_ACTION action;
    } 	VDS_SERVICE_NOTIFICATION;

typedef struct _VDS_DRIVE_LETTER_NOTIFICATION
    {
    ULONG ulEvent;
    WCHAR wcLetter;
    VDS_OBJECT_ID volumeId;
    } 	VDS_DRIVE_LETTER_NOTIFICATION;

typedef struct _VDS_FILE_SYSTEM_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID volumeId;
    DWORD dwPercentCompleted;
    } 	VDS_FILE_SYSTEM_NOTIFICATION;

typedef struct _VDS_MOUNT_POINT_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID volumeId;
    } 	VDS_MOUNT_POINT_NOTIFICATION;

typedef struct _VDS_SUB_SYSTEM_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID subSystemId;
    } 	VDS_SUB_SYSTEM_NOTIFICATION;

typedef struct _VDS_CONTROLLER_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID controllerId;
    } 	VDS_CONTROLLER_NOTIFICATION;

typedef struct _VDS_DRIVE_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID driveId;
    } 	VDS_DRIVE_NOTIFICATION;

typedef struct _VDS_LUN_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID LunId;
    } 	VDS_LUN_NOTIFICATION;

typedef struct _VDS_PORT_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID portId;
    } 	VDS_PORT_NOTIFICATION;

typedef struct _VDS_PORTAL_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID portalId;
    } 	VDS_PORTAL_NOTIFICATION;

typedef struct _VDS_TARGET_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID targetId;
    } 	VDS_TARGET_NOTIFICATION;

typedef struct _VDS_PORTAL_GROUP_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID portalGroupId;
    } 	VDS_PORTAL_GROUP_NOTIFICATION;

typedef struct _VDS_NOTIFICATION
    {
    VDS_NOTIFICATION_TARGET_TYPE objectType;
    /* [switch_type] */ union 
        {
        VDS_PACK_NOTIFICATION Pack;
        VDS_DISK_NOTIFICATION Disk;
        VDS_VOLUME_NOTIFICATION Volume;
        VDS_PARTITION_NOTIFICATION Partition;
        VDS_DRIVE_LETTER_NOTIFICATION Letter;
        VDS_FILE_SYSTEM_NOTIFICATION FileSystem;
        VDS_MOUNT_POINT_NOTIFICATION MountPoint;
        VDS_SUB_SYSTEM_NOTIFICATION SubSystem;
        VDS_CONTROLLER_NOTIFICATION Controller;
        VDS_DRIVE_NOTIFICATION Drive;
        VDS_LUN_NOTIFICATION Lun;
        VDS_PORT_NOTIFICATION Port;
        VDS_PORTAL_NOTIFICATION Portal;
        VDS_TARGET_NOTIFICATION Target;
        VDS_PORTAL_GROUP_NOTIFICATION PortalGroup;
        VDS_SERVICE_NOTIFICATION Service;
         /* Empty union arm */ 
        } 	;
    } 	VDS_NOTIFICATION;

typedef 
enum _VDS_ASYNC_OUTPUT_TYPE
    {	VDS_ASYNCOUT_UNKNOWN	= 0,
	VDS_ASYNCOUT_CREATEVOLUME	= 1,
	VDS_ASYNCOUT_EXTENDVOLUME	= 2,
	VDS_ASYNCOUT_SHRINKVOLUME	= 3,
	VDS_ASYNCOUT_ADDVOLUMEPLEX	= 4,
	VDS_ASYNCOUT_BREAKVOLUMEPLEX	= 5,
	VDS_ASYNCOUT_REMOVEVOLUMEPLEX	= 6,
	VDS_ASYNCOUT_REPAIRVOLUMEPLEX	= 7,
	VDS_ASYNCOUT_RECOVERPACK	= 8,
	VDS_ASYNCOUT_REPLACEDISK	= 9,
	VDS_ASYNCOUT_CREATEPARTITION	= 10,
	VDS_ASYNCOUT_CLEAN	= 11,
	VDS_ASYNCOUT_CREATELUN	= 50,
	VDS_ASYNCOUT_ADDLUNPLEX	= 52,
	VDS_ASYNCOUT_REMOVELUNPLEX	= 53,
	VDS_ASYNCOUT_EXTENDLUN	= 54,
	VDS_ASYNCOUT_SHRINKLUN	= 55,
	VDS_ASYNCOUT_RECOVERLUN	= 56,
	VDS_ASYNCOUT_LOGINTOTARGET	= 60,
	VDS_ASYNCOUT_LOGOUTFROMTARGET	= 61,
	VDS_ASYNCOUT_CREATETARGET	= 62,
	VDS_ASYNCOUT_CREATEPORTALGROUP	= 63,
	VDS_ASYNCOUT_DELETETARGET	= 64,
	VDS_ASYNCOUT_ADDPORTAL	= 65,
	VDS_ASYNCOUT_REMOVEPORTAL	= 66,
	VDS_ASYNCOUT_DELETEPORTALGROUP	= 67,
	VDS_ASYNCOUT_FORMAT	= 101,
	VDS_ASYNCOUT_CREATE_VDISK	= 200,
	VDS_ASYNCOUT_ATTACH_VDISK	= 201,
	VDS_ASYNCOUT_COMPACT_VDISK	= 202,
	VDS_ASYNCOUT_MERGE_VDISK	= 203,
	VDS_ASYNCOUT_EXPAND_VDISK	= 204
    } 	VDS_ASYNC_OUTPUT_TYPE;

typedef struct _VDS_ASYNC_OUTPUT
    {
    VDS_ASYNC_OUTPUT_TYPE type;
    /* [switch_type] */ union 
        {
        struct _cp
            {
            ULONGLONG ullOffset;
            VDS_OBJECT_ID volumeId;
            } 	cp;
        struct _cv
            {
            IUnknown *pVolumeUnk;
            } 	cv;
        struct _bvp
            {
            IUnknown *pVolumeUnk;
            } 	bvp;
        struct _sv
            {
            ULONGLONG ullReclaimedBytes;
            } 	sv;
        struct _cl
            {
            IUnknown *pLunUnk;
            } 	cl;
        struct _ct
            {
            IUnknown *pTargetUnk;
            } 	ct;
        struct _cpg
            {
            IUnknown *pPortalGroupUnk;
            } 	cpg;
        struct _cvd
            {
            IUnknown *pVDiskUnk;
            } 	cvd;
         /* Empty union arm */ 
        } 	;
    } 	VDS_ASYNC_OUTPUT;

typedef USHORT VDS_ISCSI_PORTALGROUP_TAG;

typedef 
enum VDS_IPADDRESS_TYPE
    {	VDS_IPT_TEXT	= 0,
	VDS_IPT_IPV4	= 1,
	VDS_IPT_IPV6	= 2,
	VDS_IPT_EMPTY	= 3
    } 	VDS_IPADDRESS_TYPE;

typedef 
enum _VDS_HEALTH
    {	VDS_H_UNKNOWN	= 0,
	VDS_H_HEALTHY	= 1,
	VDS_H_REBUILDING	= 2,
	VDS_H_STALE	= 3,
	VDS_H_FAILING	= 4,
	VDS_H_FAILING_REDUNDANCY	= 5,
	VDS_H_FAILED_REDUNDANCY	= 6,
	VDS_H_FAILED_REDUNDANCY_FAILING	= 7,
	VDS_H_FAILED	= 8,
	VDS_H_REPLACED	= 9,
	VDS_H_PENDING_FAILURE	= 10,
	VDS_H_DEGRADED	= 11
    } 	VDS_HEALTH;

typedef 
enum _VDS_TRANSITION_STATE
    {	VDS_TS_UNKNOWN	= 0,
	VDS_TS_STABLE	= 1,
	VDS_TS_EXTENDING	= 2,
	VDS_TS_SHRINKING	= 3,
	VDS_TS_RECONFIGING	= 4,
	VDS_TS_RESTRIPING	= 5
    } 	VDS_TRANSITION_STATE;

typedef 
enum _VDS_FILE_SYSTEM_TYPE
    {	VDS_FST_UNKNOWN	= 0,
	VDS_FST_RAW	= ( VDS_FST_UNKNOWN + 1 ) ,
	VDS_FST_FAT	= ( VDS_FST_RAW + 1 ) ,
	VDS_FST_FAT32	= ( VDS_FST_FAT + 1 ) ,
	VDS_FST_NTFS	= ( VDS_FST_FAT32 + 1 ) ,
	VDS_FST_CDFS	= ( VDS_FST_NTFS + 1 ) ,
	VDS_FST_UDF	= ( VDS_FST_CDFS + 1 ) ,
	VDS_FST_EXFAT	= ( VDS_FST_UDF + 1 ) 
    } 	VDS_FILE_SYSTEM_TYPE;

typedef 
enum _VDS_HBAPORT_TYPE
    {	VDS_HPT_UNKNOWN	= 1,
	VDS_HPT_OTHER	= 2,
	VDS_HPT_NOTPRESENT	= 3,
	VDS_HPT_NPORT	= 5,
	VDS_HPT_NLPORT	= 6,
	VDS_HPT_FLPORT	= 7,
	VDS_HPT_FPORT	= 8,
	VDS_HPT_EPORT	= 9,
	VDS_HPT_GPORT	= 10,
	VDS_HPT_LPORT	= 20,
	VDS_HPT_PTP	= 21
    } 	VDS_HBAPORT_TYPE;

typedef 
enum _VDS_HBAPORT_STATUS
    {	VDS_HPS_UNKNOWN	= 1,
	VDS_HPS_ONLINE	= 2,
	VDS_HPS_OFFLINE	= 3,
	VDS_HPS_BYPASSED	= 4,
	VDS_HPS_DIAGNOSTICS	= 5,
	VDS_HPS_LINKDOWN	= 6,
	VDS_HPS_ERROR	= 7,
	VDS_HPS_LOOPBACK	= 8
    } 	VDS_HBAPORT_STATUS;

typedef 
enum _VDS_HBAPORT_SPEED_FLAG
    {	VDS_HSF_UNKNOWN	= 0,
	VDS_HSF_1GBIT	= 0x1,
	VDS_HSF_2GBIT	= 0x2,
	VDS_HSF_10GBIT	= 0x4,
	VDS_HSF_4GBIT	= 0x8,
	VDS_HSF_NOT_NEGOTIATED	= ( 1 << 15 ) 
    } 	VDS_HBAPORT_SPEED_FLAG;

typedef 
enum _VDS_PATH_STATUS
    {	VDS_MPS_UNKNOWN	= 0,
	VDS_MPS_ONLINE	= 1,
	VDS_MPS_FAILED	= 5,
	VDS_MPS_STANDBY	= 7
    } 	VDS_PATH_STATUS;

typedef 
enum _VDS_LOADBALANCE_POLICY_ENUM
    {	VDS_LBP_UNKNOWN	= 0,
	VDS_LBP_FAILOVER	= 1,
	VDS_LBP_ROUND_ROBIN	= 2,
	VDS_LBP_ROUND_ROBIN_WITH_SUBSET	= 3,
	VDS_LBP_DYN_LEAST_QUEUE_DEPTH	= 4,
	VDS_LBP_WEIGHTED_PATHS	= 5,
	VDS_LBP_LEAST_BLOCKS	= 6,
	VDS_LBP_VENDOR_SPECIFIC	= 7
    } 	VDS_LOADBALANCE_POLICY_ENUM;

typedef 
enum _VDS_PROVIDER_LBSUPPORT_FLAG
    {	VDS_LBF_FAILOVER	= 0x1,
	VDS_LBF_ROUND_ROBIN	= 0x2,
	VDS_LBF_ROUND_ROBIN_WITH_SUBSET	= 0x4,
	VDS_LBF_DYN_LEAST_QUEUE_DEPTH	= 0x8,
	VDS_LBF_WEIGHTED_PATHS	= 0x10,
	VDS_LBF_LEAST_BLOCKS	= 0x20,
	VDS_LBF_VENDOR_SPECIFIC	= 0x40
    } 	VDS_PROVIDER_LBSUPPORT_FLAG;

typedef 
enum _VDS_VERSION_SUPPORT_FLAG
    {	VDS_VSF_1_0	= 0x1,
	VDS_VSF_1_1	= 0x2,
	VDS_VSF_2_0	= 0x4,
	VDS_VSF_2_1	= 0x8,
	VDS_VSF_3_0	= 0x10
    } 	VDS_VERSION_SUPPORT_FLAG;

typedef 
enum _VDS_HWPROVIDER_TYPE
    {	VDS_HWT_UNKNOWN	= 0,
	VDS_HWT_PCI_RAID	= 1,
	VDS_HWT_FIBRE_CHANNEL	= 2,
	VDS_HWT_ISCSI	= 3,
	VDS_HWT_SAS	= 4,
	VDS_HWT_HYBRID	= 5
    } 	VDS_HWPROVIDER_TYPE;

typedef 
enum _VDS_ISCSI_LOGIN_TYPE
    {	VDS_ILT_MANUAL	= 0,
	VDS_ILT_PERSISTENT	= 1,
	VDS_ILT_BOOT	= 2
    } 	VDS_ISCSI_LOGIN_TYPE;

typedef 
enum _VDS_ISCSI_AUTH_TYPE
    {	VDS_IAT_NONE	= 0,
	VDS_IAT_CHAP	= 1,
	VDS_IAT_MUTUAL_CHAP	= 2
    } 	VDS_ISCSI_AUTH_TYPE;

typedef 
enum _VDS_ISCSI_IPSEC_FLAG
    {	VDS_IIF_VALID	= 0x1,
	VDS_IIF_IKE	= 0x2,
	VDS_IIF_MAIN_MODE	= 0x4,
	VDS_IIF_AGGRESSIVE_MODE	= 0x8,
	VDS_IIF_PFS_ENABLE	= 0x10,
	VDS_IIF_TRANSPORT_MODE_PREFERRED	= 0x20,
	VDS_IIF_TUNNEL_MODE_PREFERRED	= 0x40
    } 	VDS_ISCSI_IPSEC_FLAG;

typedef 
enum _VDS_ISCSI_LOGIN_FLAG
    {	VDS_ILF_REQUIRE_IPSEC	= 0x1,
	VDS_ILF_MULTIPATH_ENABLED	= 0x2
    } 	VDS_ISCSI_LOGIN_FLAG;

typedef struct _VDS_PATH_ID
    {
    ULONGLONG ullSourceId;
    ULONGLONG ullPathId;
    } 	VDS_PATH_ID;

typedef struct _VDS_WWN
    {
    UCHAR rguchWwn[ 8 ];
    } 	VDS_WWN;

typedef struct _VDS_IPADDRESS
    {
    VDS_IPADDRESS_TYPE type;
    ULONG ipv4Address;
    UCHAR ipv6Address[ 16 ];
    ULONG ulIpv6FlowInfo;
    ULONG ulIpv6ScopeId;
    WCHAR wszTextAddress[ 257 ];
    ULONG ulPort;
    } 	VDS_IPADDRESS;

typedef struct _VDS_ISCSI_IPSEC_KEY
    {
    UCHAR *pKey;
    ULONG ulKeySize;
    } 	VDS_ISCSI_IPSEC_KEY;

typedef struct _VDS_ISCSI_SHARED_SECRET
    {
    UCHAR *pSharedSecret;
    ULONG ulSharedSecretSize;
    } 	VDS_ISCSI_SHARED_SECRET;

typedef struct _VDS_HBAPORT_PROP
    {
    VDS_OBJECT_ID id;
    VDS_WWN wwnNode;
    VDS_WWN wwnPort;
    VDS_HBAPORT_TYPE type;
    VDS_HBAPORT_STATUS status;
    ULONG ulPortSpeed;
    ULONG ulSupportedPortSpeed;
    } 	VDS_HBAPORT_PROP;

typedef struct _VDS_ISCSI_INITIATOR_ADAPTER_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszName;
    } 	VDS_ISCSI_INITIATOR_ADAPTER_PROP;

typedef struct _VDS_ISCSI_INITIATOR_PORTAL_PROP
    {
    VDS_OBJECT_ID id;
    VDS_IPADDRESS address;
    ULONG ulPortIndex;
    } 	VDS_ISCSI_INITIATOR_PORTAL_PROP;

typedef struct _VDS_PROVIDER_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszName;
    GUID guidVersionId;
    LPWSTR pwszVersion;
    VDS_PROVIDER_TYPE type;
    ULONG ulFlags;
    ULONG ulStripeSizeFlags;
    SHORT sRebuildPriority;
    } 	VDS_PROVIDER_PROP;

typedef struct _VDS_PATH_INFO
    {
    VDS_PATH_ID pathId;
    VDS_HWPROVIDER_TYPE type;
    VDS_PATH_STATUS status;
    /* [switch_type] */ union 
        {
        VDS_OBJECT_ID controllerPortId;
        VDS_OBJECT_ID targetPortalId;
         /* Empty union arm */ 
        } 	;
    /* [switch_type] */ union 
        {
        VDS_OBJECT_ID hbaPortId;
        VDS_OBJECT_ID initiatorAdapterId;
         /* Empty union arm */ 
        } 	;
    /* [switch_type] */ union 
        {
        VDS_HBAPORT_PROP *pHbaPortProp;
        VDS_IPADDRESS *pInitiatorPortalIpAddr;
         /* Empty union arm */ 
        } 	;
    } 	VDS_PATH_INFO;

typedef struct _VDS_PATH_POLICY
    {
    VDS_PATH_ID pathId;
    BOOL bPrimaryPath;
    ULONG ulWeight;
    } 	VDS_PATH_POLICY;



extern RPC_IF_HANDLE __MIDL_itf_vdshwprv_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdshwprv_0000_0000_v0_0_s_ifspec;

#ifndef __IEnumVdsObject_INTERFACE_DEFINED__
#define __IEnumVdsObject_INTERFACE_DEFINED__

/* interface IEnumVdsObject */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumVdsObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("118610b7-8d94-4030-b5b8-500889788e4e")
    IEnumVdsObject : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pcFetched) IUnknown **ppObjectArray,
            /* [out] */ __RPC__out ULONG *pcFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumVdsObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumVdsObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumVdsObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumVdsObject * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumVdsObject * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pcFetched) IUnknown **ppObjectArray,
            /* [out] */ __RPC__out ULONG *pcFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumVdsObject * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumVdsObject * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumVdsObject * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IEnumVdsObjectVtbl;

    interface IEnumVdsObject
    {
        CONST_VTBL struct IEnumVdsObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumVdsObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumVdsObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumVdsObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumVdsObject_Next(This,celt,ppObjectArray,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppObjectArray,pcFetched) ) 

#define IEnumVdsObject_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumVdsObject_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumVdsObject_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumVdsObject_INTERFACE_DEFINED__ */


#ifndef __IVdsAsync_INTERFACE_DEFINED__
#define __IVdsAsync_INTERFACE_DEFINED__

/* interface IVdsAsync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5d23b6d-5a55-4492-9889-397a3c2d2dbc")
    IVdsAsync : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Wait( 
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out VDS_ASYNC_OUTPUT *pAsyncOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out ULONG *pulPercentCompleted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsAsync * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in IVdsAsync * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Wait )( 
            __RPC__in IVdsAsync * This,
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out VDS_ASYNC_OUTPUT *pAsyncOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            __RPC__in IVdsAsync * This,
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out ULONG *pulPercentCompleted);
        
        END_INTERFACE
    } IVdsAsyncVtbl;

    interface IVdsAsync
    {
        CONST_VTBL struct IVdsAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAsync_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IVdsAsync_Wait(This,pHrResult,pAsyncOut)	\
    ( (This)->lpVtbl -> Wait(This,pHrResult,pAsyncOut) ) 

#define IVdsAsync_QueryStatus(This,pHrResult,pulPercentCompleted)	\
    ( (This)->lpVtbl -> QueryStatus(This,pHrResult,pulPercentCompleted) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAsync_INTERFACE_DEFINED__ */


#ifndef __IVdsAdviseSink_INTERFACE_DEFINED__
#define __IVdsAdviseSink_INTERFACE_DEFINED__

/* interface IVdsAdviseSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAdviseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8326cd1d-cf59-4936-b786-5efc08798e25")
    IVdsAdviseSink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnNotify( 
            /* [range][in] */ __RPC__in_range(1,100) LONG lNumberOfNotifications,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfNotifications) VDS_NOTIFICATION *pNotificationArray) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAdviseSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsAdviseSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsAdviseSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsAdviseSink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnNotify )( 
            __RPC__in IVdsAdviseSink * This,
            /* [range][in] */ __RPC__in_range(1,100) LONG lNumberOfNotifications,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfNotifications) VDS_NOTIFICATION *pNotificationArray);
        
        END_INTERFACE
    } IVdsAdviseSinkVtbl;

    interface IVdsAdviseSink
    {
        CONST_VTBL struct IVdsAdviseSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAdviseSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAdviseSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAdviseSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAdviseSink_OnNotify(This,lNumberOfNotifications,pNotificationArray)	\
    ( (This)->lpVtbl -> OnNotify(This,lNumberOfNotifications,pNotificationArray) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAdviseSink_INTERFACE_DEFINED__ */


#ifndef __IVdsProvider_INTERFACE_DEFINED__
#define __IVdsProvider_INTERFACE_DEFINED__

/* interface IVdsProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10c5e575-7984-4e81-a56b-431f5f92ae42")
    IVdsProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_PROVIDER_PROP *pProviderProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsProvider * This,
            /* [out] */ __RPC__out VDS_PROVIDER_PROP *pProviderProp);
        
        END_INTERFACE
    } IVdsProviderVtbl;

    interface IVdsProvider
    {
        CONST_VTBL struct IVdsProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsProvider_GetProperties(This,pProviderProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pProviderProp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsProvider_INTERFACE_DEFINED__ */


#ifndef __IVdsProviderSupport_INTERFACE_DEFINED__
#define __IVdsProviderSupport_INTERFACE_DEFINED__

/* interface IVdsProviderSupport */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsProviderSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1732be13-e8f9-4a03-bfbc-5f616aa66ce1")
    IVdsProviderSupport : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVersionSupport( 
            /* [out] */ __RPC__out ULONG *ulVersionSupport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsProviderSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsProviderSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsProviderSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsProviderSupport * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVersionSupport )( 
            __RPC__in IVdsProviderSupport * This,
            /* [out] */ __RPC__out ULONG *ulVersionSupport);
        
        END_INTERFACE
    } IVdsProviderSupportVtbl;

    interface IVdsProviderSupport
    {
        CONST_VTBL struct IVdsProviderSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsProviderSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsProviderSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsProviderSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsProviderSupport_GetVersionSupport(This,ulVersionSupport)	\
    ( (This)->lpVtbl -> GetVersionSupport(This,ulVersionSupport) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsProviderSupport_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vdshwprv_0000_0005 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_vdshwprv_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdshwprv_0000_0005_v0_0_s_ifspec;

#ifndef __IVdsProviderPrivate_INTERFACE_DEFINED__
#define __IVdsProviderPrivate_INTERFACE_DEFINED__

/* interface IVdsProviderPrivate */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsProviderPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11f3cd41-b7e8-48ff-9472-9dff018aa292")
    IVdsProviderPrivate : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ VDS_OBJECT_ID ObjectId,
            /* [in] */ VDS_OBJECT_TYPE type,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppObjectUnk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnLoad( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszMachineName,
            /* [in] */ __RPC__in_opt IUnknown *pCallbackObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnUnload( 
            /* [in] */ BOOL bForceUnload) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsProviderPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsProviderPrivate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsProviderPrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsProviderPrivate * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            __RPC__in IVdsProviderPrivate * This,
            /* [in] */ VDS_OBJECT_ID ObjectId,
            /* [in] */ VDS_OBJECT_TYPE type,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppObjectUnk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnLoad )( 
            __RPC__in IVdsProviderPrivate * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszMachineName,
            /* [in] */ __RPC__in_opt IUnknown *pCallbackObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnUnload )( 
            __RPC__in IVdsProviderPrivate * This,
            /* [in] */ BOOL bForceUnload);
        
        END_INTERFACE
    } IVdsProviderPrivateVtbl;

    interface IVdsProviderPrivate
    {
        CONST_VTBL struct IVdsProviderPrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsProviderPrivate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsProviderPrivate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsProviderPrivate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsProviderPrivate_GetObject(This,ObjectId,type,ppObjectUnk)	\
    ( (This)->lpVtbl -> GetObject(This,ObjectId,type,ppObjectUnk) ) 

#define IVdsProviderPrivate_OnLoad(This,pwszMachineName,pCallbackObject)	\
    ( (This)->lpVtbl -> OnLoad(This,pwszMachineName,pCallbackObject) ) 

#define IVdsProviderPrivate_OnUnload(This,bForceUnload)	\
    ( (This)->lpVtbl -> OnUnload(This,bForceUnload) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsProviderPrivate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vdshwprv_0000_0006 */
/* [local] */ 



























typedef 
enum _VDS_SUB_SYSTEM_STATUS
    {	VDS_SSS_UNKNOWN	= 0,
	VDS_SSS_ONLINE	= 1,
	VDS_SSS_NOT_READY	= 2,
	VDS_SSS_OFFLINE	= 4,
	VDS_SSS_FAILED	= 5,
	VDS_SSS_PARTIALLY_MANAGED	= 9
    } 	VDS_SUB_SYSTEM_STATUS;

typedef 
enum _VDS_SUB_SYSTEM_FLAG
    {	VDS_SF_LUN_MASKING_CAPABLE	= 0x1,
	VDS_SF_LUN_PLEXING_CAPABLE	= 0x2,
	VDS_SF_LUN_REMAPPING_CAPABLE	= 0x4,
	VDS_SF_DRIVE_EXTENT_CAPABLE	= 0x8,
	VDS_SF_HARDWARE_CHECKSUM_CAPABLE	= 0x10,
	VDS_SF_RADIUS_CAPABLE	= 0x20,
	VDS_SF_READ_BACK_VERIFY_CAPABLE	= 0x40,
	VDS_SF_WRITE_THROUGH_CACHING_CAPABLE	= 0x80,
	VDS_SF_SUPPORTS_FAULT_TOLERANT_LUNS	= 0x200,
	VDS_SF_SUPPORTS_NON_FAULT_TOLERANT_LUNS	= 0x400,
	VDS_SF_SUPPORTS_SIMPLE_LUNS	= 0x800,
	VDS_SF_SUPPORTS_SPAN_LUNS	= 0x1000,
	VDS_SF_SUPPORTS_STRIPE_LUNS	= 0x2000,
	VDS_SF_SUPPORTS_MIRROR_LUNS	= 0x4000,
	VDS_SF_SUPPORTS_PARITY_LUNS	= 0x8000,
	VDS_SF_SUPPORTS_AUTH_CHAP	= 0x10000,
	VDS_SF_SUPPORTS_AUTH_MUTUAL_CHAP	= 0x20000,
	VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG	= 0x40000,
	VDS_SF_SUPPORTS_LUN_NUMBER	= 0x80000,
	VDS_SF_SUPPORTS_MIRRORED_CACHE	= 0x100000,
	VDS_SF_READ_CACHING_CAPABLE	= 0x200000,
	VDS_SF_WRITE_CACHING_CAPABLE	= 0x400000,
	VDS_SF_MEDIA_SCAN_CAPABLE	= 0x800000,
	VDS_SF_CONSISTENCY_CHECK_CAPABLE	= 0x1000000
    } 	VDS_SUB_SYSTEM_FLAG;

typedef 
enum _VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG
    {	VDS_SF_SUPPORTS_RAID2_LUNS	= 0x1,
	VDS_SF_SUPPORTS_RAID3_LUNS	= 0x2,
	VDS_SF_SUPPORTS_RAID4_LUNS	= 0x4,
	VDS_SF_SUPPORTS_RAID5_LUNS	= 0x8,
	VDS_SF_SUPPORTS_RAID6_LUNS	= 0x10,
	VDS_SF_SUPPORTS_RAID01_LUNS	= 0x20,
	VDS_SF_SUPPORTS_RAID03_LUNS	= 0x40,
	VDS_SF_SUPPORTS_RAID05_LUNS	= 0x80,
	VDS_SF_SUPPORTS_RAID10_LUNS	= 0x100,
	VDS_SF_SUPPORTS_RAID15_LUNS	= 0x200,
	VDS_SF_SUPPORTS_RAID30_LUNS	= 0x400,
	VDS_SF_SUPPORTS_RAID50_LUNS	= 0x800,
	VDS_SF_SUPPORTS_RAID51_LUNS	= 0x1000,
	VDS_SF_SUPPORTS_RAID53_LUNS	= 0x2000,
	VDS_SF_SUPPORTS_RAID60_LUNS	= 0x4000,
	VDS_SF_SUPPORTS_RAID61_LUNS	= 0x8000
    } 	VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG;

typedef 
enum _VDS_INTERCONNECT_FLAG
    {	VDS_ITF_PCI_RAID	= 0x1,
	VDS_ITF_FIBRE_CHANNEL	= 0x2,
	VDS_ITF_ISCSI	= 0x4,
	VDS_ITF_SAS	= 0x8
    } 	VDS_INTERCONNECT_FLAG;

typedef 
enum _VDS_CONTROLLER_STATUS
    {	VDS_CS_UNKNOWN	= 0,
	VDS_CS_ONLINE	= 1,
	VDS_CS_NOT_READY	= 2,
	VDS_CS_OFFLINE	= 4,
	VDS_CS_FAILED	= 5,
	VDS_CS_REMOVED	= 8
    } 	VDS_CONTROLLER_STATUS;

typedef 
enum _VDS_PORT_STATUS
    {	VDS_PRS_UNKNOWN	= 0,
	VDS_PRS_ONLINE	= 1,
	VDS_PRS_NOT_READY	= 2,
	VDS_PRS_OFFLINE	= 4,
	VDS_PRS_FAILED	= 5,
	VDS_PRS_REMOVED	= 8
    } 	VDS_PORT_STATUS;

typedef 
enum _VDS_DRIVE_STATUS
    {	VDS_DRS_UNKNOWN	= 0,
	VDS_DRS_ONLINE	= 1,
	VDS_DRS_NOT_READY	= 2,
	VDS_DRS_OFFLINE	= 4,
	VDS_DRS_FAILED	= 5,
	VDS_DRS_REMOVED	= 8
    } 	VDS_DRIVE_STATUS;

typedef 
enum _VDS_DRIVE_FLAG
    {	VDS_DRF_HOTSPARE	= 0x1,
	VDS_DRF_ASSIGNED	= 0x2,
	VDS_DRF_UNASSIGNED	= 0x4,
	VDS_DRF_HOTSPARE_IN_USE	= 0x8,
	VDS_DRF_HOTSPARE_STANDBY	= 0x10
    } 	VDS_DRIVE_FLAG;

typedef 
enum _VDS_LUN_TYPE
    {	VDS_LT_UNKNOWN	= 0,
	VDS_LT_DEFAULT	= 1,
	VDS_LT_FAULT_TOLERANT	= 2,
	VDS_LT_NON_FAULT_TOLERANT	= 3,
	VDS_LT_SIMPLE	= 10,
	VDS_LT_SPAN	= 11,
	VDS_LT_STRIPE	= 12,
	VDS_LT_MIRROR	= 13,
	VDS_LT_PARITY	= 14,
	VDS_LT_RAID2	= 15,
	VDS_LT_RAID3	= 16,
	VDS_LT_RAID4	= 17,
	VDS_LT_RAID5	= 18,
	VDS_LT_RAID6	= 19,
	VDS_LT_RAID01	= 20,
	VDS_LT_RAID03	= 21,
	VDS_LT_RAID05	= 22,
	VDS_LT_RAID10	= 23,
	VDS_LT_RAID15	= 24,
	VDS_LT_RAID30	= 25,
	VDS_LT_RAID50	= 26,
	VDS_LT_RAID51	= 27,
	VDS_LT_RAID53	= 28,
	VDS_LT_RAID60	= 29,
	VDS_LT_RAID61	= 30
    } 	VDS_LUN_TYPE;

typedef 
enum _VDS_LUN_STATUS
    {	VDS_LS_UNKNOWN	= 0,
	VDS_LS_ONLINE	= 1,
	VDS_LS_NOT_READY	= 2,
	VDS_LS_OFFLINE	= 4,
	VDS_LS_FAILED	= 5
    } 	VDS_LUN_STATUS;

typedef 
enum _VDS_LUN_FLAG
    {	VDS_LF_LBN_REMAP_ENABLED	= 0x1,
	VDS_LF_READ_BACK_VERIFY_ENABLED	= 0x2,
	VDS_LF_WRITE_THROUGH_CACHING_ENABLED	= 0x4,
	VDS_LF_HARDWARE_CHECKSUM_ENABLED	= 0x8,
	VDS_LF_READ_CACHE_ENABLED	= 0x10,
	VDS_LF_WRITE_CACHE_ENABLED	= 0x20,
	VDS_LF_MEDIA_SCAN_ENABLED	= 0x40,
	VDS_LF_CONSISTENCY_CHECK_ENABLED	= 0x80,
	VDS_LF_SNAPSHOT	= 0x100
    } 	VDS_LUN_FLAG;

typedef 
enum _VDS_LUN_PLEX_TYPE
    {	VDS_LPT_UNKNOWN	= 0,
	VDS_LPT_SIMPLE	= VDS_LT_SIMPLE,
	VDS_LPT_SPAN	= VDS_LT_SPAN,
	VDS_LPT_STRIPE	= VDS_LT_STRIPE,
	VDS_LPT_PARITY	= VDS_LT_PARITY,
	VDS_LPT_RAID2	= VDS_LT_RAID2,
	VDS_LPT_RAID3	= VDS_LT_RAID3,
	VDS_LPT_RAID4	= VDS_LT_RAID4,
	VDS_LPT_RAID5	= VDS_LT_RAID5,
	VDS_LPT_RAID6	= VDS_LT_RAID6,
	VDS_LPT_RAID03	= VDS_LT_RAID03,
	VDS_LPT_RAID05	= VDS_LT_RAID05,
	VDS_LPT_RAID10	= VDS_LT_RAID10,
	VDS_LPT_RAID15	= VDS_LT_RAID15,
	VDS_LPT_RAID30	= VDS_LT_RAID30,
	VDS_LPT_RAID50	= VDS_LT_RAID50,
	VDS_LPT_RAID53	= VDS_LT_RAID53,
	VDS_LPT_RAID60	= VDS_LT_RAID60
    } 	VDS_LUN_PLEX_TYPE;

typedef 
enum _VDS_LUN_PLEX_STATUS
    {	VDS_LPS_UNKNOWN	= 0,
	VDS_LPS_ONLINE	= 1,
	VDS_LPS_NOT_READY	= 2,
	VDS_LPS_OFFLINE	= 4,
	VDS_LPS_FAILED	= 5
    } 	VDS_LUN_PLEX_STATUS;

typedef 
enum _VDS_LUN_PLEX_FLAG
    {	VDS_LPF_LBN_REMAP_ENABLED	= VDS_LF_LBN_REMAP_ENABLED
    } 	VDS_LUN_PLEX_FLAG;

typedef 
enum _VDS_ISCSI_PORTAL_STATUS
    {	VDS_IPS_UNKNOWN	= 0,
	VDS_IPS_ONLINE	= 1,
	VDS_IPS_NOT_READY	= 2,
	VDS_IPS_OFFLINE	= 4,
	VDS_IPS_FAILED	= 5
    } 	VDS_ISCSI_PORTAL_STATUS;

typedef 
enum _VDS_STORAGE_POOL_STATUS
    {	VDS_SPS_UNKNOWN	= 0,
	VDS_SPS_ONLINE	= 1,
	VDS_SPS_NOT_READY	= 2,
	VDS_SPS_OFFLINE	= 4
    } 	VDS_STORAGE_POOL_STATUS;

typedef 
enum _VDS_STORAGE_POOL_TYPE
    {	VDS_SPT_UNKNOWN	= 0,
	VDS_SPT_PRIMORDIAL	= 0x1,
	VDS_SPT_CONCRETE	= 0x2
    } 	VDS_STORAGE_POOL_TYPE;

typedef 
enum _VDS_MAINTENANCE_OPERATION
    {	BlinkLight	= 1,
	BeepAlarm	= 2,
	SpinDown	= 3,
	SpinUp	= 4,
	Ping	= 5
    } 	VDS_MAINTENANCE_OPERATION;

typedef struct _VDS_HINTS
    {
    ULONGLONG ullHintMask;
    ULONGLONG ullExpectedMaximumSize;
    ULONG ulOptimalReadSize;
    ULONG ulOptimalReadAlignment;
    ULONG ulOptimalWriteSize;
    ULONG ulOptimalWriteAlignment;
    ULONG ulMaximumDriveCount;
    ULONG ulStripeSize;
    BOOL bFastCrashRecoveryRequired;
    BOOL bMostlyReads;
    BOOL bOptimizeForSequentialReads;
    BOOL bOptimizeForSequentialWrites;
    BOOL bRemapEnabled;
    BOOL bReadBackVerifyEnabled;
    BOOL bWriteThroughCachingEnabled;
    BOOL bHardwareChecksumEnabled;
    BOOL bIsYankable;
    SHORT sRebuildPriority;
    } 	VDS_HINTS;

typedef struct _VDS_HINTS *PVDS_HINTS;

#define	VDS_HINT_FASTCRASHRECOVERYREQUIRED	( 0x1L )

#define	VDS_HINT_MOSTLYREADS	( 0x2L )

#define	VDS_HINT_OPTIMIZEFORSEQUENTIALREADS	( 0x4L )

#define	VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES	( 0x8L )

#define	VDS_HINT_READBACKVERIFYENABLED	( 0x10L )

#define	VDS_HINT_REMAPENABLED	( 0x20L )

#define	VDS_HINT_WRITETHROUGHCACHINGENABLED	( 0x40L )

#define	VDS_HINT_HARDWARECHECKSUMENABLED	( 0x80L )

#define	VDS_HINT_ISYANKABLE	( 0x100L )

typedef struct _VDS_HINTS2
    {
    ULONGLONG ullHintMask;
    ULONGLONG ullExpectedMaximumSize;
    ULONG ulOptimalReadSize;
    ULONG ulOptimalReadAlignment;
    ULONG ulOptimalWriteSize;
    ULONG ulOptimalWriteAlignment;
    ULONG ulMaximumDriveCount;
    ULONG ulStripeSize;
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONG ulReserved3;
    BOOL bFastCrashRecoveryRequired;
    BOOL bMostlyReads;
    BOOL bOptimizeForSequentialReads;
    BOOL bOptimizeForSequentialWrites;
    BOOL bRemapEnabled;
    BOOL bReadBackVerifyEnabled;
    BOOL bWriteThroughCachingEnabled;
    BOOL bHardwareChecksumEnabled;
    BOOL bIsYankable;
    BOOL bAllocateHotSpare;
    BOOL bUseMirroredCache;
    BOOL bReadCachingEnabled;
    BOOL bWriteCachingEnabled;
    BOOL bMediaScanEnabled;
    BOOL bConsistencyCheckEnabled;
    VDS_STORAGE_BUS_TYPE BusType;
    BOOL bReserved1;
    BOOL bReserved2;
    BOOL bReserved3;
    SHORT sRebuildPriority;
    } 	VDS_HINTS2;

typedef struct _VDS_HINTS2 *PVDS_HINTS2;

#define	VDS_HINT_ALLOCATEHOTSPARE	( 0x200L )

#define	VDS_HINT_BUSTYPE	( 0x400L )

#define	VDS_HINT_USEMIRROREDCACHE	( 0x800L )

#define	VDS_HINT_READCACHINGENABLED	( 0x1000L )

#define	VDS_HINT_WRITECACHINGENABLED	( 0x2000L )

#define	VDS_HINT_MEDIASCANENABLED	( 0x4000L )

#define	VDS_HINT_CONSISTENCYCHECKENABLED	( 0x8000L )

typedef struct _VDS_SUB_SYSTEM_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    ULONG ulStripeSizeFlags;
    VDS_SUB_SYSTEM_STATUS status;
    VDS_HEALTH health;
    SHORT sNumberOfInternalBuses;
    SHORT sMaxNumberOfSlotsEachBus;
    SHORT sMaxNumberOfControllers;
    SHORT sRebuildPriority;
    } 	VDS_SUB_SYSTEM_PROP;

typedef struct _VDS_SUB_SYSTEM_PROP2
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    ULONG ulStripeSizeFlags;
    ULONG ulSupportedRaidTypeFlags;
    VDS_SUB_SYSTEM_STATUS status;
    VDS_HEALTH health;
    SHORT sNumberOfInternalBuses;
    SHORT sMaxNumberOfSlotsEachBus;
    SHORT sMaxNumberOfControllers;
    SHORT sRebuildPriority;
    ULONG ulNumberOfEnclosures;
    } 	VDS_SUB_SYSTEM_PROP2;

typedef struct _VDS_CONTROLLER_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    VDS_CONTROLLER_STATUS status;
    VDS_HEALTH health;
    SHORT sNumberOfPorts;
    } 	VDS_CONTROLLER_PROP;

typedef struct _VDS_DRIVE_PROP
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    VDS_DRIVE_STATUS status;
    VDS_HEALTH health;
    SHORT sInternalBusNumber;
    SHORT sSlotNumber;
    } 	VDS_DRIVE_PROP;

typedef struct _VDS_DRIVE_PROP2
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    VDS_DRIVE_STATUS status;
    VDS_HEALTH health;
    SHORT sInternalBusNumber;
    SHORT sSlotNumber;
    ULONG ulEnclosureNumber;
    VDS_STORAGE_BUS_TYPE busType;
    ULONG ulSpindleSpeed;
    } 	VDS_DRIVE_PROP2;

typedef struct _VDS_DRIVE_EXTENT
    {
    VDS_OBJECT_ID id;
    VDS_OBJECT_ID LunId;
    ULONGLONG ullSize;
    BOOL bUsed;
    } 	VDS_DRIVE_EXTENT;

#define VDS_REBUILD_PRIORITY_MIN        0
#define VDS_REBUILD_PRIORITY_MAX        16
typedef struct _VDS_LUN_PROP
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    LPWSTR pwszUnmaskingList;
    ULONG ulFlags;
    VDS_LUN_TYPE type;
    VDS_LUN_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    SHORT sRebuildPriority;
    } 	VDS_LUN_PROP;

typedef struct _VDS_LUN_PROP *PVDS_LUN_PROP;

typedef struct _VDS_LUN_PLEX_PROP
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    VDS_LUN_PLEX_TYPE type;
    VDS_LUN_PLEX_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    ULONG ulFlags;
    ULONG ulStripeSize;
    SHORT sRebuildPriority;
    } 	VDS_LUN_PLEX_PROP;

typedef struct _VDS_PORT_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    VDS_PORT_STATUS status;
    } 	VDS_PORT_PROP;

typedef struct _VDS_ISCSI_PORTAL_PROP
    {
    VDS_OBJECT_ID id;
    VDS_IPADDRESS address;
    VDS_ISCSI_PORTAL_STATUS status;
    } 	VDS_ISCSI_PORTAL_PROP;

typedef struct _VDS_ISCSI_TARGET_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszIscsiName;
    LPWSTR pwszFriendlyName;
    BOOL bChapEnabled;
    } 	VDS_ISCSI_TARGET_PROP;

typedef struct _VDS_ISCSI_PORTALGROUP_PROP
    {
    VDS_OBJECT_ID id;
    VDS_ISCSI_PORTALGROUP_TAG tag;
    } 	VDS_ISCSI_PORTALGROUP_PROP;

typedef 
enum _VDS_RAID_TYPE
    {	VDS_RT_UNKNOWN	= 0,
	VDS_RT_RAID0	= 10,
	VDS_RT_RAID1	= 11,
	VDS_RT_RAID2	= 12,
	VDS_RT_RAID3	= 13,
	VDS_RT_RAID4	= 14,
	VDS_RT_RAID5	= 15,
	VDS_RT_RAID6	= 16,
	VDS_RT_RAID01	= 17,
	VDS_RT_RAID03	= 18,
	VDS_RT_RAID05	= 19,
	VDS_RT_RAID10	= 20,
	VDS_RT_RAID15	= 21,
	VDS_RT_RAID30	= 22,
	VDS_RT_RAID50	= 23,
	VDS_RT_RAID51	= 24,
	VDS_RT_RAID53	= 25,
	VDS_RT_RAID60	= 26,
	VDS_RT_RAID61	= 27
    } 	VDS_RAID_TYPE;

typedef struct _VDS_POOL_CUSTOM_ATTRIBUTES
    {
    LPWSTR pwszName;
    LPWSTR pwszValue;
    } 	VDS_POOL_CUSTOM_ATTRIBUTES;

typedef struct _VDS_POOL_CUSTOM_ATTRIBUTES *PVDS_POOL_CUSTOM_ATTRIBUTES;

typedef struct _VDS_POOL_ATTRIBUTES
    {
    ULONGLONG ullAttributeMask;
    VDS_RAID_TYPE raidType;
    VDS_STORAGE_BUS_TYPE busType;
    LPWSTR pwszIntendedUsage;
    BOOL bSpinDown;
    BOOL bIsThinProvisioned;
    ULONGLONG ullProvisionedSpace;
    BOOL bNoSinglePointOfFailure;
    ULONG ulDataRedundancyMax;
    ULONG ulDataRedundancyMin;
    ULONG ulDataRedundancyDefault;
    ULONG ulPackageRedundancyMax;
    ULONG ulPackageRedundancyMin;
    ULONG ulPackageRedundancyDefault;
    ULONG ulStripeSize;
    ULONG ulStripeSizeMax;
    ULONG ulStripeSizeMin;
    ULONG ulDefaultStripeSize;
    ULONG ulNumberOfColumns;
    ULONG ulNumberOfColumnsMax;
    ULONG ulNumberOfColumnsMin;
    ULONG ulDefaultNumberofColumns;
    ULONG ulDataAvailabilityHint;
    ULONG ulAccessRandomnessHint;
    ULONG ulAccessDirectionHint;
    ULONG ulAccessSizeHint;
    ULONG ulAccessLatencyHint;
    ULONG ulAccessBandwidthWeightHint;
    ULONG ulStorageCostHint;
    ULONG ulStorageEfficiencyHint;
    ULONG ulNumOfCustomAttributes;
    VDS_POOL_CUSTOM_ATTRIBUTES *pPoolCustomAttributes;
    BOOL bReserved1;
    BOOL bReserved2;
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONGLONG ullReserved1;
    ULONGLONG ullReserved2;
    } 	VDS_POOL_ATTRIBUTES;

typedef struct _VDS_POOL_ATTRIBUTES *PVDS_POOL_ATTRIBUTES;

#define	VDS_POOL_ATTRIB_RAIDTYPE	( 0x1L )

#define	VDS_POOL_ATTRIB_BUSTYPE	( 0x2L )

#define	VDS_POOL_ATTRIB_ALLOW_SPINDOWN	( 0x4L )

#define	VDS_POOL_ATTRIB_THIN_PROVISION	( 0x8L )

#define	VDS_POOL_ATTRIB_NO_SINGLE_POF	( 0x10L )

#define	VDS_POOL_ATTRIB_DATA_RDNCY_MAX	( 0x20L )

#define	VDS_POOL_ATTRIB_DATA_RDNCY_MIN	( 0x40L )

#define	VDS_POOL_ATTRIB_DATA_RDNCY_DEF	( 0x80L )

#define	VDS_POOL_ATTRIB_PKG_RDNCY_MAX	( 0x100L )

#define	VDS_POOL_ATTRIB_PKG_RDNCY_MIN	( 0x200L )

#define	VDS_POOL_ATTRIB_PKG_RDNCY_DEF	( 0x400L )

#define	VDS_POOL_ATTRIB_STRIPE_SIZE	( 0x800L )

#define	VDS_POOL_ATTRIB_STRIPE_SIZE_MAX	( 0x1000L )

#define	VDS_POOL_ATTRIB_STRIPE_SIZE_MIN	( 0x2000L )

#define	VDS_POOL_ATTRIB_STRIPE_SIZE_DEF	( 0x4000L )

#define	VDS_POOL_ATTRIB_NUM_CLMNS	( 0x8000L )

#define	VDS_POOL_ATTRIB_NUM_CLMNS_MAX	( 0x10000L )

#define	VDS_POOL_ATTRIB_NUM_CLMNS_MIN	( 0x20000L )

#define	VDS_POOL_ATTRIB_NUM_CLMNS_DEF	( 0x40000L )

#define	VDS_POOL_ATTRIB_DATA_AVL_HINT	( 0x80000L )

#define	VDS_POOL_ATTRIB_ACCS_RNDM_HINT	( 0x100000L )

#define	VDS_POOL_ATTRIB_ACCS_DIR_HINT	( 0x200000L )

#define	VDS_POOL_ATTRIB_ACCS_SIZE_HINT	( 0x400000L )

#define	VDS_POOL_ATTRIB_ACCS_LTNCY_HINT	( 0x800000L )

#define	VDS_POOL_ATTRIB_ACCS_BDW_WT_HINT	( 0x1000000L )

#define	VDS_POOL_ATTRIB_STOR_COST_HINT	( 0x2000000L )

#define	VDS_POOL_ATTRIB_STOR_EFFCY_HINT	( 0x4000000L )

#define	VDS_POOL_ATTRIB_CUSTOM_ATTRIB	( 0x8000000L )

typedef struct _VDS_STORAGE_POOL_PROP
    {
    VDS_OBJECT_ID id;
    VDS_STORAGE_POOL_STATUS status;
    VDS_HEALTH health;
    VDS_STORAGE_POOL_TYPE type;
    LPWSTR pwszName;
    LPWSTR pwszDescription;
    ULONGLONG ullTotalConsumedSpace;
    ULONGLONG ullTotalManagedSpace;
    ULONGLONG ullRemainingFreeSpace;
    } 	VDS_STORAGE_POOL_PROP;

typedef struct _VDS_STORAGE_POOL_PROP *PVDS_STORAGE_POOL_PROP;

typedef struct _VDS_STORAGE_POOL_DRIVE_EXTENT
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    BOOL bUsed;
    } 	VDS_STORAGE_POOL_DRIVE_EXTENT;



extern RPC_IF_HANDLE __MIDL_itf_vdshwprv_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdshwprv_0000_0006_v0_0_s_ifspec;

#ifndef __IVdsHwProvider_INTERFACE_DEFINED__
#define __IVdsHwProvider_INTERFACE_DEFINED__

/* interface IVdsHwProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d99bdaae-b13a-4178-9fdb-e27f16b4603e")
    IVdsHwProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QuerySubSystems( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reenumerate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QuerySubSystems )( 
            __RPC__in IVdsHwProvider * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reenumerate )( 
            __RPC__in IVdsHwProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IVdsHwProvider * This);
        
        END_INTERFACE
    } IVdsHwProviderVtbl;

    interface IVdsHwProvider
    {
        CONST_VTBL struct IVdsHwProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProvider_QuerySubSystems(This,ppEnum)	\
    ( (This)->lpVtbl -> QuerySubSystems(This,ppEnum) ) 

#define IVdsHwProvider_Reenumerate(This)	\
    ( (This)->lpVtbl -> Reenumerate(This) ) 

#define IVdsHwProvider_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProvider_INTERFACE_DEFINED__ */


#ifndef __IVdsHwProviderType_INTERFACE_DEFINED__
#define __IVdsHwProviderType_INTERFACE_DEFINED__

/* interface IVdsHwProviderType */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProviderType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3e0f5166-542d-4fc6-947a-012174240b7e")
    IVdsHwProviderType : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProviderType( 
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProviderType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProviderType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProviderType * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProviderType )( 
            __RPC__in IVdsHwProviderType * This,
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType);
        
        END_INTERFACE
    } IVdsHwProviderTypeVtbl;

    interface IVdsHwProviderType
    {
        CONST_VTBL struct IVdsHwProviderTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProviderType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProviderType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProviderType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProviderType_GetProviderType(This,pType)	\
    ( (This)->lpVtbl -> GetProviderType(This,pType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProviderType_INTERFACE_DEFINED__ */


#ifndef __IVdsHwProviderType2_INTERFACE_DEFINED__
#define __IVdsHwProviderType2_INTERFACE_DEFINED__

/* interface IVdsHwProviderType2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProviderType2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8190236f-c4d0-4e81-8011-d69512fcc984")
    IVdsHwProviderType2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProviderType2( 
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderType2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProviderType2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProviderType2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProviderType2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProviderType2 )( 
            __RPC__in IVdsHwProviderType2 * This,
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType);
        
        END_INTERFACE
    } IVdsHwProviderType2Vtbl;

    interface IVdsHwProviderType2
    {
        CONST_VTBL struct IVdsHwProviderType2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProviderType2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProviderType2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProviderType2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProviderType2_GetProviderType2(This,pType)	\
    ( (This)->lpVtbl -> GetProviderType2(This,pType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProviderType2_INTERFACE_DEFINED__ */


#ifndef __IVdsHwProviderStoragePools_INTERFACE_DEFINED__
#define __IVdsHwProviderStoragePools_INTERFACE_DEFINED__

/* interface IVdsHwProviderStoragePools */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProviderStoragePools;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5b5937a-f188-4c79-b86c-11c920ad11b8")
    IVdsHwProviderStoragePools : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryStoragePools( 
            /* [in] */ ULONG ulFlags,
            /* [in] */ ULONGLONG ullRemainingFreeSpace,
            /* [unique][in] */ __RPC__in_opt VDS_POOL_ATTRIBUTES *pPoolAttributes,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateLunInStoragePool( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [in] */ VDS_OBJECT_ID StoragePoolId,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunCreateSizeInStoragePool( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ VDS_OBJECT_ID StoragePoolId,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderStoragePoolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProviderStoragePools * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProviderStoragePools * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProviderStoragePools * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryStoragePools )( 
            __RPC__in IVdsHwProviderStoragePools * This,
            /* [in] */ ULONG ulFlags,
            /* [in] */ ULONGLONG ullRemainingFreeSpace,
            /* [unique][in] */ __RPC__in_opt VDS_POOL_ATTRIBUTES *pPoolAttributes,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateLunInStoragePool )( 
            __RPC__in IVdsHwProviderStoragePools * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [in] */ VDS_OBJECT_ID StoragePoolId,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunCreateSizeInStoragePool )( 
            __RPC__in IVdsHwProviderStoragePools * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ VDS_OBJECT_ID StoragePoolId,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize);
        
        END_INTERFACE
    } IVdsHwProviderStoragePoolsVtbl;

    interface IVdsHwProviderStoragePools
    {
        CONST_VTBL struct IVdsHwProviderStoragePoolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProviderStoragePools_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProviderStoragePools_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProviderStoragePools_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProviderStoragePools_QueryStoragePools(This,ulFlags,ullRemainingFreeSpace,pPoolAttributes,ppEnum)	\
    ( (This)->lpVtbl -> QueryStoragePools(This,ulFlags,ullRemainingFreeSpace,pPoolAttributes,ppEnum) ) 

#define IVdsHwProviderStoragePools_CreateLunInStoragePool(This,type,ullSizeInBytes,StoragePoolId,pwszUnmaskingList,pHints2,ppAsync)	\
    ( (This)->lpVtbl -> CreateLunInStoragePool(This,type,ullSizeInBytes,StoragePoolId,pwszUnmaskingList,pHints2,ppAsync) ) 

#define IVdsHwProviderStoragePools_QueryMaxLunCreateSizeInStoragePool(This,type,StoragePoolId,pHints2,pullMaxLunSize)	\
    ( (This)->lpVtbl -> QueryMaxLunCreateSizeInStoragePool(This,type,StoragePoolId,pHints2,pullMaxLunSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProviderStoragePools_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystem_INTERFACE_DEFINED__
#define __IVdsSubSystem_INTERFACE_DEFINED__

/* interface IVdsSubSystem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6fcee2d3-6d90-4f91-80e2-a5c7caaca9d8")
    IVdsSubSystem : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP *pSubSystemProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryControllers( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDrives( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDrive( 
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reenumerate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControllerStatus( 
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOnlineControllers) VDS_OBJECT_ID *pOnlineControllerIdArray,
            /* [in] */ LONG lNumberOfOnlineControllers,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOfflineControllers) VDS_OBJECT_ID *pOfflineControllerIdArray,
            /* [in] */ LONG lNumberOfOfflineControllers) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateLun( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReplaceDrive( 
            /* [in] */ VDS_OBJECT_ID DriveToBeReplaced,
            /* [in] */ VDS_OBJECT_ID ReplacementDrive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_SUB_SYSTEM_STATUS status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunCreateSize( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP *pSubSystemProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProvider )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryControllers )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryLuns )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDrives )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDrive )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reenumerate )( 
            __RPC__in IVdsSubSystem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetControllerStatus )( 
            __RPC__in IVdsSubSystem * This,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOnlineControllers) VDS_OBJECT_ID *pOnlineControllerIdArray,
            /* [in] */ LONG lNumberOfOnlineControllers,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOfflineControllers) VDS_OBJECT_ID *pOfflineControllerIdArray,
            /* [in] */ LONG lNumberOfOfflineControllers);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateLun )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReplaceDrive )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ VDS_OBJECT_ID DriveToBeReplaced,
            /* [in] */ VDS_OBJECT_ID ReplacementDrive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ VDS_SUB_SYSTEM_STATUS status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunCreateSize )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize);
        
        END_INTERFACE
    } IVdsSubSystemVtbl;

    interface IVdsSubSystem
    {
        CONST_VTBL struct IVdsSubSystemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystem_GetProperties(This,pSubSystemProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pSubSystemProp) ) 

#define IVdsSubSystem_GetProvider(This,ppProvider)	\
    ( (This)->lpVtbl -> GetProvider(This,ppProvider) ) 

#define IVdsSubSystem_QueryControllers(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryControllers(This,ppEnum) ) 

#define IVdsSubSystem_QueryLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryLuns(This,ppEnum) ) 

#define IVdsSubSystem_QueryDrives(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryDrives(This,ppEnum) ) 

#define IVdsSubSystem_GetDrive(This,sBusNumber,sSlotNumber,ppDrive)	\
    ( (This)->lpVtbl -> GetDrive(This,sBusNumber,sSlotNumber,ppDrive) ) 

#define IVdsSubSystem_Reenumerate(This)	\
    ( (This)->lpVtbl -> Reenumerate(This) ) 

#define IVdsSubSystem_SetControllerStatus(This,pOnlineControllerIdArray,lNumberOfOnlineControllers,pOfflineControllerIdArray,lNumberOfOfflineControllers)	\
    ( (This)->lpVtbl -> SetControllerStatus(This,pOnlineControllerIdArray,lNumberOfOnlineControllers,pOfflineControllerIdArray,lNumberOfOfflineControllers) ) 

#define IVdsSubSystem_CreateLun(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints,ppAsync)	\
    ( (This)->lpVtbl -> CreateLun(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints,ppAsync) ) 

#define IVdsSubSystem_ReplaceDrive(This,DriveToBeReplaced,ReplacementDrive)	\
    ( (This)->lpVtbl -> ReplaceDrive(This,DriveToBeReplaced,ReplacementDrive) ) 

#define IVdsSubSystem_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#define IVdsSubSystem_QueryMaxLunCreateSize(This,type,pDriveIdArray,lNumberOfDrives,pHints,pullMaxLunSize)	\
    ( (This)->lpVtbl -> QueryMaxLunCreateSize(This,type,pDriveIdArray,lNumberOfDrives,pHints,pullMaxLunSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystem_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystem2_INTERFACE_DEFINED__
#define __IVdsSubSystem2_INTERFACE_DEFINED__

/* interface IVdsSubSystem2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("be666735-7800-4a77-9d9c-40f85b87e292")
    IVdsSubSystem2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties2( 
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP2 *pSubSystemProp2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDrive2( 
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [in] */ ULONG ulEnclosureNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateLun2( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunCreateSize2( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystem2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties2 )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP2 *pSubSystemProp2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDrive2 )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [in] */ ULONG ulEnclosureNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateLun2 )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunCreateSize2 )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize);
        
        END_INTERFACE
    } IVdsSubSystem2Vtbl;

    interface IVdsSubSystem2
    {
        CONST_VTBL struct IVdsSubSystem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystem2_GetProperties2(This,pSubSystemProp2)	\
    ( (This)->lpVtbl -> GetProperties2(This,pSubSystemProp2) ) 

#define IVdsSubSystem2_GetDrive2(This,sBusNumber,sSlotNumber,ulEnclosureNumber,ppDrive)	\
    ( (This)->lpVtbl -> GetDrive2(This,sBusNumber,sSlotNumber,ulEnclosureNumber,ppDrive) ) 

#define IVdsSubSystem2_CreateLun2(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints2,ppAsync)	\
    ( (This)->lpVtbl -> CreateLun2(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints2,ppAsync) ) 

#define IVdsSubSystem2_QueryMaxLunCreateSize2(This,type,pDriveIdArray,lNumberOfDrives,pHints2,pullMaxLunSize)	\
    ( (This)->lpVtbl -> QueryMaxLunCreateSize2(This,type,pDriveIdArray,lNumberOfDrives,pHints2,pullMaxLunSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystem2_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemNaming_INTERFACE_DEFINED__
#define __IVdsSubSystemNaming_INTERFACE_DEFINED__

/* interface IVdsSubSystemNaming */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemNaming;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d70faa3-9cd4-4900-aa20-6981b6aafc75")
    IVdsSubSystemNaming : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemNamingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystemNaming * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystemNaming * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystemNaming * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            __RPC__in IVdsSubSystemNaming * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName);
        
        END_INTERFACE
    } IVdsSubSystemNamingVtbl;

    interface IVdsSubSystemNaming
    {
        CONST_VTBL struct IVdsSubSystemNamingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemNaming_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemNaming_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemNaming_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemNaming_SetFriendlyName(This,pwszFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwszFriendlyName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemNaming_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemIscsi_INTERFACE_DEFINED__
#define __IVdsSubSystemIscsi_INTERFACE_DEFINED__

/* interface IVdsSubSystemIscsi */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemIscsi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0027346f-40d0-4b45-8cec-5906dc0380c8")
    IVdsSubSystemIscsi : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryTargets( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPortals( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateTarget( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszIscsiName,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecGroupPresharedKey( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemIscsiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystemIscsi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystemIscsi * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryTargets )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPortals )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateTarget )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszIscsiName,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecGroupPresharedKey )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsSubSystemIscsiVtbl;

    interface IVdsSubSystemIscsi
    {
        CONST_VTBL struct IVdsSubSystemIscsiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemIscsi_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemIscsi_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemIscsi_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemIscsi_QueryTargets(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryTargets(This,ppEnum) ) 

#define IVdsSubSystemIscsi_QueryPortals(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPortals(This,ppEnum) ) 

#define IVdsSubSystemIscsi_CreateTarget(This,pwszIscsiName,pwszFriendlyName,ppAsync)	\
    ( (This)->lpVtbl -> CreateTarget(This,pwszIscsiName,pwszFriendlyName,ppAsync) ) 

#define IVdsSubSystemIscsi_SetIpsecGroupPresharedKey(This,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecGroupPresharedKey(This,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemIscsi_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemInterconnect_INTERFACE_DEFINED__
#define __IVdsSubSystemInterconnect_INTERFACE_DEFINED__

/* interface IVdsSubSystemInterconnect */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemInterconnect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e6fa560-c141-477b-83ba-0b6c38f7febf")
    IVdsSubSystemInterconnect : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSupportedInterconnects( 
            /* [out] */ __RPC__out ULONG *pulSupportedInterconnectsFlag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemInterconnectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystemInterconnect * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystemInterconnect * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystemInterconnect * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedInterconnects )( 
            __RPC__in IVdsSubSystemInterconnect * This,
            /* [out] */ __RPC__out ULONG *pulSupportedInterconnectsFlag);
        
        END_INTERFACE
    } IVdsSubSystemInterconnectVtbl;

    interface IVdsSubSystemInterconnect
    {
        CONST_VTBL struct IVdsSubSystemInterconnectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemInterconnect_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemInterconnect_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemInterconnect_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemInterconnect_GetSupportedInterconnects(This,pulSupportedInterconnectsFlag)	\
    ( (This)->lpVtbl -> GetSupportedInterconnects(This,pulSupportedInterconnectsFlag) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemInterconnect_INTERFACE_DEFINED__ */


#ifndef __IVdsControllerPort_INTERFACE_DEFINED__
#define __IVdsControllerPort_INTERFACE_DEFINED__

/* interface IVdsControllerPort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsControllerPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18691d0d-4e7f-43e8-92e4-cf44beeed11c")
    IVdsControllerPort : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetController( 
            /* [out] */ __RPC__deref_out_opt IVdsController **ppController) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_PORT_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsControllerPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsControllerPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsControllerPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsControllerPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsControllerPort * This,
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetController )( 
            __RPC__in IVdsControllerPort * This,
            /* [out] */ __RPC__deref_out_opt IVdsController **ppController);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedLuns )( 
            __RPC__in IVdsControllerPort * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IVdsControllerPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsControllerPort * This,
            /* [in] */ VDS_PORT_STATUS status);
        
        END_INTERFACE
    } IVdsControllerPortVtbl;

    interface IVdsControllerPort
    {
        CONST_VTBL struct IVdsControllerPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsControllerPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsControllerPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsControllerPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsControllerPort_GetProperties(This,pPortProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPortProp) ) 

#define IVdsControllerPort_GetController(This,ppController)	\
    ( (This)->lpVtbl -> GetController(This,ppController) ) 

#define IVdsControllerPort_QueryAssociatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedLuns(This,ppEnum) ) 

#define IVdsControllerPort_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IVdsControllerPort_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsControllerPort_INTERFACE_DEFINED__ */


#ifndef __IVdsController_INTERFACE_DEFINED__
#define __IVdsController_INTERFACE_DEFINED__

/* interface IVdsController */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsController;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cb53d96e-dffb-474a-a078-790d1e2bc082")
    IVdsController : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_CONTROLLER_PROP *pControllerProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPortProperties( 
            /* [in] */ SHORT sPortNumber,
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FlushCache( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvalidateCache( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_CONTROLLER_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsControllerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsController * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsController * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsController * This,
            /* [out] */ __RPC__out VDS_CONTROLLER_PROP *pControllerProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsController * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPortProperties )( 
            __RPC__in IVdsController * This,
            /* [in] */ SHORT sPortNumber,
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FlushCache )( 
            __RPC__in IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InvalidateCache )( 
            __RPC__in IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedLuns )( 
            __RPC__in IVdsController * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsController * This,
            /* [in] */ VDS_CONTROLLER_STATUS status);
        
        END_INTERFACE
    } IVdsControllerVtbl;

    interface IVdsController
    {
        CONST_VTBL struct IVdsControllerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsController_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsController_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsController_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsController_GetProperties(This,pControllerProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pControllerProp) ) 

#define IVdsController_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsController_GetPortProperties(This,sPortNumber,pPortProp)	\
    ( (This)->lpVtbl -> GetPortProperties(This,sPortNumber,pPortProp) ) 

#define IVdsController_FlushCache(This)	\
    ( (This)->lpVtbl -> FlushCache(This) ) 

#define IVdsController_InvalidateCache(This)	\
    ( (This)->lpVtbl -> InvalidateCache(This) ) 

#define IVdsController_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IVdsController_QueryAssociatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedLuns(This,ppEnum) ) 

#define IVdsController_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsController_INTERFACE_DEFINED__ */


#ifndef __IVdsControllerControllerPort_INTERFACE_DEFINED__
#define __IVdsControllerControllerPort_INTERFACE_DEFINED__

/* interface IVdsControllerControllerPort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsControllerControllerPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ca5d735f-6bae-42c0-b30e-f2666045ce71")
    IVdsControllerControllerPort : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryControllerPorts( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsControllerControllerPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsControllerControllerPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsControllerControllerPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsControllerControllerPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryControllerPorts )( 
            __RPC__in IVdsControllerControllerPort * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsControllerControllerPortVtbl;

    interface IVdsControllerControllerPort
    {
        CONST_VTBL struct IVdsControllerControllerPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsControllerControllerPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsControllerControllerPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsControllerControllerPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsControllerControllerPort_QueryControllerPorts(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryControllerPorts(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsControllerControllerPort_INTERFACE_DEFINED__ */


#ifndef __IVdsDrive_INTERFACE_DEFINED__
#define __IVdsDrive_INTERFACE_DEFINED__

/* interface IVdsDrive */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDrive;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ff24efa4-aade-4b6b-898b-eaa6a20887c7")
    IVdsDrive : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_DRIVE_PROP *pDriveProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_DRIVE_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDriveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDrive * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDrive * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDrive * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsDrive * This,
            /* [out] */ __RPC__out VDS_DRIVE_PROP *pDriveProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsDrive * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            __RPC__in IVdsDrive * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in IVdsDrive * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            __RPC__in IVdsDrive * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsDrive * This,
            /* [in] */ VDS_DRIVE_STATUS status);
        
        END_INTERFACE
    } IVdsDriveVtbl;

    interface IVdsDrive
    {
        CONST_VTBL struct IVdsDriveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDrive_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDrive_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDrive_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDrive_GetProperties(This,pDriveProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pDriveProp) ) 

#define IVdsDrive_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsDrive_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsDrive_SetFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags) ) 

#define IVdsDrive_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#define IVdsDrive_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDrive_INTERFACE_DEFINED__ */


#ifndef __IVdsDrive2_INTERFACE_DEFINED__
#define __IVdsDrive2_INTERFACE_DEFINED__

/* interface IVdsDrive2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDrive2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60b5a730-addf-4436-8ca7-5769e2d1ffa4")
    IVdsDrive2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties2( 
            /* [out] */ __RPC__out VDS_DRIVE_PROP2 *pDriveProp2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDrive2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDrive2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDrive2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDrive2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties2 )( 
            __RPC__in IVdsDrive2 * This,
            /* [out] */ __RPC__out VDS_DRIVE_PROP2 *pDriveProp2);
        
        END_INTERFACE
    } IVdsDrive2Vtbl;

    interface IVdsDrive2
    {
        CONST_VTBL struct IVdsDrive2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDrive2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDrive2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDrive2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDrive2_GetProperties2(This,pDriveProp2)	\
    ( (This)->lpVtbl -> GetProperties2(This,pDriveProp2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDrive2_INTERFACE_DEFINED__ */


#ifndef __IVdsLun_INTERFACE_DEFINED__
#define __IVdsLun_INTERFACE_DEFINED__

/* interface IVdsLun */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLun;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3540a9c7-e60f-4111-a840-8bba6c2c83d8")
    IVdsLun : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_LUN_PROP *pLunProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIdentificationData( 
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryActiveControllers( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Extend( 
            /* [in] */ ULONGLONG ullNumberOfBytesToAdd,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shrink( 
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPlexes( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPlex( 
            /* [in] */ VDS_OBJECT_ID lunId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePlex( 
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Recover( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMask( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssociateControllers( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllers) VDS_OBJECT_ID *pActiveControllerIdArray,
            /* [in] */ LONG lNumberOfActiveControllers,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllers) VDS_OBJECT_ID *pInactiveControllerIdArray,
            /* [in] */ LONG lNumberOfInactiveControllers) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHints( 
            /* [out] */ __RPC__out VDS_HINTS *pHints) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ApplyHints( 
            /* [in] */ __RPC__in VDS_HINTS *pHints) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_LUN_STATUS status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunExtendSize( 
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__out ULONGLONG *pullMaxBytesToBeAdded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLun * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLun * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLun * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__out VDS_LUN_PROP *pLunProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIdentificationData )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryActiveControllers )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Extend )( 
            __RPC__in IVdsLun * This,
            /* [in] */ ULONGLONG ullNumberOfBytesToAdd,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shrink )( 
            __RPC__in IVdsLun * This,
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPlexes )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPlex )( 
            __RPC__in IVdsLun * This,
            /* [in] */ VDS_OBJECT_ID lunId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePlex )( 
            __RPC__in IVdsLun * This,
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Recover )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMask )( 
            __RPC__in IVdsLun * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IVdsLun * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssociateControllers )( 
            __RPC__in IVdsLun * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllers) VDS_OBJECT_ID *pActiveControllerIdArray,
            /* [in] */ LONG lNumberOfActiveControllers,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllers) VDS_OBJECT_ID *pInactiveControllerIdArray,
            /* [in] */ LONG lNumberOfInactiveControllers);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHints )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__out VDS_HINTS *pHints);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ApplyHints )( 
            __RPC__in IVdsLun * This,
            /* [in] */ __RPC__in VDS_HINTS *pHints);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsLun * This,
            /* [in] */ VDS_LUN_STATUS status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunExtendSize )( 
            __RPC__in IVdsLun * This,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__out ULONGLONG *pullMaxBytesToBeAdded);
        
        END_INTERFACE
    } IVdsLunVtbl;

    interface IVdsLun
    {
        CONST_VTBL struct IVdsLunVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLun_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLun_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLun_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLun_GetProperties(This,pLunProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pLunProp) ) 

#define IVdsLun_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsLun_GetIdentificationData(This,pLunInfo)	\
    ( (This)->lpVtbl -> GetIdentificationData(This,pLunInfo) ) 

#define IVdsLun_QueryActiveControllers(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryActiveControllers(This,ppEnum) ) 

#define IVdsLun_Extend(This,ullNumberOfBytesToAdd,pDriveIdArray,lNumberOfDrives,ppAsync)	\
    ( (This)->lpVtbl -> Extend(This,ullNumberOfBytesToAdd,pDriveIdArray,lNumberOfDrives,ppAsync) ) 

#define IVdsLun_Shrink(This,ullNumberOfBytesToRemove,ppAsync)	\
    ( (This)->lpVtbl -> Shrink(This,ullNumberOfBytesToRemove,ppAsync) ) 

#define IVdsLun_QueryPlexes(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPlexes(This,ppEnum) ) 

#define IVdsLun_AddPlex(This,lunId,ppAsync)	\
    ( (This)->lpVtbl -> AddPlex(This,lunId,ppAsync) ) 

#define IVdsLun_RemovePlex(This,plexId,ppAsync)	\
    ( (This)->lpVtbl -> RemovePlex(This,plexId,ppAsync) ) 

#define IVdsLun_Recover(This,ppAsync)	\
    ( (This)->lpVtbl -> Recover(This,ppAsync) ) 

#define IVdsLun_SetMask(This,pwszUnmaskingList)	\
    ( (This)->lpVtbl -> SetMask(This,pwszUnmaskingList) ) 

#define IVdsLun_Delete(This)	\
    ( (This)->lpVtbl -> Delete(This) ) 

#define IVdsLun_AssociateControllers(This,pActiveControllerIdArray,lNumberOfActiveControllers,pInactiveControllerIdArray,lNumberOfInactiveControllers)	\
    ( (This)->lpVtbl -> AssociateControllers(This,pActiveControllerIdArray,lNumberOfActiveControllers,pInactiveControllerIdArray,lNumberOfInactiveControllers) ) 

#define IVdsLun_QueryHints(This,pHints)	\
    ( (This)->lpVtbl -> QueryHints(This,pHints) ) 

#define IVdsLun_ApplyHints(This,pHints)	\
    ( (This)->lpVtbl -> ApplyHints(This,pHints) ) 

#define IVdsLun_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#define IVdsLun_QueryMaxLunExtendSize(This,pDriveIdArray,lNumberOfDrives,pullMaxBytesToBeAdded)	\
    ( (This)->lpVtbl -> QueryMaxLunExtendSize(This,pDriveIdArray,lNumberOfDrives,pullMaxBytesToBeAdded) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLun_INTERFACE_DEFINED__ */


#ifndef __IVdsLun2_INTERFACE_DEFINED__
#define __IVdsLun2_INTERFACE_DEFINED__

/* interface IVdsLun2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLun2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e5b3a735-9efb-499a-8071-4394d9ee6fcb")
    IVdsLun2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHints2( 
            /* [out] */ __RPC__out VDS_HINTS2 *pHints2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ApplyHints2( 
            /* [in] */ __RPC__in VDS_HINTS2 *pHints2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLun2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLun2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLun2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLun2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHints2 )( 
            __RPC__in IVdsLun2 * This,
            /* [out] */ __RPC__out VDS_HINTS2 *pHints2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ApplyHints2 )( 
            __RPC__in IVdsLun2 * This,
            /* [in] */ __RPC__in VDS_HINTS2 *pHints2);
        
        END_INTERFACE
    } IVdsLun2Vtbl;

    interface IVdsLun2
    {
        CONST_VTBL struct IVdsLun2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLun2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLun2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLun2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLun2_QueryHints2(This,pHints2)	\
    ( (This)->lpVtbl -> QueryHints2(This,pHints2) ) 

#define IVdsLun2_ApplyHints2(This,pHints2)	\
    ( (This)->lpVtbl -> ApplyHints2(This,pHints2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLun2_INTERFACE_DEFINED__ */


#ifndef __IVdsLunNaming_INTERFACE_DEFINED__
#define __IVdsLunNaming_INTERFACE_DEFINED__

/* interface IVdsLunNaming */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunNaming;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("907504cb-6b4e-4d88-a34d-17ba661fbb06")
    IVdsLunNaming : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunNamingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunNaming * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunNaming * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunNaming * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            __RPC__in IVdsLunNaming * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName);
        
        END_INTERFACE
    } IVdsLunNamingVtbl;

    interface IVdsLunNaming
    {
        CONST_VTBL struct IVdsLunNamingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunNaming_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunNaming_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunNaming_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunNaming_SetFriendlyName(This,pwszFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwszFriendlyName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunNaming_INTERFACE_DEFINED__ */


#ifndef __IVdsLunNumber_INTERFACE_DEFINED__
#define __IVdsLunNumber_INTERFACE_DEFINED__

/* interface IVdsLunNumber */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunNumber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d3f95e46-54b3-41f9-b678-0f1871443a08")
    IVdsLunNumber : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLunNumber( 
            /* [out] */ __RPC__out ULONG *pulLunNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunNumberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunNumber * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunNumber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunNumber * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLunNumber )( 
            __RPC__in IVdsLunNumber * This,
            /* [out] */ __RPC__out ULONG *pulLunNumber);
        
        END_INTERFACE
    } IVdsLunNumberVtbl;

    interface IVdsLunNumber
    {
        CONST_VTBL struct IVdsLunNumberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunNumber_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunNumber_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunNumber_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunNumber_GetLunNumber(This,pulLunNumber)	\
    ( (This)->lpVtbl -> GetLunNumber(This,pulLunNumber) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunNumber_INTERFACE_DEFINED__ */


#ifndef __IVdsLunControllerPorts_INTERFACE_DEFINED__
#define __IVdsLunControllerPorts_INTERFACE_DEFINED__

/* interface IVdsLunControllerPorts */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunControllerPorts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("451fe266-da6d-406a-bb60-82e534f85aeb")
    IVdsLunControllerPorts : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssociateControllerPorts( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllerPorts) VDS_OBJECT_ID *pActiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfActiveControllerPorts,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllerPorts) VDS_OBJECT_ID *pInactiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfInactiveControllerPorts) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryActiveControllerPorts( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunControllerPortsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunControllerPorts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunControllerPorts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunControllerPorts * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssociateControllerPorts )( 
            __RPC__in IVdsLunControllerPorts * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllerPorts) VDS_OBJECT_ID *pActiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfActiveControllerPorts,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllerPorts) VDS_OBJECT_ID *pInactiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfInactiveControllerPorts);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryActiveControllerPorts )( 
            __RPC__in IVdsLunControllerPorts * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsLunControllerPortsVtbl;

    interface IVdsLunControllerPorts
    {
        CONST_VTBL struct IVdsLunControllerPortsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunControllerPorts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunControllerPorts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunControllerPorts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunControllerPorts_AssociateControllerPorts(This,pActiveControllerPortIdArray,lNumberOfActiveControllerPorts,pInactiveControllerPortIdArray,lNumberOfInactiveControllerPorts)	\
    ( (This)->lpVtbl -> AssociateControllerPorts(This,pActiveControllerPortIdArray,lNumberOfActiveControllerPorts,pInactiveControllerPortIdArray,lNumberOfInactiveControllerPorts) ) 

#define IVdsLunControllerPorts_QueryActiveControllerPorts(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryActiveControllerPorts(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunControllerPorts_INTERFACE_DEFINED__ */


#ifndef __IVdsLunMpio_INTERFACE_DEFINED__
#define __IVdsLunMpio_INTERFACE_DEFINED__

/* interface IVdsLunMpio */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunMpio;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c5fbae3-333a-48a1-a982-33c15788cde3")
    IVdsLunMpio : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPathInfo( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_INFO **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLoadBalancePolicy( 
            /* [out] */ __RPC__out VDS_LOADBALANCE_POLICY_ENUM *pPolicy,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_POLICY **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetLoadBalancePolicy( 
            /* [in] */ VDS_LOADBALANCE_POLICY_ENUM policy,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfPaths) VDS_PATH_POLICY *pPaths,
            /* [in] */ LONG lNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSupportedLbPolicies( 
            /* [out] */ __RPC__out ULONG *pulLbFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunMpioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunMpio * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunMpio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunMpio * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPathInfo )( 
            __RPC__in IVdsLunMpio * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_INFO **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLoadBalancePolicy )( 
            __RPC__in IVdsLunMpio * This,
            /* [out] */ __RPC__out VDS_LOADBALANCE_POLICY_ENUM *pPolicy,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_POLICY **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetLoadBalancePolicy )( 
            __RPC__in IVdsLunMpio * This,
            /* [in] */ VDS_LOADBALANCE_POLICY_ENUM policy,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfPaths) VDS_PATH_POLICY *pPaths,
            /* [in] */ LONG lNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSupportedLbPolicies )( 
            __RPC__in IVdsLunMpio * This,
            /* [out] */ __RPC__out ULONG *pulLbFlags);
        
        END_INTERFACE
    } IVdsLunMpioVtbl;

    interface IVdsLunMpio
    {
        CONST_VTBL struct IVdsLunMpioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunMpio_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunMpio_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunMpio_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunMpio_GetPathInfo(This,ppPaths,plNumberOfPaths)	\
    ( (This)->lpVtbl -> GetPathInfo(This,ppPaths,plNumberOfPaths) ) 

#define IVdsLunMpio_GetLoadBalancePolicy(This,pPolicy,ppPaths,plNumberOfPaths)	\
    ( (This)->lpVtbl -> GetLoadBalancePolicy(This,pPolicy,ppPaths,plNumberOfPaths) ) 

#define IVdsLunMpio_SetLoadBalancePolicy(This,policy,pPaths,lNumberOfPaths)	\
    ( (This)->lpVtbl -> SetLoadBalancePolicy(This,policy,pPaths,lNumberOfPaths) ) 

#define IVdsLunMpio_GetSupportedLbPolicies(This,pulLbFlags)	\
    ( (This)->lpVtbl -> GetSupportedLbPolicies(This,pulLbFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunMpio_INTERFACE_DEFINED__ */


#ifndef __IVdsLunIscsi_INTERFACE_DEFINED__
#define __IVdsLunIscsi_INTERFACE_DEFINED__

/* interface IVdsLunIscsi */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunIscsi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d7c1e64-b59b-45ae-b86a-2c2cc6a42067")
    IVdsLunIscsi : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssociateTargets( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfTargets) VDS_OBJECT_ID *pTargetIdArray,
            /* [in] */ LONG lNumberOfTargets) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedTargets( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunIscsiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunIscsi * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunIscsi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunIscsi * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssociateTargets )( 
            __RPC__in IVdsLunIscsi * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfTargets) VDS_OBJECT_ID *pTargetIdArray,
            /* [in] */ LONG lNumberOfTargets);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedTargets )( 
            __RPC__in IVdsLunIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsLunIscsiVtbl;

    interface IVdsLunIscsi
    {
        CONST_VTBL struct IVdsLunIscsiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunIscsi_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunIscsi_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunIscsi_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunIscsi_AssociateTargets(This,pTargetIdArray,lNumberOfTargets)	\
    ( (This)->lpVtbl -> AssociateTargets(This,pTargetIdArray,lNumberOfTargets) ) 

#define IVdsLunIscsi_QueryAssociatedTargets(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedTargets(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunIscsi_INTERFACE_DEFINED__ */


#ifndef __IVdsLunPlex_INTERFACE_DEFINED__
#define __IVdsLunPlex_INTERFACE_DEFINED__

/* interface IVdsLunPlex */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunPlex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0ee1a790-5d2e-4abb-8c99-c481e8be2138")
    IVdsLunPlex : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_LUN_PLEX_PROP *pPlexProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLun( 
            /* [out] */ __RPC__deref_out_opt IVdsLun **ppLun) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHints( 
            /* [out] */ __RPC__out VDS_HINTS *pHints) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ApplyHints( 
            /* [in] */ __RPC__in VDS_HINTS *pHints) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunPlexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunPlex * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunPlex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunPlex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsLunPlex * This,
            /* [out] */ __RPC__out VDS_LUN_PLEX_PROP *pPlexProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLun )( 
            __RPC__in IVdsLunPlex * This,
            /* [out] */ __RPC__deref_out_opt IVdsLun **ppLun);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            __RPC__in IVdsLunPlex * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHints )( 
            __RPC__in IVdsLunPlex * This,
            /* [out] */ __RPC__out VDS_HINTS *pHints);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ApplyHints )( 
            __RPC__in IVdsLunPlex * This,
            /* [in] */ __RPC__in VDS_HINTS *pHints);
        
        END_INTERFACE
    } IVdsLunPlexVtbl;

    interface IVdsLunPlex
    {
        CONST_VTBL struct IVdsLunPlexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunPlex_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunPlex_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunPlex_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunPlex_GetProperties(This,pPlexProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPlexProp) ) 

#define IVdsLunPlex_GetLun(This,ppLun)	\
    ( (This)->lpVtbl -> GetLun(This,ppLun) ) 

#define IVdsLunPlex_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsLunPlex_QueryHints(This,pHints)	\
    ( (This)->lpVtbl -> QueryHints(This,pHints) ) 

#define IVdsLunPlex_ApplyHints(This,pHints)	\
    ( (This)->lpVtbl -> ApplyHints(This,pHints) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunPlex_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiPortal_INTERFACE_DEFINED__
#define __IVdsIscsiPortal_INTERFACE_DEFINED__

/* interface IVdsIscsiPortal */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiPortal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7fa1499d-ec85-4a8a-a47b-ff69201fcd34")
    IVdsIscsiPortal : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_PORTAL_PROP *pPortalProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedPortalGroups( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_ISCSI_PORTAL_STATUS status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecTunnelAddress( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIpsecSecurity( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecSecurity( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiPortalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiPortal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiPortal * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [out] */ __RPC__out VDS_ISCSI_PORTAL_PROP *pPortalProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedPortalGroups )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ VDS_ISCSI_PORTAL_STATUS status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecTunnelAddress )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIpsecSecurity )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecSecurity )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsIscsiPortalVtbl;

    interface IVdsIscsiPortal
    {
        CONST_VTBL struct IVdsIscsiPortalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiPortal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiPortal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiPortal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiPortal_GetProperties(This,pPortalProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPortalProp) ) 

#define IVdsIscsiPortal_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsIscsiPortal_QueryAssociatedPortalGroups(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedPortalGroups(This,ppEnum) ) 

#define IVdsIscsiPortal_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#define IVdsIscsiPortal_SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress)	\
    ( (This)->lpVtbl -> SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress) ) 

#define IVdsIscsiPortal_GetIpsecSecurity(This,pInitiatorPortalAddress,pullSecurityFlags)	\
    ( (This)->lpVtbl -> GetIpsecSecurity(This,pInitiatorPortalAddress,pullSecurityFlags) ) 

#define IVdsIscsiPortal_SetIpsecSecurity(This,pInitiatorPortalAddress,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecSecurity(This,pInitiatorPortalAddress,ullSecurityFlags,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiPortal_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiTarget_INTERFACE_DEFINED__
#define __IVdsIscsiTarget_INTERFACE_DEFINED__

/* interface IVdsIscsiTarget */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa8f5055-83e5-4bcc-aa73-19851a36a849")
    IVdsIscsiTarget : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_TARGET_PROP *pTargetProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPortalGroups( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePortalGroup( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSharedSecret( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszInitiatorName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RememberInitiatorSharedSecret( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszInitiatorName,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetConnectedInitiators( 
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfInitiators) LPWSTR **pppwszInitiatorList,
            /* [out] */ __RPC__out LONG *plNumberOfInitiators) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiTarget * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__out VDS_ISCSI_TARGET_PROP *pTargetProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPortalGroups )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedLuns )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePortalGroup )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSharedSecret )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszInitiatorName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RememberInitiatorSharedSecret )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszInitiatorName,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetConnectedInitiators )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfInitiators) LPWSTR **pppwszInitiatorList,
            /* [out] */ __RPC__out LONG *plNumberOfInitiators);
        
        END_INTERFACE
    } IVdsIscsiTargetVtbl;

    interface IVdsIscsiTarget
    {
        CONST_VTBL struct IVdsIscsiTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiTarget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiTarget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiTarget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiTarget_GetProperties(This,pTargetProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pTargetProp) ) 

#define IVdsIscsiTarget_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsIscsiTarget_QueryPortalGroups(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPortalGroups(This,ppEnum) ) 

#define IVdsIscsiTarget_QueryAssociatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedLuns(This,ppEnum) ) 

#define IVdsIscsiTarget_CreatePortalGroup(This,ppAsync)	\
    ( (This)->lpVtbl -> CreatePortalGroup(This,ppAsync) ) 

#define IVdsIscsiTarget_Delete(This,ppAsync)	\
    ( (This)->lpVtbl -> Delete(This,ppAsync) ) 

#define IVdsIscsiTarget_SetFriendlyName(This,pwszFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwszFriendlyName) ) 

#define IVdsIscsiTarget_SetSharedSecret(This,pTargetSharedSecret,pwszInitiatorName)	\
    ( (This)->lpVtbl -> SetSharedSecret(This,pTargetSharedSecret,pwszInitiatorName) ) 

#define IVdsIscsiTarget_RememberInitiatorSharedSecret(This,pwszInitiatorName,pInitiatorSharedSecret)	\
    ( (This)->lpVtbl -> RememberInitiatorSharedSecret(This,pwszInitiatorName,pInitiatorSharedSecret) ) 

#define IVdsIscsiTarget_GetConnectedInitiators(This,pppwszInitiatorList,plNumberOfInitiators)	\
    ( (This)->lpVtbl -> GetConnectedInitiators(This,pppwszInitiatorList,plNumberOfInitiators) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiTarget_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiPortalGroup_INTERFACE_DEFINED__
#define __IVdsIscsiPortalGroup_INTERFACE_DEFINED__

/* interface IVdsIscsiPortalGroup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiPortalGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fef5f89d-a3dd-4b36-bf28-e7dde045c593")
    IVdsIscsiPortalGroup : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_PORTALGROUP_PROP *pPortalGroupProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTarget( 
            /* [out] */ __RPC__deref_out_opt IVdsIscsiTarget **ppTarget) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedPortals( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPortal( 
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePortal( 
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiPortalGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiPortalGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiPortalGroup * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__out VDS_ISCSI_PORTALGROUP_PROP *pPortalGroupProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTarget )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__deref_out_opt IVdsIscsiTarget **ppTarget);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedPortals )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPortal )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePortal )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsIscsiPortalGroupVtbl;

    interface IVdsIscsiPortalGroup
    {
        CONST_VTBL struct IVdsIscsiPortalGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiPortalGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiPortalGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiPortalGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiPortalGroup_GetProperties(This,pPortalGroupProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPortalGroupProp) ) 

#define IVdsIscsiPortalGroup_GetTarget(This,ppTarget)	\
    ( (This)->lpVtbl -> GetTarget(This,ppTarget) ) 

#define IVdsIscsiPortalGroup_QueryAssociatedPortals(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedPortals(This,ppEnum) ) 

#define IVdsIscsiPortalGroup_AddPortal(This,portalId,ppAsync)	\
    ( (This)->lpVtbl -> AddPortal(This,portalId,ppAsync) ) 

#define IVdsIscsiPortalGroup_RemovePortal(This,portalId,ppAsync)	\
    ( (This)->lpVtbl -> RemovePortal(This,portalId,ppAsync) ) 

#define IVdsIscsiPortalGroup_Delete(This,ppAsync)	\
    ( (This)->lpVtbl -> Delete(This,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiPortalGroup_INTERFACE_DEFINED__ */


#ifndef __IVdsStoragePool_INTERFACE_DEFINED__
#define __IVdsStoragePool_INTERFACE_DEFINED__

/* interface IVdsStoragePool */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsStoragePool;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("932ca8cf-0eb3-4ba8-9620-22665d7f8450")
    IVdsStoragePool : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_STORAGE_POOL_PROP *pStoragePoolProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ __RPC__out VDS_POOL_ATTRIBUTES *pStoragePoolAttributes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDriveExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_STORAGE_POOL_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAllocatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAllocatedStoragePools( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsStoragePoolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsStoragePool * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsStoragePool * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsStoragePool * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProvider )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__out VDS_STORAGE_POOL_PROP *pStoragePoolProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__out VDS_POOL_ATTRIBUTES *pStoragePoolAttributes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDriveExtents )( 
            __RPC__in IVdsStoragePool * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_STORAGE_POOL_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAllocatedLuns )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAllocatedStoragePools )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsStoragePoolVtbl;

    interface IVdsStoragePool
    {
        CONST_VTBL struct IVdsStoragePoolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsStoragePool_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsStoragePool_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsStoragePool_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsStoragePool_GetProvider(This,ppProvider)	\
    ( (This)->lpVtbl -> GetProvider(This,ppProvider) ) 

#define IVdsStoragePool_GetProperties(This,pStoragePoolProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pStoragePoolProp) ) 

#define IVdsStoragePool_GetAttributes(This,pStoragePoolAttributes)	\
    ( (This)->lpVtbl -> GetAttributes(This,pStoragePoolAttributes) ) 

#define IVdsStoragePool_QueryDriveExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryDriveExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsStoragePool_QueryAllocatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAllocatedLuns(This,ppEnum) ) 

#define IVdsStoragePool_QueryAllocatedStoragePools(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAllocatedStoragePools(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsStoragePool_INTERFACE_DEFINED__ */


#ifndef __IVdsMaintenance_INTERFACE_DEFINED__
#define __IVdsMaintenance_INTERFACE_DEFINED__

/* interface IVdsMaintenance */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsMaintenance;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("daebeef3-8523-47ed-a2b9-05cecce2a1ae")
    IVdsMaintenance : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartMaintenance( 
            /* [in] */ VDS_MAINTENANCE_OPERATION operation) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StopMaintenance( 
            /* [in] */ VDS_MAINTENANCE_OPERATION operation) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PulseMaintenance( 
            /* [in] */ VDS_MAINTENANCE_OPERATION operation,
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsMaintenanceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsMaintenance * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsMaintenance * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsMaintenance * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StartMaintenance )( 
            __RPC__in IVdsMaintenance * This,
            /* [in] */ VDS_MAINTENANCE_OPERATION operation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StopMaintenance )( 
            __RPC__in IVdsMaintenance * This,
            /* [in] */ VDS_MAINTENANCE_OPERATION operation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PulseMaintenance )( 
            __RPC__in IVdsMaintenance * This,
            /* [in] */ VDS_MAINTENANCE_OPERATION operation,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IVdsMaintenanceVtbl;

    interface IVdsMaintenance
    {
        CONST_VTBL struct IVdsMaintenanceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsMaintenance_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsMaintenance_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsMaintenance_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsMaintenance_StartMaintenance(This,operation)	\
    ( (This)->lpVtbl -> StartMaintenance(This,operation) ) 

#define IVdsMaintenance_StopMaintenance(This,operation)	\
    ( (This)->lpVtbl -> StopMaintenance(This,operation) ) 

#define IVdsMaintenance_PulseMaintenance(This,operation,ulCount)	\
    ( (This)->lpVtbl -> PulseMaintenance(This,operation,ulCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsMaintenance_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vdshwprv_0000_0033 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_vdshwprv_0000_0033_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdshwprv_0000_0033_v0_0_s_ifspec;

#ifndef __IVdsHwProviderPrivate_INTERFACE_DEFINED__
#define __IVdsHwProviderPrivate_INTERFACE_DEFINED__

/* interface IVdsHwProviderPrivate */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProviderPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98f17bf3-9f33-4f12-8714-8b4075092c2e")
    IVdsHwProviderPrivate : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryIfCreatedLun( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszDevicePath,
            /* [in] */ __RPC__in VDS_LUN_INFORMATION *pVdsLunInformation,
            /* [out] */ __RPC__out VDS_OBJECT_ID *pLunId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProviderPrivate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProviderPrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProviderPrivate * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryIfCreatedLun )( 
            __RPC__in IVdsHwProviderPrivate * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszDevicePath,
            /* [in] */ __RPC__in VDS_LUN_INFORMATION *pVdsLunInformation,
            /* [out] */ __RPC__out VDS_OBJECT_ID *pLunId);
        
        END_INTERFACE
    } IVdsHwProviderPrivateVtbl;

    interface IVdsHwProviderPrivate
    {
        CONST_VTBL struct IVdsHwProviderPrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProviderPrivate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProviderPrivate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProviderPrivate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProviderPrivate_QueryIfCreatedLun(This,pwszDevicePath,pVdsLunInformation,pLunId)	\
    ( (This)->lpVtbl -> QueryIfCreatedLun(This,pwszDevicePath,pVdsLunInformation,pLunId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProviderPrivate_INTERFACE_DEFINED__ */


#ifndef __IVdsHwProviderPrivateMpio_INTERFACE_DEFINED__
#define __IVdsHwProviderPrivateMpio_INTERFACE_DEFINED__

/* interface IVdsHwProviderPrivateMpio */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProviderPrivateMpio;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("310a7715-ac2b-4c6f-9827-3d742f351676")
    IVdsHwProviderPrivateMpio : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAllPathStatusesFromHbaPort( 
            /* [in] */ VDS_HBAPORT_PROP hbaPortProp,
            /* [in] */ VDS_PATH_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderPrivateMpioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProviderPrivateMpio * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProviderPrivateMpio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProviderPrivateMpio * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAllPathStatusesFromHbaPort )( 
            __RPC__in IVdsHwProviderPrivateMpio * This,
            /* [in] */ VDS_HBAPORT_PROP hbaPortProp,
            /* [in] */ VDS_PATH_STATUS status);
        
        END_INTERFACE
    } IVdsHwProviderPrivateMpioVtbl;

    interface IVdsHwProviderPrivateMpio
    {
        CONST_VTBL struct IVdsHwProviderPrivateMpioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProviderPrivateMpio_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProviderPrivateMpio_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProviderPrivateMpio_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProviderPrivateMpio_SetAllPathStatusesFromHbaPort(This,hbaPortProp,status)	\
    ( (This)->lpVtbl -> SetAllPathStatusesFromHbaPort(This,hbaPortProp,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProviderPrivateMpio_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vdshwprv_0000_0035 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_vdshwprv_0000_0035_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdshwprv_0000_0035_v0_0_s_ifspec;

#ifndef __IVdsAdmin_INTERFACE_DEFINED__
#define __IVdsAdmin_INTERFACE_DEFINED__

/* interface IVdsAdmin */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d188e97d-85aa-4d33-abc6-26299a10ffc1")
    IVdsAdmin : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterProvider( 
            /* [in] */ VDS_OBJECT_ID providerId,
            /* [in] */ CLSID providerClsid,
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( 200 + 1 ) ) LPWSTR pwszName,
            /* [in] */ VDS_PROVIDER_TYPE type,
            /* [disable_consistency_check][string][max_is][unique][in] */ __RPC__in_ecount_full_opt_string(( ( 15 - 1 )  + 1 ) ) LPWSTR pwszMachineName,
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( 16 + 1 ) ) LPWSTR pwszVersion,
            /* [in] */ GUID guidVersionId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterProvider( 
            /* [in] */ VDS_OBJECT_ID providerId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsAdmin * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsAdmin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterProvider )( 
            __RPC__in IVdsAdmin * This,
            /* [in] */ VDS_OBJECT_ID providerId,
            /* [in] */ CLSID providerClsid,
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( 200 + 1 ) ) LPWSTR pwszName,
            /* [in] */ VDS_PROVIDER_TYPE type,
            /* [disable_consistency_check][string][max_is][unique][in] */ __RPC__in_ecount_full_opt_string(( ( 15 - 1 )  + 1 ) ) LPWSTR pwszMachineName,
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( 16 + 1 ) ) LPWSTR pwszVersion,
            /* [in] */ GUID guidVersionId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterProvider )( 
            __RPC__in IVdsAdmin * This,
            /* [in] */ VDS_OBJECT_ID providerId);
        
        END_INTERFACE
    } IVdsAdminVtbl;

    interface IVdsAdmin
    {
        CONST_VTBL struct IVdsAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAdmin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAdmin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAdmin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAdmin_RegisterProvider(This,providerId,providerClsid,pwszName,type,pwszMachineName,pwszVersion,guidVersionId)	\
    ( (This)->lpVtbl -> RegisterProvider(This,providerId,providerClsid,pwszName,type,pwszMachineName,pwszVersion,guidVersionId) ) 

#define IVdsAdmin_UnregisterProvider(This,providerId)	\
    ( (This)->lpVtbl -> UnregisterProvider(This,providerId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAdmin_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\VerError.h ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
/**************************************************************************************
 **                                                                                  **
 ** Vererror.h - definitions of data structures, needed to report verifier errors.   **
 **                                                                                  **
 **************************************************************************************/

#ifndef __VERERROR_h__
#define __VERERROR_h__

#ifndef _VER_RAW_STRUCT_FOR_IDL_
#ifndef _JIT64_PEV_
#include "corhdr.h"
#include "openum.h"
#include "corerror.h"
#endif // !_JIT64_PEV_

// Set these flags if the error info fields are valid.

#define VER_ERR_FATAL		0x80000000L	// Cannot Continue
#define VER_ERR_OFFSET		0x00000001L
#define VER_ERR_OPCODE	  	0x00000002L
#define VER_ERR_OPERAND		0x00000004L
#define VER_ERR_TOKEN		0x00000008L
#define VER_ERR_EXCEP_NUM_1	0x00000010L
#define VER_ERR_EXCEP_NUM_2	0x00000020L
#define VER_ERR_STACK_SLOT  0x00000040L
#define VER_ERR_ITEM_1      0x00000080L
#define VER_ERR_ITEM_2      0x00000100L
#define VER_ERR_ITEM_F      0x00000200L
#define VER_ERR_ITEM_E      0x00000400L
#define VER_ERR_TYPE_1      0x00000800L
#define VER_ERR_TYPE_2      0x00001000L
#define VER_ERR_TYPE_F      0x00002000L
#define VER_ERR_TYPE_E      0x00004000L
#define VER_ERR_ADDL_MSG    0x00008000L

#define VER_ERR_SIG_MASK	0x07000000L	// Enum
#define VER_ERR_METHOD_SIG 	0x01000000L
#define VER_ERR_LOCAL_SIG  	0x02000000L
#define VER_ERR_FIELD_SIG	0x03000000L
#define VER_ERR_CALL_SIG	0x04000000L

#define VER_ERR_OPCODE_OFFSET (VER_ERR_OPCODE|VER_ERR_OFFSET)

#define VER_ERR_LOCAL_VAR   VER_ERR_LOCAL_SIG
#define VER_ERR_ARGUMENT    VER_ERR_METHOD_SIG

#define VER_ERR_ARG_RET	    0xFFFFFFFEL		// The Argument # is return
#define VER_ERR_NO_ARG	    0xFFFFFFFFL		// Argument # is not valid
#define VER_ERR_NO_LOC	    VER_ERR_NO_ARG	// Local # is not valid

typedef struct
{
	DWORD dwFlags;	// BYREF / BOXED etc.. see veritem.hpp
	void* pv;		// TypeHandle / MethodDesc * etc.
} _VerItem;

// This structure is used to fully define a verification error.
// Verification error codes are found in CorError.h
// The error resource strings are found in src/dlls/mscorrc/mscor.rc

typedef struct VerErrorStruct
{
	DWORD   dwFlags;            // VER_ERR_XXX

    union {
#ifndef _JIT64_PEV_
        OPCODE  opcode;
#endif // !_JIT64_PEV_
        unsigned long padding1; // to match with idl generated struct size
    };

    union {
        DWORD   dwOffset;       // #of bytes from start of method
        long    uOffset;        // for backward compat with Metadata validator
    };

    union {
        mdToken         token;
        mdToken         Token;  // for backward compat with metadata validator
        BYTE	        bCallConv;
        CorElementType  elem;
        DWORD           dwStackSlot; // positon in the Stack
        unsigned long   padding2;    // to match with idl generated struct size
    };

    union {
        _VerItem sItem1;
        _VerItem sItemFound;
        WCHAR* wszType1;
        WCHAR* wszTypeFound;
        DWORD dwException1;		// Exception Record #
        DWORD dwVarNumber;	    // Variable #
        DWORD dwArgNumber;	    // Argument #
        DWORD dwOperand;        // Operand for the opcode
        WCHAR* wszAdditionalMessage; // message from getlasterror
    };

    union {
        _VerItem sItem2;
        _VerItem sItemExpected;
        WCHAR* wszType2;
        WCHAR* wszTypeExpected;
        DWORD dwException2;	        // Exception Record #
    };

} VerError;

#else

// Assert that sizeof(_VerError) == sizeof(VerError) in Verifier.cpp
typedef struct tag_VerError
{
    unsigned long flags;            // DWORD
    unsigned long opcode;           // OPCODE, padded to ulong
    unsigned long uOffset;           // DWORD
    unsigned long Token;            // mdToken
    unsigned long item1_flags;      // _VerItem.DWORD
    int           *item1_data;      // _VerItem.PVOID
    unsigned long item2_flags;      // _VerItem.DWORD
    int           *item2_data;      // _VerItem.PVOID
}  _VerError;
#endif

#endif  // __VERERROR_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vpnotify.h ===
//------------------------------------------------------------------------------
// File: VPNotify.h
//
// Desc: 
//
// Copyright (c) 1997 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __IVPNotify__
#define __IVPNotify__

#ifdef __cplusplus
extern "C" {
#endif

// interface IVPBaseNotify
DECLARE_INTERFACE_(IVPBaseNotify, IUnknown)
{
public:
	// this function initializes the reconnection to the decoder. 
	STDMETHOD (RenegotiateVPParameters)(THIS_
					   ) PURE;

};

// interface IVPNotify
DECLARE_INTERFACE_(IVPNotify, IVPBaseNotify)
{
public:
    // function to set the mode (bob, weave etc)
    STDMETHOD (SetDeinterlaceMode)(THIS_ 
				   IN AMVP_MODE mode
				  ) PURE;

    // function to get the mode (bob, weave etc)
    STDMETHOD (GetDeinterlaceMode)(THIS_ 
				   OUT AMVP_MODE *pMode
				  ) PURE;
};

// interface IVPNotify
DECLARE_INTERFACE_(IVPNotify2, IVPNotify)
{
public:
// function to set the mode (bob, weave etc)
    STDMETHOD (SetVPSyncMaster)(THIS_ 
				   IN BOOL bVPSyncMaster
				  ) PURE;

    // function to get the mode (bob, weave etc)
    STDMETHOD (GetVPSyncMaster)(THIS_ 
				   OUT BOOL *pbVPSyncMaster
				  ) PURE;

    /*
    // this function sets the directdraw surface that the mixer is supposed to use.
    STDMETHOD (SetDirectDrawSurface)(THIS_ 
				  IN LPDIRECTDRAWSURFACE pDirectDrawSurface
				 ) PURE;

    // this function gets the directdraw surface that the mixer is using
    STDMETHOD (GetDirectDrawSurface)(THIS_ 
				  OUT LPDIRECTDRAWSURFACE *ppDirectDrawSurface
				 ) PURE;

    // this functions sets the color-controls, if the chip supports it.
    STDMETHOD (SetVPColorControls)(THIS_ 
				 IN LPDDCOLORCONTROL pColorControl
				) PURE;

    // this functions also returns the capability of the hardware in the dwFlags
    // value of the struct.
    STDMETHOD (GetVPColorControls)(THIS_ 
				 OUT LPDDCOLORCONTROL *ppColorControl
				) PURE;
    */
};


// interface IVPVBINotify
DECLARE_INTERFACE_(IVPVBINotify, IVPBaseNotify)
{
public:
};

#ifdef __cplusplus
}
#endif


#endif // __IVPNotify__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vfwmsgs.h ===
// no longer used  - but might get
 // our own facility in the future?
 // FacilityNames=(FACILITY_VFW=0x4)
 // To add a message:
 //
 // The MessageId is the number of the message.
 // Accepted severities are 'Success' and 'Warning'.
 //
 // Facility should be FACILITY_ITF (was FACILITY_VFW).
 //
 // The SymbolicName is the name used in the code to identify the message.
 // The text of a message starts the line after 'Language=' and
 // ends before a line with only a '.' in column one.
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: VFW_E_INVALIDMEDIATYPE
//
// MessageText:
//
// An invalid media type was specified.%0
//
#define VFW_E_INVALIDMEDIATYPE           ((HRESULT)0x80040200L)

//
// MessageId: VFW_E_INVALIDSUBTYPE
//
// MessageText:
//
// An invalid media subtype was specified.%0
//
#define VFW_E_INVALIDSUBTYPE             ((HRESULT)0x80040201L)

//
// MessageId: VFW_E_NEED_OWNER
//
// MessageText:
//
// This object can only be created as an aggregated object.%0
//
#define VFW_E_NEED_OWNER                 ((HRESULT)0x80040202L)

//
// MessageId: VFW_E_ENUM_OUT_OF_SYNC
//
// MessageText:
//
// The enumerator has become invalid.%0
//
#define VFW_E_ENUM_OUT_OF_SYNC           ((HRESULT)0x80040203L)

//
// MessageId: VFW_E_ALREADY_CONNECTED
//
// MessageText:
//
// At least one of the pins involved in the operation is already connected.%0
//
#define VFW_E_ALREADY_CONNECTED          ((HRESULT)0x80040204L)

//
// MessageId: VFW_E_FILTER_ACTIVE
//
// MessageText:
//
// This operation cannot be performed because the filter is active.%0
//
#define VFW_E_FILTER_ACTIVE              ((HRESULT)0x80040205L)

//
// MessageId: VFW_E_NO_TYPES
//
// MessageText:
//
// One of the specified pins supports no media types.%0
//
#define VFW_E_NO_TYPES                   ((HRESULT)0x80040206L)

//
// MessageId: VFW_E_NO_ACCEPTABLE_TYPES
//
// MessageText:
//
// There is no common media type between these pins.%0
//
#define VFW_E_NO_ACCEPTABLE_TYPES        ((HRESULT)0x80040207L)

//
// MessageId: VFW_E_INVALID_DIRECTION
//
// MessageText:
//
// Two pins of the same direction cannot be connected together.%0
//
#define VFW_E_INVALID_DIRECTION          ((HRESULT)0x80040208L)

//
// MessageId: VFW_E_NOT_CONNECTED
//
// MessageText:
//
// The operation cannot be performed because the pins are not connected.%0
//
#define VFW_E_NOT_CONNECTED              ((HRESULT)0x80040209L)

//
// MessageId: VFW_E_NO_ALLOCATOR
//
// MessageText:
//
// No sample buffer allocator is available.%0
//
#define VFW_E_NO_ALLOCATOR               ((HRESULT)0x8004020AL)

//
// MessageId: VFW_E_RUNTIME_ERROR
//
// MessageText:
//
// A run-time error occurred.%0
//
#define VFW_E_RUNTIME_ERROR              ((HRESULT)0x8004020BL)

//
// MessageId: VFW_E_BUFFER_NOTSET
//
// MessageText:
//
// No buffer space has been set.%0
//
#define VFW_E_BUFFER_NOTSET              ((HRESULT)0x8004020CL)

//
// MessageId: VFW_E_BUFFER_OVERFLOW
//
// MessageText:
//
// The buffer is not big enough.%0
//
#define VFW_E_BUFFER_OVERFLOW            ((HRESULT)0x8004020DL)

//
// MessageId: VFW_E_BADALIGN
//
// MessageText:
//
// An invalid alignment was specified.%0
//
#define VFW_E_BADALIGN                   ((HRESULT)0x8004020EL)

//
// MessageId: VFW_E_ALREADY_COMMITTED
//
// MessageText:
//
// Cannot change allocated memory while the filter is active.%0
//
#define VFW_E_ALREADY_COMMITTED          ((HRESULT)0x8004020FL)

//
// MessageId: VFW_E_BUFFERS_OUTSTANDING
//
// MessageText:
//
// One or more buffers are still active.%0
//
#define VFW_E_BUFFERS_OUTSTANDING        ((HRESULT)0x80040210L)

//
// MessageId: VFW_E_NOT_COMMITTED
//
// MessageText:
//
// Cannot allocate a sample when the allocator is not active.%0
//
#define VFW_E_NOT_COMMITTED              ((HRESULT)0x80040211L)

//
// MessageId: VFW_E_SIZENOTSET
//
// MessageText:
//
// Cannot allocate memory because no size has been set.%0
//
#define VFW_E_SIZENOTSET                 ((HRESULT)0x80040212L)

//
// MessageId: VFW_E_NO_CLOCK
//
// MessageText:
//
// Cannot lock for synchronization because no clock has been defined.%0
//
#define VFW_E_NO_CLOCK                   ((HRESULT)0x80040213L)

//
// MessageId: VFW_E_NO_SINK
//
// MessageText:
//
// Quality messages could not be sent because no quality sink has been defined.%0
//
#define VFW_E_NO_SINK                    ((HRESULT)0x80040214L)

//
// MessageId: VFW_E_NO_INTERFACE
//
// MessageText:
//
// A required interface has not been implemented.%0
//
#define VFW_E_NO_INTERFACE               ((HRESULT)0x80040215L)

//
// MessageId: VFW_E_NOT_FOUND
//
// MessageText:
//
// An object or name was not found.%0
//
#define VFW_E_NOT_FOUND                  ((HRESULT)0x80040216L)

//
// MessageId: VFW_E_CANNOT_CONNECT
//
// MessageText:
//
// No combination of intermediate filters could be found to make the connection.%0
//
#define VFW_E_CANNOT_CONNECT             ((HRESULT)0x80040217L)

//
// MessageId: VFW_E_CANNOT_RENDER
//
// MessageText:
//
// No combination of filters could be found to render the stream.%0
//
#define VFW_E_CANNOT_RENDER              ((HRESULT)0x80040218L)

//
// MessageId: VFW_E_CHANGING_FORMAT
//
// MessageText:
//
// Could not change formats dynamically.%0
//
#define VFW_E_CHANGING_FORMAT            ((HRESULT)0x80040219L)

//
// MessageId: VFW_E_NO_COLOR_KEY_SET
//
// MessageText:
//
// No color key has been set.%0
//
#define VFW_E_NO_COLOR_KEY_SET           ((HRESULT)0x8004021AL)

//
// MessageId: VFW_E_NOT_OVERLAY_CONNECTION
//
// MessageText:
//
// Current pin connection is not using the IOverlay transport.%0
//
#define VFW_E_NOT_OVERLAY_CONNECTION     ((HRESULT)0x8004021BL)

//
// MessageId: VFW_E_NOT_SAMPLE_CONNECTION
//
// MessageText:
//
// Current pin connection is not using the IMemInputPin transport.%0
//
#define VFW_E_NOT_SAMPLE_CONNECTION      ((HRESULT)0x8004021CL)

//
// MessageId: VFW_E_PALETTE_SET
//
// MessageText:
//
// Setting a color key would conflict with the palette already set.%0
//
#define VFW_E_PALETTE_SET                ((HRESULT)0x8004021DL)

//
// MessageId: VFW_E_COLOR_KEY_SET
//
// MessageText:
//
// Setting a palette would conflict with the color key already set.%0
//
#define VFW_E_COLOR_KEY_SET              ((HRESULT)0x8004021EL)

//
// MessageId: VFW_E_NO_COLOR_KEY_FOUND
//
// MessageText:
//
// No matching color key is available.%0
//
#define VFW_E_NO_COLOR_KEY_FOUND         ((HRESULT)0x8004021FL)

//
// MessageId: VFW_E_NO_PALETTE_AVAILABLE
//
// MessageText:
//
// No palette is available.%0
//
#define VFW_E_NO_PALETTE_AVAILABLE       ((HRESULT)0x80040220L)

//
// MessageId: VFW_E_NO_DISPLAY_PALETTE
//
// MessageText:
//
// Display does not use a palette.%0
//
#define VFW_E_NO_DISPLAY_PALETTE         ((HRESULT)0x80040221L)

//
// MessageId: VFW_E_TOO_MANY_COLORS
//
// MessageText:
//
// Too many colors for the current display settings.%0
//
#define VFW_E_TOO_MANY_COLORS            ((HRESULT)0x80040222L)

//
// MessageId: VFW_E_STATE_CHANGED
//
// MessageText:
//
// The state changed while waiting to process the sample.%0
//
#define VFW_E_STATE_CHANGED              ((HRESULT)0x80040223L)

//
// MessageId: VFW_E_NOT_STOPPED
//
// MessageText:
//
// The operation could not be performed because the filter is not stopped.%0
//
#define VFW_E_NOT_STOPPED                ((HRESULT)0x80040224L)

//
// MessageId: VFW_E_NOT_PAUSED
//
// MessageText:
//
// The operation could not be performed because the filter is not paused.%0
//
#define VFW_E_NOT_PAUSED                 ((HRESULT)0x80040225L)

//
// MessageId: VFW_E_NOT_RUNNING
//
// MessageText:
//
// The operation could not be performed because the filter is not running.%0
//
#define VFW_E_NOT_RUNNING                ((HRESULT)0x80040226L)

//
// MessageId: VFW_E_WRONG_STATE
//
// MessageText:
//
// The operation could not be performed because the filter is in the wrong state.%0
//
#define VFW_E_WRONG_STATE                ((HRESULT)0x80040227L)

//
// MessageId: VFW_E_START_TIME_AFTER_END
//
// MessageText:
//
// The sample start time is after the sample end time.%0
//
#define VFW_E_START_TIME_AFTER_END       ((HRESULT)0x80040228L)

//
// MessageId: VFW_E_INVALID_RECT
//
// MessageText:
//
// The supplied rectangle is invalid.%0
//
#define VFW_E_INVALID_RECT               ((HRESULT)0x80040229L)

//
// MessageId: VFW_E_TYPE_NOT_ACCEPTED
//
// MessageText:
//
// This pin cannot use the supplied media type.%0
//
#define VFW_E_TYPE_NOT_ACCEPTED          ((HRESULT)0x8004022AL)

//
// MessageId: VFW_E_SAMPLE_REJECTED
//
// MessageText:
//
// This sample cannot be rendered.%0
//
#define VFW_E_SAMPLE_REJECTED            ((HRESULT)0x8004022BL)

//
// MessageId: VFW_E_SAMPLE_REJECTED_EOS
//
// MessageText:
//
// This sample cannot be rendered because the end of the stream has been reached.%0
//
#define VFW_E_SAMPLE_REJECTED_EOS        ((HRESULT)0x8004022CL)

//
// MessageId: VFW_E_DUPLICATE_NAME
//
// MessageText:
//
// An attempt to add a filter with a duplicate name failed.%0
//
#define VFW_E_DUPLICATE_NAME             ((HRESULT)0x8004022DL)

//
// MessageId: VFW_S_DUPLICATE_NAME
//
// MessageText:
//
// An attempt to add a filter with a duplicate name succeeded with a modified name.%0
//
#define VFW_S_DUPLICATE_NAME             ((HRESULT)0x0004022DL)

//
// MessageId: VFW_E_TIMEOUT
//
// MessageText:
//
// A time-out has expired.%0
//
#define VFW_E_TIMEOUT                    ((HRESULT)0x8004022EL)

//
// MessageId: VFW_E_INVALID_FILE_FORMAT
//
// MessageText:
//
// The file format is invalid.%0
//
#define VFW_E_INVALID_FILE_FORMAT        ((HRESULT)0x8004022FL)

//
// MessageId: VFW_E_ENUM_OUT_OF_RANGE
//
// MessageText:
//
// The list has already been exhausted.%0
//
#define VFW_E_ENUM_OUT_OF_RANGE          ((HRESULT)0x80040230L)

//
// MessageId: VFW_E_CIRCULAR_GRAPH
//
// MessageText:
//
// The filter graph is circular.%0
//
#define VFW_E_CIRCULAR_GRAPH             ((HRESULT)0x80040231L)

//
// MessageId: VFW_E_NOT_ALLOWED_TO_SAVE
//
// MessageText:
//
// Updates are not allowed in this state.%0
//
#define VFW_E_NOT_ALLOWED_TO_SAVE        ((HRESULT)0x80040232L)

//
// MessageId: VFW_E_TIME_ALREADY_PASSED
//
// MessageText:
//
// An attempt was made to queue a command for a time in the past.%0
//
#define VFW_E_TIME_ALREADY_PASSED        ((HRESULT)0x80040233L)

//
// MessageId: VFW_E_ALREADY_CANCELLED
//
// MessageText:
//
// The queued command has already been canceled.%0
//
#define VFW_E_ALREADY_CANCELLED          ((HRESULT)0x80040234L)

//
// MessageId: VFW_E_CORRUPT_GRAPH_FILE
//
// MessageText:
//
// Cannot render the file because it is corrupt.%0
//
#define VFW_E_CORRUPT_GRAPH_FILE         ((HRESULT)0x80040235L)

//
// MessageId: VFW_E_ADVISE_ALREADY_SET
//
// MessageText:
//
// An overlay advise link already exists.%0
//
#define VFW_E_ADVISE_ALREADY_SET         ((HRESULT)0x80040236L)

//
// MessageId: VFW_S_STATE_INTERMEDIATE
//
// MessageText:
//
// The state transition has not completed.%0
//
#define VFW_S_STATE_INTERMEDIATE         ((HRESULT)0x00040237L)

//
// MessageId: VFW_E_NO_MODEX_AVAILABLE
//
// MessageText:
//
// No full-screen modes are available.%0
//
#define VFW_E_NO_MODEX_AVAILABLE         ((HRESULT)0x80040238L)

//
// MessageId: VFW_E_NO_ADVISE_SET
//
// MessageText:
//
// This Advise cannot be canceled because it was not successfully set.%0
//
#define VFW_E_NO_ADVISE_SET              ((HRESULT)0x80040239L)

//
// MessageId: VFW_E_NO_FULLSCREEN
//
// MessageText:
//
// A full-screen mode is not available.%0
//
#define VFW_E_NO_FULLSCREEN              ((HRESULT)0x8004023AL)

//
// MessageId: VFW_E_IN_FULLSCREEN_MODE
//
// MessageText:
//
// Cannot call IVideoWindow methods while in full-screen mode.%0
//
#define VFW_E_IN_FULLSCREEN_MODE         ((HRESULT)0x8004023BL)

//
// MessageId: VFW_E_UNKNOWN_FILE_TYPE
//
// MessageText:
//
// The media type of this file is not recognized.%0
//
#define VFW_E_UNKNOWN_FILE_TYPE          ((HRESULT)0x80040240L)

//
// MessageId: VFW_E_CANNOT_LOAD_SOURCE_FILTER
//
// MessageText:
//
// The source filter for this file could not be loaded.%0
//
#define VFW_E_CANNOT_LOAD_SOURCE_FILTER  ((HRESULT)0x80040241L)

//
// MessageId: VFW_S_PARTIAL_RENDER
//
// MessageText:
//
// Some of the streams in this movie are in an unsupported format.%0
//
#define VFW_S_PARTIAL_RENDER             ((HRESULT)0x00040242L)

//
// MessageId: VFW_E_FILE_TOO_SHORT
//
// MessageText:
//
// A file appeared to be incomplete.%0
//
#define VFW_E_FILE_TOO_SHORT             ((HRESULT)0x80040243L)

//
// MessageId: VFW_E_INVALID_FILE_VERSION
//
// MessageText:
//
// The version number of the file is invalid.%0
//
#define VFW_E_INVALID_FILE_VERSION       ((HRESULT)0x80040244L)

//
// MessageId: VFW_S_SOME_DATA_IGNORED
//
// MessageText:
//
// The file contained some property settings that were not used.%0
//
#define VFW_S_SOME_DATA_IGNORED          ((HRESULT)0x00040245L)

//
// MessageId: VFW_S_CONNECTIONS_DEFERRED
//
// MessageText:
//
// Some connections have failed and have been deferred.%0
//
#define VFW_S_CONNECTIONS_DEFERRED       ((HRESULT)0x00040246L)

//
// MessageId: VFW_E_INVALID_CLSID
//
// MessageText:
//
// This file is corrupt: it contains an invalid class identifier.%0
//
#define VFW_E_INVALID_CLSID              ((HRESULT)0x80040247L)

//
// MessageId: VFW_E_INVALID_MEDIA_TYPE
//
// MessageText:
//
// This file is corrupt: it contains an invalid media type.%0
//
#define VFW_E_INVALID_MEDIA_TYPE         ((HRESULT)0x80040248L)

 // Message id from WINWarning.H
//
// MessageId: VFW_E_BAD_KEY
//
// MessageText:
//
// A registry entry is corrupt.%0
//
#define VFW_E_BAD_KEY                    ((HRESULT)0x800403F2L)

 // Message id from WINWarning.H
//
// MessageId: VFW_S_NO_MORE_ITEMS
//
// MessageText:
//
// The end of the list has been reached.%0
//
#define VFW_S_NO_MORE_ITEMS              ((HRESULT)0x00040103L)

//
// MessageId: VFW_E_SAMPLE_TIME_NOT_SET
//
// MessageText:
//
// No time stamp has been set for this sample.%0
//
#define VFW_E_SAMPLE_TIME_NOT_SET        ((HRESULT)0x80040249L)

//
// MessageId: VFW_S_RESOURCE_NOT_NEEDED
//
// MessageText:
//
// The resource specified is no longer needed.%0
//
#define VFW_S_RESOURCE_NOT_NEEDED        ((HRESULT)0x00040250L)

//
// MessageId: VFW_E_MEDIA_TIME_NOT_SET
//
// MessageText:
//
// No media time stamp has been set for this sample.%0
//
#define VFW_E_MEDIA_TIME_NOT_SET         ((HRESULT)0x80040251L)

//
// MessageId: VFW_E_NO_TIME_FORMAT_SET
//
// MessageText:
//
// No media time format has been selected.%0
//
#define VFW_E_NO_TIME_FORMAT_SET         ((HRESULT)0x80040252L)

//
// MessageId: VFW_E_MONO_AUDIO_HW
//
// MessageText:
//
// Cannot change balance because audio device is mono only.%0
//
#define VFW_E_MONO_AUDIO_HW              ((HRESULT)0x80040253L)

//
// MessageId: VFW_S_MEDIA_TYPE_IGNORED
//
// MessageText:
//
// A connection could not be made with the media type in the persistent graph,%0
// but has been made with a negotiated media type.%0
//
#define VFW_S_MEDIA_TYPE_IGNORED         ((HRESULT)0x00040254L)

//
// MessageId: VFW_E_NO_DECOMPRESSOR
//
// MessageText:
//
// Cannot play back the video stream: no suitable decompressor could be found.%0
//
#define VFW_E_NO_DECOMPRESSOR            ((HRESULT)0x80040255L)

//
// MessageId: VFW_E_NO_AUDIO_HARDWARE
//
// MessageText:
//
// Cannot play back the audio stream: no audio hardware is available, or the hardware is not responding.%0
//
#define VFW_E_NO_AUDIO_HARDWARE          ((HRESULT)0x80040256L)

//
// MessageId: VFW_S_VIDEO_NOT_RENDERED
//
// MessageText:
//
// Cannot play back the video stream: no suitable decompressor could be found.%0
//
#define VFW_S_VIDEO_NOT_RENDERED         ((HRESULT)0x00040257L)

//
// MessageId: VFW_S_AUDIO_NOT_RENDERED
//
// MessageText:
//
// Cannot play back the audio stream: no audio hardware is available.%0
//
#define VFW_S_AUDIO_NOT_RENDERED         ((HRESULT)0x00040258L)

//
// MessageId: VFW_E_RPZA
//
// MessageText:
//
// Cannot play back the video stream: format 'RPZA' is not supported.%0
//
#define VFW_E_RPZA                       ((HRESULT)0x80040259L)

//
// MessageId: VFW_S_RPZA
//
// MessageText:
//
// Cannot play back the video stream: format 'RPZA' is not supported.%0
//
#define VFW_S_RPZA                       ((HRESULT)0x0004025AL)

//
// MessageId: VFW_E_PROCESSOR_NOT_SUITABLE
//
// MessageText:
//
// ActiveMovie cannot play MPEG movies on this processor.%0
//
#define VFW_E_PROCESSOR_NOT_SUITABLE     ((HRESULT)0x8004025BL)

//
// MessageId: VFW_E_UNSUPPORTED_AUDIO
//
// MessageText:
//
// Cannot play back the audio stream: the audio format is not supported.%0
//
#define VFW_E_UNSUPPORTED_AUDIO          ((HRESULT)0x8004025CL)

//
// MessageId: VFW_E_UNSUPPORTED_VIDEO
//
// MessageText:
//
// Cannot play back the video stream: the video format is not supported.%0
//
#define VFW_E_UNSUPPORTED_VIDEO          ((HRESULT)0x8004025DL)

//
// MessageId: VFW_E_MPEG_NOT_CONSTRAINED
//
// MessageText:
//
// ActiveMovie cannot play this video stream because it falls outside the constrained standard.%0
//
#define VFW_E_MPEG_NOT_CONSTRAINED       ((HRESULT)0x8004025EL)

//
// MessageId: VFW_E_NOT_IN_GRAPH
//
// MessageText:
//
// Cannot perform the requested function on an object that is not in the filter graph.%0
//
#define VFW_E_NOT_IN_GRAPH               ((HRESULT)0x8004025FL)

//
// MessageId: VFW_S_ESTIMATED
//
// MessageText:
//
// The value returned had to be estimated.  It's accuracy can not be guaranteed.%0
//
#define VFW_S_ESTIMATED                  ((HRESULT)0x00040260L)

//
// MessageId: VFW_E_NO_TIME_FORMAT
//
// MessageText:
//
// Cannot get or set time related information on an object that is using a time format of TIME_FORMAT_NONE.%0
//
#define VFW_E_NO_TIME_FORMAT             ((HRESULT)0x80040261L)

//
// MessageId: VFW_E_READ_ONLY
//
// MessageText:
//
// The connection cannot be made because the stream is read only and the filter alters the data.%0
//
#define VFW_E_READ_ONLY                  ((HRESULT)0x80040262L)

//
// MessageId: VFW_S_RESERVED
//
// MessageText:
//
// This success code is reserved for internal purposes within ActiveMovie.%0
//
#define VFW_S_RESERVED                   ((HRESULT)0x00040263L)

//
// MessageId: VFW_E_BUFFER_UNDERFLOW
//
// MessageText:
//
// The buffer is not full enough.%0
//
#define VFW_E_BUFFER_UNDERFLOW           ((HRESULT)0x80040264L)

//
// MessageId: VFW_E_UNSUPPORTED_STREAM
//
// MessageText:
//
// Cannot play back the file.  The format is not supported.%0
//
#define VFW_E_UNSUPPORTED_STREAM         ((HRESULT)0x80040265L)

//
// MessageId: VFW_E_NO_TRANSPORT
//
// MessageText:
//
// Pins cannot connect due to not supporting the same transport.%0
//
#define VFW_E_NO_TRANSPORT               ((HRESULT)0x80040266L)

//
// MessageId: VFW_S_STREAM_OFF
//
// MessageText:
//
// The stream has been turned off.%0
//
#define VFW_S_STREAM_OFF                 ((HRESULT)0x00040267L)

//
// MessageId: VFW_S_CANT_CUE
//
// MessageText:
//
// The graph can't be cued because of lack of or corrupt data.%0
//
#define VFW_S_CANT_CUE                   ((HRESULT)0x00040268L)

//
// MessageId: VFW_E_BAD_VIDEOCD
//
// MessageText:
//
// The Video CD can't be read correctly by the device or is the data is corrupt.%0
//
#define VFW_E_BAD_VIDEOCD                ((HRESULT)0x80040269L)

//
// MessageId: VFW_S_NO_STOP_TIME
//
// MessageText:
//
// The stop time for the sample was not set.%0
//
#define VFW_S_NO_STOP_TIME               ((HRESULT)0x00040270L)

//
// MessageId: VFW_E_OUT_OF_VIDEO_MEMORY
//
// MessageText:
//
// There is not enough Video Memory at this display resolution and number of colors. Reducing resolution might help.%0
//
#define VFW_E_OUT_OF_VIDEO_MEMORY        ((HRESULT)0x80040271L)

//
// MessageId: VFW_E_VP_NEGOTIATION_FAILED
//
// MessageText:
//
// The VideoPort connection negotiation process has failed.%0
//
#define VFW_E_VP_NEGOTIATION_FAILED      ((HRESULT)0x80040272L)

//
// MessageId: VFW_E_DDRAW_CAPS_NOT_SUITABLE
//
// MessageText:
//
// Either DirectDraw has not been installed or the Video Card capabilities are not suitable. Make sure the display is not in 16 color mode or try changing the graphics mode.%0
//
#define VFW_E_DDRAW_CAPS_NOT_SUITABLE    ((HRESULT)0x80040273L)

//
// MessageId: VFW_E_NO_VP_HARDWARE
//
// MessageText:
//
// No VideoPort hardware is available, or the hardware is not responding.%0
//
#define VFW_E_NO_VP_HARDWARE             ((HRESULT)0x80040274L)

//
// MessageId: VFW_E_NO_CAPTURE_HARDWARE
//
// MessageText:
//
// No Capture hardware is available, or the hardware is not responding.%0
//
#define VFW_E_NO_CAPTURE_HARDWARE        ((HRESULT)0x80040275L)

//
// MessageId: VFW_E_DVD_OPERATION_INHIBITED
//
// MessageText:
//
// This User Operation is inhibited by DVD Content at this time.%0
//
#define VFW_E_DVD_OPERATION_INHIBITED    ((HRESULT)0x80040276L)

//
// MessageId: VFW_E_DVD_INVALIDDOMAIN
//
// MessageText:
//
// This Operation is not permitted in the current domain.%0
//
#define VFW_E_DVD_INVALIDDOMAIN          ((HRESULT)0x80040277L)

//
// MessageId: VFW_E_DVD_NO_BUTTON
//
// MessageText:
//
// The specified button is invalid or is not present at the current time, or there is no button present at the specified location.%0
//
#define VFW_E_DVD_NO_BUTTON              ((HRESULT)0x80040278L)

//
// MessageId: VFW_E_DVD_GRAPHNOTREADY
//
// MessageText:
//
// DVD-Video playback graph has not been built yet.%0
//
#define VFW_E_DVD_GRAPHNOTREADY          ((HRESULT)0x80040279L)

//
// MessageId: VFW_E_DVD_RENDERFAIL
//
// MessageText:
//
// DVD-Video playback graph building failed.%0
//
#define VFW_E_DVD_RENDERFAIL             ((HRESULT)0x8004027AL)

//
// MessageId: VFW_E_DVD_DECNOTENOUGH
//
// MessageText:
//
// DVD-Video playback graph could not be built due to insufficient decoders.%0
//
#define VFW_E_DVD_DECNOTENOUGH           ((HRESULT)0x8004027BL)

//
// MessageId: VFW_E_DDRAW_VERSION_NOT_SUITABLE
//
// MessageText:
//
// Version number of DirectDraw not suitable. Make sure to install dx5 or higher version.%0
//
#define VFW_E_DDRAW_VERSION_NOT_SUITABLE ((HRESULT)0x8004027CL)

//
// MessageId: VFW_E_COPYPROT_FAILED
//
// MessageText:
//
// Copy protection cannot be enabled. Please make sure any other copy protected content is not being shown now.%0
//
#define VFW_E_COPYPROT_FAILED            ((HRESULT)0x8004027DL)

//
// MessageId: VFW_S_NOPREVIEWPIN
//
// MessageText:
//
// There was no preview pin available, so the capture pin output is being split to provide both capture and preview.%0
//
#define VFW_S_NOPREVIEWPIN               ((HRESULT)0x0004027EL)

//
// MessageId: VFW_E_TIME_EXPIRED
//
// MessageText:
//
// This object cannot be used anymore as its time has expired.%0
//
#define VFW_E_TIME_EXPIRED               ((HRESULT)0x8004027FL)

//
// MessageId: VFW_S_DVD_NON_ONE_SEQUENTIAL
//
// MessageText:
//
// The current title was not a sequential set of chapters (PGC), and the returned timing information might not be continuous.%0
//
#define VFW_S_DVD_NON_ONE_SEQUENTIAL     ((HRESULT)0x00040280L)

//
// MessageId: VFW_E_DVD_WRONG_SPEED
//
// MessageText:
//
// The operation cannot be performed at the current playback speed.%0
//
#define VFW_E_DVD_WRONG_SPEED            ((HRESULT)0x80040281L)

//
// MessageId: VFW_E_DVD_MENU_DOES_NOT_EXIST
//
// MessageText:
//
// The specified menu doesn't exist.%0
//
#define VFW_E_DVD_MENU_DOES_NOT_EXIST    ((HRESULT)0x80040282L)

//
// MessageId: VFW_E_DVD_CMD_CANCELLED
//
// MessageText:
//
// The specified command was either cancelled or no longer exists.%0
//
#define VFW_E_DVD_CMD_CANCELLED          ((HRESULT)0x80040283L)

//
// MessageId: VFW_E_DVD_STATE_WRONG_VERSION
//
// MessageText:
//
// The data did not contain a recognized version.%0
//
#define VFW_E_DVD_STATE_WRONG_VERSION    ((HRESULT)0x80040284L)

//
// MessageId: VFW_E_DVD_STATE_CORRUPT
//
// MessageText:
//
// The state data was corrupt.%0
//
#define VFW_E_DVD_STATE_CORRUPT          ((HRESULT)0x80040285L)

//
// MessageId: VFW_E_DVD_STATE_WRONG_DISC
//
// MessageText:
//
// The state data is from a different disc.%0
//
#define VFW_E_DVD_STATE_WRONG_DISC       ((HRESULT)0x80040286L)

//
// MessageId: VFW_E_DVD_INCOMPATIBLE_REGION
//
// MessageText:
//
// The region was not compatible with the current drive.%0
//
#define VFW_E_DVD_INCOMPATIBLE_REGION    ((HRESULT)0x80040287L)

//
// MessageId: VFW_E_DVD_NO_ATTRIBUTES
//
// MessageText:
//
// The requested DVD stream attribute does not exist.%0
//
#define VFW_E_DVD_NO_ATTRIBUTES          ((HRESULT)0x80040288L)

//
// MessageId: VFW_E_DVD_NO_GOUP_PGC
//
// MessageText:
//
// Currently there is no GoUp (Annex J user function) program chain (PGC).%0
//
#define VFW_E_DVD_NO_GOUP_PGC            ((HRESULT)0x80040289L)

//
// MessageId: VFW_E_DVD_LOW_PARENTAL_LEVEL
//
// MessageText:
//
// The current parental level was too low.%0
//
#define VFW_E_DVD_LOW_PARENTAL_LEVEL     ((HRESULT)0x8004028AL)

//
// MessageId: VFW_E_DVD_NOT_IN_KARAOKE_MODE
//
// MessageText:
//
// The current audio is not karaoke content.%0
//
#define VFW_E_DVD_NOT_IN_KARAOKE_MODE    ((HRESULT)0x8004028BL)

//
// MessageId: VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE
//
// MessageText:
//
// The audio stream did not contain sufficient information to determine the contents of each channel.%0
//
#define VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE ((HRESULT)0x0004028CL)

//
// MessageId: VFW_S_DVD_NOT_ACCURATE
//
// MessageText:
//
// The seek into the movie was not frame accurate.%0
//
#define VFW_S_DVD_NOT_ACCURATE           ((HRESULT)0x0004028DL)

//
// MessageId: VFW_E_FRAME_STEP_UNSUPPORTED
//
// MessageText:
//
// Frame step is not supported on this configuration.%0
//
#define VFW_E_FRAME_STEP_UNSUPPORTED     ((HRESULT)0x8004028EL)

//
// MessageId: VFW_E_DVD_STREAM_DISABLED
//
// MessageText:
//
// The specified stream is disabled and cannot be selected.%0
//
#define VFW_E_DVD_STREAM_DISABLED        ((HRESULT)0x8004028FL)

//
// MessageId: VFW_E_DVD_TITLE_UNKNOWN
//
// MessageText:
//
// The operation depends on the current title number, however the navigator has not yet entered the VTSM or the title domains,
// so the 'current' title index is unknown.%0
//
#define VFW_E_DVD_TITLE_UNKNOWN          ((HRESULT)0x80040290L)

//
// MessageId: VFW_E_DVD_INVALID_DISC
//
// MessageText:
//
// The specified path does not point to a valid DVD disc.%0
//
#define VFW_E_DVD_INVALID_DISC           ((HRESULT)0x80040291L)

//
// MessageId: VFW_E_DVD_NO_RESUME_INFORMATION
//
// MessageText:
//
// There is currently no resume information.%0
//
#define VFW_E_DVD_NO_RESUME_INFORMATION  ((HRESULT)0x80040292L)

//
// MessageId: VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD
//
// MessageText:
//
// This thread has already blocked this output pin.  There is no need to call IPinFlowControl::Block() again.%0
//
#define VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD ((HRESULT)0x80040293L)

//
// MessageId: VFW_E_PIN_ALREADY_BLOCKED
//
// MessageText:
//
// IPinFlowControl::Block() has been called on another thread.  The current thread cannot make any assumptions about this pin's block state.%0
//
#define VFW_E_PIN_ALREADY_BLOCKED        ((HRESULT)0x80040294L)

//
// MessageId: VFW_E_CERTIFICATION_FAILURE
//
// MessageText:
//
// An operation failed due to a certification failure.%0
//
#define VFW_E_CERTIFICATION_FAILURE      ((HRESULT)0x80040295L)

//
// MessageId: VFW_E_VMR_NOT_IN_MIXER_MODE
//
// MessageText:
//
// The VMR has not yet created a mixing component.  That is, IVMRFilterConfig::SetNumberofStreams has not yet been called.%0
//
#define VFW_E_VMR_NOT_IN_MIXER_MODE      ((HRESULT)0x80040296L)

//
// MessageId: VFW_E_VMR_NO_AP_SUPPLIED
//
// MessageText:
//
// The application has not yet provided the VMR filter with a valid allocator-presenter object.%0
//
#define VFW_E_VMR_NO_AP_SUPPLIED         ((HRESULT)0x80040297L)

//
// MessageId: VFW_E_VMR_NO_DEINTERLACE_HW
//
// MessageText:
//
// The VMR could not find any de-interlacing hardware on the current display device.%0
//
#define VFW_E_VMR_NO_DEINTERLACE_HW      ((HRESULT)0x80040298L)

//
// MessageId: VFW_E_VMR_NO_PROCAMP_HW
//
// MessageText:
//
// The VMR could not find any ProcAmp hardware on the current display device.%0
//
#define VFW_E_VMR_NO_PROCAMP_HW          ((HRESULT)0x80040299L)

//
// MessageId: VFW_E_DVD_VMR9_INCOMPATIBLEDEC
//
// MessageText:
//
// VMR9 does not work with VPE-based hardware decoders.%0
//
#define VFW_E_DVD_VMR9_INCOMPATIBLEDEC   ((HRESULT)0x8004029AL)

//
// MessageId: VFW_E_VMR_NO_AP_SUPPLIED
//
// MessageText:
//
//  The application has not yet provided the VMR filter with a valid allocator-presenter object.%0
//
#define VFW_E_VMR_NO_AP_SUPPLIED         ((HRESULT)0x80040297L)
//
// MessageId: VFW_E_VMR_NO_DEINTERLACE_HW
//
// MessageText:
//
//  The VMR could not find any de-interlacing hardware on the current display device.%0
//
#define VFW_E_VMR_NO_DEINTERLACE_HW      ((HRESULT)0x80040298L)
//
// MessageId: VFW_E_VMR_NO_PROCAMP_HW
//
// MessageText:
//
//  The VMR could not find any ProcAmp hardware on the current display device.%0
//
#define VFW_E_VMR_NO_PROCAMP_HW          ((HRESULT)0x80040299L)
//
// MessageId: VFW_E_DVD_VMR9_INCOMPATIBLEDEC
//
// MessageText:
//
//  VMR9 does not work with VPE-based hardware decoders.%0
//
#define VFW_E_DVD_VMR9_INCOMPATIBLEDEC   ((HRESULT)0x8004029AL)
//
// MessageId: VFW_E_NO_COPP_HW
//
// MessageText:
//
//  The current display device does not support Content Output Protection Protocol (COPP) H/W.%0
//
#define VFW_E_NO_COPP_HW   ((HRESULT)0x8004029BL)
//
// MessageId: VFW_E_DVD_NONBLOCKING
//
// MessageText:
//
//  Nonblocking APIs are enabled and the nav cannot perform the operation at this time (IDVDControl) or partially incomplete information may be returned (DVDInfo).%0
//
#define VFW_E_DVD_NONBLOCKING ((HRESULT)0x8004029CL)
//
// MessageId: VFW_E_DVD_TOO_MANY_RENDERERS_IN_FILTER_GRAPH
//
// MessageText:
//
// The DVD Graph Builder cannot build a DVD playback filter graph if the EVR and another renderer are in the graph builder's filter graph.
//
#define VFW_E_DVD_TOO_MANY_RENDERERS_IN_FILTER_GRAPH ((HRESULT)0x8004029DL)

//
// MessageId: VFW_E_DVD_NON_EVR_RENDERER_IN_FILTER_GRAPH
//
// MessageText:
//
// AM_DVD_EVR_ONLY cannot be passed to RenderDvdVideoVolume if the graph builder's filter graph contains a renderer which is not the EVR.
//
#define VFW_E_DVD_NON_EVR_RENDERER_IN_FILTER_GRAPH ((HRESULT)0x8004029EL)

//
// MessageId: VFW_E_DVD_RESOLUTION_ERROR
//
// MessageText:
//
// DVD Video Output is not at a proper resolution.
//
#define VFW_E_DVD_RESOLUTION_ERROR       ((HRESULT)0x8004029FL)

//
//
// E_PROP_SET_UNSUPPORTED and E_PROP_ID_UNSUPPORTED are added here using
// HRESULT_FROM_WIN32() because VC5 doesn't have WinNT's new error codes
// from winerror.h, and because it is more convienent to have them already
// formed as HRESULTs.  These should correspond to:
//     HRESULT_FROM_WIN32(ERROR_NOT_FOUND)     == E_PROP_ID_UNSUPPORTED
//     HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND) == E_PROP_SET_UNSUPPORTED
#if !defined(E_PROP_SET_UNSUPPORTED)
//
// MessageId: E_PROP_SET_UNSUPPORTED
//
// MessageText:
//
// The Specified property set is not supported.%0
//
#define E_PROP_SET_UNSUPPORTED           ((HRESULT)0x80070492L)

#endif //!defined(E_PROP_SET_UNSUPPORTED)
#if !defined(E_PROP_ID_UNSUPPORTED)
//
// MessageId: E_PROP_ID_UNSUPPORTED
//
// MessageText:
//
// The specified property ID is not supported for the specified property set.%0
//
#define E_PROP_ID_UNSUPPORTED            ((HRESULT)0x80070490L)

#endif //!defined(E_PROP_ID_UNSUPPORTED)
//
// MessageId: VFW_E_CODECAPI_LINEAR_RANGE
//
// MessageText:
//
// Parameter has linear range.%0
//
#define VFW_E_CODECAPI_LINEAR_RANGE      ((HRESULT)0x80040310L)

//
// MessageId: VFW_E_CODECAPI_ENUMERATED
//
// MessageText:
//
// Parameter is enumerated. It has no range.%0
//
#define VFW_E_CODECAPI_ENUMERATED        ((HRESULT)0x80040311L)

//
// MessageId: VFW_E_CODECAPI_NO_DEFAULT
//
// MessageText:
//
// No default value.%0
//
#define VFW_E_CODECAPI_NO_DEFAULT        ((HRESULT)0x80040313L)

//
// MessageId: VFW_E_CODECAPI_NO_CURRENT_VALUE
//
// MessageText:
//
// No current value.%0
//
#define VFW_E_CODECAPI_NO_CURRENT_VALUE  ((HRESULT)0x80040314L)

//
// MessageId: VFW_E_DVD_CHAPTER_DOES_NOT_EXIST
//
// MessageText:
//
// The operation failed since the chapter does not exist.%0
//
#define VFW_E_DVD_CHAPTER_DOES_NOT_EXIST ((HRESULT)0x80040315L)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vptype.h ===
//------------------------------------------------------------------------------
// File: VPType.h
//
// Desc: This file includes all the data structures defined for the IVPConfig
//       interface.
//
// Copyright (c) 1997 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __IVPType__
#define __IVPType__

#ifdef __cplusplus
extern "C" {
#endif

    // enum to specify the criterion, which the vpmixer is supposed to use
    // in order to select the video format
    typedef enum _AMVP_SELECT_FORMAT_BY
    {
	AMVP_DO_NOT_CARE,
	AMVP_BEST_BANDWIDTH,
	AMVP_INPUT_SAME_AS_OUTPUT
    } AMVP_SELECT_FORMAT_BY;

    // enum to specify the various mode
    typedef enum _AMVP_MODE
    {	
	AMVP_MODE_WEAVE,
	AMVP_MODE_BOBINTERLEAVED,
	AMVP_MODE_BOBNONINTERLEAVED,
	AMVP_MODE_SKIPEVEN,
	AMVP_MODE_SKIPODD
    } AMVP_MODE;

    // struct to specify the width and height. The context could be anything
    // such as scaling cropping etc.
    typedef struct _AMVPSIZE
    {
	DWORD			dwWidth;				// the width
	DWORD			dwHeight;				// the height
    } AMVPSIZE, *LPAMVPSIZE;

    // struct to specify the dimensional characteristics of the input stream
    typedef struct _AMVPDIMINFO
    {
	DWORD			dwFieldWidth;				// Field height of the data
	DWORD			dwFieldHeight;				// Field width of the data
	DWORD			dwVBIWidth;				// Width of the VBI data
	DWORD			dwVBIHeight;				// Height of the VBI data
	RECT			rcValidRegion;				// The vaild rectangle, used for cropping
    } AMVPDIMINFO, *LPAMVPDIMINFO;

    // struct to specify the various data specific characteristics of the input stream
    typedef struct _AMVPDATAINFO
    {
	DWORD			dwSize;					// Size of the struct
	DWORD			dwMicrosecondsPerField;			// Time taken by each field
	AMVPDIMINFO		amvpDimInfo;				// Dimensional Information 
	DWORD			dwPictAspectRatioX;			// X dimension of Picture Aspect Ratio
	DWORD			dwPictAspectRatioY;			// Y dimension of Picture Aspect Ratio
	BOOL			bEnableDoubleClock;			// Videoport should enable double clocking
	BOOL			bEnableVACT;				// Videoport should use an external VACT signal
	BOOL			bDataIsInterlaced;			// Indicates that the signal is interlaced
	LONG			lHalfLinesOdd;				// number of halflines in the odd field
	BOOL			bFieldPolarityInverted;			// Device inverts the polarity by default
	DWORD			dwNumLinesInVREF;			// Number of lines of data in VREF 
	LONG			lHalfLinesEven;				// number of halflines in the even field
	DWORD			dwReserved1;				// Reserved for future use
    } AMVPDATAINFO, *LPAMVPDATAINFO; 


#ifdef __cplusplus
}
#endif

#endif // __IVPType__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vidcap.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vidcap.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vidcap_h__
#define __vidcap_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IKsTopologyInfo_FWD_DEFINED__
#define __IKsTopologyInfo_FWD_DEFINED__
typedef interface IKsTopologyInfo IKsTopologyInfo;
#endif 	/* __IKsTopologyInfo_FWD_DEFINED__ */


#ifndef __ISelector_FWD_DEFINED__
#define __ISelector_FWD_DEFINED__
typedef interface ISelector ISelector;
#endif 	/* __ISelector_FWD_DEFINED__ */


#ifndef __ICameraControl_FWD_DEFINED__
#define __ICameraControl_FWD_DEFINED__
typedef interface ICameraControl ICameraControl;
#endif 	/* __ICameraControl_FWD_DEFINED__ */


#ifndef __IVideoProcAmp_FWD_DEFINED__
#define __IVideoProcAmp_FWD_DEFINED__
typedef interface IVideoProcAmp IVideoProcAmp;
#endif 	/* __IVideoProcAmp_FWD_DEFINED__ */


#ifndef __IKsNodeControl_FWD_DEFINED__
#define __IKsNodeControl_FWD_DEFINED__
typedef interface IKsNodeControl IKsNodeControl;
#endif 	/* __IKsNodeControl_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vidcap_0000_0000 */
/* [local] */ 

#include "ks.h"
#ifndef _KS_
typedef /* [public][public] */ struct __MIDL___MIDL_itf_vidcap_0000_0000_0001
    {
    ULONG FromNode;
    ULONG FromNodePin;
    ULONG ToNode;
    ULONG ToNodePin;
    } 	KSTOPOLOGY_CONNECTION;

typedef struct __MIDL___MIDL_itf_vidcap_0000_0000_0001 *PKSTOPOLOGY_CONNECTION;

#endif


extern RPC_IF_HANDLE __MIDL_itf_vidcap_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vidcap_0000_0000_v0_0_s_ifspec;

#ifndef __IKsTopologyInfo_INTERFACE_DEFINED__
#define __IKsTopologyInfo_INTERFACE_DEFINED__

/* interface IKsTopologyInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IKsTopologyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("720D4AC0-7533-11D0-A5D6-28DB04C10000")
    IKsTopologyInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_NumCategories( 
            /* [out] */ DWORD *pdwNumCategories) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Category( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ GUID *pCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_NumConnections( 
            /* [out] */ DWORD *pdwNumConnections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ConnectionInfo( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ KSTOPOLOGY_CONNECTION *pConnectionInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_NodeName( 
            /* [in] */ DWORD dwNodeId,
            /* [annotation][out] */ 
            __out_bcount_opt(dwBufSize)  WCHAR *pwchNodeName,
            /* [in] */ DWORD dwBufSize,
            /* [annotation][out] */ 
            __out  DWORD *pdwNameLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_NumNodes( 
            /* [out] */ DWORD *pdwNumNodes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_NodeType( 
            /* [in] */ DWORD dwNodeId,
            /* [out] */ GUID *pNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNodeInstance( 
            /* [in] */ DWORD dwNodeId,
            /* [in] */ REFIID iid,
            /* [out] */ void **ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKsTopologyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKsTopologyInfo * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKsTopologyInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKsTopologyInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_NumCategories )( 
            IKsTopologyInfo * This,
            /* [out] */ DWORD *pdwNumCategories);
        
        HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IKsTopologyInfo * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ GUID *pCategory);
        
        HRESULT ( STDMETHODCALLTYPE *get_NumConnections )( 
            IKsTopologyInfo * This,
            /* [out] */ DWORD *pdwNumConnections);
        
        HRESULT ( STDMETHODCALLTYPE *get_ConnectionInfo )( 
            IKsTopologyInfo * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ KSTOPOLOGY_CONNECTION *pConnectionInfo);
        
        HRESULT ( STDMETHODCALLTYPE *get_NodeName )( 
            IKsTopologyInfo * This,
            /* [in] */ DWORD dwNodeId,
            /* [annotation][out] */ 
            __out_bcount_opt(dwBufSize)  WCHAR *pwchNodeName,
            /* [in] */ DWORD dwBufSize,
            /* [annotation][out] */ 
            __out  DWORD *pdwNameLen);
        
        HRESULT ( STDMETHODCALLTYPE *get_NumNodes )( 
            IKsTopologyInfo * This,
            /* [out] */ DWORD *pdwNumNodes);
        
        HRESULT ( STDMETHODCALLTYPE *get_NodeType )( 
            IKsTopologyInfo * This,
            /* [in] */ DWORD dwNodeId,
            /* [out] */ GUID *pNodeType);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNodeInstance )( 
            IKsTopologyInfo * This,
            /* [in] */ DWORD dwNodeId,
            /* [in] */ REFIID iid,
            /* [out] */ void **ppvObject);
        
        END_INTERFACE
    } IKsTopologyInfoVtbl;

    interface IKsTopologyInfo
    {
        CONST_VTBL struct IKsTopologyInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKsTopologyInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKsTopologyInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKsTopologyInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKsTopologyInfo_get_NumCategories(This,pdwNumCategories)	\
    ( (This)->lpVtbl -> get_NumCategories(This,pdwNumCategories) ) 

#define IKsTopologyInfo_get_Category(This,dwIndex,pCategory)	\
    ( (This)->lpVtbl -> get_Category(This,dwIndex,pCategory) ) 

#define IKsTopologyInfo_get_NumConnections(This,pdwNumConnections)	\
    ( (This)->lpVtbl -> get_NumConnections(This,pdwNumConnections) ) 

#define IKsTopologyInfo_get_ConnectionInfo(This,dwIndex,pConnectionInfo)	\
    ( (This)->lpVtbl -> get_ConnectionInfo(This,dwIndex,pConnectionInfo) ) 

#define IKsTopologyInfo_get_NodeName(This,dwNodeId,pwchNodeName,dwBufSize,pdwNameLen)	\
    ( (This)->lpVtbl -> get_NodeName(This,dwNodeId,pwchNodeName,dwBufSize,pdwNameLen) ) 

#define IKsTopologyInfo_get_NumNodes(This,pdwNumNodes)	\
    ( (This)->lpVtbl -> get_NumNodes(This,pdwNumNodes) ) 

#define IKsTopologyInfo_get_NodeType(This,dwNodeId,pNodeType)	\
    ( (This)->lpVtbl -> get_NodeType(This,dwNodeId,pNodeType) ) 

#define IKsTopologyInfo_CreateNodeInstance(This,dwNodeId,iid,ppvObject)	\
    ( (This)->lpVtbl -> CreateNodeInstance(This,dwNodeId,iid,ppvObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKsTopologyInfo_INTERFACE_DEFINED__ */


#ifndef __ISelector_INTERFACE_DEFINED__
#define __ISelector_INTERFACE_DEFINED__

/* interface ISelector */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISelector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ABDAECA-68B6-4F83-9371-B413907C7B9F")
    ISelector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_NumSources( 
            /* [out] */ DWORD *pdwNumSources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_SourceNodeId( 
            /* [out] */ DWORD *pdwPinId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_SourceNodeId( 
            /* [in] */ DWORD dwPinId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISelector * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISelector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISelector * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_NumSources )( 
            ISelector * This,
            /* [out] */ DWORD *pdwNumSources);
        
        HRESULT ( STDMETHODCALLTYPE *get_SourceNodeId )( 
            ISelector * This,
            /* [out] */ DWORD *pdwPinId);
        
        HRESULT ( STDMETHODCALLTYPE *put_SourceNodeId )( 
            ISelector * This,
            /* [in] */ DWORD dwPinId);
        
        END_INTERFACE
    } ISelectorVtbl;

    interface ISelector
    {
        CONST_VTBL struct ISelectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISelector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISelector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISelector_get_NumSources(This,pdwNumSources)	\
    ( (This)->lpVtbl -> get_NumSources(This,pdwNumSources) ) 

#define ISelector_get_SourceNodeId(This,pdwPinId)	\
    ( (This)->lpVtbl -> get_SourceNodeId(This,pdwPinId) ) 

#define ISelector_put_SourceNodeId(This,dwPinId)	\
    ( (This)->lpVtbl -> put_SourceNodeId(This,dwPinId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISelector_INTERFACE_DEFINED__ */


#ifndef __ICameraControl_INTERFACE_DEFINED__
#define __ICameraControl_INTERFACE_DEFINED__

/* interface ICameraControl */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ICameraControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2BA1785D-4D1B-44EF-85E8-C7F1D3F20184")
    ICameraControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_Exposure( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Exposure( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Exposure( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Focus( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Focus( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Focus( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Iris( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Iris( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Iris( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Zoom( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Zoom( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Zoom( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_FocalLengths( 
            /* [out] */ long *plOcularFocalLength,
            /* [out] */ long *plObjectiveFocalLengthMin,
            /* [out] */ long *plObjectiveFocalLengthMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Pan( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Pan( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Pan( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Tilt( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Tilt( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Tilt( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PanTilt( 
            /* [out] */ long *pPanValue,
            /* [out] */ long *pTiltValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PanTilt( 
            /* [in] */ long PanValue,
            /* [in] */ long TiltValue,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Roll( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Roll( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Roll( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ExposureRelative( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ExposureRelative( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_ExposureRelative( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_FocusRelative( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_FocusRelative( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_FocusRelative( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_IrisRelative( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_IrisRelative( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_IrisRelative( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ZoomRelative( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ZoomRelative( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_ZoomRelative( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PanRelative( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PanRelative( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TiltRelative( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TiltRelative( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_TiltRelative( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PanTiltRelative( 
            /* [out] */ long *pPanValue,
            /* [out] */ long *pTiltValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PanTiltRelative( 
            /* [in] */ long PanValue,
            /* [in] */ long TiltValue,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_PanRelative( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_RollRelative( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_RollRelative( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_RollRelative( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ScanMode( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ScanMode( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PrivacyMode( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PrivacyMode( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICameraControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICameraControl * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICameraControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICameraControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_Exposure )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Exposure )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Exposure )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_Focus )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Focus )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Focus )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_Iris )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Iris )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Iris )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_Zoom )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Zoom )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Zoom )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_FocalLengths )( 
            ICameraControl * This,
            /* [out] */ long *plOcularFocalLength,
            /* [out] */ long *plObjectiveFocalLengthMin,
            /* [out] */ long *plObjectiveFocalLengthMax);
        
        HRESULT ( STDMETHODCALLTYPE *get_Pan )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Pan )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Pan )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_Tilt )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Tilt )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Tilt )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_PanTilt )( 
            ICameraControl * This,
            /* [out] */ long *pPanValue,
            /* [out] */ long *pTiltValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_PanTilt )( 
            ICameraControl * This,
            /* [in] */ long PanValue,
            /* [in] */ long TiltValue,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *get_Roll )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Roll )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Roll )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_ExposureRelative )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_ExposureRelative )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_ExposureRelative )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_FocusRelative )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_FocusRelative )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_FocusRelative )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_IrisRelative )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_IrisRelative )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_IrisRelative )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_ZoomRelative )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_ZoomRelative )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_ZoomRelative )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_PanRelative )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_PanRelative )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *get_TiltRelative )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_TiltRelative )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_TiltRelative )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_PanTiltRelative )( 
            ICameraControl * This,
            /* [out] */ long *pPanValue,
            /* [out] */ long *pTiltValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_PanTiltRelative )( 
            ICameraControl * This,
            /* [in] */ long PanValue,
            /* [in] */ long TiltValue,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_PanRelative )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_RollRelative )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_RollRelative )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_RollRelative )( 
            ICameraControl * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_ScanMode )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_ScanMode )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *get_PrivacyMode )( 
            ICameraControl * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_PrivacyMode )( 
            ICameraControl * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        END_INTERFACE
    } ICameraControlVtbl;

    interface ICameraControl
    {
        CONST_VTBL struct ICameraControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICameraControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICameraControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICameraControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICameraControl_get_Exposure(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Exposure(This,pValue,pFlags) ) 

#define ICameraControl_put_Exposure(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Exposure(This,Value,Flags) ) 

#define ICameraControl_getRange_Exposure(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Exposure(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_Focus(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Focus(This,pValue,pFlags) ) 

#define ICameraControl_put_Focus(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Focus(This,Value,Flags) ) 

#define ICameraControl_getRange_Focus(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Focus(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_Iris(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Iris(This,pValue,pFlags) ) 

#define ICameraControl_put_Iris(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Iris(This,Value,Flags) ) 

#define ICameraControl_getRange_Iris(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Iris(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_Zoom(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Zoom(This,pValue,pFlags) ) 

#define ICameraControl_put_Zoom(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Zoom(This,Value,Flags) ) 

#define ICameraControl_getRange_Zoom(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Zoom(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_FocalLengths(This,plOcularFocalLength,plObjectiveFocalLengthMin,plObjectiveFocalLengthMax)	\
    ( (This)->lpVtbl -> get_FocalLengths(This,plOcularFocalLength,plObjectiveFocalLengthMin,plObjectiveFocalLengthMax) ) 

#define ICameraControl_get_Pan(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Pan(This,pValue,pFlags) ) 

#define ICameraControl_put_Pan(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Pan(This,Value,Flags) ) 

#define ICameraControl_getRange_Pan(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Pan(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_Tilt(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Tilt(This,pValue,pFlags) ) 

#define ICameraControl_put_Tilt(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Tilt(This,Value,Flags) ) 

#define ICameraControl_getRange_Tilt(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Tilt(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_PanTilt(This,pPanValue,pTiltValue,pFlags)	\
    ( (This)->lpVtbl -> get_PanTilt(This,pPanValue,pTiltValue,pFlags) ) 

#define ICameraControl_put_PanTilt(This,PanValue,TiltValue,Flags)	\
    ( (This)->lpVtbl -> put_PanTilt(This,PanValue,TiltValue,Flags) ) 

#define ICameraControl_get_Roll(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Roll(This,pValue,pFlags) ) 

#define ICameraControl_put_Roll(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Roll(This,Value,Flags) ) 

#define ICameraControl_getRange_Roll(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Roll(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_ExposureRelative(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_ExposureRelative(This,pValue,pFlags) ) 

#define ICameraControl_put_ExposureRelative(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_ExposureRelative(This,Value,Flags) ) 

#define ICameraControl_getRange_ExposureRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_ExposureRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_FocusRelative(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_FocusRelative(This,pValue,pFlags) ) 

#define ICameraControl_put_FocusRelative(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_FocusRelative(This,Value,Flags) ) 

#define ICameraControl_getRange_FocusRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_FocusRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_IrisRelative(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_IrisRelative(This,pValue,pFlags) ) 

#define ICameraControl_put_IrisRelative(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_IrisRelative(This,Value,Flags) ) 

#define ICameraControl_getRange_IrisRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_IrisRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_ZoomRelative(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_ZoomRelative(This,pValue,pFlags) ) 

#define ICameraControl_put_ZoomRelative(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_ZoomRelative(This,Value,Flags) ) 

#define ICameraControl_getRange_ZoomRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_ZoomRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_PanRelative(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_PanRelative(This,pValue,pFlags) ) 

#define ICameraControl_put_PanRelative(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_PanRelative(This,Value,Flags) ) 

#define ICameraControl_get_TiltRelative(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_TiltRelative(This,pValue,pFlags) ) 

#define ICameraControl_put_TiltRelative(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_TiltRelative(This,Value,Flags) ) 

#define ICameraControl_getRange_TiltRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_TiltRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_PanTiltRelative(This,pPanValue,pTiltValue,pFlags)	\
    ( (This)->lpVtbl -> get_PanTiltRelative(This,pPanValue,pTiltValue,pFlags) ) 

#define ICameraControl_put_PanTiltRelative(This,PanValue,TiltValue,Flags)	\
    ( (This)->lpVtbl -> put_PanTiltRelative(This,PanValue,TiltValue,Flags) ) 

#define ICameraControl_getRange_PanRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_PanRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_RollRelative(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_RollRelative(This,pValue,pFlags) ) 

#define ICameraControl_put_RollRelative(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_RollRelative(This,Value,Flags) ) 

#define ICameraControl_getRange_RollRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_RollRelative(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define ICameraControl_get_ScanMode(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_ScanMode(This,pValue,pFlags) ) 

#define ICameraControl_put_ScanMode(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_ScanMode(This,Value,Flags) ) 

#define ICameraControl_get_PrivacyMode(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_PrivacyMode(This,pValue,pFlags) ) 

#define ICameraControl_put_PrivacyMode(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_PrivacyMode(This,Value,Flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICameraControl_INTERFACE_DEFINED__ */


#ifndef __IVideoProcAmp_INTERFACE_DEFINED__
#define __IVideoProcAmp_INTERFACE_DEFINED__

/* interface IVideoProcAmp */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IVideoProcAmp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4050560E-42A7-413a-85C2-09269A2D0F44")
    IVideoProcAmp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_BacklightCompensation( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_BacklightCompensation( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_BacklightCompensation( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Brightness( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Brightness( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Brightness( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ColorEnable( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ColorEnable( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_ColorEnable( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Contrast( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Contrast( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Contrast( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Gamma( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Gamma( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Gamma( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Saturation( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Saturation( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Saturation( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Sharpness( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Sharpness( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Sharpness( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_WhiteBalance( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_WhiteBalance( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_WhiteBalance( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Gain( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Gain( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Gain( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Hue( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Hue( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_Hue( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DigitalMultiplier( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DigitalMultiplier( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_DigitalMultiplier( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PowerlineFrequency( 
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PowerlineFrequency( 
            /* [in] */ long Value,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_PowerlineFrequency( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_WhiteBalanceComponent( 
            /* [out] */ long *pValue1,
            /* [out] */ long *pValue2,
            /* [out][in] */ long *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_WhiteBalanceComponent( 
            /* [in] */ long Value1,
            /* [in] */ long Value2,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getRange_WhiteBalanceComponent( 
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out][in] */ long *pCapsFlag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVideoProcAmpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoProcAmp * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoProcAmp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoProcAmp * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_BacklightCompensation )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_BacklightCompensation )( 
            IVideoProcAmp * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_BacklightCompensation )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_Brightness )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Brightness )( 
            IVideoProcAmp * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Brightness )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_ColorEnable )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_ColorEnable )( 
            IVideoProcAmp * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_ColorEnable )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_Contrast )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Contrast )( 
            IVideoProcAmp * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Contrast )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_Gamma )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Gamma )( 
            IVideoProcAmp * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Gamma )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_Saturation )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Saturation )( 
            IVideoProcAmp * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Saturation )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_Sharpness )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Sharpness )( 
            IVideoProcAmp * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Sharpness )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_WhiteBalance )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_WhiteBalance )( 
            IVideoProcAmp * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_WhiteBalance )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_Gain )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Gain )( 
            IVideoProcAmp * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Gain )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_Hue )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_Hue )( 
            IVideoProcAmp * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_Hue )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_DigitalMultiplier )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_DigitalMultiplier )( 
            IVideoProcAmp * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_DigitalMultiplier )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_PowerlineFrequency )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue,
            /* [out] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_PowerlineFrequency )( 
            IVideoProcAmp * This,
            /* [in] */ long Value,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_PowerlineFrequency )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_WhiteBalanceComponent )( 
            IVideoProcAmp * This,
            /* [out] */ long *pValue1,
            /* [out] */ long *pValue2,
            /* [out][in] */ long *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *put_WhiteBalanceComponent )( 
            IVideoProcAmp * This,
            /* [in] */ long Value1,
            /* [in] */ long Value2,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *getRange_WhiteBalanceComponent )( 
            IVideoProcAmp * This,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out][in] */ long *pCapsFlag);
        
        END_INTERFACE
    } IVideoProcAmpVtbl;

    interface IVideoProcAmp
    {
        CONST_VTBL struct IVideoProcAmpVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoProcAmp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVideoProcAmp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVideoProcAmp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVideoProcAmp_get_BacklightCompensation(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_BacklightCompensation(This,pValue,pFlags) ) 

#define IVideoProcAmp_put_BacklightCompensation(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_BacklightCompensation(This,Value,Flags) ) 

#define IVideoProcAmp_getRange_BacklightCompensation(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_BacklightCompensation(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define IVideoProcAmp_get_Brightness(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Brightness(This,pValue,pFlags) ) 

#define IVideoProcAmp_put_Brightness(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Brightness(This,Value,Flags) ) 

#define IVideoProcAmp_getRange_Brightness(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Brightness(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define IVideoProcAmp_get_ColorEnable(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_ColorEnable(This,pValue,pFlags) ) 

#define IVideoProcAmp_put_ColorEnable(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_ColorEnable(This,Value,Flags) ) 

#define IVideoProcAmp_getRange_ColorEnable(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_ColorEnable(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define IVideoProcAmp_get_Contrast(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Contrast(This,pValue,pFlags) ) 

#define IVideoProcAmp_put_Contrast(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Contrast(This,Value,Flags) ) 

#define IVideoProcAmp_getRange_Contrast(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Contrast(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define IVideoProcAmp_get_Gamma(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Gamma(This,pValue,pFlags) ) 

#define IVideoProcAmp_put_Gamma(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Gamma(This,Value,Flags) ) 

#define IVideoProcAmp_getRange_Gamma(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Gamma(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define IVideoProcAmp_get_Saturation(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Saturation(This,pValue,pFlags) ) 

#define IVideoProcAmp_put_Saturation(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Saturation(This,Value,Flags) ) 

#define IVideoProcAmp_getRange_Saturation(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Saturation(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define IVideoProcAmp_get_Sharpness(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Sharpness(This,pValue,pFlags) ) 

#define IVideoProcAmp_put_Sharpness(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Sharpness(This,Value,Flags) ) 

#define IVideoProcAmp_getRange_Sharpness(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Sharpness(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define IVideoProcAmp_get_WhiteBalance(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_WhiteBalance(This,pValue,pFlags) ) 

#define IVideoProcAmp_put_WhiteBalance(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_WhiteBalance(This,Value,Flags) ) 

#define IVideoProcAmp_getRange_WhiteBalance(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_WhiteBalance(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define IVideoProcAmp_get_Gain(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Gain(This,pValue,pFlags) ) 

#define IVideoProcAmp_put_Gain(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Gain(This,Value,Flags) ) 

#define IVideoProcAmp_getRange_Gain(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Gain(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define IVideoProcAmp_get_Hue(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_Hue(This,pValue,pFlags) ) 

#define IVideoProcAmp_put_Hue(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_Hue(This,Value,Flags) ) 

#define IVideoProcAmp_getRange_Hue(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_Hue(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define IVideoProcAmp_get_DigitalMultiplier(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_DigitalMultiplier(This,pValue,pFlags) ) 

#define IVideoProcAmp_put_DigitalMultiplier(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_DigitalMultiplier(This,Value,Flags) ) 

#define IVideoProcAmp_getRange_DigitalMultiplier(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_DigitalMultiplier(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define IVideoProcAmp_get_PowerlineFrequency(This,pValue,pFlags)	\
    ( (This)->lpVtbl -> get_PowerlineFrequency(This,pValue,pFlags) ) 

#define IVideoProcAmp_put_PowerlineFrequency(This,Value,Flags)	\
    ( (This)->lpVtbl -> put_PowerlineFrequency(This,Value,Flags) ) 

#define IVideoProcAmp_getRange_PowerlineFrequency(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_PowerlineFrequency(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#define IVideoProcAmp_get_WhiteBalanceComponent(This,pValue1,pValue2,pFlags)	\
    ( (This)->lpVtbl -> get_WhiteBalanceComponent(This,pValue1,pValue2,pFlags) ) 

#define IVideoProcAmp_put_WhiteBalanceComponent(This,Value1,Value2,Flags)	\
    ( (This)->lpVtbl -> put_WhiteBalanceComponent(This,Value1,Value2,Flags) ) 

#define IVideoProcAmp_getRange_WhiteBalanceComponent(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag)	\
    ( (This)->lpVtbl -> getRange_WhiteBalanceComponent(This,pMin,pMax,pSteppingDelta,pDefault,pCapsFlag) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVideoProcAmp_INTERFACE_DEFINED__ */


#ifndef __IKsNodeControl_INTERFACE_DEFINED__
#define __IKsNodeControl_INTERFACE_DEFINED__

/* interface IKsNodeControl */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IKsNodeControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11737C14-24A7-4bb5-81A0-0D003813B0C4")
    IKsNodeControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_NodeId( 
            /* [in] */ DWORD dwNodeId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_KsControl( 
            /* [in] */ PVOID pKsControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKsNodeControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKsNodeControl * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKsNodeControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKsNodeControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_NodeId )( 
            IKsNodeControl * This,
            /* [in] */ DWORD dwNodeId);
        
        HRESULT ( STDMETHODCALLTYPE *put_KsControl )( 
            IKsNodeControl * This,
            /* [in] */ PVOID pKsControl);
        
        END_INTERFACE
    } IKsNodeControlVtbl;

    interface IKsNodeControl
    {
        CONST_VTBL struct IKsNodeControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKsNodeControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IKsNodeControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IKsNodeControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IKsNodeControl_put_NodeId(This,dwNodeId)	\
    ( (This)->lpVtbl -> put_NodeId(This,dwNodeId) ) 

#define IKsNodeControl_put_KsControl(This,pKsControl)	\
    ( (This)->lpVtbl -> put_KsControl(This,pKsControl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IKsNodeControl_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\videoacc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for videoacc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __videoacc_h__
#define __videoacc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAMVideoAcceleratorNotify_FWD_DEFINED__
#define __IAMVideoAcceleratorNotify_FWD_DEFINED__
typedef interface IAMVideoAcceleratorNotify IAMVideoAcceleratorNotify;
#endif 	/* __IAMVideoAcceleratorNotify_FWD_DEFINED__ */


#ifndef __IAMVideoAccelerator_FWD_DEFINED__
#define __IAMVideoAccelerator_FWD_DEFINED__
typedef interface IAMVideoAccelerator IAMVideoAccelerator;
#endif 	/* __IAMVideoAccelerator_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_videoacc_0000_0000 */
/* [local] */ 

//
//   The following declarations within the 'if 0' block are dummy typedefs used to make
//   the motncomp.idl file build.  The actual definitions are contained in ddraw.h and amva.h
//
#if 0
typedef void *LPVOID;

typedef void *LPGUID;

typedef void *LPDIRECTDRAWSURFACE;

typedef void *LPDDPIXELFORMAT;

typedef void *LPAMVAInternalMemInfo;

typedef void AMVAUncompDataInfo;

typedef void *LPAMVACompBufferInfo;

typedef void AMVABUFFERINFO;

typedef void AMVAEndFrameInfo;

typedef void *LPAMVAUncompBufferInfo;

typedef void AMVABeginFrameInfo;

typedef IUnknown *IMediaSample;

#endif
#include <ddraw.h>
#include <amva.h>


extern RPC_IF_HANDLE __MIDL_itf_videoacc_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_videoacc_0000_0000_v0_0_s_ifspec;

#ifndef __IAMVideoAcceleratorNotify_INTERFACE_DEFINED__
#define __IAMVideoAcceleratorNotify_INTERFACE_DEFINED__

/* interface IAMVideoAcceleratorNotify */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IAMVideoAcceleratorNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("256A6A21-FBAD-11d1-82BF-00A0C9696C8F")
    IAMVideoAcceleratorNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUncompSurfacesInfo( 
            /* [in] */ const GUID *pGuid,
            /* [annotation][out][in] */ 
            __inout  LPAMVAUncompBufferInfo pUncompBufferInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUncompSurfacesInfo( 
            /* [in] */ DWORD dwActualUncompSurfacesAllocated) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCreateVideoAcceleratorData( 
            /* [in] */ const GUID *pGuid,
            /* [annotation][out] */ 
            __out  LPDWORD pdwSizeMiscData,
            /* [annotation][out] */ 
            __deref_out_bcount(*pdwSizeMiscData)  LPVOID *ppMiscData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoAcceleratorNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoAcceleratorNotify * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoAcceleratorNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoAcceleratorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUncompSurfacesInfo )( 
            IAMVideoAcceleratorNotify * This,
            /* [in] */ const GUID *pGuid,
            /* [annotation][out][in] */ 
            __inout  LPAMVAUncompBufferInfo pUncompBufferInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetUncompSurfacesInfo )( 
            IAMVideoAcceleratorNotify * This,
            /* [in] */ DWORD dwActualUncompSurfacesAllocated);
        
        HRESULT ( STDMETHODCALLTYPE *GetCreateVideoAcceleratorData )( 
            IAMVideoAcceleratorNotify * This,
            /* [in] */ const GUID *pGuid,
            /* [annotation][out] */ 
            __out  LPDWORD pdwSizeMiscData,
            /* [annotation][out] */ 
            __deref_out_bcount(*pdwSizeMiscData)  LPVOID *ppMiscData);
        
        END_INTERFACE
    } IAMVideoAcceleratorNotifyVtbl;

    interface IAMVideoAcceleratorNotify
    {
        CONST_VTBL struct IAMVideoAcceleratorNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoAcceleratorNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMVideoAcceleratorNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMVideoAcceleratorNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMVideoAcceleratorNotify_GetUncompSurfacesInfo(This,pGuid,pUncompBufferInfo)	\
    ( (This)->lpVtbl -> GetUncompSurfacesInfo(This,pGuid,pUncompBufferInfo) ) 

#define IAMVideoAcceleratorNotify_SetUncompSurfacesInfo(This,dwActualUncompSurfacesAllocated)	\
    ( (This)->lpVtbl -> SetUncompSurfacesInfo(This,dwActualUncompSurfacesAllocated) ) 

#define IAMVideoAcceleratorNotify_GetCreateVideoAcceleratorData(This,pGuid,pdwSizeMiscData,ppMiscData)	\
    ( (This)->lpVtbl -> GetCreateVideoAcceleratorData(This,pGuid,pdwSizeMiscData,ppMiscData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMVideoAcceleratorNotify_INTERFACE_DEFINED__ */


#ifndef __IAMVideoAccelerator_INTERFACE_DEFINED__
#define __IAMVideoAccelerator_INTERFACE_DEFINED__

/* interface IAMVideoAccelerator */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IAMVideoAccelerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("256A6A22-FBAD-11d1-82BF-00A0C9696C8F")
    IAMVideoAccelerator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVideoAcceleratorGUIDs( 
            /* [annotation][out][in] */ 
            __inout  LPDWORD pdwNumGuidsSupported,
            /* [annotation][out][in] */ 
            __out_ecount_part_opt(*pdwNumGuidsSupported, *pdwNumGuidsSupported)  LPGUID pGuidsSupported) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUncompFormatsSupported( 
            /* [in] */ const GUID *pGuid,
            /* [annotation][out][in] */ 
            __inout  LPDWORD pdwNumFormatsSupported,
            /* [annotation][out][in] */ 
            __out_ecount_part_opt(*pdwNumFormatsSupported, *pdwNumFormatsSupported)  LPDDPIXELFORMAT pFormatsSupported) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInternalMemInfo( 
            /* [in] */ const GUID *pGuid,
            /* [in] */ const AMVAUncompDataInfo *pamvaUncompDataInfo,
            /* [annotation][out][in] */ 
            __inout  LPAMVAInternalMemInfo pamvaInternalMemInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompBufferInfo( 
            /* [in] */ const GUID *pGuid,
            /* [in] */ const AMVAUncompDataInfo *pamvaUncompDataInfo,
            /* [annotation][out][in] */ 
            __inout  LPDWORD pdwNumTypesCompBuffers,
            /* [annotation][out] */ 
            __out_ecount_part_opt(*pdwNumTypesCompBuffers, *pdwNumTypesCompBuffers)  LPAMVACompBufferInfo pamvaCompBufferInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInternalCompBufferInfo( 
            /* [annotation][out][in] */ 
            __inout  LPDWORD pdwNumTypesCompBuffers,
            /* [annotation][out] */ 
            __out_ecount_part_opt(*pdwNumTypesCompBuffers, *pdwNumTypesCompBuffers)  LPAMVACompBufferInfo pamvaCompBufferInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginFrame( 
            /* [in] */ const AMVABeginFrameInfo *amvaBeginFrameInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndFrame( 
            /* [in] */ const AMVAEndFrameInfo *pEndFrameInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [in] */ DWORD dwTypeIndex,
            /* [in] */ DWORD dwBufferIndex,
            /* [in] */ BOOL bReadOnly,
            /* [annotation][out] */ 
            __out  LPVOID *ppBuffer,
            /* [annotation][out] */ 
            __out  LONG *lpStride) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseBuffer( 
            /* [in] */ DWORD dwTypeIndex,
            /* [in] */ DWORD dwBufferIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ DWORD dwFunction,
            /* [in] */ LPVOID lpPrivateInputData,
            /* [in] */ DWORD cbPrivateInputData,
            /* [in] */ LPVOID lpPrivateOutputDat,
            /* [in] */ DWORD cbPrivateOutputData,
            /* [in] */ DWORD dwNumBuffers,
            /* [annotation][in] */ 
            __in_ecount(dwNumBuffers)  const AMVABUFFERINFO *pamvaBufferInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryRenderStatus( 
            /* [in] */ DWORD dwTypeIndex,
            /* [in] */ DWORD dwBufferIndex,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayFrame( 
            /* [in] */ DWORD dwFlipToIndex,
            /* [in] */ IMediaSample *pMediaSample) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoAcceleratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoAccelerator * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoAccelerator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoAccelerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoAcceleratorGUIDs )( 
            IAMVideoAccelerator * This,
            /* [annotation][out][in] */ 
            __inout  LPDWORD pdwNumGuidsSupported,
            /* [annotation][out][in] */ 
            __out_ecount_part_opt(*pdwNumGuidsSupported, *pdwNumGuidsSupported)  LPGUID pGuidsSupported);
        
        HRESULT ( STDMETHODCALLTYPE *GetUncompFormatsSupported )( 
            IAMVideoAccelerator * This,
            /* [in] */ const GUID *pGuid,
            /* [annotation][out][in] */ 
            __inout  LPDWORD pdwNumFormatsSupported,
            /* [annotation][out][in] */ 
            __out_ecount_part_opt(*pdwNumFormatsSupported, *pdwNumFormatsSupported)  LPDDPIXELFORMAT pFormatsSupported);
        
        HRESULT ( STDMETHODCALLTYPE *GetInternalMemInfo )( 
            IAMVideoAccelerator * This,
            /* [in] */ const GUID *pGuid,
            /* [in] */ const AMVAUncompDataInfo *pamvaUncompDataInfo,
            /* [annotation][out][in] */ 
            __inout  LPAMVAInternalMemInfo pamvaInternalMemInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompBufferInfo )( 
            IAMVideoAccelerator * This,
            /* [in] */ const GUID *pGuid,
            /* [in] */ const AMVAUncompDataInfo *pamvaUncompDataInfo,
            /* [annotation][out][in] */ 
            __inout  LPDWORD pdwNumTypesCompBuffers,
            /* [annotation][out] */ 
            __out_ecount_part_opt(*pdwNumTypesCompBuffers, *pdwNumTypesCompBuffers)  LPAMVACompBufferInfo pamvaCompBufferInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetInternalCompBufferInfo )( 
            IAMVideoAccelerator * This,
            /* [annotation][out][in] */ 
            __inout  LPDWORD pdwNumTypesCompBuffers,
            /* [annotation][out] */ 
            __out_ecount_part_opt(*pdwNumTypesCompBuffers, *pdwNumTypesCompBuffers)  LPAMVACompBufferInfo pamvaCompBufferInfo);
        
        HRESULT ( STDMETHODCALLTYPE *BeginFrame )( 
            IAMVideoAccelerator * This,
            /* [in] */ const AMVABeginFrameInfo *amvaBeginFrameInfo);
        
        HRESULT ( STDMETHODCALLTYPE *EndFrame )( 
            IAMVideoAccelerator * This,
            /* [in] */ const AMVAEndFrameInfo *pEndFrameInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IAMVideoAccelerator * This,
            /* [in] */ DWORD dwTypeIndex,
            /* [in] */ DWORD dwBufferIndex,
            /* [in] */ BOOL bReadOnly,
            /* [annotation][out] */ 
            __out  LPVOID *ppBuffer,
            /* [annotation][out] */ 
            __out  LONG *lpStride);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
            IAMVideoAccelerator * This,
            /* [in] */ DWORD dwTypeIndex,
            /* [in] */ DWORD dwBufferIndex);
        
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IAMVideoAccelerator * This,
            /* [in] */ DWORD dwFunction,
            /* [in] */ LPVOID lpPrivateInputData,
            /* [in] */ DWORD cbPrivateInputData,
            /* [in] */ LPVOID lpPrivateOutputDat,
            /* [in] */ DWORD cbPrivateOutputData,
            /* [in] */ DWORD dwNumBuffers,
            /* [annotation][in] */ 
            __in_ecount(dwNumBuffers)  const AMVABUFFERINFO *pamvaBufferInfo);
        
        HRESULT ( STDMETHODCALLTYPE *QueryRenderStatus )( 
            IAMVideoAccelerator * This,
            /* [in] */ DWORD dwTypeIndex,
            /* [in] */ DWORD dwBufferIndex,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayFrame )( 
            IAMVideoAccelerator * This,
            /* [in] */ DWORD dwFlipToIndex,
            /* [in] */ IMediaSample *pMediaSample);
        
        END_INTERFACE
    } IAMVideoAcceleratorVtbl;

    interface IAMVideoAccelerator
    {
        CONST_VTBL struct IAMVideoAcceleratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoAccelerator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMVideoAccelerator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMVideoAccelerator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMVideoAccelerator_GetVideoAcceleratorGUIDs(This,pdwNumGuidsSupported,pGuidsSupported)	\
    ( (This)->lpVtbl -> GetVideoAcceleratorGUIDs(This,pdwNumGuidsSupported,pGuidsSupported) ) 

#define IAMVideoAccelerator_GetUncompFormatsSupported(This,pGuid,pdwNumFormatsSupported,pFormatsSupported)	\
    ( (This)->lpVtbl -> GetUncompFormatsSupported(This,pGuid,pdwNumFormatsSupported,pFormatsSupported) ) 

#define IAMVideoAccelerator_GetInternalMemInfo(This,pGuid,pamvaUncompDataInfo,pamvaInternalMemInfo)	\
    ( (This)->lpVtbl -> GetInternalMemInfo(This,pGuid,pamvaUncompDataInfo,pamvaInternalMemInfo) ) 

#define IAMVideoAccelerator_GetCompBufferInfo(This,pGuid,pamvaUncompDataInfo,pdwNumTypesCompBuffers,pamvaCompBufferInfo)	\
    ( (This)->lpVtbl -> GetCompBufferInfo(This,pGuid,pamvaUncompDataInfo,pdwNumTypesCompBuffers,pamvaCompBufferInfo) ) 

#define IAMVideoAccelerator_GetInternalCompBufferInfo(This,pdwNumTypesCompBuffers,pamvaCompBufferInfo)	\
    ( (This)->lpVtbl -> GetInternalCompBufferInfo(This,pdwNumTypesCompBuffers,pamvaCompBufferInfo) ) 

#define IAMVideoAccelerator_BeginFrame(This,amvaBeginFrameInfo)	\
    ( (This)->lpVtbl -> BeginFrame(This,amvaBeginFrameInfo) ) 

#define IAMVideoAccelerator_EndFrame(This,pEndFrameInfo)	\
    ( (This)->lpVtbl -> EndFrame(This,pEndFrameInfo) ) 

#define IAMVideoAccelerator_GetBuffer(This,dwTypeIndex,dwBufferIndex,bReadOnly,ppBuffer,lpStride)	\
    ( (This)->lpVtbl -> GetBuffer(This,dwTypeIndex,dwBufferIndex,bReadOnly,ppBuffer,lpStride) ) 

#define IAMVideoAccelerator_ReleaseBuffer(This,dwTypeIndex,dwBufferIndex)	\
    ( (This)->lpVtbl -> ReleaseBuffer(This,dwTypeIndex,dwBufferIndex) ) 

#define IAMVideoAccelerator_Execute(This,dwFunction,lpPrivateInputData,cbPrivateInputData,lpPrivateOutputDat,cbPrivateOutputData,dwNumBuffers,pamvaBufferInfo)	\
    ( (This)->lpVtbl -> Execute(This,dwFunction,lpPrivateInputData,cbPrivateInputData,lpPrivateOutputDat,cbPrivateOutputData,dwNumBuffers,pamvaBufferInfo) ) 

#define IAMVideoAccelerator_QueryRenderStatus(This,dwTypeIndex,dwBufferIndex,dwFlags)	\
    ( (This)->lpVtbl -> QueryRenderStatus(This,dwTypeIndex,dwBufferIndex,dwFlags) ) 

#define IAMVideoAccelerator_DisplayFrame(This,dwFlipToIndex,pMediaSample)	\
    ( (This)->lpVtbl -> DisplayFrame(This,dwFlipToIndex,pMediaSample) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMVideoAccelerator_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\virtdisk.h ===
/*++

Copyright (c) 1999 - 2008  Microsoft Corporation

Module Name:

    VirtDisk.w - Virtual Disk user mode interface

Abstract:

    This is the header file defining the data structures and user mode interface
    implemented by the virtual disk system.


Environment:

    User mode


--*/


#ifndef VIRT_DISK_API_DEF
#define VIRT_DISK_API_DEF

#if ((WINVER >= _WIN32_WINNT_WIN7) || defined(VIRTDISK_DEFINE_FLAGS))

#pragma warning(push)
#pragma warning(disable : 4200)
#pragma warning(disable : 4201)

#ifdef __cplusplus
extern "C" {
#endif

//
// Identifiers for virtual storage types and providers
//

#ifndef _VIRTUAL_STORAGE_TYPE_DEFINED
#define _VIRTUAL_STORAGE_TYPE_DEFINED
typedef struct _VIRTUAL_STORAGE_TYPE
{
    ULONG DeviceId;
    GUID  VendorId;
} VIRTUAL_STORAGE_TYPE, *PVIRTUAL_STORAGE_TYPE;
#endif

#ifdef DEFINE_GUID
DEFINE_GUID(VIRTUAL_STORAGE_TYPE_VENDOR_UNKNOWN, 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

// {EC984AEC-A0F9-47e9-901F-71415A66345B}
DEFINE_GUID(VIRTUAL_STORAGE_TYPE_VENDOR_MICROSOFT, 0xec984aec, 0xa0f9, 0x47e9, 0x90, 0x1f, 0x71, 0x41, 0x5a, 0x66, 0x34, 0x5b);
#endif


#define VIRTUAL_STORAGE_TYPE_DEVICE_UNKNOWN     0
#define VIRTUAL_STORAGE_TYPE_DEVICE_ISO         1
#define VIRTUAL_STORAGE_TYPE_DEVICE_VHD         2


#if !defined(VIRTDISK_DEFINE_FLAGS)


//
// CreateVirtualDisk
//

//
// This value causes the implementation defaults to be used for block size:
//
// Fixed VHDs: 0 is the only valid value since block size is N/A.
// Dynamic VHDs: The default block size will be used (2 MB, subject to change).
// Differencing VHDs: 0 causes the parent VHD's block size to be used.
//
#define CREATE_VIRTUAL_DISK_PARAMETERS_DEFAULT_BLOCK_SIZE 0

// Default sector size is 512B
#define CREATE_VIRTUAL_DISK_PARAMETERS_DEFAULT_SECTOR_SIZE 0x200


// Version definitions
typedef enum _CREATE_VIRTUAL_DISK_VERSION
{
    CREATE_VIRTUAL_DISK_VERSION_UNSPECIFIED = 0,
    CREATE_VIRTUAL_DISK_VERSION_1           = 1,

} CREATE_VIRTUAL_DISK_VERSION;


// Versioned CreateVirtualDisk parameter structure
typedef struct _CREATE_VIRTUAL_DISK_PARAMETERS
{
    CREATE_VIRTUAL_DISK_VERSION Version;

    union
    {
        struct
        {
            GUID                  UniqueId;
            ULONGLONG             MaximumSize;
            ULONG                 BlockSizeInBytes;
            ULONG                 SectorSizeInBytes;
            PCWSTR                ParentPath;
            PCWSTR                SourcePath;
        } Version1;
    };
} CREATE_VIRTUAL_DISK_PARAMETERS, *PCREATE_VIRTUAL_DISK_PARAMETERS;


// Flags for CreateVirtualDisk
typedef enum _CREATE_VIRTUAL_DISK_FLAG
{
    CREATE_VIRTUAL_DISK_FLAG_NONE                     = 0x00000000,

    // Pre-allocate all physical space necessary for the virtual
    // size of the disk (e.g. a fixed VHD).
    CREATE_VIRTUAL_DISK_FLAG_FULL_PHYSICAL_ALLOCATION = 0x00000001,

} CREATE_VIRTUAL_DISK_FLAG;

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(CREATE_VIRTUAL_DISK_FLAG);
#endif


// The default RW Depth parameter value
#define OPEN_VIRTUAL_DISK_RW_DEPTH_DEFAULT 1


// Version definitions
typedef enum _OPEN_VIRTUAL_DISK_VERSION
{
    OPEN_VIRTUAL_DISK_VERSION_UNSPECIFIED = 0,
    OPEN_VIRTUAL_DISK_VERSION_1           = 1,

} OPEN_VIRTUAL_DISK_VERSION;


// Versioned OpenVirtualDisk parameter structure
typedef struct _OPEN_VIRTUAL_DISK_PARAMETERS
{
    OPEN_VIRTUAL_DISK_VERSION Version;

    union
    {
        struct
        {
            ULONG RWDepth;
        } Version1;
    };
} OPEN_VIRTUAL_DISK_PARAMETERS, *POPEN_VIRTUAL_DISK_PARAMETERS;

#endif // VIRTDISK_DEFINE_FLAGS

//
//  Access Mask for OpenVirtualDisk and CreateVirtualDisk.  The virtual
//  disk drivers expose file objects as handles therefore we map
//  it into that AccessMask space.
//

#if defined(__midl)
typedef [v1_enum] enum _VIRTUAL_DISK_ACCESS_MASK {
#else
typedef enum _VIRTUAL_DISK_ACCESS_MASK {
#endif
    VIRTUAL_DISK_ACCESS_ATTACH_RO           = 0x00010000,
    VIRTUAL_DISK_ACCESS_ATTACH_RW           = 0x00020000,
    VIRTUAL_DISK_ACCESS_DETACH              = 0x00040000,
    VIRTUAL_DISK_ACCESS_GET_INFO            = 0x00080000,
    VIRTUAL_DISK_ACCESS_CREATE              = 0x00100000,
    VIRTUAL_DISK_ACCESS_METAOPS             = 0x00200000,
    VIRTUAL_DISK_ACCESS_READ                = 0x000d0000,
    VIRTUAL_DISK_ACCESS_ALL                 = 0x003f0000,

    //
    // A special flag to be used to test if the virtual disk needs to be
    // opened for write.
    //

    VIRTUAL_DISK_ACCESS_WRITABLE            = 0x00320000

} VIRTUAL_DISK_ACCESS_MASK;

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(VIRTUAL_DISK_ACCESS_MASK);
#endif

// Flags for OpenVirtualDisk
typedef enum _OPEN_VIRTUAL_DISK_FLAG
{
    OPEN_VIRTUAL_DISK_FLAG_NONE                = 0x00000000,

    // Open the backing store without opening any differencing chain parents.
    // This allows one to fixup broken parent links.
    OPEN_VIRTUAL_DISK_FLAG_NO_PARENTS          = 0x00000001,

    // The backing store being opened is an empty file. Do not perform virtual
    // disk verification.
    OPEN_VIRTUAL_DISK_FLAG_BLANK_FILE          = 0x00000002,

    // This flag is only specified at boot time to load the system disk
    // during virtual disk boot.  Must be kernel mode to specify this flag.
    OPEN_VIRTUAL_DISK_FLAG_BOOT_DRIVE          = 0x00000004,

} OPEN_VIRTUAL_DISK_FLAG;

#if !defined(VIRTDISK_DEFINE_FLAGS)

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(OPEN_VIRTUAL_DISK_FLAG);
#endif

DWORD
WINAPI
OpenVirtualDisk(
    __in     PVIRTUAL_STORAGE_TYPE         VirtualStorageType,
    __in     PCWSTR                        Path,
    __in     VIRTUAL_DISK_ACCESS_MASK      VirtualDiskAccessMask,
    __in     OPEN_VIRTUAL_DISK_FLAG        Flags,
    __in_opt POPEN_VIRTUAL_DISK_PARAMETERS Parameters,
    __out    PHANDLE                       Handle
    );

DWORD
WINAPI
CreateVirtualDisk(
    __in      PVIRTUAL_STORAGE_TYPE           VirtualStorageType,
    __in      PCWSTR                          Path,
    __in      VIRTUAL_DISK_ACCESS_MASK        VirtualDiskAccessMask,
    __in_opt  PSECURITY_DESCRIPTOR            SecurityDescriptor,
    __in      CREATE_VIRTUAL_DISK_FLAG        Flags,
    __in      ULONG                           ProviderSpecificFlags,
    __in      PCREATE_VIRTUAL_DISK_PARAMETERS Parameters,
    __in_opt  LPOVERLAPPED                    Overlapped,
    __out     PHANDLE                         Handle
    );


//
// AttachVirtualDisk
//

// Version definitions
typedef enum _ATTACH_VIRTUAL_DISK_VERSION
{
    ATTACH_VIRTUAL_DISK_VERSION_UNSPECIFIED = 0,
    ATTACH_VIRTUAL_DISK_VERSION_1           = 1,

} ATTACH_VIRTUAL_DISK_VERSION;

// Versioned parameter structure for AttachVirtualDisk
typedef struct _ATTACH_VIRTUAL_DISK_PARAMETERS
{
    ATTACH_VIRTUAL_DISK_VERSION Version;

    union
    {
        struct
        {
            ULONG Reserved;
        } Version1;
    };
} ATTACH_VIRTUAL_DISK_PARAMETERS, *PATTACH_VIRTUAL_DISK_PARAMETERS;

#endif // VIRTDISK_DEFINE_FLAGS

// Flags for AttachVirtualDisk
typedef enum _ATTACH_VIRTUAL_DISK_FLAG
{
    ATTACH_VIRTUAL_DISK_FLAG_NONE                = 0x00000000,

    // Attach the disk as read only
    ATTACH_VIRTUAL_DISK_FLAG_READ_ONLY           = 0x00000001,

    // Will cause all volumes on the disk to be mounted
    // without drive letters.
    //
    ATTACH_VIRTUAL_DISK_FLAG_NO_DRIVE_LETTER     = 0x00000002,

    // Will decouple the disk lifetime from that of the VirtualDiskHandle.
    // The disk will be attached until an explicit call is made to
    // DetachVirtualDisk, even if all handles are closed.
    ATTACH_VIRTUAL_DISK_FLAG_PERMANENT_LIFETIME  = 0x00000004,

    // Indicates that the drive will not be attached to
    // the local system (but rather to a VM).
    ATTACH_VIRTUAL_DISK_FLAG_NO_LOCAL_HOST       = 0x00000008,

} ATTACH_VIRTUAL_DISK_FLAG;

#if !defined(VIRTDISK_DEFINE_FLAGS)

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(ATTACH_VIRTUAL_DISK_FLAG);
#endif

DWORD
WINAPI
AttachVirtualDisk(
    __in     HANDLE                             VirtualDiskHandle,
    __in_opt PSECURITY_DESCRIPTOR               SecurityDescriptor,
    __in     ATTACH_VIRTUAL_DISK_FLAG           Flags,
    __in     ULONG                              ProviderSpecificFlags,
    __in_opt PATTACH_VIRTUAL_DISK_PARAMETERS    Parameters,
    __in_opt LPOVERLAPPED                       Overlapped
    );



//
// DetachVirtualDisk
//

#endif // VIRTDISK_DEFINE_FLAGS

// Flags for DetachVirtualDisk
typedef enum _DETACH_VIRTUAL_DISK_FLAG
{
    DETACH_VIRTUAL_DISK_FLAG_NONE                = 0x00000000,

} DETACH_VIRTUAL_DISK_FLAG;

#if !defined(VIRTDISK_DEFINE_FLAGS)

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(DETACH_VIRTUAL_DISK_FLAG);
#endif

DWORD
WINAPI
DetachVirtualDisk(
    __in     HANDLE                   VirtualDiskHandle,
    __in     DETACH_VIRTUAL_DISK_FLAG Flags,
    __in     ULONG                    ProviderSpecificFlags
    );


//
// GetVirtualDiskPhysicalPath
//

DWORD
WINAPI
GetVirtualDiskPhysicalPath(
    __in                              HANDLE VirtualDiskHandle,
    __inout                           PULONG DiskPathSizeInBytes,
    __out_bcount(DiskPathSizeInBytes) PWSTR  DiskPath
    );

#endif // VIRTDISK_DEFINE_FLAGS

//
// GetStorageDependencyInformation
//

// Flags for dependent disks
typedef enum _DEPENDENT_DISK_FLAG
{
    DEPENDENT_DISK_FLAG_NONE                 = 0x00000000,

    //
    // Multiple files backing the virtual storage device
    //
    DEPENDENT_DISK_FLAG_MULT_BACKING_FILES   = 0x00000001,

    DEPENDENT_DISK_FLAG_FULLY_ALLOCATED      = 0x00000002,

    DEPENDENT_DISK_FLAG_READ_ONLY            = 0x00000004,

    //
    //Backing file of the virtual storage device is not local to the machine
    //
    DEPENDENT_DISK_FLAG_REMOTE               = 0x00000008,

    //
    // Volume is the system volume
    //
    DEPENDENT_DISK_FLAG_SYSTEM_VOLUME        = 0x00000010,

    //
    // Volume backing the virtual storage device file is the system volume
    //
    DEPENDENT_DISK_FLAG_SYSTEM_VOLUME_PARENT = 0x00000020,

    DEPENDENT_DISK_FLAG_REMOVABLE            = 0x00000040,

    //
    // Drive letters are not assigned to the volumes
    // on the virtual disk automatically.
    //
    DEPENDENT_DISK_FLAG_NO_DRIVE_LETTER      = 0x00000080,

    DEPENDENT_DISK_FLAG_PARENT               = 0x00000100,

    //
    // Virtual disk is not attached on the local host
    // (instead attached on a guest VM for instance)
    //
    DEPENDENT_DISK_FLAG_NO_HOST_DISK         = 0x00000200,

    //
    // Indicates the lifetime of the disk is not tied
    // to any system handles
    //
    DEPENDENT_DISK_FLAG_PERMANENT_LIFETIME   = 0x00000400,

} DEPENDENT_DISK_FLAG;

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(DEPENDENT_DISK_FLAG);
#endif

#if !defined(VIRTDISK_DEFINE_FLAGS)

// Version definitions
typedef enum _STORAGE_DEPENDENCY_INFO_VERSION
{
    STORAGE_DEPENDENCY_INFO_VERSION_UNSPECIFIED = 0,
    STORAGE_DEPENDENCY_INFO_VERSION_1           = 1,
    STORAGE_DEPENDENCY_INFO_VERSION_2           = 2,

} STORAGE_DEPENDENCY_INFO_VERSION;


// Parameter structure for GetStorageDependencyInformation
typedef struct _STORAGE_DEPENDENCY_INFO_TYPE_1
{
    DEPENDENT_DISK_FLAG   DependencyTypeFlags;
    ULONG                 ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE  VirtualStorageType;
} STORAGE_DEPENDENCY_INFO_TYPE_1, *PSTORAGE_DEPENDENCY_INFO_TYPE_1;


// Parameter structure for GetStorageDependencyInformation
typedef struct _STORAGE_DEPENDENCY_INFO_TYPE_2
{
    DEPENDENT_DISK_FLAG  DependencyTypeFlags;
    ULONG                ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
    ULONG                AncestorLevel;
    PWSTR                DependencyDeviceName;
    PWSTR                HostVolumeName;
    PWSTR                DependentVolumeName;
    PWSTR                DependentVolumeRelativePath;
} STORAGE_DEPENDENCY_INFO_TYPE_2, *PSTORAGE_DEPENDENCY_INFO_TYPE_2;


// Parameter structure for GetStorageDependencyInformation
typedef struct _STORAGE_DEPENDENCY_INFO
{
    STORAGE_DEPENDENCY_INFO_VERSION Version;
    ULONG NumberEntries;
    union
    {
        STORAGE_DEPENDENCY_INFO_TYPE_1 Version1Entries[];
        STORAGE_DEPENDENCY_INFO_TYPE_2 Version2Entries[];
    };
} STORAGE_DEPENDENCY_INFO, *PSTORAGE_DEPENDENCY_INFO;

#endif // VIRTDISK_DEFINE_FLAGS

// Flags for GetStorageDependencyInformation
typedef enum _GET_STORAGE_DEPENDENCY_FLAG
{
    GET_STORAGE_DEPENDENCY_FLAG_NONE         = 0x00000000,

    // Return information for volumes or disks hosting the volume specified
    // If not set, returns info about volumes or disks being hosted by
    // the volume or disk specified
    GET_STORAGE_DEPENDENCY_FLAG_HOST_VOLUMES = 0x00000001,

    //  The handle provided is to a disk, not volume or file
    GET_STORAGE_DEPENDENCY_FLAG_DISK_HANDLE  = 0x00000002,

} GET_STORAGE_DEPENDENCY_FLAG;

#define GET_STORAGE_DEPENDENCY_FLAG_PARENTS GET_STORAGE_DEPENDENCY_FLAG_HOST_VOLUMES

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(GET_STORAGE_DEPENDENCY_FLAG);
#endif

#if !defined(VIRTDISK_DEFINE_FLAGS)

DWORD
WINAPI
GetStorageDependencyInformation(
    __in        HANDLE                      ObjectHandle,
    __in        GET_STORAGE_DEPENDENCY_FLAG Flags,
    __in        ULONG                       StorageDependencyInfoSize,
    __inout     PSTORAGE_DEPENDENCY_INFO    StorageDependencyInfo,
    __inout_opt PULONG                      SizeUsed
    );



//
// GetVirtualDiskInformation
//

// Version definitions
typedef enum _GET_VIRTUAL_DISK_INFO_VERSION
{
    GET_VIRTUAL_DISK_INFO_UNSPECIFIED       = 0,
    GET_VIRTUAL_DISK_INFO_SIZE              = 1,
    GET_VIRTUAL_DISK_INFO_IDENTIFIER        = 2,
    GET_VIRTUAL_DISK_INFO_PARENT_LOCATION   = 3,
    GET_VIRTUAL_DISK_INFO_PARENT_IDENTIFIER = 4,
    GET_VIRTUAL_DISK_INFO_PARENT_TIMESTAMP  = 5,
    GET_VIRTUAL_DISK_INFO_VIRTUAL_STORAGE_TYPE  = 6,
    GET_VIRTUAL_DISK_INFO_PROVIDER_SUBTYPE  = 7,

} GET_VIRTUAL_DISK_INFO_VERSION;


// Versioned parameter structure for GetVirtualDiskInformation
typedef struct _GET_VIRTUAL_DISK_INFO
{
    GET_VIRTUAL_DISK_INFO_VERSION Version;

    union
    {
        struct
        {
            ULONGLONG VirtualSize;
            ULONGLONG PhysicalSize;
            ULONG     BlockSize;
            ULONG     SectorSize;
        } Size;

        GUID Identifier;

        struct
        {
            BOOL  ParentResolved;
            WCHAR ParentLocationBuffer[1];  // MultiSz string
        } ParentLocation;

        GUID ParentIdentifier;

        ULONG ParentTimestamp;

        VIRTUAL_STORAGE_TYPE VirtualStorageType;

        ULONG ProviderSubtype;
    };
} GET_VIRTUAL_DISK_INFO, *PGET_VIRTUAL_DISK_INFO;


DWORD
WINAPI
GetVirtualDiskInformation(
    __in        HANDLE                  VirtualDiskHandle,
    __inout     PULONG                  VirtualDiskInfoSize,
    __inout     PGET_VIRTUAL_DISK_INFO  VirtualDiskInfo,
    __inout_opt PULONG                  SizeUsed
    );



//
// SetVirtualDiskInformation
//

// Version definitions
typedef enum _SET_VIRTUAL_DISK_INFO_VERSION
{
    SET_VIRTUAL_DISK_INFO_UNSPECIFIED       = 0,
    SET_VIRTUAL_DISK_INFO_PARENT_PATH       = 1,
    SET_VIRTUAL_DISK_INFO_IDENTIFIER        = 2,

} SET_VIRTUAL_DISK_INFO_VERSION;


// Versioned parameter structure for SetVirtualDiskInformation
typedef struct _SET_VIRTUAL_DISK_INFO
{
    SET_VIRTUAL_DISK_INFO_VERSION Version;

    union
    {
        PCWSTR ParentFilePath;

        GUID UniqueIdentifier;
    };
} SET_VIRTUAL_DISK_INFO, *PSET_VIRTUAL_DISK_INFO;


DWORD
WINAPI
SetVirtualDiskInformation(
    __in HANDLE                 VirtualDiskHandle,
    __in PSET_VIRTUAL_DISK_INFO VirtualDiskInfo
);



//
// GetVirtualDiskOperationProgress
//

typedef struct _VIRTUAL_DISK_PROGRESS
{
    DWORD      OperationStatus;
    ULONGLONG  CurrentValue;
    ULONGLONG  CompletionValue;
} VIRTUAL_DISK_PROGRESS, *PVIRTUAL_DISK_PROGRESS;


DWORD WINAPI
GetVirtualDiskOperationProgress(
    __in      HANDLE                 VirtualDiskHandle,
    __in      LPOVERLAPPED           Overlapped,
    __out     PVIRTUAL_DISK_PROGRESS Progress
    );



//
// CompactVirtualDisk
//

// Version definitions
typedef enum _COMPACT_VIRTUAL_DISK_VERSION
{
    COMPACT_VIRTUAL_DISK_VERSION_UNSPECIFIED    = 0,
    COMPACT_VIRTUAL_DISK_VERSION_1              = 1,

} COMPACT_VIRTUAL_DISK_VERSION;


// Versioned structure for CompactVirtualDisk
typedef struct _COMPACT_VIRTUAL_DISK_PARAMETERS
{
    COMPACT_VIRTUAL_DISK_VERSION Version;

    union
    {
        struct
        {
            ULONG Reserved;
        } Version1;
    };
} COMPACT_VIRTUAL_DISK_PARAMETERS, *PCOMPACT_VIRTUAL_DISK_PARAMETERS;


// Flags for CompactVirtualDisk
typedef enum _COMPACT_VIRTUAL_DISK_FLAG
{
    COMPACT_VIRTUAL_DISK_FLAG_NONE                 = 0x00000000,

} COMPACT_VIRTUAL_DISK_FLAG;

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(COMPACT_VIRTUAL_DISK_FLAG);
#endif

DWORD
WINAPI
CompactVirtualDisk(
    __in     HANDLE                           VirtualDiskHandle,
    __in     COMPACT_VIRTUAL_DISK_FLAG        Flags,
    __in_opt PCOMPACT_VIRTUAL_DISK_PARAMETERS Parameters,
    __in_opt LPOVERLAPPED                     Overlapped
    );



//
// MergeVirtualDisk
//

// Version definitions
typedef enum _MERGE_VIRTUAL_DISK_VERSION
{
    MERGE_VIRTUAL_DISK_VERSION_UNSPECIFIED    = 0,
    MERGE_VIRTUAL_DISK_VERSION_1              = 1,

} MERGE_VIRTUAL_DISK_VERSION;



// Versioned parameter structure for MergeVirtualDisk
#define MERGE_VIRTUAL_DISK_DEFAULT_MERGE_DEPTH 1

typedef struct _MERGE_VIRTUAL_DISK_PARAMETERS
{
    MERGE_VIRTUAL_DISK_VERSION Version;

    union
    {
        struct
        {
            ULONG MergeDepth;
        } Version1;
    };
} MERGE_VIRTUAL_DISK_PARAMETERS, *PMERGE_VIRTUAL_DISK_PARAMETERS;


// Flags for MergeVirtualDisk
typedef enum _MERGE_VIRTUAL_DISK_FLAG
{
    MERGE_VIRTUAL_DISK_FLAG_NONE                 = 0x00000000,

} MERGE_VIRTUAL_DISK_FLAG;

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(MERGE_VIRTUAL_DISK_FLAG);
#endif

DWORD
WINAPI
MergeVirtualDisk(
    __in     HANDLE                         VirtualDiskHandle,
    __in     MERGE_VIRTUAL_DISK_FLAG        Flags,
    __in     PMERGE_VIRTUAL_DISK_PARAMETERS Parameters,
    __in_opt LPOVERLAPPED                   Overlapped
    );



//
// ExpandVirtualDisk
//

// Version definitions
typedef enum _EXPAND_VIRTUAL_DISK_VERSION
{
    EXPAND_VIRTUAL_DISK_VERSION_UNSPECIFIED    = 0,
    EXPAND_VIRTUAL_DISK_VERSION_1              = 1,

} EXPAND_VIRTUAL_DISK_VERSION;


// Versioned parameter structure for ExpandVirtualDisk
typedef struct _EXPAND_VIRTUAL_DISK_PARAMETERS
{
    EXPAND_VIRTUAL_DISK_VERSION Version;

    union
    {
        struct
        {
            ULONGLONG NewSize;
        } Version1;
    };

} EXPAND_VIRTUAL_DISK_PARAMETERS, *PEXPAND_VIRTUAL_DISK_PARAMETERS;


// Flags for ExpandVirtualDisk
typedef enum _EXPAND_VIRTUAL_DISK_FLAG
{
    EXPAND_VIRTUAL_DISK_FLAG_NONE                 = 0x00000000,

} EXPAND_VIRTUAL_DISK_FLAG;

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(EXPAND_VIRTUAL_DISK_FLAG);
#endif

DWORD
WINAPI
ExpandVirtualDisk(
    __in     HANDLE                          VirtualDiskHandle,
    __in     EXPAND_VIRTUAL_DISK_FLAG        Flags,
    __in     PEXPAND_VIRTUAL_DISK_PARAMETERS Parameters,
    __in_opt LPOVERLAPPED                    Overlapped
    );

#endif // VIRTDISK_DEFINE_FLAGS

//
//  The Surface and Unsurface API names are deprecated.  Use Attach/Detach versions
//  instead.  If you use any of these defines below your code will break post Win7.
//

#define SurfaceVirtualDisk                           AttachVirtualDisk
#define UnsurfaceVirtualDisk                         DetachVirtualDisk
#define VIRTUAL_DISK_ACCESS_SURFACE_RO               VIRTUAL_DISK_ACCESS_ATTACH_RO
#define VIRTUAL_DISK_ACCESS_SURFACE_RW               VIRTUAL_DISK_ACCESS_ATTACH_RW
#define VIRTUAL_DISK_ACCESS_UNSURFACE                VIRTUAL_DISK_ACCESS_DETACH
#define SURFACE_VIRTUAL_DISK_VERSION_UNSPECIFIED     ATTACH_VIRTUAL_DISK_VERSION_UNSPECIFIED
#define SURFACE_VIRTUAL_DISK_VERSION_1               ATTACH_VIRTUAL_DISK_VERSION_1
#define SURFACE_VIRTUAL_DISK_VERSION                 ATTACH_VIRTUAL_DISK_VERSION
#define _SURFACE_VIRTUAL_DISK_VERSION                _ATTACH_VIRTUAL_DISK_VERSION
#define SURFACE_VIRTUAL_DISK_PARAMETERS              ATTACH_VIRTUAL_DISK_PARAMETERS
#define PSURFACE_VIRTUAL_DISK_PARAMETERS             PATTACH_VIRTUAL_DISK_PARAMETERS
#define _SURFACE_VIRTUAL_DISK_PARAMETERS             _ATTACH_VIRTUAL_DISK_PARAMETERS

#if !defined(__midl)

#define _SURFACE_VIRTUAL_DISK_FLAG                   _ATTACH_VIRTUAL_DISK_FLAG 
#define SURFACE_VIRTUAL_DISK_FLAG_NONE               ATTACH_VIRTUAL_DISK_FLAG_NONE
#define SURFACE_VIRTUAL_DISK_FLAG_READ_ONLY          ATTACH_VIRTUAL_DISK_FLAG_READ_ONLY
#define SURFACE_VIRTUAL_DISK_FLAG_NO_DRIVE_LETTER    ATTACH_VIRTUAL_DISK_FLAG_NO_DRIVE_LETTER
#define SURFACE_VIRTUAL_DISK_FLAG_PERMANENT_LIFETIME ATTACH_VIRTUAL_DISK_FLAG_PERMANENT_LIFETIME
#define SURFACE_VIRTUAL_DISK_FLAG_NO_LOCAL_HOST      ATTACH_VIRTUAL_DISK_FLAG_NO_LOCAL_HOST
#define SURFACE_VIRTUAL_DISK_FLAG                    ATTACH_VIRTUAL_DISK_FLAG
#define _UNSURFACE_VIRTUAL_DISK_FLAG                 _DETACH_VIRTUAL_DISK_FLAG
#define UNSURFACE_VIRTUAL_DISK_FLAG_NONE             DETACH_VIRTUAL_DISK_FLAG_NONE
#define UNSURFACE_VIRTUAL_DISK_FLAG                  DETACH_VIRTUAL_DISK_FLAG

#else

typedef enum _SURFACE_VIRTUAL_DISK_FLAG
{
    SURFACE_VIRTUAL_DISK_FLAG_NONE                = 0x00000000,
    SURFACE_VIRTUAL_DISK_FLAG_READ_ONLY           = 0x00000001,
    SURFACE_VIRTUAL_DISK_FLAG_NO_DRIVE_LETTER     = 0x00000002,
    SURFACE_VIRTUAL_DISK_FLAG_PERMANENT_LIFETIME  = 0x00000004,
    SURFACE_VIRTUAL_DISK_FLAG_NO_LOCAL_HOST       = 0x00000008,
} SURFACE_VIRTUAL_DISK_FLAG;

typedef enum _UNSURFACE_VIRTUAL_DISK_FLAG
{
    UNSURFACE_VIRTUAL_DISK_FLAG_NONE                = 0x00000000,
} UNSURFACE_VIRTUAL_DISK_FLAG;

#if !defined(VIRTDISK_DEFINE_FLAGS)

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(SURFACE_VIRTUAL_DISK_FLAG);
#endif
#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(UNSURFACE_VIRTUAL_DISK_FLAG);
#endif
#endif

#endif

//  End deprecated APIs

#ifdef __cplusplus
}
#endif

#pragma warning(pop)

#endif // WIN32_WINNT_WIN7

#endif // VIRT_DISK_API_DEF

// VirtDisk.h EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vmr9.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vmr9.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vmr9_h__
#define __vmr9_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVMRImagePresenter9_FWD_DEFINED__
#define __IVMRImagePresenter9_FWD_DEFINED__
typedef interface IVMRImagePresenter9 IVMRImagePresenter9;
#endif 	/* __IVMRImagePresenter9_FWD_DEFINED__ */


#ifndef __IVMRSurfaceAllocator9_FWD_DEFINED__
#define __IVMRSurfaceAllocator9_FWD_DEFINED__
typedef interface IVMRSurfaceAllocator9 IVMRSurfaceAllocator9;
#endif 	/* __IVMRSurfaceAllocator9_FWD_DEFINED__ */


#ifndef __IVMRSurfaceAllocatorEx9_FWD_DEFINED__
#define __IVMRSurfaceAllocatorEx9_FWD_DEFINED__
typedef interface IVMRSurfaceAllocatorEx9 IVMRSurfaceAllocatorEx9;
#endif 	/* __IVMRSurfaceAllocatorEx9_FWD_DEFINED__ */


#ifndef __IVMRSurfaceAllocatorNotify9_FWD_DEFINED__
#define __IVMRSurfaceAllocatorNotify9_FWD_DEFINED__
typedef interface IVMRSurfaceAllocatorNotify9 IVMRSurfaceAllocatorNotify9;
#endif 	/* __IVMRSurfaceAllocatorNotify9_FWD_DEFINED__ */


#ifndef __IVMRWindowlessControl9_FWD_DEFINED__
#define __IVMRWindowlessControl9_FWD_DEFINED__
typedef interface IVMRWindowlessControl9 IVMRWindowlessControl9;
#endif 	/* __IVMRWindowlessControl9_FWD_DEFINED__ */


#ifndef __IVMRMixerControl9_FWD_DEFINED__
#define __IVMRMixerControl9_FWD_DEFINED__
typedef interface IVMRMixerControl9 IVMRMixerControl9;
#endif 	/* __IVMRMixerControl9_FWD_DEFINED__ */


#ifndef __IVMRMixerBitmap9_FWD_DEFINED__
#define __IVMRMixerBitmap9_FWD_DEFINED__
typedef interface IVMRMixerBitmap9 IVMRMixerBitmap9;
#endif 	/* __IVMRMixerBitmap9_FWD_DEFINED__ */


#ifndef __IVMRSurface9_FWD_DEFINED__
#define __IVMRSurface9_FWD_DEFINED__
typedef interface IVMRSurface9 IVMRSurface9;
#endif 	/* __IVMRSurface9_FWD_DEFINED__ */


#ifndef __IVMRImagePresenterConfig9_FWD_DEFINED__
#define __IVMRImagePresenterConfig9_FWD_DEFINED__
typedef interface IVMRImagePresenterConfig9 IVMRImagePresenterConfig9;
#endif 	/* __IVMRImagePresenterConfig9_FWD_DEFINED__ */


#ifndef __IVMRVideoStreamControl9_FWD_DEFINED__
#define __IVMRVideoStreamControl9_FWD_DEFINED__
typedef interface IVMRVideoStreamControl9 IVMRVideoStreamControl9;
#endif 	/* __IVMRVideoStreamControl9_FWD_DEFINED__ */


#ifndef __IVMRFilterConfig9_FWD_DEFINED__
#define __IVMRFilterConfig9_FWD_DEFINED__
typedef interface IVMRFilterConfig9 IVMRFilterConfig9;
#endif 	/* __IVMRFilterConfig9_FWD_DEFINED__ */


#ifndef __IVMRAspectRatioControl9_FWD_DEFINED__
#define __IVMRAspectRatioControl9_FWD_DEFINED__
typedef interface IVMRAspectRatioControl9 IVMRAspectRatioControl9;
#endif 	/* __IVMRAspectRatioControl9_FWD_DEFINED__ */


#ifndef __IVMRMonitorConfig9_FWD_DEFINED__
#define __IVMRMonitorConfig9_FWD_DEFINED__
typedef interface IVMRMonitorConfig9 IVMRMonitorConfig9;
#endif 	/* __IVMRMonitorConfig9_FWD_DEFINED__ */


#ifndef __IVMRDeinterlaceControl9_FWD_DEFINED__
#define __IVMRDeinterlaceControl9_FWD_DEFINED__
typedef interface IVMRDeinterlaceControl9 IVMRDeinterlaceControl9;
#endif 	/* __IVMRDeinterlaceControl9_FWD_DEFINED__ */


#ifndef __IVMRImageCompositor9_FWD_DEFINED__
#define __IVMRImageCompositor9_FWD_DEFINED__
typedef interface IVMRImageCompositor9 IVMRImageCompositor9;
#endif 	/* __IVMRImageCompositor9_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vmr9_0000_0000 */
/* [local] */ 

#if 0
typedef DWORD IDirect3DDevice9;

typedef DWORD IDirect3DSurface9;

typedef DWORD D3DFORMAT;

typedef DWORD D3DCOLOR;

typedef DWORD D3DPOOL;

typedef LONGLONG REFERENCE_TIME;

typedef DWORD *HMONITOR;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_vmr9_0000_0000_0001
    {
    DWORD dw1;
    DWORD dw2;
    } 	AM_MEDIA_TYPE;

#endif














typedef /* [public] */ 
enum __MIDL___MIDL_itf_vmr9_0000_0000_0002
    {	VMR9Sample_SyncPoint	= 0x1,
	VMR9Sample_Preroll	= 0x2,
	VMR9Sample_Discontinuity	= 0x4,
	VMR9Sample_TimeValid	= 0x8,
	VMR9Sample_SrcDstRectsValid	= 0x10
    } 	VMR9PresentationFlags;

typedef struct _VMR9PresentationInfo
    {
    DWORD dwFlags;
    IDirect3DSurface9 *lpSurf;
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtEnd;
    SIZE szAspectRatio;
    RECT rcSrc;
    RECT rcDst;
    DWORD dwReserved1;
    DWORD dwReserved2;
    } 	VMR9PresentationInfo;



extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0000_v0_0_s_ifspec;

#ifndef __IVMRImagePresenter9_INTERFACE_DEFINED__
#define __IVMRImagePresenter9_INTERFACE_DEFINED__

/* interface IVMRImagePresenter9 */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImagePresenter9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69188c61-12a3-40f0-8ffc-342e7b433fd7")
    IVMRImagePresenter9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartPresenting( 
            /* [in] */ DWORD_PTR dwUserID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopPresenting( 
            /* [in] */ DWORD_PTR dwUserID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PresentImage( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMR9PresentationInfo *lpPresInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImagePresenter9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImagePresenter9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImagePresenter9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImagePresenter9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartPresenting )( 
            IVMRImagePresenter9 * This,
            /* [in] */ DWORD_PTR dwUserID);
        
        HRESULT ( STDMETHODCALLTYPE *StopPresenting )( 
            IVMRImagePresenter9 * This,
            /* [in] */ DWORD_PTR dwUserID);
        
        HRESULT ( STDMETHODCALLTYPE *PresentImage )( 
            IVMRImagePresenter9 * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMR9PresentationInfo *lpPresInfo);
        
        END_INTERFACE
    } IVMRImagePresenter9Vtbl;

    interface IVMRImagePresenter9
    {
        CONST_VTBL struct IVMRImagePresenter9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImagePresenter9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRImagePresenter9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRImagePresenter9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRImagePresenter9_StartPresenting(This,dwUserID)	\
    ( (This)->lpVtbl -> StartPresenting(This,dwUserID) ) 

#define IVMRImagePresenter9_StopPresenting(This,dwUserID)	\
    ( (This)->lpVtbl -> StopPresenting(This,dwUserID) ) 

#define IVMRImagePresenter9_PresentImage(This,dwUserID,lpPresInfo)	\
    ( (This)->lpVtbl -> PresentImage(This,dwUserID,lpPresInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRImagePresenter9_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vmr9_0000_0001 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_vmr9_0000_0001_0001
    {	VMR9AllocFlag_3DRenderTarget	= 0x1,
	VMR9AllocFlag_DXVATarget	= 0x2,
	VMR9AllocFlag_TextureSurface	= 0x4,
	VMR9AllocFlag_OffscreenSurface	= 0x8,
	VMR9AllocFlag_RGBDynamicSwitch	= 0x10,
	VMR9AllocFlag_UsageReserved	= 0xe0,
	VMR9AllocFlag_UsageMask	= 0xff
    } 	VMR9SurfaceAllocationFlags;

typedef struct _VMR9AllocationInfo
    {
    DWORD dwFlags;
    DWORD dwWidth;
    DWORD dwHeight;
    D3DFORMAT Format;
    D3DPOOL Pool;
    DWORD MinBuffers;
    SIZE szAspectRatio;
    SIZE szNativeSize;
    } 	VMR9AllocationInfo;



extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0001_v0_0_s_ifspec;

#ifndef __IVMRSurfaceAllocator9_INTERFACE_DEFINED__
#define __IVMRSurfaceAllocator9_INTERFACE_DEFINED__

/* interface IVMRSurfaceAllocator9 */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurfaceAllocator9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8d5148ea-3f5d-46cf-9df1-d1b896eedb1f")
    IVMRSurfaceAllocator9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeDevice( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMR9AllocationInfo *lpAllocInfo,
            /* [out][in] */ DWORD *lpNumBuffers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateDevice( 
            /* [in] */ DWORD_PTR dwID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ DWORD SurfaceIndex,
            /* [in] */ DWORD SurfaceFlags,
            /* [out] */ IDirect3DSurface9 **lplpSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseNotify( 
            /* [in] */ IVMRSurfaceAllocatorNotify9 *lpIVMRSurfAllocNotify) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurfaceAllocator9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurfaceAllocator9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurfaceAllocator9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurfaceAllocator9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDevice )( 
            IVMRSurfaceAllocator9 * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMR9AllocationInfo *lpAllocInfo,
            /* [out][in] */ DWORD *lpNumBuffers);
        
        HRESULT ( STDMETHODCALLTYPE *TerminateDevice )( 
            IVMRSurfaceAllocator9 * This,
            /* [in] */ DWORD_PTR dwID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IVMRSurfaceAllocator9 * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ DWORD SurfaceIndex,
            /* [in] */ DWORD SurfaceFlags,
            /* [out] */ IDirect3DSurface9 **lplpSurface);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseNotify )( 
            IVMRSurfaceAllocator9 * This,
            /* [in] */ IVMRSurfaceAllocatorNotify9 *lpIVMRSurfAllocNotify);
        
        END_INTERFACE
    } IVMRSurfaceAllocator9Vtbl;

    interface IVMRSurfaceAllocator9
    {
        CONST_VTBL struct IVMRSurfaceAllocator9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurfaceAllocator9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRSurfaceAllocator9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRSurfaceAllocator9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRSurfaceAllocator9_InitializeDevice(This,dwUserID,lpAllocInfo,lpNumBuffers)	\
    ( (This)->lpVtbl -> InitializeDevice(This,dwUserID,lpAllocInfo,lpNumBuffers) ) 

#define IVMRSurfaceAllocator9_TerminateDevice(This,dwID)	\
    ( (This)->lpVtbl -> TerminateDevice(This,dwID) ) 

#define IVMRSurfaceAllocator9_GetSurface(This,dwUserID,SurfaceIndex,SurfaceFlags,lplpSurface)	\
    ( (This)->lpVtbl -> GetSurface(This,dwUserID,SurfaceIndex,SurfaceFlags,lplpSurface) ) 

#define IVMRSurfaceAllocator9_AdviseNotify(This,lpIVMRSurfAllocNotify)	\
    ( (This)->lpVtbl -> AdviseNotify(This,lpIVMRSurfAllocNotify) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRSurfaceAllocator9_INTERFACE_DEFINED__ */


#ifndef __IVMRSurfaceAllocatorEx9_INTERFACE_DEFINED__
#define __IVMRSurfaceAllocatorEx9_INTERFACE_DEFINED__

/* interface IVMRSurfaceAllocatorEx9 */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurfaceAllocatorEx9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6de9a68a-a928-4522-bf57-655ae3866456")
    IVMRSurfaceAllocatorEx9 : public IVMRSurfaceAllocator9
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurfaceEx( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ DWORD SurfaceIndex,
            /* [in] */ DWORD SurfaceFlags,
            /* [out] */ IDirect3DSurface9 **lplpSurface,
            /* [out] */ RECT *lprcDst) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurfaceAllocatorEx9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurfaceAllocatorEx9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurfaceAllocatorEx9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurfaceAllocatorEx9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDevice )( 
            IVMRSurfaceAllocatorEx9 * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMR9AllocationInfo *lpAllocInfo,
            /* [out][in] */ DWORD *lpNumBuffers);
        
        HRESULT ( STDMETHODCALLTYPE *TerminateDevice )( 
            IVMRSurfaceAllocatorEx9 * This,
            /* [in] */ DWORD_PTR dwID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IVMRSurfaceAllocatorEx9 * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ DWORD SurfaceIndex,
            /* [in] */ DWORD SurfaceFlags,
            /* [out] */ IDirect3DSurface9 **lplpSurface);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseNotify )( 
            IVMRSurfaceAllocatorEx9 * This,
            /* [in] */ IVMRSurfaceAllocatorNotify9 *lpIVMRSurfAllocNotify);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurfaceEx )( 
            IVMRSurfaceAllocatorEx9 * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ DWORD SurfaceIndex,
            /* [in] */ DWORD SurfaceFlags,
            /* [out] */ IDirect3DSurface9 **lplpSurface,
            /* [out] */ RECT *lprcDst);
        
        END_INTERFACE
    } IVMRSurfaceAllocatorEx9Vtbl;

    interface IVMRSurfaceAllocatorEx9
    {
        CONST_VTBL struct IVMRSurfaceAllocatorEx9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurfaceAllocatorEx9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRSurfaceAllocatorEx9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRSurfaceAllocatorEx9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRSurfaceAllocatorEx9_InitializeDevice(This,dwUserID,lpAllocInfo,lpNumBuffers)	\
    ( (This)->lpVtbl -> InitializeDevice(This,dwUserID,lpAllocInfo,lpNumBuffers) ) 

#define IVMRSurfaceAllocatorEx9_TerminateDevice(This,dwID)	\
    ( (This)->lpVtbl -> TerminateDevice(This,dwID) ) 

#define IVMRSurfaceAllocatorEx9_GetSurface(This,dwUserID,SurfaceIndex,SurfaceFlags,lplpSurface)	\
    ( (This)->lpVtbl -> GetSurface(This,dwUserID,SurfaceIndex,SurfaceFlags,lplpSurface) ) 

#define IVMRSurfaceAllocatorEx9_AdviseNotify(This,lpIVMRSurfAllocNotify)	\
    ( (This)->lpVtbl -> AdviseNotify(This,lpIVMRSurfAllocNotify) ) 


#define IVMRSurfaceAllocatorEx9_GetSurfaceEx(This,dwUserID,SurfaceIndex,SurfaceFlags,lplpSurface,lprcDst)	\
    ( (This)->lpVtbl -> GetSurfaceEx(This,dwUserID,SurfaceIndex,SurfaceFlags,lplpSurface,lprcDst) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRSurfaceAllocatorEx9_INTERFACE_DEFINED__ */


#ifndef __IVMRSurfaceAllocatorNotify9_INTERFACE_DEFINED__
#define __IVMRSurfaceAllocatorNotify9_INTERFACE_DEFINED__

/* interface IVMRSurfaceAllocatorNotify9 */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurfaceAllocatorNotify9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dca3f5df-bb3a-4d03-bd81-84614bfbfa0c")
    IVMRSurfaceAllocatorNotify9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseSurfaceAllocator( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ IVMRSurfaceAllocator9 *lpIVRMSurfaceAllocator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetD3DDevice( 
            /* [in] */ IDirect3DDevice9 *lpD3DDevice,
            /* [in] */ HMONITOR hMonitor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeD3DDevice( 
            /* [in] */ IDirect3DDevice9 *lpD3DDevice,
            /* [in] */ HMONITOR hMonitor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateSurfaceHelper( 
            /* [in] */ VMR9AllocationInfo *lpAllocInfo,
            /* [out][in] */ DWORD *lpNumBuffers,
            /* [out] */ IDirect3DSurface9 **lplpSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ LONG EventCode,
            /* [in] */ LONG_PTR Param1,
            /* [in] */ LONG_PTR Param2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurfaceAllocatorNotify9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurfaceAllocatorNotify9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurfaceAllocatorNotify9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurfaceAllocatorNotify9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseSurfaceAllocator )( 
            IVMRSurfaceAllocatorNotify9 * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ IVMRSurfaceAllocator9 *lpIVRMSurfaceAllocator);
        
        HRESULT ( STDMETHODCALLTYPE *SetD3DDevice )( 
            IVMRSurfaceAllocatorNotify9 * This,
            /* [in] */ IDirect3DDevice9 *lpD3DDevice,
            /* [in] */ HMONITOR hMonitor);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeD3DDevice )( 
            IVMRSurfaceAllocatorNotify9 * This,
            /* [in] */ IDirect3DDevice9 *lpD3DDevice,
            /* [in] */ HMONITOR hMonitor);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSurfaceHelper )( 
            IVMRSurfaceAllocatorNotify9 * This,
            /* [in] */ VMR9AllocationInfo *lpAllocInfo,
            /* [out][in] */ DWORD *lpNumBuffers,
            /* [out] */ IDirect3DSurface9 **lplpSurface);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyEvent )( 
            IVMRSurfaceAllocatorNotify9 * This,
            /* [in] */ LONG EventCode,
            /* [in] */ LONG_PTR Param1,
            /* [in] */ LONG_PTR Param2);
        
        END_INTERFACE
    } IVMRSurfaceAllocatorNotify9Vtbl;

    interface IVMRSurfaceAllocatorNotify9
    {
        CONST_VTBL struct IVMRSurfaceAllocatorNotify9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurfaceAllocatorNotify9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRSurfaceAllocatorNotify9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRSurfaceAllocatorNotify9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(This,dwUserID,lpIVRMSurfaceAllocator)	\
    ( (This)->lpVtbl -> AdviseSurfaceAllocator(This,dwUserID,lpIVRMSurfaceAllocator) ) 

#define IVMRSurfaceAllocatorNotify9_SetD3DDevice(This,lpD3DDevice,hMonitor)	\
    ( (This)->lpVtbl -> SetD3DDevice(This,lpD3DDevice,hMonitor) ) 

#define IVMRSurfaceAllocatorNotify9_ChangeD3DDevice(This,lpD3DDevice,hMonitor)	\
    ( (This)->lpVtbl -> ChangeD3DDevice(This,lpD3DDevice,hMonitor) ) 

#define IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(This,lpAllocInfo,lpNumBuffers,lplpSurface)	\
    ( (This)->lpVtbl -> AllocateSurfaceHelper(This,lpAllocInfo,lpNumBuffers,lplpSurface) ) 

#define IVMRSurfaceAllocatorNotify9_NotifyEvent(This,EventCode,Param1,Param2)	\
    ( (This)->lpVtbl -> NotifyEvent(This,EventCode,Param1,Param2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRSurfaceAllocatorNotify9_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vmr9_0000_0004 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_vmr9_0000_0004_0001
    {	VMR9ARMode_None	= 0,
	VMR9ARMode_LetterBox	= ( VMR9ARMode_None + 1 ) 
    } 	VMR9AspectRatioMode;



extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0004_v0_0_s_ifspec;

#ifndef __IVMRWindowlessControl9_INTERFACE_DEFINED__
#define __IVMRWindowlessControl9_INTERFACE_DEFINED__

/* interface IVMRWindowlessControl9 */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRWindowlessControl9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8f537d09-f85e-4414-b23b-502e54c79927")
    IVMRWindowlessControl9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNativeVideoSize( 
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight,
            /* [out] */ LONG *lpARWidth,
            /* [out] */ LONG *lpARHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinIdealVideoSize( 
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxIdealVideoSize( 
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVideoPosition( 
            /* [in] */ const LPRECT lpSRCRect,
            /* [in] */ const LPRECT lpDSTRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPosition( 
            /* [out] */ LPRECT lpSRCRect,
            /* [out] */ LPRECT lpDSTRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAspectRatioMode( 
            /* [out] */ DWORD *lpAspectRatioMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAspectRatioMode( 
            /* [in] */ DWORD AspectRatioMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVideoClippingWindow( 
            /* [in] */ HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RepaintVideo( 
            /* [in] */ HWND hwnd,
            /* [in] */ HDC hdc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayModeChanged( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentImage( 
            /* [out] */ BYTE **lpDib) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBorderColor( 
            /* [in] */ COLORREF Clr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBorderColor( 
            /* [out] */ COLORREF *lpClr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRWindowlessControl9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRWindowlessControl9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRWindowlessControl9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRWindowlessControl9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNativeVideoSize )( 
            IVMRWindowlessControl9 * This,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight,
            /* [out] */ LONG *lpARWidth,
            /* [out] */ LONG *lpARHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinIdealVideoSize )( 
            IVMRWindowlessControl9 * This,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxIdealVideoSize )( 
            IVMRWindowlessControl9 * This,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoPosition )( 
            IVMRWindowlessControl9 * This,
            /* [in] */ const LPRECT lpSRCRect,
            /* [in] */ const LPRECT lpDSTRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPosition )( 
            IVMRWindowlessControl9 * This,
            /* [out] */ LPRECT lpSRCRect,
            /* [out] */ LPRECT lpDSTRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetAspectRatioMode )( 
            IVMRWindowlessControl9 * This,
            /* [out] */ DWORD *lpAspectRatioMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetAspectRatioMode )( 
            IVMRWindowlessControl9 * This,
            /* [in] */ DWORD AspectRatioMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoClippingWindow )( 
            IVMRWindowlessControl9 * This,
            /* [in] */ HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *RepaintVideo )( 
            IVMRWindowlessControl9 * This,
            /* [in] */ HWND hwnd,
            /* [in] */ HDC hdc);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayModeChanged )( 
            IVMRWindowlessControl9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IVMRWindowlessControl9 * This,
            /* [out] */ BYTE **lpDib);
        
        HRESULT ( STDMETHODCALLTYPE *SetBorderColor )( 
            IVMRWindowlessControl9 * This,
            /* [in] */ COLORREF Clr);
        
        HRESULT ( STDMETHODCALLTYPE *GetBorderColor )( 
            IVMRWindowlessControl9 * This,
            /* [out] */ COLORREF *lpClr);
        
        END_INTERFACE
    } IVMRWindowlessControl9Vtbl;

    interface IVMRWindowlessControl9
    {
        CONST_VTBL struct IVMRWindowlessControl9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRWindowlessControl9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRWindowlessControl9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRWindowlessControl9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRWindowlessControl9_GetNativeVideoSize(This,lpWidth,lpHeight,lpARWidth,lpARHeight)	\
    ( (This)->lpVtbl -> GetNativeVideoSize(This,lpWidth,lpHeight,lpARWidth,lpARHeight) ) 

#define IVMRWindowlessControl9_GetMinIdealVideoSize(This,lpWidth,lpHeight)	\
    ( (This)->lpVtbl -> GetMinIdealVideoSize(This,lpWidth,lpHeight) ) 

#define IVMRWindowlessControl9_GetMaxIdealVideoSize(This,lpWidth,lpHeight)	\
    ( (This)->lpVtbl -> GetMaxIdealVideoSize(This,lpWidth,lpHeight) ) 

#define IVMRWindowlessControl9_SetVideoPosition(This,lpSRCRect,lpDSTRect)	\
    ( (This)->lpVtbl -> SetVideoPosition(This,lpSRCRect,lpDSTRect) ) 

#define IVMRWindowlessControl9_GetVideoPosition(This,lpSRCRect,lpDSTRect)	\
    ( (This)->lpVtbl -> GetVideoPosition(This,lpSRCRect,lpDSTRect) ) 

#define IVMRWindowlessControl9_GetAspectRatioMode(This,lpAspectRatioMode)	\
    ( (This)->lpVtbl -> GetAspectRatioMode(This,lpAspectRatioMode) ) 

#define IVMRWindowlessControl9_SetAspectRatioMode(This,AspectRatioMode)	\
    ( (This)->lpVtbl -> SetAspectRatioMode(This,AspectRatioMode) ) 

#define IVMRWindowlessControl9_SetVideoClippingWindow(This,hwnd)	\
    ( (This)->lpVtbl -> SetVideoClippingWindow(This,hwnd) ) 

#define IVMRWindowlessControl9_RepaintVideo(This,hwnd,hdc)	\
    ( (This)->lpVtbl -> RepaintVideo(This,hwnd,hdc) ) 

#define IVMRWindowlessControl9_DisplayModeChanged(This)	\
    ( (This)->lpVtbl -> DisplayModeChanged(This) ) 

#define IVMRWindowlessControl9_GetCurrentImage(This,lpDib)	\
    ( (This)->lpVtbl -> GetCurrentImage(This,lpDib) ) 

#define IVMRWindowlessControl9_SetBorderColor(This,Clr)	\
    ( (This)->lpVtbl -> SetBorderColor(This,Clr) ) 

#define IVMRWindowlessControl9_GetBorderColor(This,lpClr)	\
    ( (This)->lpVtbl -> GetBorderColor(This,lpClr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRWindowlessControl9_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vmr9_0000_0005 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_vmr9_0000_0005_0001
    {	MixerPref9_NoDecimation	= 0x1,
	MixerPref9_DecimateOutput	= 0x2,
	MixerPref9_ARAdjustXorY	= 0x4,
	MixerPref9_NonSquareMixing	= 0x8,
	MixerPref9_DecimateMask	= 0xf,
	MixerPref9_BiLinearFiltering	= 0x10,
	MixerPref9_PointFiltering	= 0x20,
	MixerPref9_AnisotropicFiltering	= 0x40,
	MixerPref9_PyramidalQuadFiltering	= 0x80,
	MixerPref9_GaussianQuadFiltering	= 0x100,
	MixerPref9_FilteringReserved	= 0xe00,
	MixerPref9_FilteringMask	= 0xff0,
	MixerPref9_RenderTargetRGB	= 0x1000,
	MixerPref9_RenderTargetYUV	= 0x2000,
	MixerPref9_RenderTargetReserved	= 0xfc000,
	MixerPref9_RenderTargetMask	= 0xff000,
	MixerPref9_DynamicSwitchToBOB	= 0x100000,
	MixerPref9_DynamicDecimateBy2	= 0x200000,
	MixerPref9_DynamicReserved	= 0xc00000,
	MixerPref9_DynamicMask	= 0xf00000
    } 	VMR9MixerPrefs;

typedef struct _VMR9NormalizedRect
    {
    float left;
    float top;
    float right;
    float bottom;
    } 	VMR9NormalizedRect;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_vmr9_0000_0005_0002
    {	ProcAmpControl9_Brightness	= 0x1,
	ProcAmpControl9_Contrast	= 0x2,
	ProcAmpControl9_Hue	= 0x4,
	ProcAmpControl9_Saturation	= 0x8,
	ProcAmpControl9_Mask	= 0xf
    } 	VMR9ProcAmpControlFlags;

typedef struct _VMR9ProcAmpControl
    {
    DWORD dwSize;
    DWORD dwFlags;
    float Brightness;
    float Contrast;
    float Hue;
    float Saturation;
    } 	VMR9ProcAmpControl;

typedef struct _VMR9ProcAmpControlRange
    {
    DWORD dwSize;
    VMR9ProcAmpControlFlags dwProperty;
    float MinValue;
    float MaxValue;
    float DefaultValue;
    float StepSize;
    } 	VMR9ProcAmpControlRange;



extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0005_v0_0_s_ifspec;

#ifndef __IVMRMixerControl9_INTERFACE_DEFINED__
#define __IVMRMixerControl9_INTERFACE_DEFINED__

/* interface IVMRMixerControl9 */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRMixerControl9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1a777eaa-47c8-4930-b2c9-8fee1c1b0f3b")
    IVMRMixerControl9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAlpha( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ float Alpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlpha( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ float *pAlpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZOrder( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ DWORD dwZ) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZOrder( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ DWORD *pZ) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputRect( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ const VMR9NormalizedRect *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputRect( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ VMR9NormalizedRect *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundClr( 
            /* [in] */ COLORREF ClrBkg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundClr( 
            /* [in] */ COLORREF *lpClrBkg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMixingPrefs( 
            /* [in] */ DWORD dwMixerPrefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMixingPrefs( 
            /* [out] */ DWORD *pdwMixerPrefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProcAmpControl( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ VMR9ProcAmpControl *lpClrControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcAmpControl( 
            /* [in] */ DWORD dwStreamID,
            /* [out][in] */ VMR9ProcAmpControl *lpClrControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcAmpControlRange( 
            /* [in] */ DWORD dwStreamID,
            /* [out][in] */ VMR9ProcAmpControlRange *lpClrControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMixerControl9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMixerControl9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMixerControl9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMixerControl9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAlpha )( 
            IVMRMixerControl9 * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ float Alpha);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlpha )( 
            IVMRMixerControl9 * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ float *pAlpha);
        
        HRESULT ( STDMETHODCALLTYPE *SetZOrder )( 
            IVMRMixerControl9 * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ DWORD dwZ);
        
        HRESULT ( STDMETHODCALLTYPE *GetZOrder )( 
            IVMRMixerControl9 * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ DWORD *pZ);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputRect )( 
            IVMRMixerControl9 * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ const VMR9NormalizedRect *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputRect )( 
            IVMRMixerControl9 * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ VMR9NormalizedRect *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackgroundClr )( 
            IVMRMixerControl9 * This,
            /* [in] */ COLORREF ClrBkg);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackgroundClr )( 
            IVMRMixerControl9 * This,
            /* [in] */ COLORREF *lpClrBkg);
        
        HRESULT ( STDMETHODCALLTYPE *SetMixingPrefs )( 
            IVMRMixerControl9 * This,
            /* [in] */ DWORD dwMixerPrefs);
        
        HRESULT ( STDMETHODCALLTYPE *GetMixingPrefs )( 
            IVMRMixerControl9 * This,
            /* [out] */ DWORD *pdwMixerPrefs);
        
        HRESULT ( STDMETHODCALLTYPE *SetProcAmpControl )( 
            IVMRMixerControl9 * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ VMR9ProcAmpControl *lpClrControl);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcAmpControl )( 
            IVMRMixerControl9 * This,
            /* [in] */ DWORD dwStreamID,
            /* [out][in] */ VMR9ProcAmpControl *lpClrControl);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcAmpControlRange )( 
            IVMRMixerControl9 * This,
            /* [in] */ DWORD dwStreamID,
            /* [out][in] */ VMR9ProcAmpControlRange *lpClrControl);
        
        END_INTERFACE
    } IVMRMixerControl9Vtbl;

    interface IVMRMixerControl9
    {
        CONST_VTBL struct IVMRMixerControl9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMixerControl9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRMixerControl9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRMixerControl9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRMixerControl9_SetAlpha(This,dwStreamID,Alpha)	\
    ( (This)->lpVtbl -> SetAlpha(This,dwStreamID,Alpha) ) 

#define IVMRMixerControl9_GetAlpha(This,dwStreamID,pAlpha)	\
    ( (This)->lpVtbl -> GetAlpha(This,dwStreamID,pAlpha) ) 

#define IVMRMixerControl9_SetZOrder(This,dwStreamID,dwZ)	\
    ( (This)->lpVtbl -> SetZOrder(This,dwStreamID,dwZ) ) 

#define IVMRMixerControl9_GetZOrder(This,dwStreamID,pZ)	\
    ( (This)->lpVtbl -> GetZOrder(This,dwStreamID,pZ) ) 

#define IVMRMixerControl9_SetOutputRect(This,dwStreamID,pRect)	\
    ( (This)->lpVtbl -> SetOutputRect(This,dwStreamID,pRect) ) 

#define IVMRMixerControl9_GetOutputRect(This,dwStreamID,pRect)	\
    ( (This)->lpVtbl -> GetOutputRect(This,dwStreamID,pRect) ) 

#define IVMRMixerControl9_SetBackgroundClr(This,ClrBkg)	\
    ( (This)->lpVtbl -> SetBackgroundClr(This,ClrBkg) ) 

#define IVMRMixerControl9_GetBackgroundClr(This,lpClrBkg)	\
    ( (This)->lpVtbl -> GetBackgroundClr(This,lpClrBkg) ) 

#define IVMRMixerControl9_SetMixingPrefs(This,dwMixerPrefs)	\
    ( (This)->lpVtbl -> SetMixingPrefs(This,dwMixerPrefs) ) 

#define IVMRMixerControl9_GetMixingPrefs(This,pdwMixerPrefs)	\
    ( (This)->lpVtbl -> GetMixingPrefs(This,pdwMixerPrefs) ) 

#define IVMRMixerControl9_SetProcAmpControl(This,dwStreamID,lpClrControl)	\
    ( (This)->lpVtbl -> SetProcAmpControl(This,dwStreamID,lpClrControl) ) 

#define IVMRMixerControl9_GetProcAmpControl(This,dwStreamID,lpClrControl)	\
    ( (This)->lpVtbl -> GetProcAmpControl(This,dwStreamID,lpClrControl) ) 

#define IVMRMixerControl9_GetProcAmpControlRange(This,dwStreamID,lpClrControl)	\
    ( (This)->lpVtbl -> GetProcAmpControlRange(This,dwStreamID,lpClrControl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRMixerControl9_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vmr9_0000_0006 */
/* [local] */ 

typedef struct _VMR9AlphaBitmap
    {
    DWORD dwFlags;
    HDC hdc;
    IDirect3DSurface9 *pDDS;
    RECT rSrc;
    VMR9NormalizedRect rDest;
    FLOAT fAlpha;
    COLORREF clrSrcKey;
    DWORD dwFilterMode;
    } 	VMR9AlphaBitmap;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_vmr9_0000_0006_0001
    {	VMR9AlphaBitmap_Disable	= 0x1,
	VMR9AlphaBitmap_hDC	= 0x2,
	VMR9AlphaBitmap_EntireDDS	= 0x4,
	VMR9AlphaBitmap_SrcColorKey	= 0x8,
	VMR9AlphaBitmap_SrcRect	= 0x10,
	VMR9AlphaBitmap_FilterMode	= 0x20
    } 	VMR9AlphaBitmapFlags;



extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0006_v0_0_s_ifspec;

#ifndef __IVMRMixerBitmap9_INTERFACE_DEFINED__
#define __IVMRMixerBitmap9_INTERFACE_DEFINED__

/* interface IVMRMixerBitmap9 */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRMixerBitmap9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ced175e5-1935-4820-81bd-ff6ad00c9108")
    IVMRMixerBitmap9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAlphaBitmap( 
            /* [in] */ const VMR9AlphaBitmap *pBmpParms) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateAlphaBitmapParameters( 
            /* [in] */ const VMR9AlphaBitmap *pBmpParms) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlphaBitmapParameters( 
            /* [out] */ VMR9AlphaBitmap *pBmpParms) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMixerBitmap9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMixerBitmap9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMixerBitmap9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMixerBitmap9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAlphaBitmap )( 
            IVMRMixerBitmap9 * This,
            /* [in] */ const VMR9AlphaBitmap *pBmpParms);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateAlphaBitmapParameters )( 
            IVMRMixerBitmap9 * This,
            /* [in] */ const VMR9AlphaBitmap *pBmpParms);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlphaBitmapParameters )( 
            IVMRMixerBitmap9 * This,
            /* [out] */ VMR9AlphaBitmap *pBmpParms);
        
        END_INTERFACE
    } IVMRMixerBitmap9Vtbl;

    interface IVMRMixerBitmap9
    {
        CONST_VTBL struct IVMRMixerBitmap9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMixerBitmap9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRMixerBitmap9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRMixerBitmap9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRMixerBitmap9_SetAlphaBitmap(This,pBmpParms)	\
    ( (This)->lpVtbl -> SetAlphaBitmap(This,pBmpParms) ) 

#define IVMRMixerBitmap9_UpdateAlphaBitmapParameters(This,pBmpParms)	\
    ( (This)->lpVtbl -> UpdateAlphaBitmapParameters(This,pBmpParms) ) 

#define IVMRMixerBitmap9_GetAlphaBitmapParameters(This,pBmpParms)	\
    ( (This)->lpVtbl -> GetAlphaBitmapParameters(This,pBmpParms) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRMixerBitmap9_INTERFACE_DEFINED__ */


#ifndef __IVMRSurface9_INTERFACE_DEFINED__
#define __IVMRSurface9_INTERFACE_DEFINED__

/* interface IVMRSurface9 */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurface9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dfc581a1-6e1f-4c3a-8d0a-5e9792ea2afc")
    IVMRSurface9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsSurfaceLocked( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockSurface( 
            /* [out] */ BYTE **lpSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockSurface( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [out] */ IDirect3DSurface9 **lplpSurface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurface9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurface9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurface9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurface9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSurfaceLocked )( 
            IVMRSurface9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockSurface )( 
            IVMRSurface9 * This,
            /* [out] */ BYTE **lpSurface);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockSurface )( 
            IVMRSurface9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IVMRSurface9 * This,
            /* [out] */ IDirect3DSurface9 **lplpSurface);
        
        END_INTERFACE
    } IVMRSurface9Vtbl;

    interface IVMRSurface9
    {
        CONST_VTBL struct IVMRSurface9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurface9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRSurface9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRSurface9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRSurface9_IsSurfaceLocked(This)	\
    ( (This)->lpVtbl -> IsSurfaceLocked(This) ) 

#define IVMRSurface9_LockSurface(This,lpSurface)	\
    ( (This)->lpVtbl -> LockSurface(This,lpSurface) ) 

#define IVMRSurface9_UnlockSurface(This)	\
    ( (This)->lpVtbl -> UnlockSurface(This) ) 

#define IVMRSurface9_GetSurface(This,lplpSurface)	\
    ( (This)->lpVtbl -> GetSurface(This,lplpSurface) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRSurface9_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vmr9_0000_0008 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_vmr9_0000_0008_0001
    {	RenderPrefs9_DoNotRenderBorder	= 0x1,
	RenderPrefs9_Mask	= 0x1
    } 	VMR9RenderPrefs;



extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0008_v0_0_s_ifspec;

#ifndef __IVMRImagePresenterConfig9_INTERFACE_DEFINED__
#define __IVMRImagePresenterConfig9_INTERFACE_DEFINED__

/* interface IVMRImagePresenterConfig9 */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImagePresenterConfig9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45c15cab-6e22-420a-8043-ae1f0ac02c7d")
    IVMRImagePresenterConfig9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRenderingPrefs( 
            /* [in] */ DWORD dwRenderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderingPrefs( 
            /* [out] */ DWORD *dwRenderFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImagePresenterConfig9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImagePresenterConfig9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImagePresenterConfig9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImagePresenterConfig9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingPrefs )( 
            IVMRImagePresenterConfig9 * This,
            /* [in] */ DWORD dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingPrefs )( 
            IVMRImagePresenterConfig9 * This,
            /* [out] */ DWORD *dwRenderFlags);
        
        END_INTERFACE
    } IVMRImagePresenterConfig9Vtbl;

    interface IVMRImagePresenterConfig9
    {
        CONST_VTBL struct IVMRImagePresenterConfig9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImagePresenterConfig9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRImagePresenterConfig9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRImagePresenterConfig9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRImagePresenterConfig9_SetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> SetRenderingPrefs(This,dwRenderFlags) ) 

#define IVMRImagePresenterConfig9_GetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> GetRenderingPrefs(This,dwRenderFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRImagePresenterConfig9_INTERFACE_DEFINED__ */


#ifndef __IVMRVideoStreamControl9_INTERFACE_DEFINED__
#define __IVMRVideoStreamControl9_INTERFACE_DEFINED__

/* interface IVMRVideoStreamControl9 */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRVideoStreamControl9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0cfe38b-93e7-4772-8957-0400c49a4485")
    IVMRVideoStreamControl9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStreamActiveState( 
            /* [in] */ BOOL fActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamActiveState( 
            /* [out] */ BOOL *lpfActive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRVideoStreamControl9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRVideoStreamControl9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRVideoStreamControl9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRVideoStreamControl9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamActiveState )( 
            IVMRVideoStreamControl9 * This,
            /* [in] */ BOOL fActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamActiveState )( 
            IVMRVideoStreamControl9 * This,
            /* [out] */ BOOL *lpfActive);
        
        END_INTERFACE
    } IVMRVideoStreamControl9Vtbl;

    interface IVMRVideoStreamControl9
    {
        CONST_VTBL struct IVMRVideoStreamControl9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRVideoStreamControl9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRVideoStreamControl9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRVideoStreamControl9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRVideoStreamControl9_SetStreamActiveState(This,fActive)	\
    ( (This)->lpVtbl -> SetStreamActiveState(This,fActive) ) 

#define IVMRVideoStreamControl9_GetStreamActiveState(This,lpfActive)	\
    ( (This)->lpVtbl -> GetStreamActiveState(This,lpfActive) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRVideoStreamControl9_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vmr9_0000_0010 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_vmr9_0000_0010_0001
    {	VMR9Mode_Windowed	= 0x1,
	VMR9Mode_Windowless	= 0x2,
	VMR9Mode_Renderless	= 0x4,
	VMR9Mode_Mask	= 0x7
    } 	VMR9Mode;



extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0010_v0_0_s_ifspec;

#ifndef __IVMRFilterConfig9_INTERFACE_DEFINED__
#define __IVMRFilterConfig9_INTERFACE_DEFINED__

/* interface IVMRFilterConfig9 */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRFilterConfig9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5a804648-4f66-4867-9c43-4f5c822cf1b8")
    IVMRFilterConfig9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetImageCompositor( 
            /* [in] */ IVMRImageCompositor9 *lpVMRImgCompositor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNumberOfStreams( 
            /* [in] */ DWORD dwMaxStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfStreams( 
            /* [out] */ DWORD *pdwMaxStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderingPrefs( 
            /* [in] */ DWORD dwRenderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderingPrefs( 
            /* [out] */ DWORD *pdwRenderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderingMode( 
            /* [in] */ DWORD Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderingMode( 
            /* [out] */ DWORD *pMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRFilterConfig9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRFilterConfig9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRFilterConfig9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRFilterConfig9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetImageCompositor )( 
            IVMRFilterConfig9 * This,
            /* [in] */ IVMRImageCompositor9 *lpVMRImgCompositor);
        
        HRESULT ( STDMETHODCALLTYPE *SetNumberOfStreams )( 
            IVMRFilterConfig9 * This,
            /* [in] */ DWORD dwMaxStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfStreams )( 
            IVMRFilterConfig9 * This,
            /* [out] */ DWORD *pdwMaxStreams);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingPrefs )( 
            IVMRFilterConfig9 * This,
            /* [in] */ DWORD dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingPrefs )( 
            IVMRFilterConfig9 * This,
            /* [out] */ DWORD *pdwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingMode )( 
            IVMRFilterConfig9 * This,
            /* [in] */ DWORD Mode);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingMode )( 
            IVMRFilterConfig9 * This,
            /* [out] */ DWORD *pMode);
        
        END_INTERFACE
    } IVMRFilterConfig9Vtbl;

    interface IVMRFilterConfig9
    {
        CONST_VTBL struct IVMRFilterConfig9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRFilterConfig9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRFilterConfig9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRFilterConfig9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRFilterConfig9_SetImageCompositor(This,lpVMRImgCompositor)	\
    ( (This)->lpVtbl -> SetImageCompositor(This,lpVMRImgCompositor) ) 

#define IVMRFilterConfig9_SetNumberOfStreams(This,dwMaxStreams)	\
    ( (This)->lpVtbl -> SetNumberOfStreams(This,dwMaxStreams) ) 

#define IVMRFilterConfig9_GetNumberOfStreams(This,pdwMaxStreams)	\
    ( (This)->lpVtbl -> GetNumberOfStreams(This,pdwMaxStreams) ) 

#define IVMRFilterConfig9_SetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> SetRenderingPrefs(This,dwRenderFlags) ) 

#define IVMRFilterConfig9_GetRenderingPrefs(This,pdwRenderFlags)	\
    ( (This)->lpVtbl -> GetRenderingPrefs(This,pdwRenderFlags) ) 

#define IVMRFilterConfig9_SetRenderingMode(This,Mode)	\
    ( (This)->lpVtbl -> SetRenderingMode(This,Mode) ) 

#define IVMRFilterConfig9_GetRenderingMode(This,pMode)	\
    ( (This)->lpVtbl -> GetRenderingMode(This,pMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRFilterConfig9_INTERFACE_DEFINED__ */


#ifndef __IVMRAspectRatioControl9_INTERFACE_DEFINED__
#define __IVMRAspectRatioControl9_INTERFACE_DEFINED__

/* interface IVMRAspectRatioControl9 */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRAspectRatioControl9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00d96c29-bbde-4efc-9901-bb5036392146")
    IVMRAspectRatioControl9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAspectRatioMode( 
            /* [out] */ LPDWORD lpdwARMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAspectRatioMode( 
            /* [in] */ DWORD dwARMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRAspectRatioControl9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRAspectRatioControl9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRAspectRatioControl9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRAspectRatioControl9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAspectRatioMode )( 
            IVMRAspectRatioControl9 * This,
            /* [out] */ LPDWORD lpdwARMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetAspectRatioMode )( 
            IVMRAspectRatioControl9 * This,
            /* [in] */ DWORD dwARMode);
        
        END_INTERFACE
    } IVMRAspectRatioControl9Vtbl;

    interface IVMRAspectRatioControl9
    {
        CONST_VTBL struct IVMRAspectRatioControl9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRAspectRatioControl9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRAspectRatioControl9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRAspectRatioControl9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRAspectRatioControl9_GetAspectRatioMode(This,lpdwARMode)	\
    ( (This)->lpVtbl -> GetAspectRatioMode(This,lpdwARMode) ) 

#define IVMRAspectRatioControl9_SetAspectRatioMode(This,dwARMode)	\
    ( (This)->lpVtbl -> SetAspectRatioMode(This,dwARMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRAspectRatioControl9_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vmr9_0000_0012 */
/* [local] */ 

typedef struct _VMR9MonitorInfo
    {
    UINT uDevID;
    RECT rcMonitor;
    HMONITOR hMon;
    DWORD dwFlags;
    wchar_t szDevice[ 32 ];
    wchar_t szDescription[ 512 ];
    LARGE_INTEGER liDriverVersion;
    DWORD dwVendorId;
    DWORD dwDeviceId;
    DWORD dwSubSysId;
    DWORD dwRevision;
    } 	VMR9MonitorInfo;



extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0012_v0_0_s_ifspec;

#ifndef __IVMRMonitorConfig9_INTERFACE_DEFINED__
#define __IVMRMonitorConfig9_INTERFACE_DEFINED__

/* interface IVMRMonitorConfig9 */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRMonitorConfig9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("46c2e457-8ba0-4eef-b80b-0680f0978749")
    IVMRMonitorConfig9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMonitor( 
            /* [in] */ UINT uDev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMonitor( 
            /* [out] */ UINT *puDev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultMonitor( 
            /* [in] */ UINT uDev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultMonitor( 
            /* [out] */ UINT *puDev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAvailableMonitors( 
            /* [size_is][out] */ VMR9MonitorInfo *pInfo,
            /* [in] */ DWORD dwMaxInfoArraySize,
            /* [out] */ DWORD *pdwNumDevices) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMonitorConfig9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMonitorConfig9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMonitorConfig9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMonitorConfig9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMonitor )( 
            IVMRMonitorConfig9 * This,
            /* [in] */ UINT uDev);
        
        HRESULT ( STDMETHODCALLTYPE *GetMonitor )( 
            IVMRMonitorConfig9 * This,
            /* [out] */ UINT *puDev);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultMonitor )( 
            IVMRMonitorConfig9 * This,
            /* [in] */ UINT uDev);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultMonitor )( 
            IVMRMonitorConfig9 * This,
            /* [out] */ UINT *puDev);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableMonitors )( 
            IVMRMonitorConfig9 * This,
            /* [size_is][out] */ VMR9MonitorInfo *pInfo,
            /* [in] */ DWORD dwMaxInfoArraySize,
            /* [out] */ DWORD *pdwNumDevices);
        
        END_INTERFACE
    } IVMRMonitorConfig9Vtbl;

    interface IVMRMonitorConfig9
    {
        CONST_VTBL struct IVMRMonitorConfig9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMonitorConfig9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRMonitorConfig9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRMonitorConfig9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRMonitorConfig9_SetMonitor(This,uDev)	\
    ( (This)->lpVtbl -> SetMonitor(This,uDev) ) 

#define IVMRMonitorConfig9_GetMonitor(This,puDev)	\
    ( (This)->lpVtbl -> GetMonitor(This,puDev) ) 

#define IVMRMonitorConfig9_SetDefaultMonitor(This,uDev)	\
    ( (This)->lpVtbl -> SetDefaultMonitor(This,uDev) ) 

#define IVMRMonitorConfig9_GetDefaultMonitor(This,puDev)	\
    ( (This)->lpVtbl -> GetDefaultMonitor(This,puDev) ) 

#define IVMRMonitorConfig9_GetAvailableMonitors(This,pInfo,dwMaxInfoArraySize,pdwNumDevices)	\
    ( (This)->lpVtbl -> GetAvailableMonitors(This,pInfo,dwMaxInfoArraySize,pdwNumDevices) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRMonitorConfig9_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vmr9_0000_0013 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_vmr9_0000_0013_0001
    {	DeinterlacePref9_NextBest	= 0x1,
	DeinterlacePref9_BOB	= 0x2,
	DeinterlacePref9_Weave	= 0x4,
	DeinterlacePref9_Mask	= 0x7
    } 	VMR9DeinterlacePrefs;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_vmr9_0000_0013_0002
    {	DeinterlaceTech9_Unknown	= 0,
	DeinterlaceTech9_BOBLineReplicate	= 0x1,
	DeinterlaceTech9_BOBVerticalStretch	= 0x2,
	DeinterlaceTech9_MedianFiltering	= 0x4,
	DeinterlaceTech9_EdgeFiltering	= 0x10,
	DeinterlaceTech9_FieldAdaptive	= 0x20,
	DeinterlaceTech9_PixelAdaptive	= 0x40,
	DeinterlaceTech9_MotionVectorSteered	= 0x80
    } 	VMR9DeinterlaceTech;

typedef struct _VMR9Frequency
    {
    DWORD dwNumerator;
    DWORD dwDenominator;
    } 	VMR9Frequency;

typedef 
enum _VMR9_SampleFormat
    {	VMR9_SampleReserved	= 1,
	VMR9_SampleProgressiveFrame	= 2,
	VMR9_SampleFieldInterleavedEvenFirst	= 3,
	VMR9_SampleFieldInterleavedOddFirst	= 4,
	VMR9_SampleFieldSingleEven	= 5,
	VMR9_SampleFieldSingleOdd	= 6
    } 	VMR9_SampleFormat;

typedef struct _VMR9VideoDesc
    {
    DWORD dwSize;
    DWORD dwSampleWidth;
    DWORD dwSampleHeight;
    VMR9_SampleFormat SampleFormat;
    DWORD dwFourCC;
    VMR9Frequency InputSampleFreq;
    VMR9Frequency OutputFrameFreq;
    } 	VMR9VideoDesc;

typedef struct _VMR9DeinterlaceCaps
    {
    DWORD dwSize;
    DWORD dwNumPreviousOutputFrames;
    DWORD dwNumForwardRefSamples;
    DWORD dwNumBackwardRefSamples;
    VMR9DeinterlaceTech DeinterlaceTechnology;
    } 	VMR9DeinterlaceCaps;



extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0013_v0_0_s_ifspec;

#ifndef __IVMRDeinterlaceControl9_INTERFACE_DEFINED__
#define __IVMRDeinterlaceControl9_INTERFACE_DEFINED__

/* interface IVMRDeinterlaceControl9 */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRDeinterlaceControl9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a215fb8d-13c2-4f7f-993c-003d6271a459")
    IVMRDeinterlaceControl9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfDeinterlaceModes( 
            /* [in] */ VMR9VideoDesc *lpVideoDescription,
            /* [out][in] */ LPDWORD lpdwNumDeinterlaceModes,
            /* [out] */ LPGUID lpDeinterlaceModes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeinterlaceModeCaps( 
            /* [in] */ LPGUID lpDeinterlaceMode,
            /* [in] */ VMR9VideoDesc *lpVideoDescription,
            /* [out] */ VMR9DeinterlaceCaps *lpDeinterlaceCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeinterlaceMode( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LPGUID lpDeinterlaceMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeinterlaceMode( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ LPGUID lpDeinterlaceMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeinterlacePrefs( 
            /* [out] */ LPDWORD lpdwDeinterlacePrefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeinterlacePrefs( 
            /* [in] */ DWORD dwDeinterlacePrefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActualDeinterlaceMode( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LPGUID lpDeinterlaceMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRDeinterlaceControl9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRDeinterlaceControl9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRDeinterlaceControl9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRDeinterlaceControl9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfDeinterlaceModes )( 
            IVMRDeinterlaceControl9 * This,
            /* [in] */ VMR9VideoDesc *lpVideoDescription,
            /* [out][in] */ LPDWORD lpdwNumDeinterlaceModes,
            /* [out] */ LPGUID lpDeinterlaceModes);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeinterlaceModeCaps )( 
            IVMRDeinterlaceControl9 * This,
            /* [in] */ LPGUID lpDeinterlaceMode,
            /* [in] */ VMR9VideoDesc *lpVideoDescription,
            /* [out] */ VMR9DeinterlaceCaps *lpDeinterlaceCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeinterlaceMode )( 
            IVMRDeinterlaceControl9 * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LPGUID lpDeinterlaceMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeinterlaceMode )( 
            IVMRDeinterlaceControl9 * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ LPGUID lpDeinterlaceMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeinterlacePrefs )( 
            IVMRDeinterlaceControl9 * This,
            /* [out] */ LPDWORD lpdwDeinterlacePrefs);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeinterlacePrefs )( 
            IVMRDeinterlaceControl9 * This,
            /* [in] */ DWORD dwDeinterlacePrefs);
        
        HRESULT ( STDMETHODCALLTYPE *GetActualDeinterlaceMode )( 
            IVMRDeinterlaceControl9 * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LPGUID lpDeinterlaceMode);
        
        END_INTERFACE
    } IVMRDeinterlaceControl9Vtbl;

    interface IVMRDeinterlaceControl9
    {
        CONST_VTBL struct IVMRDeinterlaceControl9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRDeinterlaceControl9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRDeinterlaceControl9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRDeinterlaceControl9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRDeinterlaceControl9_GetNumberOfDeinterlaceModes(This,lpVideoDescription,lpdwNumDeinterlaceModes,lpDeinterlaceModes)	\
    ( (This)->lpVtbl -> GetNumberOfDeinterlaceModes(This,lpVideoDescription,lpdwNumDeinterlaceModes,lpDeinterlaceModes) ) 

#define IVMRDeinterlaceControl9_GetDeinterlaceModeCaps(This,lpDeinterlaceMode,lpVideoDescription,lpDeinterlaceCaps)	\
    ( (This)->lpVtbl -> GetDeinterlaceModeCaps(This,lpDeinterlaceMode,lpVideoDescription,lpDeinterlaceCaps) ) 

#define IVMRDeinterlaceControl9_GetDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode)	\
    ( (This)->lpVtbl -> GetDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode) ) 

#define IVMRDeinterlaceControl9_SetDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode)	\
    ( (This)->lpVtbl -> SetDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode) ) 

#define IVMRDeinterlaceControl9_GetDeinterlacePrefs(This,lpdwDeinterlacePrefs)	\
    ( (This)->lpVtbl -> GetDeinterlacePrefs(This,lpdwDeinterlacePrefs) ) 

#define IVMRDeinterlaceControl9_SetDeinterlacePrefs(This,dwDeinterlacePrefs)	\
    ( (This)->lpVtbl -> SetDeinterlacePrefs(This,dwDeinterlacePrefs) ) 

#define IVMRDeinterlaceControl9_GetActualDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode)	\
    ( (This)->lpVtbl -> GetActualDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRDeinterlaceControl9_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vmr9_0000_0014 */
/* [local] */ 

typedef struct _VMR9VideoStreamInfo
    {
    IDirect3DSurface9 *pddsVideoSurface;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwStrmID;
    FLOAT fAlpha;
    VMR9NormalizedRect rNormal;
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtEnd;
    VMR9_SampleFormat SampleFormat;
    } 	VMR9VideoStreamInfo;



extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vmr9_0000_0014_v0_0_s_ifspec;

#ifndef __IVMRImageCompositor9_INTERFACE_DEFINED__
#define __IVMRImageCompositor9_INTERFACE_DEFINED__

/* interface IVMRImageCompositor9 */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImageCompositor9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a5c89eb-df51-4654-ac2a-e48e02bbabf6")
    IVMRImageCompositor9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitCompositionDevice( 
            /* [in] */ IUnknown *pD3DDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TermCompositionDevice( 
            /* [in] */ IUnknown *pD3DDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamMediaType( 
            /* [in] */ DWORD dwStrmID,
            /* [in] */ AM_MEDIA_TYPE *pmt,
            /* [in] */ BOOL fTexture) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompositeImage( 
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ IDirect3DSurface9 *pddsRenderTarget,
            /* [in] */ AM_MEDIA_TYPE *pmtRenderTarget,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtEnd,
            /* [in] */ D3DCOLOR dwClrBkGnd,
            /* [in] */ VMR9VideoStreamInfo *pVideoStreamInfo,
            /* [in] */ UINT cStreams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImageCompositor9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImageCompositor9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImageCompositor9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImageCompositor9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitCompositionDevice )( 
            IVMRImageCompositor9 * This,
            /* [in] */ IUnknown *pD3DDevice);
        
        HRESULT ( STDMETHODCALLTYPE *TermCompositionDevice )( 
            IVMRImageCompositor9 * This,
            /* [in] */ IUnknown *pD3DDevice);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamMediaType )( 
            IVMRImageCompositor9 * This,
            /* [in] */ DWORD dwStrmID,
            /* [in] */ AM_MEDIA_TYPE *pmt,
            /* [in] */ BOOL fTexture);
        
        HRESULT ( STDMETHODCALLTYPE *CompositeImage )( 
            IVMRImageCompositor9 * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ IDirect3DSurface9 *pddsRenderTarget,
            /* [in] */ AM_MEDIA_TYPE *pmtRenderTarget,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtEnd,
            /* [in] */ D3DCOLOR dwClrBkGnd,
            /* [in] */ VMR9VideoStreamInfo *pVideoStreamInfo,
            /* [in] */ UINT cStreams);
        
        END_INTERFACE
    } IVMRImageCompositor9Vtbl;

    interface IVMRImageCompositor9
    {
        CONST_VTBL struct IVMRImageCompositor9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImageCompositor9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRImageCompositor9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRImageCompositor9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRImageCompositor9_InitCompositionDevice(This,pD3DDevice)	\
    ( (This)->lpVtbl -> InitCompositionDevice(This,pD3DDevice) ) 

#define IVMRImageCompositor9_TermCompositionDevice(This,pD3DDevice)	\
    ( (This)->lpVtbl -> TermCompositionDevice(This,pD3DDevice) ) 

#define IVMRImageCompositor9_SetStreamMediaType(This,dwStrmID,pmt,fTexture)	\
    ( (This)->lpVtbl -> SetStreamMediaType(This,dwStrmID,pmt,fTexture) ) 

#define IVMRImageCompositor9_CompositeImage(This,pD3DDevice,pddsRenderTarget,pmtRenderTarget,rtStart,rtEnd,dwClrBkGnd,pVideoStreamInfo,cStreams)	\
    ( (This)->lpVtbl -> CompositeImage(This,pD3DDevice,pddsRenderTarget,pmtRenderTarget,rtStart,rtEnd,dwClrBkGnd,pVideoStreamInfo,cStreams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRImageCompositor9_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vpccominterfaces.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vpccominterfaces.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __vpccominterfaces_h__
#define __vpccominterfaces_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVMAccountant_FWD_DEFINED__
#define __IVMAccountant_FWD_DEFINED__
typedef interface IVMAccountant IVMAccountant;
#endif 	/* __IVMAccountant_FWD_DEFINED__ */


#ifndef __IVMHardDiskConnection_FWD_DEFINED__
#define __IVMHardDiskConnection_FWD_DEFINED__
typedef interface IVMHardDiskConnection IVMHardDiskConnection;
#endif 	/* __IVMHardDiskConnection_FWD_DEFINED__ */


#ifndef __IVMHardDiskConnectionCollection_FWD_DEFINED__
#define __IVMHardDiskConnectionCollection_FWD_DEFINED__
typedef interface IVMHardDiskConnectionCollection IVMHardDiskConnectionCollection;
#endif 	/* __IVMHardDiskConnectionCollection_FWD_DEFINED__ */


#ifndef __IVMFloppyDrive_FWD_DEFINED__
#define __IVMFloppyDrive_FWD_DEFINED__
typedef interface IVMFloppyDrive IVMFloppyDrive;
#endif 	/* __IVMFloppyDrive_FWD_DEFINED__ */


#ifndef __IVMFloppyDriveCollection_FWD_DEFINED__
#define __IVMFloppyDriveCollection_FWD_DEFINED__
typedef interface IVMFloppyDriveCollection IVMFloppyDriveCollection;
#endif 	/* __IVMFloppyDriveCollection_FWD_DEFINED__ */


#ifndef __IVMDVDDrive_FWD_DEFINED__
#define __IVMDVDDrive_FWD_DEFINED__
typedef interface IVMDVDDrive IVMDVDDrive;
#endif 	/* __IVMDVDDrive_FWD_DEFINED__ */


#ifndef __IVMDVDDriveCollection_FWD_DEFINED__
#define __IVMDVDDriveCollection_FWD_DEFINED__
typedef interface IVMDVDDriveCollection IVMDVDDriveCollection;
#endif 	/* __IVMDVDDriveCollection_FWD_DEFINED__ */


#ifndef __IVMGuestOS_FWD_DEFINED__
#define __IVMGuestOS_FWD_DEFINED__
typedef interface IVMGuestOS IVMGuestOS;
#endif 	/* __IVMGuestOS_FWD_DEFINED__ */


#ifndef __IVMNetworkAdapter_FWD_DEFINED__
#define __IVMNetworkAdapter_FWD_DEFINED__
typedef interface IVMNetworkAdapter IVMNetworkAdapter;
#endif 	/* __IVMNetworkAdapter_FWD_DEFINED__ */


#ifndef __IVMNetworkAdapterCollection_FWD_DEFINED__
#define __IVMNetworkAdapterCollection_FWD_DEFINED__
typedef interface IVMNetworkAdapterCollection IVMNetworkAdapterCollection;
#endif 	/* __IVMNetworkAdapterCollection_FWD_DEFINED__ */


#ifndef __IVMDisplay_FWD_DEFINED__
#define __IVMDisplay_FWD_DEFINED__
typedef interface IVMDisplay IVMDisplay;
#endif 	/* __IVMDisplay_FWD_DEFINED__ */


#ifndef __IVMMouse_FWD_DEFINED__
#define __IVMMouse_FWD_DEFINED__
typedef interface IVMMouse IVMMouse;
#endif 	/* __IVMMouse_FWD_DEFINED__ */


#ifndef __IVMKeyboard_FWD_DEFINED__
#define __IVMKeyboard_FWD_DEFINED__
typedef interface IVMKeyboard IVMKeyboard;
#endif 	/* __IVMKeyboard_FWD_DEFINED__ */


#ifndef __IVMParallelPort_FWD_DEFINED__
#define __IVMParallelPort_FWD_DEFINED__
typedef interface IVMParallelPort IVMParallelPort;
#endif 	/* __IVMParallelPort_FWD_DEFINED__ */


#ifndef __IVMParallelPortCollection_FWD_DEFINED__
#define __IVMParallelPortCollection_FWD_DEFINED__
typedef interface IVMParallelPortCollection IVMParallelPortCollection;
#endif 	/* __IVMParallelPortCollection_FWD_DEFINED__ */


#ifndef __IVMSerialPort_FWD_DEFINED__
#define __IVMSerialPort_FWD_DEFINED__
typedef interface IVMSerialPort IVMSerialPort;
#endif 	/* __IVMSerialPort_FWD_DEFINED__ */


#ifndef __IVMSerialPortCollection_FWD_DEFINED__
#define __IVMSerialPortCollection_FWD_DEFINED__
typedef interface IVMSerialPortCollection IVMSerialPortCollection;
#endif 	/* __IVMSerialPortCollection_FWD_DEFINED__ */


#ifndef __IVMTask_FWD_DEFINED__
#define __IVMTask_FWD_DEFINED__
typedef interface IVMTask IVMTask;
#endif 	/* __IVMTask_FWD_DEFINED__ */


#ifndef __IVMUSBDevice_FWD_DEFINED__
#define __IVMUSBDevice_FWD_DEFINED__
typedef interface IVMUSBDevice IVMUSBDevice;
#endif 	/* __IVMUSBDevice_FWD_DEFINED__ */


#ifndef __IVMUSBDeviceCollection_FWD_DEFINED__
#define __IVMUSBDeviceCollection_FWD_DEFINED__
typedef interface IVMUSBDeviceCollection IVMUSBDeviceCollection;
#endif 	/* __IVMUSBDeviceCollection_FWD_DEFINED__ */


#ifndef __IVMVirtualMachine_FWD_DEFINED__
#define __IVMVirtualMachine_FWD_DEFINED__
typedef interface IVMVirtualMachine IVMVirtualMachine;
#endif 	/* __IVMVirtualMachine_FWD_DEFINED__ */


#ifndef __IVMVirtualMachineEvents_FWD_DEFINED__
#define __IVMVirtualMachineEvents_FWD_DEFINED__
typedef interface IVMVirtualMachineEvents IVMVirtualMachineEvents;
#endif 	/* __IVMVirtualMachineEvents_FWD_DEFINED__ */


#ifndef __IVMVirtualMachineCollection_FWD_DEFINED__
#define __IVMVirtualMachineCollection_FWD_DEFINED__
typedef interface IVMVirtualMachineCollection IVMVirtualMachineCollection;
#endif 	/* __IVMVirtualMachineCollection_FWD_DEFINED__ */


#ifndef __VMVirtualMachine_FWD_DEFINED__
#define __VMVirtualMachine_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMVirtualMachine VMVirtualMachine;
#else
typedef struct VMVirtualMachine VMVirtualMachine;
#endif /* __cplusplus */

#endif 	/* __VMVirtualMachine_FWD_DEFINED__ */


#ifndef __IVMSupportDriver_FWD_DEFINED__
#define __IVMSupportDriver_FWD_DEFINED__
typedef interface IVMSupportDriver IVMSupportDriver;
#endif 	/* __IVMSupportDriver_FWD_DEFINED__ */


#ifndef __IVMSupportDriverCollection_FWD_DEFINED__
#define __IVMSupportDriverCollection_FWD_DEFINED__
typedef interface IVMSupportDriverCollection IVMSupportDriverCollection;
#endif 	/* __IVMSupportDriverCollection_FWD_DEFINED__ */


#ifndef __VMSupportDriver_FWD_DEFINED__
#define __VMSupportDriver_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMSupportDriver VMSupportDriver;
#else
typedef struct VMSupportDriver VMSupportDriver;
#endif /* __cplusplus */

#endif 	/* __VMSupportDriver_FWD_DEFINED__ */


#ifndef __IVMHostInfo_FWD_DEFINED__
#define __IVMHostInfo_FWD_DEFINED__
typedef interface IVMHostInfo IVMHostInfo;
#endif 	/* __IVMHostInfo_FWD_DEFINED__ */


#ifndef __IVMVirtualNetworkCollection_FWD_DEFINED__
#define __IVMVirtualNetworkCollection_FWD_DEFINED__
typedef interface IVMVirtualNetworkCollection IVMVirtualNetworkCollection;
#endif 	/* __IVMVirtualNetworkCollection_FWD_DEFINED__ */


#ifndef __IVMVirtualNetwork_FWD_DEFINED__
#define __IVMVirtualNetwork_FWD_DEFINED__
typedef interface IVMVirtualNetwork IVMVirtualNetwork;
#endif 	/* __IVMVirtualNetwork_FWD_DEFINED__ */


#ifndef __IVMHardDisk_FWD_DEFINED__
#define __IVMHardDisk_FWD_DEFINED__
typedef interface IVMHardDisk IVMHardDisk;
#endif 	/* __IVMHardDisk_FWD_DEFINED__ */


#ifndef __IVMTaskCollection_FWD_DEFINED__
#define __IVMTaskCollection_FWD_DEFINED__
typedef interface IVMTaskCollection IVMTaskCollection;
#endif 	/* __IVMTaskCollection_FWD_DEFINED__ */


#ifndef __IVMVirtualPC_FWD_DEFINED__
#define __IVMVirtualPC_FWD_DEFINED__
typedef interface IVMVirtualPC IVMVirtualPC;
#endif 	/* __IVMVirtualPC_FWD_DEFINED__ */


#ifndef __IVMVirtualPCEvents_FWD_DEFINED__
#define __IVMVirtualPCEvents_FWD_DEFINED__
typedef interface IVMVirtualPCEvents IVMVirtualPCEvents;
#endif 	/* __IVMVirtualPCEvents_FWD_DEFINED__ */


#ifndef __VMVirtualPC_FWD_DEFINED__
#define __VMVirtualPC_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMVirtualPC VMVirtualPC;
#else
typedef struct VMVirtualPC VMVirtualPC;
#endif /* __cplusplus */

#endif 	/* __VMVirtualPC_FWD_DEFINED__ */


#ifndef __VMAccountant_FWD_DEFINED__
#define __VMAccountant_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMAccountant VMAccountant;
#else
typedef struct VMAccountant VMAccountant;
#endif /* __cplusplus */

#endif 	/* __VMAccountant_FWD_DEFINED__ */


#ifndef __VMDisplay_FWD_DEFINED__
#define __VMDisplay_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMDisplay VMDisplay;
#else
typedef struct VMDisplay VMDisplay;
#endif /* __cplusplus */

#endif 	/* __VMDisplay_FWD_DEFINED__ */


#ifndef __IVMDVDDriveEvents_FWD_DEFINED__
#define __IVMDVDDriveEvents_FWD_DEFINED__
typedef interface IVMDVDDriveEvents IVMDVDDriveEvents;
#endif 	/* __IVMDVDDriveEvents_FWD_DEFINED__ */


#ifndef __VMDVDDrive_FWD_DEFINED__
#define __VMDVDDrive_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMDVDDrive VMDVDDrive;
#else
typedef struct VMDVDDrive VMDVDDrive;
#endif /* __cplusplus */

#endif 	/* __VMDVDDrive_FWD_DEFINED__ */


#ifndef __IVMFloppyDriveEvents_FWD_DEFINED__
#define __IVMFloppyDriveEvents_FWD_DEFINED__
typedef interface IVMFloppyDriveEvents IVMFloppyDriveEvents;
#endif 	/* __IVMFloppyDriveEvents_FWD_DEFINED__ */


#ifndef __VMFloppyDrive_FWD_DEFINED__
#define __VMFloppyDrive_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMFloppyDrive VMFloppyDrive;
#else
typedef struct VMFloppyDrive VMFloppyDrive;
#endif /* __cplusplus */

#endif 	/* __VMFloppyDrive_FWD_DEFINED__ */


#ifndef __VMGuestOS_FWD_DEFINED__
#define __VMGuestOS_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMGuestOS VMGuestOS;
#else
typedef struct VMGuestOS VMGuestOS;
#endif /* __cplusplus */

#endif 	/* __VMGuestOS_FWD_DEFINED__ */


#ifndef __VMHardDiskConnection_FWD_DEFINED__
#define __VMHardDiskConnection_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMHardDiskConnection VMHardDiskConnection;
#else
typedef struct VMHardDiskConnection VMHardDiskConnection;
#endif /* __cplusplus */

#endif 	/* __VMHardDiskConnection_FWD_DEFINED__ */


#ifndef __VMHardDisk_FWD_DEFINED__
#define __VMHardDisk_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMHardDisk VMHardDisk;
#else
typedef struct VMHardDisk VMHardDisk;
#endif /* __cplusplus */

#endif 	/* __VMHardDisk_FWD_DEFINED__ */


#ifndef __VMHostInfo_FWD_DEFINED__
#define __VMHostInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMHostInfo VMHostInfo;
#else
typedef struct VMHostInfo VMHostInfo;
#endif /* __cplusplus */

#endif 	/* __VMHostInfo_FWD_DEFINED__ */


#ifndef __VMKeyboard_FWD_DEFINED__
#define __VMKeyboard_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMKeyboard VMKeyboard;
#else
typedef struct VMKeyboard VMKeyboard;
#endif /* __cplusplus */

#endif 	/* __VMKeyboard_FWD_DEFINED__ */


#ifndef __VMMouseDevice_FWD_DEFINED__
#define __VMMouseDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMMouseDevice VMMouseDevice;
#else
typedef struct VMMouseDevice VMMouseDevice;
#endif /* __cplusplus */

#endif 	/* __VMMouseDevice_FWD_DEFINED__ */


#ifndef __VMNetworkAdapter_FWD_DEFINED__
#define __VMNetworkAdapter_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMNetworkAdapter VMNetworkAdapter;
#else
typedef struct VMNetworkAdapter VMNetworkAdapter;
#endif /* __cplusplus */

#endif 	/* __VMNetworkAdapter_FWD_DEFINED__ */


#ifndef __VMParallelPort_FWD_DEFINED__
#define __VMParallelPort_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMParallelPort VMParallelPort;
#else
typedef struct VMParallelPort VMParallelPort;
#endif /* __cplusplus */

#endif 	/* __VMParallelPort_FWD_DEFINED__ */


#ifndef __VMSerialPort_FWD_DEFINED__
#define __VMSerialPort_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMSerialPort VMSerialPort;
#else
typedef struct VMSerialPort VMSerialPort;
#endif /* __cplusplus */

#endif 	/* __VMSerialPort_FWD_DEFINED__ */


#ifndef __VMVirtualNetwork_FWD_DEFINED__
#define __VMVirtualNetwork_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMVirtualNetwork VMVirtualNetwork;
#else
typedef struct VMVirtualNetwork VMVirtualNetwork;
#endif /* __cplusplus */

#endif 	/* __VMVirtualNetwork_FWD_DEFINED__ */


#ifndef __VMTask_FWD_DEFINED__
#define __VMTask_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMTask VMTask;
#else
typedef struct VMTask VMTask;
#endif /* __cplusplus */

#endif 	/* __VMTask_FWD_DEFINED__ */


#ifndef __VMUSBDevice_FWD_DEFINED__
#define __VMUSBDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class VMUSBDevice VMUSBDevice;
#else
typedef struct VMUSBDevice VMUSBDevice;
#endif /* __cplusplus */

#endif 	/* __VMUSBDevice_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vpccominterfaces_0000_0000 */
/* [local] */ 

#pragma once
#pragma once
#pragma once
#pragma once
/*------------------------------------------------------------------
	Virtual PC-specific HRESULT codes
------------------------------------------------------------------*/

#define	VM_E_TIMED_OUT	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x202 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_OUT_OF_RESOURCE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x203 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_TOO_MANY_VMS	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x204 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_VM_NOT_RUNNING	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x206 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_VM_UNKNOWN	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x207 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_OUT_OF_RESERVE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x208 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_APP_SHUTTING_DOWN	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x209 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_SCRIPT_ALREADY_EXISTS	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x20a ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_VM_RUNNING_OR_SAVED	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x20b ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_PREF_NOT_FOUND	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x300 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_PREF_ILLEGAL_VALUE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x301 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_PREF_VM_ACTIVE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x302 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_PREF_CONFIG_UPDATED_VM_ACTIVE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x303 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_PREF_UNLOADABLE_ACTIVATION	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x306 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_PREF_SAVED_STATE_BAD_VERSION	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x307 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_PREF_SAVED_STATE_ACCESS_DENIED	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x308 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_CONFIG_NO_NAME	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x400 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_CONFIG_NAME_TOO_LONG	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x401 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_CONFIG_NAME_INVALID_CHAR	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x402 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_CONFIG_DUPLICATE_NAME	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x403 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_VM_RUNNING	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x500 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_VM_NO_SAVED_STATE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x501 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_DRIVE_INVALID	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x502 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_DRIVE_BUS_LOC_IN_USE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x503 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_ADDITIONS_NOT_AVAIL	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x504 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_ADDITIONS_FEATURE_NOT_AVAIL	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x505 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_FOLDER_NOT_SHARED	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x506 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_VM_PAUSED	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x507 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_MEDIA_UNMOUNT_FAIL	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x508 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_IMAGE_CAPTURE_FAIL	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x650 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_HOST_FLOPPY_CAPTURE_FAIL	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x651 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_NO_MEDIA_CAPTURED	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x652 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_PARENT_PATH_NOT_FOUND	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x677 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_FILE_TOO_LARGE_FOR_VOLUME	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x679 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_FILE_READ_ONLY	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x67a ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_WRONG_HD_IMAGE_TYPE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x67b ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_HD_IMAGE_OPEN_FAIL	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x67c ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_HOST_DRIVE_NOT_FOUND	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x67e ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_HD_IMAGE_ACCESS	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x681 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_INVALID_HD_FILE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x682 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_IMAGE_SIZE_TOO_LARGE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x683 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_IMAGE_SIZE_TOO_SMALL	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x684 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_PARENT_CHILD_ID_MISMATCH	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x685 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_UNSUPPORTED_HD_DISK_TYPE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x686 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_PARENT_MODIFIED	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x687 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_ADAPTER_NOT_FOUND	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x700 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_VIRTUAL_NETWORK_NAME_ALREADY_EXISTS	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x701 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_INVALID_VIRTUAL_NETWORK_ID	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x702 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_CANT_SET_ETHERNET_ADDRESS	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x703 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_INVALID_IP_ADDRESS	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x704 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_INVALID_NETWORK_ADDRESS	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x705 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_INVALID_NETWORK_MASK	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x706 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_INVALID_STARTING_ADDRESS	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x707 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_INVALID_ENDING_ADDRESS	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x708 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_INVALID_ADDRESS_RANGE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x709 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_CANT_SET_DYNAMIC_MAC_ADDRESS	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x70a ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_DRIVE_IN_USE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x727 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_MEDIA_WRONG_TYPE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x728 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_NO_LICENSE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x750 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_INVALID_LICENSE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x751 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_INVALID_LICENSE_KEY	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x752 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_INVALID_LICENSE_VALUE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x753 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_LICENSE_ACTIVE_VM_LIMIT	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x754 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_LICENSE_HOST_MEMORY_LIMIT	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x755 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_LICENSE_VM_MEMORY_LIMIT	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x756 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_NOT_A_TRIAL_VERSION	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x757 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_NON_ACTIVE_TRIAL	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x758 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_MOUSE_NOT_ACTIVE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x800 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_USING_ABSOLUTE_COORDINATES	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x801 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_USING_RELATIVE_COORDINATES	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x802 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_SET_EXCLUSIVE_MODE_FAIL	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x825 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_NO_DISPLAY	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x850 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_SECURITY_DUPLICATE_USER	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x900 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_USB_CONNECTOR_DRIVER_ERROR	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x925 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_USB_ATTACH_FAILED	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x926 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_USB_DETACH_FAILED	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x927 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_USB_ENUMERATION_FAILED	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x928 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_USB_EXTERNAL_VM	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x929 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_USB_ENUMERATION_FAILED_MORE_DEVICES	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x930 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_USB_ATTACH_FAILED_MORE_DEVICES	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x931 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_USB_ATTACH_FAILED_GP_ERROR	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x932 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_USB_ATTACH_FAILED_ALREADY_ASSIGNED	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x933 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_UNSUPPORTED_HARDWARE	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x950 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_HARDWARE_VIRTUALIZATION_DISABLED	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x951 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

#define	VM_E_VMVIRTUALPC_OLDER_VERSION	( ( ( HRESULT  )(( ( ( ( unsigned long  )1 << 31 )  | ( ( unsigned long  )4 << 16 )  )  | ( unsigned long  )0x952 ) ) | ( HRESULT  )(( 1 << 29 ) ) )  )

const ULONG kVSTypeLibrary_MajorVersion = 1;
const ULONG kVSTypeLibrary_MinorVersion = 0;



extern RPC_IF_HANDLE __MIDL_itf_vpccominterfaces_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vpccominterfaces_0000_0000_v0_0_s_ifspec;


#ifndef __VirtualPC_LIBRARY_DEFINED__
#define __VirtualPC_LIBRARY_DEFINED__

/* library VirtualPC */
/* [custom][version][uuid] */ 

typedef /* [public][v1_enum][uuid] */  DECLSPEC_UUID("24e65079-6dc8-4655-802b-0baff6352998") 
enum __MIDL___MIDL_itf_vpccominterfaces_0000_0000_0001
    {	vmEvent_VirtualPCStarted	= 0,
	vmEvent_VirtualPCStopped	= ( vmEvent_VirtualPCStarted + 1 ) ,
	vmEvent_VirtualMachineLaunched	= ( vmEvent_VirtualPCStopped + 1 ) ,
	vmEvent_VirtualMachineStateRestored	= ( vmEvent_VirtualMachineLaunched + 1 ) ,
	vmEvent_VirtualMachineStateSaved	= ( vmEvent_VirtualMachineStateRestored + 1 ) ,
	vmEvent_VirtualMachineTurnedOff	= ( vmEvent_VirtualMachineStateSaved + 1 ) ,
	vmEvent_VirtualMachineTurnedOffByGuest	= ( vmEvent_VirtualMachineTurnedOff + 1 ) ,
	vmEvent_VirtualMachineReset	= ( vmEvent_VirtualMachineTurnedOffByGuest + 1 ) ,
	vmEvent_VirtualMachineNoHeartbeat	= ( vmEvent_VirtualMachineReset + 1 ) ,
	vmEvent_VirtualMachineProcessorError	= ( vmEvent_VirtualMachineNoHeartbeat + 1 ) ,
	vmEvent_VirtualMachineHostDiskSpaceWarning	= ( vmEvent_VirtualMachineProcessorError + 1 ) ,
	vmEvent_VirtualMachineHostDiskSpaceError	= ( vmEvent_VirtualMachineHostDiskSpaceWarning + 1 ) 
    } 	VMEventType;





















typedef /* [public][public][public][v1_enum][uuid] */  DECLSPEC_UUID("ba5a8f81-8bf3-497e-ada5-1d91ec015469") 
enum __MIDL___MIDL_itf_vpccominterfaces_0000_0000_0002
    {	vmUndoAction_Discard	= 0,
	vmUndoAction_Keep	= ( vmUndoAction_Discard + 1 ) ,
	vmUndoAction_Commit	= ( vmUndoAction_Keep + 1 ) 
    } 	VMUndoAction;

typedef /* [public][public][public][public][v1_enum][uuid] */  DECLSPEC_UUID("942984fb-1d9c-4b65-8cb2-43928a452b7a") 
enum __MIDL___MIDL_itf_vpccominterfaces_0000_0000_0003
    {	vmVMState_Invalid	= 0,
	vmVMState_TurnedOff	= ( vmVMState_Invalid + 1 ) ,
	vmVMState_Saved	= ( vmVMState_TurnedOff + 1 ) ,
	vmVMState_TurningOn	= ( vmVMState_Saved + 1 ) ,
	vmVMState_Restoring	= ( vmVMState_TurningOn + 1 ) ,
	vmVMState_Running	= ( vmVMState_Restoring + 1 ) ,
	vmVMState_Paused	= ( vmVMState_Running + 1 ) ,
	vmVMState_Saving	= ( vmVMState_Paused + 1 ) ,
	vmVMState_TurningOff	= ( vmVMState_Saving + 1 ) ,
	vmVMState_MergingDrives	= ( vmVMState_TurningOff + 1 ) ,
	vmVMState_DeleteMachine	= ( vmVMState_MergingDrives + 1 ) 
    } 	VMVMState;

typedef /* [public][v1_enum][uuid] */  DECLSPEC_UUID("a21f0a07-10bf-494f-a9b5-f5c6b3a646fe") 
enum __MIDL___MIDL_itf_vpccominterfaces_0000_0000_0004
    {	vmDriveType_Null	= 0,
	vmDriveType_HardDisk	= ( vmDriveType_Null + 1 ) ,
	vmDriveType_DVD	= ( vmDriveType_HardDisk + 1 ) 
    } 	VMDriveType;

typedef /* [public][v1_enum][uuid] */  DECLSPEC_UUID("6657ecee-2a47-421b-9488-7f75d6588bca") 
enum __MIDL___MIDL_itf_vpccominterfaces_0000_0000_0005
    {	vmDriveBusType_Invalid	= -1,
	vmDriveBusType_IDE	= 0,
	vmDriveBusType_SCSI	= 1
    } 	VMDriveBusType;

typedef /* [public][public][public][v1_enum][uuid] */  DECLSPEC_UUID("37e07d0a-6aea-41a1-994f-fe134590263c") 
enum __MIDL___MIDL_itf_vpccominterfaces_0000_0000_0006
    {	vmSerialPort_HostPort	= 0,
	vmSerialPort_TextFile	= ( vmSerialPort_HostPort + 1 ) ,
	vmSerialPort_NamedPipe	= ( vmSerialPort_TextFile + 1 ) ,
	vmSerialPort_Null	= ( vmSerialPort_NamedPipe + 1 ) 
    } 	VMSerialPortType;

typedef /* [public][public][public][v1_enum][uuid] */  DECLSPEC_UUID("263c1019-8285-4a3e-9f37-b2a361be28ac") 
enum __MIDL___MIDL_itf_vpccominterfaces_0000_0000_0007
    {	vmShutdownAction_Save	= 0,
	vmShutdownAction_TurnOff	= ( vmShutdownAction_Save + 1 ) ,
	vmShutdownAction_Shutdown	= ( vmShutdownAction_TurnOff + 1 ) 
    } 	VMShutdownAction;

typedef /* [public][public][v1_enum][uuid] */  DECLSPEC_UUID("F581CDF8-B92B-475e-8167-6C448B642216") 
enum __MIDL___MIDL_itf_vpccominterfaces_0000_0000_0008
    {	vmStartupOption_Normal	= 0,
	vmStartupOption_FixParentTimestampMismatch	= ( vmStartupOption_Normal + 1 ) 
    } 	VMStartupOption;

typedef /* [public][public][public][v1_enum][uuid] */  DECLSPEC_UUID("2af36ec0-cfe5-11dd-ad8b-0800200c9a66") 
enum __MIDL___MIDL_itf_vpccominterfaces_0000_0000_0009
    {	vmEndpoint_NamedPipe	= 0,
	vmEndpoint_TCPIP	= ( vmEndpoint_NamedPipe + 1 ) 
    } 	VMEndpointType;

typedef /* [public][public][v1_enum][uuid] */  DECLSPEC_UUID("7aa05db2-2aec-4b9e-b011-875303424da6") 
enum __MIDL___MIDL_itf_vpccominterfaces_0000_0000_0010
    {	vmLogoff_Normal	= 0,
	vmLogoff_Forced	= ( vmLogoff_Normal + 1 ) ,
	vmLogoff_External	= ( vmLogoff_Forced + 1 ) 
    } 	VMLogoffType;

EXTERN_C const IID DIID_IVMVirtualMachineEvents;
typedef /* [public][v1_enum][uuid] */  DECLSPEC_UUID("e6ad021d-4c84-420d-a0fc-a7bd19250949") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0004_0001
    {	vmVirtualMachineEvent_StateChanged	= 1,
	vmVirtualMachineEvent_RequestShutdown	= ( vmVirtualMachineEvent_StateChanged + 1 ) ,
	vmVirtualMachineEvent_Reset	= ( vmVirtualMachineEvent_RequestShutdown + 1 ) ,
	vmVirtualMachineEvent_TripleFault	= ( vmVirtualMachineEvent_Reset + 1 ) ,
	vmVirtualMachineEvent_HeartbeatStopped	= ( vmVirtualMachineEvent_TripleFault + 1 ) ,
	vmVirtualMachineEvent_ConfigurationChanged	= ( vmVirtualMachineEvent_HeartbeatStopped + 1 ) ,
	vmVirtualMachineEvent_EnhancedVideoModeChanged	= ( vmVirtualMachineEvent_ConfigurationChanged + 1 ) ,
	vmVirtualMachineEvent_AdditionsUninstalled	= ( vmVirtualMachineEvent_EnhancedVideoModeChanged + 1 ) ,
	vmVirtualMachineEvent_AdditionsAvailable	= ( vmVirtualMachineEvent_AdditionsUninstalled + 1 ) ,
	vmVirtualMachineEvent_GuestShutdown	= ( vmVirtualMachineEvent_AdditionsAvailable + 1 ) ,
	vmVirtualMachineEvent_GuestLogoff	= ( vmVirtualMachineEvent_GuestShutdown + 1 ) ,
	vmVirtualMachineEvent_DiskOutOfSpace	= ( vmVirtualMachineEvent_GuestLogoff + 1 ) 
    } 	VMVirtualMachineEvents;

typedef /* [public][public][v1_enum][uuid] */  DECLSPEC_UUID("c3a4a6cc-d87b-4109-b352-e2e689d8b5af") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0006_0001
    {	vmSupportDriver_InvalidType	= -1,
	vmSupportDriver_VirtualMachineMonitor	= 0,
	vmSupportDriver_NetworkServices	= ( vmSupportDriver_VirtualMachineMonitor + 1 ) 
    } 	VMSupportDriverType;














typedef /* [public][public][public][v1_enum][uuid] */  DECLSPEC_UUID("537df63f-75f4-4871-a1b1-3af93279f9cc") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0008_0001
    {	vmFloppyDiskImage_Unknown	= 0,
	vmFloppyDiskImage_LowDensity	= ( vmFloppyDiskImage_Unknown + 1 ) ,
	vmFloppyDiskImage_HighDensity	= ( vmFloppyDiskImage_LowDensity + 1 ) ,
	vmFloppyDiskImage_DMF	= ( vmFloppyDiskImage_HighDensity + 1 ) ,
	vmFloppyDiskImage_LowDensitySingleSided	= ( vmFloppyDiskImage_DMF + 1 ) ,
	vmFloppyDiskImage_MediumDensity	= ( vmFloppyDiskImage_LowDensitySingleSided + 1 ) ,
	vmFloppyDiskImage_HighDensityMSS	= ( vmFloppyDiskImage_MediumDensity + 1 ) 
    } 	VMFloppyDiskImageType;

EXTERN_C const IID DIID_IVMVirtualPCEvents;
typedef /* [public][v1_enum][uuid] */  DECLSPEC_UUID("5b030e37-c851-4cd8-b44e-0dadf07d866e") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0009_0001
    {	vmVirtualPCEvent_ServiceEvent	= 1,
	vmVirtualPCEvent_VMStateChange	= ( vmVirtualPCEvent_ServiceEvent + 1 ) ,
	vmVirtualPCEvent_EventLogged	= ( vmVirtualPCEvent_VMStateChange + 1 ) ,
	vmVirtualPCEvent_VMHeartbeatStopped	= ( vmVirtualPCEvent_EventLogged + 1 ) 
    } 	VMVirtualPCEvent;

typedef /* [public][public][v1_enum][uuid] */  DECLSPEC_UUID("4c1fe6af-54dc-4c06-9efc-cf59819cbd47") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0011_0001
    {	vmVideoMode_TextMode	= 0,
	vmVideoMode_CGAMode	= ( vmVideoMode_TextMode + 1 ) ,
	vmVideoMode_VGAMode	= ( vmVideoMode_CGAMode + 1 ) ,
	vmVideoMode_SVGAMode	= ( vmVideoMode_VGAMode + 1 ) 
    } 	VMDisplayVideoMode;

typedef /* [public][public][v1_enum][uuid] */  DECLSPEC_UUID("739bd96f-00e0-45b3-938d-c9a3026e0145") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0012_0001
    {	vmDVDDrive_None	= 0,
	vmDVDDrive_Image	= ( vmDVDDrive_None + 1 ) ,
	vmDVDDrive_HostDrive	= ( vmDVDDrive_Image + 1 ) 
    } 	VMDVDDriveAttachmentType;

EXTERN_C const IID DIID_IVMDVDDriveEvents;
typedef /* [public][v1_enum][uuid] */  DECLSPEC_UUID("27834185-e110-4dbf-9a99-ca56e6bff436") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0013_0001
    {	vmDVDDriveEvent_OnInsert	= 1,
	vmDVDDriveEvent_OnEject	= ( vmDVDDriveEvent_OnInsert + 1 ) 
    } 	VMDVDDriveEvent;

typedef /* [public][public][v1_enum][uuid] */  DECLSPEC_UUID("6af87b8a-9078-4993-99fc-86c0895f6b9c") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0015_0001
    {	vmFloppyDrive_None	= 0,
	vmFloppyDrive_Image	= ( vmFloppyDrive_None + 1 ) ,
	vmFloppyDrive_HostDrive	= ( vmFloppyDrive_Image + 1 ) 
    } 	VMFloppyDriveAttachmentType;

EXTERN_C const IID DIID_IVMFloppyDriveEvents;
typedef /* [public][v1_enum][uuid] */  DECLSPEC_UUID("dfd0275a-ffd0-4c66-be25-fc73a4cff255") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0016_0001
    {	vmFloppyDriveEvent_OnInsert	= 1,
	vmFloppyDriveEvent_OnEject	= ( vmFloppyDriveEvent_OnInsert + 1 ) 
    } 	vmFloppyDriveEvent;


typedef /* [public][v1_enum][uuid] */  DECLSPEC_UUID("6A21E5E1-8A1F-4d79-A6CD-65332D187F75") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0018_0001
    {	vmGuestOS_Shutdown	= 0,
	vmGuestOS_LogOff	= ( vmGuestOS_Shutdown + 1 ) ,
	vmGuestOS_Reboot	= ( vmGuestOS_LogOff + 1 ) 
    } 	VMGuestOSOperationType;


typedef /* [public][public][public][public][v1_enum][uuid] */  DECLSPEC_UUID("1a075387-a2d1-47ea-aaad-b64288cc7d42") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0021_0001
    {	vmDiskType_Dynamic	= 0,
	vmDiskType_FixedSize	= ( vmDiskType_Dynamic + 1 ) ,
	vmDiskType_Differencing	= ( vmDiskType_FixedSize + 1 ) 
    } 	VMHardDiskType;


typedef /* [public][public][public][public][v1_enum][uuid] */  DECLSPEC_UUID("1e2d0ecf-d9f1-40d2-86f1-d4ff7d05ae33") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0024_0001
    {	vmMouseButton_Left	= 1,
	vmMouseButton_Right	= ( vmMouseButton_Left + 1 ) ,
	vmMouseButton_Center	= ( vmMouseButton_Right + 1 ) 
    } 	VMMouseButton;



typedef /* [public][public][v1_enum][uuid] */  DECLSPEC_UUID("ae3756b8-21e3-476a-a249-e032cf5be685") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0033_0001
    {	vmTaskResult_Success	= 0,
	vmTaskResult_Cancelled	= ( vmTaskResult_Success + 1 ) ,
	vmTaskResult_UnexpectedError	= ( vmTaskResult_Cancelled + 1 ) ,
	vmTaskResult_OutOfMemoryError	= ( vmTaskResult_UnexpectedError + 1 ) ,
	vmTaskResult_DiskRelatedError	= ( vmTaskResult_OutOfMemoryError + 1 ) ,
	vmTaskResult_IncompatibleSavedStateError	= ( vmTaskResult_DiskRelatedError + 1 ) ,
	vmTaskResult_TimeOutError	= ( vmTaskResult_IncompatibleSavedStateError + 1 ) ,
	vmTaskResult_IllegalValueError	= ( vmTaskResult_TimeOutError + 1 ) ,
	vmTaskResult_ThreadCrashError	= ( vmTaskResult_IllegalValueError + 1 ) ,
	vmTaskResult_ShutdownAbort	= ( vmTaskResult_ThreadCrashError + 1 ) 
    } 	VMTaskResult;

typedef /* [public][public][v1_enum][uuid] */  DECLSPEC_UUID("F3BD102C-E664-43fd-9E8E-4D4EF3E45021") 
enum __MIDL___MIDL_itf_vpccominterfaces_0001_0035_0001
    {	vmUSBDeviceClass_InterfaceDescriptor	= 0,
	vmUSBDeviceClass_Audio	= 0x1,
	vmUSBDeviceClass_Communication	= 0x2,
	vmUSBDeviceClass_HID	= 0x3,
	vmUSBDeviceClass_Physical	= 0x5,
	vmUSBDeviceClass_Image	= 0x6,
	vmUSBDeviceClass_Printer	= 0x7,
	vmUSBDeviceClass_MassStorage	= 0x8,
	vmUSBDeviceClass_Hub	= 0x9,
	vmUSBDeviceClass_CDCData	= 0xa,
	vmUSBDeviceClass_SmartCard	= 0xb,
	vmUSBDeviceClass_ContentSecurity	= 0xd,
	vmUSBDeviceClass_Video	= 0xe,
	vmUSBDeviceClass_PersonalHealthcare	= 0xf,
	vmUSBDeviceClass_DiagnosticDevice	= 0xdc,
	vmUSBDeviceClass_WirelessController	= 0xe0,
	vmUSBDeviceClass_Miscellaneous	= 0xef,
	vmUSBDeviceClass_ApplicationSpecific	= 0xfe,
	vmUSBDeviceClass_VendorSpecific	= 0xff
    } 	VMUSBDeviceClassEnum;


EXTERN_C const IID LIBID_VirtualPC;

#ifndef __IVMAccountant_INTERFACE_DEFINED__
#define __IVMAccountant_INTERFACE_DEFINED__

/* interface IVMAccountant */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMAccountant;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6376c067-7f57-4d63-b754-06e2e4f51d73")
    IVMAccountant : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CPUUtilization( 
            /* [retval][out] */ __RPC__out long *percentageUtilization) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CPUUtilizationHistory( 
            /* [retval][out] */ __RPC__out VARIANT *percentageUtilization) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DiskBytesRead( 
            /* [retval][out] */ __RPC__out VARIANT *bytesRead) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DiskBytesWritten( 
            /* [retval][out] */ __RPC__out VARIANT *bytesWritten) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkBytesReceived( 
            /* [retval][out] */ __RPC__out VARIANT *bytesReceived) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkBytesSent( 
            /* [retval][out] */ __RPC__out VARIANT *bytesSent) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UpTime( 
            /* [retval][out] */ __RPC__out long *secondsAlive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMAccountantVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMAccountant * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMAccountant * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMAccountant * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMAccountant * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMAccountant * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMAccountant * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMAccountant * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CPUUtilization )( 
            __RPC__in IVMAccountant * This,
            /* [retval][out] */ __RPC__out long *percentageUtilization);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CPUUtilizationHistory )( 
            __RPC__in IVMAccountant * This,
            /* [retval][out] */ __RPC__out VARIANT *percentageUtilization);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiskBytesRead )( 
            __RPC__in IVMAccountant * This,
            /* [retval][out] */ __RPC__out VARIANT *bytesRead);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiskBytesWritten )( 
            __RPC__in IVMAccountant * This,
            /* [retval][out] */ __RPC__out VARIANT *bytesWritten);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkBytesReceived )( 
            __RPC__in IVMAccountant * This,
            /* [retval][out] */ __RPC__out VARIANT *bytesReceived);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkBytesSent )( 
            __RPC__in IVMAccountant * This,
            /* [retval][out] */ __RPC__out VARIANT *bytesSent);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UpTime )( 
            __RPC__in IVMAccountant * This,
            /* [retval][out] */ __RPC__out long *secondsAlive);
        
        END_INTERFACE
    } IVMAccountantVtbl;

    interface IVMAccountant
    {
        CONST_VTBL struct IVMAccountantVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMAccountant_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMAccountant_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMAccountant_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMAccountant_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMAccountant_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMAccountant_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMAccountant_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMAccountant_get_CPUUtilization(This,percentageUtilization)	\
    ( (This)->lpVtbl -> get_CPUUtilization(This,percentageUtilization) ) 

#define IVMAccountant_get_CPUUtilizationHistory(This,percentageUtilization)	\
    ( (This)->lpVtbl -> get_CPUUtilizationHistory(This,percentageUtilization) ) 

#define IVMAccountant_get_DiskBytesRead(This,bytesRead)	\
    ( (This)->lpVtbl -> get_DiskBytesRead(This,bytesRead) ) 

#define IVMAccountant_get_DiskBytesWritten(This,bytesWritten)	\
    ( (This)->lpVtbl -> get_DiskBytesWritten(This,bytesWritten) ) 

#define IVMAccountant_get_NetworkBytesReceived(This,bytesReceived)	\
    ( (This)->lpVtbl -> get_NetworkBytesReceived(This,bytesReceived) ) 

#define IVMAccountant_get_NetworkBytesSent(This,bytesSent)	\
    ( (This)->lpVtbl -> get_NetworkBytesSent(This,bytesSent) ) 

#define IVMAccountant_get_UpTime(This,secondsAlive)	\
    ( (This)->lpVtbl -> get_UpTime(This,secondsAlive) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMAccountant_INTERFACE_DEFINED__ */


#ifndef __IVMHardDiskConnection_INTERFACE_DEFINED__
#define __IVMHardDiskConnection_INTERFACE_DEFINED__

/* interface IVMHardDiskConnection */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMHardDiskConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aefa36a5-463a-46ae-9e6c-a1fb4e12e671")
    IVMHardDiskConnection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HardDisk( 
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDisk **hardDisk) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UndoHardDisk( 
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDisk **undoHardDisk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetBusLocation( 
            /* [in] */ long vmBusNumber,
            /* [in] */ long vmDeviceNumber) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BusNumber( 
            /* [retval][out] */ __RPC__out long *vmBusNumber) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceNumber( 
            /* [retval][out] */ __RPC__out long *vmDeviceNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMHardDiskConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMHardDiskConnection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMHardDiskConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMHardDiskConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMHardDiskConnection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMHardDiskConnection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMHardDiskConnection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMHardDiskConnection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HardDisk )( 
            __RPC__in IVMHardDiskConnection * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDisk **hardDisk);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UndoHardDisk )( 
            __RPC__in IVMHardDiskConnection * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDisk **undoHardDisk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetBusLocation )( 
            __RPC__in IVMHardDiskConnection * This,
            /* [in] */ long vmBusNumber,
            /* [in] */ long vmDeviceNumber);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BusNumber )( 
            __RPC__in IVMHardDiskConnection * This,
            /* [retval][out] */ __RPC__out long *vmBusNumber);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceNumber )( 
            __RPC__in IVMHardDiskConnection * This,
            /* [retval][out] */ __RPC__out long *vmDeviceNumber);
        
        END_INTERFACE
    } IVMHardDiskConnectionVtbl;

    interface IVMHardDiskConnection
    {
        CONST_VTBL struct IVMHardDiskConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMHardDiskConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMHardDiskConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMHardDiskConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMHardDiskConnection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMHardDiskConnection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMHardDiskConnection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMHardDiskConnection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMHardDiskConnection_get_HardDisk(This,hardDisk)	\
    ( (This)->lpVtbl -> get_HardDisk(This,hardDisk) ) 

#define IVMHardDiskConnection_get_UndoHardDisk(This,undoHardDisk)	\
    ( (This)->lpVtbl -> get_UndoHardDisk(This,undoHardDisk) ) 

#define IVMHardDiskConnection_SetBusLocation(This,vmBusNumber,vmDeviceNumber)	\
    ( (This)->lpVtbl -> SetBusLocation(This,vmBusNumber,vmDeviceNumber) ) 

#define IVMHardDiskConnection_get_BusNumber(This,vmBusNumber)	\
    ( (This)->lpVtbl -> get_BusNumber(This,vmBusNumber) ) 

#define IVMHardDiskConnection_get_DeviceNumber(This,vmDeviceNumber)	\
    ( (This)->lpVtbl -> get_DeviceNumber(This,vmDeviceNumber) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMHardDiskConnection_INTERFACE_DEFINED__ */


#ifndef __IVMHardDiskConnectionCollection_INTERFACE_DEFINED__
#define __IVMHardDiskConnectionCollection_INTERFACE_DEFINED__

/* interface IVMHardDiskConnectionCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMHardDiskConnectionCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b9f2caf4-0aeb-4085-b105-ceddb90dbf62")
    IVMHardDiskConnectionCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDiskConnection **hardDiskConnection) = 0;
        
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMHardDiskConnectionCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMHardDiskConnectionCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMHardDiskConnectionCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMHardDiskConnectionCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMHardDiskConnectionCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMHardDiskConnectionCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMHardDiskConnectionCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMHardDiskConnectionCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IVMHardDiskConnectionCollection * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IVMHardDiskConnectionCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDiskConnection **hardDiskConnection);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IVMHardDiskConnectionCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator);
        
        END_INTERFACE
    } IVMHardDiskConnectionCollectionVtbl;

    interface IVMHardDiskConnectionCollection
    {
        CONST_VTBL struct IVMHardDiskConnectionCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMHardDiskConnectionCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMHardDiskConnectionCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMHardDiskConnectionCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMHardDiskConnectionCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMHardDiskConnectionCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMHardDiskConnectionCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMHardDiskConnectionCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMHardDiskConnectionCollection_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IVMHardDiskConnectionCollection_get_Item(This,index,hardDiskConnection)	\
    ( (This)->lpVtbl -> get_Item(This,index,hardDiskConnection) ) 

#define IVMHardDiskConnectionCollection_get__NewEnum(This,enumerator)	\
    ( (This)->lpVtbl -> get__NewEnum(This,enumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMHardDiskConnectionCollection_INTERFACE_DEFINED__ */


#ifndef __IVMFloppyDrive_INTERFACE_DEFINED__
#define __IVMFloppyDrive_INTERFACE_DEFINED__

/* interface IVMFloppyDrive */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMFloppyDrive;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("661abee6-112a-4ed9-babf-3c874969f10e")
    IVMFloppyDrive : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AttachImage( 
            /* [in] */ __RPC__in BSTR mediaImagePath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReleaseImage( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ImageFile( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *imageFile) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AttachHostDrive( 
            /* [in] */ __RPC__in BSTR driveLetter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReleaseHostDrive( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostDriveLetter( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *driveLetter) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DriveNumber( 
            /* [retval][out] */ __RPC__out long *driveNumber) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Attachment( 
            /* [retval][out] */ __RPC__out VMFloppyDriveAttachmentType *driveAttachment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMFloppyDriveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMFloppyDrive * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMFloppyDrive * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMFloppyDrive * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMFloppyDrive * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMFloppyDrive * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMFloppyDrive * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMFloppyDrive * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AttachImage )( 
            __RPC__in IVMFloppyDrive * This,
            /* [in] */ __RPC__in BSTR mediaImagePath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReleaseImage )( 
            __RPC__in IVMFloppyDrive * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImageFile )( 
            __RPC__in IVMFloppyDrive * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *imageFile);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AttachHostDrive )( 
            __RPC__in IVMFloppyDrive * This,
            /* [in] */ __RPC__in BSTR driveLetter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReleaseHostDrive )( 
            __RPC__in IVMFloppyDrive * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostDriveLetter )( 
            __RPC__in IVMFloppyDrive * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *driveLetter);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DriveNumber )( 
            __RPC__in IVMFloppyDrive * This,
            /* [retval][out] */ __RPC__out long *driveNumber);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attachment )( 
            __RPC__in IVMFloppyDrive * This,
            /* [retval][out] */ __RPC__out VMFloppyDriveAttachmentType *driveAttachment);
        
        END_INTERFACE
    } IVMFloppyDriveVtbl;

    interface IVMFloppyDrive
    {
        CONST_VTBL struct IVMFloppyDriveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMFloppyDrive_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMFloppyDrive_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMFloppyDrive_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMFloppyDrive_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMFloppyDrive_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMFloppyDrive_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMFloppyDrive_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMFloppyDrive_AttachImage(This,mediaImagePath)	\
    ( (This)->lpVtbl -> AttachImage(This,mediaImagePath) ) 

#define IVMFloppyDrive_ReleaseImage(This)	\
    ( (This)->lpVtbl -> ReleaseImage(This) ) 

#define IVMFloppyDrive_get_ImageFile(This,imageFile)	\
    ( (This)->lpVtbl -> get_ImageFile(This,imageFile) ) 

#define IVMFloppyDrive_AttachHostDrive(This,driveLetter)	\
    ( (This)->lpVtbl -> AttachHostDrive(This,driveLetter) ) 

#define IVMFloppyDrive_ReleaseHostDrive(This)	\
    ( (This)->lpVtbl -> ReleaseHostDrive(This) ) 

#define IVMFloppyDrive_get_HostDriveLetter(This,driveLetter)	\
    ( (This)->lpVtbl -> get_HostDriveLetter(This,driveLetter) ) 

#define IVMFloppyDrive_get_DriveNumber(This,driveNumber)	\
    ( (This)->lpVtbl -> get_DriveNumber(This,driveNumber) ) 

#define IVMFloppyDrive_get_Attachment(This,driveAttachment)	\
    ( (This)->lpVtbl -> get_Attachment(This,driveAttachment) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMFloppyDrive_INTERFACE_DEFINED__ */


#ifndef __IVMFloppyDriveCollection_INTERFACE_DEFINED__
#define __IVMFloppyDriveCollection_INTERFACE_DEFINED__

/* interface IVMFloppyDriveCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMFloppyDriveCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8ba70a25-f698-4ee5-85ce-3cc93a925516")
    IVMFloppyDriveCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMFloppyDrive **floppyDrive) = 0;
        
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMFloppyDriveCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMFloppyDriveCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMFloppyDriveCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMFloppyDriveCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMFloppyDriveCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMFloppyDriveCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMFloppyDriveCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMFloppyDriveCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IVMFloppyDriveCollection * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IVMFloppyDriveCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMFloppyDrive **floppyDrive);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IVMFloppyDriveCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator);
        
        END_INTERFACE
    } IVMFloppyDriveCollectionVtbl;

    interface IVMFloppyDriveCollection
    {
        CONST_VTBL struct IVMFloppyDriveCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMFloppyDriveCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMFloppyDriveCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMFloppyDriveCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMFloppyDriveCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMFloppyDriveCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMFloppyDriveCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMFloppyDriveCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMFloppyDriveCollection_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IVMFloppyDriveCollection_get_Item(This,index,floppyDrive)	\
    ( (This)->lpVtbl -> get_Item(This,index,floppyDrive) ) 

#define IVMFloppyDriveCollection_get__NewEnum(This,enumerator)	\
    ( (This)->lpVtbl -> get__NewEnum(This,enumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMFloppyDriveCollection_INTERFACE_DEFINED__ */


#ifndef __IVMDVDDrive_INTERFACE_DEFINED__
#define __IVMDVDDrive_INTERFACE_DEFINED__

/* interface IVMDVDDrive */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMDVDDrive;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b96328f6-6732-437d-a00d-ffa47e43971c")
    IVMDVDDrive : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetBusLocation( 
            /* [in] */ long busNumber,
            /* [in] */ long deviceNumber) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BusNumber( 
            /* [retval][out] */ __RPC__out long *vmBusNumber) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceNumber( 
            /* [retval][out] */ __RPC__out long *vmDeviceNumber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AttachImage( 
            /* [in] */ __RPC__in BSTR imagePath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReleaseImage( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ImageFile( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *imagePath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AttachHostDrive( 
            /* [in] */ __RPC__in BSTR driveLetter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReleaseHostDrive( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostDriveLetter( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *driveLetter) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Attachment( 
            /* [retval][out] */ __RPC__out VMDVDDriveAttachmentType *driveAttachment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMDVDDriveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMDVDDrive * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMDVDDrive * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMDVDDrive * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMDVDDrive * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMDVDDrive * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMDVDDrive * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMDVDDrive * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetBusLocation )( 
            __RPC__in IVMDVDDrive * This,
            /* [in] */ long busNumber,
            /* [in] */ long deviceNumber);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BusNumber )( 
            __RPC__in IVMDVDDrive * This,
            /* [retval][out] */ __RPC__out long *vmBusNumber);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceNumber )( 
            __RPC__in IVMDVDDrive * This,
            /* [retval][out] */ __RPC__out long *vmDeviceNumber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AttachImage )( 
            __RPC__in IVMDVDDrive * This,
            /* [in] */ __RPC__in BSTR imagePath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReleaseImage )( 
            __RPC__in IVMDVDDrive * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImageFile )( 
            __RPC__in IVMDVDDrive * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *imagePath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AttachHostDrive )( 
            __RPC__in IVMDVDDrive * This,
            /* [in] */ __RPC__in BSTR driveLetter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReleaseHostDrive )( 
            __RPC__in IVMDVDDrive * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostDriveLetter )( 
            __RPC__in IVMDVDDrive * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *driveLetter);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attachment )( 
            __RPC__in IVMDVDDrive * This,
            /* [retval][out] */ __RPC__out VMDVDDriveAttachmentType *driveAttachment);
        
        END_INTERFACE
    } IVMDVDDriveVtbl;

    interface IVMDVDDrive
    {
        CONST_VTBL struct IVMDVDDriveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMDVDDrive_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMDVDDrive_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMDVDDrive_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMDVDDrive_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMDVDDrive_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMDVDDrive_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMDVDDrive_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMDVDDrive_SetBusLocation(This,busNumber,deviceNumber)	\
    ( (This)->lpVtbl -> SetBusLocation(This,busNumber,deviceNumber) ) 

#define IVMDVDDrive_get_BusNumber(This,vmBusNumber)	\
    ( (This)->lpVtbl -> get_BusNumber(This,vmBusNumber) ) 

#define IVMDVDDrive_get_DeviceNumber(This,vmDeviceNumber)	\
    ( (This)->lpVtbl -> get_DeviceNumber(This,vmDeviceNumber) ) 

#define IVMDVDDrive_AttachImage(This,imagePath)	\
    ( (This)->lpVtbl -> AttachImage(This,imagePath) ) 

#define IVMDVDDrive_ReleaseImage(This)	\
    ( (This)->lpVtbl -> ReleaseImage(This) ) 

#define IVMDVDDrive_get_ImageFile(This,imagePath)	\
    ( (This)->lpVtbl -> get_ImageFile(This,imagePath) ) 

#define IVMDVDDrive_AttachHostDrive(This,driveLetter)	\
    ( (This)->lpVtbl -> AttachHostDrive(This,driveLetter) ) 

#define IVMDVDDrive_ReleaseHostDrive(This)	\
    ( (This)->lpVtbl -> ReleaseHostDrive(This) ) 

#define IVMDVDDrive_get_HostDriveLetter(This,driveLetter)	\
    ( (This)->lpVtbl -> get_HostDriveLetter(This,driveLetter) ) 

#define IVMDVDDrive_get_Attachment(This,driveAttachment)	\
    ( (This)->lpVtbl -> get_Attachment(This,driveAttachment) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMDVDDrive_INTERFACE_DEFINED__ */


#ifndef __IVMDVDDriveCollection_INTERFACE_DEFINED__
#define __IVMDVDDriveCollection_INTERFACE_DEFINED__

/* interface IVMDVDDriveCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMDVDDriveCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bc86e297-e55f-4742-9614-ad11d3131f68")
    IVMDVDDriveCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMDVDDrive **dvdDrive) = 0;
        
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMDVDDriveCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMDVDDriveCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMDVDDriveCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMDVDDriveCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMDVDDriveCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMDVDDriveCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMDVDDriveCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMDVDDriveCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IVMDVDDriveCollection * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IVMDVDDriveCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMDVDDrive **dvdDrive);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IVMDVDDriveCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator);
        
        END_INTERFACE
    } IVMDVDDriveCollectionVtbl;

    interface IVMDVDDriveCollection
    {
        CONST_VTBL struct IVMDVDDriveCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMDVDDriveCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMDVDDriveCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMDVDDriveCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMDVDDriveCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMDVDDriveCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMDVDDriveCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMDVDDriveCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMDVDDriveCollection_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IVMDVDDriveCollection_get_Item(This,index,dvdDrive)	\
    ( (This)->lpVtbl -> get_Item(This,index,dvdDrive) ) 

#define IVMDVDDriveCollection_get__NewEnum(This,enumerator)	\
    ( (This)->lpVtbl -> get__NewEnum(This,enumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMDVDDriveCollection_INTERFACE_DEFINED__ */


#ifndef __IVMGuestOS_INTERFACE_DEFINED__
#define __IVMGuestOS_INTERFACE_DEFINED__

/* interface IVMGuestOS */
/* [hidden][unique][helpstring][dual][uuid][object] */ 

typedef struct _GUESTOSVERSIONINFOEX
    {
    long dwOSVersionInfoSize;
    long dwMajorVersion;
    long dwMinorVersion;
    long dwBuildNumber;
    long dwPlatformId;
    wchar_t szCSDVersion[ 128 ];
    short wServicePackMajor;
    short wServicePackMinor;
    short wSuiteMask;
    byte wProductType;
    byte wReserved;
    } 	GUESTOSVERSIONINFOEX;


EXTERN_C const IID IID_IVMGuestOS;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("99fea0db-4880-499a-b6d8-73dff9bc91be")
    IVMGuestOS : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InstallIntegrationComponents( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetParameter( 
            /* [in] */ __RPC__in BSTR inParameterName,
            /* [in] */ __RPC__in BSTR inParameterValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shutdown( 
            /* [in] */ VARIANT_BOOL inForced,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **outShutdownTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Restart( 
            /* [in] */ VARIANT_BOOL inForced,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **outRestartTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Logoff( 
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **outLogoffTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetOsVersionInfo( 
            /* [retval][ref][out] */ __RPC__deref_out_opt GUESTOSVERSIONINFOEX **guestOsVersionInfo) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsHostTimeSyncEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isEnabled) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_IsHostTimeSyncEnabled( 
            /* [in] */ VARIANT_BOOL shouldEnable) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HeartbeatPercentage( 
            /* [retval][out] */ __RPC__out long *heartbeatPercentage) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsHeartbeating( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *heartBeating) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OSName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *guestOSName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IntegrationComponentsVersion( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ICVersion) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CanShutdown( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *canShutdown) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TerminalServicesInitialized( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *termServStatus) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MultipleUserSessionsAllowed( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *sessionStatus) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TerminalServerPort( 
            /* [retval][out] */ __RPC__out long *tsPort) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OSMajorVersion( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *majorVersion) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OSMinorVersion( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *minorVersion) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OSBuildNumber( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *buildNumber) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OSVersion( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *OSVersion) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OSPlatformId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *platformId) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CSDVersion( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *csdVersion) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServicePackMajor( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *servicePackMajor) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServicePackMinor( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *servicePackMinor) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SuiteMask( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *suiteMask) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProductType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *productType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetParameter( 
            /* [in] */ __RPC__in BSTR inParameterName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *outParameterValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *guestComputerName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScreenLocked( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *guestScreenLocked) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsUserLoggedOn( 
            /* [in] */ long inRailSession,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *outSessionPresent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMGuestOSVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMGuestOS * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMGuestOS * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMGuestOS * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMGuestOS * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMGuestOS * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMGuestOS * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMGuestOS * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InstallIntegrationComponents )( 
            __RPC__in IVMGuestOS * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetParameter )( 
            __RPC__in IVMGuestOS * This,
            /* [in] */ __RPC__in BSTR inParameterName,
            /* [in] */ __RPC__in BSTR inParameterValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            __RPC__in IVMGuestOS * This,
            /* [in] */ VARIANT_BOOL inForced,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **outShutdownTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Restart )( 
            __RPC__in IVMGuestOS * This,
            /* [in] */ VARIANT_BOOL inForced,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **outRestartTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Logoff )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **outLogoffTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetOsVersionInfo )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt GUESTOSVERSIONINFOEX **guestOsVersionInfo);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsHostTimeSyncEnabled )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isEnabled);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsHostTimeSyncEnabled )( 
            __RPC__in IVMGuestOS * This,
            /* [in] */ VARIANT_BOOL shouldEnable);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HeartbeatPercentage )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__out long *heartbeatPercentage);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsHeartbeating )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *heartBeating);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSName )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *guestOSName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IntegrationComponentsVersion )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ICVersion);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanShutdown )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *canShutdown);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TerminalServicesInitialized )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *termServStatus);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MultipleUserSessionsAllowed )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *sessionStatus);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TerminalServerPort )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__out long *tsPort);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSMajorVersion )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *majorVersion);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSMinorVersion )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *minorVersion);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSBuildNumber )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *buildNumber);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSVersion )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *OSVersion);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSPlatformId )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *platformId);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSDVersion )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *csdVersion);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServicePackMajor )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *servicePackMajor);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServicePackMinor )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *servicePackMinor);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SuiteMask )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *suiteMask);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProductType )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *productType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetParameter )( 
            __RPC__in IVMGuestOS * This,
            /* [in] */ __RPC__in BSTR inParameterName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *outParameterValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ComputerName )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *guestComputerName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScreenLocked )( 
            __RPC__in IVMGuestOS * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *guestScreenLocked);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsUserLoggedOn )( 
            __RPC__in IVMGuestOS * This,
            /* [in] */ long inRailSession,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *outSessionPresent);
        
        END_INTERFACE
    } IVMGuestOSVtbl;

    interface IVMGuestOS
    {
        CONST_VTBL struct IVMGuestOSVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMGuestOS_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMGuestOS_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMGuestOS_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMGuestOS_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMGuestOS_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMGuestOS_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMGuestOS_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMGuestOS_InstallIntegrationComponents(This)	\
    ( (This)->lpVtbl -> InstallIntegrationComponents(This) ) 

#define IVMGuestOS_SetParameter(This,inParameterName,inParameterValue)	\
    ( (This)->lpVtbl -> SetParameter(This,inParameterName,inParameterValue) ) 

#define IVMGuestOS_Shutdown(This,inForced,outShutdownTask)	\
    ( (This)->lpVtbl -> Shutdown(This,inForced,outShutdownTask) ) 

#define IVMGuestOS_Restart(This,inForced,outRestartTask)	\
    ( (This)->lpVtbl -> Restart(This,inForced,outRestartTask) ) 

#define IVMGuestOS_Logoff(This,outLogoffTask)	\
    ( (This)->lpVtbl -> Logoff(This,outLogoffTask) ) 

#define IVMGuestOS_GetOsVersionInfo(This,guestOsVersionInfo)	\
    ( (This)->lpVtbl -> GetOsVersionInfo(This,guestOsVersionInfo) ) 

#define IVMGuestOS_get_IsHostTimeSyncEnabled(This,isEnabled)	\
    ( (This)->lpVtbl -> get_IsHostTimeSyncEnabled(This,isEnabled) ) 

#define IVMGuestOS_put_IsHostTimeSyncEnabled(This,shouldEnable)	\
    ( (This)->lpVtbl -> put_IsHostTimeSyncEnabled(This,shouldEnable) ) 

#define IVMGuestOS_get_HeartbeatPercentage(This,heartbeatPercentage)	\
    ( (This)->lpVtbl -> get_HeartbeatPercentage(This,heartbeatPercentage) ) 

#define IVMGuestOS_get_IsHeartbeating(This,heartBeating)	\
    ( (This)->lpVtbl -> get_IsHeartbeating(This,heartBeating) ) 

#define IVMGuestOS_get_OSName(This,guestOSName)	\
    ( (This)->lpVtbl -> get_OSName(This,guestOSName) ) 

#define IVMGuestOS_get_IntegrationComponentsVersion(This,ICVersion)	\
    ( (This)->lpVtbl -> get_IntegrationComponentsVersion(This,ICVersion) ) 

#define IVMGuestOS_get_CanShutdown(This,canShutdown)	\
    ( (This)->lpVtbl -> get_CanShutdown(This,canShutdown) ) 

#define IVMGuestOS_get_TerminalServicesInitialized(This,termServStatus)	\
    ( (This)->lpVtbl -> get_TerminalServicesInitialized(This,termServStatus) ) 

#define IVMGuestOS_get_MultipleUserSessionsAllowed(This,sessionStatus)	\
    ( (This)->lpVtbl -> get_MultipleUserSessionsAllowed(This,sessionStatus) ) 

#define IVMGuestOS_get_TerminalServerPort(This,tsPort)	\
    ( (This)->lpVtbl -> get_TerminalServerPort(This,tsPort) ) 

#define IVMGuestOS_get_OSMajorVersion(This,majorVersion)	\
    ( (This)->lpVtbl -> get_OSMajorVersion(This,majorVersion) ) 

#define IVMGuestOS_get_OSMinorVersion(This,minorVersion)	\
    ( (This)->lpVtbl -> get_OSMinorVersion(This,minorVersion) ) 

#define IVMGuestOS_get_OSBuildNumber(This,buildNumber)	\
    ( (This)->lpVtbl -> get_OSBuildNumber(This,buildNumber) ) 

#define IVMGuestOS_get_OSVersion(This,OSVersion)	\
    ( (This)->lpVtbl -> get_OSVersion(This,OSVersion) ) 

#define IVMGuestOS_get_OSPlatformId(This,platformId)	\
    ( (This)->lpVtbl -> get_OSPlatformId(This,platformId) ) 

#define IVMGuestOS_get_CSDVersion(This,csdVersion)	\
    ( (This)->lpVtbl -> get_CSDVersion(This,csdVersion) ) 

#define IVMGuestOS_get_ServicePackMajor(This,servicePackMajor)	\
    ( (This)->lpVtbl -> get_ServicePackMajor(This,servicePackMajor) ) 

#define IVMGuestOS_get_ServicePackMinor(This,servicePackMinor)	\
    ( (This)->lpVtbl -> get_ServicePackMinor(This,servicePackMinor) ) 

#define IVMGuestOS_get_SuiteMask(This,suiteMask)	\
    ( (This)->lpVtbl -> get_SuiteMask(This,suiteMask) ) 

#define IVMGuestOS_get_ProductType(This,productType)	\
    ( (This)->lpVtbl -> get_ProductType(This,productType) ) 

#define IVMGuestOS_GetParameter(This,inParameterName,outParameterValue)	\
    ( (This)->lpVtbl -> GetParameter(This,inParameterName,outParameterValue) ) 

#define IVMGuestOS_get_ComputerName(This,guestComputerName)	\
    ( (This)->lpVtbl -> get_ComputerName(This,guestComputerName) ) 

#define IVMGuestOS_get_ScreenLocked(This,guestScreenLocked)	\
    ( (This)->lpVtbl -> get_ScreenLocked(This,guestScreenLocked) ) 

#define IVMGuestOS_IsUserLoggedOn(This,inRailSession,outSessionPresent)	\
    ( (This)->lpVtbl -> IsUserLoggedOn(This,inRailSession,outSessionPresent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMGuestOS_INTERFACE_DEFINED__ */


#ifndef __IVMNetworkAdapter_INTERFACE_DEFINED__
#define __IVMNetworkAdapter_INTERFACE_DEFINED__

/* interface IVMNetworkAdapter */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMNetworkAdapter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e32e4165-22b8-4dc0-8d57-850171ae207a")
    IVMNetworkAdapter : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][hidden] */ HRESULT STDMETHODCALLTYPE _ID( 
            /* [out] */ __RPC__out long *identifier) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_VirtualMachine( 
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualMachine **virtualMachine) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AttachToVirtualNetwork( 
            /* [in] */ __RPC__in_opt IVMVirtualNetwork *virtualNetwork) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DetachFromVirtualNetwork( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_VirtualNetwork( 
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualNetwork **virtualNetwork) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EthernetAddress( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ethernetAddress) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EthernetAddress( 
            /* [in] */ __RPC__in BSTR ethernetAddress) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsEthernetAddressDynamic( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isDynamic) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_IsEthernetAddressDynamic( 
            /* [in] */ VARIANT_BOOL isDynamic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMNetworkAdapterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMNetworkAdapter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMNetworkAdapter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMNetworkAdapter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMNetworkAdapter * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMNetworkAdapter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMNetworkAdapter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMNetworkAdapter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *_ID )( 
            __RPC__in IVMNetworkAdapter * This,
            /* [out] */ __RPC__out long *identifier);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VirtualMachine )( 
            __RPC__in IVMNetworkAdapter * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualMachine **virtualMachine);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AttachToVirtualNetwork )( 
            __RPC__in IVMNetworkAdapter * This,
            /* [in] */ __RPC__in_opt IVMVirtualNetwork *virtualNetwork);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DetachFromVirtualNetwork )( 
            __RPC__in IVMNetworkAdapter * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VirtualNetwork )( 
            __RPC__in IVMNetworkAdapter * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualNetwork **virtualNetwork);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EthernetAddress )( 
            __RPC__in IVMNetworkAdapter * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ethernetAddress);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EthernetAddress )( 
            __RPC__in IVMNetworkAdapter * This,
            /* [in] */ __RPC__in BSTR ethernetAddress);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsEthernetAddressDynamic )( 
            __RPC__in IVMNetworkAdapter * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isDynamic);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsEthernetAddressDynamic )( 
            __RPC__in IVMNetworkAdapter * This,
            /* [in] */ VARIANT_BOOL isDynamic);
        
        END_INTERFACE
    } IVMNetworkAdapterVtbl;

    interface IVMNetworkAdapter
    {
        CONST_VTBL struct IVMNetworkAdapterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMNetworkAdapter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMNetworkAdapter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMNetworkAdapter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMNetworkAdapter_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMNetworkAdapter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMNetworkAdapter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMNetworkAdapter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMNetworkAdapter__ID(This,identifier)	\
    ( (This)->lpVtbl -> _ID(This,identifier) ) 

#define IVMNetworkAdapter_get_VirtualMachine(This,virtualMachine)	\
    ( (This)->lpVtbl -> get_VirtualMachine(This,virtualMachine) ) 

#define IVMNetworkAdapter_AttachToVirtualNetwork(This,virtualNetwork)	\
    ( (This)->lpVtbl -> AttachToVirtualNetwork(This,virtualNetwork) ) 

#define IVMNetworkAdapter_DetachFromVirtualNetwork(This)	\
    ( (This)->lpVtbl -> DetachFromVirtualNetwork(This) ) 

#define IVMNetworkAdapter_get_VirtualNetwork(This,virtualNetwork)	\
    ( (This)->lpVtbl -> get_VirtualNetwork(This,virtualNetwork) ) 

#define IVMNetworkAdapter_get_EthernetAddress(This,ethernetAddress)	\
    ( (This)->lpVtbl -> get_EthernetAddress(This,ethernetAddress) ) 

#define IVMNetworkAdapter_put_EthernetAddress(This,ethernetAddress)	\
    ( (This)->lpVtbl -> put_EthernetAddress(This,ethernetAddress) ) 

#define IVMNetworkAdapter_get_IsEthernetAddressDynamic(This,isDynamic)	\
    ( (This)->lpVtbl -> get_IsEthernetAddressDynamic(This,isDynamic) ) 

#define IVMNetworkAdapter_put_IsEthernetAddressDynamic(This,isDynamic)	\
    ( (This)->lpVtbl -> put_IsEthernetAddressDynamic(This,isDynamic) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMNetworkAdapter_INTERFACE_DEFINED__ */


#ifndef __IVMNetworkAdapterCollection_INTERFACE_DEFINED__
#define __IVMNetworkAdapterCollection_INTERFACE_DEFINED__

/* interface IVMNetworkAdapterCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMNetworkAdapterCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ebaeafe9-ebcd-47cf-866e-ad87d735e479")
    IVMNetworkAdapterCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMNetworkAdapter **networkInterface) = 0;
        
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMNetworkAdapterCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMNetworkAdapterCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMNetworkAdapterCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMNetworkAdapterCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMNetworkAdapterCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMNetworkAdapterCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMNetworkAdapterCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMNetworkAdapterCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IVMNetworkAdapterCollection * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IVMNetworkAdapterCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMNetworkAdapter **networkInterface);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IVMNetworkAdapterCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator);
        
        END_INTERFACE
    } IVMNetworkAdapterCollectionVtbl;

    interface IVMNetworkAdapterCollection
    {
        CONST_VTBL struct IVMNetworkAdapterCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMNetworkAdapterCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMNetworkAdapterCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMNetworkAdapterCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMNetworkAdapterCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMNetworkAdapterCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMNetworkAdapterCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMNetworkAdapterCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMNetworkAdapterCollection_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IVMNetworkAdapterCollection_get_Item(This,index,networkInterface)	\
    ( (This)->lpVtbl -> get_Item(This,index,networkInterface) ) 

#define IVMNetworkAdapterCollection_get__NewEnum(This,enumerator)	\
    ( (This)->lpVtbl -> get__NewEnum(This,enumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMNetworkAdapterCollection_INTERFACE_DEFINED__ */


#ifndef __IVMDisplay_INTERFACE_DEFINED__
#define __IVMDisplay_INTERFACE_DEFINED__

/* interface IVMDisplay */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMDisplay;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("960895e9-f743-4498-96aa-261f867e7fc5")
    IVMDisplay : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDimensions( 
            /* [in] */ long displayPixelWidth,
            /* [in] */ long displayPixelHeight) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ __RPC__out long *displayPixelWidth) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ __RPC__out long *displayPixelHeight) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CanResize( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *canResize) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_VideoMode( 
            /* [retval][out] */ __RPC__out VMDisplayVideoMode *videoMode) = 0;
        
        virtual /* [helpstring][restricted][hidden] */ HRESULT STDMETHODCALLTYPE _GenerateThumbnail( 
            /* [out] */ __RPC__out_ecount_full(( 64 * 48 ) ) unsigned long thumbnailImage[ 3072 ]) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Thumbnail( 
            /* [retval][out] */ __RPC__out VARIANT *thumbnailImage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMDisplayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMDisplay * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMDisplay * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMDisplay * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMDisplay * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMDisplay * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMDisplay * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMDisplay * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDimensions )( 
            __RPC__in IVMDisplay * This,
            /* [in] */ long displayPixelWidth,
            /* [in] */ long displayPixelHeight);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            __RPC__in IVMDisplay * This,
            /* [retval][out] */ __RPC__out long *displayPixelWidth);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            __RPC__in IVMDisplay * This,
            /* [retval][out] */ __RPC__out long *displayPixelHeight);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanResize )( 
            __RPC__in IVMDisplay * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *canResize);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoMode )( 
            __RPC__in IVMDisplay * This,
            /* [retval][out] */ __RPC__out VMDisplayVideoMode *videoMode);
        
        /* [helpstring][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *_GenerateThumbnail )( 
            __RPC__in IVMDisplay * This,
            /* [out] */ __RPC__out_ecount_full(( 64 * 48 ) ) unsigned long thumbnailImage[ 3072 ]);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Thumbnail )( 
            __RPC__in IVMDisplay * This,
            /* [retval][out] */ __RPC__out VARIANT *thumbnailImage);
        
        END_INTERFACE
    } IVMDisplayVtbl;

    interface IVMDisplay
    {
        CONST_VTBL struct IVMDisplayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMDisplay_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMDisplay_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMDisplay_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMDisplay_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMDisplay_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMDisplay_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMDisplay_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMDisplay_SetDimensions(This,displayPixelWidth,displayPixelHeight)	\
    ( (This)->lpVtbl -> SetDimensions(This,displayPixelWidth,displayPixelHeight) ) 

#define IVMDisplay_get_Width(This,displayPixelWidth)	\
    ( (This)->lpVtbl -> get_Width(This,displayPixelWidth) ) 

#define IVMDisplay_get_Height(This,displayPixelHeight)	\
    ( (This)->lpVtbl -> get_Height(This,displayPixelHeight) ) 

#define IVMDisplay_get_CanResize(This,canResize)	\
    ( (This)->lpVtbl -> get_CanResize(This,canResize) ) 

#define IVMDisplay_get_VideoMode(This,videoMode)	\
    ( (This)->lpVtbl -> get_VideoMode(This,videoMode) ) 

#define IVMDisplay__GenerateThumbnail(This,thumbnailImage)	\
    ( (This)->lpVtbl -> _GenerateThumbnail(This,thumbnailImage) ) 

#define IVMDisplay_get_Thumbnail(This,thumbnailImage)	\
    ( (This)->lpVtbl -> get_Thumbnail(This,thumbnailImage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMDisplay_INTERFACE_DEFINED__ */


#ifndef __IVMMouse_INTERFACE_DEFINED__
#define __IVMMouse_INTERFACE_DEFINED__

/* interface IVMMouse */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMMouse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ac903f6d-6346-4f29-8875-5d511a13895e")
    IVMMouse : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetButton( 
            /* [in] */ VMMouseButton buttonIndex,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isDown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButton( 
            /* [in] */ VMMouseButton buttonIndex,
            /* [in] */ VARIANT_BOOL down) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Click( 
            /* [in] */ VMMouseButton buttonIndex) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HorizontalPosition( 
            /* [retval][out] */ __RPC__out long *position) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_HorizontalPosition( 
            /* [in] */ long position) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_VerticalPosition( 
            /* [retval][out] */ __RPC__out long *position) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_VerticalPosition( 
            /* [in] */ long position) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ScrollWheelPosition( 
            /* [in] */ long position) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UsingAbsoluteCoordinates( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *usingAbsoluteCoordinates) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_UsingAbsoluteCoordinates( 
            /* [in] */ VARIANT_BOOL usingAbsoluteCoordinates) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMMouseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMMouse * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMMouse * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMMouse * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMMouse * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMMouse * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMMouse * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMMouse * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetButton )( 
            __RPC__in IVMMouse * This,
            /* [in] */ VMMouseButton buttonIndex,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isDown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetButton )( 
            __RPC__in IVMMouse * This,
            /* [in] */ VMMouseButton buttonIndex,
            /* [in] */ VARIANT_BOOL down);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Click )( 
            __RPC__in IVMMouse * This,
            /* [in] */ VMMouseButton buttonIndex);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HorizontalPosition )( 
            __RPC__in IVMMouse * This,
            /* [retval][out] */ __RPC__out long *position);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HorizontalPosition )( 
            __RPC__in IVMMouse * This,
            /* [in] */ long position);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VerticalPosition )( 
            __RPC__in IVMMouse * This,
            /* [retval][out] */ __RPC__out long *position);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_VerticalPosition )( 
            __RPC__in IVMMouse * This,
            /* [in] */ long position);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ScrollWheelPosition )( 
            __RPC__in IVMMouse * This,
            /* [in] */ long position);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsingAbsoluteCoordinates )( 
            __RPC__in IVMMouse * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *usingAbsoluteCoordinates);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UsingAbsoluteCoordinates )( 
            __RPC__in IVMMouse * This,
            /* [in] */ VARIANT_BOOL usingAbsoluteCoordinates);
        
        END_INTERFACE
    } IVMMouseVtbl;

    interface IVMMouse
    {
        CONST_VTBL struct IVMMouseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMMouse_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMMouse_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMMouse_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMMouse_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMMouse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMMouse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMMouse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMMouse_GetButton(This,buttonIndex,isDown)	\
    ( (This)->lpVtbl -> GetButton(This,buttonIndex,isDown) ) 

#define IVMMouse_SetButton(This,buttonIndex,down)	\
    ( (This)->lpVtbl -> SetButton(This,buttonIndex,down) ) 

#define IVMMouse_Click(This,buttonIndex)	\
    ( (This)->lpVtbl -> Click(This,buttonIndex) ) 

#define IVMMouse_get_HorizontalPosition(This,position)	\
    ( (This)->lpVtbl -> get_HorizontalPosition(This,position) ) 

#define IVMMouse_put_HorizontalPosition(This,position)	\
    ( (This)->lpVtbl -> put_HorizontalPosition(This,position) ) 

#define IVMMouse_get_VerticalPosition(This,position)	\
    ( (This)->lpVtbl -> get_VerticalPosition(This,position) ) 

#define IVMMouse_put_VerticalPosition(This,position)	\
    ( (This)->lpVtbl -> put_VerticalPosition(This,position) ) 

#define IVMMouse_put_ScrollWheelPosition(This,position)	\
    ( (This)->lpVtbl -> put_ScrollWheelPosition(This,position) ) 

#define IVMMouse_get_UsingAbsoluteCoordinates(This,usingAbsoluteCoordinates)	\
    ( (This)->lpVtbl -> get_UsingAbsoluteCoordinates(This,usingAbsoluteCoordinates) ) 

#define IVMMouse_put_UsingAbsoluteCoordinates(This,usingAbsoluteCoordinates)	\
    ( (This)->lpVtbl -> put_UsingAbsoluteCoordinates(This,usingAbsoluteCoordinates) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMMouse_INTERFACE_DEFINED__ */


#ifndef __IVMKeyboard_INTERFACE_DEFINED__
#define __IVMKeyboard_INTERFACE_DEFINED__

/* interface IVMKeyboard */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMKeyboard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00695f2e-c5ad-4d6e-b1ab-336ed121f8c4")
    IVMKeyboard : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PressKey( 
            /* [in] */ __RPC__in BSTR key) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReleaseKey( 
            /* [in] */ __RPC__in BSTR key) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PressAndReleaseKey( 
            /* [in] */ __RPC__in BSTR key) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsPressed( 
            /* [in] */ __RPC__in BSTR key,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pressed) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TypeAsciiText( 
            /* [in] */ __RPC__in BSTR text) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TypeKeySequence( 
            /* [in] */ __RPC__in BSTR keySequence) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasExclusiveAccess( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isExclusive) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_HasExclusiveAccess( 
            /* [in] */ VARIANT_BOOL makeExclusive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMKeyboardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMKeyboard * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMKeyboard * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMKeyboard * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMKeyboard * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMKeyboard * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMKeyboard * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMKeyboard * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PressKey )( 
            __RPC__in IVMKeyboard * This,
            /* [in] */ __RPC__in BSTR key);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReleaseKey )( 
            __RPC__in IVMKeyboard * This,
            /* [in] */ __RPC__in BSTR key);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PressAndReleaseKey )( 
            __RPC__in IVMKeyboard * This,
            /* [in] */ __RPC__in BSTR key);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsPressed )( 
            __RPC__in IVMKeyboard * This,
            /* [in] */ __RPC__in BSTR key,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pressed);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TypeAsciiText )( 
            __RPC__in IVMKeyboard * This,
            /* [in] */ __RPC__in BSTR text);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TypeKeySequence )( 
            __RPC__in IVMKeyboard * This,
            /* [in] */ __RPC__in BSTR keySequence);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasExclusiveAccess )( 
            __RPC__in IVMKeyboard * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isExclusive);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HasExclusiveAccess )( 
            __RPC__in IVMKeyboard * This,
            /* [in] */ VARIANT_BOOL makeExclusive);
        
        END_INTERFACE
    } IVMKeyboardVtbl;

    interface IVMKeyboard
    {
        CONST_VTBL struct IVMKeyboardVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMKeyboard_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMKeyboard_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMKeyboard_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMKeyboard_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMKeyboard_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMKeyboard_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMKeyboard_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMKeyboard_PressKey(This,key)	\
    ( (This)->lpVtbl -> PressKey(This,key) ) 

#define IVMKeyboard_ReleaseKey(This,key)	\
    ( (This)->lpVtbl -> ReleaseKey(This,key) ) 

#define IVMKeyboard_PressAndReleaseKey(This,key)	\
    ( (This)->lpVtbl -> PressAndReleaseKey(This,key) ) 

#define IVMKeyboard_IsPressed(This,key,pressed)	\
    ( (This)->lpVtbl -> IsPressed(This,key,pressed) ) 

#define IVMKeyboard_TypeAsciiText(This,text)	\
    ( (This)->lpVtbl -> TypeAsciiText(This,text) ) 

#define IVMKeyboard_TypeKeySequence(This,keySequence)	\
    ( (This)->lpVtbl -> TypeKeySequence(This,keySequence) ) 

#define IVMKeyboard_get_HasExclusiveAccess(This,isExclusive)	\
    ( (This)->lpVtbl -> get_HasExclusiveAccess(This,isExclusive) ) 

#define IVMKeyboard_put_HasExclusiveAccess(This,makeExclusive)	\
    ( (This)->lpVtbl -> put_HasExclusiveAccess(This,makeExclusive) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMKeyboard_INTERFACE_DEFINED__ */


#ifndef __IVMParallelPort_INTERFACE_DEFINED__
#define __IVMParallelPort_INTERFACE_DEFINED__

/* interface IVMParallelPort */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMParallelPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("097beecb-0a02-474f-abd6-298b22293fc6")
    IVMParallelPort : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][hidden] */ HRESULT STDMETHODCALLTYPE _ID( 
            /* [out] */ __RPC__out long *portID) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *portName) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR portName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMParallelPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMParallelPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMParallelPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMParallelPort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMParallelPort * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMParallelPort * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMParallelPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMParallelPort * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *_ID )( 
            __RPC__in IVMParallelPort * This,
            /* [out] */ __RPC__out long *portID);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IVMParallelPort * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *portName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IVMParallelPort * This,
            /* [in] */ __RPC__in BSTR portName);
        
        END_INTERFACE
    } IVMParallelPortVtbl;

    interface IVMParallelPort
    {
        CONST_VTBL struct IVMParallelPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMParallelPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMParallelPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMParallelPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMParallelPort_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMParallelPort_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMParallelPort_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMParallelPort_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMParallelPort__ID(This,portID)	\
    ( (This)->lpVtbl -> _ID(This,portID) ) 

#define IVMParallelPort_get_Name(This,portName)	\
    ( (This)->lpVtbl -> get_Name(This,portName) ) 

#define IVMParallelPort_put_Name(This,portName)	\
    ( (This)->lpVtbl -> put_Name(This,portName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMParallelPort_INTERFACE_DEFINED__ */


#ifndef __IVMParallelPortCollection_INTERFACE_DEFINED__
#define __IVMParallelPortCollection_INTERFACE_DEFINED__

/* interface IVMParallelPortCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMParallelPortCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27c3e036-198f-430c-8735-6e652f7203fd")
    IVMParallelPortCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMParallelPort **vmParallelPort) = 0;
        
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMParallelPortCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMParallelPortCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMParallelPortCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMParallelPortCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMParallelPortCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMParallelPortCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMParallelPortCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMParallelPortCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IVMParallelPortCollection * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IVMParallelPortCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMParallelPort **vmParallelPort);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IVMParallelPortCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator);
        
        END_INTERFACE
    } IVMParallelPortCollectionVtbl;

    interface IVMParallelPortCollection
    {
        CONST_VTBL struct IVMParallelPortCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMParallelPortCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMParallelPortCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMParallelPortCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMParallelPortCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMParallelPortCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMParallelPortCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMParallelPortCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMParallelPortCollection_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IVMParallelPortCollection_get_Item(This,index,vmParallelPort)	\
    ( (This)->lpVtbl -> get_Item(This,index,vmParallelPort) ) 

#define IVMParallelPortCollection_get__NewEnum(This,enumerator)	\
    ( (This)->lpVtbl -> get__NewEnum(This,enumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMParallelPortCollection_INTERFACE_DEFINED__ */


#ifndef __IVMSerialPort_INTERFACE_DEFINED__
#define __IVMSerialPort_INTERFACE_DEFINED__

/* interface IVMSerialPort */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMSerialPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2ce4460d-1d3f-4458-bf8b-44084b816815")
    IVMSerialPort : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ VMSerialPortType portType,
            /* [in] */ __RPC__in BSTR portName,
            /* [in] */ VARIANT_BOOL vmConnectImmediately) = 0;
        
        virtual /* [helpstring][restricted][hidden] */ HRESULT STDMETHODCALLTYPE _ID( 
            /* [out] */ __RPC__out long *portID) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__out VMSerialPortType *portType) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *portName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectImmediately( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *vmConnectImmediately) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMSerialPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMSerialPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMSerialPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMSerialPort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMSerialPort * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMSerialPort * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMSerialPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMSerialPort * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Configure )( 
            __RPC__in IVMSerialPort * This,
            /* [in] */ VMSerialPortType portType,
            /* [in] */ __RPC__in BSTR portName,
            /* [in] */ VARIANT_BOOL vmConnectImmediately);
        
        /* [helpstring][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *_ID )( 
            __RPC__in IVMSerialPort * This,
            /* [out] */ __RPC__out long *portID);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in IVMSerialPort * This,
            /* [retval][out] */ __RPC__out VMSerialPortType *portType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IVMSerialPort * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *portName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectImmediately )( 
            __RPC__in IVMSerialPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *vmConnectImmediately);
        
        END_INTERFACE
    } IVMSerialPortVtbl;

    interface IVMSerialPort
    {
        CONST_VTBL struct IVMSerialPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMSerialPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMSerialPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMSerialPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMSerialPort_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMSerialPort_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMSerialPort_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMSerialPort_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMSerialPort_Configure(This,portType,portName,vmConnectImmediately)	\
    ( (This)->lpVtbl -> Configure(This,portType,portName,vmConnectImmediately) ) 

#define IVMSerialPort__ID(This,portID)	\
    ( (This)->lpVtbl -> _ID(This,portID) ) 

#define IVMSerialPort_get_Type(This,portType)	\
    ( (This)->lpVtbl -> get_Type(This,portType) ) 

#define IVMSerialPort_get_Name(This,portName)	\
    ( (This)->lpVtbl -> get_Name(This,portName) ) 

#define IVMSerialPort_get_ConnectImmediately(This,vmConnectImmediately)	\
    ( (This)->lpVtbl -> get_ConnectImmediately(This,vmConnectImmediately) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMSerialPort_INTERFACE_DEFINED__ */


#ifndef __IVMSerialPortCollection_INTERFACE_DEFINED__
#define __IVMSerialPortCollection_INTERFACE_DEFINED__

/* interface IVMSerialPortCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMSerialPortCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dd3c6175-1f04-4341-9f85-104074880289")
    IVMSerialPortCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMSerialPort **serialPort) = 0;
        
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMSerialPortCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMSerialPortCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMSerialPortCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMSerialPortCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMSerialPortCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMSerialPortCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMSerialPortCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMSerialPortCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IVMSerialPortCollection * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IVMSerialPortCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMSerialPort **serialPort);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IVMSerialPortCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator);
        
        END_INTERFACE
    } IVMSerialPortCollectionVtbl;

    interface IVMSerialPortCollection
    {
        CONST_VTBL struct IVMSerialPortCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMSerialPortCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMSerialPortCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMSerialPortCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMSerialPortCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMSerialPortCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMSerialPortCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMSerialPortCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMSerialPortCollection_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IVMSerialPortCollection_get_Item(This,index,serialPort)	\
    ( (This)->lpVtbl -> get_Item(This,index,serialPort) ) 

#define IVMSerialPortCollection_get__NewEnum(This,enumerator)	\
    ( (This)->lpVtbl -> get__NewEnum(This,enumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMSerialPortCollection_INTERFACE_DEFINED__ */


#ifndef __IVMTask_INTERFACE_DEFINED__
#define __IVMTask_INTERFACE_DEFINED__

/* interface IVMTask */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMTask;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ab72b222-6e9c-48ae-aa54-85e3e635767c")
    IVMTask : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WaitForCompletion( 
            /* [in] */ long timeout) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PercentCompleted( 
            /* [retval][out] */ __RPC__out long *percentCompleted) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Result( 
            /* [retval][out] */ __RPC__out VMTaskResult *result) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsCancelable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isCancelable) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ __RPC__out long *ID) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsComplete( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isComplete) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ __RPC__out long *outError) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *outErrorDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMTaskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMTask * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMTask * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMTask * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMTask * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMTask * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMTask * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            __RPC__in IVMTask * This,
            /* [in] */ long timeout);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in IVMTask * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PercentCompleted )( 
            __RPC__in IVMTask * This,
            /* [retval][out] */ __RPC__out long *percentCompleted);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IVMTask * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Result )( 
            __RPC__in IVMTask * This,
            /* [retval][out] */ __RPC__out VMTaskResult *result);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsCancelable )( 
            __RPC__in IVMTask * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isCancelable);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            __RPC__in IVMTask * This,
            /* [retval][out] */ __RPC__out long *ID);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsComplete )( 
            __RPC__in IVMTask * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isComplete);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            __RPC__in IVMTask * This,
            /* [retval][out] */ __RPC__out long *outError);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            __RPC__in IVMTask * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *outErrorDesc);
        
        END_INTERFACE
    } IVMTaskVtbl;

    interface IVMTask
    {
        CONST_VTBL struct IVMTaskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMTask_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMTask_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMTask_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMTask_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMTask_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMTask_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMTask_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMTask_WaitForCompletion(This,timeout)	\
    ( (This)->lpVtbl -> WaitForCompletion(This,timeout) ) 

#define IVMTask_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IVMTask_get_PercentCompleted(This,percentCompleted)	\
    ( (This)->lpVtbl -> get_PercentCompleted(This,percentCompleted) ) 

#define IVMTask_get_Description(This,description)	\
    ( (This)->lpVtbl -> get_Description(This,description) ) 

#define IVMTask_get_Result(This,result)	\
    ( (This)->lpVtbl -> get_Result(This,result) ) 

#define IVMTask_get_IsCancelable(This,isCancelable)	\
    ( (This)->lpVtbl -> get_IsCancelable(This,isCancelable) ) 

#define IVMTask_get_ID(This,ID)	\
    ( (This)->lpVtbl -> get_ID(This,ID) ) 

#define IVMTask_get_IsComplete(This,isComplete)	\
    ( (This)->lpVtbl -> get_IsComplete(This,isComplete) ) 

#define IVMTask_get_Error(This,outError)	\
    ( (This)->lpVtbl -> get_Error(This,outError) ) 

#define IVMTask_get_ErrorDescription(This,outErrorDesc)	\
    ( (This)->lpVtbl -> get_ErrorDescription(This,outErrorDesc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMTask_INTERFACE_DEFINED__ */


#ifndef __IVMUSBDevice_INTERFACE_DEFINED__
#define __IVMUSBDevice_INTERFACE_DEFINED__

/* interface IVMUSBDevice */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMUSBDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63C1258C-5721-4070-B86B-A6CE2AFEC0B3")
    IVMUSBDevice : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *deviceName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ManufacturerString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *manufacturerName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AttachedToVM( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ConfigName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HubID( 
            /* [retval][out] */ __RPC__out long *hubID) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Port( 
            /* [retval][out] */ __RPC__out long *port) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceClass( 
            /* [retval][out] */ __RPC__out VMUSBDeviceClassEnum *deviceClass) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMUSBDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMUSBDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMUSBDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMUSBDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMUSBDevice * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMUSBDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMUSBDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMUSBDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceString )( 
            __RPC__in IVMUSBDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *deviceName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ManufacturerString )( 
            __RPC__in IVMUSBDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *manufacturerName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AttachedToVM )( 
            __RPC__in IVMUSBDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ConfigName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HubID )( 
            __RPC__in IVMUSBDevice * This,
            /* [retval][out] */ __RPC__out long *hubID);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Port )( 
            __RPC__in IVMUSBDevice * This,
            /* [retval][out] */ __RPC__out long *port);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceClass )( 
            __RPC__in IVMUSBDevice * This,
            /* [retval][out] */ __RPC__out VMUSBDeviceClassEnum *deviceClass);
        
        END_INTERFACE
    } IVMUSBDeviceVtbl;

    interface IVMUSBDevice
    {
        CONST_VTBL struct IVMUSBDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMUSBDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMUSBDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMUSBDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMUSBDevice_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMUSBDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMUSBDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMUSBDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMUSBDevice_get_DeviceString(This,deviceName)	\
    ( (This)->lpVtbl -> get_DeviceString(This,deviceName) ) 

#define IVMUSBDevice_get_ManufacturerString(This,manufacturerName)	\
    ( (This)->lpVtbl -> get_ManufacturerString(This,manufacturerName) ) 

#define IVMUSBDevice_get_AttachedToVM(This,ConfigName)	\
    ( (This)->lpVtbl -> get_AttachedToVM(This,ConfigName) ) 

#define IVMUSBDevice_get_HubID(This,hubID)	\
    ( (This)->lpVtbl -> get_HubID(This,hubID) ) 

#define IVMUSBDevice_get_Port(This,port)	\
    ( (This)->lpVtbl -> get_Port(This,port) ) 

#define IVMUSBDevice_get_DeviceClass(This,deviceClass)	\
    ( (This)->lpVtbl -> get_DeviceClass(This,deviceClass) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMUSBDevice_INTERFACE_DEFINED__ */


#ifndef __IVMUSBDeviceCollection_INTERFACE_DEFINED__
#define __IVMUSBDeviceCollection_INTERFACE_DEFINED__

/* interface IVMUSBDeviceCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMUSBDeviceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4FBCD6A5-F53C-4d1c-9F4D-E90ABB8B3749")
    IVMUSBDeviceCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMUSBDevice **usbDevice) = 0;
        
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMUSBDeviceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMUSBDeviceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMUSBDeviceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMUSBDeviceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMUSBDeviceCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMUSBDeviceCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMUSBDeviceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMUSBDeviceCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IVMUSBDeviceCollection * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IVMUSBDeviceCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMUSBDevice **usbDevice);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IVMUSBDeviceCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator);
        
        END_INTERFACE
    } IVMUSBDeviceCollectionVtbl;

    interface IVMUSBDeviceCollection
    {
        CONST_VTBL struct IVMUSBDeviceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMUSBDeviceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMUSBDeviceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMUSBDeviceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMUSBDeviceCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMUSBDeviceCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMUSBDeviceCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMUSBDeviceCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMUSBDeviceCollection_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IVMUSBDeviceCollection_get_Item(This,index,usbDevice)	\
    ( (This)->lpVtbl -> get_Item(This,index,usbDevice) ) 

#define IVMUSBDeviceCollection_get__NewEnum(This,enumerator)	\
    ( (This)->lpVtbl -> get__NewEnum(This,enumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMUSBDeviceCollection_INTERFACE_DEFINED__ */


#ifndef __IVMVirtualMachine_INTERFACE_DEFINED__
#define __IVMVirtualMachine_INTERFACE_DEFINED__

/* interface IVMVirtualMachine */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMVirtualMachine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f7092aa1-33ed-4f78-a59f-c00adfc2edd7")
    IVMVirtualMachine : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *virtualMachineName) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR virtualMachineName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ConfigID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *virtualMachineConfigID) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_File( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *virtualMachineXMLFile) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Accountant( 
            /* [retval][out] */ __RPC__deref_out_opt IVMAccountant **accountant) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GuestOS( 
            /* [retval][out] */ __RPC__deref_out_opt IVMGuestOS **guestOS) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Display( 
            /* [retval][out] */ __RPC__deref_out_opt IVMDisplay **display) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Keyboard( 
            /* [retval][out] */ __RPC__deref_out_opt IVMKeyboard **keyboard) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Mouse( 
            /* [retval][out] */ __RPC__deref_out_opt IVMMouse **mouse) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Startup( 
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **startupTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Startup2( 
            /* [in] */ VMStartupOption startupOption,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **startupTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TurnOff( 
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **turnOffTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **saveTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( 
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **resetTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DiscardSavedState( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out VMVMState *virtualMachineState) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShutdownActionOnQuit( 
            /* [retval][out] */ __RPC__out VMShutdownAction *shutdownAction) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ShutdownActionOnQuit( 
            /* [in] */ VMShutdownAction shutdownAction) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SavedStateFilePath( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *savedStateFilePath) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BIOSGUID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *biosGUID) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_BIOSGUID( 
            /* [in] */ __RPC__in BSTR biosGUID) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BIOSSerialNumber( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *biosSerialNumber) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_BIOSSerialNumber( 
            /* [in] */ __RPC__in BSTR biosSerialNumber) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BaseBoardSerialNumber( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *baseBoardSerialNumber) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_BaseBoardSerialNumber( 
            /* [in] */ __RPC__in BSTR baseBoardSerialNumber) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ChassisSerialNumber( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *chassisSerialNumber) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ChassisSerialNumber( 
            /* [in] */ __RPC__in BSTR chasisSerialNumber) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ChassisAssetTag( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *chassisAssetTag) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ChassisAssetTag( 
            /* [in] */ __RPC__in BSTR chassisAssetTag) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddHardDiskConnection( 
            /* [in] */ __RPC__in BSTR hardDiskPath,
            /* [in] */ long busNumber,
            /* [in] */ long deviceNumber,
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDiskConnection **hardDiskConnection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveHardDiskConnection( 
            /* [in] */ __RPC__in_opt IVMHardDiskConnection *hardDiskConnection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HardDiskConnections( 
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDiskConnectionCollection **hardDiskConnectionCollection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MergeUndoDisks( 
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **undoMergeTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DiscardUndoDisks( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Undoable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isUndoable) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Undoable( 
            /* [in] */ VARIANT_BOOL enableUndo) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UndoAction( 
            /* [retval][out] */ __RPC__out VMUndoAction *undoAction) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_UndoAction( 
            /* [in] */ VMUndoAction undoAction) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddDVDROMDrive( 
            /* [in] */ long busNumber,
            /* [in] */ long deviceNumber,
            /* [retval][out] */ __RPC__deref_out_opt IVMDVDDrive **dvdDrive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveDVDROMDrive( 
            /* [in] */ __RPC__in_opt IVMDVDDrive *dvdDrive) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DVDROMDrives( 
            /* [retval][out] */ __RPC__deref_out_opt IVMDVDDriveCollection **dvdROMCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FloppyDrives( 
            /* [retval][out] */ __RPC__deref_out_opt IVMFloppyDriveCollection **floppyCollection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddNetworkAdapter( 
            /* [retval][out] */ __RPC__deref_out_opt IVMNetworkAdapter **networkAdapter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveNetworkAdapter( 
            /* [in] */ __RPC__in_opt IVMNetworkAdapter *networkAdapter) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkAdapters( 
            /* [retval][out] */ __RPC__deref_out_opt IVMNetworkAdapterCollection **networkAdapterCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SerialPorts( 
            /* [retval][out] */ __RPC__deref_out_opt IVMSerialPortCollection **serialPortCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ParallelPorts( 
            /* [retval][out] */ __RPC__deref_out_opt IVMParallelPortCollection **parallelPortCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProcessorSpeed( 
            /* [retval][out] */ __RPC__out long *processorSpeed) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasMMX( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *mmxEnabled) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasSSE( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *sseEnabled) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasSSE2( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *sse2Enabled) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Has3DNow( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *threeDNowEnabled) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_RdpPipeName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *RdpPipeName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AttachUSBDevice( 
            /* [in] */ __RPC__in_opt IVMUSBDevice *inUSBDevice) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DetachUSBDevice( 
            /* [in] */ __RPC__in_opt IVMUSBDevice *inUSBDevice) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Notes( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *virtualMachineNotes) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Notes( 
            /* [in] */ __RPC__in BSTR virtualMachineNotes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Memory( 
            /* [retval][out] */ __RPC__out long *megabytesOfMemory) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Memory( 
            /* [in] */ long megabytesOfMemory) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AttachedDriveTypes( 
            /* [retval][out] */ __RPC__out VARIANT *driveTypes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetConfigurationValue( 
            /* [in] */ __RPC__in BSTR configurationKey,
            /* [retval][out] */ __RPC__out VARIANT *configurationValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetConfigurationValue( 
            /* [in] */ __RPC__in BSTR configurationKey,
            /* [in] */ VARIANT configurationValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveConfigurationValue( 
            /* [in] */ __RPC__in BSTR configurationKey) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetActivationValue( 
            /* [in] */ __RPC__in BSTR activationKey,
            /* [retval][out] */ __RPC__out VARIANT *activationValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetActivationValue( 
            /* [in] */ __RPC__in BSTR activationKey,
            /* [in] */ VARIANT activationValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveActivationValue( 
            /* [in] */ __RPC__in BSTR activationKey) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartCommunicationChannel( 
            /* [in] */ VMEndpointType inHostEndpointType,
            /* [in] */ __RPC__in BSTR inHostEndPointName,
            /* [in] */ VMEndpointType inGuestEndpointType,
            /* [in] */ __RPC__in BSTR inGuestEndpointName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMVirtualMachineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMVirtualMachine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMVirtualMachine * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMVirtualMachine * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMVirtualMachine * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *virtualMachineName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR virtualMachineName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConfigID )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *virtualMachineConfigID);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_File )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *virtualMachineXMLFile);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Accountant )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMAccountant **accountant);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GuestOS )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMGuestOS **guestOS);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Display )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMDisplay **display);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Keyboard )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMKeyboard **keyboard);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Mouse )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMMouse **mouse);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Startup )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **startupTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Startup2 )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ VMStartupOption startupOption,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **startupTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TurnOff )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **turnOffTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **saveTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **resetTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DiscardSavedState )( 
            __RPC__in IVMVirtualMachine * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            __RPC__in IVMVirtualMachine * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            __RPC__in IVMVirtualMachine * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__out VMVMState *virtualMachineState);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShutdownActionOnQuit )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__out VMShutdownAction *shutdownAction);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ShutdownActionOnQuit )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ VMShutdownAction shutdownAction);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SavedStateFilePath )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *savedStateFilePath);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BIOSGUID )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *biosGUID);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BIOSGUID )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR biosGUID);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BIOSSerialNumber )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *biosSerialNumber);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BIOSSerialNumber )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR biosSerialNumber);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BaseBoardSerialNumber )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *baseBoardSerialNumber);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BaseBoardSerialNumber )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR baseBoardSerialNumber);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChassisSerialNumber )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *chassisSerialNumber);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ChassisSerialNumber )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR chasisSerialNumber);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChassisAssetTag )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *chassisAssetTag);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ChassisAssetTag )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR chassisAssetTag);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddHardDiskConnection )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR hardDiskPath,
            /* [in] */ long busNumber,
            /* [in] */ long deviceNumber,
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDiskConnection **hardDiskConnection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveHardDiskConnection )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in_opt IVMHardDiskConnection *hardDiskConnection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HardDiskConnections )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDiskConnectionCollection **hardDiskConnectionCollection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MergeUndoDisks )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **undoMergeTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DiscardUndoDisks )( 
            __RPC__in IVMVirtualMachine * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Undoable )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isUndoable);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Undoable )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ VARIANT_BOOL enableUndo);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UndoAction )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__out VMUndoAction *undoAction);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UndoAction )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ VMUndoAction undoAction);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddDVDROMDrive )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ long busNumber,
            /* [in] */ long deviceNumber,
            /* [retval][out] */ __RPC__deref_out_opt IVMDVDDrive **dvdDrive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveDVDROMDrive )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in_opt IVMDVDDrive *dvdDrive);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DVDROMDrives )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMDVDDriveCollection **dvdROMCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FloppyDrives )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMFloppyDriveCollection **floppyCollection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddNetworkAdapter )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMNetworkAdapter **networkAdapter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveNetworkAdapter )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in_opt IVMNetworkAdapter *networkAdapter);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkAdapters )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMNetworkAdapterCollection **networkAdapterCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SerialPorts )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMSerialPortCollection **serialPortCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParallelPorts )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMParallelPortCollection **parallelPortCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProcessorSpeed )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__out long *processorSpeed);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasMMX )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *mmxEnabled);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasSSE )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *sseEnabled);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasSSE2 )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *sse2Enabled);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Has3DNow )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *threeDNowEnabled);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RdpPipeName )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *RdpPipeName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AttachUSBDevice )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in_opt IVMUSBDevice *inUSBDevice);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DetachUSBDevice )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in_opt IVMUSBDevice *inUSBDevice);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Notes )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *virtualMachineNotes);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Notes )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR virtualMachineNotes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Memory )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__out long *megabytesOfMemory);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Memory )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ long megabytesOfMemory);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AttachedDriveTypes )( 
            __RPC__in IVMVirtualMachine * This,
            /* [retval][out] */ __RPC__out VARIANT *driveTypes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetConfigurationValue )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR configurationKey,
            /* [retval][out] */ __RPC__out VARIANT *configurationValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetConfigurationValue )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR configurationKey,
            /* [in] */ VARIANT configurationValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveConfigurationValue )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR configurationKey);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetActivationValue )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR activationKey,
            /* [retval][out] */ __RPC__out VARIANT *activationValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetActivationValue )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR activationKey,
            /* [in] */ VARIANT activationValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveActivationValue )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ __RPC__in BSTR activationKey);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StartCommunicationChannel )( 
            __RPC__in IVMVirtualMachine * This,
            /* [in] */ VMEndpointType inHostEndpointType,
            /* [in] */ __RPC__in BSTR inHostEndPointName,
            /* [in] */ VMEndpointType inGuestEndpointType,
            /* [in] */ __RPC__in BSTR inGuestEndpointName);
        
        END_INTERFACE
    } IVMVirtualMachineVtbl;

    interface IVMVirtualMachine
    {
        CONST_VTBL struct IVMVirtualMachineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMVirtualMachine_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMVirtualMachine_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMVirtualMachine_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMVirtualMachine_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMVirtualMachine_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMVirtualMachine_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMVirtualMachine_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMVirtualMachine_get_Name(This,virtualMachineName)	\
    ( (This)->lpVtbl -> get_Name(This,virtualMachineName) ) 

#define IVMVirtualMachine_put_Name(This,virtualMachineName)	\
    ( (This)->lpVtbl -> put_Name(This,virtualMachineName) ) 

#define IVMVirtualMachine_get_ConfigID(This,virtualMachineConfigID)	\
    ( (This)->lpVtbl -> get_ConfigID(This,virtualMachineConfigID) ) 

#define IVMVirtualMachine_get_File(This,virtualMachineXMLFile)	\
    ( (This)->lpVtbl -> get_File(This,virtualMachineXMLFile) ) 

#define IVMVirtualMachine_get_Accountant(This,accountant)	\
    ( (This)->lpVtbl -> get_Accountant(This,accountant) ) 

#define IVMVirtualMachine_get_GuestOS(This,guestOS)	\
    ( (This)->lpVtbl -> get_GuestOS(This,guestOS) ) 

#define IVMVirtualMachine_get_Display(This,display)	\
    ( (This)->lpVtbl -> get_Display(This,display) ) 

#define IVMVirtualMachine_get_Keyboard(This,keyboard)	\
    ( (This)->lpVtbl -> get_Keyboard(This,keyboard) ) 

#define IVMVirtualMachine_get_Mouse(This,mouse)	\
    ( (This)->lpVtbl -> get_Mouse(This,mouse) ) 

#define IVMVirtualMachine_Startup(This,startupTask)	\
    ( (This)->lpVtbl -> Startup(This,startupTask) ) 

#define IVMVirtualMachine_Startup2(This,startupOption,startupTask)	\
    ( (This)->lpVtbl -> Startup2(This,startupOption,startupTask) ) 

#define IVMVirtualMachine_TurnOff(This,turnOffTask)	\
    ( (This)->lpVtbl -> TurnOff(This,turnOffTask) ) 

#define IVMVirtualMachine_Save(This,saveTask)	\
    ( (This)->lpVtbl -> Save(This,saveTask) ) 

#define IVMVirtualMachine_Reset(This,resetTask)	\
    ( (This)->lpVtbl -> Reset(This,resetTask) ) 

#define IVMVirtualMachine_DiscardSavedState(This)	\
    ( (This)->lpVtbl -> DiscardSavedState(This) ) 

#define IVMVirtualMachine_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IVMVirtualMachine_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IVMVirtualMachine_get_State(This,virtualMachineState)	\
    ( (This)->lpVtbl -> get_State(This,virtualMachineState) ) 

#define IVMVirtualMachine_get_ShutdownActionOnQuit(This,shutdownAction)	\
    ( (This)->lpVtbl -> get_ShutdownActionOnQuit(This,shutdownAction) ) 

#define IVMVirtualMachine_put_ShutdownActionOnQuit(This,shutdownAction)	\
    ( (This)->lpVtbl -> put_ShutdownActionOnQuit(This,shutdownAction) ) 

#define IVMVirtualMachine_get_SavedStateFilePath(This,savedStateFilePath)	\
    ( (This)->lpVtbl -> get_SavedStateFilePath(This,savedStateFilePath) ) 

#define IVMVirtualMachine_get_BIOSGUID(This,biosGUID)	\
    ( (This)->lpVtbl -> get_BIOSGUID(This,biosGUID) ) 

#define IVMVirtualMachine_put_BIOSGUID(This,biosGUID)	\
    ( (This)->lpVtbl -> put_BIOSGUID(This,biosGUID) ) 

#define IVMVirtualMachine_get_BIOSSerialNumber(This,biosSerialNumber)	\
    ( (This)->lpVtbl -> get_BIOSSerialNumber(This,biosSerialNumber) ) 

#define IVMVirtualMachine_put_BIOSSerialNumber(This,biosSerialNumber)	\
    ( (This)->lpVtbl -> put_BIOSSerialNumber(This,biosSerialNumber) ) 

#define IVMVirtualMachine_get_BaseBoardSerialNumber(This,baseBoardSerialNumber)	\
    ( (This)->lpVtbl -> get_BaseBoardSerialNumber(This,baseBoardSerialNumber) ) 

#define IVMVirtualMachine_put_BaseBoardSerialNumber(This,baseBoardSerialNumber)	\
    ( (This)->lpVtbl -> put_BaseBoardSerialNumber(This,baseBoardSerialNumber) ) 

#define IVMVirtualMachine_get_ChassisSerialNumber(This,chassisSerialNumber)	\
    ( (This)->lpVtbl -> get_ChassisSerialNumber(This,chassisSerialNumber) ) 

#define IVMVirtualMachine_put_ChassisSerialNumber(This,chasisSerialNumber)	\
    ( (This)->lpVtbl -> put_ChassisSerialNumber(This,chasisSerialNumber) ) 

#define IVMVirtualMachine_get_ChassisAssetTag(This,chassisAssetTag)	\
    ( (This)->lpVtbl -> get_ChassisAssetTag(This,chassisAssetTag) ) 

#define IVMVirtualMachine_put_ChassisAssetTag(This,chassisAssetTag)	\
    ( (This)->lpVtbl -> put_ChassisAssetTag(This,chassisAssetTag) ) 

#define IVMVirtualMachine_AddHardDiskConnection(This,hardDiskPath,busNumber,deviceNumber,hardDiskConnection)	\
    ( (This)->lpVtbl -> AddHardDiskConnection(This,hardDiskPath,busNumber,deviceNumber,hardDiskConnection) ) 

#define IVMVirtualMachine_RemoveHardDiskConnection(This,hardDiskConnection)	\
    ( (This)->lpVtbl -> RemoveHardDiskConnection(This,hardDiskConnection) ) 

#define IVMVirtualMachine_get_HardDiskConnections(This,hardDiskConnectionCollection)	\
    ( (This)->lpVtbl -> get_HardDiskConnections(This,hardDiskConnectionCollection) ) 

#define IVMVirtualMachine_MergeUndoDisks(This,undoMergeTask)	\
    ( (This)->lpVtbl -> MergeUndoDisks(This,undoMergeTask) ) 

#define IVMVirtualMachine_DiscardUndoDisks(This)	\
    ( (This)->lpVtbl -> DiscardUndoDisks(This) ) 

#define IVMVirtualMachine_get_Undoable(This,isUndoable)	\
    ( (This)->lpVtbl -> get_Undoable(This,isUndoable) ) 

#define IVMVirtualMachine_put_Undoable(This,enableUndo)	\
    ( (This)->lpVtbl -> put_Undoable(This,enableUndo) ) 

#define IVMVirtualMachine_get_UndoAction(This,undoAction)	\
    ( (This)->lpVtbl -> get_UndoAction(This,undoAction) ) 

#define IVMVirtualMachine_put_UndoAction(This,undoAction)	\
    ( (This)->lpVtbl -> put_UndoAction(This,undoAction) ) 

#define IVMVirtualMachine_AddDVDROMDrive(This,busNumber,deviceNumber,dvdDrive)	\
    ( (This)->lpVtbl -> AddDVDROMDrive(This,busNumber,deviceNumber,dvdDrive) ) 

#define IVMVirtualMachine_RemoveDVDROMDrive(This,dvdDrive)	\
    ( (This)->lpVtbl -> RemoveDVDROMDrive(This,dvdDrive) ) 

#define IVMVirtualMachine_get_DVDROMDrives(This,dvdROMCollection)	\
    ( (This)->lpVtbl -> get_DVDROMDrives(This,dvdROMCollection) ) 

#define IVMVirtualMachine_get_FloppyDrives(This,floppyCollection)	\
    ( (This)->lpVtbl -> get_FloppyDrives(This,floppyCollection) ) 

#define IVMVirtualMachine_AddNetworkAdapter(This,networkAdapter)	\
    ( (This)->lpVtbl -> AddNetworkAdapter(This,networkAdapter) ) 

#define IVMVirtualMachine_RemoveNetworkAdapter(This,networkAdapter)	\
    ( (This)->lpVtbl -> RemoveNetworkAdapter(This,networkAdapter) ) 

#define IVMVirtualMachine_get_NetworkAdapters(This,networkAdapterCollection)	\
    ( (This)->lpVtbl -> get_NetworkAdapters(This,networkAdapterCollection) ) 

#define IVMVirtualMachine_get_SerialPorts(This,serialPortCollection)	\
    ( (This)->lpVtbl -> get_SerialPorts(This,serialPortCollection) ) 

#define IVMVirtualMachine_get_ParallelPorts(This,parallelPortCollection)	\
    ( (This)->lpVtbl -> get_ParallelPorts(This,parallelPortCollection) ) 

#define IVMVirtualMachine_get_ProcessorSpeed(This,processorSpeed)	\
    ( (This)->lpVtbl -> get_ProcessorSpeed(This,processorSpeed) ) 

#define IVMVirtualMachine_get_HasMMX(This,mmxEnabled)	\
    ( (This)->lpVtbl -> get_HasMMX(This,mmxEnabled) ) 

#define IVMVirtualMachine_get_HasSSE(This,sseEnabled)	\
    ( (This)->lpVtbl -> get_HasSSE(This,sseEnabled) ) 

#define IVMVirtualMachine_get_HasSSE2(This,sse2Enabled)	\
    ( (This)->lpVtbl -> get_HasSSE2(This,sse2Enabled) ) 

#define IVMVirtualMachine_get_Has3DNow(This,threeDNowEnabled)	\
    ( (This)->lpVtbl -> get_Has3DNow(This,threeDNowEnabled) ) 

#define IVMVirtualMachine_get_RdpPipeName(This,RdpPipeName)	\
    ( (This)->lpVtbl -> get_RdpPipeName(This,RdpPipeName) ) 

#define IVMVirtualMachine_AttachUSBDevice(This,inUSBDevice)	\
    ( (This)->lpVtbl -> AttachUSBDevice(This,inUSBDevice) ) 

#define IVMVirtualMachine_DetachUSBDevice(This,inUSBDevice)	\
    ( (This)->lpVtbl -> DetachUSBDevice(This,inUSBDevice) ) 

#define IVMVirtualMachine_get_Notes(This,virtualMachineNotes)	\
    ( (This)->lpVtbl -> get_Notes(This,virtualMachineNotes) ) 

#define IVMVirtualMachine_put_Notes(This,virtualMachineNotes)	\
    ( (This)->lpVtbl -> put_Notes(This,virtualMachineNotes) ) 

#define IVMVirtualMachine_get_Memory(This,megabytesOfMemory)	\
    ( (This)->lpVtbl -> get_Memory(This,megabytesOfMemory) ) 

#define IVMVirtualMachine_put_Memory(This,megabytesOfMemory)	\
    ( (This)->lpVtbl -> put_Memory(This,megabytesOfMemory) ) 

#define IVMVirtualMachine_get_AttachedDriveTypes(This,driveTypes)	\
    ( (This)->lpVtbl -> get_AttachedDriveTypes(This,driveTypes) ) 

#define IVMVirtualMachine_GetConfigurationValue(This,configurationKey,configurationValue)	\
    ( (This)->lpVtbl -> GetConfigurationValue(This,configurationKey,configurationValue) ) 

#define IVMVirtualMachine_SetConfigurationValue(This,configurationKey,configurationValue)	\
    ( (This)->lpVtbl -> SetConfigurationValue(This,configurationKey,configurationValue) ) 

#define IVMVirtualMachine_RemoveConfigurationValue(This,configurationKey)	\
    ( (This)->lpVtbl -> RemoveConfigurationValue(This,configurationKey) ) 

#define IVMVirtualMachine_GetActivationValue(This,activationKey,activationValue)	\
    ( (This)->lpVtbl -> GetActivationValue(This,activationKey,activationValue) ) 

#define IVMVirtualMachine_SetActivationValue(This,activationKey,activationValue)	\
    ( (This)->lpVtbl -> SetActivationValue(This,activationKey,activationValue) ) 

#define IVMVirtualMachine_RemoveActivationValue(This,activationKey)	\
    ( (This)->lpVtbl -> RemoveActivationValue(This,activationKey) ) 

#define IVMVirtualMachine_StartCommunicationChannel(This,inHostEndpointType,inHostEndPointName,inGuestEndpointType,inGuestEndpointName)	\
    ( (This)->lpVtbl -> StartCommunicationChannel(This,inHostEndpointType,inHostEndPointName,inGuestEndpointType,inGuestEndpointName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMVirtualMachine_INTERFACE_DEFINED__ */


#ifndef __IVMVirtualMachineEvents_DISPINTERFACE_DEFINED__
#define __IVMVirtualMachineEvents_DISPINTERFACE_DEFINED__

/* dispinterface IVMVirtualMachineEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_IVMVirtualMachineEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("9d84f560-bb67-4961-bd12-a4da780c67e4")
    IVMVirtualMachineEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IVMVirtualMachineEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMVirtualMachineEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMVirtualMachineEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMVirtualMachineEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMVirtualMachineEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMVirtualMachineEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMVirtualMachineEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMVirtualMachineEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IVMVirtualMachineEventsVtbl;

    interface IVMVirtualMachineEvents
    {
        CONST_VTBL struct IVMVirtualMachineEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMVirtualMachineEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMVirtualMachineEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMVirtualMachineEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMVirtualMachineEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMVirtualMachineEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMVirtualMachineEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMVirtualMachineEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IVMVirtualMachineEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IVMVirtualMachineCollection_INTERFACE_DEFINED__
#define __IVMVirtualMachineCollection_INTERFACE_DEFINED__

/* interface IVMVirtualMachineCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMVirtualMachineCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59f31786-2a3d-4fbf-9896-d85338ca0da1")
    IVMVirtualMachineCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualMachine **virtualMachine) = 0;
        
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMVirtualMachineCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMVirtualMachineCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMVirtualMachineCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMVirtualMachineCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMVirtualMachineCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMVirtualMachineCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMVirtualMachineCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMVirtualMachineCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IVMVirtualMachineCollection * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IVMVirtualMachineCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualMachine **virtualMachine);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IVMVirtualMachineCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator);
        
        END_INTERFACE
    } IVMVirtualMachineCollectionVtbl;

    interface IVMVirtualMachineCollection
    {
        CONST_VTBL struct IVMVirtualMachineCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMVirtualMachineCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMVirtualMachineCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMVirtualMachineCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMVirtualMachineCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMVirtualMachineCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMVirtualMachineCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMVirtualMachineCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMVirtualMachineCollection_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IVMVirtualMachineCollection_get_Item(This,index,virtualMachine)	\
    ( (This)->lpVtbl -> get_Item(This,index,virtualMachine) ) 

#define IVMVirtualMachineCollection_get__NewEnum(This,enumerator)	\
    ( (This)->lpVtbl -> get__NewEnum(This,enumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMVirtualMachineCollection_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_VMVirtualMachine;

#ifdef __cplusplus

class DECLSPEC_UUID("83c47dfc-aaeb-4718-9b52-ec74161ebc3d")
VMVirtualMachine;
#endif

#ifndef __IVMSupportDriver_INTERFACE_DEFINED__
#define __IVMSupportDriver_INTERFACE_DEFINED__

/* interface IVMSupportDriver */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMSupportDriver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48be8c61-631e-404b-9984-2b051023511a")
    IVMSupportDriver : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__out VMSupportDriverType *driverType) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Manufacturer( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *manufacturer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Provider( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *provider) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *version) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Date( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *date) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMSupportDriverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMSupportDriver * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMSupportDriver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMSupportDriver * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMSupportDriver * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMSupportDriver * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMSupportDriver * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMSupportDriver * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in IVMSupportDriver * This,
            /* [retval][out] */ __RPC__out VMSupportDriverType *driverType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IVMSupportDriver * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Manufacturer )( 
            __RPC__in IVMSupportDriver * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *manufacturer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Provider )( 
            __RPC__in IVMSupportDriver * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *provider);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            __RPC__in IVMSupportDriver * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *version);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Date )( 
            __RPC__in IVMSupportDriver * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *date);
        
        END_INTERFACE
    } IVMSupportDriverVtbl;

    interface IVMSupportDriver
    {
        CONST_VTBL struct IVMSupportDriverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMSupportDriver_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMSupportDriver_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMSupportDriver_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMSupportDriver_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMSupportDriver_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMSupportDriver_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMSupportDriver_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMSupportDriver_get_Type(This,driverType)	\
    ( (This)->lpVtbl -> get_Type(This,driverType) ) 

#define IVMSupportDriver_get_Description(This,description)	\
    ( (This)->lpVtbl -> get_Description(This,description) ) 

#define IVMSupportDriver_get_Manufacturer(This,manufacturer)	\
    ( (This)->lpVtbl -> get_Manufacturer(This,manufacturer) ) 

#define IVMSupportDriver_get_Provider(This,provider)	\
    ( (This)->lpVtbl -> get_Provider(This,provider) ) 

#define IVMSupportDriver_get_Version(This,version)	\
    ( (This)->lpVtbl -> get_Version(This,version) ) 

#define IVMSupportDriver_get_Date(This,date)	\
    ( (This)->lpVtbl -> get_Date(This,date) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMSupportDriver_INTERFACE_DEFINED__ */


#ifndef __IVMSupportDriverCollection_INTERFACE_DEFINED__
#define __IVMSupportDriverCollection_INTERFACE_DEFINED__

/* interface IVMSupportDriverCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMSupportDriverCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67f454f1-a69b-4271-953d-ab99e2458650")
    IVMSupportDriverCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMSupportDriver **supportDriver) = 0;
        
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMSupportDriverCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMSupportDriverCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMSupportDriverCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMSupportDriverCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMSupportDriverCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMSupportDriverCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMSupportDriverCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMSupportDriverCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IVMSupportDriverCollection * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IVMSupportDriverCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMSupportDriver **supportDriver);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IVMSupportDriverCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator);
        
        END_INTERFACE
    } IVMSupportDriverCollectionVtbl;

    interface IVMSupportDriverCollection
    {
        CONST_VTBL struct IVMSupportDriverCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMSupportDriverCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMSupportDriverCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMSupportDriverCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMSupportDriverCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMSupportDriverCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMSupportDriverCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMSupportDriverCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMSupportDriverCollection_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IVMSupportDriverCollection_get_Item(This,index,supportDriver)	\
    ( (This)->lpVtbl -> get_Item(This,index,supportDriver) ) 

#define IVMSupportDriverCollection_get__NewEnum(This,enumerator)	\
    ( (This)->lpVtbl -> get__NewEnum(This,enumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMSupportDriverCollection_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_VMSupportDriver;

#ifdef __cplusplus

class DECLSPEC_UUID("430985a9-5fec-45f3-8fd3-d9e111d36fc2")
VMSupportDriver;
#endif

#ifndef __IVMHostInfo_INTERFACE_DEFINED__
#define __IVMHostInfo_INTERFACE_DEFINED__

/* interface IVMHostInfo */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMHostInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5b5cf343-05ad-453b-be99-adf4e27b2ebc")
    IVMHostInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LogicalProcessorCount( 
            /* [retval][out] */ __RPC__out long *processorCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PhysicalProcessorCount( 
            /* [retval][out] */ __RPC__out long *processorCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProcessorSpeed( 
            /* [retval][out] */ __RPC__out long *processorSpeed) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProcessorSpeedString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *processorSpeedString) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProcessorManufacturerString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *processorManufacturerString) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProcessorVersionString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *processorVersionString) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProcessorFeaturesString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *featuresString) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MMX( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *mmxEnabled) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SSE( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *sseEnabled) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SSE2( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *sse2Enabled) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ThreeDNow( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *threeDNowEnabled) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Memory( 
            /* [retval][out] */ __RPC__out VARIANT *megabytesOfMemory) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MemoryTotalString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *megabytesOfMemory) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MemoryAvail( 
            /* [retval][out] */ __RPC__out VARIANT *megabytesOfMemory) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MemoryAvailString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *megabytesOfMemory) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OperatingSystem( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *operatingSystem) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OSVersionString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *OSVersion) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OSMajorVersion( 
            /* [retval][out] */ __RPC__out long *osMajorVersion) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OSMinorVersion( 
            /* [retval][out] */ __RPC__out long *osMinorVersion) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OSServicePackString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *OSServicePack) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkAdapters( 
            /* [retval][out] */ __RPC__out VARIANT *hostNICs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkAddresses( 
            /* [retval][out] */ __RPC__out VARIANT *hostAddresses) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DVDDrives( 
            /* [retval][out] */ __RPC__out VARIANT *DVDDrives) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FloppyDrives( 
            /* [retval][out] */ __RPC__out VARIANT *floppyDrives) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SerialPorts( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *serialPorts) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ParallelPort( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *vmParallelPort) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UTCTime( 
            /* [retval][out] */ __RPC__out DATE *UTCTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMHostInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMHostInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMHostInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMHostInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMHostInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMHostInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMHostInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMHostInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogicalProcessorCount )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out long *processorCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PhysicalProcessorCount )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out long *processorCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProcessorSpeed )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out long *processorSpeed);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProcessorSpeedString )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *processorSpeedString);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProcessorManufacturerString )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *processorManufacturerString);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProcessorVersionString )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *processorVersionString);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProcessorFeaturesString )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *featuresString);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MMX )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *mmxEnabled);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SSE )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *sseEnabled);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SSE2 )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *sse2Enabled);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ThreeDNow )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *threeDNowEnabled);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Memory )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out VARIANT *megabytesOfMemory);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemoryTotalString )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *megabytesOfMemory);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemoryAvail )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out VARIANT *megabytesOfMemory);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemoryAvailString )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *megabytesOfMemory);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OperatingSystem )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *operatingSystem);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSVersionString )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *OSVersion);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSMajorVersion )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out long *osMajorVersion);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSMinorVersion )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out long *osMinorVersion);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSServicePackString )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *OSServicePack);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkAdapters )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out VARIANT *hostNICs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkAddresses )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out VARIANT *hostAddresses);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DVDDrives )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out VARIANT *DVDDrives);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FloppyDrives )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out VARIANT *floppyDrives);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SerialPorts )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *serialPorts);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParallelPort )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *vmParallelPort);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UTCTime )( 
            __RPC__in IVMHostInfo * This,
            /* [retval][out] */ __RPC__out DATE *UTCTime);
        
        END_INTERFACE
    } IVMHostInfoVtbl;

    interface IVMHostInfo
    {
        CONST_VTBL struct IVMHostInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMHostInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMHostInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMHostInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMHostInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMHostInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMHostInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMHostInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMHostInfo_get_LogicalProcessorCount(This,processorCount)	\
    ( (This)->lpVtbl -> get_LogicalProcessorCount(This,processorCount) ) 

#define IVMHostInfo_get_PhysicalProcessorCount(This,processorCount)	\
    ( (This)->lpVtbl -> get_PhysicalProcessorCount(This,processorCount) ) 

#define IVMHostInfo_get_ProcessorSpeed(This,processorSpeed)	\
    ( (This)->lpVtbl -> get_ProcessorSpeed(This,processorSpeed) ) 

#define IVMHostInfo_get_ProcessorSpeedString(This,processorSpeedString)	\
    ( (This)->lpVtbl -> get_ProcessorSpeedString(This,processorSpeedString) ) 

#define IVMHostInfo_get_ProcessorManufacturerString(This,processorManufacturerString)	\
    ( (This)->lpVtbl -> get_ProcessorManufacturerString(This,processorManufacturerString) ) 

#define IVMHostInfo_get_ProcessorVersionString(This,processorVersionString)	\
    ( (This)->lpVtbl -> get_ProcessorVersionString(This,processorVersionString) ) 

#define IVMHostInfo_get_ProcessorFeaturesString(This,featuresString)	\
    ( (This)->lpVtbl -> get_ProcessorFeaturesString(This,featuresString) ) 

#define IVMHostInfo_get_MMX(This,mmxEnabled)	\
    ( (This)->lpVtbl -> get_MMX(This,mmxEnabled) ) 

#define IVMHostInfo_get_SSE(This,sseEnabled)	\
    ( (This)->lpVtbl -> get_SSE(This,sseEnabled) ) 

#define IVMHostInfo_get_SSE2(This,sse2Enabled)	\
    ( (This)->lpVtbl -> get_SSE2(This,sse2Enabled) ) 

#define IVMHostInfo_get_ThreeDNow(This,threeDNowEnabled)	\
    ( (This)->lpVtbl -> get_ThreeDNow(This,threeDNowEnabled) ) 

#define IVMHostInfo_get_Memory(This,megabytesOfMemory)	\
    ( (This)->lpVtbl -> get_Memory(This,megabytesOfMemory) ) 

#define IVMHostInfo_get_MemoryTotalString(This,megabytesOfMemory)	\
    ( (This)->lpVtbl -> get_MemoryTotalString(This,megabytesOfMemory) ) 

#define IVMHostInfo_get_MemoryAvail(This,megabytesOfMemory)	\
    ( (This)->lpVtbl -> get_MemoryAvail(This,megabytesOfMemory) ) 

#define IVMHostInfo_get_MemoryAvailString(This,megabytesOfMemory)	\
    ( (This)->lpVtbl -> get_MemoryAvailString(This,megabytesOfMemory) ) 

#define IVMHostInfo_get_OperatingSystem(This,operatingSystem)	\
    ( (This)->lpVtbl -> get_OperatingSystem(This,operatingSystem) ) 

#define IVMHostInfo_get_OSVersionString(This,OSVersion)	\
    ( (This)->lpVtbl -> get_OSVersionString(This,OSVersion) ) 

#define IVMHostInfo_get_OSMajorVersion(This,osMajorVersion)	\
    ( (This)->lpVtbl -> get_OSMajorVersion(This,osMajorVersion) ) 

#define IVMHostInfo_get_OSMinorVersion(This,osMinorVersion)	\
    ( (This)->lpVtbl -> get_OSMinorVersion(This,osMinorVersion) ) 

#define IVMHostInfo_get_OSServicePackString(This,OSServicePack)	\
    ( (This)->lpVtbl -> get_OSServicePackString(This,OSServicePack) ) 

#define IVMHostInfo_get_NetworkAdapters(This,hostNICs)	\
    ( (This)->lpVtbl -> get_NetworkAdapters(This,hostNICs) ) 

#define IVMHostInfo_get_NetworkAddresses(This,hostAddresses)	\
    ( (This)->lpVtbl -> get_NetworkAddresses(This,hostAddresses) ) 

#define IVMHostInfo_get_DVDDrives(This,DVDDrives)	\
    ( (This)->lpVtbl -> get_DVDDrives(This,DVDDrives) ) 

#define IVMHostInfo_get_FloppyDrives(This,floppyDrives)	\
    ( (This)->lpVtbl -> get_FloppyDrives(This,floppyDrives) ) 

#define IVMHostInfo_get_SerialPorts(This,serialPorts)	\
    ( (This)->lpVtbl -> get_SerialPorts(This,serialPorts) ) 

#define IVMHostInfo_get_ParallelPort(This,vmParallelPort)	\
    ( (This)->lpVtbl -> get_ParallelPort(This,vmParallelPort) ) 

#define IVMHostInfo_get_UTCTime(This,UTCTime)	\
    ( (This)->lpVtbl -> get_UTCTime(This,UTCTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMHostInfo_INTERFACE_DEFINED__ */


#ifndef __IVMVirtualNetworkCollection_INTERFACE_DEFINED__
#define __IVMVirtualNetworkCollection_INTERFACE_DEFINED__

/* interface IVMVirtualNetworkCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMVirtualNetworkCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8ed680be-4242-4b2a-a21c-1982d8b0f675")
    IVMVirtualNetworkCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualNetwork **virtualNetwork) = 0;
        
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMVirtualNetworkCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMVirtualNetworkCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMVirtualNetworkCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMVirtualNetworkCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMVirtualNetworkCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMVirtualNetworkCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMVirtualNetworkCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMVirtualNetworkCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IVMVirtualNetworkCollection * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IVMVirtualNetworkCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualNetwork **virtualNetwork);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IVMVirtualNetworkCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator);
        
        END_INTERFACE
    } IVMVirtualNetworkCollectionVtbl;

    interface IVMVirtualNetworkCollection
    {
        CONST_VTBL struct IVMVirtualNetworkCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMVirtualNetworkCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMVirtualNetworkCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMVirtualNetworkCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMVirtualNetworkCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMVirtualNetworkCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMVirtualNetworkCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMVirtualNetworkCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMVirtualNetworkCollection_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IVMVirtualNetworkCollection_get_Item(This,index,virtualNetwork)	\
    ( (This)->lpVtbl -> get_Item(This,index,virtualNetwork) ) 

#define IVMVirtualNetworkCollection_get__NewEnum(This,enumerator)	\
    ( (This)->lpVtbl -> get__NewEnum(This,enumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMVirtualNetworkCollection_INTERFACE_DEFINED__ */


#ifndef __IVMVirtualNetwork_INTERFACE_DEFINED__
#define __IVMVirtualNetwork_INTERFACE_DEFINED__

/* interface IVMVirtualNetwork */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMVirtualNetwork;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("431cb7a1-2469-4563-b94e-38b987adca63")
    IVMVirtualNetwork : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][hidden] */ HRESULT STDMETHODCALLTYPE _ID( 
            /* [out] */ __RPC__out VARIANT *virtualNetworkID) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *virtualNetworkName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isWireless) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostAdapter( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *hostAdapter) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkAdapters( 
            /* [retval][out] */ __RPC__deref_out_opt IVMNetworkAdapterCollection **networkInterfaceCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMVirtualNetworkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMVirtualNetwork * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMVirtualNetwork * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMVirtualNetwork * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMVirtualNetwork * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMVirtualNetwork * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMVirtualNetwork * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMVirtualNetwork * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *_ID )( 
            __RPC__in IVMVirtualNetwork * This,
            /* [out] */ __RPC__out VARIANT *virtualNetworkID);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IVMVirtualNetwork * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *virtualNetworkName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            __RPC__in IVMVirtualNetwork * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isWireless);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostAdapter )( 
            __RPC__in IVMVirtualNetwork * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *hostAdapter);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkAdapters )( 
            __RPC__in IVMVirtualNetwork * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMNetworkAdapterCollection **networkInterfaceCollection);
        
        END_INTERFACE
    } IVMVirtualNetworkVtbl;

    interface IVMVirtualNetwork
    {
        CONST_VTBL struct IVMVirtualNetworkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMVirtualNetwork_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMVirtualNetwork_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMVirtualNetwork_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMVirtualNetwork_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMVirtualNetwork_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMVirtualNetwork_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMVirtualNetwork_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMVirtualNetwork__ID(This,virtualNetworkID)	\
    ( (This)->lpVtbl -> _ID(This,virtualNetworkID) ) 

#define IVMVirtualNetwork_get_Name(This,virtualNetworkName)	\
    ( (This)->lpVtbl -> get_Name(This,virtualNetworkName) ) 

#define IVMVirtualNetwork_get_MediaType(This,isWireless)	\
    ( (This)->lpVtbl -> get_MediaType(This,isWireless) ) 

#define IVMVirtualNetwork_get_HostAdapter(This,hostAdapter)	\
    ( (This)->lpVtbl -> get_HostAdapter(This,hostAdapter) ) 

#define IVMVirtualNetwork_get_NetworkAdapters(This,networkInterfaceCollection)	\
    ( (This)->lpVtbl -> get_NetworkAdapters(This,networkInterfaceCollection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMVirtualNetwork_INTERFACE_DEFINED__ */


#ifndef __IVMHardDisk_INTERFACE_DEFINED__
#define __IVMHardDisk_INTERFACE_DEFINED__

/* interface IVMHardDisk */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMHardDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ffa14ae6-48f5-42a4-8a22-186f2e5c7db0")
    IVMHardDisk : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Merge( 
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **mergeTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MergeTo( 
            /* [in] */ __RPC__in BSTR newDiskImagePath,
            /* [in] */ VMHardDiskType newDiskImageType,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **mergeTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Compact( 
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **compactTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Convert( 
            /* [in] */ __RPC__in BSTR convertedDiskImagePath,
            /* [in] */ VMHardDiskType convertedDiskImageType,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **convertTask) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_File( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *hardDiskfile) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__out VMHardDiskType *type) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SizeInGuest( 
            /* [retval][out] */ __RPC__out VARIANT *fileSize) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SizeOnHost( 
            /* [retval][out] */ __RPC__out VARIANT *fileSize) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostFreeDiskSpace( 
            /* [retval][out] */ __RPC__out VARIANT *freeBytes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDisk **parent) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Parent( 
            /* [in] */ __RPC__in_opt IVMHardDisk *parent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMHardDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMHardDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMHardDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMHardDisk * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMHardDisk * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMHardDisk * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMHardDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMHardDisk * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Merge )( 
            __RPC__in IVMHardDisk * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **mergeTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MergeTo )( 
            __RPC__in IVMHardDisk * This,
            /* [in] */ __RPC__in BSTR newDiskImagePath,
            /* [in] */ VMHardDiskType newDiskImageType,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **mergeTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Compact )( 
            __RPC__in IVMHardDisk * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **compactTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Convert )( 
            __RPC__in IVMHardDisk * This,
            /* [in] */ __RPC__in BSTR convertedDiskImagePath,
            /* [in] */ VMHardDiskType convertedDiskImageType,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **convertTask);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_File )( 
            __RPC__in IVMHardDisk * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *hardDiskfile);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in IVMHardDisk * This,
            /* [retval][out] */ __RPC__out VMHardDiskType *type);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeInGuest )( 
            __RPC__in IVMHardDisk * This,
            /* [retval][out] */ __RPC__out VARIANT *fileSize);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeOnHost )( 
            __RPC__in IVMHardDisk * This,
            /* [retval][out] */ __RPC__out VARIANT *fileSize);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostFreeDiskSpace )( 
            __RPC__in IVMHardDisk * This,
            /* [retval][out] */ __RPC__out VARIANT *freeBytes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            __RPC__in IVMHardDisk * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDisk **parent);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Parent )( 
            __RPC__in IVMHardDisk * This,
            /* [in] */ __RPC__in_opt IVMHardDisk *parent);
        
        END_INTERFACE
    } IVMHardDiskVtbl;

    interface IVMHardDisk
    {
        CONST_VTBL struct IVMHardDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMHardDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMHardDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMHardDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMHardDisk_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMHardDisk_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMHardDisk_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMHardDisk_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMHardDisk_Merge(This,mergeTask)	\
    ( (This)->lpVtbl -> Merge(This,mergeTask) ) 

#define IVMHardDisk_MergeTo(This,newDiskImagePath,newDiskImageType,mergeTask)	\
    ( (This)->lpVtbl -> MergeTo(This,newDiskImagePath,newDiskImageType,mergeTask) ) 

#define IVMHardDisk_Compact(This,compactTask)	\
    ( (This)->lpVtbl -> Compact(This,compactTask) ) 

#define IVMHardDisk_Convert(This,convertedDiskImagePath,convertedDiskImageType,convertTask)	\
    ( (This)->lpVtbl -> Convert(This,convertedDiskImagePath,convertedDiskImageType,convertTask) ) 

#define IVMHardDisk_get_File(This,hardDiskfile)	\
    ( (This)->lpVtbl -> get_File(This,hardDiskfile) ) 

#define IVMHardDisk_get_Type(This,type)	\
    ( (This)->lpVtbl -> get_Type(This,type) ) 

#define IVMHardDisk_get_SizeInGuest(This,fileSize)	\
    ( (This)->lpVtbl -> get_SizeInGuest(This,fileSize) ) 

#define IVMHardDisk_get_SizeOnHost(This,fileSize)	\
    ( (This)->lpVtbl -> get_SizeOnHost(This,fileSize) ) 

#define IVMHardDisk_get_HostFreeDiskSpace(This,freeBytes)	\
    ( (This)->lpVtbl -> get_HostFreeDiskSpace(This,freeBytes) ) 

#define IVMHardDisk_get_Parent(This,parent)	\
    ( (This)->lpVtbl -> get_Parent(This,parent) ) 

#define IVMHardDisk_put_Parent(This,parent)	\
    ( (This)->lpVtbl -> put_Parent(This,parent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMHardDisk_INTERFACE_DEFINED__ */


#ifndef __IVMTaskCollection_INTERFACE_DEFINED__
#define __IVMTaskCollection_INTERFACE_DEFINED__

/* interface IVMTaskCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMTaskCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5c4387c8-0e8b-4b97-8058-84679adf4c40")
    IVMTaskCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **task) = 0;
        
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMTaskCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMTaskCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMTaskCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMTaskCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMTaskCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMTaskCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMTaskCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMTaskCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IVMTaskCollection * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IVMTaskCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **task);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IVMTaskCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **enumerator);
        
        END_INTERFACE
    } IVMTaskCollectionVtbl;

    interface IVMTaskCollection
    {
        CONST_VTBL struct IVMTaskCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMTaskCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMTaskCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMTaskCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMTaskCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMTaskCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMTaskCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMTaskCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMTaskCollection_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IVMTaskCollection_get_Item(This,index,task)	\
    ( (This)->lpVtbl -> get_Item(This,index,task) ) 

#define IVMTaskCollection_get__NewEnum(This,enumerator)	\
    ( (This)->lpVtbl -> get__NewEnum(This,enumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMTaskCollection_INTERFACE_DEFINED__ */


#ifndef __IVMVirtualPC_INTERFACE_DEFINED__
#define __IVMVirtualPC_INTERFACE_DEFINED__

/* interface IVMVirtualPC */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVMVirtualPC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("236ba0d9-a24a-4292-a132-27c1421dfd01")
    IVMVirtualPC : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostInfo( 
            /* [retval][out] */ __RPC__deref_out_opt IVMHostInfo **hostInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindVirtualMachine( 
            /* [in] */ __RPC__in BSTR configurationName,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualMachine **virtualMachine) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateVirtualMachine( 
            /* [in] */ __RPC__in BSTR configurationName,
            /* [in] */ __RPC__in BSTR configurationPath,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualMachine **virtualMachine) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteVirtualMachine( 
            /* [in] */ __RPC__in_opt IVMVirtualMachine *virtualMachine) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterVirtualMachine( 
            /* [in] */ __RPC__in BSTR configurationName,
            /* [in] */ __RPC__in BSTR configurationPath,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualMachine **virtualMachine) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterVirtualMachine( 
            /* [in] */ __RPC__in_opt IVMVirtualMachine *virtualMachine) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_VirtualMachines( 
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualMachineCollection **virtualMachineCollection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindVirtualNetwork( 
            /* [in] */ __RPC__in BSTR virtualNetworkName,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualNetwork **virtualNetwork) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_VirtualNetworks( 
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualNetworkCollection **virtualNetworkCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UnconnectedNetworkAdapters( 
            /* [retval][out] */ __RPC__deref_out_opt IVMNetworkAdapterCollection **unconnectedNetworkAdapterCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SupportDrivers( 
            /* [retval][out] */ __RPC__deref_out_opt IVMSupportDriverCollection **supportDriverCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Tasks( 
            /* [retval][out] */ __RPC__deref_out_opt IVMTaskCollection **taskCollection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateDynamicVirtualHardDisk( 
            /* [in] */ __RPC__in BSTR imagePath,
            /* [in] */ long size,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **diskTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateFixedVirtualHardDisk( 
            /* [in] */ __RPC__in BSTR imagePath,
            /* [in] */ long size,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **diskTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateDifferencingVirtualHardDisk( 
            /* [in] */ __RPC__in BSTR imagePath,
            /* [in] */ __RPC__in BSTR parentPath,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **diskTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHardDisk( 
            /* [in] */ __RPC__in BSTR imagePath,
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDisk **hardDisk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateFloppyDiskImage( 
            /* [in] */ __RPC__in BSTR imagePath,
            /* [in] */ VMFloppyDiskImageType imageType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFloppyDiskImageType( 
            /* [in] */ __RPC__in BSTR imagePath,
            /* [retval][out] */ __RPC__out VMFloppyDiskImageType *imageType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetConfigurationValue( 
            /* [in] */ __RPC__in BSTR preferenceKey,
            /* [retval][out] */ __RPC__out VARIANT *preferenceValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetConfigurationValue( 
            /* [in] */ __RPC__in BSTR preferenceKey,
            /* [in] */ VARIANT preferenceValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveConfigurationValue( 
            /* [in] */ __RPC__in BSTR preferenceKey) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MinimumMemoryPerVM( 
            /* [retval][out] */ __RPC__out long *megabytesOfMemory) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaximumMemoryPerVM( 
            /* [retval][out] */ __RPC__out long *megabytesOfMemory) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SuggestedMaximumMemoryPerVM( 
            /* [retval][out] */ __RPC__out long *megabytesOfMemory) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaximumFloppyDrivesPerVM( 
            /* [retval][out] */ __RPC__out long *maxDrives) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaximumSerialPortsPerVM( 
            /* [retval][out] */ __RPC__out long *maxPorts) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaximumParallelPortsPerVM( 
            /* [retval][out] */ __RPC__out long *maxPorts) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaximumNetworkAdaptersPerVM( 
            /* [retval][out] */ __RPC__out long *maxNetworkAdapters) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaximumNumberOfIDEBuses( 
            /* [retval][out] */ __RPC__out long *maxNumBuses) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultVMConfigurationPath( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *configurationPath) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultVMConfigurationPath( 
            /* [in] */ __RPC__in BSTR configurationPath) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPaths( 
            /* [retval][out] */ __RPC__out VARIANT *searchPaths) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_SearchPaths( 
            /* [in] */ VARIANT searchPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHardDiskFiles( 
            /* [in] */ VARIANT inAdditionalSearchPaths,
            /* [retval][out] */ __RPC__out VARIANT *outHardDiskFileList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVirtualMachineFiles( 
            /* [in] */ VARIANT inAdditionalSearchPaths,
            /* [in] */ VARIANT_BOOL inExcludedRegisteredVMs,
            /* [retval][out] */ __RPC__out VARIANT *outVirtualMachineFileList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFloppyDiskFiles( 
            /* [in] */ VARIANT inAdditionalSearchPaths,
            /* [retval][out] */ __RPC__out VARIANT *outFloppyDiskFileList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDVDFiles( 
            /* [in] */ VARIANT inAdditionalSearchPaths,
            /* [retval][out] */ __RPC__out VARIANT *outDVDFileList) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_USBDeviceCollection( 
            /* [retval][out] */ __RPC__deref_out_opt IVMUSBDeviceCollection **usbDeviceCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *virtualPCName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *version) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UpTime( 
            /* [retval][out] */ __RPC__out long *secondsAlive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMVirtualPCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMVirtualPC * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMVirtualPC * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMVirtualPC * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMVirtualPC * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostInfo )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMHostInfo **hostInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindVirtualMachine )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR configurationName,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualMachine **virtualMachine);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateVirtualMachine )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR configurationName,
            /* [in] */ __RPC__in BSTR configurationPath,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualMachine **virtualMachine);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteVirtualMachine )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in_opt IVMVirtualMachine *virtualMachine);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterVirtualMachine )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR configurationName,
            /* [in] */ __RPC__in BSTR configurationPath,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualMachine **virtualMachine);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterVirtualMachine )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in_opt IVMVirtualMachine *virtualMachine);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VirtualMachines )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualMachineCollection **virtualMachineCollection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindVirtualNetwork )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR virtualNetworkName,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualNetwork **virtualNetwork);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VirtualNetworks )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMVirtualNetworkCollection **virtualNetworkCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UnconnectedNetworkAdapters )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMNetworkAdapterCollection **unconnectedNetworkAdapterCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportDrivers )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMSupportDriverCollection **supportDriverCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tasks )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMTaskCollection **taskCollection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateDynamicVirtualHardDisk )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR imagePath,
            /* [in] */ long size,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **diskTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateFixedVirtualHardDisk )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR imagePath,
            /* [in] */ long size,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **diskTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateDifferencingVirtualHardDisk )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR imagePath,
            /* [in] */ __RPC__in BSTR parentPath,
            /* [retval][out] */ __RPC__deref_out_opt IVMTask **diskTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetHardDisk )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR imagePath,
            /* [retval][out] */ __RPC__deref_out_opt IVMHardDisk **hardDisk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateFloppyDiskImage )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR imagePath,
            /* [in] */ VMFloppyDiskImageType imageType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFloppyDiskImageType )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR imagePath,
            /* [retval][out] */ __RPC__out VMFloppyDiskImageType *imageType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetConfigurationValue )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR preferenceKey,
            /* [retval][out] */ __RPC__out VARIANT *preferenceValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetConfigurationValue )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR preferenceKey,
            /* [in] */ VARIANT preferenceValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveConfigurationValue )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR preferenceKey);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumMemoryPerVM )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__out long *megabytesOfMemory);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumMemoryPerVM )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__out long *megabytesOfMemory);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SuggestedMaximumMemoryPerVM )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__out long *megabytesOfMemory);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumFloppyDrivesPerVM )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__out long *maxDrives);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumSerialPortsPerVM )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__out long *maxPorts);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumParallelPortsPerVM )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__out long *maxPorts);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumNetworkAdaptersPerVM )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__out long *maxNetworkAdapters);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumNumberOfIDEBuses )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__out long *maxNumBuses);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultVMConfigurationPath )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *configurationPath);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultVMConfigurationPath )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ __RPC__in BSTR configurationPath);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPaths )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__out VARIANT *searchPaths);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SearchPaths )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ VARIANT searchPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetHardDiskFiles )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ VARIANT inAdditionalSearchPaths,
            /* [retval][out] */ __RPC__out VARIANT *outHardDiskFileList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVirtualMachineFiles )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ VARIANT inAdditionalSearchPaths,
            /* [in] */ VARIANT_BOOL inExcludedRegisteredVMs,
            /* [retval][out] */ __RPC__out VARIANT *outVirtualMachineFileList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFloppyDiskFiles )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ VARIANT inAdditionalSearchPaths,
            /* [retval][out] */ __RPC__out VARIANT *outFloppyDiskFileList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDVDFiles )( 
            __RPC__in IVMVirtualPC * This,
            /* [in] */ VARIANT inAdditionalSearchPaths,
            /* [retval][out] */ __RPC__out VARIANT *outDVDFileList);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_USBDeviceCollection )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__deref_out_opt IVMUSBDeviceCollection **usbDeviceCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *virtualPCName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *version);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UpTime )( 
            __RPC__in IVMVirtualPC * This,
            /* [retval][out] */ __RPC__out long *secondsAlive);
        
        END_INTERFACE
    } IVMVirtualPCVtbl;

    interface IVMVirtualPC
    {
        CONST_VTBL struct IVMVirtualPCVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMVirtualPC_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMVirtualPC_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMVirtualPC_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMVirtualPC_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMVirtualPC_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMVirtualPC_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMVirtualPC_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVMVirtualPC_get_HostInfo(This,hostInfo)	\
    ( (This)->lpVtbl -> get_HostInfo(This,hostInfo) ) 

#define IVMVirtualPC_FindVirtualMachine(This,configurationName,virtualMachine)	\
    ( (This)->lpVtbl -> FindVirtualMachine(This,configurationName,virtualMachine) ) 

#define IVMVirtualPC_CreateVirtualMachine(This,configurationName,configurationPath,virtualMachine)	\
    ( (This)->lpVtbl -> CreateVirtualMachine(This,configurationName,configurationPath,virtualMachine) ) 

#define IVMVirtualPC_DeleteVirtualMachine(This,virtualMachine)	\
    ( (This)->lpVtbl -> DeleteVirtualMachine(This,virtualMachine) ) 

#define IVMVirtualPC_RegisterVirtualMachine(This,configurationName,configurationPath,virtualMachine)	\
    ( (This)->lpVtbl -> RegisterVirtualMachine(This,configurationName,configurationPath,virtualMachine) ) 

#define IVMVirtualPC_UnregisterVirtualMachine(This,virtualMachine)	\
    ( (This)->lpVtbl -> UnregisterVirtualMachine(This,virtualMachine) ) 

#define IVMVirtualPC_get_VirtualMachines(This,virtualMachineCollection)	\
    ( (This)->lpVtbl -> get_VirtualMachines(This,virtualMachineCollection) ) 

#define IVMVirtualPC_FindVirtualNetwork(This,virtualNetworkName,virtualNetwork)	\
    ( (This)->lpVtbl -> FindVirtualNetwork(This,virtualNetworkName,virtualNetwork) ) 

#define IVMVirtualPC_get_VirtualNetworks(This,virtualNetworkCollection)	\
    ( (This)->lpVtbl -> get_VirtualNetworks(This,virtualNetworkCollection) ) 

#define IVMVirtualPC_get_UnconnectedNetworkAdapters(This,unconnectedNetworkAdapterCollection)	\
    ( (This)->lpVtbl -> get_UnconnectedNetworkAdapters(This,unconnectedNetworkAdapterCollection) ) 

#define IVMVirtualPC_get_SupportDrivers(This,supportDriverCollection)	\
    ( (This)->lpVtbl -> get_SupportDrivers(This,supportDriverCollection) ) 

#define IVMVirtualPC_get_Tasks(This,taskCollection)	\
    ( (This)->lpVtbl -> get_Tasks(This,taskCollection) ) 

#define IVMVirtualPC_CreateDynamicVirtualHardDisk(This,imagePath,size,diskTask)	\
    ( (This)->lpVtbl -> CreateDynamicVirtualHardDisk(This,imagePath,size,diskTask) ) 

#define IVMVirtualPC_CreateFixedVirtualHardDisk(This,imagePath,size,diskTask)	\
    ( (This)->lpVtbl -> CreateFixedVirtualHardDisk(This,imagePath,size,diskTask) ) 

#define IVMVirtualPC_CreateDifferencingVirtualHardDisk(This,imagePath,parentPath,diskTask)	\
    ( (This)->lpVtbl -> CreateDifferencingVirtualHardDisk(This,imagePath,parentPath,diskTask) ) 

#define IVMVirtualPC_GetHardDisk(This,imagePath,hardDisk)	\
    ( (This)->lpVtbl -> GetHardDisk(This,imagePath,hardDisk) ) 

#define IVMVirtualPC_CreateFloppyDiskImage(This,imagePath,imageType)	\
    ( (This)->lpVtbl -> CreateFloppyDiskImage(This,imagePath,imageType) ) 

#define IVMVirtualPC_GetFloppyDiskImageType(This,imagePath,imageType)	\
    ( (This)->lpVtbl -> GetFloppyDiskImageType(This,imagePath,imageType) ) 

#define IVMVirtualPC_GetConfigurationValue(This,preferenceKey,preferenceValue)	\
    ( (This)->lpVtbl -> GetConfigurationValue(This,preferenceKey,preferenceValue) ) 

#define IVMVirtualPC_SetConfigurationValue(This,preferenceKey,preferenceValue)	\
    ( (This)->lpVtbl -> SetConfigurationValue(This,preferenceKey,preferenceValue) ) 

#define IVMVirtualPC_RemoveConfigurationValue(This,preferenceKey)	\
    ( (This)->lpVtbl -> RemoveConfigurationValue(This,preferenceKey) ) 

#define IVMVirtualPC_get_MinimumMemoryPerVM(This,megabytesOfMemory)	\
    ( (This)->lpVtbl -> get_MinimumMemoryPerVM(This,megabytesOfMemory) ) 

#define IVMVirtualPC_get_MaximumMemoryPerVM(This,megabytesOfMemory)	\
    ( (This)->lpVtbl -> get_MaximumMemoryPerVM(This,megabytesOfMemory) ) 

#define IVMVirtualPC_get_SuggestedMaximumMemoryPerVM(This,megabytesOfMemory)	\
    ( (This)->lpVtbl -> get_SuggestedMaximumMemoryPerVM(This,megabytesOfMemory) ) 

#define IVMVirtualPC_get_MaximumFloppyDrivesPerVM(This,maxDrives)	\
    ( (This)->lpVtbl -> get_MaximumFloppyDrivesPerVM(This,maxDrives) ) 

#define IVMVirtualPC_get_MaximumSerialPortsPerVM(This,maxPorts)	\
    ( (This)->lpVtbl -> get_MaximumSerialPortsPerVM(This,maxPorts) ) 

#define IVMVirtualPC_get_MaximumParallelPortsPerVM(This,maxPorts)	\
    ( (This)->lpVtbl -> get_MaximumParallelPortsPerVM(This,maxPorts) ) 

#define IVMVirtualPC_get_MaximumNetworkAdaptersPerVM(This,maxNetworkAdapters)	\
    ( (This)->lpVtbl -> get_MaximumNetworkAdaptersPerVM(This,maxNetworkAdapters) ) 

#define IVMVirtualPC_get_MaximumNumberOfIDEBuses(This,maxNumBuses)	\
    ( (This)->lpVtbl -> get_MaximumNumberOfIDEBuses(This,maxNumBuses) ) 

#define IVMVirtualPC_get_DefaultVMConfigurationPath(This,configurationPath)	\
    ( (This)->lpVtbl -> get_DefaultVMConfigurationPath(This,configurationPath) ) 

#define IVMVirtualPC_put_DefaultVMConfigurationPath(This,configurationPath)	\
    ( (This)->lpVtbl -> put_DefaultVMConfigurationPath(This,configurationPath) ) 

#define IVMVirtualPC_get_SearchPaths(This,searchPaths)	\
    ( (This)->lpVtbl -> get_SearchPaths(This,searchPaths) ) 

#define IVMVirtualPC_put_SearchPaths(This,searchPaths)	\
    ( (This)->lpVtbl -> put_SearchPaths(This,searchPaths) ) 

#define IVMVirtualPC_GetHardDiskFiles(This,inAdditionalSearchPaths,outHardDiskFileList)	\
    ( (This)->lpVtbl -> GetHardDiskFiles(This,inAdditionalSearchPaths,outHardDiskFileList) ) 

#define IVMVirtualPC_GetVirtualMachineFiles(This,inAdditionalSearchPaths,inExcludedRegisteredVMs,outVirtualMachineFileList)	\
    ( (This)->lpVtbl -> GetVirtualMachineFiles(This,inAdditionalSearchPaths,inExcludedRegisteredVMs,outVirtualMachineFileList) ) 

#define IVMVirtualPC_GetFloppyDiskFiles(This,inAdditionalSearchPaths,outFloppyDiskFileList)	\
    ( (This)->lpVtbl -> GetFloppyDiskFiles(This,inAdditionalSearchPaths,outFloppyDiskFileList) ) 

#define IVMVirtualPC_GetDVDFiles(This,inAdditionalSearchPaths,outDVDFileList)	\
    ( (This)->lpVtbl -> GetDVDFiles(This,inAdditionalSearchPaths,outDVDFileList) ) 

#define IVMVirtualPC_get_USBDeviceCollection(This,usbDeviceCollection)	\
    ( (This)->lpVtbl -> get_USBDeviceCollection(This,usbDeviceCollection) ) 

#define IVMVirtualPC_get_Name(This,virtualPCName)	\
    ( (This)->lpVtbl -> get_Name(This,virtualPCName) ) 

#define IVMVirtualPC_get_Version(This,version)	\
    ( (This)->lpVtbl -> get_Version(This,version) ) 

#define IVMVirtualPC_get_UpTime(This,secondsAlive)	\
    ( (This)->lpVtbl -> get_UpTime(This,secondsAlive) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMVirtualPC_INTERFACE_DEFINED__ */


#ifndef __IVMVirtualPCEvents_DISPINTERFACE_DEFINED__
#define __IVMVirtualPCEvents_DISPINTERFACE_DEFINED__

/* dispinterface IVMVirtualPCEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_IVMVirtualPCEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("efed1ef1-3c09-41f7-a9c2-7e29fa286c9d")
    IVMVirtualPCEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IVMVirtualPCEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMVirtualPCEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMVirtualPCEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMVirtualPCEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMVirtualPCEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMVirtualPCEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMVirtualPCEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMVirtualPCEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IVMVirtualPCEventsVtbl;

    interface IVMVirtualPCEvents
    {
        CONST_VTBL struct IVMVirtualPCEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMVirtualPCEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMVirtualPCEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMVirtualPCEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMVirtualPCEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMVirtualPCEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMVirtualPCEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMVirtualPCEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IVMVirtualPCEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_VMVirtualPC;

#ifdef __cplusplus

class DECLSPEC_UUID("9a1774b7-8251-4468-a214-61dcaed9ac2f")
VMVirtualPC;
#endif

EXTERN_C const CLSID CLSID_VMAccountant;

#ifdef __cplusplus

class DECLSPEC_UUID("f3a5aaa1-63c5-4c66-b0d4-625892f79d19")
VMAccountant;
#endif

EXTERN_C const CLSID CLSID_VMDisplay;

#ifdef __cplusplus

class DECLSPEC_UUID("f11ce62b-39c0-4692-a805-c88dad27e038")
VMDisplay;
#endif

#ifndef __IVMDVDDriveEvents_DISPINTERFACE_DEFINED__
#define __IVMDVDDriveEvents_DISPINTERFACE_DEFINED__

/* dispinterface IVMDVDDriveEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_IVMDVDDriveEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("c2a7d8e9-e76c-4eb8-94f7-71a5122d249b")
    IVMDVDDriveEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IVMDVDDriveEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMDVDDriveEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMDVDDriveEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMDVDDriveEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMDVDDriveEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMDVDDriveEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMDVDDriveEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMDVDDriveEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IVMDVDDriveEventsVtbl;

    interface IVMDVDDriveEvents
    {
        CONST_VTBL struct IVMDVDDriveEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMDVDDriveEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMDVDDriveEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMDVDDriveEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMDVDDriveEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMDVDDriveEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMDVDDriveEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMDVDDriveEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IVMDVDDriveEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_VMDVDDrive;

#ifdef __cplusplus

class DECLSPEC_UUID("30ac1778-42d6-4ff8-8f4b-7475282e1b49")
VMDVDDrive;
#endif

#ifndef __IVMFloppyDriveEvents_DISPINTERFACE_DEFINED__
#define __IVMFloppyDriveEvents_DISPINTERFACE_DEFINED__

/* dispinterface IVMFloppyDriveEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_IVMFloppyDriveEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("a9ed3401-4e09-4177-86ec-a13bf9fa7d4e")
    IVMFloppyDriveEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IVMFloppyDriveEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVMFloppyDriveEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVMFloppyDriveEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVMFloppyDriveEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IVMFloppyDriveEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IVMFloppyDriveEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IVMFloppyDriveEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVMFloppyDriveEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IVMFloppyDriveEventsVtbl;

    interface IVMFloppyDriveEvents
    {
        CONST_VTBL struct IVMFloppyDriveEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMFloppyDriveEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMFloppyDriveEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMFloppyDriveEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMFloppyDriveEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVMFloppyDriveEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVMFloppyDriveEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVMFloppyDriveEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IVMFloppyDriveEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_VMFloppyDrive;

#ifdef __cplusplus

class DECLSPEC_UUID("3a2e7c18-33e8-4102-be39-8d5c96c8ced5")
VMFloppyDrive;
#endif

EXTERN_C const CLSID CLSID_VMGuestOS;

#ifdef __cplusplus

class DECLSPEC_UUID("b8f18ab3-250a-4b83-bb01-4278d4176cfa")
VMGuestOS;
#endif

EXTERN_C const CLSID CLSID_VMHardDiskConnection;

#ifdef __cplusplus

class DECLSPEC_UUID("67d6604f-30fd-48e3-b57b-395bdb06e6bb")
VMHardDiskConnection;
#endif

EXTERN_C const CLSID CLSID_VMHardDisk;

#ifdef __cplusplus

class DECLSPEC_UUID("788ec54b-4555-4aa0-9e70-0d5380172ac5")
VMHardDisk;
#endif

EXTERN_C const CLSID CLSID_VMHostInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("5faa96f0-30f0-4822-b164-447730ca1879")
VMHostInfo;
#endif

EXTERN_C const CLSID CLSID_VMKeyboard;

#ifdef __cplusplus

class DECLSPEC_UUID("7dce7fba-45c9-4de0-8d2d-12d0f94759c4")
VMKeyboard;
#endif

EXTERN_C const CLSID CLSID_VMMouseDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("b78d8052-b722-4f7a-850e-2aeb1e747aa6")
VMMouseDevice;
#endif

EXTERN_C const CLSID CLSID_VMNetworkAdapter;

#ifdef __cplusplus

class DECLSPEC_UUID("620e38fd-249e-4e03-9367-acde5d17d267")
VMNetworkAdapter;
#endif

EXTERN_C const CLSID CLSID_VMParallelPort;

#ifdef __cplusplus

class DECLSPEC_UUID("d45c9931-d2a9-4ef9-8b18-a0fc6044ec9f")
VMParallelPort;
#endif

EXTERN_C const CLSID CLSID_VMSerialPort;

#ifdef __cplusplus

class DECLSPEC_UUID("a92a74da-d35c-4b45-86dc-321c6e28ab49")
VMSerialPort;
#endif

EXTERN_C const CLSID CLSID_VMVirtualNetwork;

#ifdef __cplusplus

class DECLSPEC_UUID("9b8e2ef9-28b2-4e8e-907f-f7050db0ffb8")
VMVirtualNetwork;
#endif

EXTERN_C const CLSID CLSID_VMTask;

#ifdef __cplusplus

class DECLSPEC_UUID("0747074d-4bfc-49f8-9aab-c926e11b756d")
VMTask;
#endif

EXTERN_C const CLSID CLSID_VMUSBDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("44253B42-5B8B-4b57-BB1B-C5285CF372EB")
VMUSBDevice;
#endif
#endif /* __VirtualPC_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vpconfig.h ===
//------------------------------------------------------------------------------
// File: VPConfig.h
//
// Desc: An interface exposed by the decoder to help it and the filter
//       configuring the videoport to communicate.
//
// Copyright (c) 1992 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __IVPConfig__
#define __IVPConfig__

#ifdef __cplusplus
extern "C" {
#endif

// IVPBaseConfig
DECLARE_INTERFACE_(IVPBaseConfig, IUnknown)
{
public:

    // gets the various connection information structures (guid, portwidth)
    // in an array of structures. If the pointer to the array is NULL, first 
    // parameter returns the total number of formats supported.
    STDMETHOD (GetConnectInfo)(THIS_
			       __inout LPDWORD pdwNumConnectInfo,
			       __out_ecount_part_opt(*pdwNumConnectInfo, *pdwNumConnectInfo) LPDDVIDEOPORTCONNECT pddVPConnectInfo
			      ) PURE;

    // sets the connection entry chosen (0, 1, .. ,(dwNumProposedEntries-1))
    STDMETHOD (SetConnectInfo)(THIS_
			       IN DWORD dwChosenEntry
			      ) PURE;

    // gets various data parameters, includes dimensionnal info
    STDMETHOD (GetVPDataInfo)(THIS_
			      IN OUT LPAMVPDATAINFO pamvpDataInfo
			     ) PURE;

    // retrives maximum pixels per second rate expected for a given 
    // format and a given scaling factor. If decoder does not support 
    // those scaling factors, then it gives the rate and the nearest 
    // scaling factors.
    STDMETHOD (GetMaxPixelRate)(THIS_
				IN OUT LPAMVPSIZE pamvpSize,
				OUT LPDWORD pdwMaxPixelsPerSecond
			       ) PURE;

    // informs the callee of the videoformats supported by the videoport
    STDMETHOD (InformVPInputFormats)(THIS_
				     IN DWORD dwNumFormats,
				     IN LPDDPIXELFORMAT pDDPixelFormats
				    ) PURE;

    // gets the various formats supported by the decoder in an array
    // of structures. If the pointer to the array is NULL, first parameter
    // returns the total number of formats supported.
    STDMETHOD (GetVideoFormats)(THIS_
				__inout LPDWORD pdwNumFormats,
				__out_ecount_part_opt(*pdwNumFormats, *pdwNumFormats) LPDDPIXELFORMAT pddPixelFormats
			       ) PURE;

    // sets the format entry chosen (0, 1, .. ,(dwNumProposedEntries-1))
    STDMETHOD (SetVideoFormat)(THIS_
			       IN DWORD dwChosenEntry
			      ) PURE;

    // asks the decoder to treat even fields like odd fields and visa versa
    STDMETHOD (SetInvertPolarity)(THIS_
				 ) PURE;

    // the mixer uses this function to determine if the callee wants
    // the vpmixer to use its overlay surface and if so to get a pointer to it
    STDMETHOD (GetOverlaySurface)(THIS_
				  OUT LPDIRECTDRAWSURFACE* ppddOverlaySurface
				 ) PURE;

    // sets the direct draw kernel handle
    STDMETHOD (SetDirectDrawKernelHandle)(THIS_
					  IN ULONG_PTR dwDDKernelHandle
					 ) PURE;

    // sets the video port id
    STDMETHOD (SetVideoPortID)(THIS_
			       IN DWORD dwVideoPortID
			      ) PURE;

    // sets the direct draw surface kernel handle
    STDMETHOD (SetDDSurfaceKernelHandles)(THIS_
					  IN DWORD cHandles,
					  IN ULONG_PTR *rgDDKernelHandles
					 ) PURE;

    // Tells driver about surface created on its behalf by ovmixer/vbisurf and 
    // returned from videoport/ddraw. Should always return NOERROR or E_NOIMPL. 
    // dwPitch is the pitch of the surface (distance in pixels between the start 
    // pixels of two consecutive lines of the surface). (dwXOrigin, dwYOrigin) 
    // are the (X, Y) coordinates of the pixel at which valid data starts.  
    STDMETHOD (SetSurfaceParameters)(THIS_
                    IN DWORD dwPitch,
                    IN DWORD dwXOrigin,
                    IN DWORD dwYOrigin
                    ) PURE;
};

// IVPConfig
DECLARE_INTERFACE_(IVPConfig, IVPBaseConfig)
{
public:
	// the mixer uses this function to determine if the callee wants
	// the mixer to decimate VIDEO data at its own descrition
	STDMETHOD (IsVPDecimationAllowed)(THIS_
					  OUT LPBOOL pbIsDecimationAllowed
					 ) PURE;

	// sets the scaling factors. If decoder does not support these,
	// then it sets the values to the nearest factors it can support
	STDMETHOD (SetScalingFactors)(THIS_
				      IN LPAMVPSIZE pamvpSize
				     ) PURE;
};

// IVPVBIConfig
DECLARE_INTERFACE_(IVPVBIConfig, IVPBaseConfig)
{
public:
};

#ifdef __cplusplus
}
#endif


#endif // __IVPConfig__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vsadmin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vsadmin.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vsadmin_h__
#define __vsadmin_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVssAdmin_FWD_DEFINED__
#define __IVssAdmin_FWD_DEFINED__
typedef interface IVssAdmin IVssAdmin;
#endif 	/* __IVssAdmin_FWD_DEFINED__ */


#ifndef __IVssAdminEx_FWD_DEFINED__
#define __IVssAdminEx_FWD_DEFINED__
typedef interface IVssAdminEx IVssAdminEx;
#endif 	/* __IVssAdminEx_FWD_DEFINED__ */


#ifndef __VSSCoordinator_FWD_DEFINED__
#define __VSSCoordinator_FWD_DEFINED__

#ifdef __cplusplus
typedef class VSSCoordinator VSSCoordinator;
#else
typedef struct VSSCoordinator VSSCoordinator;
#endif /* __cplusplus */

#endif 	/* __VSSCoordinator_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "vss.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IVssAdmin_INTERFACE_DEFINED__
#define __IVssAdmin_INTERFACE_DEFINED__

/* interface IVssAdmin */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77ED5996-2F63-11d3-8A39-00C04F72D8E3")
    IVssAdmin : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterProvider( 
            /* [in] */ VSS_ID pProviderId,
            /* [in] */ CLSID ClassId,
            /* [in] */ __RPC__in VSS_PWSZ pwszProviderName,
            /* [in] */ VSS_PROVIDER_TYPE eProviderType,
            /* [in] */ __RPC__in VSS_PWSZ pwszProviderVersion,
            /* [in] */ VSS_ID ProviderVersionId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterProvider( 
            /* [in] */ VSS_ID ProviderId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryProviders( 
            /* [out] */ __RPC__deref_out_opt IVssEnumObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AbortAllSnapshotsInProgress( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssAdmin * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssAdmin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterProvider )( 
            __RPC__in IVssAdmin * This,
            /* [in] */ VSS_ID pProviderId,
            /* [in] */ CLSID ClassId,
            /* [in] */ __RPC__in VSS_PWSZ pwszProviderName,
            /* [in] */ VSS_PROVIDER_TYPE eProviderType,
            /* [in] */ __RPC__in VSS_PWSZ pwszProviderVersion,
            /* [in] */ VSS_ID ProviderVersionId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterProvider )( 
            __RPC__in IVssAdmin * This,
            /* [in] */ VSS_ID ProviderId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryProviders )( 
            __RPC__in IVssAdmin * This,
            /* [out] */ __RPC__deref_out_opt IVssEnumObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AbortAllSnapshotsInProgress )( 
            __RPC__in IVssAdmin * This);
        
        END_INTERFACE
    } IVssAdminVtbl;

    interface IVssAdmin
    {
        CONST_VTBL struct IVssAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssAdmin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssAdmin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssAdmin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssAdmin_RegisterProvider(This,pProviderId,ClassId,pwszProviderName,eProviderType,pwszProviderVersion,ProviderVersionId)	\
    ( (This)->lpVtbl -> RegisterProvider(This,pProviderId,ClassId,pwszProviderName,eProviderType,pwszProviderVersion,ProviderVersionId) ) 

#define IVssAdmin_UnregisterProvider(This,ProviderId)	\
    ( (This)->lpVtbl -> UnregisterProvider(This,ProviderId) ) 

#define IVssAdmin_QueryProviders(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryProviders(This,ppEnum) ) 

#define IVssAdmin_AbortAllSnapshotsInProgress(This)	\
    ( (This)->lpVtbl -> AbortAllSnapshotsInProgress(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssAdmin_INTERFACE_DEFINED__ */


#ifndef __IVssAdminEx_INTERFACE_DEFINED__
#define __IVssAdminEx_INTERFACE_DEFINED__

/* interface IVssAdminEx */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssAdminEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7858A9F8-B1FA-41a6-964F-B9B36B8CD8D8")
    IVssAdminEx : public IVssAdmin
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProviderCapability( 
            /* [in] */ VSS_ID pProviderId,
            /* [out] */ __RPC__out ULONGLONG *pllOriginalCapabilityMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProviderContext( 
            /* [in] */ VSS_ID ProviderId,
            /* [out] */ __RPC__out LONG *plContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetProviderContext( 
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ LONG lContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssAdminExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssAdminEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssAdminEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssAdminEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterProvider )( 
            __RPC__in IVssAdminEx * This,
            /* [in] */ VSS_ID pProviderId,
            /* [in] */ CLSID ClassId,
            /* [in] */ __RPC__in VSS_PWSZ pwszProviderName,
            /* [in] */ VSS_PROVIDER_TYPE eProviderType,
            /* [in] */ __RPC__in VSS_PWSZ pwszProviderVersion,
            /* [in] */ VSS_ID ProviderVersionId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterProvider )( 
            __RPC__in IVssAdminEx * This,
            /* [in] */ VSS_ID ProviderId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryProviders )( 
            __RPC__in IVssAdminEx * This,
            /* [out] */ __RPC__deref_out_opt IVssEnumObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AbortAllSnapshotsInProgress )( 
            __RPC__in IVssAdminEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProviderCapability )( 
            __RPC__in IVssAdminEx * This,
            /* [in] */ VSS_ID pProviderId,
            /* [out] */ __RPC__out ULONGLONG *pllOriginalCapabilityMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProviderContext )( 
            __RPC__in IVssAdminEx * This,
            /* [in] */ VSS_ID ProviderId,
            /* [out] */ __RPC__out LONG *plContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetProviderContext )( 
            __RPC__in IVssAdminEx * This,
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ LONG lContext);
        
        END_INTERFACE
    } IVssAdminExVtbl;

    interface IVssAdminEx
    {
        CONST_VTBL struct IVssAdminExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssAdminEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssAdminEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssAdminEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssAdminEx_RegisterProvider(This,pProviderId,ClassId,pwszProviderName,eProviderType,pwszProviderVersion,ProviderVersionId)	\
    ( (This)->lpVtbl -> RegisterProvider(This,pProviderId,ClassId,pwszProviderName,eProviderType,pwszProviderVersion,ProviderVersionId) ) 

#define IVssAdminEx_UnregisterProvider(This,ProviderId)	\
    ( (This)->lpVtbl -> UnregisterProvider(This,ProviderId) ) 

#define IVssAdminEx_QueryProviders(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryProviders(This,ppEnum) ) 

#define IVssAdminEx_AbortAllSnapshotsInProgress(This)	\
    ( (This)->lpVtbl -> AbortAllSnapshotsInProgress(This) ) 


#define IVssAdminEx_GetProviderCapability(This,pProviderId,pllOriginalCapabilityMask)	\
    ( (This)->lpVtbl -> GetProviderCapability(This,pProviderId,pllOriginalCapabilityMask) ) 

#define IVssAdminEx_GetProviderContext(This,ProviderId,plContext)	\
    ( (This)->lpVtbl -> GetProviderContext(This,ProviderId,plContext) ) 

#define IVssAdminEx_SetProviderContext(This,ProviderId,lContext)	\
    ( (This)->lpVtbl -> SetProviderContext(This,ProviderId,lContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssAdminEx_INTERFACE_DEFINED__ */



#ifndef __VSSAdmin_LIBRARY_DEFINED__
#define __VSSAdmin_LIBRARY_DEFINED__

/* library VSSAdmin */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_VSSAdmin;

EXTERN_C const CLSID CLSID_VSSCoordinator;

#ifdef __cplusplus

class DECLSPEC_UUID("E579AB5F-1CC4-44b4-BED9-DE0991FF0623")
VSSCoordinator;
#endif
#endif /* __VSSAdmin_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vsmgmt.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vsmgmt.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vsmgmt_h__
#define __vsmgmt_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVssSnapshotMgmt_FWD_DEFINED__
#define __IVssSnapshotMgmt_FWD_DEFINED__
typedef interface IVssSnapshotMgmt IVssSnapshotMgmt;
#endif 	/* __IVssSnapshotMgmt_FWD_DEFINED__ */


#ifndef __IVssSnapshotMgmt2_FWD_DEFINED__
#define __IVssSnapshotMgmt2_FWD_DEFINED__
typedef interface IVssSnapshotMgmt2 IVssSnapshotMgmt2;
#endif 	/* __IVssSnapshotMgmt2_FWD_DEFINED__ */


#ifndef __IVssDifferentialSoftwareSnapshotMgmt_FWD_DEFINED__
#define __IVssDifferentialSoftwareSnapshotMgmt_FWD_DEFINED__
typedef interface IVssDifferentialSoftwareSnapshotMgmt IVssDifferentialSoftwareSnapshotMgmt;
#endif 	/* __IVssDifferentialSoftwareSnapshotMgmt_FWD_DEFINED__ */


#ifndef __IVssDifferentialSoftwareSnapshotMgmt2_FWD_DEFINED__
#define __IVssDifferentialSoftwareSnapshotMgmt2_FWD_DEFINED__
typedef interface IVssDifferentialSoftwareSnapshotMgmt2 IVssDifferentialSoftwareSnapshotMgmt2;
#endif 	/* __IVssDifferentialSoftwareSnapshotMgmt2_FWD_DEFINED__ */


#ifndef __IVssDifferentialSoftwareSnapshotMgmt3_FWD_DEFINED__
#define __IVssDifferentialSoftwareSnapshotMgmt3_FWD_DEFINED__
typedef interface IVssDifferentialSoftwareSnapshotMgmt3 IVssDifferentialSoftwareSnapshotMgmt3;
#endif 	/* __IVssDifferentialSoftwareSnapshotMgmt3_FWD_DEFINED__ */


#ifndef __IVssEnumMgmtObject_FWD_DEFINED__
#define __IVssEnumMgmtObject_FWD_DEFINED__
typedef interface IVssEnumMgmtObject IVssEnumMgmtObject;
#endif 	/* __IVssEnumMgmtObject_FWD_DEFINED__ */


#ifndef __VssSnapshotMgmt_FWD_DEFINED__
#define __VssSnapshotMgmt_FWD_DEFINED__

#ifdef __cplusplus
typedef class VssSnapshotMgmt VssSnapshotMgmt;
#else
typedef struct VssSnapshotMgmt VssSnapshotMgmt;
#endif /* __cplusplus */

#endif 	/* __VssSnapshotMgmt_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "vss.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vsmgmt_0000_0000 */
/* [local] */ 

typedef 
enum _VSS_MGMT_OBJECT_TYPE
    {	VSS_MGMT_OBJECT_UNKNOWN	= 0,
	VSS_MGMT_OBJECT_VOLUME	= ( VSS_MGMT_OBJECT_UNKNOWN + 1 ) ,
	VSS_MGMT_OBJECT_DIFF_VOLUME	= ( VSS_MGMT_OBJECT_VOLUME + 1 ) ,
	VSS_MGMT_OBJECT_DIFF_AREA	= ( VSS_MGMT_OBJECT_DIFF_VOLUME + 1 ) 
    } 	VSS_MGMT_OBJECT_TYPE;

typedef enum _VSS_MGMT_OBJECT_TYPE *PVSS_MGMT_OBJECT_TYPE;

#define	VSS_ASSOC_NO_MAX_SPACE	( -1 )

#define	VSS_ASSOC_REMOVE	( 0 )

typedef struct _VSS_VOLUME_PROP
    {
    VSS_PWSZ m_pwszVolumeName;
    VSS_PWSZ m_pwszVolumeDisplayName;
    } 	VSS_VOLUME_PROP;

typedef struct _VSS_VOLUME_PROP *PVSS_VOLUME_PROP;

typedef struct _VSS_DIFF_VOLUME_PROP
    {
    VSS_PWSZ m_pwszVolumeName;
    VSS_PWSZ m_pwszVolumeDisplayName;
    LONGLONG m_llVolumeFreeSpace;
    LONGLONG m_llVolumeTotalSpace;
    } 	VSS_DIFF_VOLUME_PROP;

typedef struct _VSS_DIFF_VOLUME_PROP *PVSS_DIFF_VOLUME_PROP;

typedef struct _VSS_DIFF_AREA_PROP
    {
    VSS_PWSZ m_pwszVolumeName;
    VSS_PWSZ m_pwszDiffAreaVolumeName;
    LONGLONG m_llMaximumDiffSpace;
    LONGLONG m_llAllocatedDiffSpace;
    LONGLONG m_llUsedDiffSpace;
    } 	VSS_DIFF_AREA_PROP;

typedef struct _VSS_DIFF_AREA_PROP *PVSS_DIFF_AREA_PROP;

typedef /* [public][public][public][public][switch_type] */ union __MIDL___MIDL_itf_vsmgmt_0000_0000_0001
    {
    VSS_VOLUME_PROP Vol;
    VSS_DIFF_VOLUME_PROP DiffVol;
    VSS_DIFF_AREA_PROP DiffArea;
     /* Empty union arm */ 
    } 	VSS_MGMT_OBJECT_UNION;

typedef /* [switch_type] */ union __MIDL___MIDL_itf_vsmgmt_0000_0000_0001 *PVSS_MGMT_OBJECT_UNION;

typedef struct _VSS_MGMT_OBJECT_PROP
    {
    VSS_MGMT_OBJECT_TYPE Type;
    VSS_MGMT_OBJECT_UNION Obj;
    } 	VSS_MGMT_OBJECT_PROP;

typedef struct _VSS_MGMT_OBJECT_PROP *PVSS_MGMT_OBJECT_PROP;

typedef 
enum _VSS_PROTECTION_LEVEL
    {	VSS_PROTECTION_LEVEL_ORIGINAL_VOLUME	= 0,
	VSS_PROTECTION_LEVEL_SNAPSHOT	= ( VSS_PROTECTION_LEVEL_ORIGINAL_VOLUME + 1 ) 
    } 	VSS_PROTECTION_LEVEL;

typedef enum _VSS_PROTECTION_LEVEL *PVSS_PROTECTION_LEVEL;

typedef 
enum _VSS_PROTECTION_FAULT
    {	VSS_PROTECTION_FAULT_NONE	= 0,
	VSS_PROTECTION_FAULT_DIFF_AREA_MISSING	= ( VSS_PROTECTION_FAULT_NONE + 1 ) ,
	VSS_PROTECTION_FAULT_IO_FAILURE_DURING_ONLINE	= ( VSS_PROTECTION_FAULT_DIFF_AREA_MISSING + 1 ) ,
	VSS_PROTECTION_FAULT_META_DATA_CORRUPTION	= ( VSS_PROTECTION_FAULT_IO_FAILURE_DURING_ONLINE + 1 ) ,
	VSS_PROTECTION_FAULT_MEMORY_ALLOCATION_FAILURE	= ( VSS_PROTECTION_FAULT_META_DATA_CORRUPTION + 1 ) ,
	VSS_PROTECTION_FAULT_MAPPED_MEMORY_FAILURE	= ( VSS_PROTECTION_FAULT_MEMORY_ALLOCATION_FAILURE + 1 ) ,
	VSS_PROTECTION_FAULT_COW_READ_FAILURE	= ( VSS_PROTECTION_FAULT_MAPPED_MEMORY_FAILURE + 1 ) ,
	VSS_PROTECTION_FAULT_COW_WRITE_FAILURE	= ( VSS_PROTECTION_FAULT_COW_READ_FAILURE + 1 ) ,
	VSS_PROTECTION_FAULT_DIFF_AREA_FULL	= ( VSS_PROTECTION_FAULT_COW_WRITE_FAILURE + 1 ) ,
	VSS_PROTECTION_FAULT_GROW_TOO_SLOW	= ( VSS_PROTECTION_FAULT_DIFF_AREA_FULL + 1 ) ,
	VSS_PROTECTION_FAULT_GROW_FAILED	= ( VSS_PROTECTION_FAULT_GROW_TOO_SLOW + 1 ) ,
	VSS_PROTECTION_FAULT_DESTROY_ALL_SNAPSHOTS	= ( VSS_PROTECTION_FAULT_GROW_FAILED + 1 ) ,
	VSS_PROTECTION_FAULT_FILE_SYSTEM_FAILURE	= ( VSS_PROTECTION_FAULT_DESTROY_ALL_SNAPSHOTS + 1 ) ,
	VSS_PROTECTION_FAULT_IO_FAILURE	= ( VSS_PROTECTION_FAULT_FILE_SYSTEM_FAILURE + 1 ) ,
	VSS_PROTECTION_FAULT_DIFF_AREA_REMOVED	= ( VSS_PROTECTION_FAULT_IO_FAILURE + 1 ) ,
	VSS_PROTECTION_FAULT_EXTERNAL_WRITER_TO_DIFF_AREA	= ( VSS_PROTECTION_FAULT_DIFF_AREA_REMOVED + 1 ) 
    } 	VSS_PROTECTION_FAULT;

typedef enum _VSS_PROTECTION_FAULT *PVSS_PROTECTION_FAULT;

typedef struct _VSS_VOLUME_PROTECTION_INFO
    {
    VSS_PROTECTION_LEVEL m_protectionLevel;
    BOOL m_volumeIsOfflineForProtection;
    VSS_PROTECTION_FAULT m_protectionFault;
    LONG m_failureStatus;
    BOOL m_volumeHasUnusedDiffArea;
    DWORD m_reserved;
    } 	VSS_VOLUME_PROTECTION_INFO;

typedef struct _VSS_VOLUME_PROTECTION_INFO *PVSS_VOLUME_PROTECTION_INFO;






extern RPC_IF_HANDLE __MIDL_itf_vsmgmt_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vsmgmt_0000_0000_v0_0_s_ifspec;

#ifndef __IVssSnapshotMgmt_INTERFACE_DEFINED__
#define __IVssSnapshotMgmt_INTERFACE_DEFINED__

/* interface IVssSnapshotMgmt */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssSnapshotMgmt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA7DF749-66E7-4986-A27F-E2F04AE53772")
    IVssSnapshotMgmt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProviderMgmtInterface( 
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ __RPC__in REFIID InterfaceId,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppItf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryVolumesSupportedForSnapshots( 
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ LONG lContext,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QuerySnapshotsByVolume( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_ID ProviderId,
            /* [out] */ __RPC__deref_out_opt IVssEnumObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssSnapshotMgmtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssSnapshotMgmt * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssSnapshotMgmt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssSnapshotMgmt * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProviderMgmtInterface )( 
            __RPC__in IVssSnapshotMgmt * This,
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ __RPC__in REFIID InterfaceId,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppItf);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVolumesSupportedForSnapshots )( 
            __RPC__in IVssSnapshotMgmt * This,
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ LONG lContext,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QuerySnapshotsByVolume )( 
            __RPC__in IVssSnapshotMgmt * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_ID ProviderId,
            /* [out] */ __RPC__deref_out_opt IVssEnumObject **ppEnum);
        
        END_INTERFACE
    } IVssSnapshotMgmtVtbl;

    interface IVssSnapshotMgmt
    {
        CONST_VTBL struct IVssSnapshotMgmtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssSnapshotMgmt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssSnapshotMgmt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssSnapshotMgmt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssSnapshotMgmt_GetProviderMgmtInterface(This,ProviderId,InterfaceId,ppItf)	\
    ( (This)->lpVtbl -> GetProviderMgmtInterface(This,ProviderId,InterfaceId,ppItf) ) 

#define IVssSnapshotMgmt_QueryVolumesSupportedForSnapshots(This,ProviderId,lContext,ppEnum)	\
    ( (This)->lpVtbl -> QueryVolumesSupportedForSnapshots(This,ProviderId,lContext,ppEnum) ) 

#define IVssSnapshotMgmt_QuerySnapshotsByVolume(This,pwszVolumeName,ProviderId,ppEnum)	\
    ( (This)->lpVtbl -> QuerySnapshotsByVolume(This,pwszVolumeName,ProviderId,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssSnapshotMgmt_INTERFACE_DEFINED__ */


#ifndef __IVssSnapshotMgmt2_INTERFACE_DEFINED__
#define __IVssSnapshotMgmt2_INTERFACE_DEFINED__

/* interface IVssSnapshotMgmt2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssSnapshotMgmt2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0f61ec39-fe82-45f2-a3f0-768b5d427102")
    IVssSnapshotMgmt2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMinDiffAreaSize( 
            /* [out] */ __RPC__out LONGLONG *pllMinDiffAreaSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssSnapshotMgmt2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssSnapshotMgmt2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssSnapshotMgmt2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssSnapshotMgmt2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinDiffAreaSize )( 
            __RPC__in IVssSnapshotMgmt2 * This,
            /* [out] */ __RPC__out LONGLONG *pllMinDiffAreaSize);
        
        END_INTERFACE
    } IVssSnapshotMgmt2Vtbl;

    interface IVssSnapshotMgmt2
    {
        CONST_VTBL struct IVssSnapshotMgmt2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssSnapshotMgmt2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssSnapshotMgmt2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssSnapshotMgmt2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssSnapshotMgmt2_GetMinDiffAreaSize(This,pllMinDiffAreaSize)	\
    ( (This)->lpVtbl -> GetMinDiffAreaSize(This,pllMinDiffAreaSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssSnapshotMgmt2_INTERFACE_DEFINED__ */


#ifndef __IVssDifferentialSoftwareSnapshotMgmt_INTERFACE_DEFINED__
#define __IVssDifferentialSoftwareSnapshotMgmt_INTERFACE_DEFINED__

/* interface IVssDifferentialSoftwareSnapshotMgmt */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssDifferentialSoftwareSnapshotMgmt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("214A0F28-B737-4026-B847-4F9E37D79529")
    IVssDifferentialSoftwareSnapshotMgmt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddDiffArea( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeDiffAreaMaximumSize( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryVolumesSupportedForDiffAreas( 
            /* [in] */ __RPC__in VSS_PWSZ pwszOriginalVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDiffAreasForVolume( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDiffAreasOnVolume( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDiffAreasForSnapshot( 
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssDifferentialSoftwareSnapshotMgmtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddDiffArea )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeDiffAreaMaximumSize )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVolumesSupportedForDiffAreas )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszOriginalVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDiffAreasForVolume )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDiffAreasOnVolume )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDiffAreasForSnapshot )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        END_INTERFACE
    } IVssDifferentialSoftwareSnapshotMgmtVtbl;

    interface IVssDifferentialSoftwareSnapshotMgmt
    {
        CONST_VTBL struct IVssDifferentialSoftwareSnapshotMgmtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssDifferentialSoftwareSnapshotMgmt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssDifferentialSoftwareSnapshotMgmt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssDifferentialSoftwareSnapshotMgmt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssDifferentialSoftwareSnapshotMgmt_AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)	\
    ( (This)->lpVtbl -> AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace) ) 

#define IVssDifferentialSoftwareSnapshotMgmt_ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)	\
    ( (This)->lpVtbl -> ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace) ) 

#define IVssDifferentialSoftwareSnapshotMgmt_QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum)	\
    ( (This)->lpVtbl -> QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum) ) 

#define IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum)	\
    ( (This)->lpVtbl -> QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum) ) 

#define IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum)	\
    ( (This)->lpVtbl -> QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum) ) 

#define IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum)	\
    ( (This)->lpVtbl -> QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssDifferentialSoftwareSnapshotMgmt_INTERFACE_DEFINED__ */


#ifndef __IVssDifferentialSoftwareSnapshotMgmt2_INTERFACE_DEFINED__
#define __IVssDifferentialSoftwareSnapshotMgmt2_INTERFACE_DEFINED__

/* interface IVssDifferentialSoftwareSnapshotMgmt2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssDifferentialSoftwareSnapshotMgmt2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("949d7353-675f-4275-8969-f044c6277815")
    IVssDifferentialSoftwareSnapshotMgmt2 : public IVssDifferentialSoftwareSnapshotMgmt
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ChangeDiffAreaMaximumSizeEx( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace,
            /* [in] */ BOOL bVolatile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MigrateDiffAreas( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszNewDiffAreaVolumeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryMigrationStatus( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssAsync **ppAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSnapshotPriority( 
            /* [in] */ VSS_ID idSnapshot,
            /* [in] */ BYTE priority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssDifferentialSoftwareSnapshotMgmt2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddDiffArea )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeDiffAreaMaximumSize )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVolumesSupportedForDiffAreas )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszOriginalVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDiffAreasForVolume )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDiffAreasOnVolume )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDiffAreasForSnapshot )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This,
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeDiffAreaMaximumSizeEx )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace,
            /* [in] */ BOOL bVolatile);
        
        HRESULT ( STDMETHODCALLTYPE *MigrateDiffAreas )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszNewDiffAreaVolumeName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryMigrationStatus )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssAsync **ppAsync);
        
        HRESULT ( STDMETHODCALLTYPE *SetSnapshotPriority )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt2 * This,
            /* [in] */ VSS_ID idSnapshot,
            /* [in] */ BYTE priority);
        
        END_INTERFACE
    } IVssDifferentialSoftwareSnapshotMgmt2Vtbl;

    interface IVssDifferentialSoftwareSnapshotMgmt2
    {
        CONST_VTBL struct IVssDifferentialSoftwareSnapshotMgmt2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssDifferentialSoftwareSnapshotMgmt2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssDifferentialSoftwareSnapshotMgmt2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssDifferentialSoftwareSnapshotMgmt2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssDifferentialSoftwareSnapshotMgmt2_AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)	\
    ( (This)->lpVtbl -> AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace) ) 

#define IVssDifferentialSoftwareSnapshotMgmt2_ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)	\
    ( (This)->lpVtbl -> ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace) ) 

#define IVssDifferentialSoftwareSnapshotMgmt2_QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum)	\
    ( (This)->lpVtbl -> QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum) ) 

#define IVssDifferentialSoftwareSnapshotMgmt2_QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum)	\
    ( (This)->lpVtbl -> QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum) ) 

#define IVssDifferentialSoftwareSnapshotMgmt2_QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum)	\
    ( (This)->lpVtbl -> QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum) ) 

#define IVssDifferentialSoftwareSnapshotMgmt2_QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum)	\
    ( (This)->lpVtbl -> QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum) ) 


#define IVssDifferentialSoftwareSnapshotMgmt2_ChangeDiffAreaMaximumSizeEx(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace,bVolatile)	\
    ( (This)->lpVtbl -> ChangeDiffAreaMaximumSizeEx(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace,bVolatile) ) 

#define IVssDifferentialSoftwareSnapshotMgmt2_MigrateDiffAreas(This,pwszVolumeName,pwszDiffAreaVolumeName,pwszNewDiffAreaVolumeName)	\
    ( (This)->lpVtbl -> MigrateDiffAreas(This,pwszVolumeName,pwszDiffAreaVolumeName,pwszNewDiffAreaVolumeName) ) 

#define IVssDifferentialSoftwareSnapshotMgmt2_QueryMigrationStatus(This,pwszVolumeName,pwszDiffAreaVolumeName,ppAsync)	\
    ( (This)->lpVtbl -> QueryMigrationStatus(This,pwszVolumeName,pwszDiffAreaVolumeName,ppAsync) ) 

#define IVssDifferentialSoftwareSnapshotMgmt2_SetSnapshotPriority(This,idSnapshot,priority)	\
    ( (This)->lpVtbl -> SetSnapshotPriority(This,idSnapshot,priority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssDifferentialSoftwareSnapshotMgmt2_INTERFACE_DEFINED__ */


#ifndef __IVssDifferentialSoftwareSnapshotMgmt3_INTERFACE_DEFINED__
#define __IVssDifferentialSoftwareSnapshotMgmt3_INTERFACE_DEFINED__

/* interface IVssDifferentialSoftwareSnapshotMgmt3 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssDifferentialSoftwareSnapshotMgmt3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("383f7e71-a4c5-401f-b27f-f826289f8458")
    IVssDifferentialSoftwareSnapshotMgmt3 : public IVssDifferentialSoftwareSnapshotMgmt2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetVolumeProtectLevel( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_PROTECTION_LEVEL protectionLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVolumeProtectLevel( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__out VSS_VOLUME_PROTECTION_INFO *protectionLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearVolumeProtectFault( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteUnusedDiffAreas( 
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QuerySnapshotDeltaBitmap( 
            /* [in] */ VSS_ID idSnapshotOlder,
            /* [in] */ VSS_ID idSnapshotYounger,
            /* [out] */ __RPC__out ULONG *pcBlockSizePerBit,
            /* [out] */ __RPC__out ULONG *pcBitmapLength,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcBitmapLength) BYTE **ppbBitmap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssDifferentialSoftwareSnapshotMgmt3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddDiffArea )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeDiffAreaMaximumSize )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVolumesSupportedForDiffAreas )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszOriginalVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDiffAreasForVolume )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDiffAreasOnVolume )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDiffAreasForSnapshot )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ __RPC__deref_out_opt IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeDiffAreaMaximumSizeEx )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace,
            /* [in] */ BOOL bVolatile);
        
        HRESULT ( STDMETHODCALLTYPE *MigrateDiffAreas )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszNewDiffAreaVolumeName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryMigrationStatus )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName,
            /* [out] */ __RPC__deref_out_opt IVssAsync **ppAsync);
        
        HRESULT ( STDMETHODCALLTYPE *SetSnapshotPriority )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ VSS_ID idSnapshot,
            /* [in] */ BYTE priority);
        
        HRESULT ( STDMETHODCALLTYPE *SetVolumeProtectLevel )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_PROTECTION_LEVEL protectionLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetVolumeProtectLevel )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__out VSS_VOLUME_PROTECTION_INFO *protectionLevel);
        
        HRESULT ( STDMETHODCALLTYPE *ClearVolumeProtectFault )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteUnusedDiffAreas )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszDiffAreaVolumeName);
        
        HRESULT ( STDMETHODCALLTYPE *QuerySnapshotDeltaBitmap )( 
            __RPC__in IVssDifferentialSoftwareSnapshotMgmt3 * This,
            /* [in] */ VSS_ID idSnapshotOlder,
            /* [in] */ VSS_ID idSnapshotYounger,
            /* [out] */ __RPC__out ULONG *pcBlockSizePerBit,
            /* [out] */ __RPC__out ULONG *pcBitmapLength,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcBitmapLength) BYTE **ppbBitmap);
        
        END_INTERFACE
    } IVssDifferentialSoftwareSnapshotMgmt3Vtbl;

    interface IVssDifferentialSoftwareSnapshotMgmt3
    {
        CONST_VTBL struct IVssDifferentialSoftwareSnapshotMgmt3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssDifferentialSoftwareSnapshotMgmt3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssDifferentialSoftwareSnapshotMgmt3_AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)	\
    ( (This)->lpVtbl -> AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)	\
    ( (This)->lpVtbl -> ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum)	\
    ( (This)->lpVtbl -> QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum)	\
    ( (This)->lpVtbl -> QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum)	\
    ( (This)->lpVtbl -> QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum)	\
    ( (This)->lpVtbl -> QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum) ) 


#define IVssDifferentialSoftwareSnapshotMgmt3_ChangeDiffAreaMaximumSizeEx(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace,bVolatile)	\
    ( (This)->lpVtbl -> ChangeDiffAreaMaximumSizeEx(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace,bVolatile) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_MigrateDiffAreas(This,pwszVolumeName,pwszDiffAreaVolumeName,pwszNewDiffAreaVolumeName)	\
    ( (This)->lpVtbl -> MigrateDiffAreas(This,pwszVolumeName,pwszDiffAreaVolumeName,pwszNewDiffAreaVolumeName) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_QueryMigrationStatus(This,pwszVolumeName,pwszDiffAreaVolumeName,ppAsync)	\
    ( (This)->lpVtbl -> QueryMigrationStatus(This,pwszVolumeName,pwszDiffAreaVolumeName,ppAsync) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_SetSnapshotPriority(This,idSnapshot,priority)	\
    ( (This)->lpVtbl -> SetSnapshotPriority(This,idSnapshot,priority) ) 


#define IVssDifferentialSoftwareSnapshotMgmt3_SetVolumeProtectLevel(This,pwszVolumeName,protectionLevel)	\
    ( (This)->lpVtbl -> SetVolumeProtectLevel(This,pwszVolumeName,protectionLevel) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_GetVolumeProtectLevel(This,pwszVolumeName,protectionLevel)	\
    ( (This)->lpVtbl -> GetVolumeProtectLevel(This,pwszVolumeName,protectionLevel) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_ClearVolumeProtectFault(This,pwszVolumeName)	\
    ( (This)->lpVtbl -> ClearVolumeProtectFault(This,pwszVolumeName) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_DeleteUnusedDiffAreas(This,pwszDiffAreaVolumeName)	\
    ( (This)->lpVtbl -> DeleteUnusedDiffAreas(This,pwszDiffAreaVolumeName) ) 

#define IVssDifferentialSoftwareSnapshotMgmt3_QuerySnapshotDeltaBitmap(This,idSnapshotOlder,idSnapshotYounger,pcBlockSizePerBit,pcBitmapLength,ppbBitmap)	\
    ( (This)->lpVtbl -> QuerySnapshotDeltaBitmap(This,idSnapshotOlder,idSnapshotYounger,pcBlockSizePerBit,pcBitmapLength,ppbBitmap) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssDifferentialSoftwareSnapshotMgmt3_INTERFACE_DEFINED__ */


#ifndef __IVssEnumMgmtObject_INTERFACE_DEFINED__
#define __IVssEnumMgmtObject_INTERFACE_DEFINED__

/* interface IVssEnumMgmtObject */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssEnumMgmtObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01954E6B-9254-4e6e-808C-C9E05D007696")
    IVssEnumMgmtObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) VSS_MGMT_OBJECT_PROP *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out][in] */ __RPC__deref_inout_opt IVssEnumMgmtObject **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssEnumMgmtObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssEnumMgmtObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssEnumMgmtObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssEnumMgmtObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IVssEnumMgmtObject * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) VSS_MGMT_OBJECT_PROP *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IVssEnumMgmtObject * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IVssEnumMgmtObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IVssEnumMgmtObject * This,
            /* [out][in] */ __RPC__deref_inout_opt IVssEnumMgmtObject **ppenum);
        
        END_INTERFACE
    } IVssEnumMgmtObjectVtbl;

    interface IVssEnumMgmtObject
    {
        CONST_VTBL struct IVssEnumMgmtObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssEnumMgmtObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssEnumMgmtObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssEnumMgmtObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssEnumMgmtObject_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IVssEnumMgmtObject_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IVssEnumMgmtObject_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IVssEnumMgmtObject_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssEnumMgmtObject_INTERFACE_DEFINED__ */



#ifndef __VSMGMT_LIBRARY_DEFINED__
#define __VSMGMT_LIBRARY_DEFINED__

/* library VSMGMT */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_VSMGMT;

EXTERN_C const CLSID CLSID_VssSnapshotMgmt;

#ifdef __cplusplus

class DECLSPEC_UUID("0B5A2C52-3EB9-470a-96E2-6C6D4570E40F")
VssSnapshotMgmt;
#endif
#endif /* __VSMGMT_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vsbackup.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    vsbackup.h

Abstract:

    Declaration of backup interfaces.

--*/

#ifndef _VSBACKUP_H_
#define _VSBACKUP_H_


const IID IID_IVssExamineWriterMetadata      =   // 902fcf7f-b7fd-42f8-81f1-b2e400b1e5bd 
                     {
                     0x902fcf7f,
                     0xb7fd,
                     0x42f8,
                     {0x81, 0xf1, 0xb2, 0xe4, 0x00, 0xb1, 0xe5, 0xbd }
                     };

const IID IID_IVssExamineWriterMetadataEx  =  // 0c0e5ec0-ca44-472b-b702-e652db1c0451 
                    {
                    0x0c0e5ec0,
                    0xca44,
                    0x472b,
                    { 0xb7, 0x02, 0xe6, 0x52, 0xdb, 0x1c, 0x04, 0x51  }
                    };

const IID IID_IVssExamineWriterMetadataEx2 = // ce115780-a611-431b-b57f-c38303ab6aee
                    {
                    0xce115780,
                    0xa611,
                    0x431b,
                    { 0xb5, 0x7f, 0xc3, 0x83, 0x03, 0xab, 0x6a, 0xee }
                    };
                    
const IID IID_IVssBackupComponents            =  // 665c1d5f-c218-414d-a05d-7fef5f9d5c86 
                    {
                    0x665c1d5f,
                    0xc218,
                    0x414d,
                    { 0xa0, 0x5d, 0x7f, 0xef, 0x5f, 0x9d, 0x5c, 0x86 }
                    };

const IID IID_IVssBackupComponentsEx         = // 963f03ad-9e4c-4a34-ac15-e4b6174e5036 
                    {
                    0x963f03ad,
                    0x9e4c,
                    0x4a34,
                    { 0xac, 0x15, 0xe4, 0xb6, 0x17, 0x4e, 0x50, 0x36 }
                    };

const IID IID_IVssBackupComponentsEx2       = // acfe2b3a-22c9-4ef8-bd03-2f9ca230084e
                    {
                    0xacfe2b3a,
                    0x22c9,
                    0x4ef8,
                    { 0xbd, 0x03, 0x2f, 0x9c, 0xa2, 0x30, 0x08, 0x4e }
                    };

const IID IID_IVssBackupComponentsEx3       = // c191bfbc-b602-4675-8bd1-67d642f529d5
                    {
                    0xc191bfbc,
                    0xb602,
                    0x4675,
                    { 0x8b, 0xd1, 0x67, 0xd6, 0x42, 0xf5, 0x29, 0xd5 }
                    };


// description of a component
typedef struct _VSS_COMPONENTINFO
    {
    VSS_COMPONENT_TYPE type;    // either VSS_CT_DATABASE or VSS_CT_FILEGROUP
    BSTR bstrLogicalPath;        // logical path to component
    BSTR bstrComponentName;        // component name
    BSTR bstrCaption;        // description of component
    BYTE *pbIcon;            // icon
    UINT cbIcon;            // icon
    bool bRestoreMetadata;        // whether component supplies restore metadata
    bool bNotifyOnBackupComplete;    // whether component needs to be informed if backup was successful
    bool bSelectable;        // is component selectable    
    bool bSelectableForRestore; // is component selectable for restore
    DWORD dwComponentFlags;    // extra attribute flags for the component
    UINT cFileCount;        // # of files in file group
    UINT cDatabases;        // # of database files
    UINT cLogFiles;            // # of log files
    UINT cDependencies;        // # of components that this component depends on
    } VSS_COMPONENTINFO;

typedef const VSS_COMPONENTINFO *PVSSCOMPONENTINFO;


// component information
class IVssWMComponent : public IUnknown
{
public:
    // get component information
    STDMETHOD(GetComponentInfo)
        (
        __out PVSSCOMPONENTINFO *ppInfo
        ) = 0;

    // free component information
    STDMETHOD(FreeComponentInfo)
        (
        __in PVSSCOMPONENTINFO pInfo
        ) = 0;

    // obtain a specific file in a file group
    STDMETHOD(GetFile)
        (
        __in UINT iFile,
        __out IVssWMFiledesc **ppFiledesc
        ) = 0;

    // obtain a specific physical database file for a database
    STDMETHOD(GetDatabaseFile)
        (
        __in UINT iDBFile,
        __out IVssWMFiledesc **ppFiledesc
        ) = 0;

    // obtain a specific physical log file for a database
    STDMETHOD(GetDatabaseLogFile)
        (
        __in UINT iDbLogFile,
        __out IVssWMFiledesc **ppFiledesc
        ) = 0;

    STDMETHOD(GetDependency)
        (
        __in UINT iDependency,
        __out IVssWMDependency **ppDependency
        ) = 0;
};


// interface to examine writer metadata
class __declspec(uuid("902fcf7f-b7fd-42f8-81f1-b2e400b1e5bd")) IVssExamineWriterMetadata : public IUnknown
    {
public:
    // obtain identity of the writer
    STDMETHOD(GetIdentity)
        (
        __out VSS_ID *pidInstance,
        __out VSS_ID *pidWriter,
        __out BSTR *pbstrWriterName,
        __out VSS_USAGE_TYPE *pUsage,
        __out VSS_SOURCE_TYPE *pSource
        ) = 0;

    // obtain number of include files, exclude files, and components
    STDMETHOD(GetFileCounts)
        (
        __out UINT *pcIncludeFiles,
        __out UINT *pcExcludeFiles,
        __out UINT *pcComponents
        ) = 0;

    // obtain specific include files
    STDMETHOD(GetIncludeFile)
        (
        __in UINT iFile,
        __out IVssWMFiledesc **ppFiledesc
        ) = 0;

    // obtain specific exclude files
    STDMETHOD(GetExcludeFile)
        (
        __in UINT iFile,
        __out IVssWMFiledesc **ppFiledesc
        ) = 0;

    // obtain specific component
    STDMETHOD(GetComponent)
        (
        __in UINT iComponent,
        __out IVssWMComponent **ppComponent
        ) = 0;

    // obtain restoration method
    STDMETHOD(GetRestoreMethod)
        (
        __out VSS_RESTOREMETHOD_ENUM *pMethod,
        __out BSTR *pbstrService,
        __out BSTR *pbstrUserProcedure,
        __out VSS_WRITERRESTORE_ENUM *pwriterRestore,
        __out bool *pbRebootRequired,
        __out UINT *pcMappings
        ) = 0;

    // obtain a specific alternative location mapping
    STDMETHOD(GetAlternateLocationMapping)
        (
        __in UINT iMapping,
        __out IVssWMFiledesc **ppFiledesc
        ) = 0;

    // get the backup schema
    STDMETHOD(GetBackupSchema)
        (
        __out DWORD *pdwSchemaMask
        ) = 0;

    // obtain reference to actual XML document
    STDMETHOD(GetDocument)
        (
        __out IXMLDOMDocument **pDoc
        ) = 0;

    // convert document to a XML string
    STDMETHOD(SaveAsXML)
        (
        __in BSTR *pbstrXML
        ) = 0;

    // load document from an XML string
    STDMETHOD(LoadFromXML)
        (
        __in BSTR bstrXML
        ) = 0;
};


class __declspec(uuid("0c0e5ec0-ca44-472b-b702-e652db1c0451")) IVssExamineWriterMetadataEx : public IVssExamineWriterMetadata
{
public:
    // obtain identity of the writer
    STDMETHOD(GetIdentityEx)
        (
        __out VSS_ID *pidInstance,
        __out VSS_ID *pidWriter,
        __out BSTR *pbstrWriterName,
        __out BSTR* pbstrInstanceName,
        __out VSS_USAGE_TYPE *pUsage,
        __out VSS_SOURCE_TYPE *pSource
        ) = 0;
};


class __declspec(uuid("ce115780-a611-431b-b57f-c38303ab6aee")) IVssExamineWriterMetadataEx2 : public IVssExamineWriterMetadataEx
{
public:
    STDMETHOD(GetVersion)
        (
        __out DWORD* pdwMajorVersion,
        __out DWORD* pdwMinorVersion
        ) = 0;

    STDMETHOD(GetExcludeFromSnapshotCount)
        (
        __out UINT* pcExcludedFromSnapshot
        ) = 0;

    // obtain specific exclude files
    STDMETHOD(GetExcludeFromSnapshotFile)
        (
        __in UINT iFile,
        __out IVssWMFiledesc **ppFiledesc
        ) = 0;
};

class IVssWriterComponentsExt :
    public IVssWriterComponents,
    public IUnknown
{
};


// backup components interface
class __declspec(uuid("665c1d5f-c218-414d-a05d-7fef5f9d5c86")) IVssBackupComponents : public IUnknown
{
public:
    // get count of writer components
    STDMETHOD(GetWriterComponentsCount)
        (
        __out UINT *pcComponents
        ) = 0;

    // obtain a specific writer component
    STDMETHOD(GetWriterComponents)
        (
        __in UINT iWriter,
        __out IVssWriterComponentsExt **ppWriter
        ) = 0;

    // initialize and create BACKUP_COMPONENTS document
    STDMETHOD(InitializeForBackup)
        (
        __in_opt BSTR bstrXML = NULL
        ) = 0;

    // set state describing backup
    STDMETHOD(SetBackupState)
        (
        __in bool bSelectComponents,
        __in bool bBackupBootableSystemState,
        __in VSS_BACKUP_TYPE backupType,
        __in bool bPartialFileSupport = false
        ) = 0;

    STDMETHOD(InitializeForRestore)
        (
        __in BSTR bstrXML
        ) = 0;

    // set state describing restore
    STDMETHOD(SetRestoreState)
        (
        __in VSS_RESTORE_TYPE restoreType
        ) = 0;

    // gather writer metadata
    STDMETHOD(GatherWriterMetadata)
        (
        __out IVssAsync **pAsync
        ) = 0;

    // get count of writers with metadata
    STDMETHOD(GetWriterMetadataCount)
        (
        __out UINT *pcWriters
        ) = 0;

    // get writer metadata for a specific writer
    STDMETHOD(GetWriterMetadata)
        (
        __in UINT iWriter,
        __out VSS_ID *pidInstance,
        __out IVssExamineWriterMetadata **ppMetadata
        ) = 0;

    // free writer metadata
    STDMETHOD(FreeWriterMetadata)() = 0;

    // add a component to the BACKUP_COMPONENTS document
    STDMETHOD(AddComponent)
        (
        __in VSS_ID instanceId,
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName
        ) = 0;

    // dispatch PrepareForBackup event to writers
    STDMETHOD(PrepareForBackup)
        (
        __out IVssAsync **ppAsync
        ) = 0;

    // abort the backup
    STDMETHOD(AbortBackup)() = 0;

    // dispatch the Identify event so writers can expose their metadata
    STDMETHOD(GatherWriterStatus)
        (
        __out IVssAsync **pAsync
        ) = 0;


    // get count of writers with status
    STDMETHOD(GetWriterStatusCount)
        (
        __out UINT *pcWriters
        ) = 0;

    STDMETHOD(FreeWriterStatus)() = 0;

    STDMETHOD(GetWriterStatus)
        (
        __in UINT iWriter,
        __out VSS_ID *pidInstance,
        __out VSS_ID *pidWriter,
        __out BSTR *pbstrWriter,
        __out VSS_WRITER_STATE *pnStatus,
        __out HRESULT *phResultFailure
        ) = 0;

    // indicate whether backup succeeded on a component
    STDMETHOD(SetBackupSucceeded)
        (
        __in VSS_ID instanceId,
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in bool bSucceded
        ) = 0;

    // set backup options for the writer
    STDMETHOD(SetBackupOptions)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in LPCWSTR wszBackupOptions
        ) = 0;

    // indicate that a given component is selected to be restored
    STDMETHOD(SetSelectedForRestore)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in bool bSelectedForRestore
        ) = 0;


    // set restore options for the writer
    STDMETHOD(SetRestoreOptions)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in LPCWSTR wszRestoreOptions
        ) = 0;

    // indicate that additional restores will follow
    STDMETHOD(SetAdditionalRestores)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in bool bAdditionalRestores
        ) = 0;


    // set the backup stamp that the differential or incremental
    // backup is based on
    STDMETHOD(SetPreviousBackupStamp)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in LPCWSTR wszPreviousBackupStamp
        ) = 0;



    // save BACKUP_COMPONENTS document as XML string
    STDMETHOD(SaveAsXML)
        (
        __in BSTR *pbstrXML
        ) = 0;

    // signal BackupComplete event to the writers
    STDMETHOD(BackupComplete)
        (
        __out IVssAsync **ppAsync
        ) = 0;

    // add an alternate mapping on restore
    STDMETHOD(AddAlternativeLocationMapping)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE componentType,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in LPCWSTR wszPath,
        __in LPCWSTR wszFilespec,
        __in bool bRecursive,
        __in LPCWSTR wszDestination
        ) = 0;

    // add a subcomponent to be restored
    STDMETHOD(AddRestoreSubcomponent)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE componentType,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in LPCWSTR wszSubComponentLogicalPath,
        __in LPCWSTR wszSubComponentName,
        __in bool bRepair
        ) = 0;

    // requestor indicates whether files were successfully restored
    STDMETHOD(SetFileRestoreStatus)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in VSS_FILE_RESTORE_STATUS status
        ) = 0;

    // add a new location target for a file to be restored
    STDMETHOD(AddNewTarget)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in LPCWSTR wszPath,
        __in LPCWSTR wszFileName, 
        __in bool bRecursive,
        __in LPCWSTR wszAlternatePath
        ) = 0;

    // add a new location for the ranges file in case it was restored to
    // a different location
    STDMETHOD(SetRangesFilePath)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName, 
        __in UINT iPartialFile,
        __in LPCWSTR wszRangesFile
        ) = 0;

    // signal PreRestore event to the writers
    STDMETHOD(PreRestore)
        (
        __out IVssAsync **ppAsync
        ) = 0;

    // signal PostRestore event to the writers
    STDMETHOD(PostRestore)
        (
        __out IVssAsync **ppAsync
        ) = 0;

    // Called to set the context for subsequent snapshot-related operations
    STDMETHOD(SetContext)
        (
        __in LONG lContext
        ) = 0;

    // start a snapshot set
    STDMETHOD(StartSnapshotSet)
        (
        __out VSS_ID *pSnapshotSetId
        ) = 0;

    // add a volume to a snapshot set
    STDMETHOD(AddToSnapshotSet)
    (
        __in_z VSS_PWSZ        pwszVolumeName,
        __in VSS_ID        ProviderId,
        __out VSS_ID        *pidSnapshot
        ) = 0;

    // create the snapshot set
    STDMETHOD(DoSnapshotSet)
    (
        __out IVssAsync**     ppAsync
        ) = 0;

    STDMETHOD(DeleteSnapshots)
        (
        __in VSS_ID        SourceObjectId,
        __in VSS_OBJECT_TYPE     eSourceObjectType,
        __in BOOL            bForceDelete,
        __in LONG*        plDeletedSnapshots,
        __in VSS_ID*        pNondeletedSnapshotID
        ) = 0;

    STDMETHOD(ImportSnapshots)
        (
        __out IVssAsync**        ppAsync
        ) = 0;

    STDMETHOD(BreakSnapshotSet)
        (
        __in VSS_ID            SnapshotSetId
        ) = 0;

    STDMETHOD(GetSnapshotProperties)
        (
        __in VSS_ID        SnapshotId,
        __out VSS_SNAPSHOT_PROP    *pProp
        ) = 0;

    STDMETHOD(Query)
        (
        __in VSS_ID        QueriedObjectId,
        __in VSS_OBJECT_TYPE    eQueriedObjectType,
        __in VSS_OBJECT_TYPE    eReturnedObjectsType,
        __in IVssEnumObject     **ppEnum
        ) = 0;

    STDMETHOD(IsVolumeSupported)
        (
        __in VSS_ID ProviderId,
        __in_z VSS_PWSZ pwszVolumeName,
        __in BOOL * pbSupportedByThisProvider
        ) = 0;

    STDMETHOD(DisableWriterClasses)
        (
        __in const VSS_ID *rgWriterClassId,
        __in UINT cClassId
        ) = 0;

    STDMETHOD(EnableWriterClasses)
        (
        __in const VSS_ID *rgWriterClassId,
        __in UINT cClassId
        ) = 0;

    STDMETHOD(DisableWriterInstances)
        (
        __in const VSS_ID *rgWriterInstanceId,
        __in UINT cInstanceId
        ) = 0;

    // called to expose a snapshot
    STDMETHOD(ExposeSnapshot)
        (
        __in VSS_ID SnapshotId,
        __in_z VSS_PWSZ wszPathFromRoot,
        __in LONG lAttributes,
        __in_z VSS_PWSZ wszExpose,
        __out_z VSS_PWSZ *pwszExposed
        ) = 0;

    STDMETHOD(RevertToSnapshot)
        (
        __in VSS_ID SnapshotId,
        __in BOOL bForceDismount
        ) = 0;

    STDMETHOD(QueryRevertStatus)
        (
        __in_z VSS_PWSZ pwszVolume,
        __out IVssAsync **ppAsync
        ) = 0;
};


class __declspec(uuid("963f03ad-9e4c-4a34-ac15-e4b6174e5036")) IVssBackupComponentsEx : public IVssBackupComponents
{
public:
    // get writer metadata for a specific writer
    STDMETHOD(GetWriterMetadataEx)
    (
        __in UINT iWriter,
        __out VSS_ID *pidInstance,
        __out IVssExamineWriterMetadataEx **ppMetadata
        ) = 0;

    // indicate that a given component is selected to be restored
    STDMETHOD(SetSelectedForRestoreEx)
    (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in bool bSelectedForRestore,
        __in VSS_ID instanceId = GUID_NULL
        ) = 0;
};


class __declspec(uuid("acfe2b3a-22c9-4ef8-bd03-2f9ca230084e")) IVssBackupComponentsEx2 : public IVssBackupComponentsEx
{
public:
    STDMETHOD(UnexposeSnapshot)
        (
        __in VSS_ID snapshotId
        ) = 0;

    STDMETHOD(SetAuthoritativeRestore)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in bool bAuth
        )= 0;

    STDMETHOD(SetRollForward)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in VSS_ROLLFORWARD_TYPE rollType,
        __in LPCWSTR wszRollForwardPoint
        )= 0;

    STDMETHOD(SetRestoreName)
        (
        __in VSS_ID writerId,
        __in VSS_COMPONENT_TYPE ct,
        __in LPCWSTR wszLogicalPath,
        __in LPCWSTR wszComponentName,
        __in LPCWSTR wszRestoreName
        ) = 0;

    STDMETHOD(BreakSnapshotSetEx)
        (
        __in VSS_ID SnapshotSetID,
        __in DWORD dwBreakFlags,
        __out IVssAsync** ppAsync
        ) = 0;

    STDMETHOD(PreFastRecovery)
        (
        __in VSS_ID SnapshotSetID,
        __in DWORD dwPreFastRecoveryFlags,
        __out IVssAsync** ppAsync
        ) = 0;

    STDMETHOD(FastRecovery)
        (
        __in VSS_ID SnapshotSetID,
        __in DWORD dwFastRecoveryFlags,
        __out IVssAsync** ppAsync
        ) = 0;
};


class __declspec(uuid("c191bfbc-b602-4675-8bd1-67d642f529d5")) IVssBackupComponentsEx3 : public IVssBackupComponentsEx2
{
public:

    STDMETHOD(GetWriterStatusEx)
        (
        __in UINT iWriter,
        __out VSS_ID *pidInstance,
        __out VSS_ID *pidWriter,
        __out BSTR *pbstrWriter,
        __out VSS_WRITER_STATE *pnStatus,
        __out HRESULT *phrFailureWriter,
        __out_opt HRESULT *phrApplication = NULL,
        __out_opt BSTR *pbstrApplicationMessage = NULL
        ) = 0;

    STDMETHOD(AddSnapshotToRecoverySet)
        (
        __in     VSS_ID    snapshotId,
        __in     DWORD     dwFlags,
        __in_opt VSS_PWSZ  pwszDestinationVolume = NULL
        ) = 0;

    STDMETHOD(RecoverSet)
        (
        __in          DWORD         dwFlags,
        __deref_out   IVssAsync**   ppAsync
        ) = 0;

    STDMETHOD(GetSessionId)
        (
        __out   VSS_ID      *idSession
        ) = 0;
};

#define VSS_SW_BOOTABLE_STATE   (1 << 0)

extern "C"  {
    HRESULT STDAPICALLTYPE CreateVssBackupComponentsInternal
        (
        __out IVssBackupComponents **ppBackup
        );

    HRESULT STDAPICALLTYPE CreateVssExamineWriterMetadataInternal
        (
        __in BSTR bstrXML,
        __out IVssExamineWriterMetadata **ppMetadata
        );


    HRESULT APIENTRY IsVolumeSnapshottedInternal
        (
        __in_z VSS_PWSZ  pwszVolumeName,
        __out BOOL    *pbSnapshotsPresent,
        __out LONG    *plSnapshotCapability
        );

/////////////////////////////////////////////////////////////////////
// Life-management methods for structure members

    void APIENTRY VssFreeSnapshotPropertiesInternal(
        __in VSS_SNAPSHOT_PROP*  pProp
        );


    HRESULT APIENTRY GetProviderMgmtInterfaceInternal(
        __in VSS_ID ProviderId,
        __in IID InterfaceId,
        __out IUnknown** ppItf
        );

    HRESULT APIENTRY ShouldBlockRevertInternal
        (
        __in LPCWSTR wszVolumeName,
        __out bool* pbBlock
        );
}

inline HRESULT  CreateVssBackupComponents
    (
    __out IVssBackupComponents **ppBackup
    )
{
    return CreateVssBackupComponentsInternal(ppBackup);
}

inline HRESULT CreateVssExamineWriterMetadata
    (
    __in BSTR bstrXML,
    __out IVssExamineWriterMetadata **ppMetadata
    )
{
    return CreateVssExamineWriterMetadataInternal(bstrXML, ppMetadata);
}

inline HRESULT IsVolumeSnapshotted
    (
    __in_z VSS_PWSZ  pwszVolumeName,
    __out BOOL    *pbSnapshotsPresent,
    __out LONG    *plSnapshotCapability
    )
{
    return IsVolumeSnapshottedInternal(pwszVolumeName, pbSnapshotsPresent, plSnapshotCapability);
}

inline void VssFreeSnapshotProperties
    (
    __in VSS_SNAPSHOT_PROP* pProp
    )
{
    return VssFreeSnapshotPropertiesInternal(pProp);
}

inline HRESULT GetProviderMgmtInterface
    (
    __in VSS_ID ProviderId,
    __in IID InterfaceId,
    __out IUnknown** ppItf
    )
{
    return GetProviderMgmtInterfaceInternal(ProviderId, InterfaceId, ppItf);
}

inline HRESULT ShouldBlockRevert
    (
    __in LPCWSTR wszVolumeName,
    __out bool* pbBlock
    )
{
    return ShouldBlockRevertInternal(wszVolumeName, pbBlock);
}


#endif // _VSBACKUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vsprov.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vsprov.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vsprov_h__
#define __vsprov_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVssSoftwareSnapshotProvider_FWD_DEFINED__
#define __IVssSoftwareSnapshotProvider_FWD_DEFINED__
typedef interface IVssSoftwareSnapshotProvider IVssSoftwareSnapshotProvider;
#endif 	/* __IVssSoftwareSnapshotProvider_FWD_DEFINED__ */


#ifndef __IVssProviderCreateSnapshotSet_FWD_DEFINED__
#define __IVssProviderCreateSnapshotSet_FWD_DEFINED__
typedef interface IVssProviderCreateSnapshotSet IVssProviderCreateSnapshotSet;
#endif 	/* __IVssProviderCreateSnapshotSet_FWD_DEFINED__ */


#ifndef __IVssProviderNotifications_FWD_DEFINED__
#define __IVssProviderNotifications_FWD_DEFINED__
typedef interface IVssProviderNotifications IVssProviderNotifications;
#endif 	/* __IVssProviderNotifications_FWD_DEFINED__ */


#ifndef __IVssHardwareSnapshotProvider_FWD_DEFINED__
#define __IVssHardwareSnapshotProvider_FWD_DEFINED__
typedef interface IVssHardwareSnapshotProvider IVssHardwareSnapshotProvider;
#endif 	/* __IVssHardwareSnapshotProvider_FWD_DEFINED__ */


#ifndef __IVssHardwareSnapshotProviderEx_FWD_DEFINED__
#define __IVssHardwareSnapshotProviderEx_FWD_DEFINED__
typedef interface IVssHardwareSnapshotProviderEx IVssHardwareSnapshotProviderEx;
#endif 	/* __IVssHardwareSnapshotProviderEx_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "vss.h"
#include "vdslun.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vsprov_0000_0000 */
/* [local] */ 



typedef VSS_PWSZ *PVSS_PWSZ;



extern RPC_IF_HANDLE __MIDL_itf_vsprov_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vsprov_0000_0000_v0_0_s_ifspec;

#ifndef __IVssSoftwareSnapshotProvider_INTERFACE_DEFINED__
#define __IVssSoftwareSnapshotProvider_INTERFACE_DEFINED__

/* interface IVssSoftwareSnapshotProvider */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssSoftwareSnapshotProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("609e123e-2c5a-44d3-8f01-0b1d9a47d1ff")
    IVssSoftwareSnapshotProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ LONG lContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapshotProperties( 
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ __RPC__out VSS_SNAPSHOT_PROP *pProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Query( 
            /* [in] */ VSS_ID QueriedObjectId,
            /* [in] */ VSS_OBJECT_TYPE eQueriedObjectType,
            /* [in] */ VSS_OBJECT_TYPE eReturnedObjectsType,
            /* [out] */ __RPC__deref_out_opt IVssEnumObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteSnapshots( 
            /* [in] */ VSS_ID SourceObjectId,
            /* [in] */ VSS_OBJECT_TYPE eSourceObjectType,
            /* [in] */ BOOL bForceDelete,
            /* [out] */ __RPC__out LONG *plDeletedSnapshots,
            /* [out] */ __RPC__out VSS_ID *pNondeletedSnapshotID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BeginPrepareSnapshot( 
            /* [in] */ VSS_ID SnapshotSetId,
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ LONG lNewContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsVolumeSupported( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__out BOOL *pbSupportedByThisProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsVolumeSnapshotted( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__out BOOL *pbSnapshotsPresent,
            /* [out] */ __RPC__out LONG *plSnapshotCompatibility) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSnapshotProperty( 
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ VSS_SNAPSHOT_PROPERTY_ID eSnapshotPropertyId,
            /* [in] */ VARIANT vProperty) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RevertToSnapshot( 
            /* [in] */ VSS_ID SnapshotId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryRevertStatus( 
            /* [in] */ __RPC__in VSS_PWSZ pwszVolume,
            /* [out] */ __RPC__deref_out_opt IVssAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssSoftwareSnapshotProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssSoftwareSnapshotProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssSoftwareSnapshotProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssSoftwareSnapshotProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            __RPC__in IVssSoftwareSnapshotProvider * This,
            /* [in] */ LONG lContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSnapshotProperties )( 
            __RPC__in IVssSoftwareSnapshotProvider * This,
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ __RPC__out VSS_SNAPSHOT_PROP *pProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Query )( 
            __RPC__in IVssSoftwareSnapshotProvider * This,
            /* [in] */ VSS_ID QueriedObjectId,
            /* [in] */ VSS_OBJECT_TYPE eQueriedObjectType,
            /* [in] */ VSS_OBJECT_TYPE eReturnedObjectsType,
            /* [out] */ __RPC__deref_out_opt IVssEnumObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteSnapshots )( 
            __RPC__in IVssSoftwareSnapshotProvider * This,
            /* [in] */ VSS_ID SourceObjectId,
            /* [in] */ VSS_OBJECT_TYPE eSourceObjectType,
            /* [in] */ BOOL bForceDelete,
            /* [out] */ __RPC__out LONG *plDeletedSnapshots,
            /* [out] */ __RPC__out VSS_ID *pNondeletedSnapshotID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BeginPrepareSnapshot )( 
            __RPC__in IVssSoftwareSnapshotProvider * This,
            /* [in] */ VSS_ID SnapshotSetId,
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [in] */ LONG lNewContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsVolumeSupported )( 
            __RPC__in IVssSoftwareSnapshotProvider * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__out BOOL *pbSupportedByThisProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsVolumeSnapshotted )( 
            __RPC__in IVssSoftwareSnapshotProvider * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolumeName,
            /* [out] */ __RPC__out BOOL *pbSnapshotsPresent,
            /* [out] */ __RPC__out LONG *plSnapshotCompatibility);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSnapshotProperty )( 
            __RPC__in IVssSoftwareSnapshotProvider * This,
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ VSS_SNAPSHOT_PROPERTY_ID eSnapshotPropertyId,
            /* [in] */ VARIANT vProperty);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RevertToSnapshot )( 
            __RPC__in IVssSoftwareSnapshotProvider * This,
            /* [in] */ VSS_ID SnapshotId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryRevertStatus )( 
            __RPC__in IVssSoftwareSnapshotProvider * This,
            /* [in] */ __RPC__in VSS_PWSZ pwszVolume,
            /* [out] */ __RPC__deref_out_opt IVssAsync **ppAsync);
        
        END_INTERFACE
    } IVssSoftwareSnapshotProviderVtbl;

    interface IVssSoftwareSnapshotProvider
    {
        CONST_VTBL struct IVssSoftwareSnapshotProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssSoftwareSnapshotProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssSoftwareSnapshotProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssSoftwareSnapshotProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssSoftwareSnapshotProvider_SetContext(This,lContext)	\
    ( (This)->lpVtbl -> SetContext(This,lContext) ) 

#define IVssSoftwareSnapshotProvider_GetSnapshotProperties(This,SnapshotId,pProp)	\
    ( (This)->lpVtbl -> GetSnapshotProperties(This,SnapshotId,pProp) ) 

#define IVssSoftwareSnapshotProvider_Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum)	\
    ( (This)->lpVtbl -> Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum) ) 

#define IVssSoftwareSnapshotProvider_DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID)	\
    ( (This)->lpVtbl -> DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID) ) 

#define IVssSoftwareSnapshotProvider_BeginPrepareSnapshot(This,SnapshotSetId,SnapshotId,pwszVolumeName,lNewContext)	\
    ( (This)->lpVtbl -> BeginPrepareSnapshot(This,SnapshotSetId,SnapshotId,pwszVolumeName,lNewContext) ) 

#define IVssSoftwareSnapshotProvider_IsVolumeSupported(This,pwszVolumeName,pbSupportedByThisProvider)	\
    ( (This)->lpVtbl -> IsVolumeSupported(This,pwszVolumeName,pbSupportedByThisProvider) ) 

#define IVssSoftwareSnapshotProvider_IsVolumeSnapshotted(This,pwszVolumeName,pbSnapshotsPresent,plSnapshotCompatibility)	\
    ( (This)->lpVtbl -> IsVolumeSnapshotted(This,pwszVolumeName,pbSnapshotsPresent,plSnapshotCompatibility) ) 

#define IVssSoftwareSnapshotProvider_SetSnapshotProperty(This,SnapshotId,eSnapshotPropertyId,vProperty)	\
    ( (This)->lpVtbl -> SetSnapshotProperty(This,SnapshotId,eSnapshotPropertyId,vProperty) ) 

#define IVssSoftwareSnapshotProvider_RevertToSnapshot(This,SnapshotId)	\
    ( (This)->lpVtbl -> RevertToSnapshot(This,SnapshotId) ) 

#define IVssSoftwareSnapshotProvider_QueryRevertStatus(This,pwszVolume,ppAsync)	\
    ( (This)->lpVtbl -> QueryRevertStatus(This,pwszVolume,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssSoftwareSnapshotProvider_INTERFACE_DEFINED__ */


#ifndef __IVssProviderCreateSnapshotSet_INTERFACE_DEFINED__
#define __IVssProviderCreateSnapshotSet_INTERFACE_DEFINED__

/* interface IVssProviderCreateSnapshotSet */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssProviderCreateSnapshotSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5F894E5B-1E39-4778-8E23-9ABAD9F0E08C")
    IVssProviderCreateSnapshotSet : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EndPrepareSnapshots( 
            /* [in] */ VSS_ID SnapshotSetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PreCommitSnapshots( 
            /* [in] */ VSS_ID SnapshotSetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CommitSnapshots( 
            /* [in] */ VSS_ID SnapshotSetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PostCommitSnapshots( 
            /* [in] */ VSS_ID SnapshotSetId,
            /* [in] */ LONG lSnapshotsCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PreFinalCommitSnapshots( 
            /* [in] */ VSS_ID SnapshotSetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PostFinalCommitSnapshots( 
            /* [in] */ VSS_ID SnapshotSetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AbortSnapshots( 
            /* [in] */ VSS_ID SnapshotSetId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssProviderCreateSnapshotSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssProviderCreateSnapshotSet * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssProviderCreateSnapshotSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssProviderCreateSnapshotSet * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EndPrepareSnapshots )( 
            __RPC__in IVssProviderCreateSnapshotSet * This,
            /* [in] */ VSS_ID SnapshotSetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PreCommitSnapshots )( 
            __RPC__in IVssProviderCreateSnapshotSet * This,
            /* [in] */ VSS_ID SnapshotSetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CommitSnapshots )( 
            __RPC__in IVssProviderCreateSnapshotSet * This,
            /* [in] */ VSS_ID SnapshotSetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PostCommitSnapshots )( 
            __RPC__in IVssProviderCreateSnapshotSet * This,
            /* [in] */ VSS_ID SnapshotSetId,
            /* [in] */ LONG lSnapshotsCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PreFinalCommitSnapshots )( 
            __RPC__in IVssProviderCreateSnapshotSet * This,
            /* [in] */ VSS_ID SnapshotSetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PostFinalCommitSnapshots )( 
            __RPC__in IVssProviderCreateSnapshotSet * This,
            /* [in] */ VSS_ID SnapshotSetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AbortSnapshots )( 
            __RPC__in IVssProviderCreateSnapshotSet * This,
            /* [in] */ VSS_ID SnapshotSetId);
        
        END_INTERFACE
    } IVssProviderCreateSnapshotSetVtbl;

    interface IVssProviderCreateSnapshotSet
    {
        CONST_VTBL struct IVssProviderCreateSnapshotSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssProviderCreateSnapshotSet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssProviderCreateSnapshotSet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssProviderCreateSnapshotSet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssProviderCreateSnapshotSet_EndPrepareSnapshots(This,SnapshotSetId)	\
    ( (This)->lpVtbl -> EndPrepareSnapshots(This,SnapshotSetId) ) 

#define IVssProviderCreateSnapshotSet_PreCommitSnapshots(This,SnapshotSetId)	\
    ( (This)->lpVtbl -> PreCommitSnapshots(This,SnapshotSetId) ) 

#define IVssProviderCreateSnapshotSet_CommitSnapshots(This,SnapshotSetId)	\
    ( (This)->lpVtbl -> CommitSnapshots(This,SnapshotSetId) ) 

#define IVssProviderCreateSnapshotSet_PostCommitSnapshots(This,SnapshotSetId,lSnapshotsCount)	\
    ( (This)->lpVtbl -> PostCommitSnapshots(This,SnapshotSetId,lSnapshotsCount) ) 

#define IVssProviderCreateSnapshotSet_PreFinalCommitSnapshots(This,SnapshotSetId)	\
    ( (This)->lpVtbl -> PreFinalCommitSnapshots(This,SnapshotSetId) ) 

#define IVssProviderCreateSnapshotSet_PostFinalCommitSnapshots(This,SnapshotSetId)	\
    ( (This)->lpVtbl -> PostFinalCommitSnapshots(This,SnapshotSetId) ) 

#define IVssProviderCreateSnapshotSet_AbortSnapshots(This,SnapshotSetId)	\
    ( (This)->lpVtbl -> AbortSnapshots(This,SnapshotSetId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssProviderCreateSnapshotSet_INTERFACE_DEFINED__ */


#ifndef __IVssProviderNotifications_INTERFACE_DEFINED__
#define __IVssProviderNotifications_INTERFACE_DEFINED__

/* interface IVssProviderNotifications */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssProviderNotifications;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E561901F-03A5-4afe-86D0-72BAEECE7004")
    IVssProviderNotifications : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnLoad( 
            /* [unique][in] */ __RPC__in_opt IUnknown *pCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnUnload( 
            /* [in] */ BOOL bForceUnload) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssProviderNotificationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssProviderNotifications * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssProviderNotifications * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssProviderNotifications * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnLoad )( 
            __RPC__in IVssProviderNotifications * This,
            /* [unique][in] */ __RPC__in_opt IUnknown *pCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnUnload )( 
            __RPC__in IVssProviderNotifications * This,
            /* [in] */ BOOL bForceUnload);
        
        END_INTERFACE
    } IVssProviderNotificationsVtbl;

    interface IVssProviderNotifications
    {
        CONST_VTBL struct IVssProviderNotificationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssProviderNotifications_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssProviderNotifications_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssProviderNotifications_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssProviderNotifications_OnLoad(This,pCallback)	\
    ( (This)->lpVtbl -> OnLoad(This,pCallback) ) 

#define IVssProviderNotifications_OnUnload(This,bForceUnload)	\
    ( (This)->lpVtbl -> OnUnload(This,bForceUnload) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssProviderNotifications_INTERFACE_DEFINED__ */


#ifndef __IVssHardwareSnapshotProvider_INTERFACE_DEFINED__
#define __IVssHardwareSnapshotProvider_INTERFACE_DEFINED__

/* interface IVssHardwareSnapshotProvider */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssHardwareSnapshotProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9593A157-44E9-4344-BBEB-44FBF9B06B10")
    IVssHardwareSnapshotProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AreLunsSupported( 
            /* [in] */ LONG lLunCount,
            /* [in] */ LONG lContext,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VSS_PWSZ *rgwszDevices,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(lLunCount) VDS_LUN_INFORMATION *pLunInformation,
            /* [out] */ __RPC__out BOOL *pbIsSupported) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FillInLunInfo( 
            /* [in] */ __RPC__in VSS_PWSZ wszDeviceName,
            /* [out][in] */ __RPC__inout VDS_LUN_INFORMATION *pLunInfo,
            /* [out] */ __RPC__out BOOL *pbIsSupported) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BeginPrepareSnapshot( 
            /* [in] */ VSS_ID SnapshotSetId,
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ LONG lContext,
            /* [in] */ LONG lLunCount,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VSS_PWSZ *rgDeviceNames,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(lLunCount) VDS_LUN_INFORMATION *rgLunInformation) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTargetLuns( 
            /* [in] */ LONG lLunCount,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VSS_PWSZ *rgDeviceNames,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VDS_LUN_INFORMATION *rgSourceLuns,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(lLunCount) VDS_LUN_INFORMATION *rgDestinationLuns) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LocateLuns( 
            /* [in] */ LONG lLunCount,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VDS_LUN_INFORMATION *rgSourceLuns) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnLunEmpty( 
            /* [unique][in] */ __RPC__in_opt VSS_PWSZ wszDeviceName,
            /* [unique][in] */ __RPC__in_opt VDS_LUN_INFORMATION *pInformation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssHardwareSnapshotProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssHardwareSnapshotProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssHardwareSnapshotProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssHardwareSnapshotProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AreLunsSupported )( 
            __RPC__in IVssHardwareSnapshotProvider * This,
            /* [in] */ LONG lLunCount,
            /* [in] */ LONG lContext,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VSS_PWSZ *rgwszDevices,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(lLunCount) VDS_LUN_INFORMATION *pLunInformation,
            /* [out] */ __RPC__out BOOL *pbIsSupported);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FillInLunInfo )( 
            __RPC__in IVssHardwareSnapshotProvider * This,
            /* [in] */ __RPC__in VSS_PWSZ wszDeviceName,
            /* [out][in] */ __RPC__inout VDS_LUN_INFORMATION *pLunInfo,
            /* [out] */ __RPC__out BOOL *pbIsSupported);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BeginPrepareSnapshot )( 
            __RPC__in IVssHardwareSnapshotProvider * This,
            /* [in] */ VSS_ID SnapshotSetId,
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ LONG lContext,
            /* [in] */ LONG lLunCount,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VSS_PWSZ *rgDeviceNames,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(lLunCount) VDS_LUN_INFORMATION *rgLunInformation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTargetLuns )( 
            __RPC__in IVssHardwareSnapshotProvider * This,
            /* [in] */ LONG lLunCount,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VSS_PWSZ *rgDeviceNames,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VDS_LUN_INFORMATION *rgSourceLuns,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(lLunCount) VDS_LUN_INFORMATION *rgDestinationLuns);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LocateLuns )( 
            __RPC__in IVssHardwareSnapshotProvider * This,
            /* [in] */ LONG lLunCount,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VDS_LUN_INFORMATION *rgSourceLuns);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnLunEmpty )( 
            __RPC__in IVssHardwareSnapshotProvider * This,
            /* [unique][in] */ __RPC__in_opt VSS_PWSZ wszDeviceName,
            /* [unique][in] */ __RPC__in_opt VDS_LUN_INFORMATION *pInformation);
        
        END_INTERFACE
    } IVssHardwareSnapshotProviderVtbl;

    interface IVssHardwareSnapshotProvider
    {
        CONST_VTBL struct IVssHardwareSnapshotProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssHardwareSnapshotProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssHardwareSnapshotProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssHardwareSnapshotProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssHardwareSnapshotProvider_AreLunsSupported(This,lLunCount,lContext,rgwszDevices,pLunInformation,pbIsSupported)	\
    ( (This)->lpVtbl -> AreLunsSupported(This,lLunCount,lContext,rgwszDevices,pLunInformation,pbIsSupported) ) 

#define IVssHardwareSnapshotProvider_FillInLunInfo(This,wszDeviceName,pLunInfo,pbIsSupported)	\
    ( (This)->lpVtbl -> FillInLunInfo(This,wszDeviceName,pLunInfo,pbIsSupported) ) 

#define IVssHardwareSnapshotProvider_BeginPrepareSnapshot(This,SnapshotSetId,SnapshotId,lContext,lLunCount,rgDeviceNames,rgLunInformation)	\
    ( (This)->lpVtbl -> BeginPrepareSnapshot(This,SnapshotSetId,SnapshotId,lContext,lLunCount,rgDeviceNames,rgLunInformation) ) 

#define IVssHardwareSnapshotProvider_GetTargetLuns(This,lLunCount,rgDeviceNames,rgSourceLuns,rgDestinationLuns)	\
    ( (This)->lpVtbl -> GetTargetLuns(This,lLunCount,rgDeviceNames,rgSourceLuns,rgDestinationLuns) ) 

#define IVssHardwareSnapshotProvider_LocateLuns(This,lLunCount,rgSourceLuns)	\
    ( (This)->lpVtbl -> LocateLuns(This,lLunCount,rgSourceLuns) ) 

#define IVssHardwareSnapshotProvider_OnLunEmpty(This,wszDeviceName,pInformation)	\
    ( (This)->lpVtbl -> OnLunEmpty(This,wszDeviceName,pInformation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssHardwareSnapshotProvider_INTERFACE_DEFINED__ */


#ifndef __IVssHardwareSnapshotProviderEx_INTERFACE_DEFINED__
#define __IVssHardwareSnapshotProviderEx_INTERFACE_DEFINED__

/* interface IVssHardwareSnapshotProviderEx */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssHardwareSnapshotProviderEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7F5BA925-CDB1-4d11-A71F-339EB7E709FD")
    IVssHardwareSnapshotProviderEx : public IVssHardwareSnapshotProvider
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProviderCapabilities( 
            /* [out] */ __RPC__out ULONGLONG *pllOriginalCapabilityMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnLunStateChange( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwCount) VDS_LUN_INFORMATION *pSnapshotLuns,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwCount) VDS_LUN_INFORMATION *pOriginalLuns,
            /* [in] */ DWORD dwCount,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResyncLuns( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwCount) VDS_LUN_INFORMATION *pSourceLuns,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwCount) VDS_LUN_INFORMATION *pTargetLuns,
            /* [in] */ DWORD dwCount,
            /* [out] */ __RPC__deref_out_opt IVssAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnReuseLuns( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwCount) VDS_LUN_INFORMATION *pSnapshotLuns,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwCount) VDS_LUN_INFORMATION *pOriginalLuns,
            /* [in] */ DWORD dwCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssHardwareSnapshotProviderExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AreLunsSupported )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This,
            /* [in] */ LONG lLunCount,
            /* [in] */ LONG lContext,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VSS_PWSZ *rgwszDevices,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(lLunCount) VDS_LUN_INFORMATION *pLunInformation,
            /* [out] */ __RPC__out BOOL *pbIsSupported);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FillInLunInfo )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This,
            /* [in] */ __RPC__in VSS_PWSZ wszDeviceName,
            /* [out][in] */ __RPC__inout VDS_LUN_INFORMATION *pLunInfo,
            /* [out] */ __RPC__out BOOL *pbIsSupported);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BeginPrepareSnapshot )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This,
            /* [in] */ VSS_ID SnapshotSetId,
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ LONG lContext,
            /* [in] */ LONG lLunCount,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VSS_PWSZ *rgDeviceNames,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(lLunCount) VDS_LUN_INFORMATION *rgLunInformation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTargetLuns )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This,
            /* [in] */ LONG lLunCount,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VSS_PWSZ *rgDeviceNames,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VDS_LUN_INFORMATION *rgSourceLuns,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(lLunCount) VDS_LUN_INFORMATION *rgDestinationLuns);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LocateLuns )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This,
            /* [in] */ LONG lLunCount,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lLunCount) VDS_LUN_INFORMATION *rgSourceLuns);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnLunEmpty )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This,
            /* [unique][in] */ __RPC__in_opt VSS_PWSZ wszDeviceName,
            /* [unique][in] */ __RPC__in_opt VDS_LUN_INFORMATION *pInformation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProviderCapabilities )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This,
            /* [out] */ __RPC__out ULONGLONG *pllOriginalCapabilityMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnLunStateChange )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwCount) VDS_LUN_INFORMATION *pSnapshotLuns,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwCount) VDS_LUN_INFORMATION *pOriginalLuns,
            /* [in] */ DWORD dwCount,
            /* [in] */ DWORD dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ResyncLuns )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwCount) VDS_LUN_INFORMATION *pSourceLuns,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwCount) VDS_LUN_INFORMATION *pTargetLuns,
            /* [in] */ DWORD dwCount,
            /* [out] */ __RPC__deref_out_opt IVssAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnReuseLuns )( 
            __RPC__in IVssHardwareSnapshotProviderEx * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwCount) VDS_LUN_INFORMATION *pSnapshotLuns,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwCount) VDS_LUN_INFORMATION *pOriginalLuns,
            /* [in] */ DWORD dwCount);
        
        END_INTERFACE
    } IVssHardwareSnapshotProviderExVtbl;

    interface IVssHardwareSnapshotProviderEx
    {
        CONST_VTBL struct IVssHardwareSnapshotProviderExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssHardwareSnapshotProviderEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssHardwareSnapshotProviderEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssHardwareSnapshotProviderEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssHardwareSnapshotProviderEx_AreLunsSupported(This,lLunCount,lContext,rgwszDevices,pLunInformation,pbIsSupported)	\
    ( (This)->lpVtbl -> AreLunsSupported(This,lLunCount,lContext,rgwszDevices,pLunInformation,pbIsSupported) ) 

#define IVssHardwareSnapshotProviderEx_FillInLunInfo(This,wszDeviceName,pLunInfo,pbIsSupported)	\
    ( (This)->lpVtbl -> FillInLunInfo(This,wszDeviceName,pLunInfo,pbIsSupported) ) 

#define IVssHardwareSnapshotProviderEx_BeginPrepareSnapshot(This,SnapshotSetId,SnapshotId,lContext,lLunCount,rgDeviceNames,rgLunInformation)	\
    ( (This)->lpVtbl -> BeginPrepareSnapshot(This,SnapshotSetId,SnapshotId,lContext,lLunCount,rgDeviceNames,rgLunInformation) ) 

#define IVssHardwareSnapshotProviderEx_GetTargetLuns(This,lLunCount,rgDeviceNames,rgSourceLuns,rgDestinationLuns)	\
    ( (This)->lpVtbl -> GetTargetLuns(This,lLunCount,rgDeviceNames,rgSourceLuns,rgDestinationLuns) ) 

#define IVssHardwareSnapshotProviderEx_LocateLuns(This,lLunCount,rgSourceLuns)	\
    ( (This)->lpVtbl -> LocateLuns(This,lLunCount,rgSourceLuns) ) 

#define IVssHardwareSnapshotProviderEx_OnLunEmpty(This,wszDeviceName,pInformation)	\
    ( (This)->lpVtbl -> OnLunEmpty(This,wszDeviceName,pInformation) ) 


#define IVssHardwareSnapshotProviderEx_GetProviderCapabilities(This,pllOriginalCapabilityMask)	\
    ( (This)->lpVtbl -> GetProviderCapabilities(This,pllOriginalCapabilityMask) ) 

#define IVssHardwareSnapshotProviderEx_OnLunStateChange(This,pSnapshotLuns,pOriginalLuns,dwCount,dwFlags)	\
    ( (This)->lpVtbl -> OnLunStateChange(This,pSnapshotLuns,pOriginalLuns,dwCount,dwFlags) ) 

#define IVssHardwareSnapshotProviderEx_ResyncLuns(This,pSourceLuns,pTargetLuns,dwCount,ppAsync)	\
    ( (This)->lpVtbl -> ResyncLuns(This,pSourceLuns,pTargetLuns,dwCount,ppAsync) ) 

#define IVssHardwareSnapshotProviderEx_OnReuseLuns(This,pSnapshotLuns,pOriginalLuns,dwCount)	\
    ( (This)->lpVtbl -> OnReuseLuns(This,pSnapshotLuns,pOriginalLuns,dwCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssHardwareSnapshotProviderEx_INTERFACE_DEFINED__ */



#ifndef __VSSProvider_LIBRARY_DEFINED__
#define __VSSProvider_LIBRARY_DEFINED__

/* library VSSProvider */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_VSSProvider;
#endif /* __VSSProvider_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vss.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vss.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vss_h__
#define __vss_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVssEnumObject_FWD_DEFINED__
#define __IVssEnumObject_FWD_DEFINED__
typedef interface IVssEnumObject IVssEnumObject;
#endif 	/* __IVssEnumObject_FWD_DEFINED__ */


#ifndef __IVssAsync_FWD_DEFINED__
#define __IVssAsync_FWD_DEFINED__
typedef interface IVssAsync IVssAsync;
#endif 	/* __IVssAsync_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vss_0000_0000 */
/* [local] */ 


#pragma pack(push, 8)
#include "vsserror.h" 


typedef 
enum _VSS_OBJECT_TYPE
    {	VSS_OBJECT_UNKNOWN	= 0,
	VSS_OBJECT_NONE	= ( VSS_OBJECT_UNKNOWN + 1 ) ,
	VSS_OBJECT_SNAPSHOT_SET	= ( VSS_OBJECT_NONE + 1 ) ,
	VSS_OBJECT_SNAPSHOT	= ( VSS_OBJECT_SNAPSHOT_SET + 1 ) ,
	VSS_OBJECT_PROVIDER	= ( VSS_OBJECT_SNAPSHOT + 1 ) ,
	VSS_OBJECT_TYPE_COUNT	= ( VSS_OBJECT_PROVIDER + 1 ) 
    } 	VSS_OBJECT_TYPE;

typedef enum _VSS_OBJECT_TYPE *PVSS_OBJECT_TYPE;

typedef 
enum _VSS_SNAPSHOT_STATE
    {	VSS_SS_UNKNOWN	= 0,
	VSS_SS_PREPARING	= ( VSS_SS_UNKNOWN + 1 ) ,
	VSS_SS_PROCESSING_PREPARE	= ( VSS_SS_PREPARING + 1 ) ,
	VSS_SS_PREPARED	= ( VSS_SS_PROCESSING_PREPARE + 1 ) ,
	VSS_SS_PROCESSING_PRECOMMIT	= ( VSS_SS_PREPARED + 1 ) ,
	VSS_SS_PRECOMMITTED	= ( VSS_SS_PROCESSING_PRECOMMIT + 1 ) ,
	VSS_SS_PROCESSING_COMMIT	= ( VSS_SS_PRECOMMITTED + 1 ) ,
	VSS_SS_COMMITTED	= ( VSS_SS_PROCESSING_COMMIT + 1 ) ,
	VSS_SS_PROCESSING_POSTCOMMIT	= ( VSS_SS_COMMITTED + 1 ) ,
	VSS_SS_PROCESSING_PREFINALCOMMIT	= ( VSS_SS_PROCESSING_POSTCOMMIT + 1 ) ,
	VSS_SS_PREFINALCOMMITTED	= ( VSS_SS_PROCESSING_PREFINALCOMMIT + 1 ) ,
	VSS_SS_PROCESSING_POSTFINALCOMMIT	= ( VSS_SS_PREFINALCOMMITTED + 1 ) ,
	VSS_SS_CREATED	= ( VSS_SS_PROCESSING_POSTFINALCOMMIT + 1 ) ,
	VSS_SS_ABORTED	= ( VSS_SS_CREATED + 1 ) ,
	VSS_SS_DELETED	= ( VSS_SS_ABORTED + 1 ) ,
	VSS_SS_POSTCOMMITTED	= ( VSS_SS_DELETED + 1 ) ,
	VSS_SS_COUNT	= ( VSS_SS_POSTCOMMITTED + 1 ) 
    } 	VSS_SNAPSHOT_STATE;

typedef enum _VSS_SNAPSHOT_STATE *PVSS_SNAPSHOT_STATE;

typedef 
enum _VSS_VOLUME_SNAPSHOT_ATTRIBUTES
    {	VSS_VOLSNAP_ATTR_PERSISTENT	= 0x1,
	VSS_VOLSNAP_ATTR_NO_AUTORECOVERY	= 0x2,
	VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE	= 0x4,
	VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE	= 0x8,
	VSS_VOLSNAP_ATTR_NO_WRITERS	= 0x10,
	VSS_VOLSNAP_ATTR_TRANSPORTABLE	= 0x20,
	VSS_VOLSNAP_ATTR_NOT_SURFACED	= 0x40,
	VSS_VOLSNAP_ATTR_NOT_TRANSACTED	= 0x80,
	VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED	= 0x10000,
	VSS_VOLSNAP_ATTR_DIFFERENTIAL	= 0x20000,
	VSS_VOLSNAP_ATTR_PLEX	= 0x40000,
	VSS_VOLSNAP_ATTR_IMPORTED	= 0x80000,
	VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY	= 0x100000,
	VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY	= 0x200000,
	VSS_VOLSNAP_ATTR_AUTORECOVER	= 0x400000,
	VSS_VOLSNAP_ATTR_ROLLBACK_RECOVERY	= 0x800000,
	VSS_VOLSNAP_ATTR_DELAYED_POSTSNAPSHOT	= 0x1000000,
	VSS_VOLSNAP_ATTR_TXF_RECOVERY	= 0x2000000
    } 	VSS_VOLUME_SNAPSHOT_ATTRIBUTES;

typedef enum _VSS_VOLUME_SNAPSHOT_ATTRIBUTES *PVSS_VOLUME_SNAPSHOT_ATTRIBUTES;

typedef 
enum _VSS_SNAPSHOT_CONTEXT
    {	VSS_CTX_BACKUP	= 0,
	VSS_CTX_FILE_SHARE_BACKUP	= VSS_VOLSNAP_ATTR_NO_WRITERS,
	VSS_CTX_NAS_ROLLBACK	= ( ( VSS_VOLSNAP_ATTR_PERSISTENT | VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE )  | VSS_VOLSNAP_ATTR_NO_WRITERS ) ,
	VSS_CTX_APP_ROLLBACK	= ( VSS_VOLSNAP_ATTR_PERSISTENT | VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE ) ,
	VSS_CTX_CLIENT_ACCESSIBLE	= ( ( ( VSS_VOLSNAP_ATTR_PERSISTENT | VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE )  | VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE )  | VSS_VOLSNAP_ATTR_NO_WRITERS ) ,
	VSS_CTX_CLIENT_ACCESSIBLE_WRITERS	= ( ( VSS_VOLSNAP_ATTR_PERSISTENT | VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE )  | VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE ) ,
	VSS_CTX_ALL	= 0xffffffff
    } 	VSS_SNAPSHOT_CONTEXT;

typedef enum _VSS_SNAPSHOT_CONTEXT *PVSS_SNAPSHOT_CONTEXT;

typedef 
enum _VSS_PROVIDER_CAPABILITIES
    {	VSS_PRV_CAPABILITY_LEGACY	= 0x1,
	VSS_PRV_CAPABILITY_COMPLIANT	= 0x2,
	VSS_PRV_CAPABILITY_LUN_REPOINT	= 0x4,
	VSS_PRV_CAPABILITY_LUN_RESYNC	= 0x8,
	VSS_PRV_CAPABILITY_OFFLINE_CREATION	= 0x10,
	VSS_PRV_CAPABILITY_MULTIPLE_IMPORT	= 0x20,
	VSS_PRV_CAPABILITY_RECYCLING	= 0x40,
	VSS_PRV_CAPABILITY_PLEX	= 0x80,
	VSS_PRV_CAPABILITY_DIFFERENTIAL	= 0x100,
	VSS_PRV_CAPABILITY_CLUSTERED	= 0x200
    } 	VSS_PROVIDER_CAPABILITIES;

typedef enum _VSS_PROVIDER_CAPABILITIES *PVSS_PROVIDER_CAPABILITIES;

typedef 
enum _VSS_HARDWARE_OPTIONS
    {	VSS_BREAKEX_FLAG_MASK_LUNS	= 0x1,
	VSS_BREAKEX_FLAG_MAKE_READ_WRITE	= 0x2,
	VSS_BREAKEX_FLAG_REVERT_IDENTITY_ALL	= 0x4,
	VSS_BREAKEX_FLAG_REVERT_IDENTITY_NONE	= 0x8,
	VSS_ONLUNSTATECHANGE_NOTIFY_READ_WRITE	= 0x100,
	VSS_ONLUNSTATECHANGE_NOTIFY_LUN_PRE_RECOVERY	= 0x200,
	VSS_ONLUNSTATECHANGE_NOTIFY_LUN_POST_RECOVERY	= 0x400,
	VSS_ONLUNSTATECHANGE_DO_MASK_LUNS	= 0x800
    } 	VSS_HARDWARE_OPTIONS;

typedef enum _VSS_HARDWARE_OPTIONS *PVSS_HARDWARE_OPTIONS;

typedef 
enum _VSS_RECOVERY_OPTIONS
    {	VSS_RECOVERY_REVERT_IDENTITY_ALL	= 0x100,
	VSS_RECOVERY_NO_VOLUME_CHECK	= 0x200
    } 	VSS_RECOVERY_OPTIONS;

typedef enum _VSS_RECOVERY_OPTIONS *PVSS_RECOVERY_OPTIONS;

typedef 
enum _VSS_WRITER_STATE
    {	VSS_WS_UNKNOWN	= 0,
	VSS_WS_STABLE	= ( VSS_WS_UNKNOWN + 1 ) ,
	VSS_WS_WAITING_FOR_FREEZE	= ( VSS_WS_STABLE + 1 ) ,
	VSS_WS_WAITING_FOR_THAW	= ( VSS_WS_WAITING_FOR_FREEZE + 1 ) ,
	VSS_WS_WAITING_FOR_POST_SNAPSHOT	= ( VSS_WS_WAITING_FOR_THAW + 1 ) ,
	VSS_WS_WAITING_FOR_BACKUP_COMPLETE	= ( VSS_WS_WAITING_FOR_POST_SNAPSHOT + 1 ) ,
	VSS_WS_FAILED_AT_IDENTIFY	= ( VSS_WS_WAITING_FOR_BACKUP_COMPLETE + 1 ) ,
	VSS_WS_FAILED_AT_PREPARE_BACKUP	= ( VSS_WS_FAILED_AT_IDENTIFY + 1 ) ,
	VSS_WS_FAILED_AT_PREPARE_SNAPSHOT	= ( VSS_WS_FAILED_AT_PREPARE_BACKUP + 1 ) ,
	VSS_WS_FAILED_AT_FREEZE	= ( VSS_WS_FAILED_AT_PREPARE_SNAPSHOT + 1 ) ,
	VSS_WS_FAILED_AT_THAW	= ( VSS_WS_FAILED_AT_FREEZE + 1 ) ,
	VSS_WS_FAILED_AT_POST_SNAPSHOT	= ( VSS_WS_FAILED_AT_THAW + 1 ) ,
	VSS_WS_FAILED_AT_BACKUP_COMPLETE	= ( VSS_WS_FAILED_AT_POST_SNAPSHOT + 1 ) ,
	VSS_WS_FAILED_AT_PRE_RESTORE	= ( VSS_WS_FAILED_AT_BACKUP_COMPLETE + 1 ) ,
	VSS_WS_FAILED_AT_POST_RESTORE	= ( VSS_WS_FAILED_AT_PRE_RESTORE + 1 ) ,
	VSS_WS_FAILED_AT_BACKUPSHUTDOWN	= ( VSS_WS_FAILED_AT_POST_RESTORE + 1 ) ,
	VSS_WS_COUNT	= ( VSS_WS_FAILED_AT_BACKUPSHUTDOWN + 1 ) 
    } 	VSS_WRITER_STATE;

typedef enum _VSS_WRITER_STATE *PVSS_WRITER_STATE;

typedef 
enum _VSS_BACKUP_TYPE
    {	VSS_BT_UNDEFINED	= 0,
	VSS_BT_FULL	= ( VSS_BT_UNDEFINED + 1 ) ,
	VSS_BT_INCREMENTAL	= ( VSS_BT_FULL + 1 ) ,
	VSS_BT_DIFFERENTIAL	= ( VSS_BT_INCREMENTAL + 1 ) ,
	VSS_BT_LOG	= ( VSS_BT_DIFFERENTIAL + 1 ) ,
	VSS_BT_COPY	= ( VSS_BT_LOG + 1 ) ,
	VSS_BT_OTHER	= ( VSS_BT_COPY + 1 ) 
    } 	VSS_BACKUP_TYPE;

typedef enum _VSS_BACKUP_TYPE *PVSS_BACKUP_TYPE;

typedef 
enum _VSS_RESTORE_TYPE
    {	VSS_RTYPE_UNDEFINED	= 0,
	VSS_RTYPE_BY_COPY	= ( VSS_RTYPE_UNDEFINED + 1 ) ,
	VSS_RTYPE_IMPORT	= ( VSS_RTYPE_BY_COPY + 1 ) ,
	VSS_RTYPE_OTHER	= ( VSS_RTYPE_IMPORT + 1 ) 
    } 	VSS_RESTORE_TYPE;

typedef enum _VSS_RESTORE_TYPE *PVSS_RESTORE_TYPE;

typedef 
enum _VSS_ROLLFORWARD_TYPE
    {	VSS_RF_UNDEFINED	= 0,
	VSS_RF_NONE	= ( VSS_RF_UNDEFINED + 1 ) ,
	VSS_RF_ALL	= ( VSS_RF_NONE + 1 ) ,
	VSS_RF_PARTIAL	= ( VSS_RF_ALL + 1 ) 
    } 	VSS_ROLLFORWARD_TYPE;

typedef enum _VSS_ROLLFORWARD_TYPE *PVSS_ROLLFORWARD_TYPE;

typedef 
enum _VSS_PROVIDER_TYPE
    {	VSS_PROV_UNKNOWN	= 0,
	VSS_PROV_SYSTEM	= 1,
	VSS_PROV_SOFTWARE	= 2,
	VSS_PROV_HARDWARE	= 3
    } 	VSS_PROVIDER_TYPE;

typedef enum _VSS_PROVIDER_TYPE *PVSS_PROVIDER_TYPE;

typedef 
enum _VSS_APPLICATION_LEVEL
    {	VSS_APP_UNKNOWN	= 0,
	VSS_APP_SYSTEM	= 1,
	VSS_APP_BACK_END	= 2,
	VSS_APP_FRONT_END	= 3,
	VSS_APP_SYSTEM_RM	= 4,
	VSS_APP_AUTO	= -1
    } 	VSS_APPLICATION_LEVEL;

typedef enum _VSS_APPLICATION_LEVEL *PVSS_APPLICATION_LEVEL;

typedef 
enum _VSS_SNAPSHOT_COMPATIBILITY
    {	VSS_SC_DISABLE_DEFRAG	= 0x1,
	VSS_SC_DISABLE_CONTENTINDEX	= 0x2
    } 	VSS_SNAPSHOT_COMPATIBILITY;

typedef 
enum _VSS_SNAPSHOT_PROPERTY_ID
    {	VSS_SPROPID_UNKNOWN	= 0,
	VSS_SPROPID_SNAPSHOT_ID	= 0x1,
	VSS_SPROPID_SNAPSHOT_SET_ID	= 0x2,
	VSS_SPROPID_SNAPSHOTS_COUNT	= 0x3,
	VSS_SPROPID_SNAPSHOT_DEVICE	= 0x4,
	VSS_SPROPID_ORIGINAL_VOLUME	= 0x5,
	VSS_SPROPID_ORIGINATING_MACHINE	= 0x6,
	VSS_SPROPID_SERVICE_MACHINE	= 0x7,
	VSS_SPROPID_EXPOSED_NAME	= 0x8,
	VSS_SPROPID_EXPOSED_PATH	= 0x9,
	VSS_SPROPID_PROVIDER_ID	= 0xa,
	VSS_SPROPID_SNAPSHOT_ATTRIBUTES	= 0xb,
	VSS_SPROPID_CREATION_TIMESTAMP	= 0xc,
	VSS_SPROPID_STATUS	= 0xd
    } 	VSS_SNAPSHOT_PROPERTY_ID;

typedef enum _VSS_SNAPSHOT_PROPERTY_ID *PVSS_SNAPSHOT_PROPERTY_ID;

typedef 
enum _VSS_FILE_SPEC_BACKUP_TYPE
    {	VSS_FSBT_FULL_BACKUP_REQUIRED	= 0x1,
	VSS_FSBT_DIFFERENTIAL_BACKUP_REQUIRED	= 0x2,
	VSS_FSBT_INCREMENTAL_BACKUP_REQUIRED	= 0x4,
	VSS_FSBT_LOG_BACKUP_REQUIRED	= 0x8,
	VSS_FSBT_FULL_SNAPSHOT_REQUIRED	= 0x100,
	VSS_FSBT_DIFFERENTIAL_SNAPSHOT_REQUIRED	= 0x200,
	VSS_FSBT_INCREMENTAL_SNAPSHOT_REQUIRED	= 0x400,
	VSS_FSBT_LOG_SNAPSHOT_REQUIRED	= 0x800,
	VSS_FSBT_ALL_BACKUP_REQUIRED	= 0xf,
	VSS_FSBT_ALL_SNAPSHOT_REQUIRED	= 0xf00
    } 	VSS_FILE_SPEC_BACKUP_TYPE;

typedef enum _VSS_FILE_SPEC_BACKUP_TYPE *PVSS_FILE_SPEC_BACKUP_TYPE;

typedef 
enum _VSS_BACKUP_SCHEMA
    {	VSS_BS_UNDEFINED	= 0,
	VSS_BS_DIFFERENTIAL	= 0x1,
	VSS_BS_INCREMENTAL	= 0x2,
	VSS_BS_EXCLUSIVE_INCREMENTAL_DIFFERENTIAL	= 0x4,
	VSS_BS_LOG	= 0x8,
	VSS_BS_COPY	= 0x10,
	VSS_BS_TIMESTAMPED	= 0x20,
	VSS_BS_LAST_MODIFY	= 0x40,
	VSS_BS_LSN	= 0x80,
	VSS_BS_WRITER_SUPPORTS_NEW_TARGET	= 0x100,
	VSS_BS_WRITER_SUPPORTS_RESTORE_WITH_MOVE	= 0x200,
	VSS_BS_INDEPENDENT_SYSTEM_STATE	= 0x400,
	VSS_BS_ROLLFORWARD_RESTORE	= 0x1000,
	VSS_BS_RESTORE_RENAME	= 0x2000,
	VSS_BS_AUTHORITATIVE_RESTORE	= 0x4000,
	VSS_BS_WRITER_SUPPORTS_PARALLEL_RESTORES	= 0x8000
    } 	VSS_BACKUP_SCHEMA;

typedef enum _VSS_BACKUP_SCHEMA *PVSS_BACKUP_SCHEMA;

typedef GUID VSS_ID;

typedef /* [string][unique] */  __RPC_unique_pointer  __RPC_string WCHAR *VSS_PWSZ;

typedef LONGLONG VSS_TIMESTAMP;

typedef struct _VSS_SNAPSHOT_PROP
    {
    VSS_ID m_SnapshotId;
    VSS_ID m_SnapshotSetId;
    LONG m_lSnapshotsCount;
    VSS_PWSZ m_pwszSnapshotDeviceObject;
    VSS_PWSZ m_pwszOriginalVolumeName;
    VSS_PWSZ m_pwszOriginatingMachine;
    VSS_PWSZ m_pwszServiceMachine;
    VSS_PWSZ m_pwszExposedName;
    VSS_PWSZ m_pwszExposedPath;
    VSS_ID m_ProviderId;
    LONG m_lSnapshotAttributes;
    VSS_TIMESTAMP m_tsCreationTimestamp;
    VSS_SNAPSHOT_STATE m_eStatus;
    } 	VSS_SNAPSHOT_PROP;

typedef struct _VSS_SNAPSHOT_PROP *PVSS_SNAPSHOT_PROP;

typedef struct _VSS_PROVIDER_PROP
    {
    VSS_ID m_ProviderId;
    VSS_PWSZ m_pwszProviderName;
    VSS_PROVIDER_TYPE m_eProviderType;
    VSS_PWSZ m_pwszProviderVersion;
    VSS_ID m_ProviderVersionId;
    CLSID m_ClassId;
    } 	VSS_PROVIDER_PROP;

typedef struct _VSS_PROVIDER_PROP *PVSS_PROVIDER_PROP;

typedef /* [public][public][public][public][switch_type] */ union __MIDL___MIDL_itf_vss_0000_0000_0001
    {
    VSS_SNAPSHOT_PROP Snap;
    VSS_PROVIDER_PROP Prov;
     /* Empty union arm */ 
    } 	VSS_OBJECT_UNION;

typedef struct _VSS_OBJECT_PROP
    {
    VSS_OBJECT_TYPE Type;
    VSS_OBJECT_UNION Obj;
    } 	VSS_OBJECT_PROP;

typedef struct _VSS_OBJECT_PROP *PVSS_OBJECT_PROP;



extern RPC_IF_HANDLE __MIDL_itf_vss_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vss_0000_0000_v0_0_s_ifspec;

#ifndef __IVssEnumObject_INTERFACE_DEFINED__
#define __IVssEnumObject_INTERFACE_DEFINED__

/* interface IVssEnumObject */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssEnumObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE1C7110-2F60-11d3-8A39-00C04F72D8E3")
    IVssEnumObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) VSS_OBJECT_PROP *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out][in] */ __RPC__deref_inout_opt IVssEnumObject **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssEnumObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssEnumObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssEnumObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssEnumObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IVssEnumObject * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) VSS_OBJECT_PROP *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IVssEnumObject * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IVssEnumObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IVssEnumObject * This,
            /* [out][in] */ __RPC__deref_inout_opt IVssEnumObject **ppenum);
        
        END_INTERFACE
    } IVssEnumObjectVtbl;

    interface IVssEnumObject
    {
        CONST_VTBL struct IVssEnumObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssEnumObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssEnumObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssEnumObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssEnumObject_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IVssEnumObject_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IVssEnumObject_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IVssEnumObject_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssEnumObject_INTERFACE_DEFINED__ */


#ifndef __IVssAsync_INTERFACE_DEFINED__
#define __IVssAsync_INTERFACE_DEFINED__

/* interface IVssAsync */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("507C37B4-CF5B-4e95-B0AF-14EB9767467E")
    IVssAsync : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Wait( 
            /* [defaultvalue][in] */ DWORD dwMilliseconds = 0xffffffff) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [unique][out][in] */ __RPC__inout_opt INT *pReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVssAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVssAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVssAsync * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in IVssAsync * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Wait )( 
            __RPC__in IVssAsync * This,
            /* [defaultvalue][in] */ DWORD dwMilliseconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            __RPC__in IVssAsync * This,
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [unique][out][in] */ __RPC__inout_opt INT *pReserved);
        
        END_INTERFACE
    } IVssAsyncVtbl;

    interface IVssAsync
    {
        CONST_VTBL struct IVssAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVssAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVssAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVssAsync_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IVssAsync_Wait(This,dwMilliseconds)	\
    ( (This)->lpVtbl -> Wait(This,dwMilliseconds) ) 

#define IVssAsync_QueryStatus(This,pHrResult,pReserved)	\
    ( (This)->lpVtbl -> QueryStatus(This,pHrResult,pReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVssAsync_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vss_0000_0002 */
/* [local] */ 


#pragma pack(pop)


extern RPC_IF_HANDLE __MIDL_itf_vss_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vss_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vssym32.h ===
//-------------------------------------------------------------------------//
//  VisualStyle Core Win32/ComCtl32 symbols
//-------------------------------------------------------------------------//

#ifndef __VSSYM32_H__
#define __VSSYM32_H__

#include "VSStyle.h"

//
//  enumerated property values
//

enum BGTYPE {
	BT_IMAGEFILE = 0,
	BT_BORDERFILL = 1,
	BT_NONE = 2,
};


//
//  enumerated property values
//

enum IMAGELAYOUT {
	IL_VERTICAL = 0,
	IL_HORIZONTAL = 1,
};


//
//  enumerated property values
//

enum BORDERTYPE {
	BT_RECT = 0,
	BT_ROUNDRECT = 1,
	BT_ELLIPSE = 2,
};


//
//  enumerated property values
//

enum FILLTYPE {
	FT_SOLID = 0,
	FT_VERTGRADIENT = 1,
	FT_HORZGRADIENT = 2,
	FT_RADIALGRADIENT = 3,
	FT_TILEIMAGE = 4,
};


//
//  enumerated property values
//

enum SIZINGTYPE {
	ST_TRUESIZE = 0,
	ST_STRETCH = 1,
	ST_TILE = 2,
};


//
//  enumerated property values
//

enum HALIGN {
	HA_LEFT = 0,
	HA_CENTER = 1,
	HA_RIGHT = 2,
};


//
//  enumerated property values
//

enum CONTENTALIGNMENT {
	CA_LEFT = 0,
	CA_CENTER = 1,
	CA_RIGHT = 2,
};


//
//  enumerated property values
//

enum VALIGN {
	VA_TOP = 0,
	VA_CENTER = 1,
	VA_BOTTOM = 2,
};


//
//  enumerated property values
//

enum OFFSETTYPE {
	OT_TOPLEFT = 0,
	OT_TOPRIGHT = 1,
	OT_TOPMIDDLE = 2,
	OT_BOTTOMLEFT = 3,
	OT_BOTTOMRIGHT = 4,
	OT_BOTTOMMIDDLE = 5,
	OT_MIDDLELEFT = 6,
	OT_MIDDLERIGHT = 7,
	OT_LEFTOFCAPTION = 8,
	OT_RIGHTOFCAPTION = 9,
	OT_LEFTOFLASTBUTTON = 10,
	OT_RIGHTOFLASTBUTTON = 11,
	OT_ABOVELASTBUTTON = 12,
	OT_BELOWLASTBUTTON = 13,
};


//
//  enumerated property values
//

enum ICONEFFECT {
	ICE_NONE = 0,
	ICE_GLOW = 1,
	ICE_SHADOW = 2,
	ICE_PULSE = 3,
	ICE_ALPHA = 4,
};


//
//  enumerated property values
//

enum TEXTSHADOWTYPE {
	TST_NONE = 0,
	TST_SINGLE = 1,
	TST_CONTINUOUS = 2,
};


//
//  enumerated property values
//

enum GLYPHTYPE {
	GT_NONE = 0,
	GT_IMAGEGLYPH = 1,
	GT_FONTGLYPH = 2,
};


//
//  enumerated property values
//

enum IMAGESELECTTYPE {
	IST_NONE = 0,
	IST_SIZE = 1,
	IST_DPI = 2,
};


//
//  enumerated property values
//

enum TRUESIZESCALINGTYPE {
	TSST_NONE = 0,
	TSST_SIZE = 1,
	TSST_DPI = 2,
};


//
//  enumerated property values
//

enum GLYPHFONTSIZINGTYPE {
	GFST_NONE = 0,
	GFST_SIZE = 1,
	GFST_DPI = 2,
};

//
//  property symbol definitions
//

#define TMT_RESERVEDLOW	0
#define TMT_RESERVEDHIGH	7999

#define TMT_DIBDATA	2
#define TMT_GLYPHDIBDATA	8
#define TMT_ENUM	200
#define TMT_STRING	201
#define TMT_INT	202
#define TMT_BOOL	203
#define TMT_COLOR	204
#define TMT_MARGINS	205
#define TMT_FILENAME	206
#define TMT_SIZE	207
#define TMT_POSITION	208
#define TMT_RECT	209
#define TMT_FONT	210
#define TMT_INTLIST	211
#define TMT_HBITMAP	212
#define TMT_DISKSTREAM	213
#define TMT_STREAM	214
#define TMT_BITMAPREF	215
#define TMT_COLORSCHEMES	401
#define TMT_SIZES	402
#define TMT_CHARSET	403
#define TMT_NAME	600
#define TMT_DISPLAYNAME	601
#define TMT_TOOLTIP	602
#define TMT_COMPANY	603
#define TMT_AUTHOR	604
#define TMT_COPYRIGHT	605
#define TMT_URL	606
#define TMT_VERSION	607
#define TMT_DESCRIPTION	608
#define TMT_FIRST_RCSTRING_NAME	TMT_DISPLAYNAME
#define TMT_LAST_RCSTRING_NAME	TMT_DESCRIPTION
#define TMT_CAPTIONFONT	801
#define TMT_SMALLCAPTIONFONT	802
#define TMT_MENUFONT	803
#define TMT_STATUSFONT	804
#define TMT_MSGBOXFONT	805
#define TMT_ICONTITLEFONT	806
#define TMT_HEADING1FONT	807
#define TMT_HEADING2FONT	808
#define TMT_BODYFONT	809
#define TMT_FIRSTFONT	TMT_CAPTIONFONT
#define TMT_LASTFONT	TMT_BODYFONT
#define TMT_FLATMENUS	1001
#define TMT_FIRSTBOOL	TMT_FLATMENUS
#define TMT_LASTBOOL	TMT_FLATMENUS
#define TMT_SIZINGBORDERWIDTH	1201
#define TMT_SCROLLBARWIDTH	1202
#define TMT_SCROLLBARHEIGHT	1203
#define TMT_CAPTIONBARWIDTH	1204
#define TMT_CAPTIONBARHEIGHT	1205
#define TMT_SMCAPTIONBARWIDTH	1206
#define TMT_SMCAPTIONBARHEIGHT	1207
#define TMT_MENUBARWIDTH	1208
#define TMT_MENUBARHEIGHT	1209
#define TMT_PADDEDBORDERWIDTH	1210
#define TMT_FIRSTSIZE	TMT_SIZINGBORDERWIDTH
#define TMT_LASTSIZE	TMT_PADDEDBORDERWIDTH
#define TMT_MINCOLORDEPTH	1301
#define TMT_FIRSTINT	TMT_MINCOLORDEPTH
#define TMT_LASTINT	TMT_MINCOLORDEPTH
#define TMT_CSSNAME	1401
#define TMT_XMLNAME	1402
#define TMT_LASTUPDATED	1403
#define TMT_ALIAS	1404
#define TMT_FIRSTSTRING	TMT_CSSNAME
#define TMT_LASTSTRING	TMT_ALIAS
#define TMT_SCROLLBAR	1601
#define TMT_BACKGROUND	1602
#define TMT_ACTIVECAPTION	1603
#define TMT_INACTIVECAPTION	1604
#define TMT_MENU	1605
#define TMT_WINDOW	1606
#define TMT_WINDOWFRAME	1607
#define TMT_MENUTEXT	1608
#define TMT_WINDOWTEXT	1609
#define TMT_CAPTIONTEXT	1610
#define TMT_ACTIVEBORDER	1611
#define TMT_INACTIVEBORDER	1612
#define TMT_APPWORKSPACE	1613
#define TMT_HIGHLIGHT	1614
#define TMT_HIGHLIGHTTEXT	1615
#define TMT_BTNFACE	1616
#define TMT_BTNSHADOW	1617
#define TMT_GRAYTEXT	1618
#define TMT_BTNTEXT	1619
#define TMT_INACTIVECAPTIONTEXT	1620
#define TMT_BTNHIGHLIGHT	1621
#define TMT_DKSHADOW3D	1622
#define TMT_LIGHT3D	1623
#define TMT_INFOTEXT	1624
#define TMT_INFOBK	1625
#define TMT_BUTTONALTERNATEFACE	1626
#define TMT_HOTTRACKING	1627
#define TMT_GRADIENTACTIVECAPTION	1628
#define TMT_GRADIENTINACTIVECAPTION	1629
#define TMT_MENUHILIGHT	1630
#define TMT_MENUBAR	1631
#define TMT_FIRSTCOLOR	TMT_SCROLLBAR
#define TMT_LASTCOLOR	TMT_MENUBAR
#define TMT_FROMHUE1	1801
#define TMT_FROMHUE2	1802
#define TMT_FROMHUE3	1803
#define TMT_FROMHUE4	1804
#define TMT_FROMHUE5	1805
#define TMT_TOHUE1	1806
#define TMT_TOHUE2	1807
#define TMT_TOHUE3	1808
#define TMT_TOHUE4	1809
#define TMT_TOHUE5	1810
#define TMT_FROMCOLOR1	2001
#define TMT_FROMCOLOR2	2002
#define TMT_FROMCOLOR3	2003
#define TMT_FROMCOLOR4	2004
#define TMT_FROMCOLOR5	2005
#define TMT_TOCOLOR1	2006
#define TMT_TOCOLOR2	2007
#define TMT_TOCOLOR3	2008
#define TMT_TOCOLOR4	2009
#define TMT_TOCOLOR5	2010
#define TMT_TRANSPARENT	2201
#define TMT_AUTOSIZE	2202
#define TMT_BORDERONLY	2203
#define TMT_COMPOSITED	2204
#define TMT_BGFILL	2205
#define TMT_GLYPHTRANSPARENT	2206
#define TMT_GLYPHONLY	2207
#define TMT_ALWAYSSHOWSIZINGBAR	2208
#define TMT_MIRRORIMAGE	2209
#define TMT_UNIFORMSIZING	2210
#define TMT_INTEGRALSIZING	2211
#define TMT_SOURCEGROW	2212
#define TMT_SOURCESHRINK	2213
#define TMT_DRAWBORDERS	2214
#define TMT_NOETCHEDEFFECT	2215
#define TMT_TEXTAPPLYOVERLAY	2216
#define TMT_TEXTGLOW	2217
#define TMT_TEXTITALIC	2218
#define TMT_COMPOSITEDOPAQUE	2219
#define TMT_LOCALIZEDMIRRORIMAGE	2220
#define TMT_IMAGECOUNT	2401
#define TMT_ALPHALEVEL	2402
#define TMT_BORDERSIZE	2403
#define TMT_ROUNDCORNERWIDTH	2404
#define TMT_ROUNDCORNERHEIGHT	2405
#define TMT_GRADIENTRATIO1	2406
#define TMT_GRADIENTRATIO2	2407
#define TMT_GRADIENTRATIO3	2408
#define TMT_GRADIENTRATIO4	2409
#define TMT_GRADIENTRATIO5	2410
#define TMT_PROGRESSCHUNKSIZE	2411
#define TMT_PROGRESSSPACESIZE	2412
#define TMT_SATURATION	2413
#define TMT_TEXTBORDERSIZE	2414
#define TMT_ALPHATHRESHOLD	2415
#define TMT_WIDTH	2416
#define TMT_HEIGHT	2417
#define TMT_GLYPHINDEX	2418
#define TMT_TRUESIZESTRETCHMARK	2419
#define TMT_MINDPI1	2420
#define TMT_MINDPI2	2421
#define TMT_MINDPI3	2422
#define TMT_MINDPI4	2423
#define TMT_MINDPI5	2424
#define TMT_TEXTGLOWSIZE	2425
#define TMT_FRAMESPERSECOND	2426
#define TMT_PIXELSPERFRAME	2427
#define TMT_ANIMATIONDELAY	2428
#define TMT_GLOWINTENSITY	2429
#define TMT_OPACITY	2430
#define TMT_COLORIZATIONCOLOR	2431
#define TMT_COLORIZATIONOPACITY	2432
#define TMT_GLYPHFONT	2601
#define TMT_IMAGEFILE	3001
#define TMT_IMAGEFILE1	3002
#define TMT_IMAGEFILE2	3003
#define TMT_IMAGEFILE3	3004
#define TMT_IMAGEFILE4	3005
#define TMT_IMAGEFILE5	3006
#define TMT_GLYPHIMAGEFILE	3008
#define TMT_TEXT	3201
#define TMT_CLASSICVALUE	3202
#define TMT_OFFSET	3401
#define TMT_TEXTSHADOWOFFSET	3402
#define TMT_MINSIZE	3403
#define TMT_MINSIZE1	3404
#define TMT_MINSIZE2	3405
#define TMT_MINSIZE3	3406
#define TMT_MINSIZE4	3407
#define TMT_MINSIZE5	3408
#define TMT_NORMALSIZE	3409
#define TMT_SIZINGMARGINS	3601
#define TMT_CONTENTMARGINS	3602
#define TMT_CAPTIONMARGINS	3603
#define TMT_BORDERCOLOR	3801
#define TMT_FILLCOLOR	3802
#define TMT_TEXTCOLOR	3803
#define TMT_EDGELIGHTCOLOR	3804
#define TMT_EDGEHIGHLIGHTCOLOR	3805
#define TMT_EDGESHADOWCOLOR	3806
#define TMT_EDGEDKSHADOWCOLOR	3807
#define TMT_EDGEFILLCOLOR	3808
#define TMT_TRANSPARENTCOLOR	3809
#define TMT_GRADIENTCOLOR1	3810
#define TMT_GRADIENTCOLOR2	3811
#define TMT_GRADIENTCOLOR3	3812
#define TMT_GRADIENTCOLOR4	3813
#define TMT_GRADIENTCOLOR5	3814
#define TMT_SHADOWCOLOR	3815
#define TMT_GLOWCOLOR	3816
#define TMT_TEXTBORDERCOLOR	3817
#define TMT_TEXTSHADOWCOLOR	3818
#define TMT_GLYPHTEXTCOLOR	3819
#define TMT_GLYPHTRANSPARENTCOLOR	3820
#define TMT_FILLCOLORHINT	3821
#define TMT_BORDERCOLORHINT	3822
#define TMT_ACCENTCOLORHINT	3823
#define TMT_TEXTCOLORHINT	3824
#define TMT_HEADING1TEXTCOLOR	3825
#define TMT_HEADING2TEXTCOLOR	3826
#define TMT_BODYTEXTCOLOR	3827
#define TMT_BGTYPE	4001
#define TMT_BORDERTYPE	4002
#define TMT_FILLTYPE	4003
#define TMT_SIZINGTYPE	4004
#define TMT_HALIGN	4005
#define TMT_CONTENTALIGNMENT	4006
#define TMT_VALIGN	4007
#define TMT_OFFSETTYPE	4008
#define TMT_ICONEFFECT	4009
#define TMT_TEXTSHADOWTYPE	4010
#define TMT_IMAGELAYOUT	4011
#define TMT_GLYPHTYPE	4012
#define TMT_IMAGESELECTTYPE	4013
#define TMT_GLYPHFONTSIZINGTYPE	4014
#define TMT_TRUESIZESCALINGTYPE	4015
#define TMT_USERPICTURE	5001
#define TMT_DEFAULTPANESIZE	5002
#define TMT_BLENDCOLOR	5003
#define TMT_CUSTOMSPLITRECT	5004
#define TMT_ANIMATIONBUTTONRECT	5005
#define TMT_ANIMATIONDURATION	5006
#define TMT_TRANSITIONDURATIONS	6000
#define TMT_SCALEDBACKGROUND	7001
#define TMT_ATLASIMAGE	8000
#define TMT_ATLASINPUTIMAGE	8001
#define TMT_ATLASRECT	8002


//
//  LINK class parts and states 
//
#define VSCLASS_LINK	L"LINK"

enum LINKPARTS {
	LP_HYPERLINK = 1,
};

enum HYPERLINKSTATES {
	HLS_NORMALTEXT = 1,
	HLS_LINKTEXT = 2,
};


//
//  EMPTYMARKUP class parts and states 
//
#define VSCLASS_EMPTYMARKUP	L"EMPTYMARKUP"

enum EMPTYMARKUPPARTS {
	EMP_MARKUPTEXT = 1,
};

enum MARKUPTEXTSTATES {
	EMT_NORMALTEXT = 1,
	EMT_LINKTEXT = 2,
};


//
//  STATIC class parts and states 
//
#define VSCLASS_STATIC	L"STATIC"

enum STATICPARTS {
	STAT_TEXT = 1,
};


//
//  PAGE class parts and states 
//
#define VSCLASS_PAGE	L"PAGE"

enum PAGEPARTS {
	PGRP_UP = 1,
	PGRP_DOWN = 2,
	PGRP_UPHORZ = 3,
	PGRP_DOWNHORZ = 4,
};


//
//  MONTHCAL class parts and states 
//
#define VSCLASS_MONTHCAL	L"MONTHCAL"

enum MONTHCALPARTS {
	MC_BACKGROUND = 1,
	MC_BORDERS = 2,
	MC_GRIDBACKGROUND = 3,
	MC_COLHEADERSPLITTER = 4,
	MC_GRIDCELLBACKGROUND = 5,
	MC_GRIDCELL = 6,
	MC_GRIDCELLUPPER = 7,
	MC_TRAILINGGRIDCELL = 8,
	MC_TRAILINGGRIDCELLUPPER = 9,
	MC_NAVNEXT = 10,
	MC_NAVPREV = 11,
};

enum GRIDCELLBACKGROUNDSTATES {
	MCGCB_SELECTED = 1,
	MCGCB_HOT = 2,
	MCGCB_SELECTEDHOT = 3,
	MCGCB_SELECTEDNOTFOCUSED = 4,
	MCGCB_TODAY = 5,
};

enum GRIDCELLSTATES {
	MCGC_HOT = 1,
	MCGC_HASSTATE = 2,
	MCGC_HASSTATEHOT = 3,
	MCGC_TODAY = 4,
};

enum GRIDCELLUPPERSTATES {
	MCGCU_HOT = 1,
	MCGCU_HASSTATE = 2,
	MCGCU_HASSTATEHOT = 3,
};

enum TRAILINGGRIDCELLSTATES {
	MCTGC_HOT = 1,
	MCTGC_HASSTATE = 2,
	MCTGC_HASSTATEHOT = 3,
	MCTGC_TODAY = 4,
};

enum TRAILINGGRIDCELLUPPERSTATES {
	MCTGCU_HOT = 1,
	MCTGCU_HASSTATE = 2,
	MCTGCU_HASSTATEHOT = 3,
};

enum NAVNEXTSTATES {
	MCNN_NORMAL = 1,
	MCNN_HOT = 2,
	MCNN_PRESSED = 3,
	MCNN_DISABLED = 4,
};

enum NAVPREVSTATES {
	MCNP_NORMAL = 1,
	MCNP_HOT = 2,
	MCNP_PRESSED = 3,
	MCNP_DISABLED = 4,
};


//
//  CLOCK class parts and states 
//
#define VSCLASS_CLOCK	L"CLOCK"

enum CLOCKPARTS {
	CLP_TIME = 1,
};

enum CLOCKSTATES {
	CLS_NORMAL = 1,
	CLS_HOT = 2,
	CLS_PRESSED = 3,
};


//
//  TRAYNOTIFY class parts and states 
//
#define VSCLASS_TRAYNOTIFY	L"TRAYNOTIFY"

enum TRAYNOTIFYPARTS {
	TNP_BACKGROUND = 1,
	TNP_ANIMBACKGROUND = 2,
};


//
//  TASKBAR class parts and states 
//
#define VSCLASS_TASKBAR	L"TASKBAR"

enum TASKBARPARTS {
	TBP_BACKGROUNDBOTTOM = 1,
	TBP_BACKGROUNDRIGHT = 2,
	TBP_BACKGROUNDTOP = 3,
	TBP_BACKGROUNDLEFT = 4,
	TBP_SIZINGBARBOTTOM = 5,
	TBP_SIZINGBARRIGHT = 6,
	TBP_SIZINGBARTOP = 7,
	TBP_SIZINGBARLEFT = 8,
};


//
//  TASKBAND class parts and states 
//
#define VSCLASS_TASKBAND	L"TASKBAND"

enum TASKBANDPARTS {
	TDP_GROUPCOUNT = 1,
	TDP_FLASHBUTTON = 2,
	TDP_FLASHBUTTONGROUPMENU = 3,
};


//
//  STARTPANEL class parts and states 
//
#define VSCLASS_STARTPANEL	L"STARTPANEL"

enum STARTPANELPARTS {
	SPP_USERPANE = 1,
	SPP_MOREPROGRAMS = 2,
	SPP_MOREPROGRAMSARROW = 3,
	SPP_PROGLIST = 4,
	SPP_PROGLISTSEPARATOR = 5,
	SPP_PLACESLIST = 6,
	SPP_PLACESLISTSEPARATOR = 7,
	SPP_LOGOFF = 8,
	SPP_LOGOFFBUTTONS = 9,
	SPP_USERPICTURE = 10,
	SPP_PREVIEW = 11,
	SPP_MOREPROGRAMSTAB = 12,
	SPP_NSCHOST = 13,
	SPP_SOFTWAREEXPLORER = 14,
	SPP_OPENBOX = 15,
	SPP_SEARCHVIEW = 16,
	SPP_MOREPROGRAMSARROWBACK = 17,
	SPP_TOPMATCH = 18,
	SPP_LOGOFFSPLITBUTTONDROPDOWN = 19,
};

enum MOREPROGRAMSTABSTATES {
	SPMPT_NORMAL = 1,
	SPMPT_HOT = 2,
	SPMPT_SELECTED = 3,
	SPMPT_DISABLED = 4,
	SPMPT_FOCUSED = 5,
};

enum SOFTWAREEXPLORERSTATES {
	SPSE_NORMAL = 1,
	SPSE_HOT = 2,
	SPSE_SELECTED = 3,
	SPSE_DISABLED = 4,
	SPSE_FOCUSED = 5,
};

enum OPENBOXSTATES {
	SPOB_NORMAL = 1,
	SPOB_HOT = 2,
	SPOB_SELECTED = 3,
	SPOB_DISABLED = 4,
	SPOB_FOCUSED = 5,
};

enum MOREPROGRAMSARROWSTATES {
	SPS_NORMAL = 1,
	SPS_HOT = 2,
	SPS_PRESSED = 3,
};

enum MOREPROGRAMSARROWBACKSTATES {
	SPSB_NORMAL = 1,
	SPSB_HOT = 2,
	SPSB_PRESSED = 3,
};

enum LOGOFFBUTTONSSTATES {
	SPLS_NORMAL = 1,
	SPLS_HOT = 2,
	SPLS_PRESSED = 3,
};


//
//  MENUBAND class parts and states 
//
#define VSCLASS_MENUBAND	L"MENUBAND"

enum MENUBANDPARTS {
	MDP_NEWAPPBUTTON = 1,
	MDP_SEPERATOR = 2,
};

enum MENUBANDSTATES {
	MDS_NORMAL = 1,
	MDS_HOT = 2,
	MDS_PRESSED = 3,
	MDS_DISABLED = 4,
	MDS_CHECKED = 5,
	MDS_HOTCHECKED = 6,
};


#endif //__VSSYM32_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vsserror.h ===
/*--

Copyright (c) 1999-2005  Microsoft Corporation

Module Name:

    errors.h

Abstract:

    This file contains the message definitions for common VSS errors.
    They are a subset of message definitions of vssadmin.exe.

Author:

Revision History:

--*/

#ifndef _ERRORS_H_
#define _ERRORS_H_
//
//  VSS error codes.
//
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: VSS_E_BAD_STATE
//
// MessageText:
//
// A function call was made when the object was in an incorrect state
// for that function
//
#define VSS_E_BAD_STATE                  ((HRESULT)0x80042301L)

//
// MessageId: VSS_E_UNEXPECTED
//
// MessageText:
//
// A Volume Shadow Copy Service component encountered an unexpected error.
// Check the Application event log for more information.
//
#define VSS_E_UNEXPECTED                 ((HRESULT)0x80042302L)

//
// MessageId: VSS_E_PROVIDER_ALREADY_REGISTERED
//
// MessageText:
//
// The provider has already been registered.
//
#define VSS_E_PROVIDER_ALREADY_REGISTERED ((HRESULT)0x80042303L)

//
// MessageId: VSS_E_PROVIDER_NOT_REGISTERED
//
// MessageText:
//
// The volume shadow copy provider is not registered in the system.
//
#define VSS_E_PROVIDER_NOT_REGISTERED    ((HRESULT)0x80042304L)

//
// MessageId: VSS_E_PROVIDER_VETO
//
// MessageText:
//
// The shadow copy provider had an error. Check the System and Application event logs for more information.
//
#define VSS_E_PROVIDER_VETO              ((HRESULT)0x80042306L)

//
// MessageId: VSS_E_PROVIDER_IN_USE
//
// MessageText:
//
// The shadow copy provider is currently in use and cannot be unregistered.
//
#define VSS_E_PROVIDER_IN_USE            ((HRESULT)0x80042307L)

//
// MessageId: VSS_E_OBJECT_NOT_FOUND
//
// MessageText:
//
// The specified object was not found.
//
#define VSS_E_OBJECT_NOT_FOUND           ((HRESULT)0x80042308L)

//
// MessageId: VSS_S_ASYNC_PENDING
//
// MessageText:
//
// The asynchronous operation is pending.
//
#define VSS_S_ASYNC_PENDING              ((HRESULT)0x00042309L)

//
// MessageId: VSS_S_ASYNC_FINISHED
//
// MessageText:
//
// The asynchronous operation has completed.
//
#define VSS_S_ASYNC_FINISHED             ((HRESULT)0x0004230AL)

//
// MessageId: VSS_S_ASYNC_CANCELLED
//
// MessageText:
//
// The asynchronous operation has been cancelled.
//
#define VSS_S_ASYNC_CANCELLED            ((HRESULT)0x0004230BL)

//
// MessageId: VSS_E_VOLUME_NOT_SUPPORTED
//
// MessageText:
//
// Shadow copying the specified volume is not supported.
//
#define VSS_E_VOLUME_NOT_SUPPORTED       ((HRESULT)0x8004230CL)

//
// MessageId: VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER
//
// MessageText:
//
// The given shadow copy provider does not support shadow copying the specified volume.
//
#define VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER ((HRESULT)0x8004230EL)

//
// MessageId: VSS_E_OBJECT_ALREADY_EXISTS
//
// MessageText:
//
// The object already exists.
//
#define VSS_E_OBJECT_ALREADY_EXISTS      ((HRESULT)0x8004230DL)

//
// MessageId: VSS_E_UNEXPECTED_PROVIDER_ERROR
//
// MessageText:
//
// The shadow copy provider had an unexpected error while trying to process the specified operation.
//
#define VSS_E_UNEXPECTED_PROVIDER_ERROR  ((HRESULT)0x8004230FL)

//
// MessageId: VSS_E_CORRUPT_XML_DOCUMENT
//
// MessageText:
//
// The given XML document is invalid.  It is either incorrectly-formed XML or it does not match the
// schema.  This error code is deprecated.
//
#define VSS_E_CORRUPT_XML_DOCUMENT       ((HRESULT)0x80042310L)

//
// MessageId: VSS_E_INVALID_XML_DOCUMENT
//
// MessageText:
//
// The given XML document is invalid.  It is either incorrectly-formed XML or it does not match the
// schema.
//
#define VSS_E_INVALID_XML_DOCUMENT       ((HRESULT)0x80042311L)

//
// MessageId: VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED
//
// MessageText:
//
// The maximum number of volumes for this operation has been reached.
//
#define VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED ((HRESULT)0x80042312L)

//
// MessageId: VSS_E_FLUSH_WRITES_TIMEOUT
//
// MessageText:
//
// The shadow copy provider timed out while flushing data to the volume being shadow copied. This is probably due to excessive activity on the volume. Try again later when the volume is not being used so heavily.
//
#define VSS_E_FLUSH_WRITES_TIMEOUT       ((HRESULT)0x80042313L)

//
// MessageId: VSS_E_HOLD_WRITES_TIMEOUT
//
// MessageText:
//
// The shadow copy provider timed out while holding writes to the volume being shadow copied. This is probably due to excessive activity on the volume by an application or a system service. Try again later when activity on the volume is reduced.
//
#define VSS_E_HOLD_WRITES_TIMEOUT        ((HRESULT)0x80042314L)

//
// MessageId: VSS_E_UNEXPECTED_WRITER_ERROR
//
// MessageText:
//
// VSS encountered problems while sending events to writers.
//
#define VSS_E_UNEXPECTED_WRITER_ERROR    ((HRESULT)0x80042315L)

//
// MessageId: VSS_E_SNAPSHOT_SET_IN_PROGRESS
//
// MessageText:
//
// Another shadow copy creation is already in progress. Wait a few moments and try again.
//
#define VSS_E_SNAPSHOT_SET_IN_PROGRESS   ((HRESULT)0x80042316L)

//
// MessageId: VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED
//
// MessageText:
//
// The specified volume has already reached its maximum number of shadow copies.
//
#define VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED ((HRESULT)0x80042317L)

//
// MessageId: VSS_E_WRITER_INFRASTRUCTURE
//
// MessageText:
//
// An error was detected in the Volume Shadow Copy Service (VSS). The problem occurred while trying to contact VSS writers.
// Verify that the Event System service and the VSS service are running and check for associated errors in the event logs.
//
#define VSS_E_WRITER_INFRASTRUCTURE      ((HRESULT)0x80042318L)

//
// MessageId: VSS_E_WRITER_NOT_RESPONDING
//
// MessageText:
//
// A writer did not respond to a GatherWriterStatus call.  The writer may either have terminated
// or it may be stuck.  Check the System and Application event logs for more information.
//
#define VSS_E_WRITER_NOT_RESPONDING      ((HRESULT)0x80042319L)

//
// MessageId: VSS_E_WRITER_ALREADY_SUBSCRIBED
//
// MessageText:
//
// The writer has already successfully called the Subscribe function.  It cannot call
// Subscribe multiple times.
//
#define VSS_E_WRITER_ALREADY_SUBSCRIBED  ((HRESULT)0x8004231AL)

//
// MessageId: VSS_E_UNSUPPORTED_CONTEXT
//
// MessageText:
//
// The shadow copy provider does not support the specified shadow copy type.
//
#define VSS_E_UNSUPPORTED_CONTEXT        ((HRESULT)0x8004231BL)

//
// MessageId: VSS_E_VOLUME_IN_USE
//
// MessageText:
//
// The specified shadow copy storage association is in use and so can't be deleted.
//
#define VSS_E_VOLUME_IN_USE              ((HRESULT)0x8004231DL)

//
// MessageId: VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED
//
// MessageText:
//
// Maximum number of shadow copy storage associations already reached.
//
#define VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED ((HRESULT)0x8004231EL)

//
// MessageId: VSS_E_INSUFFICIENT_STORAGE
//
// MessageText:
//
// Insufficient storage available to create either the shadow copy storage file or other shadow copy data.
//
#define VSS_E_INSUFFICIENT_STORAGE       ((HRESULT)0x8004231FL)

//
// MessageId: VSS_E_NO_SNAPSHOTS_IMPORTED
//
// MessageText:
//
// No shadow copies were successfully imported.
//
#define VSS_E_NO_SNAPSHOTS_IMPORTED      ((HRESULT)0x80042320L)

//
// MessageId: VSS_S_SOME_SNAPSHOTS_NOT_IMPORTED
//
// MessageText:
//
// Some shadow copies were not successfully imported.
//
#define VSS_S_SOME_SNAPSHOTS_NOT_IMPORTED ((HRESULT)0x00042321L)

//
// MessageId: VSS_E_SOME_SNAPSHOTS_NOT_IMPORTED
//
// MessageText:
//
// Some shadow copies were not successfully imported.
//
#define VSS_E_SOME_SNAPSHOTS_NOT_IMPORTED ((HRESULT)0x80042321L)

//
// MessageId: VSS_E_MAXIMUM_NUMBER_OF_REMOTE_MACHINES_REACHED
//
// MessageText:
//
// The maximum number of remote machines for this operation has been reached.
//
#define VSS_E_MAXIMUM_NUMBER_OF_REMOTE_MACHINES_REACHED ((HRESULT)0x80042322L)

//
// MessageId: VSS_E_REMOTE_SERVER_UNAVAILABLE
//
// MessageText:
//
// The remote server is unavailable.
//
#define VSS_E_REMOTE_SERVER_UNAVAILABLE  ((HRESULT)0x80042323L)

//
// MessageId: VSS_E_REMOTE_SERVER_UNSUPPORTED
//
// MessageText:
//
// The remote server is running a version of the Volume Shadow Copy Service that does not
// support remote shadow-copy creation.
//
#define VSS_E_REMOTE_SERVER_UNSUPPORTED  ((HRESULT)0x80042324L)

//
// MessageId: VSS_E_REVERT_IN_PROGRESS
//
// MessageText:
//
// A revert is currently in progress for the specified volume.  Another revert
// cannot be initiated until the current revert completes.
//
#define VSS_E_REVERT_IN_PROGRESS         ((HRESULT)0x80042325L)

//
// MessageId: VSS_E_REVERT_VOLUME_LOST
//
// MessageText:
//
// The volume being reverted was lost during revert.
//
#define VSS_E_REVERT_VOLUME_LOST         ((HRESULT)0x80042326L)

//
// MessageId: VSS_E_REBOOT_REQUIRED
//
// MessageText:
//
// A reboot is required after completing this operation.
//
#define VSS_E_REBOOT_REQUIRED            ((HRESULT)0x80042327L)

//
// MessageId: VSS_E_TRANSACTION_FREEZE_TIMEOUT
//
// MessageText:
//
// A timeout occurred while freezing a transaction manager.
//
#define VSS_E_TRANSACTION_FREEZE_TIMEOUT ((HRESULT)0x80042328L)

//
// MessageId: VSS_E_TRANSACTION_THAW_TIMEOUT
//
// MessageText:
//
// Too much time elapsed between freezing a transaction manager and thawing
// the transaction manager.
//
#define VSS_E_TRANSACTION_THAW_TIMEOUT   ((HRESULT)0x80042329L)

//
// MessageId: VSS_E_VOLUME_NOT_LOCAL
//
// MessageText:
//
// The volume being backed up is not mounted on the local host.
//
#define VSS_E_VOLUME_NOT_LOCAL           ((HRESULT)0x8004232DL)

//
// MessageId: VSS_E_CLUSTER_TIMEOUT
//
// MessageText:
//
// A timeout occurred while preparing a cluster shared volume for backup.
//
#define VSS_E_CLUSTER_TIMEOUT            ((HRESULT)0x8004232EL)

//
// MessageId: VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
//
// MessageText:
//
// The shadow-copy set only contains only a subset of the
// volumes needed to correctly backup the selected components
// of the writer.
//
#define VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT ((HRESULT)0x800423F0L)

//
// MessageId: VSS_E_WRITERERROR_OUTOFRESOURCES
//
// MessageText:
//
// A resource allocation failed while processing this operation.
//
#define VSS_E_WRITERERROR_OUTOFRESOURCES ((HRESULT)0x800423F1L)

//
// MessageId: VSS_E_WRITERERROR_TIMEOUT
//
// MessageText:
//
// The writer's timeout expired between the Freeze and Thaw events.
//
#define VSS_E_WRITERERROR_TIMEOUT        ((HRESULT)0x800423F2L)

//
// MessageId: VSS_E_WRITERERROR_RETRYABLE
//
// MessageText:
//
// The writer experienced a transient error.  If the backup process is retried,
// the error may not reoccur.
//
#define VSS_E_WRITERERROR_RETRYABLE      ((HRESULT)0x800423F3L)

//
// MessageId: VSS_E_WRITERERROR_NONRETRYABLE
//
// MessageText:
//
// The writer experienced a non-transient error.  If the backup process is retried,
// the error is likely to reoccur.
//
#define VSS_E_WRITERERROR_NONRETRYABLE   ((HRESULT)0x800423F4L)

//
// MessageId: VSS_E_WRITERERROR_RECOVERY_FAILED
//
// MessageText:
//
// The writer experienced an error while trying to recover the shadow-copy volume.
//
#define VSS_E_WRITERERROR_RECOVERY_FAILED ((HRESULT)0x800423F5L)

//
// MessageId: VSS_E_BREAK_REVERT_ID_FAILED
//
// MessageText:
//
// The shadow copy set break operation failed because the disk/partition identities could not be reverted. The target identity already exists on the machine or cluster and must be masked before this operation can succeed.
//
#define VSS_E_BREAK_REVERT_ID_FAILED     ((HRESULT)0x800423F6L)

//
// MessageId: VSS_E_LEGACY_PROVIDER
//
// MessageText:
//
// This version of the hardware provider does not support this operation.
//
#define VSS_E_LEGACY_PROVIDER            ((HRESULT)0x800423F7L)

//
// MessageId: VSS_E_MISSING_DISK
//
// MessageText:
//
// An expected disk did not arrive in the system.
//
#define VSS_E_MISSING_DISK               ((HRESULT)0x800423F8L)

//
// MessageId: VSS_E_MISSING_HIDDEN_VOLUME
//
// MessageText:
//
// An expected hidden volume did not arrive in the system. Check the Application event log for more information.
//
#define VSS_E_MISSING_HIDDEN_VOLUME      ((HRESULT)0x800423F9L)

//
// MessageId: VSS_E_MISSING_VOLUME
//
// MessageText:
//
// An expected volume did not arrive in the system. Check the Application event log for more information.
//
#define VSS_E_MISSING_VOLUME             ((HRESULT)0x800423FAL)

//
// MessageId: VSS_E_AUTORECOVERY_FAILED
//
// MessageText:
//
// The autorecovery operation failed to complete on the shadow copy.
//
#define VSS_E_AUTORECOVERY_FAILED        ((HRESULT)0x800423FBL)

//
// MessageId: VSS_E_DYNAMIC_DISK_ERROR
//
// MessageText:
//
// An error occurred in processing the dynamic disks involved in the operation.
//
#define VSS_E_DYNAMIC_DISK_ERROR         ((HRESULT)0x800423FCL)

//
// MessageId: VSS_E_NONTRANSPORTABLE_BCD
//
// MessageText:
//
// The given Backup Components Document is for a non-transportable shadow copy. This operation can only be done on transportable shadow copies.
//
#define VSS_E_NONTRANSPORTABLE_BCD       ((HRESULT)0x800423FDL)

//
// MessageId: VSS_E_CANNOT_REVERT_DISKID
//
// MessageText:
//
// The MBR signature or GPT ID for one or more disks could not be set to the intended value. Check the Application event log for more information.
//
#define VSS_E_CANNOT_REVERT_DISKID       ((HRESULT)0x800423FEL)

//
// MessageId: VSS_E_RESYNC_IN_PROGRESS
//
// MessageText:
//
// The LUN resynchronization operation could not be started because another resynchronization operation is already in progress.
//
#define VSS_E_RESYNC_IN_PROGRESS         ((HRESULT)0x800423FFL)

//
// MessageId: VSS_E_CLUSTER_ERROR
//
// MessageText:
//
// The clustered disks could not be enumerated or could not be put into cluster maintenance mode. Check the System event log for cluster related events and the Application event log for VSS related events.
//
#define VSS_E_CLUSTER_ERROR              ((HRESULT)0x80042400L)

//
// MessageId: VSS_E_UNSELECTED_VOLUME
//
// MessageText:
//
// The requested operation would overwrite a volume that is not explicitly selected. For more information, check the Application event log.
//
#define VSS_E_UNSELECTED_VOLUME          ((HRESULT)0x8004232AL)

//
// MessageId: VSS_E_SNAPSHOT_NOT_IN_SET
//
// MessageText:
//
// The shadow copy ID was not found in the backup components document for the shadow copy set.
//
#define VSS_E_SNAPSHOT_NOT_IN_SET        ((HRESULT)0x8004232BL)

//
// MessageId: VSS_E_NESTED_VOLUME_LIMIT
//
// MessageText:
//
// The specified volume is nested too deeply to participate in the VSS operation.
//
#define VSS_E_NESTED_VOLUME_LIMIT        ((HRESULT)0x8004232CL)

//
// MessageId: VSS_E_NOT_SUPPORTED
//
// MessageText:
//
// The requested operation is not supported.
//
#define VSS_E_NOT_SUPPORTED              ((HRESULT)0x8004232FL)

//
// MessageId: VSS_E_WRITERERROR_PARTIAL_FAILURE
//
// MessageText:
//
// The writer experienced a partial failure. Check the component level error state for more information.
//
#define VSS_E_WRITERERROR_PARTIAL_FAILURE ((HRESULT)0x80042336L)

 //
 // ASR error codes
 //
//
// MessageId: VSS_E_ASRERROR_DISK_ASSIGNMENT_FAILED
//
// MessageText:
//
// There are too few disks on this computer or one or more of the disks is too small. Add or change disks so they match the disks in the backup, and try the restore again.
//
#define VSS_E_ASRERROR_DISK_ASSIGNMENT_FAILED ((HRESULT)0x80042401L)

//
// MessageId: VSS_E_ASRERROR_DISK_RECREATION_FAILED
//
// MessageText:
//
// Windows cannot create a disk on this computer needed to restore from the backup. Make sure the disks are properly connected, or add or change disks, and try the restore again.
//
#define VSS_E_ASRERROR_DISK_RECREATION_FAILED ((HRESULT)0x80042402L)

//
// MessageId: VSS_E_ASRERROR_NO_ARCPATH
//
// MessageText:
//
// The computer needs to be restarted to finish preparing a hard disk for restore. To continue, restart your computer and run the restore again.
//
#define VSS_E_ASRERROR_NO_ARCPATH        ((HRESULT)0x80042403L)

//
// MessageId: VSS_E_ASRERROR_MISSING_DYNDISK
//
// MessageText:
//
// The backup failed due to a missing disk for a dynamic volume. Ensure the disk is online and retry the backup.
//
#define VSS_E_ASRERROR_MISSING_DYNDISK   ((HRESULT)0x80042404L)

//
// MessageId: VSS_E_ASRERROR_SHARED_CRIDISK
//
// MessageText:
//
// Automated System Recovery failed the shadow copy, because a selected critical volume is located on a cluster shared disk. This is an unsupported configuration.
//
#define VSS_E_ASRERROR_SHARED_CRIDISK    ((HRESULT)0x80042405L)

//
// MessageId: VSS_E_ASRERROR_DATADISK_RDISK0
//
// MessageText:
//
// A data disk is currently set as active in BIOS. Set some other disk as active or use the DiskPart utility to clean the data disk, and then retry the restore operation.
//
#define VSS_E_ASRERROR_DATADISK_RDISK0   ((HRESULT)0x80042406L)

//
// MessageId: VSS_E_ASRERROR_RDISK0_TOOSMALL
//
// MessageText:
//
// The disk that is set as active in BIOS is too small to recover the original system disk. Replace the disk with a larger one and retry the restore operation.
//
#define VSS_E_ASRERROR_RDISK0_TOOSMALL   ((HRESULT)0x80042407L)

//
// MessageId: VSS_E_ASRERROR_CRITICAL_DISKS_TOO_SMALL
//
// MessageText:
//
// Failed to find enough suitable disks for recreating all critical disks. The number of available disks should be same or greater than the number of critical disks at time of backup, and each one of the disks must be of same or greater size.
//
#define VSS_E_ASRERROR_CRITICAL_DISKS_TOO_SMALL ((HRESULT)0x80042408L)

//
// MessageId: VSS_E_WRITER_STATUS_NOT_AVAILABLE
//
// MessageText:
//
// Writer status is not available for one or more writers.  A writer may have reached the limit to the number of available backup-restore session states.
//
#define VSS_E_WRITER_STATUS_NOT_AVAILABLE ((HRESULT)0x80042409L)

//
// MessageId: VSS_E_ASRERROR_DYNAMIC_VHD_NOT_SUPPORTED
//
// MessageText:
//
// A critical dynamic disk is a Virtual Hard Disk (VHD). This is an unsupported configuration. Check the Application event log for more details.
//
#define VSS_E_ASRERROR_DYNAMIC_VHD_NOT_SUPPORTED ((HRESULT)0x8004240AL)

//
// MessageId: VSS_E_CRITICAL_VOLUME_ON_INVALID_DISK
//
// MessageText:
//
// A critical volume selected for backup exists on a disk which cannot be backed up by ASR.
//
#define VSS_E_CRITICAL_VOLUME_ON_INVALID_DISK ((HRESULT)0x80042411L)

//
// MessageId: VSS_E_ASRERROR_RDISK_FOR_SYSTEM_DISK_NOT_FOUND
//
// MessageText:
//
// No disk that can be used for recovering the system disk can be found.
// Try the following:
// 1) A probable system disk may have been excluded by mistake.
//     a.  Review the list of disks that you have excluded from the recovery
//         for a likely disk.
//     b.  Type LIST DISK command in the DISKPART command interpreter. The
//         probable system disk is usually the first disk listed in the results.
//     c.  If possible, remove the disk from the exclusion list and then retry
//        the recovery.
// 2) A USB disk may have been assigned as a system disk.
//     a.  Detach all USB disks from the computer.
//     b.  Reboot into Windows Recovery Environment (Win RE),
//         then reattach USB disks and retry the recovery.
// 3) An invalid disk may have been assigned as system disk.
//     a.  Physically detach the disk from your computer. Then boot
//         into Win RE to retry the recovery.
//
#define VSS_E_ASRERROR_RDISK_FOR_SYSTEM_DISK_NOT_FOUND ((HRESULT)0x80042412L)

//
// MessageId: VSS_E_ASRERROR_NO_PHYSICAL_DISK_AVAILABLE
//
// MessageText:
//
// Windows did not find any fixed disk that can be used to recreate volumes present in backup. Ensure disks are online, and disk drivers are installed to access the disk(s). 'diskpart.exe' tool with list disks command can be used to see the list of available fixed disks on the system.
//
#define VSS_E_ASRERROR_NO_PHYSICAL_DISK_AVAILABLE ((HRESULT)0x80042413L)

//
// MessageId: VSS_E_ASRERROR_FIXED_PHYSICAL_DISK_AVAILABLE_AFTER_DISK_EXCLUSION
//
// MessageText:
//
// Windows did not find any disk which it can use for recreating volumes present in backup. Offline disks, cluster shared disks or disks explicitly excluded by user will not be used by Windows. Ensure that disks are online and no disks are excluded by mistake.
//
#define VSS_E_ASRERROR_FIXED_PHYSICAL_DISK_AVAILABLE_AFTER_DISK_EXCLUSION ((HRESULT)0x80042414L)

//
// MessageId: VSS_E_ASRERROR_CRITICAL_DISK_CANNOT_BE_EXCLUDED
//
// MessageText:
//
// Restore failed because a disk which was critical at backup is excluded. To continue you need to either remove the disk from exclusion list or detach it from machine or clean it using DiskPart utility, and then retry restore. If you cannot clean or detach it then change the disk signature using DiskPart command UNIQUEID DISK ID.
//
#define VSS_E_ASRERROR_CRITICAL_DISK_CANNOT_BE_EXCLUDED ((HRESULT)0x80042415L)

//
// MessageId: VSS_E_ASRERROR_SYSTEM_PARTITION_HIDDEN
//
// MessageText:
//
// System partition (partition marked "active") is hidden or contains an unrecognized file system. Backup does not support this configuration.
//
#define VSS_E_ASRERROR_SYSTEM_PARTITION_HIDDEN ((HRESULT)0x80042416L)

#endif // _ERRORS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vsstyle.h ===
//-------------------------------------------------------------------------//
//  VisualStyle Style Guide symbols
//-------------------------------------------------------------------------//

#ifndef __VSSTYLE_H__
#define __VSSTYLE_H__

//
//  property symbol definitions
//

#define TMTVS_RESERVEDLOW	100000
#define TMTVS_RESERVEDHIGH	19999



//
//  AEROWIZARDSTYLE class parts and states 
//
#define VSCLASS_AEROWIZARDSTYLE	L"AEROWIZARDSTYLE"
#define VSCLASS_AEROWIZARD	L"AEROWIZARD"

enum AEROWIZARDPARTS {
	AW_TITLEBAR = 1,
	AW_HEADERAREA = 2,
	AW_CONTENTAREA = 3,
	AW_COMMANDAREA = 4,
	AW_BUTTON = 5,
};

#define AEROWIZARDSTYLEPARTS AEROWIZARDPARTS;

enum TITLEBARSTATES {
	AW_S_TITLEBAR_ACTIVE = 1,
	AW_S_TITLEBAR_INACTIVE = 2,
};

enum HEADERAREASTATES {
	AW_S_HEADERAREA_NOMARGIN = 1,
};

enum CONTENTAREASTATES {
	AW_S_CONTENTAREA_NOMARGIN = 1,
};


//
//  BUTTONSTYLE class parts and states 
//
#define VSCLASS_BUTTONSTYLE	L"BUTTONSTYLE"
#define VSCLASS_BUTTON	L"BUTTON"

enum BUTTONPARTS {
	BP_PUSHBUTTON = 1,
	BP_RADIOBUTTON = 2,
	BP_CHECKBOX = 3,
	BP_GROUPBOX = 4,
	BP_USERBUTTON = 5,
	BP_COMMANDLINK = 6,
	BP_COMMANDLINKGLYPH = 7,
};

#define BUTTONSTYLEPARTS BUTTONPARTS;

enum PUSHBUTTONSTATES {
	PBS_NORMAL = 1,
	PBS_HOT = 2,
	PBS_PRESSED = 3,
	PBS_DISABLED = 4,
	PBS_DEFAULTED = 5,
	PBS_DEFAULTED_ANIMATING = 6,
};

enum RADIOBUTTONSTATES {
	RBS_UNCHECKEDNORMAL = 1,
	RBS_UNCHECKEDHOT = 2,
	RBS_UNCHECKEDPRESSED = 3,
	RBS_UNCHECKEDDISABLED = 4,
	RBS_CHECKEDNORMAL = 5,
	RBS_CHECKEDHOT = 6,
	RBS_CHECKEDPRESSED = 7,
	RBS_CHECKEDDISABLED = 8,
};

enum CHECKBOXSTATES {
	CBS_UNCHECKEDNORMAL = 1,
	CBS_UNCHECKEDHOT = 2,
	CBS_UNCHECKEDPRESSED = 3,
	CBS_UNCHECKEDDISABLED = 4,
	CBS_CHECKEDNORMAL = 5,
	CBS_CHECKEDHOT = 6,
	CBS_CHECKEDPRESSED = 7,
	CBS_CHECKEDDISABLED = 8,
	CBS_MIXEDNORMAL = 9,
	CBS_MIXEDHOT = 10,
	CBS_MIXEDPRESSED = 11,
	CBS_MIXEDDISABLED = 12,
	CBS_IMPLICITNORMAL = 13,
	CBS_IMPLICITHOT = 14,
	CBS_IMPLICITPRESSED = 15,
	CBS_IMPLICITDISABLED = 16,
	CBS_EXCLUDEDNORMAL = 17,
	CBS_EXCLUDEDHOT = 18,
	CBS_EXCLUDEDPRESSED = 19,
	CBS_EXCLUDEDDISABLED = 20,
};

enum GROUPBOXSTATES {
	GBS_NORMAL = 1,
	GBS_DISABLED = 2,
};

enum COMMANDLINKSTATES {
	CMDLS_NORMAL = 1,
	CMDLS_HOT = 2,
	CMDLS_PRESSED = 3,
	CMDLS_DISABLED = 4,
	CMDLS_DEFAULTED = 5,
	CMDLS_DEFAULTED_ANIMATING = 6,
};

enum COMMANDLINKGLYPHSTATES {
	CMDLGS_NORMAL = 1,
	CMDLGS_HOT = 2,
	CMDLGS_PRESSED = 3,
	CMDLGS_DISABLED = 4,
	CMDLGS_DEFAULTED = 5,
};


//
//  COMBOBOXSTYLE class parts and states 
//
#define VSCLASS_COMBOBOXSTYLE	L"COMBOBOXSTYLE"
#define VSCLASS_COMBOBOX	L"COMBOBOX"

enum COMBOBOXPARTS {
	CP_DROPDOWNBUTTON = 1,
	CP_BACKGROUND = 2,
	CP_TRANSPARENTBACKGROUND = 3,
	CP_BORDER = 4,
	CP_READONLY = 5,
	CP_DROPDOWNBUTTONRIGHT = 6,
	CP_DROPDOWNBUTTONLEFT = 7,
	CP_CUEBANNER = 8,
};

#define COMBOBOXSTYLEPARTS COMBOBOXPARTS;

enum COMBOBOXSTYLESTATES {
	CBXS_NORMAL = 1,
	CBXS_HOT = 2,
	CBXS_PRESSED = 3,
	CBXS_DISABLED = 4,
};

enum DROPDOWNBUTTONRIGHTSTATES {
	CBXSR_NORMAL = 1,
	CBXSR_HOT = 2,
	CBXSR_PRESSED = 3,
	CBXSR_DISABLED = 4,
};

enum DROPDOWNBUTTONLEFTSTATES {
	CBXSL_NORMAL = 1,
	CBXSL_HOT = 2,
	CBXSL_PRESSED = 3,
	CBXSL_DISABLED = 4,
};

enum TRANSPARENTBACKGROUNDSTATES {
	CBTBS_NORMAL = 1,
	CBTBS_HOT = 2,
	CBTBS_DISABLED = 3,
	CBTBS_FOCUSED = 4,
};

enum BORDERSTATES {
	CBB_NORMAL = 1,
	CBB_HOT = 2,
	CBB_FOCUSED = 3,
	CBB_DISABLED = 4,
};

enum READONLYSTATES {
	CBRO_NORMAL = 1,
	CBRO_HOT = 2,
	CBRO_PRESSED = 3,
	CBRO_DISABLED = 4,
};

enum CUEBANNERSTATES {
	CBCB_NORMAL = 1,
	CBCB_HOT = 2,
	CBCB_PRESSED = 3,
	CBCB_DISABLED = 4,
};


//
//  COMMUNICATIONSSTYLE class parts and states 
//
#define VSCLASS_COMMUNICATIONSSTYLE	L"COMMUNICATIONSSTYLE"
#define VSCLASS_COMMUNICATIONS	L"COMMUNICATIONS"

enum COMMUNICATIONSPARTS {
	CSST_TAB = 1,
};

#define COMMUNICATIONSSTYLEPARTS COMMUNICATIONSPARTS;

enum TABSTATES {
	CSTB_NORMAL = 1,
	CSTB_HOT = 2,
	CSTB_SELECTED = 3,
};


//
//  CONTROLPANELSTYLE class parts and states 
//
#define VSCLASS_CONTROLPANELSTYLE	L"CONTROLPANELSTYLE"
#define VSCLASS_CONTROLPANEL	L"CONTROLPANEL"

enum CONTROLPANELPARTS {
	CPANEL_NAVIGATIONPANE = 1,
	CPANEL_CONTENTPANE = 2,
	CPANEL_NAVIGATIONPANELABEL = 3,
	CPANEL_CONTENTPANELABEL = 4,
	CPANEL_TITLE = 5,
	CPANEL_BODYTEXT = 6,
	CPANEL_HELPLINK = 7,
	CPANEL_TASKLINK = 8,
	CPANEL_GROUPTEXT = 9,
	CPANEL_CONTENTLINK = 10,
	CPANEL_SECTIONTITLELINK = 11,
	CPANEL_LARGECOMMANDAREA = 12,
	CPANEL_SMALLCOMMANDAREA = 13,
	CPANEL_BUTTON = 14,
	CPANEL_MESSAGETEXT = 15,
	CPANEL_NAVIGATIONPANELINE = 16,
	CPANEL_CONTENTPANELINE = 17,
	CPANEL_BANNERAREA = 18,
	CPANEL_BODYTITLE = 19,
};

#define CONTROLPANELSTYLEPARTS CONTROLPANELPARTS;

enum HELPLINKSTATES {
	CPHL_NORMAL = 1,
	CPHL_HOT = 2,
	CPHL_PRESSED = 3,
	CPHL_DISABLED = 4,
};

enum TASKLINKSTATES {
	CPTL_NORMAL = 1,
	CPTL_HOT = 2,
	CPTL_PRESSED = 3,
	CPTL_DISABLED = 4,
	CPTL_PAGE = 5,
};

enum CONTENTLINKSTATES {
	CPCL_NORMAL = 1,
	CPCL_HOT = 2,
	CPCL_PRESSED = 3,
	CPCL_DISABLED = 4,
};

enum SECTIONTITLELINKSTATES {
	CPSTL_NORMAL = 1,
	CPSTL_HOT = 2,
};


//
//  DATEPICKERSTYLE class parts and states 
//
#define VSCLASS_DATEPICKERSTYLE	L"DATEPICKERSTYLE"
#define VSCLASS_DATEPICKER	L"DATEPICKER"

enum DATEPICKERPARTS {
	DP_DATETEXT = 1,
	DP_DATEBORDER = 2,
	DP_SHOWCALENDARBUTTONRIGHT = 3,
};

#define DATEPICKERSTYLEPARTS DATEPICKERPARTS;

enum DATETEXTSTATES {
	DPDT_NORMAL = 1,
	DPDT_DISABLED = 2,
	DPDT_SELECTED = 3,
};

enum DATEBORDERSTATES {
	DPDB_NORMAL = 1,
	DPDB_HOT = 2,
	DPDB_FOCUSED = 3,
	DPDB_DISABLED = 4,
};

enum SHOWCALENDARBUTTONRIGHTSTATES {
	DPSCBR_NORMAL = 1,
	DPSCBR_HOT = 2,
	DPSCBR_PRESSED = 3,
	DPSCBR_DISABLED = 4,
};


//
//  DRAGDROPSTYLE class parts and states 
//
#define VSCLASS_DRAGDROPSTYLE	L"DRAGDROPSTYLE"
#define VSCLASS_DRAGDROP	L"DRAGDROP"

enum DRAGDROPPARTS {
	DD_COPY = 1,
	DD_MOVE = 2,
	DD_UPDATEMETADATA = 3,
	DD_CREATELINK = 4,
	DD_WARNING = 5,
	DD_NONE = 6,
	DD_IMAGEBG = 7,
	DD_TEXTBG = 8,
};

#define DRAGDROPSTYLEPARTS DRAGDROPPARTS;

enum COPYSTATES {
	DDCOPY_HIGHLIGHT = 1,
	DDCOPY_NOHIGHLIGHT = 2,
};

enum MOVESTATES {
	DDMOVE_HIGHLIGHT = 1,
	DDMOVE_NOHIGHLIGHT = 2,
};

enum UPDATEMETADATASTATES {
	DDUPDATEMETADATA_HIGHLIGHT = 1,
	DDUPDATEMETADATA_NOHIGHLIGHT = 2,
};

enum CREATELINKSTATES {
	DDCREATELINK_HIGHLIGHT = 1,
	DDCREATELINK_NOHIGHLIGHT = 2,
};

enum WARNINGSTATES {
	DDWARNING_HIGHLIGHT = 1,
	DDWARNING_NOHIGHLIGHT = 2,
};

enum NONESTATES {
	DDNONE_HIGHLIGHT = 1,
	DDNONE_NOHIGHLIGHT = 2,
};


//
//  EDITSTYLE class parts and states 
//
#define VSCLASS_EDITSTYLE	L"EDITSTYLE"
#define VSCLASS_EDIT	L"EDIT"

enum EDITPARTS {
	EP_EDITTEXT = 1,
	EP_CARET = 2,
	EP_BACKGROUND = 3,
	EP_PASSWORD = 4,
	EP_BACKGROUNDWITHBORDER = 5,
	EP_EDITBORDER_NOSCROLL = 6,
	EP_EDITBORDER_HSCROLL = 7,
	EP_EDITBORDER_VSCROLL = 8,
	EP_EDITBORDER_HVSCROLL = 9,
};

#define EDITSTYLEPARTS EDITPARTS;

enum EDITTEXTSTATES {
	ETS_NORMAL = 1,
	ETS_HOT = 2,
	ETS_SELECTED = 3,
	ETS_DISABLED = 4,
	ETS_FOCUSED = 5,
	ETS_READONLY = 6,
	ETS_ASSIST = 7,
	ETS_CUEBANNER = 8,
};

enum BACKGROUNDSTATES {
	EBS_NORMAL = 1,
	EBS_HOT = 2,
	EBS_DISABLED = 3,
	EBS_FOCUSED = 4,
	EBS_READONLY = 5,
	EBS_ASSIST = 6,
};

enum BACKGROUNDWITHBORDERSTATES {
	EBWBS_NORMAL = 1,
	EBWBS_HOT = 2,
	EBWBS_DISABLED = 3,
	EBWBS_FOCUSED = 4,
};

enum EDITBORDER_NOSCROLLSTATES {
	EPSN_NORMAL = 1,
	EPSN_HOT = 2,
	EPSN_FOCUSED = 3,
	EPSN_DISABLED = 4,
};

enum EDITBORDER_HSCROLLSTATES {
	EPSH_NORMAL = 1,
	EPSH_HOT = 2,
	EPSH_FOCUSED = 3,
	EPSH_DISABLED = 4,
};

enum EDITBORDER_VSCROLLSTATES {
	EPSV_NORMAL = 1,
	EPSV_HOT = 2,
	EPSV_FOCUSED = 3,
	EPSV_DISABLED = 4,
};

enum EDITBORDER_HVSCROLLSTATES {
	EPSHV_NORMAL = 1,
	EPSHV_HOT = 2,
	EPSHV_FOCUSED = 3,
	EPSHV_DISABLED = 4,
};


//
//  EXPLORERBARSTYLE class parts and states 
//
#define VSCLASS_EXPLORERBARSTYLE	L"EXPLORERBARSTYLE"
#define VSCLASS_EXPLORERBAR	L"EXPLORERBAR"

enum EXPLORERBARPARTS {
	EBP_HEADERBACKGROUND = 1,
	EBP_HEADERCLOSE = 2,
	EBP_HEADERPIN = 3,
	EBP_IEBARMENU = 4,
	EBP_NORMALGROUPBACKGROUND = 5,
	EBP_NORMALGROUPCOLLAPSE = 6,
	EBP_NORMALGROUPEXPAND = 7,
	EBP_NORMALGROUPHEAD = 8,
	EBP_SPECIALGROUPBACKGROUND = 9,
	EBP_SPECIALGROUPCOLLAPSE = 10,
	EBP_SPECIALGROUPEXPAND = 11,
	EBP_SPECIALGROUPHEAD = 12,
};

#define EXPLORERBARSTYLEPARTS EXPLORERBARPARTS;

enum HEADERCLOSESTATES {
	EBHC_NORMAL = 1,
	EBHC_HOT = 2,
	EBHC_PRESSED = 3,
};

enum HEADERPINSTATES {
	EBHP_NORMAL = 1,
	EBHP_HOT = 2,
	EBHP_PRESSED = 3,
	EBHP_SELECTEDNORMAL = 4,
	EBHP_SELECTEDHOT = 5,
	EBHP_SELECTEDPRESSED = 6,
};

enum IEBARMENUSTATES {
	EBM_NORMAL = 1,
	EBM_HOT = 2,
	EBM_PRESSED = 3,
};

enum NORMALGROUPCOLLAPSESTATES {
	EBNGC_NORMAL = 1,
	EBNGC_HOT = 2,
	EBNGC_PRESSED = 3,
};

enum NORMALGROUPEXPANDSTATES {
	EBNGE_NORMAL = 1,
	EBNGE_HOT = 2,
	EBNGE_PRESSED = 3,
};

enum SPECIALGROUPCOLLAPSESTATES {
	EBSGC_NORMAL = 1,
	EBSGC_HOT = 2,
	EBSGC_PRESSED = 3,
};

enum SPECIALGROUPEXPANDSTATES {
	EBSGE_NORMAL = 1,
	EBSGE_HOT = 2,
	EBSGE_PRESSED = 3,
};


//
//  FLYOUTSTYLE class parts and states 
//
#define VSCLASS_FLYOUTSTYLE	L"FLYOUTSTYLE"
#define VSCLASS_FLYOUT	L"FLYOUT"

enum FLYOUTPARTS {
	FLYOUT_HEADER = 1,
	FLYOUT_BODY = 2,
	FLYOUT_LABEL = 3,
	FLYOUT_LINK = 4,
	FLYOUT_DIVIDER = 5,
	FLYOUT_WINDOW = 6,
	FLYOUT_LINKAREA = 7,
	FLYOUT_LINKHEADER = 8,
};

#define FLYOUTSTYLEPARTS FLYOUTPARTS;

enum LABELSTATES {
	FLS_NORMAL = 1,
	FLS_SELECTED = 2,
	FLS_EMPHASIZED = 3,
	FLS_DISABLED = 4,
};

enum LINKSTATES {
	FLYOUTLINK_NORMAL = 1,
	FLYOUTLINK_HOVER = 2,
};

enum BODYSTATES {
	FBS_NORMAL = 1,
	FBS_EMPHASIZED = 2,
};

enum LINKHEADERSTATES {
	FLH_NORMAL = 1,
	FLH_HOVER = 2,
};


//
//  HEADERSTYLE class parts and states 
//
#define VSCLASS_HEADERSTYLE	L"HEADERSTYLE"
#define VSCLASS_HEADER	L"HEADER"

enum HEADERPARTS {
	HP_HEADERITEM = 1,
	HP_HEADERITEMLEFT = 2,
	HP_HEADERITEMRIGHT = 3,
	HP_HEADERSORTARROW = 4,
	HP_HEADERDROPDOWN = 5,
	HP_HEADERDROPDOWNFILTER = 6,
	HP_HEADEROVERFLOW = 7,
};

#define HEADERSTYLEPARTS HEADERPARTS;

enum HEADERSTYLESTATES {
	HBG_DETAILS = 1,
	HBG_ICON = 2,
};

enum HEADERITEMSTATES {
	HIS_NORMAL = 1,
	HIS_HOT = 2,
	HIS_PRESSED = 3,
	HIS_SORTEDNORMAL = 4,
	HIS_SORTEDHOT = 5,
	HIS_SORTEDPRESSED = 6,
	HIS_ICONNORMAL = 7,
	HIS_ICONHOT = 8,
	HIS_ICONPRESSED = 9,
	HIS_ICONSORTEDNORMAL = 10,
	HIS_ICONSORTEDHOT = 11,
	HIS_ICONSORTEDPRESSED = 12,
};

enum HEADERITEMLEFTSTATES {
	HILS_NORMAL = 1,
	HILS_HOT = 2,
	HILS_PRESSED = 3,
};

enum HEADERITEMRIGHTSTATES {
	HIRS_NORMAL = 1,
	HIRS_HOT = 2,
	HIRS_PRESSED = 3,
};

enum HEADERSORTARROWSTATES {
	HSAS_SORTEDUP = 1,
	HSAS_SORTEDDOWN = 2,
};

enum HEADERDROPDOWNSTATES {
	HDDS_NORMAL = 1,
	HDDS_SOFTHOT = 2,
	HDDS_HOT = 3,
};

enum HEADERDROPDOWNFILTERSTATES {
	HDDFS_NORMAL = 1,
	HDDFS_SOFTHOT = 2,
	HDDFS_HOT = 3,
};

enum HEADEROVERFLOWSTATES {
	HOFS_NORMAL = 1,
	HOFS_HOT = 2,
};


//
//  LISTBOXSTYLE class parts and states 
//
#define VSCLASS_LISTBOXSTYLE	L"LISTBOXSTYLE"
#define VSCLASS_LISTBOX	L"LISTBOX"

enum LISTBOXPARTS {
	LBCP_BORDER_HSCROLL = 1,
	LBCP_BORDER_HVSCROLL = 2,
	LBCP_BORDER_NOSCROLL = 3,
	LBCP_BORDER_VSCROLL = 4,
	LBCP_ITEM = 5,
};

#define LISTBOXSTYLEPARTS LISTBOXPARTS;

enum BORDER_HSCROLLSTATES {
	LBPSH_NORMAL = 1,
	LBPSH_FOCUSED = 2,
	LBPSH_HOT = 3,
	LBPSH_DISABLED = 4,
};

enum BORDER_HVSCROLLSTATES {
	LBPSHV_NORMAL = 1,
	LBPSHV_FOCUSED = 2,
	LBPSHV_HOT = 3,
	LBPSHV_DISABLED = 4,
};

enum BORDER_NOSCROLLSTATES {
	LBPSN_NORMAL = 1,
	LBPSN_FOCUSED = 2,
	LBPSN_HOT = 3,
	LBPSN_DISABLED = 4,
};

enum BORDER_VSCROLLSTATES {
	LBPSV_NORMAL = 1,
	LBPSV_FOCUSED = 2,
	LBPSV_HOT = 3,
	LBPSV_DISABLED = 4,
};

enum ITEMSTATES {
	LBPSI_HOT = 1,
	LBPSI_HOTSELECTED = 2,
	LBPSI_SELECTED = 3,
	LBPSI_SELECTEDNOTFOCUS = 4,
};


//
//  LISTVIEWSTYLE class parts and states 
//
#define VSCLASS_LISTVIEWSTYLE	L"LISTVIEWSTYLE"
#define VSCLASS_LISTVIEW	L"LISTVIEW"

enum LISTVIEWPARTS {
	LVP_LISTITEM = 1,
	LVP_LISTGROUP = 2,
	LVP_LISTDETAIL = 3,
	LVP_LISTSORTEDDETAIL = 4,
	LVP_EMPTYTEXT = 5,
	LVP_GROUPHEADER = 6,
	LVP_GROUPHEADERLINE = 7,
	LVP_EXPANDBUTTON = 8,
	LVP_COLLAPSEBUTTON = 9,
	LVP_COLUMNDETAIL = 10,
};

#define LISTVIEWSTYLEPARTS LISTVIEWPARTS;

enum LISTITEMSTATES {
	LISS_NORMAL = 1,
	LISS_HOT = 2,
	LISS_SELECTED = 3,
	LISS_DISABLED = 4,
	LISS_SELECTEDNOTFOCUS = 5,
	LISS_HOTSELECTED = 6,
};

enum GROUPHEADERSTATES {
	LVGH_OPEN = 1,
	LVGH_OPENHOT = 2,
	LVGH_OPENSELECTED = 3,
	LVGH_OPENSELECTEDHOT = 4,
	LVGH_OPENSELECTEDNOTFOCUSED = 5,
	LVGH_OPENSELECTEDNOTFOCUSEDHOT = 6,
	LVGH_OPENMIXEDSELECTION = 7,
	LVGH_OPENMIXEDSELECTIONHOT = 8,
	LVGH_CLOSE = 9,
	LVGH_CLOSEHOT = 10,
	LVGH_CLOSESELECTED = 11,
	LVGH_CLOSESELECTEDHOT = 12,
	LVGH_CLOSESELECTEDNOTFOCUSED = 13,
	LVGH_CLOSESELECTEDNOTFOCUSEDHOT = 14,
	LVGH_CLOSEMIXEDSELECTION = 15,
	LVGH_CLOSEMIXEDSELECTIONHOT = 16,
};

enum GROUPHEADERLINESTATES {
	LVGHL_OPEN = 1,
	LVGHL_OPENHOT = 2,
	LVGHL_OPENSELECTED = 3,
	LVGHL_OPENSELECTEDHOT = 4,
	LVGHL_OPENSELECTEDNOTFOCUSED = 5,
	LVGHL_OPENSELECTEDNOTFOCUSEDHOT = 6,
	LVGHL_OPENMIXEDSELECTION = 7,
	LVGHL_OPENMIXEDSELECTIONHOT = 8,
	LVGHL_CLOSE = 9,
	LVGHL_CLOSEHOT = 10,
	LVGHL_CLOSESELECTED = 11,
	LVGHL_CLOSESELECTEDHOT = 12,
	LVGHL_CLOSESELECTEDNOTFOCUSED = 13,
	LVGHL_CLOSESELECTEDNOTFOCUSEDHOT = 14,
	LVGHL_CLOSEMIXEDSELECTION = 15,
	LVGHL_CLOSEMIXEDSELECTIONHOT = 16,
};

enum EXPANDBUTTONSTATES {
	LVEB_NORMAL = 1,
	LVEB_HOVER = 2,
	LVEB_PUSHED = 3,
};

enum COLLAPSEBUTTONSTATES {
	LVCB_NORMAL = 1,
	LVCB_HOVER = 2,
	LVCB_PUSHED = 3,
};


//
//  MENUSTYLE class parts and states 
//
#define VSCLASS_MENUSTYLE	L"MENUSTYLE"
#define VSCLASS_MENU	L"MENU"

enum MENUPARTS {
	MENU_MENUITEM_TMSCHEMA = 1,
	MENU_MENUDROPDOWN_TMSCHEMA = 2,
	MENU_MENUBARITEM_TMSCHEMA = 3,
	MENU_MENUBARDROPDOWN_TMSCHEMA = 4,
	MENU_CHEVRON_TMSCHEMA = 5,
	MENU_SEPARATOR_TMSCHEMA = 6,
	MENU_BARBACKGROUND = 7,
	MENU_BARITEM = 8,
	MENU_POPUPBACKGROUND = 9,
	MENU_POPUPBORDERS = 10,
	MENU_POPUPCHECK = 11,
	MENU_POPUPCHECKBACKGROUND = 12,
	MENU_POPUPGUTTER = 13,
	MENU_POPUPITEM = 14,
	MENU_POPUPSEPARATOR = 15,
	MENU_POPUPSUBMENU = 16,
	MENU_SYSTEMCLOSE = 17,
	MENU_SYSTEMMAXIMIZE = 18,
	MENU_SYSTEMMINIMIZE = 19,
	MENU_SYSTEMRESTORE = 20,
};

#define MENUSTYLEPARTS MENUPARTS;

enum BARBACKGROUNDSTATES {
	MB_ACTIVE = 1,
	MB_INACTIVE = 2,
};

enum BARITEMSTATES {
	MBI_NORMAL = 1,
	MBI_HOT = 2,
	MBI_PUSHED = 3,
	MBI_DISABLED = 4,
	MBI_DISABLEDHOT = 5,
	MBI_DISABLEDPUSHED = 6,
};

enum POPUPCHECKSTATES {
	MC_CHECKMARKNORMAL = 1,
	MC_CHECKMARKDISABLED = 2,
	MC_BULLETNORMAL = 3,
	MC_BULLETDISABLED = 4,
};

enum POPUPCHECKBACKGROUNDSTATES {
	MCB_DISABLED = 1,
	MCB_NORMAL = 2,
	MCB_BITMAP = 3,
};

enum POPUPITEMSTATES {
	MPI_NORMAL = 1,
	MPI_HOT = 2,
	MPI_DISABLED = 3,
	MPI_DISABLEDHOT = 4,
};

enum POPUPSUBMENUSTATES {
	MSM_NORMAL = 1,
	MSM_DISABLED = 2,
};

enum SYSTEMCLOSESTATES {
	MSYSC_NORMAL = 1,
	MSYSC_DISABLED = 2,
};

enum SYSTEMMAXIMIZESTATES {
	MSYSMX_NORMAL = 1,
	MSYSMX_DISABLED = 2,
};

enum SYSTEMMINIMIZESTATES {
	MSYSMN_NORMAL = 1,
	MSYSMN_DISABLED = 2,
};

enum SYSTEMRESTORESTATES {
	MSYSR_NORMAL = 1,
	MSYSR_DISABLED = 2,
};


//
//  NAVIGATION class parts and states 
//
#define VSCLASS_NAVIGATION	L"NAVIGATION"

enum NAVIGATIONPARTS {
	NAV_BACKBUTTON = 1,
	NAV_FORWARDBUTTON = 2,
	NAV_MENUBUTTON = 3,
};

enum NAV_BACKBUTTONSTATES {
	NAV_BB_NORMAL = 1,
	NAV_BB_HOT = 2,
	NAV_BB_PRESSED = 3,
	NAV_BB_DISABLED = 4,
};

enum NAV_FORWARDBUTTONSTATES {
	NAV_FB_NORMAL = 1,
	NAV_FB_HOT = 2,
	NAV_FB_PRESSED = 3,
	NAV_FB_DISABLED = 4,
};

enum NAV_MENUBUTTONSTATES {
	NAV_MB_NORMAL = 1,
	NAV_MB_HOT = 2,
	NAV_MB_PRESSED = 3,
	NAV_MB_DISABLED = 4,
};


//
//  PROGRESSSTYLE class parts and states 
//
#define VSCLASS_PROGRESSSTYLE	L"PROGRESSSTYLE"
#define VSCLASS_PROGRESS	L"PROGRESS"

enum PROGRESSPARTS {
	PP_BAR = 1,
	PP_BARVERT = 2,
	PP_CHUNK = 3,
	PP_CHUNKVERT = 4,
	PP_FILL = 5,
	PP_FILLVERT = 6,
	PP_PULSEOVERLAY = 7,
	PP_MOVEOVERLAY = 8,
	PP_PULSEOVERLAYVERT = 9,
	PP_MOVEOVERLAYVERT = 10,
	PP_TRANSPARENTBAR = 11,
	PP_TRANSPARENTBARVERT = 12,
};

#define PROGRESSSTYLEPARTS PROGRESSPARTS;

enum TRANSPARENTBARSTATES {
	PBBS_NORMAL = 1,
	PBBS_PARTIAL = 2,
};

enum TRANSPARENTBARVERTSTATES {
	PBBVS_NORMAL = 1,
	PBBVS_PARTIAL = 2,
};

enum FILLSTATES {
	PBFS_NORMAL = 1,
	PBFS_ERROR = 2,
	PBFS_PAUSED = 3,
	PBFS_PARTIAL = 4,
};

enum FILLVERTSTATES {
	PBFVS_NORMAL = 1,
	PBFVS_ERROR = 2,
	PBFVS_PAUSED = 3,
	PBFVS_PARTIAL = 4,
};


//
//  REBARSTYLE class parts and states 
//
#define VSCLASS_REBARSTYLE	L"REBARSTYLE"
#define VSCLASS_REBAR	L"REBAR"

enum REBARPARTS {
	RP_GRIPPER = 1,
	RP_GRIPPERVERT = 2,
	RP_BAND = 3,
	RP_CHEVRON = 4,
	RP_CHEVRONVERT = 5,
	RP_BACKGROUND = 6,
	RP_SPLITTER = 7,
	RP_SPLITTERVERT = 8,
};

#define REBARSTYLEPARTS REBARPARTS;

enum CHEVRONSTATES {
	CHEVS_NORMAL = 1,
	CHEVS_HOT = 2,
	CHEVS_PRESSED = 3,
};

enum CHEVRONVERTSTATES {
	CHEVSV_NORMAL = 1,
	CHEVSV_HOT = 2,
	CHEVSV_PRESSED = 3,
};

enum SPLITTERSTATES {
	SPLITS_NORMAL = 1,
	SPLITS_HOT = 2,
	SPLITS_PRESSED = 3,
};

enum SPLITTERVERTSTATES {
	SPLITSV_NORMAL = 1,
	SPLITSV_HOT = 2,
	SPLITSV_PRESSED = 3,
};


//
//  SCROLLBARSTYLE class parts and states 
//
#define VSCLASS_SCROLLBARSTYLE	L"SCROLLBARSTYLE"
#define VSCLASS_SCROLLBAR	L"SCROLLBAR"

enum SCROLLBARPARTS {
	SBP_ARROWBTN = 1,
	SBP_THUMBBTNHORZ = 2,
	SBP_THUMBBTNVERT = 3,
	SBP_LOWERTRACKHORZ = 4,
	SBP_UPPERTRACKHORZ = 5,
	SBP_LOWERTRACKVERT = 6,
	SBP_UPPERTRACKVERT = 7,
	SBP_GRIPPERHORZ = 8,
	SBP_GRIPPERVERT = 9,
	SBP_SIZEBOX = 10,
};

#define SCROLLBARSTYLEPARTS SCROLLBARPARTS;

enum ARROWBTNSTATES {
	ABS_UPNORMAL = 1,
	ABS_UPHOT = 2,
	ABS_UPPRESSED = 3,
	ABS_UPDISABLED = 4,
	ABS_DOWNNORMAL = 5,
	ABS_DOWNHOT = 6,
	ABS_DOWNPRESSED = 7,
	ABS_DOWNDISABLED = 8,
	ABS_LEFTNORMAL = 9,
	ABS_LEFTHOT = 10,
	ABS_LEFTPRESSED = 11,
	ABS_LEFTDISABLED = 12,
	ABS_RIGHTNORMAL = 13,
	ABS_RIGHTHOT = 14,
	ABS_RIGHTPRESSED = 15,
	ABS_RIGHTDISABLED = 16,
	ABS_UPHOVER = 17,
	ABS_DOWNHOVER = 18,
	ABS_LEFTHOVER = 19,
	ABS_RIGHTHOVER = 20,
};

enum SCROLLBARSTYLESTATES {
	SCRBS_NORMAL = 1,
	SCRBS_HOT = 2,
	SCRBS_PRESSED = 3,
	SCRBS_DISABLED = 4,
	SCRBS_HOVER = 5,
};

enum SIZEBOXSTATES {
	SZB_RIGHTALIGN = 1,
	SZB_LEFTALIGN = 2,
	SZB_TOPRIGHTALIGN = 3,
	SZB_TOPLEFTALIGN = 4,
	SZB_HALFBOTTOMRIGHTALIGN = 5,
	SZB_HALFBOTTOMLEFTALIGN = 6,
	SZB_HALFTOPRIGHTALIGN = 7,
	SZB_HALFTOPLEFTALIGN = 8,
};


//
//  SPINSTYLE class parts and states 
//
#define VSCLASS_SPINSTYLE	L"SPINSTYLE"
#define VSCLASS_SPIN	L"SPIN"

enum SPINPARTS {
	SPNP_UP = 1,
	SPNP_DOWN = 2,
	SPNP_UPHORZ = 3,
	SPNP_DOWNHORZ = 4,
};

#define SPINSTYLEPARTS SPINPARTS;

enum UPSTATES {
	UPS_NORMAL = 1,
	UPS_HOT = 2,
	UPS_PRESSED = 3,
	UPS_DISABLED = 4,
};

enum DOWNSTATES {
	DNS_NORMAL = 1,
	DNS_HOT = 2,
	DNS_PRESSED = 3,
	DNS_DISABLED = 4,
};

enum UPHORZSTATES {
	UPHZS_NORMAL = 1,
	UPHZS_HOT = 2,
	UPHZS_PRESSED = 3,
	UPHZS_DISABLED = 4,
};

enum DOWNHORZSTATES {
	DNHZS_NORMAL = 1,
	DNHZS_HOT = 2,
	DNHZS_PRESSED = 3,
	DNHZS_DISABLED = 4,
};


//
//  STATUSSTYLE class parts and states 
//
#define VSCLASS_STATUSSTYLE	L"STATUSSTYLE"
#define VSCLASS_STATUS	L"STATUS"

enum STATUSPARTS {
	SP_PANE = 1,
	SP_GRIPPERPANE = 2,
	SP_GRIPPER = 3,
};

#define STATUSSTYLEPARTS STATUSPARTS;


//
//  TABSTYLE class parts and states 
//
#define VSCLASS_TABSTYLE	L"TABSTYLE"
#define VSCLASS_TAB	L"TAB"

enum TABPARTS {
	TABP_TABITEM = 1,
	TABP_TABITEMLEFTEDGE = 2,
	TABP_TABITEMRIGHTEDGE = 3,
	TABP_TABITEMBOTHEDGE = 4,
	TABP_TOPTABITEM = 5,
	TABP_TOPTABITEMLEFTEDGE = 6,
	TABP_TOPTABITEMRIGHTEDGE = 7,
	TABP_TOPTABITEMBOTHEDGE = 8,
	TABP_PANE = 9,
	TABP_BODY = 10,
	TABP_AEROWIZARDBODY = 11,
};

#define TABSTYLEPARTS TABPARTS;

enum TABITEMSTATES {
	TIS_NORMAL = 1,
	TIS_HOT = 2,
	TIS_SELECTED = 3,
	TIS_DISABLED = 4,
	TIS_FOCUSED = 5,
};

enum TABITEMLEFTEDGESTATES {
	TILES_NORMAL = 1,
	TILES_HOT = 2,
	TILES_SELECTED = 3,
	TILES_DISABLED = 4,
	TILES_FOCUSED = 5,
};

enum TABITEMRIGHTEDGESTATES {
	TIRES_NORMAL = 1,
	TIRES_HOT = 2,
	TIRES_SELECTED = 3,
	TIRES_DISABLED = 4,
	TIRES_FOCUSED = 5,
};

enum TABITEMBOTHEDGESTATES {
	TIBES_NORMAL = 1,
	TIBES_HOT = 2,
	TIBES_SELECTED = 3,
	TIBES_DISABLED = 4,
	TIBES_FOCUSED = 5,
};

enum TOPTABITEMSTATES {
	TTIS_NORMAL = 1,
	TTIS_HOT = 2,
	TTIS_SELECTED = 3,
	TTIS_DISABLED = 4,
	TTIS_FOCUSED = 5,
};

enum TOPTABITEMLEFTEDGESTATES {
	TTILES_NORMAL = 1,
	TTILES_HOT = 2,
	TTILES_SELECTED = 3,
	TTILES_DISABLED = 4,
	TTILES_FOCUSED = 5,
};

enum TOPTABITEMRIGHTEDGESTATES {
	TTIRES_NORMAL = 1,
	TTIRES_HOT = 2,
	TTIRES_SELECTED = 3,
	TTIRES_DISABLED = 4,
	TTIRES_FOCUSED = 5,
};

enum TOPTABITEMBOTHEDGESTATES {
	TTIBES_NORMAL = 1,
	TTIBES_HOT = 2,
	TTIBES_SELECTED = 3,
	TTIBES_DISABLED = 4,
	TTIBES_FOCUSED = 5,
};


//
//  TASKDIALOGSTYLE class parts and states 
//
#define VSCLASS_TASKDIALOGSTYLE	L"TASKDIALOGSTYLE"
#define VSCLASS_TASKDIALOG	L"TASKDIALOG"

enum TASKDIALOGPARTS {
	TDLG_PRIMARYPANEL = 1,
	TDLG_MAININSTRUCTIONPANE = 2,
	TDLG_MAINICON = 3,
	TDLG_CONTENTPANE = 4,
	TDLG_CONTENTICON = 5,
	TDLG_EXPANDEDCONTENT = 6,
	TDLG_COMMANDLINKPANE = 7,
	TDLG_SECONDARYPANEL = 8,
	TDLG_CONTROLPANE = 9,
	TDLG_BUTTONSECTION = 10,
	TDLG_BUTTONWRAPPER = 11,
	TDLG_EXPANDOTEXT = 12,
	TDLG_EXPANDOBUTTON = 13,
	TDLG_VERIFICATIONTEXT = 14,
	TDLG_FOOTNOTEPANE = 15,
	TDLG_FOOTNOTEAREA = 16,
	TDLG_FOOTNOTESEPARATOR = 17,
	TDLG_EXPANDEDFOOTERAREA = 18,
	TDLG_PROGRESSBAR = 19,
	TDLG_IMAGEALIGNMENT = 20,
	TDLG_RADIOBUTTONPANE = 21,
};

#define TASKDIALOGSTYLEPARTS TASKDIALOGPARTS;

enum CONTENTPANESTATES {
	TDLGCPS_STANDALONE = 1,
};

enum EXPANDOBUTTONSTATES {
	TDLGEBS_NORMAL = 1,
	TDLGEBS_HOVER = 2,
	TDLGEBS_PRESSED = 3,
	TDLGEBS_EXPANDEDNORMAL = 4,
	TDLGEBS_EXPANDEDHOVER = 5,
	TDLGEBS_EXPANDEDPRESSED = 6,
};


//
//  TEXTSTYLE class parts and states 
//
#define VSCLASS_TEXTSTYLE	L"TEXTSTYLE"

enum TEXTSTYLEPARTS {
	TEXT_MAININSTRUCTION = 1,
	TEXT_INSTRUCTION = 2,
	TEXT_BODYTITLE = 3,
	TEXT_BODYTEXT = 4,
	TEXT_SECONDARYTEXT = 5,
	TEXT_HYPERLINKTEXT = 6,
	TEXT_EXPANDED = 7,
	TEXT_LABEL = 8,
	TEXT_CONTROLLABEL = 9,
};

enum HYPERLINKTEXTSTATES {
	TS_HYPERLINK_NORMAL = 1,
	TS_HYPERLINK_HOT = 2,
	TS_HYPERLINK_PRESSED = 3,
	TS_HYPERLINK_DISABLED = 4,
};

enum CONTROLLABELSTATES {
	TS_CONTROLLABEL_NORMAL = 1,
	TS_CONTROLLABEL_DISABLED = 2,
};


//
//  TOOLBARSTYLE class parts and states 
//
#define VSCLASS_TOOLBARSTYLE	L"TOOLBARSTYLE"
#define VSCLASS_TOOLBAR	L"TOOLBAR"

enum TOOLBARPARTS {
	TP_BUTTON = 1,
	TP_DROPDOWNBUTTON = 2,
	TP_SPLITBUTTON = 3,
	TP_SPLITBUTTONDROPDOWN = 4,
	TP_SEPARATOR = 5,
	TP_SEPARATORVERT = 6,
	TP_DROPDOWNBUTTONGLYPH = 7,
};

#define TOOLBARSTYLEPARTS TOOLBARPARTS;

enum TOOLBARSTYLESTATES {
	TS_NORMAL = 1,
	TS_HOT = 2,
	TS_PRESSED = 3,
	TS_DISABLED = 4,
	TS_CHECKED = 5,
	TS_HOTCHECKED = 6,
	TS_NEARHOT = 7,
	TS_OTHERSIDEHOT = 8,
};


//
//  TOOLTIPSTYLE class parts and states 
//
#define VSCLASS_TOOLTIPSTYLE	L"TOOLTIPSTYLE"
#define VSCLASS_TOOLTIP	L"TOOLTIP"

enum TOOLTIPPARTS {
	TTP_STANDARD = 1,
	TTP_STANDARDTITLE = 2,
	TTP_BALLOON = 3,
	TTP_BALLOONTITLE = 4,
	TTP_CLOSE = 5,
	TTP_BALLOONSTEM = 6,
	TTP_WRENCH = 7,
};

#define TOOLTIPSTYLEPARTS TOOLTIPPARTS;

enum CLOSESTATES {
	TTCS_NORMAL = 1,
	TTCS_HOT = 2,
	TTCS_PRESSED = 3,
};

enum STANDARDSTATES {
	TTSS_NORMAL = 1,
	TTSS_LINK = 2,
};

enum BALLOONSTATES {
	TTBS_NORMAL = 1,
	TTBS_LINK = 2,
};

enum BALLOONSTEMSTATES {
	TTBSS_POINTINGUPLEFTWALL = 1,
	TTBSS_POINTINGUPCENTERED = 2,
	TTBSS_POINTINGUPRIGHTWALL = 3,
	TTBSS_POINTINGDOWNRIGHTWALL = 4,
	TTBSS_POINTINGDOWNCENTERED = 5,
	TTBSS_POINTINGDOWNLEFTWALL = 6,
};

enum WRENCHSTATES {
	TTWS_NORMAL = 1,
	TTWS_HOT = 2,
	TTWS_PRESSED = 3,
};


//
//  TRACKBARSTYLE class parts and states 
//
#define VSCLASS_TRACKBARSTYLE	L"TRACKBARSTYLE"
#define VSCLASS_TRACKBAR	L"TRACKBAR"

enum TRACKBARPARTS {
	TKP_TRACK = 1,
	TKP_TRACKVERT = 2,
	TKP_THUMB = 3,
	TKP_THUMBBOTTOM = 4,
	TKP_THUMBTOP = 5,
	TKP_THUMBVERT = 6,
	TKP_THUMBLEFT = 7,
	TKP_THUMBRIGHT = 8,
	TKP_TICS = 9,
	TKP_TICSVERT = 10,
};

#define TRACKBARSTYLEPARTS TRACKBARPARTS;

enum TRACKBARSTYLESTATES {
	TKS_NORMAL = 1,
};

enum TRACKSTATES {
	TRS_NORMAL = 1,
};

enum TRACKVERTSTATES {
	TRVS_NORMAL = 1,
};

enum THUMBSTATES {
	TUS_NORMAL = 1,
	TUS_HOT = 2,
	TUS_PRESSED = 3,
	TUS_FOCUSED = 4,
	TUS_DISABLED = 5,
};

enum THUMBBOTTOMSTATES {
	TUBS_NORMAL = 1,
	TUBS_HOT = 2,
	TUBS_PRESSED = 3,
	TUBS_FOCUSED = 4,
	TUBS_DISABLED = 5,
};

enum THUMBTOPSTATES {
	TUTS_NORMAL = 1,
	TUTS_HOT = 2,
	TUTS_PRESSED = 3,
	TUTS_FOCUSED = 4,
	TUTS_DISABLED = 5,
};

enum THUMBVERTSTATES {
	TUVS_NORMAL = 1,
	TUVS_HOT = 2,
	TUVS_PRESSED = 3,
	TUVS_FOCUSED = 4,
	TUVS_DISABLED = 5,
};

enum THUMBLEFTSTATES {
	TUVLS_NORMAL = 1,
	TUVLS_HOT = 2,
	TUVLS_PRESSED = 3,
	TUVLS_FOCUSED = 4,
	TUVLS_DISABLED = 5,
};

enum THUMBRIGHTSTATES {
	TUVRS_NORMAL = 1,
	TUVRS_HOT = 2,
	TUVRS_PRESSED = 3,
	TUVRS_FOCUSED = 4,
	TUVRS_DISABLED = 5,
};

enum TICSSTATES {
	TSS_NORMAL = 1,
};

enum TICSVERTSTATES {
	TSVS_NORMAL = 1,
};


//
//  TREEVIEWSTYLE class parts and states 
//
#define VSCLASS_TREEVIEWSTYLE	L"TREEVIEWSTYLE"
#define VSCLASS_TREEVIEW	L"TREEVIEW"

enum TREEVIEWPARTS {
	TVP_TREEITEM = 1,
	TVP_GLYPH = 2,
	TVP_BRANCH = 3,
	TVP_HOTGLYPH = 4,
};

#define TREEVIEWSTYLEPARTS TREEVIEWPARTS;

enum TREEITEMSTATES {
	TREIS_NORMAL = 1,
	TREIS_HOT = 2,
	TREIS_SELECTED = 3,
	TREIS_DISABLED = 4,
	TREIS_SELECTEDNOTFOCUS = 5,
	TREIS_HOTSELECTED = 6,
};

enum GLYPHSTATES {
	GLPS_CLOSED = 1,
	GLPS_OPENED = 2,
};

enum HOTGLYPHSTATES {
	HGLPS_CLOSED = 1,
	HGLPS_OPENED = 2,
};


//
//  WINDOWSTYLE class parts and states 
//
#define VSCLASS_WINDOWSTYLE	L"WINDOWSTYLE"
#define VSCLASS_WINDOW	L"WINDOW"

enum WINDOWPARTS {
	WP_CAPTION = 1,
	WP_SMALLCAPTION = 2,
	WP_MINCAPTION = 3,
	WP_SMALLMINCAPTION = 4,
	WP_MAXCAPTION = 5,
	WP_SMALLMAXCAPTION = 6,
	WP_FRAMELEFT = 7,
	WP_FRAMERIGHT = 8,
	WP_FRAMEBOTTOM = 9,
	WP_SMALLFRAMELEFT = 10,
	WP_SMALLFRAMERIGHT = 11,
	WP_SMALLFRAMEBOTTOM = 12,
	WP_SYSBUTTON = 13,
	WP_MDISYSBUTTON = 14,
	WP_MINBUTTON = 15,
	WP_MDIMINBUTTON = 16,
	WP_MAXBUTTON = 17,
	WP_CLOSEBUTTON = 18,
	WP_SMALLCLOSEBUTTON = 19,
	WP_MDICLOSEBUTTON = 20,
	WP_RESTOREBUTTON = 21,
	WP_MDIRESTOREBUTTON = 22,
	WP_HELPBUTTON = 23,
	WP_MDIHELPBUTTON = 24,
	WP_HORZSCROLL = 25,
	WP_HORZTHUMB = 26,
	WP_VERTSCROLL = 27,
	WP_VERTTHUMB = 28,
	WP_DIALOG = 29,
	WP_CAPTIONSIZINGTEMPLATE = 30,
	WP_SMALLCAPTIONSIZINGTEMPLATE = 31,
	WP_FRAMELEFTSIZINGTEMPLATE = 32,
	WP_SMALLFRAMELEFTSIZINGTEMPLATE = 33,
	WP_FRAMERIGHTSIZINGTEMPLATE = 34,
	WP_SMALLFRAMERIGHTSIZINGTEMPLATE = 35,
	WP_FRAMEBOTTOMSIZINGTEMPLATE = 36,
	WP_SMALLFRAMEBOTTOMSIZINGTEMPLATE = 37,
	WP_FRAME = 38,
};

#define WINDOWSTYLEPARTS WINDOWPARTS;

enum FRAMESTATES {
	FS_ACTIVE = 1,
	FS_INACTIVE = 2,
};

enum CAPTIONSTATES {
	CS_ACTIVE = 1,
	CS_INACTIVE = 2,
	CS_DISABLED = 3,
};

enum MAXCAPTIONSTATES {
	MXCS_ACTIVE = 1,
	MXCS_INACTIVE = 2,
	MXCS_DISABLED = 3,
};

enum MINCAPTIONSTATES {
	MNCS_ACTIVE = 1,
	MNCS_INACTIVE = 2,
	MNCS_DISABLED = 3,
};

enum HORZSCROLLSTATES {
	HSS_NORMAL = 1,
	HSS_HOT = 2,
	HSS_PUSHED = 3,
	HSS_DISABLED = 4,
};

enum HORZTHUMBSTATES {
	HTS_NORMAL = 1,
	HTS_HOT = 2,
	HTS_PUSHED = 3,
	HTS_DISABLED = 4,
};

enum VERTSCROLLSTATES {
	VSS_NORMAL = 1,
	VSS_HOT = 2,
	VSS_PUSHED = 3,
	VSS_DISABLED = 4,
};

enum VERTTHUMBSTATES {
	VTS_NORMAL = 1,
	VTS_HOT = 2,
	VTS_PUSHED = 3,
	VTS_DISABLED = 4,
};

enum SYSBUTTONSTATES {
	SBS_NORMAL = 1,
	SBS_HOT = 2,
	SBS_PUSHED = 3,
	SBS_DISABLED = 4,
};

enum MINBUTTONSTATES {
	MINBS_NORMAL = 1,
	MINBS_HOT = 2,
	MINBS_PUSHED = 3,
	MINBS_DISABLED = 4,
};

enum MAXBUTTONSTATES {
	MAXBS_NORMAL = 1,
	MAXBS_HOT = 2,
	MAXBS_PUSHED = 3,
	MAXBS_DISABLED = 4,
};

enum RESTOREBUTTONSTATES {
	RBS_NORMAL = 1,
	RBS_HOT = 2,
	RBS_PUSHED = 3,
	RBS_DISABLED = 4,
};

enum HELPBUTTONSTATES {
	HBS_NORMAL = 1,
	HBS_HOT = 2,
	HBS_PUSHED = 3,
	HBS_DISABLED = 4,
};

enum CLOSEBUTTONSTATES {
	CBS_NORMAL = 1,
	CBS_HOT = 2,
	CBS_PUSHED = 3,
	CBS_DISABLED = 4,
};


#endif //__VSSTYLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WabIab.h ===
/* IAddrBook Interface ----------------------------------------------------- */

/*  CreateOneOff */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO		((ULONG) 0x00010000) */

/*  RecipOptions */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  QueryDefaultRecipOpt */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  GetSearchPath */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */


#ifndef WABIAB_H
#define WABIAB_H

// These are WAB only flags for IAdrBook::ResolveName
//      MAPI_UNICODE                        ((ULONG) 0x80000000)
#define WAB_RESOLVE_LOCAL_ONLY              ((ULONG) 0x80000000) 
#define WAB_RESOLVE_ALL_EMAILS              ((ULONG) 0x40000000)
#define WAB_RESOLVE_NO_ONE_OFFS             ((ULONG) 0x20000000)
#define WAB_RESOLVE_NEED_CERT               ((ULONG) 0x10000000)
#define WAB_RESOLVE_NO_NOT_FOUND_UI         ((ULONG) 0x08000000)
#define WAB_RESOLVE_USE_CURRENT_PROFILE     ((ULONG) 0x04000000)
#define WAB_RESOLVE_FIRST_MATCH             ((ULONG) 0x02000000)
#define WAB_RESOLVE_UNICODE                 ((ULONG) 0x01000000)
//      MAPI_DIALOG                         ((ULONG) 0x00000008)

#ifndef MAPIX_H

#define MAPI_IADDRBOOK_METHODS(IPURE)									\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;          	\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(CreateOneOff)											\
		(THIS_	LPTSTR						lpszName,					\
				LPTSTR						lpszAdrType,				\
				LPTSTR						lpszAddress,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(NewEntry)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cbEIDContainer,				\
				LPENTRYID					lpEIDContainer,				\
				ULONG						cbEIDNewEntryTpl,			\
				LPENTRYID					lpEIDNewEntryTpl,			\
				ULONG FAR *					lpcbEIDNewEntry,			\
				LPENTRYID FAR *				lppEIDNewEntry) IPURE;		\
	MAPIMETHOD(ResolveName)												\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				LPTSTR						lpszNewEntryTitle,			\
				LPADRLIST					lpAdrList) IPURE;			\
	MAPIMETHOD(Address)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPADRPARM					lpAdrParms,					\
				LPADRLIST FAR *				lppAdrList) IPURE;			\
	MAPIMETHOD(Details)													\
		(THIS_	ULONG_PTR FAR *				lpulUIParam,				\
				LPFNDISMISS					lpfnDismiss,				\
				LPVOID						lpvDismissContext,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPFNBUTTON					lpfButtonCallback,			\
				LPVOID						lpvButtonContext,			\
				LPTSTR						lpszButtonText,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RecipOptions)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				LPADRENTRY					lpRecip) IPURE;				\
	MAPIMETHOD(QueryDefaultRecipOpt)									\
		(THIS_	LPTSTR						lpszAdrType,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(GetPAB)													\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetPAB)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetDefaultDir)											\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetDefaultDir)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet FAR *				lppSearchPath) IPURE;		\
	MAPIMETHOD(SetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSearchPath) IPURE;		\
	MAPIMETHOD(PrepareRecips)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray				lpPropTagArray,				\
				LPADRLIST					lpRecipList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IAddrBook
DECLARE_MAPI_INTERFACE_(IAddrBook, IMAPIProp)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IADDRBOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IAddrBook, LPADRBOOK);
#endif  // MAPIX_H
#endif  // WABIAB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WabMem.h ===
#if !defined(WABMEM_H)
#define WABMEM_H

#if !defined(MAPIX_H)
typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEBUFFER)(
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEMORE)(
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE MAPIFREEBUFFER)(
	LPVOID			lpBuffer
);

typedef MAPIALLOCATEBUFFER FAR	*LPMAPIALLOCATEBUFFER;
typedef MAPIALLOCATEMORE FAR	*LPMAPIALLOCATEMORE;
typedef MAPIFREEBUFFER FAR 		*LPMAPIFREEBUFFER;

#endif  // MAPIX_H

typedef SCODE (STDMETHODCALLTYPE WABALLOCATEBUFFER)(
   LPWABOBJECT     lpWABObject,
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE WABALLOCATEMORE)(
   LPWABOBJECT     lpWABObject,
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE WABFREEBUFFER)(
   LPWABOBJECT     lpWABObject,
	LPVOID			lpBuffer
);

typedef WABALLOCATEBUFFER FAR	*LPWABALLOCATEBUFFER;
typedef WABALLOCATEMORE FAR	*LPWABALLOCATEMORE;
typedef WABFREEBUFFER FAR 		*LPWABFREEBUFFER;
#endif  // WABMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WabNot.h ===
/*
 *	WABNOT.H
 *
 * Defines Notification structures.  These are also defined in mapispi.h.
 *
 * Copyright 1986-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(MAPISPI_H) && !defined(WABSPI_H)
#define WABSPI_H
/* Include common MAPI header files if they haven't been already. */


#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Notification key structure for the MAPI notification engine */

typedef struct
{
	ULONG		cb;				/* How big the key is */
	BYTE		ab[MAPI_DIM];	/* Key contents */
} NOTIFKEY, FAR * LPNOTIFKEY;

#define CbNewNOTIFKEY(_cb)		(offsetof(NOTIFKEY,ab) + (_cb))
#define CbNOTIFKEY(_lpkey)		(offsetof(NOTIFKEY,ab) + (_lpkey)->cb)
#define SizedNOTIFKEY(_cb, _name) \
	struct _NOTIFKEY_ ## _name \
{ \
	ULONG		cb; \
	BYTE		ab[_cb]; \
} _name


/* For Subscribe() */

#define NOTIFY_SYNC				((ULONG) 0x40000000)

/* For Notify() */

#define NOTIFY_CANCELED			((ULONG) 0x80000000)


/* From the Notification Callback function (well, this is really a ulResult) */

#define CALLBACK_DISCONTINUE	((ULONG) 0x80000000)

/* For Transport's SpoolerNotify() */

#define NOTIFY_NEWMAIL			((ULONG) 0x00000001)
#define NOTIFY_READYTOSEND		((ULONG) 0x00000002)
#define NOTIFY_SENTDEFERRED		((ULONG) 0x00000004)
#define NOTIFY_CRITSEC			((ULONG) 0x00001000)
#define NOTIFY_NONCRIT			((ULONG) 0x00002000)
#define NOTIFY_CONFIG_CHANGE	((ULONG) 0x00004000)
#define NOTIFY_CRITICAL_ERROR	((ULONG) 0x10000000)

/* For Message Store's SpoolerNotify() */

#define NOTIFY_NEWMAIL_RECEIVED	((ULONG) 0x20000000)

/* For ModifyStatusRow() */

#define	STATUSROW_UPDATE		((ULONG) 0x10000000)

/* For IStorageFromStream() */

#define STGSTRM_RESET			((ULONG) 0x00000000)
#define STGSTRM_CURRENT			((ULONG) 0x10000000)
#define STGSTRM_MODIFY			((ULONG) 0x00000002)
#define STGSTRM_CREATE			((ULONG) 0x00001000)

/* For GetOneOffTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/* For CreateOneOff() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO	((ULONG) 0x00010000) */

/* For ReadReceipt() */
#define MAPI_NON_READ			((ULONG) 0x00000001)

/* For DoConfigPropSheet() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#ifdef __cplusplus
}
#endif

#endif /* MAPISPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Wab.h ===
/*
 * WAB.H
 *
 * Top level public header for WAB API functions.
 *
 */

#include <wabdefs.h>
#include <wabcode.h>
#include <wabtags.h>
#include <wabutil.h>
#include <wabiab.h>
#include <wabapi.h>
#include <wabmem.h>
#include <wabnot.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\vswriter.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Abstract:

    @doc
    @module Writer.h | Declaration of Writer
    @end
--*/

#ifndef __CVSS_WRITER_H_
#define __CVSS_WRITER_H_

#include "vsserror.h"

const IID IID_IVssComponent =                   // d2c72c96-c121-4518-b627-e5a93d010ead
{
    0xd2c72c96,
    0xc121,
    0x4518,
    { 0xb6, 0x27, 0xe5, 0xa9, 0x3d, 0x01, 0x0e, 0xad }
};

const IID IID_IVssComponentEx =                 // 156c8b5e-f131-4bd7-9c97-d1923be7e1fa
{
    0x156c8b5e,
    0xf131,
    0x4bd7,
    { 0x9c, 0x97, 0xd1, 0x92, 0x3b, 0xe7, 0xe1, 0xfa }
};

const IID IID_IVssComponentEx2 =                // 3b5be0f2-07a9-4e4b-bdd3-cfdc8e2c0d2d
{
    0x3b5be0f2,
    0x07a9,
    0x4e4b,
    { 0xbd, 0xd3, 0xcf, 0xdc, 0x8e, 0x2c, 0x0d, 0x2d }
};

const IID IID_IVssCreateWriterMetadataEx =      // 9f21981d-d469-4349-b807-39e64e4674e1
{
    0x9f21981d,
    0xd469,
    0x4349,
    { 0xb8, 0x07, 0x39, 0xe6, 0x4e, 0x46, 0x74, 0xe1 }
};


const IID IID_IVssCreateExpressWriterMetadata = // 9c772e77-b26e-427f-92dd-c996f41ea5e3
{
    0x9c772e77,
    0xb26e,
    0x427f,
    { 0x92, 0xdd, 0xc9, 0x96, 0xf4, 0x1e, 0xa5, 0xe3 }
};

const IID IID_IVssExpressWriter =               // e33affdc-59c7-47b1-97d5-4266598f6235
{
    0xe33affdc,
    0x59c7,
    0x47b1,
    {0x97, 0xd5, 0x42, 0x66, 0x59, 0x8f, 0x62, 0x35}
};

// declaration of how application data is used
typedef enum VSS_USAGE_TYPE
{
    VSS_UT_UNDEFINED = 0,
    VSS_UT_BOOTABLESYSTEMSTATE,     // formerly "system state"
    VSS_UT_SYSTEMSERVICE,           // system service
    VSS_UT_USERDATA,                // user data
    VSS_UT_OTHER                    // unclassified
};

typedef enum VSS_SOURCE_TYPE
{
    VSS_ST_UNDEFINED = 0,
    VSS_ST_TRANSACTEDDB,            // transacted db (e.g., SQL Server, JET Blue)
    VSS_ST_NONTRANSACTEDDB,         // not transacted(e.g., Jet Red)
    VSS_ST_OTHER                    // unclassified
};

typedef enum VSS_RESTOREMETHOD_ENUM
{
    VSS_RME_UNDEFINED = 0,
    VSS_RME_RESTORE_IF_NOT_THERE,
    VSS_RME_RESTORE_IF_CAN_REPLACE,
    VSS_RME_STOP_RESTORE_START,
    VSS_RME_RESTORE_TO_ALTERNATE_LOCATION,
    VSS_RME_RESTORE_AT_REBOOT,
    VSS_RME_RESTORE_AT_REBOOT_IF_CANNOT_REPLACE,
    VSS_RME_CUSTOM,
    VSS_RME_RESTORE_STOP_START
};

typedef enum VSS_WRITERRESTORE_ENUM
{
    VSS_WRE_UNDEFINED = 0,
    VSS_WRE_NEVER,
    VSS_WRE_IF_REPLACE_FAILS,
    VSS_WRE_ALWAYS
};

typedef enum VSS_COMPONENT_TYPE
{
    VSS_CT_UNDEFINED = 0,
    VSS_CT_DATABASE,
    VSS_CT_FILEGROUP
};

typedef enum VSS_ALTERNATE_WRITER_STATE
{
    VSS_AWS_UNDEFINED = 0,
    VSS_AWS_NO_ALTERNATE_WRITER,
    VSS_AWS_ALTERNATE_WRITER_EXISTS,
    VSS_AWS_THIS_IS_ALTERNATE_WRITER
};

// Flags to specify which types of events to receive.  Used in Subscribe.
typedef enum VSS_SUBSCRIBE_MASK
{
    VSS_SM_POST_SNAPSHOT_FLAG   = 0x00000001,
    VSS_SM_BACKUP_EVENTS_FLAG   = 0x00000002,
    VSS_SM_RESTORE_EVENTS_FLAG  = 0x00000004,
    VSS_SM_IO_THROTTLING_FLAG   = 0x00000008,
    VSS_SM_ALL_FLAGS            = 0xffffffff
};

// enumeration of restore targets
typedef enum VSS_RESTORE_TARGET
{
    VSS_RT_UNDEFINED = 0,
    VSS_RT_ORIGINAL,
    VSS_RT_ALTERNATE,
    VSS_RT_DIRECTED,
    VSS_RT_ORIGINAL_LOCATION
};

// enumeration of file restore status codes
typedef enum VSS_FILE_RESTORE_STATUS
{
    VSS_RS_UNDEFINED = 0,
    VSS_RS_NONE,
    VSS_RS_ALL,
    VSS_RS_FAILED
};

typedef enum VSS_COMPONENT_FLAGS
{
    VSS_CF_BACKUP_RECOVERY          = 0x00000001,
    VSS_CF_APP_ROLLBACK_RECOVERY    = 0x00000002,
    VSS_CF_NOT_SYSTEM_STATE         = 0x00000004
};

class IVssExamineWriterMetadata;

// file description
class IVssWMFiledesc
    : public IUnknown
{
public:
    // get path to toplevel directory
    STDMETHOD(GetPath)(
        __out   BSTR *pbstrPath
        ) = 0;

    // get filespec (may include wildcards)
    STDMETHOD(GetFilespec)(
        __out   BSTR *pbstrFilespec
        ) = 0;

    // is path a directory or root of a tree
    STDMETHOD(GetRecursive)(
        __out   bool *pbRecursive
        ) = 0;

    // alternate location for files
    STDMETHOD(GetAlternateLocation)(
        __out   BSTR *pbstrAlternateLocation
        ) = 0;

    // backup type
    STDMETHOD(GetBackupTypeMask)(
        __out   DWORD *pdwTypeMask
        ) = 0;
};


// dependency description
class IVssWMDependency
    : public IUnknown
{
public:
    STDMETHOD(GetWriterId)(OUT VSS_ID *pWriterId) = 0;
    STDMETHOD(GetLogicalPath)(OUT BSTR *pbstrLogicalPath) = 0;
    STDMETHOD(GetComponentName)(OUT BSTR *pbstrComponentName) = 0;
};

// backup components interface
class __declspec(uuid("d2c72c96-c121-4518-b627-e5a93d010ead")) IVssComponent
    : public IUnknown
{
public:
    // obtain logical path of component
    STDMETHOD(GetLogicalPath)(OUT BSTR *pbstrPath) = 0;

    // obtain component type(VSS_CT_DATABASE or VSS_CT_FILEGROUP)
    STDMETHOD(GetComponentType)(VSS_COMPONENT_TYPE *pct) = 0;

    // get component name
    STDMETHOD(GetComponentName)(OUT BSTR *pbstrName) = 0;

    // determine whether the component was successfully backed up.
    STDMETHOD(GetBackupSucceeded)(OUT bool *pbSucceeded) = 0;

    // get altermative location mapping count
    STDMETHOD(GetAlternateLocationMappingCount)
        (
        OUT UINT *pcMappings
        ) = 0;

    // get a paraticular alternative location mapping
    STDMETHOD(GetAlternateLocationMapping)
        (
        IN UINT iMapping,
        OUT IVssWMFiledesc **ppFiledesc
        ) = 0;

    // set the backup metadata for a component
    STDMETHOD(SetBackupMetadata)
        (
        IN LPCWSTR wszData
        ) = 0;

    // get the backup metadata for a component
    STDMETHOD(GetBackupMetadata)
        (
        OUT BSTR *pbstrData
        ) = 0;

    // indicate that only ranges in the file are to be backed up
    STDMETHOD(AddPartialFile)
        (
        IN LPCWSTR wszPath,
        IN LPCWSTR wszFilename,
        IN LPCWSTR wszRanges,
        IN LPCWSTR wszMetadata
        ) = 0;

    // get count of partial file declarations
    STDMETHOD(GetPartialFileCount)
        (
        OUT UINT *pcPartialFiles
        ) = 0;

    // get a partial file declaration
    STDMETHOD(GetPartialFile)
        (
        IN UINT iPartialFile,
        OUT BSTR *pbstrPath,
        OUT BSTR *pbstrFilename,
        OUT BSTR *pbstrRange,
        OUT BSTR *pbstrMetadata
        ) = 0;

    // determine if the component is selected to be restored
    STDMETHOD(IsSelectedForRestore)
        (
        OUT bool *pbSelectedForRestore
        ) = 0;

    STDMETHOD(GetAdditionalRestores)
        (
        OUT bool *pbAdditionalRestores
        ) = 0;

    // get count of new target specifications
    STDMETHOD(GetNewTargetCount)
        (
        OUT UINT *pcNewTarget
        ) = 0;

    STDMETHOD(GetNewTarget)
        (
        IN UINT iNewTarget,
        OUT IVssWMFiledesc **ppFiledesc
        ) = 0;

    // add a directed target specification
    STDMETHOD(AddDirectedTarget)
        (
        IN LPCWSTR wszSourcePath,
        IN LPCWSTR wszSourceFilename,
        IN LPCWSTR wszSourceRangeList,
        IN LPCWSTR wszDestinationPath,
        IN LPCWSTR wszDestinationFilename,
        IN LPCWSTR wszDestinationRangeList
        ) = 0;

    // get count of directed target specifications
    STDMETHOD(GetDirectedTargetCount)
        (
        OUT UINT *pcDirectedTarget
        ) = 0;

    // obtain a particular directed target specification
    STDMETHOD(GetDirectedTarget)
        (
        IN UINT iDirectedTarget,
        OUT BSTR *pbstrSourcePath,
        OUT BSTR *pbstrSourceFileName,
        OUT BSTR *pbstrSourceRangeList,
        OUT BSTR *pbstrDestinationPath,
        OUT BSTR *pbstrDestinationFilename,
        OUT BSTR *pbstrDestinationRangeList
        ) = 0;

    // set restore metadata associated with the component
    STDMETHOD(SetRestoreMetadata)
        (
        IN LPCWSTR wszRestoreMetadata
        ) = 0;

    // obtain restore metadata associated with the component
    STDMETHOD(GetRestoreMetadata)
        (
        OUT BSTR *pbstrRestoreMetadata
        ) = 0;

     // set the restore target
     STDMETHOD(SetRestoreTarget)
           (
        IN VSS_RESTORE_TARGET target
        ) = 0;

    // obtain the restore target
    STDMETHOD(GetRestoreTarget)
        (
        OUT VSS_RESTORE_TARGET *pTarget
        ) = 0;

    // set failure message during pre restore event
    STDMETHOD(SetPreRestoreFailureMsg)
        (
        IN LPCWSTR wszPreRestoreFailureMsg
        ) = 0;

    // obtain failure message during pre restore event
    STDMETHOD(GetPreRestoreFailureMsg)
        (
        OUT BSTR *pbstrPreRestoreFailureMsg
        ) = 0;

    // set the failure message during the post restore event
    STDMETHOD(SetPostRestoreFailureMsg)
        (
        IN LPCWSTR wszPostRestoreFailureMsg
        ) = 0;

    // obtain the failure message set during the post restore event
    STDMETHOD(GetPostRestoreFailureMsg)
        (
        OUT BSTR *pbstrPostRestoreFailureMsg
        ) = 0;

    // set the backup stamp of the backup
    STDMETHOD(SetBackupStamp)
        (
        IN LPCWSTR wszBackupStamp
        ) = 0;

    // obtain the stamp of the backup
    STDMETHOD(GetBackupStamp)
        (
        OUT BSTR *pbstrBackupStamp
        ) = 0;


    // obtain the backup stamp that the differential or incremental
    // backup is baed on
    STDMETHOD(GetPreviousBackupStamp)
        (
        OUT BSTR *pbstrBackupStamp
        ) = 0;

    // obtain backup options for the writer
    STDMETHOD(GetBackupOptions)
        (
        OUT BSTR *pbstrBackupOptions
        ) = 0;

    // obtain the restore options
    STDMETHOD(GetRestoreOptions)
        (
        OUT BSTR *pbstrRestoreOptions
        ) = 0;

    // obtain count of subcomponents to be restored
    STDMETHOD(GetRestoreSubcomponentCount)
        (
        OUT UINT *pcRestoreSubcomponent
        ) = 0;

    // obtain a particular subcomponent to be restored
    STDMETHOD(GetRestoreSubcomponent)
        (
        UINT iComponent,
        OUT BSTR *pbstrLogicalPath,
        OUT BSTR *pbstrComponentName,
        OUT bool *pbRepair
        ) = 0;


    // obtain whether files were successfully restored
    STDMETHOD(GetFileRestoreStatus)
        (
        OUT VSS_FILE_RESTORE_STATUS *pStatus
        ) = 0;

    // add differenced files by last modify time
    STDMETHOD(AddDifferencedFilesByLastModifyTime)
        (
        IN LPCWSTR wszPath,
        IN LPCWSTR wszFilespec,
        IN BOOL bRecursive,
        IN FILETIME ftLastModifyTime
        ) = 0;

    STDMETHOD(AddDifferencedFilesByLastModifyLSN)
        (
        IN LPCWSTR wszPath,
        IN LPCWSTR wszFilespec,
        IN BOOL bRecursive,
        IN BSTR bstrLsnString
        ) = 0;

    STDMETHOD(GetDifferencedFilesCount)
        (
        OUT UINT *pcDifferencedFiles
        ) = 0;

    STDMETHOD(GetDifferencedFile)
        (
        IN UINT iDifferencedFile,
        OUT BSTR *pbstrPath,
        OUT BSTR *pbstrFilespec,
        OUT BOOL *pbRecursive,
        OUT BSTR *pbstrLsnString,
        OUT FILETIME *pftLastModifyTime
        ) = 0;
};


// backup writer components interface (i.e., all components for an
// individual writer
class IVssWriterComponents
{
public:
    // get count of components
    STDMETHOD(GetComponentCount)(OUT UINT *pcComponents) = 0;

    // get information about the writer
    STDMETHOD(GetWriterInfo)
        (
        OUT VSS_ID *pidInstance,
        OUT VSS_ID *pidWriter
        ) = 0;

    // obtain a specific component
    STDMETHOD(GetComponent)
        (
        IN UINT iComponent,
        OUT IVssComponent **ppComponent
        ) = 0;
};


class __declspec(uuid("156c8b5e-f131-4bd7-9c97-d1923be7e1fa")) IVssComponentEx
    : public IVssComponent
{
public:
    // set a failure message during prepareforbackup
    STDMETHOD(SetPrepareForBackupFailureMsg)
        (
        __in LPCWSTR wszFailureMsg
        ) = 0;

    // set a failure message during postsnapshot
    STDMETHOD(SetPostSnapshotFailureMsg)
        (
        __in LPCWSTR wszFailureMsg
        ) = 0;

    // get the failure message set during prepareforbackup
    STDMETHOD(GetPrepareForBackupFailureMsg)
        (
        __deref_out_opt BSTR* pbstrFailureMsg
        ) = 0;

    // get the failure message set during postsnapshot
    STDMETHOD(GetPostSnapshotFailureMsg)
        (
        __deref_out_opt BSTR* pbstrFailureMsg
        ) = 0;


    // get the authoritative restore status
    STDMETHOD(GetAuthoritativeRestore)
        (
        __out bool* pbAuth
        ) = 0;

    // get the roll-forward status
    STDMETHOD(GetRollForward)
        (
        __out VSS_ROLLFORWARD_TYPE* pRollType,
        __deref_out_opt BSTR* pbstrPoint
        ) = 0;

    // get the restore name
    STDMETHOD(GetRestoreName)
        (
        __deref_out_opt BSTR* pbstrName
        ) = 0;
};


class __declspec(uuid("3b5be0f2-07a9-4e4b-bdd3-cfdc8e2c0d2d")) IVssComponentEx2
    : public IVssComponentEx
{
public:
    STDMETHOD(SetFailure)
        (
        __in        HRESULT hr,
        __in        HRESULT hrApplication,
        __in_opt    LPCWSTR wszApplicationMessage,
        __in        DWORD   dwReserved
        ) = 0;

    STDMETHOD(GetFailure)
        (
        __out       HRESULT *phr,
        __out       HRESULT *phrApplication,
        __out       BSTR    *pbstrApplicationMessage,
        __out       DWORD   *pdwReserved
        ) = 0;
};


// create backup metadata interface
class IVssCreateWriterMetadata
{
public:
    // add files to include to metadata document
    STDMETHOD(AddIncludeFiles)
        (
        IN LPCWSTR wszPath,
        IN LPCWSTR wszFilespec,
        IN bool bRecursive,
        IN LPCWSTR wszAlternateLocation
        ) = 0;

    // add files to exclude to metadata document
    STDMETHOD(AddExcludeFiles)
        (
        IN LPCWSTR wszPath,
        IN LPCWSTR wszFilespec,
        IN bool bRecursive
        ) = 0;

    // add component to metadata document
    STDMETHOD(AddComponent)
        (
        IN VSS_COMPONENT_TYPE ct,
        IN LPCWSTR wszLogicalPath,
        IN LPCWSTR wszComponentName,
        IN LPCWSTR wszCaption,
        IN const BYTE *pbIcon,
        IN UINT cbIcon,
        IN bool bRestoreMetadata,
        IN bool bNotifyOnBackupComplete,
        IN bool bSelectable,
        IN bool bSelectableForRestore = false,
        IN DWORD dwComponentFlags = 0
        ) = 0;

    // add physical database files to a database component
    STDMETHOD(AddDatabaseFiles)
        (
        IN LPCWSTR wszLogicalPath,
        IN LPCWSTR wszDatabaseName,
        IN LPCWSTR wszPath,
        IN LPCWSTR wszFilespec,
        IN DWORD dwBackupTypeMask = (VSS_FSBT_ALL_BACKUP_REQUIRED |
                                     VSS_FSBT_ALL_SNAPSHOT_REQUIRED)
        ) = 0;

    // add log files to a database component
    STDMETHOD(AddDatabaseLogFiles)
        (
        IN LPCWSTR wszLogicalPath,
        IN LPCWSTR wszDatabaseName,
        IN LPCWSTR wszPath,
        IN LPCWSTR wszFilespec,
        IN DWORD dwBackupTypeMask = (VSS_FSBT_ALL_BACKUP_REQUIRED |
                                     VSS_FSBT_ALL_SNAPSHOT_REQUIRED)
        ) = 0;


    // add files to a FILE_GROUP component
    STDMETHOD(AddFilesToFileGroup)
        (
        IN LPCWSTR wszLogicalPath,
        IN LPCWSTR wszGroupName,
        IN LPCWSTR wszPath,
        IN LPCWSTR wszFilespec,
        IN bool bRecursive,
        IN LPCWSTR wszAlternateLocation,
        IN DWORD dwBackupTypeMask = (VSS_FSBT_ALL_BACKUP_REQUIRED |
                                     VSS_FSBT_ALL_SNAPSHOT_REQUIRED)
        ) = 0;

    // create a restore method
    STDMETHOD(SetRestoreMethod)
        (
        IN VSS_RESTOREMETHOD_ENUM method,
        IN LPCWSTR wszService,
        IN LPCWSTR wszUserProcedure,
        IN VSS_WRITERRESTORE_ENUM writerRestore,
        IN bool bRebootRequired
        ) = 0;

    // add alternative location mappings to the restore method
    STDMETHOD(AddAlternateLocationMapping)
        (
        IN LPCWSTR wszSourcePath,
        IN LPCWSTR wszSourceFilespec,
        IN bool bRecursive,
        IN LPCWSTR wszDestination
        ) = 0;

    // add a dependency to another writer's component
    STDMETHOD(AddComponentDependency)
                (
                IN LPCWSTR wszForLogicalPath,
                IN LPCWSTR wszForComponentName,
                IN VSS_ID onWriterId,
                IN LPCWSTR wszOnLogicalPath,
                IN LPCWSTR wszOnComponentName
                ) = 0;

    // Set the schema used during backup
    STDMETHOD(SetBackupSchema)
                (
                IN DWORD dwSchemaMask
                ) = 0;

    // obtain reference to actual XML document
    STDMETHOD(GetDocument)(IXMLDOMDocument **pDoc) = 0;

    // save document as an XML string
    STDMETHOD(SaveAsXML)(BSTR *pbstrXML) = 0;
};

class __declspec(uuid("9f21981d-d469-4349-b807-39e64e4674e1")) IVssCreateWriterMetadataEx : public IVssCreateWriterMetadata, public IUnknown
{
public:
    // add files to exclude to metadata document
    STDMETHOD(AddExcludeFilesFromSnapshot)
        (
        __in LPCWSTR wszPath,
        __in LPCWSTR wszFilespec,
        __in bool bRecursive
        ) = 0;
};


// implementation class for writers
class IVssWriterImpl : public IUnknown
{
public:
    // initialize writer
    virtual HRESULT Initialize(
        __in    VSS_ID                      writerId,
        __in    LPCWSTR                     wszWriterName,
        __in    LPCWSTR                     wszWriterInstanceName,
        __in    DWORD                       dwMajorVersion,
        __in    DWORD                       dwMinorVersion,
        __in    VSS_USAGE_TYPE              ut,
        __in    VSS_SOURCE_TYPE             st,
        __in    VSS_APPLICATION_LEVEL       nLevel,
        __in    DWORD                       dwTimeout,
        __in    VSS_ALTERNATE_WRITER_STATE  aws,
        __in    bool                        bIOThrottlingOnly
        ) = 0;

    // subscribe to events
    virtual HRESULT Subscribe(
        __in    DWORD   dwSubscribeTimeout,
        __in    DWORD   dwEventFlags
        ) = 0;

    // unsubscribe from events
    virtual HRESULT Unsubscribe() = 0;

    virtual void Uninitialize() = 0;

    // get array of volume names
    virtual LPCWSTR *GetCurrentVolumeArray() const = 0;

    // get # of volumes in volume array
    virtual UINT GetCurrentVolumeCount() const = 0;

    // get the snapshot device name for a particular volume
    virtual HRESULT GetSnapshotDeviceName(
        __in            LPCWSTR wszOriginalVolume,
        __deref_out_opt LPCWSTR *ppwszSnapshotDevice
        ) const = 0;

    // get id of snapshot set
    virtual VSS_ID GetCurrentSnapshotSetId() const = 0;

    // get the current backup context
    virtual LONG GetContext() const = 0;

    // determine which Freeze event writer responds to
    virtual VSS_APPLICATION_LEVEL GetCurrentLevel() const = 0;

    // determine if path is included in the snapshot
    virtual bool IsPathAffected(__in LPCWSTR wszPath) const = 0;

    // determine if bootable state is backed up
    virtual bool IsBootableSystemStateBackedUp() const = 0;

    // determine if the backup application is selecting components
    virtual bool AreComponentsSelected() const = 0;

    // determine the backup type for the backup
    virtual VSS_BACKUP_TYPE GetBackupType() const = 0;

    // determine the type of restore
    virtual VSS_RESTORE_TYPE GetRestoreType() const = 0;

    // let writer pass back indication of reason for failure
    virtual HRESULT SetWriterFailure(
        __in    HRESULT hr
        ) = 0;

    // determine if requestor support partial file backups
    virtual bool IsPartialFileSupportEnabled() const = 0;

    virtual HRESULT InstallAlternateWriter(
        __in    VSS_ID  idWriter,
        __in    CLSID   clsid
        ) = 0;

    // determine the current identity information
    virtual IVssExamineWriterMetadata* GetIdentityInformation() const = 0;

    // let writer pass back indication of reason for failure
    virtual HRESULT SetWriterFailureEx(
        __in    HRESULT hr,
        __in    HRESULT hrApplication,
        __in    LPCWSTR wszApplicationMessage
        ) = 0;

    virtual HRESULT GetSessionId(
        __out   VSS_ID  *idSession
        ) = 0;

    virtual bool IsWriterShuttingDown(
        ) = 0;
};


class __declspec(uuid("9c772e77-b26e-427f-92dd-c996f41ea5e3")) IVssCreateExpressWriterMetadata
    : public IUnknown
{
public:
    // add files to exclude to metadata document
    STDMETHOD(AddExcludeFiles)(
        __in    LPCWSTR wszPath,
        __in    LPCWSTR wszFilespec,
        __in    bool bRecursive
        ) = 0;

    // add component to metadata document
    STDMETHOD(AddComponent)(
        __in    VSS_COMPONENT_TYPE ct,
        __in    LPCWSTR wszLogicalPath,
        __in    LPCWSTR wszComponentName,
        __in    LPCWSTR wszCaption,
        __in    const BYTE *pbIcon,
        __in    UINT cbIcon,
        __in    bool bRestoreMetadata,
        __in    bool bNotifyOnBackupComplete,
        __in    bool bSelectable,
        __in    bool bSelectableForRestore = false,
        __in    DWORD dwComponentFlags = 0
        ) = 0;

    // add files to a FILE_GROUP component
    STDMETHOD(AddFilesToFileGroup)(
        __in    LPCWSTR wszLogicalPath,
        __in    LPCWSTR wszGroupName,
        __in    LPCWSTR wszPath,
        __in    LPCWSTR wszFilespec,
        __in    bool bRecursive,
        __in    LPCWSTR wszAlternateLocation,
        __in    DWORD dwBackupTypeMask = (VSS_FSBT_ALL_BACKUP_REQUIRED | VSS_FSBT_ALL_SNAPSHOT_REQUIRED)
        ) = 0;

    // create a restore method
    STDMETHOD(SetRestoreMethod)(
        __in    VSS_RESTOREMETHOD_ENUM method,
        __in    LPCWSTR wszService,
        __in    LPCWSTR wszUserProcedure,
        __in    VSS_WRITERRESTORE_ENUM writerRestore,
        __in    bool bRebootRequired
        ) = 0;

    // add a dependency to another writer's component
    STDMETHOD(AddComponentDependency)(
        __in    LPCWSTR wszForLogicalPath,
        __in    LPCWSTR wszForComponentName,
        __in    VSS_ID onWriterId,
        __in    LPCWSTR wszOnLogicalPath,
        __in    LPCWSTR wszOnComponentName
        ) = 0;

    // Set the schema used during backup
    STDMETHOD(SetBackupSchema)(
        __in    DWORD dwSchemaMask
        ) = 0;

    // save document as an XML string
    STDMETHOD(SaveAsXML)(
        __out   BSTR *pbstrXML
        ) = 0;
};


class __declspec(uuid("e33affdc-59c7-47b1-97d5-4266598f6235")) IVssExpressWriter
    : public IUnknown
{
public:
    STDMETHOD(CreateMetadata)(
        __in    VSS_ID                          writerId,
        __in    LPCWSTR                         writerName,
        __in    VSS_USAGE_TYPE                  usageType,
        __in    DWORD                           versionMajor,
        __in    DWORD                           versionMinor,
        __in    DWORD                           reserved,
        __out   IVssCreateExpressWriterMetadata **ppMetadata
        ) = 0;

    STDMETHOD(LoadMetadata)(
        __in    LPCWSTR metadata,
        __in    DWORD   reserved
        ) = 0;

    STDMETHOD(Register)() = 0;

    STDMETHOD(Unregister)(
        __in    VSS_ID  writerId
        ) = 0;
};


class CVssWriter;


/////////////////////////////////////////////////////////////////////////////
// CVssWriter

extern "C"  {
    HRESULT STDAPICALLTYPE CreateWriter(__in CVssWriter* pWriter, __out IVssWriterImpl** pWriterImpl);
}


class CVssWriter
{
// Constants
public:

// Constructors & Destructors
public:
    STDMETHODCALLTYPE CVssWriter()
        : m_pWriterImpl(NULL)
    {
    }

    virtual STDMETHODCALLTYPE ~CVssWriter()
    {
        if (m_pWriterImpl != NULL)
        {
            m_pWriterImpl->Uninitialize();
            m_pWriterImpl->Release();
            m_pWriterImpl = NULL;
        }
    }

// Exposed operations
public:
    // initialize the writer object
    HRESULT STDMETHODCALLTYPE Initialize(
        __in VSS_ID WriterId,
        __in LPCWSTR wszWriterName,
        __in VSS_USAGE_TYPE ut,
        __in VSS_SOURCE_TYPE st,
        __in VSS_APPLICATION_LEVEL nLevel = VSS_APP_FRONT_END,
        __in DWORD dwTimeoutFreeze = 60000,         // Maximum milliseconds between Freeze/Thaw
        __in VSS_ALTERNATE_WRITER_STATE aws = VSS_AWS_NO_ALTERNATE_WRITER,
        __in bool bIOThrottlingOnly = false,
        __in LPCWSTR wszWriterInstanceName = NULL
        )
    {
        if (m_pWriterImpl != NULL)
            return E_FAIL;

        HRESULT hr = CreateWriter(this, &m_pWriterImpl);
        if (FAILED(hr))
            return hr;

        hr = m_pWriterImpl->Initialize(WriterId, wszWriterName, wszWriterInstanceName, 0, 0, ut, st, nLevel, dwTimeoutFreeze, aws, bIOThrottlingOnly);
        if (FAILED(hr))
        {
            m_pWriterImpl->Release();
            m_pWriterImpl = NULL;
        }

        return hr;
    }

    // cause the writer to subscribe to events.
    HRESULT STDMETHODCALLTYPE Subscribe
        (
        __in DWORD dwEventFlags = VSS_SM_BACKUP_EVENTS_FLAG | VSS_SM_RESTORE_EVENTS_FLAG
        )
    {
        if (m_pWriterImpl == NULL)
            return E_FAIL;

        return m_pWriterImpl->Subscribe(0, dwEventFlags);
    }

    // cause the writer to unsubscribe from events
    HRESULT STDMETHODCALLTYPE Unsubscribe()
    {
        if (m_pWriterImpl == NULL)
            return E_FAIL;

        m_pWriterImpl->Unsubscribe();


        return S_OK;
    }

    // installs an alternative writer
    HRESULT STDMETHODCALLTYPE InstallAlternateWriter
        (
        __in VSS_ID writerId,
        __in CLSID persistentWriterClassId
        )
    {
        if (m_pWriterImpl == NULL)
            return E_FAIL;

        return m_pWriterImpl->InstallAlternateWriter(writerId, persistentWriterClassId);
    }

    // Internal properties - accessible from OnXXX methods
protected:

    // get array of volume names
    LPCWSTR* STDMETHODCALLTYPE GetCurrentVolumeArray() const
    {
        if (m_pWriterImpl == NULL)
            return NULL;

        return m_pWriterImpl->GetCurrentVolumeArray();
    }

    // get count of volume names in array
    UINT STDMETHODCALLTYPE GetCurrentVolumeCount() const
    {
        if (m_pWriterImpl == NULL)
            return 0;

        return m_pWriterImpl->GetCurrentVolumeCount();
    }

    // get the name of the snapshot device corresponding to a given volume.
    HRESULT STDMETHODCALLTYPE GetSnapshotDeviceName
    (
        __in LPCWSTR wszOriginalVolume,
        __deref_out_opt LPCWSTR* ppwszSnapshotDevice
    ) const
    {
        if (m_pWriterImpl == NULL)
            return E_FAIL;

        return m_pWriterImpl->GetSnapshotDeviceName(wszOriginalVolume, ppwszSnapshotDevice);
    }

    // current snapshot set GUID
    VSS_ID STDMETHODCALLTYPE GetCurrentSnapshotSetId() const
    {
        if (m_pWriterImpl == NULL)
            return GUID_NULL;

        return m_pWriterImpl->GetCurrentSnapshotSetId();
    }

    // Current backup context.
    LONG STDMETHODCALLTYPE GetContext() const
    {
        if (m_pWriterImpl == NULL)
            return 0;

        return m_pWriterImpl->GetContext();
    }

    // current app level (either 1,2,3)
    VSS_APPLICATION_LEVEL STDMETHODCALLTYPE GetCurrentLevel() const
    {
        if (m_pWriterImpl == NULL)
            return VSS_APP_AUTO;

        return m_pWriterImpl->GetCurrentLevel();
    }

    // determine if path is in set of volumes being snapshotted
    bool STDMETHODCALLTYPE IsPathAffected
        (
        __in LPCWSTR wszPath
        ) const
        {
        if (m_pWriterImpl == NULL)
            return false;

        return m_pWriterImpl->IsPathAffected(wszPath);
        }

    // does the backup include bootable state (formerly system state backup)
    bool STDMETHODCALLTYPE IsBootableSystemStateBackedUp() const
    {
        if (m_pWriterImpl == NULL)
            return false;

        return m_pWriterImpl->IsBootableSystemStateBackedUp();
    }

    // is the backup application smart (i.e., selecting components) or
    // dump (i.e., just selecting volumes)
    bool STDMETHODCALLTYPE AreComponentsSelected() const
    {
        if (m_pWriterImpl == NULL)
            return false;

        return m_pWriterImpl->AreComponentsSelected();
    }

    VSS_BACKUP_TYPE STDMETHODCALLTYPE GetBackupType() const
    {
        if (m_pWriterImpl == NULL)
            return VSS_BT_UNDEFINED;

        return m_pWriterImpl->GetBackupType();
    }

    VSS_RESTORE_TYPE STDMETHODCALLTYPE GetRestoreType() const
    {
        if (m_pWriterImpl == NULL)
            return VSS_RTYPE_UNDEFINED;

        return m_pWriterImpl->GetRestoreType();
    }

    bool STDMETHODCALLTYPE IsPartialFileSupportEnabled() const
    {
        if (m_pWriterImpl == NULL)
            return false;

        return m_pWriterImpl->IsPartialFileSupportEnabled();
    }

    HRESULT STDMETHODCALLTYPE SetWriterFailure(HRESULT hr)
    {
        if (m_pWriterImpl == NULL)
            return E_FAIL;

        return m_pWriterImpl->SetWriterFailure(hr);
    }

// Ovverides
public:
    // callback when request for metadata comes in
    virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
    {
        UNREFERENCED_PARAMETER(pMetadata);
        return true;
    }

    // callback for prepare backup event
    virtual bool STDMETHODCALLTYPE OnPrepareBackup(
        __in IVssWriterComponents *pComponent
        )
    {
        UNREFERENCED_PARAMETER(pComponent);
        return true;
    }

    // callback for prepare snapsot event
    virtual bool STDMETHODCALLTYPE OnPrepareSnapshot() = 0;

    // callback for freeze event
    virtual bool STDMETHODCALLTYPE OnFreeze() = 0;

    // callback for thaw event
    virtual bool STDMETHODCALLTYPE OnThaw() = 0;

    // callback if current sequence is aborted
    virtual bool STDMETHODCALLTYPE OnAbort() = 0;

    // callback on backup complete event
    virtual bool STDMETHODCALLTYPE OnBackupComplete
        (
        __in IVssWriterComponents *pComponent
        )
    {
        UNREFERENCED_PARAMETER(pComponent);
        return true;
    }

    // callback indicating that the backup process has either completed or has shut down
    virtual bool STDMETHODCALLTYPE OnBackupShutdown
        (
        __in VSS_ID SnapshotSetId
        )
    {
        UNREFERENCED_PARAMETER(SnapshotSetId);
        return true;
    }

    // callback on pre-restore event
    virtual bool STDMETHODCALLTYPE OnPreRestore
        (
        __in IVssWriterComponents *pComponent
        )
    {
        UNREFERENCED_PARAMETER(pComponent);
        return true;
    }

    // callback on post-restore event
    virtual bool STDMETHODCALLTYPE OnPostRestore
        (
        __in IVssWriterComponents *pComponent
        )
    {
        UNREFERENCED_PARAMETER(pComponent);
        return true;
    }

    // callback on post snapshot event
    virtual bool STDMETHODCALLTYPE OnPostSnapshot
        (
        __in IVssWriterComponents *pComponent
        )
    {
        UNREFERENCED_PARAMETER(pComponent);
        return true;
    }

    // callback on back off I/O volume event
    virtual bool STDMETHODCALLTYPE OnBackOffIOOnVolume
        (
        __in VSS_PWSZ wszVolumeName,
        __in VSS_ID snapshotId,
        __in VSS_ID providerId
        )
    {
        UNREFERENCED_PARAMETER(wszVolumeName);
        UNREFERENCED_PARAMETER(snapshotId);
        UNREFERENCED_PARAMETER(providerId);

        return true;
    }

    // callback on Continue I/O on volume event
    virtual bool STDMETHODCALLTYPE OnContinueIOOnVolume
        (
        __in VSS_PWSZ wszVolumeName,
        __in VSS_ID snapshotId,
        __in VSS_ID providerId
        )
    {
        UNREFERENCED_PARAMETER(wszVolumeName);
        UNREFERENCED_PARAMETER(snapshotId);
        UNREFERENCED_PARAMETER(providerId);

        return true;
    }


    // callback to specify that the volume snaphost service is shutting down.  Used
    // by alternative writers to signal when to shutdown.
    virtual bool STDMETHODCALLTYPE OnVSSShutdown()
    {
        return true;
    }


    // callback to an alternative writer when the application writer subscribes.  Used to
    // signal the alternative writer to shutdown.
    virtual bool STDMETHODCALLTYPE OnVSSApplicationStartup()
    {
        return true;
    }


protected:

    IVssWriterImpl *m_pWriterImpl;
};


class CVssWriterEx;
extern "C"  {
    HRESULT STDMETHODCALLTYPE CreateWriterEx(
        __in    CVssWriterEx    *pWriter,
        __out   IVssWriterImpl  **pWriterImpl
        );
}


class CVssWriterEx : public CVssWriter
{
public:
  HRESULT STDMETHODCALLTYPE Initialize
        (
        __in VSS_ID WriterId,
        __in LPCWSTR wszWriterName,
        __in VSS_USAGE_TYPE ut,
        __in VSS_SOURCE_TYPE st,
        __in VSS_APPLICATION_LEVEL nLevel = VSS_APP_FRONT_END,
        __in DWORD dwTimeoutFreeze = 60000,         // Maximum milliseconds between Freeze/Thaw
        __in VSS_ALTERNATE_WRITER_STATE aws = VSS_AWS_NO_ALTERNATE_WRITER,
        __in bool bIOThrottlingOnly = false,
        __in LPCWSTR wszWriterInstanceName = NULL
        )
    {
        if (m_pWriterImpl != NULL)
            return E_FAIL;

        HRESULT hr = CreateWriterEx(this, &m_pWriterImpl);
        if (FAILED(hr))
            return hr;

        hr = m_pWriterImpl->Initialize(WriterId, wszWriterName, wszWriterInstanceName, 0, 0, ut, st, nLevel, dwTimeoutFreeze, aws, bIOThrottlingOnly);
        if (FAILED(hr))
        {
            m_pWriterImpl->Release();
            m_pWriterImpl = NULL;
        }

        return hr;
    }

    HRESULT STDMETHODCALLTYPE InitializeEx
        (
        __in VSS_ID WriterId,
        __in LPCWSTR wszWriterName,
        __in DWORD dwMajorVersion,
        __in DWORD dwMinorVersion,
        __in VSS_USAGE_TYPE ut,
        __in VSS_SOURCE_TYPE st,
        __in VSS_APPLICATION_LEVEL nLevel = VSS_APP_FRONT_END,
        __in DWORD dwTimeoutFreeze = 60000,         // Maximum milliseconds between Freeze/Thaw
        __in VSS_ALTERNATE_WRITER_STATE aws = VSS_AWS_NO_ALTERNATE_WRITER,
        __in bool bIOThrottlingOnly = false,
        __in LPCWSTR wszWriterInstanceName = NULL
        )
    {
        if (m_pWriterImpl != NULL)
            return E_FAIL;

        HRESULT hr = CreateWriterEx(this, &m_pWriterImpl);
        if (FAILED(hr))
            return hr;

        hr = m_pWriterImpl->Initialize(WriterId, wszWriterName, wszWriterInstanceName, dwMajorVersion, dwMinorVersion, ut, st, nLevel, dwTimeoutFreeze, aws, bIOThrottlingOnly);
        if (FAILED(hr))
        {
            m_pWriterImpl->Release();
            m_pWriterImpl = NULL;
        }

        return hr;
    }

    virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
    {
        UNREFERENCED_PARAMETER(pMetadata);
        return false;
    }

    virtual bool STDMETHODCALLTYPE OnIdentifyEx(__in IVssCreateWriterMetadataEx *pMetadata)
    {
        UNREFERENCED_PARAMETER(pMetadata);
        return false;
    }

protected:
    HRESULT GetIdentifyInformation
    (
        __out IVssExamineWriterMetadata** ppMetadata
    )
    {
    UNREFERENCED_PARAMETER(ppMetadata);

    if (m_pWriterImpl == NULL)
        return E_FAIL;

    *ppMetadata = m_pWriterImpl->GetIdentityInformation();

    return S_OK;
    }

    // cause the writer to subscribe to events.
    HRESULT STDMETHODCALLTYPE SubscribeEx
        (
        __in DWORD dwUnsubscribeTimeout,
        __in DWORD dwEventFlags = VSS_SM_BACKUP_EVENTS_FLAG | VSS_SM_RESTORE_EVENTS_FLAG
        )
    {
        if (m_pWriterImpl == NULL)
            return E_FAIL;

        return m_pWriterImpl->Subscribe(dwUnsubscribeTimeout, dwEventFlags);
    }
};


class CVssWriterEx2 : public CVssWriterEx
{
public:

    HRESULT STDMETHODCALLTYPE SetWriterFailureEx(
        __in HRESULT hrWriter,
        __in HRESULT hrApplication = S_FALSE,
        __in LPCWSTR wszApplicationMessage = NULL
        )
    {
        if (m_pWriterImpl == NULL)
            return E_FAIL;

        return m_pWriterImpl->SetWriterFailureEx(hrWriter, hrApplication, wszApplicationMessage);
    }

    HRESULT STDMETHODCALLTYPE GetSessionId(
        __out VSS_ID *idSession
        )
    {
        if (m_pWriterImpl == NULL)
            return E_FAIL;

        return m_pWriterImpl->GetSessionId(idSession);
    }

    bool STDMETHODCALLTYPE IsWriterShuttingDown()
    {
        return m_pWriterImpl->IsWriterShuttingDown();
    }
};


extern "C"  {
    HRESULT STDAPICALLTYPE CreateVssExpressWriterInternal
        (
        __out IVssExpressWriter **ppWriter
        );
}


inline HRESULT  CreateVssExpressWriter
    (
    __out IVssExpressWriter **ppWriter
    )
{
    return CreateVssExpressWriterInternal(ppWriter);
}


#endif //__CVSS_WRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\warning.h ===
#ifndef _WARNING_H_
#define _WARNING_H_


#pragma warning(3:4092)   // sizeof returns 'unsigned long'
#pragma warning(4:4096)   // '__cdecl' must be used with '...'
#pragma warning(4:4121)   // structure is sensitive to alignment
#pragma warning(3:4125)   // decimal digit in octal sequence
#pragma warning(3:4130)   // logical operation on address of string constant
#pragma warning(3:4132)   // const object should be initialized
#if _DBG_MEMCPY_INLINE_
#pragma warning(disable:4163) // not available as an intrinsic function
#endif
#pragma warning(4:4206)   // Source File is empty
#pragma warning(4:4101)   // Unreferenced local variable
#pragma warning(4:4208)   // delete[exp] - exp evaluated but ignored
#pragma warning(3:4212)   // function declaration used ellipsis
#pragma warning(3:4242)   // convertion possible loss of data
#if defined(_M_IA64)
#pragma warning(disable:4714) // function marked as __forceinline not inlined
                              // (VC7.1:  inlining is not allowed in finally)
#endif
#pragma warning(4:4267)   // convertion from size_t to smaller type
#pragma warning(4:4312)   // conversion to type of greater size
#pragma warning(disable:4324)  // structure padded due to __declspec(align())
#pragma warning(error:4700)    // Local used w/o being initialized
#pragma warning(error:4259)    // pure virtual function was not defined
#pragma warning(disable:4071)  // no function prototype given - formals unspecified
#pragma warning(error:4013)    // function' undefined - assuming extern returning int
#pragma warning(error:4551)    // Function call missing argument list
#pragma warning(error:4806)    // unsafe operation involving type 'bool'
#pragma warning(disable:4826)  // pointer sign extension
#pragma warning(4:4509)   // use of SEH with destructor
#pragma warning(4:4177)   // pragma data_seg s/b at global scope
#pragma warning(disable:4274)  // #ident ignored
#pragma warning(disable:4786)  // identifier was truncated to 255 chararcers in debug information.
#pragma warning(disable:4503)  // decorated name length exceeded, name was truncated.
#pragma warning(disable:4263)  // Derived override doesn't match base - who cares...
#pragma warning(disable:4264)  // base function is hidden - again who cares.
#pragma warning(disable:4710)  // Function marked as inline - wasn't
#pragma warning(disable:4917)  // A GUID can only be associated with a class, interface or namespace
#pragma warning(error:4552)    // <<, >> ops used to no effect (probably missing an = sign)
#pragma warning(error:4553)    // == op used w/o effect (probably s/b an = sign)
#pragma warning(3:4288)   // nonstandard extension used (loop counter)
#pragma warning(3:4532)   // jump out of __finally block
#pragma warning(error:4312)  // cast of 32-bit int to 64-bit ptr
#pragma warning(error:4296)  // expression is always true/false
#pragma warning(3:4546)   // function call before comma missing argument list
// disable until __noop(arg,arg,arg) doesn't generate false hits.
// #pragma warning(3:4547)   // '<' : operator before comma has no effect; expected operator with side-effect
// #pragma warning(3:4548)   // expression before comma has no effect; expected expression with side-effect

#if _MSC_VER > 1300
#pragma warning(disable:4675)	// picked overload found via Koenig lookup
#pragma warning(disable:4356)	// static member cannot be initialized via derived class
#endif

// Ignoring these warnings can cause blatantly incorrect code generation.
// Since not all projects are -W4 -WX, treat as errors explicitly
#pragma warning(error:4028)   // C4028: formal parameter different from declaration
#pragma warning(error:4029)   // C4029: declared formal parameter list different from definition

#if 0
#pragma warning(3:4100)   // Unreferenced formal parameter
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4706)   // assignment w/i conditional expression
#pragma warning(3:4709)   // command operator w/o index expression
#endif

#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif

#if _MSC_VER <= 1400
#pragma warning(disable: 4068)	// turn off unknown pragma warning so prefast pragmas won't show
				// show up in build.wrn/build.err
#endif

// Macros for suppressing PREfast warnings
#include <suppress.h>


#if _MSC_FULL_VER >= 140040702
#pragma warning(disable:4430)	// default-int warning (C++)
#pragma warning(disable:4431)	// default-int warning (C)
#pragma warning(disable:4812)	// obsolete template destructor syntax
#endif


#if defined(_M_IA64) && _MSC_VER > 1310
#define __TYPENAME typename
#elif defined(_M_IX86) && _MSC_FULL_VER >= 13102154
#define __TYPENAME typename
#elif defined(_M_AMD64) && _MSC_VER >= 1400
#define __TYPENAME typename
#else
#define __TYPENAME
#endif

#endif // _WARNING_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WabApi.h ===
#ifndef _WABAPI_H_
#define _WABAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WABACTIONITEM * LPWABACTIONITEM;

/* IWABObject Interface ---------------------------------------------------- */

#define CBIWABOBJECT sizeof(IWABOBJECT)

#define WAB_IWABOBJECT_METHODS(IPURE)                       \
        MAPIMETHOD(GetLastError)                            \
            (THIS_  HRESULT hResult,                        \
                    ULONG ulFlags,                          \
                    LPMAPIERROR* lppMAPIError) IPURE;       \
        MAPIMETHOD(AllocateBuffer)                          \
            (THIS_  ULONG cbSize,                           \
                    __deref_out LPVOID* lppBuffer) IPURE;   \
        MAPIMETHOD(AllocateMore)                            \
            (THIS_  ULONG cbSize,                           \
                    __in LPVOID lpObject,                   \
                    __deref_out LPVOID* lppBuffer) IPURE;   \
        MAPIMETHOD(FreeBuffer)                              \
            (THIS_  __in LPVOID lpBuffer) IPURE;            \
        MAPIMETHOD(Backup)                                  \
            (THIS_  __in LPSTR lpFileName) IPURE;           \
        MAPIMETHOD(Import)                                  \
            (THIS_  __in LPSTR lpWIP) IPURE;     \
        MAPIMETHOD(Find)                                    \
            (THIS_  __in LPADRBOOK lpIAB,                   \
                    __in_opt HWND hWnd) IPURE;              \
        MAPIMETHOD(VCardDisplay)                            \
            (THIS_  __in LPADRBOOK lpIAB,                   \
                    __in_opt HWND hWnd,                     \
                    __in LPSTR lpszFileName) IPURE;         \
        MAPIMETHOD(LDAPUrl)                                 \
            (THIS_  __in LPADRBOOK lpIAB,                   \
                    __in_opt HWND hWnd,                     \
                    ULONG ulFlags,                          \
                    __in LPSTR lpszURL,                     \
                    __deref_out_opt LPMAILUSER *lppMailUser) IPURE; \
        MAPIMETHOD(VCardCreate)                             \
            (THIS_  __in LPADRBOOK lpIAB,                   \
                    ULONG ulFlags,                          \
                    __in LPSTR lpszVCard,                   \
                    __in LPMAILUSER lpMailUser) IPURE;      \
        MAPIMETHOD(VCardRetrieve)                           \
            (THIS_  __in LPADRBOOK lpIAB,                   \
                    ULONG ulFlags,                          \
                    __in LPSTR lpszVCard,                   \
                    __deref_out LPMAILUSER *lppMailUser) IPURE; \
        MAPIMETHOD(GetMe)                                   \
            (THIS_  __in LPADRBOOK lpIAB,                   \
                    ULONG ulFlags,                          \
                    __out DWORD* lpdwAction,                \
                    __out SBinary* lpsbEID,                 \
                    __in_opt HWND hwnd) IPURE;              \
        MAPIMETHOD(SetMe)                                   \
            (THIS_  __in LPADRBOOK lpIAB,                   \
                    ULONG ulFlags,                          \
                    SBinary sbEID,                          \
                    __in_opt HWND hwnd) IPURE;              \



#undef           INTERFACE
#define          INTERFACE      IWABObject
DECLARE_MAPI_INTERFACE_(IWABObject, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        WAB_IWABOBJECT_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IWABObject, LPWABOBJECT);


#undef  INTERFACE
#define INTERFACE       struct _IWABOBJECT

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWABOBJECT_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWABOBJECT_)
                MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWABOBJECT_)
                MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWABOBJECT_)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(IMPL)
   WAB_IWABOBJECT_METHODS(IMPL)
};


/*** WABObject_LDAPUrl flags ***/

// If this flag is specified and the LDAPUrl returns a single
// query result, instructs the WAB to return the result in the
// form of a MailUser object instead of displaying Details on it
// If there are multiple results to the query, fail ..
#define WABOBJECT_LDAPURL_RETURN_MAILUSER   0x00000001

// WAB 5.0x and higher:
// If your application supports Unicode and wants to pass ina Unicode
//  URL to the WAB, you can cast the Unicode URL to an LPSTR and pass it
// to the LDAPUrl API, *also* setting ulFlags to MAPI_UNICODE to mark the URL
// as such. Casting is prefered to converting the string because 
// (a) Converting the string may result in loss of data (b) since this is an
// already published interface we can't modify the interface.
//      MAPI_UNICODE                        0x80000000



/*** WABObject_GetMe returned parameter ***/
// If the GetMe call results in the creation of a new 'Me' contact,
// the lpdwAction returned parameter will contain this value
// indicating to the caller that the object is freshly created and
// does not have any properties in it
#define WABOBJECT_ME_NEW                    0x00000001



/*** WABObject_GetMe flags ***/
// WABObject_GetMe will create a new ME object by default, if 
// none already exists. To force the call to not-create an object, if
// one doesn't already exist, specify the WABOBJECT_ME_NOCREATE flag.
// If no me is found, the call fails with MAPI_E_NOT_FOUND.
// Other flag for WABObject_GetMe is AB_NO_DIALOG defined in wabdefs.h
#define WABOBJECT_ME_NOCREATE               0x00000002



/*** IWABObject_VCard Create/Retrieve ***/
// Flags the WAB whether the lpszVCard parameter is a filename or if
// it is a NULL terminated string containing the compelte VCard contents
//
#define WAB_VCARD_FILE                      0x00000000
#define WAB_VCARD_STREAM                    0x00000001

//
// Input information to pass to WABOpen
//
typedef struct _tagWAB_PARAM
{
    ULONG   cbSize;         // sizeof(WAB_PARAM).
    HWND    hwnd;           // hWnd of calling client Application. Can be NULL
    LPSTR   szFileName;     // WAB File name to open. if NULL, opens default.
    ULONG   ulFlags;        // See below
    GUID    guidPSExt;      // A GUID that identifies the calling application's Property Sheet extensions
                            // The GUID can be used to determine whether the extension prop sheets are displayed or not.
} WAB_PARAM, * LPWAB_PARAM;

//flags for WAB_PARAM
#define WAB_USE_OE_SENDMAIL     0x00000001  // Tells WAB to use Outlook Express for e-mail before checking for a 
                                            // default Simple MAPI client. Default behaviour is to check for the 
                                            // Simple MAPI client first

#define WAB_ENABLE_PROFILES     0x00400000  // Invokes WAB in a Identity-aware session using Identity-Manager 
                                            // based profiles
                                            // DEPRECATED IN VISTA.


//
// Root public entry points for WAB API
//
STDMETHODIMP WABOpen(
    __deref_out LPADRBOOK* lppAdrBook,
    __deref_out LPWABOBJECT* lppWABObject,
    __in_opt LPWAB_PARAM lpWP,
    DWORD Reserved2);

typedef HRESULT (STDMETHODCALLTYPE WABOPEN)(
    LPADRBOOK FAR * lppAdrBook,
    LPWABOBJECT FAR * lppWABObject,
    LPWAB_PARAM lpWP,
    DWORD Reserved2
);
typedef WABOPEN FAR * LPWABOPEN;

// Deprecated in Vista.  Calls WABOpen.  Additional parameters are ignored.
STDMETHODIMP WABOpenEx(
    __deref_out LPADRBOOK* lppAdrBook,
    __deref_out LPWABOBJECT* lppWABObject,
    __in_opt LPWAB_PARAM lpWP,
    DWORD Reserved,
    ALLOCATEBUFFER * fnAllocateBuffer,
    ALLOCATEMORE * fnAllocateMore,
    FREEBUFFER * fnFreeBuffer);

typedef HRESULT (STDMETHODCALLTYPE WABOPENEX)(
    LPADRBOOK FAR * lppAdrBook,
    LPWABOBJECT FAR * lppWABObject,
    LPWAB_PARAM lpWP,
    DWORD Reserved,
    ALLOCATEBUFFER * fnAllocateBuffer,
    ALLOCATEMORE * fnAllocateMore,
    FREEBUFFER * fnFreeBuffer
);
typedef WABOPENEX FAR * LPWABOPENEX;

/* --------------------- */
typedef struct _WABIMPORTPARAM
{
    ULONG cbSize;       // sizeof(WABIMPORTPARAM)
    LPADRBOOK lpAdrBook;// ptr to the IAdrBook object (required)
    HWND hWnd;          // Parent HWND for any dialogs
    ULONG ulFlags;      // MAPI_DIALOG to show progress dialog and messages,
                        // MAPI_IMPORT_VCF to import a VCF instead of a WAB file 
                        // MAPI_UNICODE to use lpszFileName as WCHAR*
    LPSTR lpszFileName; // FileName to import or NULL .. if NULL will show FileOpen dialog 
} WABIMPORTPARAM, FAR * LPWABIMPORTPARAM;



/* ---- WABEXTDISPLAY ----------------- */
/* WABEXTDISPLAY Structure used in extending the WAB Details Property Dialogs 
    and for doing WAB Context Menu verb extensions.
   The structure is passed into the IWABExtInit::Initialize method
    of the implementor */

// Flags
#define WAB_DISPLAY_LDAPURL 0x00000001  // The object being displayed is an LDAP URL
                                        // The URL can be found in the lpsz struct member

#define WAB_CONTEXT_ADRLIST 0x00000002  // THe lpv parameter contains a pointer to an
                                        // AdrList structure corresponding to selected items
                                        // on which to display a context menu

#define WAB_DISPLAY_ISNTDS  0x00000004  // Identifies that the entry being displayed originated
                                        // on the NT Directory Service, for clients that use ADSI and
                                        // retrieve additional information from the service.

//      MAPI_UNICODE        0x80000000  // Indicates that the WED.lpsz string is actually a UNICODE
                                        //  string and should be cast to a (LPWSTR) before using it
                                        // If this flag is not present then the WED.lpsz is a DBCS string
                                        //  and should be cast to an LPSTR before using.

// Struct
typedef struct _WABEXTDISPLAY
{
    ULONG cbSize;
    LPWABOBJECT lpWABObject;    // pointer to IWABObject
    LPADRBOOK lpAdrBook;        // pointer to IAdrBook object
    LPMAPIPROP lpPropObj;       // Object being displayed
    BOOL fReadOnly;             // Indicates if this is a ReadOnly mode
    BOOL fDataChanged;          // Set by extension sheet to signal data change
    ULONG ulFlags;              // See above
    LPVOID lpv;                 // Used for passing in specific data
    LPTSTR lpsz;               // Used for passing in specific data
} WABEXTDISPLAY, FAR * LPWABEXTDISPLAY;

/* --------------------- */

#define WAB_IWABEXTINIT_METHODS(IPURE)                          \
        MAPIMETHOD(Initialize)                                  \
            (THIS_  LPWABEXTDISPLAY lpWABExtDisplay)    IPURE;  \

#undef           INTERFACE
#define          INTERFACE      IWABExtInit
DECLARE_MAPI_INTERFACE_(IWABExtInit, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        WAB_IWABEXTINIT_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IWABExtInit, LPWABEXTINIT);

DEFINE_GUID(IID_IWABExtInit, 
0xea22ebf0, 0x87a4, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);


/* --------------------- */

#define WAB_DLL_NAME TEXT("WAB32.DLL")
#define WAB_DLL_PATH_KEY TEXT("Software\\Microsoft\\WAB\\DLLPath")

#ifdef __cplusplus
}
#endif

#endif /* _WABAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\WabDefs.h ===
/*
 *  WABDEFS.H
 *
 *  Definitions used by WAB clients
 *
 *  Copyright 1993-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(MAPIDEFS_H) && !defined(WABDEFS_H)
#define WABDEFS_H

#ifndef _WINDOWS_
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Windows NT; Windows 95 needs it */
#define _INC_OLE /* Windows 95 will include OLE1 without this */
#include <windef.h>
#include <winnt.h>
#endif

#ifndef _OLEERROR_H_
#include <objerror.h>
#endif
#ifndef _OBJBASE_H_
#include <objbase.h>
#endif

#ifndef _INC_STDDEF
#include <stddef.h>
#endif

#include "limits.h"
/* Array dimension for structures with variable-sized arrays at the end. */

#ifndef MAPI_DIM
#define MAPI_DIM    1
#endif

/* Provider init type. Force to cdecl always */

#ifndef STDMAPIINITCALLTYPE
#if !defined (_MAC) && defined (WIN32)
#define STDMAPIINITCALLTYPE     __cdecl
#else
#define STDMAPIINITCALLTYPE     STDMETHODCALLTYPE
#endif
#define STDINITMETHODIMP        HRESULT STDMAPIINITCALLTYPE
#define STDINITMETHODIMP_(type) type STDMAPIINITCALLTYPE
#endif

#ifdef  __cplusplus
extern "C" {
#endif

/* Simple data types */


typedef PBYTE  LPBYTE;
typedef PULONG LPULONG;

#ifndef __LHANDLE
#define __LHANDLE
typedef ULONG_PTR LHANDLE, *LPLHANDLE;
#endif

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME;
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 *  This flag is used in many different MAPI calls to signify that
 *  the object opened by the call should be modifiable (MAPI_MODIFY).
 *  If the flag MAPI_MAX_ACCESS is set, the object returned should be
 *  returned at the maximum access level allowed.  An additional
 *  property available on the object (PR_ACCESS_LEVEL) uses the same
 *  MAPI_MODIFY flag to say just what this new access level is.
 */

#define MAPI_MODIFY             ((ULONG) 0x00000001)

/*
 *  The following flags are used to indicate to the client what access
 *  level is permissible in the object. They appear in PR_ACCESS in
 *  message and folder objects as well as in contents and associated
 *  contents tables
 */

#define MAPI_ACCESS_MODIFY                  ((ULONG) 0x00000001)
#define MAPI_ACCESS_READ                    ((ULONG) 0x00000002)
#define MAPI_ACCESS_DELETE                  ((ULONG) 0x00000004)
#define MAPI_ACCESS_CREATE_HIERARCHY        ((ULONG) 0x00000008)
#define MAPI_ACCESS_CREATE_CONTENTS         ((ULONG) 0x00000010)
#define MAPI_ACCESS_CREATE_ASSOCIATED       ((ULONG) 0x00000020)

/*
 *  The MAPI_UNICODE flag is used in many different MAPI calls to signify
 *  that strings passed through the interface are in Unicode (a 16-bit
 *  character set). The default is an 8-bit character set.
 *
 *  The value fMapiUnicode can be used as the 'normal' value for
 *  that bit, given the application's default character set.
 */

#define MAPI_UNICODE            ((ULONG) 0x80000000)

#ifdef UNICODE
#define fMapiUnicode            MAPI_UNICODE
#else
#define fMapiUnicode            0
#endif

/* successful HRESULT */
#define hrSuccess               0



/* Recipient types */
#ifndef MAPI_ORIG               /* also defined in mapi.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_P1     0x10000000  /* Recipient is a P1 resend recipient       */
#define MAPI_SUBMITTED 0x80000000 /* Recipient is already processed         */
/* #define MAPI_AUTHORIZE 4        recipient is a CMC authorizing user      */
/*#define MAPI_DISCRETE 0x10000000 Recipient is a P1 resend recipient       */
#endif

/* Bit definitions for abFlags[0] of ENTRYID */
#define MAPI_SHORTTERM          0x80
#define MAPI_NOTRECIP           0x40
#define MAPI_THISSESSION        0x20
#define MAPI_NOW                0x10
#define MAPI_NOTRESERVED        0x08

/* Bit definitions for abFlags[1] of ENTRYID */
#define MAPI_COMPOUND           0x80

/* ENTRYID */
typedef struct
{
    BYTE    abFlags[4];
    BYTE    ab[MAPI_DIM];
} ENTRYID, FAR *LPENTRYID;

#define CbNewENTRYID(_cb)       (offsetof(ENTRYID,ab) + (_cb))
#define CbENTRYID(_cb)          (offsetof(ENTRYID,ab) + (_cb))
#define SizedENTRYID(_cb, _name) \
    struct _ENTRYID_ ## _name \
{ \
    BYTE    abFlags[4]; \
    BYTE    ab[_cb]; \
} _name

/* Byte-order-independent version of GUID (world-unique identifier) */
typedef struct _MAPIUID
{
    BYTE ab[16];
} MAPIUID, FAR * LPMAPIUID;

/* Note:  need to include C run-times (memory.h) to use this macro */

#define IsEqualMAPIUID(lpuid1, lpuid2)  (!memcmp(lpuid1, lpuid2, sizeof(MAPIUID)))


/* Object type */

#define MAPI_STORE      ((ULONG) 0x00000001)    /* Message Store */
#define MAPI_ADDRBOOK   ((ULONG) 0x00000002)    /* Address Book */
#define MAPI_FOLDER     ((ULONG) 0x00000003)    /* Folder */
#define MAPI_ABCONT     ((ULONG) 0x00000004)    /* Address Book Container */
#define MAPI_MESSAGE    ((ULONG) 0x00000005)    /* Message */
#define MAPI_MAILUSER   ((ULONG) 0x00000006)    /* Individual Recipient */
#define MAPI_ATTACH     ((ULONG) 0x00000007)    /* Attachment */
#define MAPI_DISTLIST   ((ULONG) 0x00000008)    /* Distribution List Recipient */
#define MAPI_PROFSECT   ((ULONG) 0x00000009)    /* Profile Section */
#define MAPI_STATUS     ((ULONG) 0x0000000A)    /* Status Object */
#define MAPI_SESSION    ((ULONG) 0x0000000B)    /* Session */
#define MAPI_FORMINFO   ((ULONG) 0x0000000C)    /* Form Information */


/*
 *  Maximum length of profile names and passwords, not including
 *  the null termination character.
 */
#ifndef cchProfileNameMax
#define cchProfileNameMax   64
#define cchProfilePassMax   64
#endif


/* Property Types */

#define MV_FLAG         0x1000          /* Multi-value flag */

#define PT_UNSPECIFIED  ((ULONG)  0)    /* (Reserved for interface use) type doesn't matter to caller */
#define PT_NULL         ((ULONG)  1)    /* NULL property value */
#define PT_I2           ((ULONG)  2)    /* Signed 16-bit value */
#define PT_LONG         ((ULONG)  3)    /* Signed 32-bit value */
#define PT_R4           ((ULONG)  4)    /* 4-byte floating point */
#define PT_DOUBLE       ((ULONG)  5)    /* Floating point double */
#define PT_CURRENCY     ((ULONG)  6)    /* Signed 64-bit int (decimal w/    4 digits right of decimal pt) */
#define PT_APPTIME      ((ULONG)  7)    /* Application time */
#define PT_ERROR        ((ULONG) 10)    /* 32-bit error value */
#define PT_BOOLEAN      ((ULONG) 11)    /* 16-bit boolean (non-zero true) */
#define PT_OBJECT       ((ULONG) 13)    /* Embedded object in a property */
#define PT_I8           ((ULONG) 20)    /* 8-byte signed integer */
#define PT_STRING8      ((ULONG) 30)    /* Null terminated 8-bit character string */
#define PT_UNICODE      ((ULONG) 31)    /* Null terminated Unicode string */
#define PT_SYSTIME      ((ULONG) 64)    /* FILETIME 64-bit int w/ number of 100ns periods since Jan 1,1601 */
#define PT_CLSID        ((ULONG) 72)    /* OLE GUID */
#define PT_BINARY       ((ULONG) 258)   /* Uninterpreted (counted byte array) */
/* Changes are likely to these numbers, and to their structures. */

/* Alternate property type names for ease of use */
#define PT_SHORT    PT_I2
#define PT_I4       PT_LONG
#define PT_FLOAT    PT_R4
#define PT_R8       PT_DOUBLE
#define PT_LONGLONG PT_I8

/*
 *  The type of a MAPI-defined string property is indirected, so
 *  that it defaults to Unicode string on a Unicode platform and to
 *  String8 on an ANSI or DBCS platform.
 *
 *  Macros are defined here both for the property type, and for the
 *  field of the property value structure which should be
 *  dereferenced to obtain the string pointer.
 */

#ifdef  UNICODE
#define PT_TSTRING          PT_UNICODE
#define PT_MV_TSTRING       (MV_FLAG|PT_UNICODE)
#define LPSZ                lpszW
#define LPPSZ               lppszW
#define MVSZ                MVszW
#else
#define PT_TSTRING          PT_STRING8
#define PT_MV_TSTRING       (MV_FLAG|PT_STRING8)
#define LPSZ                lpszA
#define LPPSZ               lppszA
#define MVSZ                MVszA
#endif


/* Property Tags
 *
 * By convention, MAPI never uses 0 or FFFF as a property ID.
 * Use as null values, initializers, sentinels, or what have you.
 */

#define PROP_TYPE_MASK          ((ULONG)0x0000FFFF) /* Mask for Property type */
#define PROP_TYPE(ulPropTag)    (((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag)      (((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID)   ((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL            0
#define PROP_ID_INVALID         0xFFFF
#define PR_NULL                 PROP_TAG( PT_NULL, PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType) \
                        (((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)


/* Multi-valued Property Types */

#define PT_MV_I2        (MV_FLAG|PT_I2)
#define PT_MV_LONG      (MV_FLAG|PT_LONG)
#define PT_MV_R4        (MV_FLAG|PT_R4)
#define PT_MV_DOUBLE    (MV_FLAG|PT_DOUBLE)
#define PT_MV_CURRENCY  (MV_FLAG|PT_CURRENCY)
#define PT_MV_APPTIME   (MV_FLAG|PT_APPTIME)
#define PT_MV_SYSTIME   (MV_FLAG|PT_SYSTIME)
#define PT_MV_STRING8   (MV_FLAG|PT_STRING8)
#define PT_MV_BINARY    (MV_FLAG|PT_BINARY)
#define PT_MV_UNICODE   (MV_FLAG|PT_UNICODE)
#define PT_MV_CLSID     (MV_FLAG|PT_CLSID)
#define PT_MV_I8        (MV_FLAG|PT_I8)

/* Alternate property type names for ease of use */
#define PT_MV_SHORT     PT_MV_I2
#define PT_MV_I4        PT_MV_LONG
#define PT_MV_FLOAT     PT_MV_R4
#define PT_MV_R8        PT_MV_DOUBLE
#define PT_MV_LONGLONG  PT_MV_I8

/*
 *  Property type reserved bits
 *
 *  MV_INSTANCE is used as a flag in table operations to request
 *  that a multi-valued property be presented as a single-valued
 *  property appearing in multiple rows.
 */

#define MV_INSTANCE     0x2000
#define MVI_FLAG        (MV_FLAG | MV_INSTANCE)
#define MVI_PROP(tag)   ((tag) | MVI_FLAG)

/* --------------- */
/* Data Structures */
/* --------------- */

/* Property Tag Array */

typedef struct _SPropTagArray
{
    ULONG   cValues;
    ULONG   aulPropTag[MAPI_DIM];
} SPropTagArray, *LPSPropTagArray;

#define CbNewSPropTagArray(_ctag) \
    (offsetof(SPropTagArray,aulPropTag) + (_ctag)*sizeof(ULONG))
#define CbSPropTagArray(_lparray) \
    (offsetof(SPropTagArray,aulPropTag) + \
    (UINT)((_lparray)->cValues)*sizeof(ULONG))
/*  SPropTagArray */
#define SizedSPropTagArray(_ctag, _name) \
struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name

/* -------------- */
/* Property Value */
/* -------------- */

typedef struct _SPropValue  SPropValue;


/* 32-bit CURRENCY definition stolen from oaidl.h */
/* 16-bit CURRENCY definition stolen from variant.h */

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if (defined (WIN16) || defined (DOS)) && !defined (_VARIANT_H_)
typedef struct FARSTRUCT tagCY {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
} CY;
#elif defined (WIN32)
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
    };
    LONGLONG int64;
} CY;
#endif /* 16-bit vs 32-bit definition */
#endif
            /* size is 8 */
typedef CY CURRENCY;

typedef struct _SBinary
{
    ULONG   cb;
    __field_bcount(cb) LPBYTE  lpb;
} SBinary;

typedef SBinary* LPSBinary;

typedef struct _SShortArray
{
    ULONG cValues;
    short *lpi;
} SShortArray;

typedef struct _SGuidArray
{
    ULONG cValues;
    GUID  *lpguid;
} SGuidArray;

typedef struct _SRealArray
{
    ULONG cValues;
    float *lpflt;
} SRealArray;

typedef struct _SLongArray
{
    ULONG cValues;
    LONG  *lpl;
} SLongArray;

typedef struct _SLargeIntegerArray
{
    ULONG         cValues;
    LARGE_INTEGER *lpli;
} SLargeIntegerArray;

typedef struct _SDateTimeArray
{
    ULONG       cValues;
    FILETIME    *lpft;
} SDateTimeArray;

typedef struct _SAppTimeArray
{
    ULONG  cValues;
    double *lpat;
} SAppTimeArray;

typedef struct _SCurrencyArray
{
    ULONG    cValues;
    CURRENCY *lpcur;
} SCurrencyArray;

typedef struct _SBinaryArray
{
    ULONG   cValues;
    SBinary *lpbin;
} SBinaryArray;

typedef struct _SDoubleArray
{
    ULONG  cValues;
    double *lpdbl;
} SDoubleArray;

typedef struct _SWStringArray
{
    ULONG  cValues;
    LPWSTR *lppszW;
} SWStringArray;

typedef struct _SLPSTRArray
{
    ULONG cValues;
    LPSTR *lppszA;
} SLPSTRArray;

typedef union _PV
{
    short int           i;          /* case PT_I2 */
    LONG                l;          /* case PT_LONG */
    ULONG               ul;         /* alias for PT_LONG */
    float               flt;        /* case PT_R4 */
    double              dbl;        /* case PT_DOUBLE */
    unsigned short int  b;          /* case PT_BOOLEAN */
    CURRENCY            cur;        /* case PT_CURRENCY */
    double              at;         /* case PT_APPTIME */
    FILETIME            ft;         /* case PT_SYSTIME */
    LPSTR               lpszA;      /* case PT_STRING8 */
    SBinary             bin;        /* case PT_BINARY */
    LPWSTR              lpszW;      /* case PT_UNICODE */
    GUID               *lpguid;     /* case PT_CLSID */
    LARGE_INTEGER       li;         /* case PT_I8 */
    SShortArray         MVi;        /* case PT_MV_I2 */
    SLongArray          MVl;        /* case PT_MV_LONG */
    SRealArray          MVflt;      /* case PT_MV_R4 */
    SDoubleArray        MVdbl;      /* case PT_MV_DOUBLE */
    SCurrencyArray      MVcur;      /* case PT_MV_CURRENCY */
    SAppTimeArray       MVat;       /* case PT_MV_APPTIME */
    SDateTimeArray      MVft;       /* case PT_MV_SYSTIME */
    SBinaryArray        MVbin;      /* case PT_MV_BINARY */
    SLPSTRArray         MVszA;      /* case PT_MV_STRING8 */
    SWStringArray       MVszW;      /* case PT_MV_UNICODE */
    SGuidArray          MVguid;     /* case PT_MV_CLSID */
    SLargeIntegerArray  MVli;       /* case PT_MV_I8 */
    SCODE               err;        /* case PT_ERROR */
    LONG                x;          /* case PT_NULL, PT_OBJECT (no usable value) */
} __UPV;

typedef struct _SPropValue
{
    ULONG       ulPropTag;
    ULONG       dwAlignPad;
    union _PV   Value;
} SPropValue, *LPSPropValue;


/* --------------------------------------------- */
/* Property Problem and Property Problem Arrays */
/* --------------------------------------------- */

typedef struct _SPropProblem
{
    ULONG   ulIndex;
    ULONG   ulPropTag;
    SCODE   scode;
} SPropProblem, *LPSPropProblem;

typedef struct _SPropProblemArray
{
    ULONG           cProblem;
    SPropProblem    aProblem[MAPI_DIM];
} SPropProblemArray, *LPSPropProblemArray;

#define CbNewSPropProblemArray(_cprob) \
    (offsetof(SPropProblemArray,aProblem) + (_cprob)*sizeof(SPropProblem))
#define CbSPropProblemArray(_lparray) \
    (offsetof(SPropProblemArray,aProblem) + \
    (UINT) ((_lparray)->cProblem*sizeof(SPropProblem)))
#define SizedSPropProblemArray(_cprob, _name) \
struct _SPropProblemArray_ ## _name \
{ \
    ULONG           cProblem; \
    SPropProblem    aProblem[_cprob]; \
} _name

/*
 *  ENTRYLIST
 */

typedef SBinaryArray ENTRYLIST, FAR *LPENTRYLIST;

/*
 *  FLATENTRYLIST
 *  MTSID
 *  FLATMTSIDLIST
 */

typedef struct {
    ULONG cb;
    BYTE abEntry[MAPI_DIM];
} FLATENTRY, FAR *LPFLATENTRY;

typedef struct {
    ULONG       cEntries;
    ULONG       cbEntries;
    BYTE        abEntries[MAPI_DIM];
} FLATENTRYLIST, FAR *LPFLATENTRYLIST;

typedef struct {
    ULONG       cb;
    BYTE        ab[MAPI_DIM];
} MTSID, FAR *LPMTSID;

typedef struct {
    ULONG       cMTSIDs;
    ULONG       cbMTSIDs;
    BYTE        abMTSIDs[MAPI_DIM];
} FLATMTSIDLIST, FAR *LPFLATMTSIDLIST;

#define CbNewFLATENTRY(_cb)     (offsetof(FLATENTRY,abEntry) + (_cb))
#define CbFLATENTRY(_lpentry)   (offsetof(FLATENTRY,abEntry) + (_lpentry)->cb)
#define CbNewFLATENTRYLIST(_cb) (offsetof(FLATENTRYLIST,abEntries) + (_cb))
#define CbFLATENTRYLIST(_lplist) (offsetof(FLATENTRYLIST,abEntries) + (_lplist)->cbEntries)
#define CbNewMTSID(_cb)         (offsetof(MTSID,ab) + (_cb))
#define CbMTSID(_lpentry)       (offsetof(MTSID,ab) + (_lpentry)->cb)
#define CbNewFLATMTSIDLIST(_cb) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_cb))
#define CbFLATMTSIDLIST(_lplist) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_lplist)->cbMTSIDs)
/* No SizedXXX macros for these types. */

/* ------------------------------ */
/* ADRENTRY, ADRLIST */

typedef struct _ADRENTRY
{
    ULONG           ulReserved1;    /* Never used */
    ULONG           cValues;
    LPSPropValue    rgPropVals;
} ADRENTRY, FAR * LPADRENTRY;

typedef struct _ADRLIST
{
    ULONG           cEntries;
    ADRENTRY        aEntries[MAPI_DIM];
} ADRLIST, FAR * LPADRLIST;

#define CbNewADRLIST(_centries) \
    (offsetof(ADRLIST,aEntries) + (_centries)*sizeof(ADRENTRY))
#define CbADRLIST(_lpadrlist) \
    (offsetof(ADRLIST,aEntries) + (UINT)(_lpadrlist)->cEntries*sizeof(ADRENTRY))
#define SizedADRLIST(_centries, _name) \
struct _ADRLIST_ ## _name \
{ \
    ULONG           cEntries; \
    ADRENTRY        aEntries[_centries]; \
} _name

/* ------------------------------ */
/* SRow, SRowSet */

typedef struct _SRow
{
    ULONG           ulAdrEntryPad;  /* Pad so SRow's can map to ADRENTRY's */
    ULONG           cValues;        /* Count of property values */
    LPSPropValue    lpProps;        /* Property value array */
} SRow, FAR * LPSRow;

typedef struct _SRowSet
{
    ULONG           cRows;          /* Count of rows */
    SRow            aRow[MAPI_DIM]; /* Array of rows */
} SRowSet, FAR * LPSRowSet;

#define DoesCbNewSRowSetOverflow(_crow) \
    (((_crow) >= (ULONG_MAX/(ULONG)sizeof(SRow))) || ((CbNewSRowSet(_crow)) < ((CbNewSRowSet(0)))))
        
        
#define CbNewSRowSet(_crow)     (offsetof(SRowSet,aRow) + (_crow)*sizeof(SRow))
#define CbSRowSet(_lprowset)    (offsetof(SRowSet,aRow) + \
                                    (UINT)((_lprowset)->cRows*sizeof(SRow)))
#define SizedSRowSet(_crow, _name) \
struct _SRowSet_ ## _name \
{ \
    ULONG           cRows; \
    SRow            aRow[_crow]; \
} _name

/* MAPI Allocation Routines ------------------------------------------------ */

typedef SCODE (STDMETHODCALLTYPE ALLOCATEBUFFER)(
    ULONG           cbSize,
    LPVOID* lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE ALLOCATEMORE)(
    ULONG    cbSize,
    LPVOID   lpObject,
    LPVOID * lppBuffer
);

typedef ULONG (STDAPICALLTYPE FREEBUFFER)(
    LPVOID          lpBuffer
);

typedef ALLOCATEBUFFER *LPALLOCATEBUFFER;
typedef ALLOCATEMORE *  LPALLOCATEMORE;
typedef FREEBUFFER *    LPFREEBUFFER;

/* MAPI Component Object Model Macros -------------------------------------- */

#if defined(MAPI_IF) && (!defined(__cplusplus) || defined(CINTERFACE))
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface;            \
        struct iface##Vtbl
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_MAPI_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface, FAR * FAR * piface;
#else
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        DECLARE_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_INTERFACE_(iface, baseiface)
#ifdef __cplusplus
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        interface iface; typedef iface FAR * piface
#else
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef interface iface iface, FAR * piface
#endif
#endif

#define MAPIMETHOD(method)              MAPIMETHOD_(HRESULT, method)
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)
#define MAPIMETHOD_DECLARE(type, method, prefix) \
        STDMETHODIMP_(type) prefix##method
#define MAPIMETHOD_TYPEDEF(type, method, prefix) \
        typedef type (STDMETHODCALLTYPE prefix##method##_METHOD)

#define MAPI_IUNKNOWN_METHODS(IPURE)                                    \
    MAPIMETHOD(QueryInterface)                                          \
        (THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;                 \
    MAPIMETHOD_(ULONG,AddRef)  (THIS) IPURE;                            \
    MAPIMETHOD_(ULONG,Release) (THIS) IPURE;                            \

#undef  IMPL
#define IMPL

/* Pointers to MAPI Interfaces --------------------------------------------- */

typedef const IID FAR * LPCIID;

DECLARE_MAPI_INTERFACE_PTR(IMsgStore,       LPMDB);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFolder,     LPMAPIFOLDER);
DECLARE_MAPI_INTERFACE_PTR(IMessage,        LPMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IAttach,         LPATTACH);
DECLARE_MAPI_INTERFACE_PTR(IAddrBook,       LPADRBOOK);
DECLARE_MAPI_INTERFACE_PTR(IABContainer,    LPABCONT);
DECLARE_MAPI_INTERFACE_PTR(IMailUser,       LPMAILUSER);
DECLARE_MAPI_INTERFACE_PTR(IDistList,       LPDISTLIST);
DECLARE_MAPI_INTERFACE_PTR(IMAPIStatus,     LPMAPISTATUS);
DECLARE_MAPI_INTERFACE_PTR(IMAPITable,      LPMAPITABLE);
DECLARE_MAPI_INTERFACE_PTR(IProfSect,       LPPROFSECT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProp,       LPMAPIPROP);
DECLARE_MAPI_INTERFACE_PTR(IMAPIContainer,  LPMAPICONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIAdviseSink, LPMAPIADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProgress,   LPMAPIPROGRESS);
DECLARE_MAPI_INTERFACE_PTR(IProviderAdmin,  LPPROVIDERADMIN);

/* Extended MAPI Error Information ----------------------------------------- */

typedef struct _MAPIERROR
{
    ULONG   ulVersion;
    LPTSTR  lpszError;
    LPTSTR  lpszComponent;
    ULONG   ulLowLevelError;
    ULONG   ulContext;

} MAPIERROR, *LPMAPIERROR;


/* IMAPIAdviseSink Interface ----------------------------------------------- */

/*
 *  Notification event types. The event types can be combined in a bitmask
 *  for filtering. Each one has a parameter structure associated with it:
 *
 *      fnevCriticalError       ERROR_NOTIFICATION
 *      fnevNewMail             NEWMAIL_NOTIFICATION
 *      fnevObjectCreated       OBJECT_NOTIFICATION
 *      fnevObjectDeleted       OBJECT_NOTIFICATION
 *      fnevObjectModified      OBJECT_NOTIFICATION
 *      fnevObjectCopied        OBJECT_NOTIFICATION
 *      fnevSearchComplete      OBJECT_NOTIFICATION
 *      fnevTableModified       TABLE_NOTIFICATION
 *      fnevStatusObjectModified OBJECT_NOTIFICATION
 *
 *      fnevExtended            EXTENDED_NOTIFICATION
 */

#define fnevCriticalError           ((ULONG) 0x00000001)
#define fnevNewMail                 ((ULONG) 0x00000002)
#define fnevObjectCreated           ((ULONG) 0x00000004)
#define fnevObjectDeleted           ((ULONG) 0x00000008)
#define fnevObjectModified          ((ULONG) 0x00000010)
#define fnevObjectMoved             ((ULONG) 0x00000020)
#define fnevObjectCopied            ((ULONG) 0x00000040)
#define fnevSearchComplete          ((ULONG) 0x00000080)
#define fnevTableModified           ((ULONG) 0x00000100)
#define fnevStatusObjectModified    ((ULONG) 0x00000200)
#define fnevReservedForMapi         ((ULONG) 0x40000000)
#define fnevExtended                ((ULONG) 0x80000000)

/* TABLE_NOTIFICATION event types passed in ulTableEvent */

#define TABLE_CHANGED       1
#define TABLE_ERROR         2
#define TABLE_ROW_ADDED     3
#define TABLE_ROW_DELETED   4
#define TABLE_ROW_MODIFIED  5
#define TABLE_SORT_DONE     6
#define TABLE_RESTRICT_DONE 7
#define TABLE_SETCOL_DONE   8
#define TABLE_RELOAD        9

/* Event Structures */

typedef struct _ERROR_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;
    SCODE       scode;
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPMAPIERROR lpMAPIError;        /* Detailed error information */
} ERROR_NOTIFICATION;

typedef struct _NEWMAIL_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;          /* identifies the new message */
    ULONG       cbParentID;
    LPENTRYID   lpParentID;         /* identifies the folder it lives in */
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPTSTR      lpszMessageClass;   /* message class (UNICODE or string8) */
    ULONG       ulMessageFlags;     /* copy of PR_MESSAGE_FLAGS */
} NEWMAIL_NOTIFICATION;

typedef struct _OBJECT_NOTIFICATION
{
    ULONG               cbEntryID;
    LPENTRYID           lpEntryID;      /* EntryID of object */
    ULONG               ulObjType;      /* Type of object */
    ULONG               cbParentID;
    LPENTRYID           lpParentID;     /* EntryID of parent object */
    ULONG               cbOldID;
    LPENTRYID           lpOldID;        /* EntryID of old object */
    ULONG               cbOldParentID;
    LPENTRYID           lpOldParentID;  /* EntryID of old parent */
    LPSPropTagArray     lpPropTagArray;
} OBJECT_NOTIFICATION;

typedef struct _TABLE_NOTIFICATION
{
    ULONG               ulTableEvent;   /* Identifies WHICH table event */
    HRESULT             hResult;        /* Value for TABLE_ERROR */
    SPropValue          propIndex;      /* This row's "index property" */
    SPropValue          propPrior;      /* Preceding row's "index property" */
    SRow                row;            /* New data of added/modified row */
    ULONG               ulPad;          /* Force to 8-byte boundary */
} TABLE_NOTIFICATION;

typedef struct _EXTENDED_NOTIFICATION
{
    ULONG       ulEvent;                    /* extended event code */
    ULONG       cb;                         /* size of event parameters */
    LPBYTE      pbEventParameters;          /* event parameters */
} EXTENDED_NOTIFICATION;

typedef struct
{
    ULONG           cbEntryID;
    LPENTRYID       lpEntryID;
    ULONG           cValues;
    LPSPropValue    lpPropVals;
} STATUS_OBJECT_NOTIFICATION;

typedef struct _NOTIFICATION
{
    ULONG   ulEventType;        /* notification type, i.e. fnevSomething */
    ULONG   ulAlignPad;         /* Force to 8-byte boundary */
    union
    {
        ERROR_NOTIFICATION          err;
        NEWMAIL_NOTIFICATION        newmail;
        OBJECT_NOTIFICATION         obj;
        TABLE_NOTIFICATION          tab;
        EXTENDED_NOTIFICATION       ext;
        STATUS_OBJECT_NOTIFICATION  statobj;
    } info;
} NOTIFICATION, FAR * LPNOTIFICATION;


/* Interface used for registering and issuing notification callbacks. */

#define MAPI_IMAPIADVISESINK_METHODS(IPURE)                             \
    MAPIMETHOD_(ULONG, OnNotify)                                        \
        (THIS_  ULONG                       cNotif,                     \
                LPNOTIFICATION              lpNotifications) IPURE;     \

#undef       INTERFACE
#define      INTERFACE  IMAPIAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIADVISESINK_METHODS(PURE)
};

/* Callback function type for MAPIAllocAdviseSink */

typedef long (STDAPICALLTYPE NOTIFCALLBACK) (
    LPVOID          lpvContext,
    ULONG           cNotification,
    LPNOTIFICATION  lpNotifications);
typedef NOTIFCALLBACK FAR * LPNOTIFCALLBACK;

/*
 *  Message name for the 16-bit MAPI notififcation engine.
 *  This can be used in 16-bit applications to force processing
 *  of notification callbacks.
 */

#define szMAPINotificationMsg "MAPI Notify window message"


/* IMAPIProgress Interface ------------------------------------------------- */

/* Flag values for the progress indicator */

#define MAPI_TOP_LEVEL      ((ULONG) 0x00000001)

#define MAPI_IMAPIPROGRESS_METHODS(IPURE)                               \
    MAPIMETHOD(Progress)                                                \
        (THIS_  ULONG                       ulValue,                    \
                ULONG                       ulCount,                    \
                ULONG                       ulTotal) IPURE;             \
    MAPIMETHOD(GetFlags)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(GetMax)                                                  \
        (THIS_  ULONG FAR *                 lpulMax) IPURE;             \
    MAPIMETHOD(GetMin)                                                  \
        (THIS_  ULONG FAR *                 lpulMin) IPURE;             \
    MAPIMETHOD(SetLimits)                                               \
        (THIS_  LPULONG                     lpulMin,                    \
                LPULONG                     lpulMax,                    \
                LPULONG                     lpulFlags) IPURE;           \

#undef      INTERFACE
#define     INTERFACE   IMAPIProgress
DECLARE_MAPI_INTERFACE_(IMAPIProgress, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROGRESS_METHODS(PURE)
};


/* IMAPIProp Interface ----------------------------------------------------- */

/* GetLastError */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/*
 *  Version:
 */
#define MAPI_ERROR_VERSION      0x00000000L

/* GetPropList */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetProps */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* SaveChanges */

#define KEEP_OPEN_READONLY      ((ULONG) 0x00000001)
#define KEEP_OPEN_READWRITE     ((ULONG) 0x00000002)
#define FORCE_SAVE              ((ULONG) 0x00000004)
/* define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) below */

/* OpenProperty  - ulFlags */
/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
#define MAPI_CREATE             ((ULONG) 0x00000002)
#define STREAM_APPEND           ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* OpenProperty  - ulInterfaceOptions, IID_IMAPITable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* CopyTo, CopyProps */

#define MAPI_MOVE               ((ULONG) 0x00000001)
#define MAPI_NOREPLACE          ((ULONG) 0x00000002)
#define MAPI_DECLINE_OK         ((ULONG) 0x00000004)

// Import flag
#define MAPI_IMPORT_VCF         ((ULONG) 0x00000001)

#ifndef MAPI_DIALOG             /* also defined in mapi.h */
#define MAPI_DIALOG             ((ULONG) 0x00000008)
#endif

#ifndef MAPI_USE_DEFAULT        /* also defined in mapi.h */
#define MAPI_USE_DEFAULT        0x00000040  /* Use default profile in logon */
#endif

/* Flags used in GetIDsFromNames  */
/****** MAPI_CREATE             ((ULONG) 0x00000002) above */

/* Flags used in GetNamesFromIDs  (bit fields) */
#define MAPI_NO_STRINGS         ((ULONG) 0x00000001)
#define MAPI_NO_IDS             ((ULONG) 0x00000002)

/*  Union discriminator  */
#define MNID_ID                 0
#define MNID_STRING             1
typedef struct _MAPINAMEID
{
    LPGUID lpguid;
    ULONG ulKind;
    union {
        LONG lID;
        LPWSTR lpwstrName;
    } Kind;

} MAPINAMEID, FAR * LPMAPINAMEID;

#define MAPI_IMAPIPROP_METHODS(IPURE)                                   \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(SaveChanges)                                             \
        (THIS_ ULONG                        ulFlags) IPURE;             \
    MAPIMETHOD(GetProps)                                                \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppPropArray) IPURE;        \
    MAPIMETHOD(GetPropList)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTagArray) IPURE;     \
    MAPIMETHOD(OpenProperty)                                            \
        (THIS_  ULONG                       ulPropTag,                  \
                LPCIID                      lpiid,                      \
                ULONG                       ulInterfaceOptions,         \
                ULONG                       ulFlags,                    \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetProps)                                                \
        (THIS_  ULONG                       cValues,                    \
                LPSPropValue                lpPropArray,                \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DeleteProps)                                             \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyTo)                                                  \
        (THIS_  ULONG                       ciidExclude,                \
                LPCIID                      rgiidExclude,               \
                LPSPropTagArray             lpExcludeProps,             \
                ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyProps)                                               \
        (THIS_  LPSPropTagArray             lpIncludeProps,             \
                ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(GetNamesFromIDs)                                         \
        (THIS_  LPSPropTagArray FAR *       lppPropTags,                \
                LPGUID                      lpPropSetGuid,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcPropNames,               \
                LPMAPINAMEID FAR * FAR *    lpppPropNames) IPURE;       \
    MAPIMETHOD(GetIDsFromNames)                                         \
        (THIS_  ULONG                       cPropNames,                 \
                LPMAPINAMEID FAR *          lppPropNames,               \
                ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTags) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IMAPIProp
DECLARE_MAPI_INTERFACE_(IMAPIProp, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
};

/* IMAPITable Interface ---------------------------------------------------- */

/* Table status */

#define TBLSTAT_COMPLETE            ((ULONG) 0)
#define TBLSTAT_QCHANGED            ((ULONG) 7)
#define TBLSTAT_SORTING             ((ULONG) 9)
#define TBLSTAT_SORT_ERROR          ((ULONG) 10)
#define TBLSTAT_SETTING_COLS        ((ULONG) 11)
#define TBLSTAT_SETCOL_ERROR        ((ULONG) 13)
#define TBLSTAT_RESTRICTING         ((ULONG) 14)
#define TBLSTAT_RESTRICT_ERROR      ((ULONG) 15)


/* Table Type */

#define TBLTYPE_SNAPSHOT            ((ULONG) 0)
#define TBLTYPE_KEYSET              ((ULONG) 1)
#define TBLTYPE_DYNAMIC             ((ULONG) 2)


/* Sort order */

/* bit 0: set if descending, clear if ascending */

#define TABLE_SORT_ASCEND       ((ULONG) 0x00000000)
#define TABLE_SORT_DESCEND      ((ULONG) 0x00000001)
#define TABLE_SORT_COMBINE      ((ULONG) 0x00000002)


/* Data structures */

typedef struct _SSortOrder
{
    ULONG   ulPropTag;          /* Column to sort on */
    ULONG   ulOrder;            /* Ascending, descending, combine to left */
} SSortOrder, FAR * LPSSortOrder;

typedef struct _SSortOrderSet
{
    ULONG           cSorts;     /* Number of sort columns in aSort below*/
    ULONG           cCategories;    /* 0 for non-categorized, up to cSorts */
    ULONG           cExpanded;      /* 0 if no categories start expanded, */
                                    /*      up to cExpanded */
    SSortOrder      aSort[MAPI_DIM];    /* The sort orders */
} SSortOrderSet, FAR * LPSSortOrderSet;

#define CbNewSSortOrderSet(_csort) \
    (offsetof(SSortOrderSet,aSort) + (_csort)*sizeof(SSortOrder))
#define CbSSortOrderSet(_lpset) \
    (offsetof(SSortOrderSet,aSort) + \
    (UINT)((_lpset)->cSorts*sizeof(SSortOrder)))
#define SizedSSortOrderSet(_csort, _name) \
struct _SSortOrderSet_ ## _name \
{ \
    ULONG           cSorts;         \
    ULONG           cCategories;    \
    ULONG           cExpanded;      \
    SSortOrder      aSort[_csort];  \
} _name

typedef ULONG       BOOKMARK;

#define BOOKMARK_BEGINNING  ((BOOKMARK) 0)      /* Before first row */
#define BOOKMARK_CURRENT    ((BOOKMARK) 1)      /* Before current row */
#define BOOKMARK_END        ((BOOKMARK) 2)      /* After last row */

/* Fuzzy Level */

#define FL_FULLSTRING       ((ULONG) 0x00000000)
#define FL_SUBSTRING        ((ULONG) 0x00000001)
#define FL_PREFIX           ((ULONG) 0x00000002)

#define FL_IGNORECASE       ((ULONG) 0x00010000)
#define FL_IGNORENONSPACE   ((ULONG) 0x00020000)
#define FL_LOOSE            ((ULONG) 0x00040000)

/* Restrictions */

typedef struct _SRestriction    FAR * LPSRestriction;

/* Restriction types */

#define RES_AND             ((ULONG) 0x00000000)
#define RES_OR              ((ULONG) 0x00000001)
#define RES_NOT             ((ULONG) 0x00000002)
#define RES_CONTENT         ((ULONG) 0x00000003)
#define RES_PROPERTY        ((ULONG) 0x00000004)
#define RES_COMPAREPROPS    ((ULONG) 0x00000005)
#define RES_BITMASK         ((ULONG) 0x00000006)
#define RES_SIZE            ((ULONG) 0x00000007)
#define RES_EXIST           ((ULONG) 0x00000008)
#define RES_SUBRESTRICTION  ((ULONG) 0x00000009)
#define RES_COMMENT         ((ULONG) 0x0000000A)

/* Relational operators. These apply to all property comparison restrictions. */

#define RELOP_LT        ((ULONG) 0)     /* <  */
#define RELOP_LE        ((ULONG) 1)     /* <= */
#define RELOP_GT        ((ULONG) 2)     /* >  */
#define RELOP_GE        ((ULONG) 3)     /* >= */
#define RELOP_EQ        ((ULONG) 4)     /* == */
#define RELOP_NE        ((ULONG) 5)     /* != */
#define RELOP_RE        ((ULONG) 6)     /* LIKE (Regular expression) */

/* Bitmask operators, for RES_BITMASK only. */

#define BMR_EQZ     ((ULONG) 0)     /* ==0 */
#define BMR_NEZ     ((ULONG) 1)     /* !=0 */

/* Subobject identifiers for RES_SUBRESTRICTION only. See MAPITAGS.H. */

/* #define PR_MESSAGE_RECIPIENTS  PROP_TAG(PT_OBJECT,0x0E12) */
/* #define PR_MESSAGE_ATTACHMENTS PROP_TAG(PT_OBJECT,0x0E13) */

typedef struct _SAndRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SAndRestriction;

typedef struct _SOrRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SOrRestriction;

typedef struct _SNotRestriction
{
    ULONG           ulReserved;
    LPSRestriction  lpRes;
} SNotRestriction;

typedef struct _SContentRestriction
{
    ULONG           ulFuzzyLevel;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SContentRestriction;

typedef struct _SBitMaskRestriction
{
    ULONG           relBMR;
    ULONG           ulPropTag;
    ULONG           ulMask;
} SBitMaskRestriction;

typedef struct _SPropertyRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SPropertyRestriction;

typedef struct _SComparePropsRestriction
{
    ULONG           relop;
    ULONG           ulPropTag1;
    ULONG           ulPropTag2;
} SComparePropsRestriction;

typedef struct _SSizeRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    ULONG           cb;
} SSizeRestriction;

typedef struct _SExistRestriction
{
    ULONG           ulReserved1;
    ULONG           ulPropTag;
    ULONG           ulReserved2;
} SExistRestriction;

typedef struct _SSubRestriction
{
    ULONG           ulSubObject;
    LPSRestriction  lpRes;
} SSubRestriction;

typedef struct _SCommentRestriction
{
    ULONG           cValues; /* # of properties in lpProp */
    LPSRestriction  lpRes;
    LPSPropValue    lpProp;
} SCommentRestriction;

typedef struct _SRestriction
{
    ULONG   rt;         /* Restriction type */
    union
    {
        SComparePropsRestriction    resCompareProps;    /* first */
        SAndRestriction             resAnd;
        SOrRestriction              resOr;
        SNotRestriction             resNot;
        SContentRestriction         resContent;
        SPropertyRestriction        resProperty;
        SBitMaskRestriction         resBitMask;
        SSizeRestriction            resSize;
        SExistRestriction           resExist;
        SSubRestriction             resSub;
        SCommentRestriction         resComment;
    } res;
} SRestriction;

/* SComparePropsRestriction is first in the union so that */
/* static initializations of 3-value restriction work.    */

/* Flags of the methods of IMAPITable */

/* QueryColumn */

#define TBL_ALL_COLUMNS     ((ULONG) 0x00000001)

/* QueryRows */
/* Possible values for PR_ROW_TYPE (for categorization) */

#define TBL_LEAF_ROW            ((ULONG) 1)
#define TBL_EMPTY_CATEGORY      ((ULONG) 2)
#define TBL_EXPANDED_CATEGORY   ((ULONG) 3)
#define TBL_COLLAPSED_CATEGORY  ((ULONG) 4)

/* Table wait flag */

#define TBL_NOWAIT          ((ULONG) 0x00000001)
/* alternative name for TBL_NOWAIT */
#define TBL_ASYNC           ((ULONG) 0x00000001)
#define TBL_BATCH           ((ULONG) 0x00000002)

/* FindRow */

#define DIR_BACKWARD        ((ULONG) 0x00000001)

/* Table cursor states */

#define TBL_NOADVANCE       ((ULONG) 0x00000001)

#define MAPI_IMAPITABLE_METHODS(IPURE)                                  \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(GetStatus)                                               \
        (THIS_  ULONG FAR *                 lpulTableStatus,            \
                ULONG FAR *                 lpulTableType) IPURE;       \
    MAPIMETHOD(SetColumns)                                              \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QueryColumns)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lpPropTagArray) IPURE;      \
    MAPIMETHOD(GetRowCount)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulCount) IPURE;           \
    MAPIMETHOD(SeekRow)                                                 \
        (THIS_  BOOKMARK                    bkOrigin,                   \
                LONG                        lRowCount,                  \
                LONG FAR *                  lplRowsSought) IPURE;       \
    MAPIMETHOD(SeekRowApprox)                                           \
        (THIS_  ULONG                       ulNumerator,                \
                ULONG                       ulDenominator) IPURE;       \
    MAPIMETHOD(QueryPosition)                                           \
        (THIS_  ULONG FAR *                 lpulRow,                    \
                ULONG FAR *                 lpulNumerator,              \
                ULONG FAR *                 lpulDenominator) IPURE;     \
    MAPIMETHOD(FindRow)                                                 \
        (THIS_  LPSRestriction              lpRestriction,              \
                BOOKMARK                    bkOrigin,                   \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(Restrict)                                                \
        (THIS_  LPSRestriction              lpRestriction,              \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateBookmark)                                          \
        (THIS_  BOOKMARK FAR *              lpbkPosition) IPURE;        \
    MAPIMETHOD(FreeBookmark)                                            \
        (THIS_  BOOKMARK                    bkPosition) IPURE;          \
    MAPIMETHOD(SortTable)                                               \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QuerySortOrder)                                          \
        (THIS_  LPSSortOrderSet FAR *       lppSortCriteria) IPURE;     \
    MAPIMETHOD(QueryRows)                                               \
        (THIS_  LONG                        lRowCount,                  \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows) IPURE;             \
    MAPIMETHOD(Abort) (THIS) IPURE;                                     \
    MAPIMETHOD(ExpandRow)                                               \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulRowCount,                 \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows,                    \
                ULONG FAR *                 lpulMoreRows) IPURE;        \
    MAPIMETHOD(CollapseRow)                                             \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulRowCount) IPURE;        \
    MAPIMETHOD(WaitForCompletion)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       ulTimeout,                  \
                ULONG FAR *                 lpulTableStatus) IPURE;     \
    MAPIMETHOD(GetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbInstanceKey,              \
                LPBYTE                      lpbInstanceKey,             \
                ULONG FAR *                 lpcbCollapseState,          \
                LPBYTE FAR *                lppbCollapseState) IPURE;   \
    MAPIMETHOD(SetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbCollapseState,            \
                LPBYTE                      pbCollapseState,            \
                BOOKMARK FAR *              lpbkLocation) IPURE;        \

#undef       INTERFACE
#define      INTERFACE  IMAPITable
DECLARE_MAPI_INTERFACE_(IMAPITable, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPITABLE_METHODS(PURE)
};

/* IProfSect Interface ----------------------------------------------------- */

/* Standard section for public profile properties */

#define PS_PROFILE_PROPERTIES_INIT \
{   0x98, 0x15, 0xAC, 0x08, 0xAA, 0xB0, 0x10, 0x1A, \
    0x8C, 0x93, 0x08, 0x00, 0x2B, 0x2A, 0x56, 0xC2  }


#define MAPI_IPROFSECT_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IProfSect
DECLARE_MAPI_INTERFACE_(IProfSect, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IPROFSECT_METHODS(PURE)
};

/* IMAPIStatus Interface --------------------------------------------------- */

/* Values for PR_RESOURCE_TYPE, _METHODS, _FLAGS */

#define MAPI_STORE_PROVIDER     ((ULONG) 33)    /* Message Store */
#define MAPI_AB                 ((ULONG) 34)    /* Address Book */
#define MAPI_AB_PROVIDER        ((ULONG) 35)    /* Address Book Provider */
#define MAPI_TRANSPORT_PROVIDER ((ULONG) 36)    /* Transport Provider */
#define MAPI_SPOOLER            ((ULONG) 37)    /* Message Spooler */
#define MAPI_PROFILE_PROVIDER   ((ULONG) 38)    /* Profile Provider */
#define MAPI_SUBSYSTEM          ((ULONG) 39)    /* Overall Subsystem Status */
#define MAPI_HOOK_PROVIDER      ((ULONG) 40)    /* Spooler Hook */

#define STATUS_VALIDATE_STATE   ((ULONG) 0x00000001)
#define STATUS_SETTINGS_DIALOG  ((ULONG) 0x00000002)
#define STATUS_CHANGE_PASSWORD  ((ULONG) 0x00000004)
#define STATUS_FLUSH_QUEUES     ((ULONG) 0x00000008)

#define STATUS_DEFAULT_OUTBOUND ((ULONG) 0x00000001)
#define STATUS_DEFAULT_STORE    ((ULONG) 0x00000002)
#define STATUS_PRIMARY_IDENTITY ((ULONG) 0x00000004)
#define STATUS_SIMPLE_STORE     ((ULONG) 0x00000008)
#define STATUS_XP_PREFER_LAST   ((ULONG) 0x00000010)
#define STATUS_NO_PRIMARY_IDENTITY ((ULONG) 0x00000020)
#define STATUS_NO_DEFAULT_STORE ((ULONG) 0x00000040)
#define STATUS_TEMP_SECTION     ((ULONG) 0x00000080)
#define STATUS_OWN_STORE        ((ULONG) 0x00000100)
/****** HOOK_INBOUND            ((ULONG) 0x00000200) Defined in MAPIHOOK.H */
/****** HOOK_OUTBOUND           ((ULONG) 0x00000400) Defined in MAPIHOOK.H */
#define STATUS_NEED_IPM_TREE    ((ULONG) 0x00000800)
#define STATUS_PRIMARY_STORE    ((ULONG) 0x00001000)
#define STATUS_SECONDARY_STORE  ((ULONG) 0x00002000)


/*
 * PR_STATUS_CODE bit. Low 16 bits for common values; High 16 bits
 * for provider type-specific values. (DCR 304)
 */

#define STATUS_AVAILABLE        ((ULONG) 0x00000001)
#define STATUS_OFFLINE          ((ULONG) 0x00000002)
#define STATUS_FAILURE          ((ULONG) 0x00000004)

/* Transport values of PR_STATUS_CODE */

#define STATUS_INBOUND_ENABLED  ((ULONG) 0x00010000)
#define STATUS_INBOUND_ACTIVE   ((ULONG) 0x00020000)
#define STATUS_INBOUND_FLUSH    ((ULONG) 0x00040000)
#define STATUS_OUTBOUND_ENABLED ((ULONG) 0x00100000)
#define STATUS_OUTBOUND_ACTIVE  ((ULONG) 0x00200000)
#define STATUS_OUTBOUND_FLUSH   ((ULONG) 0x00400000)
#define STATUS_REMOTE_ACCESS    ((ULONG) 0x00800000)

/* ValidateState flags */

#define SUPPRESS_UI                 ((ULONG) 0x00000001)
#define REFRESH_XP_HEADER_CACHE     ((ULONG) 0x00010000)
#define PROCESS_XP_HEADER_CACHE     ((ULONG) 0x00020000)
#define FORCE_XP_CONNECT            ((ULONG) 0x00040000)
#define FORCE_XP_DISCONNECT         ((ULONG) 0x00080000)
#define CONFIG_CHANGED              ((ULONG) 0x00100000)
#define ABORT_XP_HEADER_OPERATION   ((ULONG) 0x00200000)
#define SHOW_XP_SESSION_UI          ((ULONG) 0x00400000)

/* SettingsDialog flags */

#define UI_READONLY     ((ULONG) 0x00000001)

/* FlushQueues flags */

#define FLUSH_UPLOAD        ((ULONG) 0x00000002)
#define FLUSH_DOWNLOAD      ((ULONG) 0x00000004)
#define FLUSH_FORCE         ((ULONG) 0x00000008)
#define FLUSH_NO_UI         ((ULONG) 0x00000010)
#define FLUSH_ASYNC_OK      ((ULONG) 0x00000020)

#define MAPI_IMAPISTATUS_METHODS(IPURE)                                 \
    MAPIMETHOD(ValidateState)                                           \
        (THIS_  __in_opt ULONG_PTR                   ulUIParam,         \
                         ULONG                       ulFlags) IPURE;    \
    MAPIMETHOD(SettingsDialog)                                          \
        (THIS_  __in_opt ULONG_PTR                   ulUIParam,         \
                         ULONG                       ulFlags) IPURE;    \
    MAPIMETHOD(ChangePassword)                                          \
        (THIS_  __in LPTSTR                      lpOldPass,             \
                __in LPTSTR                      lpNewPass,             \
                     ULONG                       ulFlags) IPURE;        \
    MAPIMETHOD(FlushQueues)                                             \
        (THIS_  __in_opt ULONG_PTR                   ulUIParam,         \
                         ULONG                       cbTargetTransport, \
                __in_ecount_opt(cbTargetTransport) LPENTRYID lpTargetTransport, \
                         ULONG                       ulFlags) IPURE;    \

#undef       INTERFACE
#define      INTERFACE  IMAPIStatus
DECLARE_MAPI_INTERFACE_(IMAPIStatus, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(