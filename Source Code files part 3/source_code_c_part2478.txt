s initialized
    BOOL     bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA  WSAData;

    // sSocket is the socket descriptor
    SOCKET   sSocket;

    // bException indicates if an exception occurred
    BOOL     bException;
    // iLastError is the error code if the operation failed
    int      iLastError;

    // szFunctionName is the function name
    CHAR     szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "socket v%04x", WinsockVersion);
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_socket+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_socket-");

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < socketTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, socketTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, socketTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != socketTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, socketTable[dwTableIndex].szVariationName);

        // Check the state of Winsock
        if (bWinsockInitialized != socketTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == socketTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = socketTable[dwTableIndex].bWinsockInitialized;
        }

        bException = FALSE;

        __try {
            // Call socket
            sSocket = socket(socketTable[dwTableIndex].af, socketTable[dwTableIndex].type, socketTable[dwTableIndex].protocol);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == socketTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "socket RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "socket caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == socketTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "socket did not RIP");
            }

            if ((INVALID_SOCKET == sSocket) && (INVALID_SOCKET == socketTable[dwTableIndex].sSocket)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != socketTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "iLastError - EXPECTED: %u; RECEIVED: %u", socketTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "iLastError - OUT: %u", iLastError);
                }
            }
            else if (INVALID_SOCKET == sSocket) {
                xLog(hLog, XLL_FAIL, "socket returned INVALID_SOCKET - ec = %u", WSAGetLastError());
            }
            else if (INVALID_SOCKET == socketTable[dwTableIndex].sSocket) {
                xLog(hLog, XLL_FAIL, "socket returned non-INVALID_SOCKET");
            }
            else {
                xLog(hLog, XLL_PASS, "socket succeeded");
            }

            if (INVALID_SOCKET != sSocket) {
                closesocket(sSocket);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\util.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.h

Abstract:

  This module contains the definitions for util.c

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#pragma once



namespace XNetAPINamespace {

LPSTR
GetIniString(
    HANDLE  hMemObject,
    LPCSTR  lpszSectionName,
    LPCSTR  lpszKeyName
);

LPSTR
GetIniSection(
    HANDLE  hMemObject,
    LPCSTR  lpszSectionName
);

BOOL
FindString(
    LPSTR  lpszString,
    LPSTR  lpszSubString
);

BOOL
ParseAndFindString(
    LPSTR  lpszString,
    LPSTR  lpszSubString
);

} // namespace XNetAPINamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\wsacanceloverlappedio.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  wsacanceloverlappedio.c

Abstract:

  This modules tests WSACancelOverlappedIO

Author:

  Steven Kehrli (steveke) 6-Feb-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// WSACancelOverlappedIO messages

#define WSACANCELOVERLAPPEDIO_REQUEST_MSG   NETSYNC_MSG_USER + 250 + 1
#define WSACANCELOVERLAPPEDIO_COMPLETE_MSG  NETSYNC_MSG_USER + 250 + 2

typedef struct _WSACANCELOVERLAPPEDIO_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bServerSend;
    BOOL     bServerReceive;
    int      nQueueLen;
} WSACANCELOVERLAPPEDIO_REQUEST, *PWSACANCELOVERLAPPEDIO_REQUEST;

typedef struct _WSACANCELOVERLAPPEDIO_COMPLETE {
    DWORD    dwMessageId;
} WSACANCELOVERLAPPEDIO_COMPLETE, *PWSACANCELOVERLAPPEDIO_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define WSASEND_FUNCTION             0x00000010
#define WSASENDTO_FUNCTION           0x00000020
#define WSARECV_FUNCTION             0x00000040
#define WSARECVFROM_FUNCTION         0x00000080

typedef struct WSACANCELOVERLAPPEDIO_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket;                                // dwSocket indicates the socket to be created
    DWORD  dwFunction;                              // dwFunction specifies the function to start the pending overlapped operation
    int    iReturnCode;                             // iReturnCode is the return code of WSACancelOverlappedIO
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} WSACANCELOVERLAPPEDIO_TABLE, *PWSACANCELOVERLAPPEDIO_TABLE;

static WSACANCELOVERLAPPEDIO_TABLE WSACancelOverlappedIOTable[] =
{
    { "25.1 Not Initialized",      FALSE, FALSE, SOCKET_INVALID_SOCKET,      0,                                         SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "25.2 s = INT_MIN",          TRUE,  TRUE,  SOCKET_INT_MIN,             0,                                         SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "25.3 s = -1",               TRUE,  TRUE,  SOCKET_NEG_ONE,             0,                                         SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "25.4 s = 0",                TRUE,  TRUE,  SOCKET_ZERO,                0,                                         SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "25.5 s = INT_MAX",          TRUE,  TRUE,  SOCKET_INT_MAX,             0,                                         SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "25.6 s = INVALID_SOCKET",   TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      0,                                         SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "25.7 TCP None",             TRUE,  TRUE,  SOCKET_TCP,                 0,                                         0,            0,                 FALSE },
    { "25.8 TCP Send",             TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION,                          0,            0,                 FALSE },
    { "25.9 TCP SendTo",           TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION,                        0,            0,                 FALSE },
    { "25.10 TCP Recv",            TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION,                          0,            0,                 FALSE },
    { "25.11 TCP RecvFrom",        TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION,                      0,            0,                 FALSE },
    { "25.12 TCP Send/Recv",       TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECV_FUNCTION,       0,            0,                 FALSE },
    { "25.13 TCP Send/RecvFrom",   TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECVFROM_FUNCTION,   0,            0,                 FALSE },
    { "25.14 TCP SendTo/Recv",     TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECV_FUNCTION,     0,            0,                 FALSE },
    { "25.15 TCP SendTo/RecvFrom", TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECVFROM_FUNCTION, 0,            0,                 FALSE },
    { "25.16 UDP None",            TRUE,  TRUE,  SOCKET_UDP,                 0,                                         0,            0,                 FALSE },
    { "25.17 UDP Recv",            TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                          0,            0,                 FALSE },
    { "25.18 UDP RecvFrom",        TRUE,  TRUE,  SOCKET_UDP,                 WSARECVFROM_FUNCTION,                      0,            0,                 FALSE },
    { "25.19 Closed Socket TCP",   TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, 0,                                         SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "25.20 Closed Socket UDP",   TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, 0,                                         SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "25.21 Not Initialized",     FALSE, FALSE, SOCKET_INVALID_SOCKET,      0,                                         SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define WSACancelOverlappedIOTableCount (sizeof(WSACancelOverlappedIOTable) / sizeof(WSACANCELOVERLAPPEDIO_TABLE))

NETSYNC_TYPE_THREAD  WSACancelOverlappedIOTestSessionNt =
{
    1,
    WSACancelOverlappedIOTableCount,
    L"xnetapi_nt.dll",
    "WSACancelOverlappedIOTestServer"
};

NETSYNC_TYPE_THREAD  WSACancelOverlappedIOTestSessionXbox =
{
    1,
    WSACancelOverlappedIOTableCount,
    L"xnetapi_xbox.dll",
    "WSACancelOverlappedIOTestServer"
};



VOID
WSACancelOverlappedIOTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests WSACancelOverlappedIO - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                          lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                          lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                          dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                           bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                        WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                         hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD            NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                         NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                        LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                        HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                        CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                         FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                          dwMessageSize;
    // pMessage is a pointer to the received message
    char                           *pMessage;
    // WSACancelOverlappedIORequest is the request sent to the server
    WSACANCELOVERLAPPEDIO_REQUEST  WSACancelOverlappedIORequest;
    
    // sSocket is the socket descriptor
    SOCKET                         sSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD                          dwBufferSize = BUFFER_10_LEN;
    // bNagle indicates if Nagle is enabled
    BOOL                           bNagle = FALSE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                         Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                           bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN                    localname;
    // remotename1 is the first remote address
    SOCKADDR_IN                    remotename1;
    // remotename2 is the second remote address
    SOCKADDR_IN                    remotename2;
    // namelen is the size of the address buffer
    int                            namelen;

    // writefds is the set of sockets to check for a write condition
    fd_set                         writefds;

    // SendBuffer10 is the send buffer
    char                           SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                           SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBuffer10 is the recv buffer
    char                           RecvBuffer10[BUFFER_10_LEN + 1];

    // WSASendBuf is the send WSABUF structure
    WSABUF                         WSASendBuf;
    // WSARecvBuf is the recv WSABUF structure
    WSABUF                         WSARecvBuf;

    // dwSendBytes1 is the number of bytes transferred for the function call
    DWORD                          dwSendBytes1;
    // dwSendBytes2 is the number of bytes transferred for the result call
    DWORD                          dwSendBytes2;
    // dwRecvBytes1 is the number of bytes transferred for the function call
    DWORD                          dwRecvBytes1;
    // dwRecvBytes2 is the number of bytes transferred for the result call
    DWORD                          dwRecvBytes2;

    // dwSendFlags2 is the transfer flags for the result call
    DWORD                          dwSendFlags2;
    // dwRecvFlags1 is the transfer flags for the function call
    DWORD                          dwRecvFlags1;
    // dwRecvFlags2 is the transfer flags for the result call
    DWORD                          dwRecvFlags2;

    // hSendEvent is a handle to the overlapped event
    HANDLE                         hSendEvent;
    // hRecvEvent is a handle to the overlapped event
    HANDLE                         hRecvEvent;

    // WSASendOverlapped is the overlapped structure
    WSAOVERLAPPED                  WSASendOverlapped;
    // WSARecvOverlapped is the overlapped structure
    WSAOVERLAPPED                  WSARecvOverlapped;

    // bException indicates if an exception occurred
    BOOL                           bException;
    // iReturnCode is the return code of the operation
    int                            iReturnCode;
    // iLastError is the error code if the operation failed
    int                            iLastError;
    // bTestPassed indicates if the test passed
    BOOL                           bTestPassed;

    // szFunctionName is the function name
    CHAR                           szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "WSACancelOver... v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_WSACancelOverlappedIO+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_WSACancelOverlappedIO-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = WSACancelOverlappedIOTestSessionXbox;
    }
    else {
        NetsyncTypeSession = WSACancelOverlappedIOTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < WSACancelOverlappedIOTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, WSACancelOverlappedIOTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, WSACancelOverlappedIOTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != WSACancelOverlappedIOTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, WSACancelOverlappedIOTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == WSACancelOverlappedIOTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != WSACancelOverlappedIOTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == WSACancelOverlappedIOTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = WSACancelOverlappedIOTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == WSACancelOverlappedIOTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the overlapped events
        hSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        hRecvEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        // Setup the overlapped structures
        ZeroMemory(&WSASendOverlapped, sizeof(WSASendOverlapped));
        WSASendOverlapped.hEvent = hSendEvent;

        ZeroMemory(&WSARecvOverlapped, sizeof(WSARecvOverlapped));
        WSARecvOverlapped.hEvent = hRecvEvent;

        // Create the socket
        sSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == WSACancelOverlappedIOTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == WSACancelOverlappedIOTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == WSACancelOverlappedIOTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == WSACancelOverlappedIOTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == WSACancelOverlappedIOTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & WSACancelOverlappedIOTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & WSACancelOverlappedIOTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & WSACancelOverlappedIOTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        if ((0 != (SOCKET_TCP & WSACancelOverlappedIOTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & WSACancelOverlappedIOTable[dwTableIndex].dwSocket))) {
            // Set the buffer size
            dwBufferSize = 10;
            setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

            dwBufferSize = 10;
            setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

            // Set the socket to non-blocking mode
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);

            // Bind the socket
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        if (0 != WSACancelOverlappedIOTable[dwTableIndex].dwFunction) {
            // Initialize the WSACancelOverlappedIO request
            WSACancelOverlappedIORequest.dwMessageId = WSACANCELOVERLAPPEDIO_REQUEST_MSG;
            if (0 != (SOCKET_TCP & WSACancelOverlappedIOTable[dwTableIndex].dwSocket)) {
                WSACancelOverlappedIORequest.nSocketType = SOCK_STREAM;
            }
            else {
                WSACancelOverlappedIORequest.nSocketType = SOCK_DGRAM;
            }
            WSACancelOverlappedIORequest.Port = CurrentPort;
            WSACancelOverlappedIORequest.bServerSend = (0 != (WSARECV_FUNCTION & WSACancelOverlappedIOTable[dwTableIndex].dwFunction)) || (0 != (WSARECVFROM_FUNCTION & WSACancelOverlappedIOTable[dwTableIndex].dwFunction));
            WSACancelOverlappedIORequest.bServerReceive = (0 != (WSASEND_FUNCTION & WSACancelOverlappedIOTable[dwTableIndex].dwFunction)) || (0 != (WSASENDTO_FUNCTION & WSACancelOverlappedIOTable[dwTableIndex].dwFunction));
            WSACancelOverlappedIORequest.nQueueLen = 0;

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSACancelOverlappedIORequest), (char *) &WSACancelOverlappedIORequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            // Connect the socket
            ZeroMemory(&remotename1, sizeof(remotename1));
            remotename1.sin_family = AF_INET;
            remotename1.sin_addr.s_addr = FromInAddr;
            remotename1.sin_port = htons(CurrentPort);

            connect(sSocket, (SOCKADDR *) &remotename1, sizeof(remotename1));

            if (0 != (SOCKET_TCP & WSACancelOverlappedIOTable[dwTableIndex].dwSocket)) {
                FD_ZERO(&writefds);
                FD_SET(sSocket, &writefds);
                select(0, NULL, &writefds, NULL, NULL);
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSACancelOverlappedIORequest), (char *) &WSACancelOverlappedIORequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);
        }

        // Setup the WSABuf structures
        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
        WSASendBuf.len = BUFFER_TCPSEGMENT_LEN;
        WSASendBuf.buf = SendBufferLarge;

        ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
        WSARecvBuf.len = 10;
        WSARecvBuf.buf = RecvBuffer10;

        // Initialize dwBytes and dwFlags
        dwSendBytes1 = 0;
        dwSendBytes2 = 0;
        dwRecvBytes1 = 0;
        dwRecvBytes2 = 0;

        dwSendFlags2 = 0;
        dwRecvFlags1 = 0;
        dwRecvFlags2 = 0;

        // Start the pending overlapped operation
        if (0 != (WSASEND_FUNCTION & WSACancelOverlappedIOTable[dwTableIndex].dwFunction)) {
            // Fill the queue
            ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
            while (SOCKET_ERROR != send(sSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0)) {
                WSACancelOverlappedIORequest.nQueueLen++;
                Sleep(SLEEP_ZERO_TIME);
            }

            // Call WSASend
            iReturnCode = WSASend(sSocket, &WSASendBuf, 1, &dwSendBytes1, 0, &WSASendOverlapped, NULL);

            if (SOCKET_ERROR != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSASend returned non-SOCKET_ERROR");
            }
            else if (WSA_IO_PENDING != WSAGetLastError()) {
                xLog(hLog, XLL_FAIL, "WSASend iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, WSAGetLastError());
            }
        }
        else if (0 != (WSASENDTO_FUNCTION & WSACancelOverlappedIOTable[dwTableIndex].dwFunction)) {
            // Fill the queue
            ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
            while (SOCKET_ERROR != send(sSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0)) {
                WSACancelOverlappedIORequest.nQueueLen++;
                Sleep(SLEEP_ZERO_TIME);
            }

            // Call WSASendTo
            ZeroMemory(&remotename1, sizeof(remotename1));
            remotename1.sin_family = AF_INET;
            remotename1.sin_addr.s_addr = FromInAddr;
            remotename1.sin_port = htons(CurrentPort);

            iReturnCode = WSASendTo(sSocket, &WSASendBuf, 1, &dwSendBytes1, 0, (SOCKADDR *) &remotename1, sizeof(remotename1), &WSASendOverlapped, NULL);

            if (SOCKET_ERROR != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSASendTo returned non-SOCKET_ERROR");
            }
            else if (WSA_IO_PENDING != WSAGetLastError()) {
                xLog(hLog, XLL_FAIL, "WSASendTo iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, WSAGetLastError());
            }
        }

        if (0 != (WSARECV_FUNCTION & WSACancelOverlappedIOTable[dwTableIndex].dwFunction)) {
            // Call WSARecv
            iReturnCode = WSARecv(sSocket, &WSARecvBuf, 1, &dwRecvBytes1, &dwRecvFlags1, &WSARecvOverlapped, NULL);

            if (SOCKET_ERROR != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSARecv returned non-SOCKET_ERROR");
            }
            else if (WSA_IO_PENDING != WSAGetLastError()) {
                xLog(hLog, XLL_FAIL, "WSARecv iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, WSAGetLastError());
            }
        }
        else if (0 != (WSARECVFROM_FUNCTION & WSACancelOverlappedIOTable[dwTableIndex].dwFunction)) {
            // Call WSARecvFrom
            namelen = sizeof(remotename2);
            ZeroMemory(&remotename2, sizeof(remotename2));

            iReturnCode = WSARecvFrom(sSocket, &WSARecvBuf, 1, &dwRecvBytes1, &dwRecvFlags1, (SOCKADDR *) &remotename2, &namelen, &WSARecvOverlapped, NULL);

            if (SOCKET_ERROR != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSARecvFrom returned non-SOCKET_ERROR");
            }
            else if (WSA_IO_PENDING != WSAGetLastError()) {
                xLog(hLog, XLL_FAIL, "WSARecvFrom iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, WSAGetLastError());
            }
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & WSACancelOverlappedIOTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        __try {
            // Call WSACancelOverlappedIO
            iReturnCode = WSACancelOverlappedIO(sSocket);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == WSACancelOverlappedIOTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "WSACancelOverlappedIO RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "WSACancelOverlappedIO caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (0 != WSACancelOverlappedIOTable[dwTableIndex].dwFunction) {
                // Send the function request
                NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSACancelOverlappedIORequest), (char *) &WSACancelOverlappedIORequest);

                // Wait for the function complete
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                NetsyncFreeMessage(pMessage);
            }

            if (TRUE == WSACancelOverlappedIOTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "WSACancelOverlappedIO did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == WSACancelOverlappedIOTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != WSACancelOverlappedIOTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "WSACancelOverlappedIO iLastError - EXPECTED: %u; RECEIVED: %u", WSACancelOverlappedIOTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "WSACancelOverlappedIO iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSACancelOverlappedIO returned SOCKET_ERROR - ec = %u", WSAGetLastError());
            }
            else if (SOCKET_ERROR == WSACancelOverlappedIOTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSACancelOverlappedIO returned non-SOCKET_ERROR");
            }
            else {
                if ((0 != (WSASEND_FUNCTION & WSACancelOverlappedIOTable[dwTableIndex].dwFunction)) || (0 != (WSASENDTO_FUNCTION & WSACancelOverlappedIOTable[dwTableIndex].dwFunction))) {
                    if (TRUE == WSAGetOverlappedResult(sSocket, &WSASendOverlapped, &dwSendBytes2, TRUE, &dwSendFlags2)) {
                        xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult send returned TRUE");
                        bTestPassed = FALSE;
                    }
                    else if (WSAECANCELLED != WSAGetLastError()) {
                        xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult send iLastError - EXPECTED: %u; RECEIVED: %u", WSAECANCELLED, WSAGetLastError());
                        bTestPassed = FALSE;
                    }
                    else {
                        FD_ZERO(&writefds);
                        FD_SET(sSocket, &writefds);
                        select(0, NULL, &writefds, NULL, NULL);

                        if (0 == FD_ISSET(sSocket, &writefds)) {
                            xLog(hLog, XLL_FAIL, "select writefds returned failure");
                            bTestPassed = FALSE;
                        }
                    }
                }

                if ((0 != (WSARECV_FUNCTION & WSACancelOverlappedIOTable[dwTableIndex].dwFunction)) || (0 != (WSARECVFROM_FUNCTION & WSACancelOverlappedIOTable[dwTableIndex].dwFunction))) {
                    if (TRUE == WSAGetOverlappedResult(sSocket, &WSARecvOverlapped, &dwRecvBytes2, TRUE, &dwRecvFlags2)) {
                        xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult send returned TRUE");
                        bTestPassed = FALSE;
                    }
                    else if (WSAECANCELLED != WSAGetLastError()) {
                        xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult send iLastError - EXPECTED: %u; RECEIVED: %u", WSAECANCELLED, WSAGetLastError());
                        bTestPassed = FALSE;
                    }
                    else if (SOCKET_ERROR == recv(sSocket, RecvBuffer10, sizeof(RecvBuffer10), 0)) {
                        xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "WSACancelOverlappedIO succeeded");
                }
            }
        }

        if (0 != WSACancelOverlappedIOTable[dwTableIndex].dwFunction) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSACancelOverlappedIORequest), (char *) &WSACancelOverlappedIORequest);
        }

        // Close the socket
        if (0 == (SOCKET_CLOSED & WSACancelOverlappedIOTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & WSACancelOverlappedIOTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & WSACancelOverlappedIOTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Close the event
        CloseHandle(hRecvEvent);
        CloseHandle(hSendEvent);

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
WSACancelOverlappedIOTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests WSACancelOverlappedIO - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long                          FromInAddr;
    // dwMessageType is the type of received message
    DWORD                           dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                           dwMessageSize;
    // pMessage is a pointer to the received message
    char                            *pMessage;
    // WSACancelOverlappedIORequest is the request
    WSACANCELOVERLAPPEDIO_REQUEST   WSACancelOverlappedIORequest;
    // WSACancelOverlappedIOComplete is the result
    WSACANCELOVERLAPPEDIO_COMPLETE  WSACancelOverlappedIOComplete;

    // sSocket is the socket descriptor
    SOCKET                          sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                          nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD                           dwBufferSize = 1;
    // bNagle indicates if Nagle is enabled
    BOOL                            bNagle = FALSE;
    // nQueueLen is the size of the queue
    int                             nQueueLen;

    // localname is the local address
    SOCKADDR_IN                     localname;
    // remotename is the remote address
    SOCKADDR_IN                     remotename;

    // SendBuffer10 is the send buffer
    char                            SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                            SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // nSendCount is a counter to enumerate each send
    int                             nSendCount;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&WSACancelOverlappedIORequest, pMessage, sizeof(WSACancelOverlappedIORequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, WSACancelOverlappedIORequest.nSocketType, 0);

        if (SOCK_STREAM == WSACancelOverlappedIORequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the buffer size
        dwBufferSize = 1;
        setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

        dwBufferSize = 1;
        setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(WSACancelOverlappedIORequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if (SOCK_STREAM == WSACancelOverlappedIORequest.nSocketType) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }

        // Send the complete
        WSACancelOverlappedIOComplete.dwMessageId = WSACANCELOVERLAPPEDIO_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSACancelOverlappedIOComplete), (char *) &WSACancelOverlappedIOComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if (SOCK_STREAM == WSACancelOverlappedIORequest.nSocketType) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(WSACancelOverlappedIORequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        WSACancelOverlappedIOComplete.dwMessageId = WSACANCELOVERLAPPEDIO_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSACancelOverlappedIOComplete), (char *) &WSACancelOverlappedIOComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        nQueueLen = ((PWSACANCELOVERLAPPEDIO_REQUEST) pMessage)->nQueueLen;
        NetsyncFreeMessage(pMessage);

        // Fulfill the send/recv operations
        if (TRUE == WSACancelOverlappedIORequest.bServerSend) {
            // Call send
            sprintf(SendBuffer10, "%05d%05d", 1, 1);
            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0);
        }

        if (TRUE == WSACancelOverlappedIORequest.bServerReceive) {
            ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
            for (nSendCount = 0; nSendCount < nQueueLen; nSendCount++) {
                recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0);
            }
        }

        // Send the complete
        WSACancelOverlappedIOComplete.dwMessageId = WSACANCELOVERLAPPEDIO_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSACancelOverlappedIOComplete), (char *) &WSACancelOverlappedIOComplete);

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\wsacleanup.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  WSACleanup.c

Abstract:

  This modules tests WSACleanup

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _SOCKET_TABLE {
    int  af;       // af is the address family of the socket
    int  type;     // type is the type of the socket
    int  protocol; // protocol is the protocol of the socket
} SOCKET_TABLE, *PSOCKET_TABLE;

static SOCKET_TABLE socketTable[] =
{
    { AF_INET, SOCK_STREAM, 0            },
    { AF_INET, SOCK_STREAM, IPPROTO_TCP  },
    { AF_INET, SOCK_DGRAM,  0            },
    { AF_INET, SOCK_DGRAM,  IPPROTO_UDP  }
};

#define socketTableCount (sizeof(socketTable) / sizeof(SOCKET_TABLE))



typedef struct _WSACLEANUP_TABLE {
    CHAR  szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL  bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL  bRecleanup;                              // bRecleanup indicates if Winsock should be terminated a second time
    BOOL  bOpenSockets;                            // bOpenSockets indicates if sockets should be created before cleanup
    int   iReturnCode;                             // iReturnCode is the return value of WSACleanup
    int   iLastError;                              // iLastError is the error code if the operation failed
    BOOL  bRIP;                                    // Specifies a RIP test case
} WSACLEANUP_TABLE, *PWSACLEANUP_TABLE;

static WSACLEANUP_TABLE WSACleanupTable[] =
{
    { "7.1 Not Initialized", FALSE, FALSE, FALSE, SOCKET_ERROR, WSANOTINITIALISED },
    { "7.2 Initialized",     TRUE,  FALSE, FALSE, 0,            0                 },
    { "7.3 Cleanup Twice",   TRUE,  TRUE,  FALSE, SOCKET_ERROR, WSANOTINITIALISED },
    { "7.4 Open Sockets",    TRUE,  FALSE, TRUE,  0,            0                 }
};

#define WSACleanupTableCount (sizeof(WSACleanupTable) / sizeof(WSACLEANUP_TABLE))



VOID
WSACleanupTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests WSACleanup

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR    lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR    lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD    dwTableIndex;

    // WSAData is the details of the Winsock implementation
    WSADATA  WSAData;

    // sSockets is an array of socket descriptors
    SOCKET   sSockets[socketTableCount];
    // dwSocket is a counter to enumerate each entry in socketTable
    DWORD    dwSocket;

    // bException indicates if an exception occurred
    BOOL     bException;
    // iReturnCode is the return code of the operation
    int      iReturnCode;
    // iLastError is the error code if the operation failed
    int      iLastError;

    // szFunctionName is the function name
    CHAR     szFunctionName[FUNCTION_NAME_LENGTH];

    // Set the function name
    sprintf(szFunctionName, "WSACleanup v%04x", WinsockVersion);
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_WSACleanup+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_WSACleanup-");

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < WSACleanupTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, WSACleanupTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, WSACleanupTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != WSACleanupTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, WSACleanupTable[dwTableIndex].szVariationName);

        // Check the state of Winsock
        if (TRUE == WSACleanupTable[dwTableIndex].bWinsockInitialized) {
            // Initialize Winsock
            WSAStartup(WinsockVersion, &WSAData);
        }

        // Check the state of terminate twice
        if (TRUE == WSACleanupTable[dwTableIndex].bRecleanup) {
            WSACleanup();
        }

        // Check the state of open sockets
        if (TRUE == WSACleanupTable[dwTableIndex].bOpenSockets) {
            for (dwSocket = 0; dwSocket < socketTableCount; dwSocket++) {
                // Create the socket
                sSockets[dwSocket] = socket(socketTable[dwSocket].af, socketTable[dwSocket].type, socketTable[dwSocket].protocol);
            }
        }

        bException = FALSE;

        __try {
            // Call WSACleanup
            iReturnCode = WSACleanup();
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == WSACleanupTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "WSACleanup RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "WSACleanup caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == WSACleanupTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "WSACleanup did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == WSACleanupTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != WSACleanupTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "iLastError - EXPECTED: %u; RECEIVED: %u", WSACleanupTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSACleanup returned SOCKET_ERROR - ec: %u", WSAGetLastError());
            }
            else if (SOCKET_ERROR == WSACleanupTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSACleanup returned non-SOCKET_ERROR");
            }
            else {
                xLog(hLog, XLL_PASS, "iReturnCode - OUT: %u", iReturnCode);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate net subsystem
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\util.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module contains the utility functions for xnetapi.dll

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

LPSTR
GetIniString(
    HANDLE  hMemObject,
    LPCSTR  lpszSectionName,
    LPCSTR  lpszKeyName
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the specified string of the .ini file

Arguments:

  hMemObject - handle to the memory object
  lpszSectionName - pointer to the ini section name
  lpszKeyName - pointer to the ini key name

Return Value:

  LPSTR:
    If the function succeeds, the return value is a pointer to the string.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

-----------------------------------------------------------------------------*/
{
    // lpszString is a pointer to the string
    LPSTR  lpszString = NULL;
    // dwBufferSize is the size of the buffer referenced by lpszString
    DWORD  dwBufferSize = 0;
    // dwResult is the result of the GetProfileString call
    DWORD  dwResult = 0;

    // Allocate the memory for the string
    dwBufferSize = 0x10;
    lpszString = (LPSTR) xMemAlloc(hMemObject, dwBufferSize);

    while (NULL != lpszString)
    {
        dwResult = GetProfileStringA(lpszSectionName, lpszKeyName, NULL, lpszString, dwBufferSize);

        if (0 == dwResult) {
            goto FunctionFailed;
        }

        if (dwResult < (dwBufferSize - 2))
        {
            break;
        }

        dwBufferSize += 0x10;
        lpszString = (LPSTR) xMemReAlloc(hMemObject, lpszString, dwBufferSize);
    }

    if (NULL == lpszString)
    {
        goto FunctionFailed;
    }

    return lpszString;

FunctionFailed:
    if (NULL != lpszString) {
        xMemFree(hMemObject, lpszString);
    }

    return NULL;
}



LPSTR
GetIniSection(
    HANDLE  hMemObject,
    LPCSTR  lpszSectionName
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the strings in the specified section of the .ini file

Arguments:

  hMemObject - handle to the memory object
  lpszSectionName - pointer to the ini section name

Return Value:

  LPSTR:
    If the function succeeds, the return value is a pointer to the string.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

-----------------------------------------------------------------------------*/
{
    // lpszString is a pointer to the string
    LPSTR  lpszString = NULL;
    // dwBufferSize is the size of the buffer referenced by lpszString
    DWORD  dwBufferSize = 0;
    // dwResult is the result of the GetProfileString call
    DWORD  dwResult = 0;

    // Allocate the memory for the string
    dwBufferSize = 0x10;
    lpszString = (LPSTR) xMemAlloc(hMemObject, dwBufferSize);

    while (NULL != lpszString)
    {
        dwResult = GetProfileSectionA(lpszSectionName, lpszString, dwBufferSize);

        if (0 == dwResult) {
            goto FunctionFailed;
        }

        if (dwResult < (dwBufferSize - 2))
        {
            break;
        }

        dwBufferSize += 0x10;
        lpszString = (LPSTR) xMemReAlloc(hMemObject, lpszString, dwBufferSize);
    }

    if (NULL == lpszString)
    {
        goto FunctionFailed;
    }

    return lpszString;

FunctionFailed:
    if (NULL != lpszString) {
        xMemFree(hMemObject, lpszString);
    }

    return NULL;
}



BOOL
FindString(
    LPSTR  lpszString,
    LPSTR  lpszSubString
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Search a list of strings for a specified string

Arguments:

  lpszString - pointer to the list of strings
  lpszSubString - pointer to the specified string

Return Value:

  BOOL:
    If the specified string is found, the return value is non-zero.
    If the specified string is not found, the return value is zero.

-----------------------------------------------------------------------------*/
{
    // lpszCurString is a pointer to the current string
    LPSTR  lpszCurString = lpszString;

    while ('\0' != *lpszCurString) {
        if (0 == _stricmp(lpszCurString, lpszSubString)) {
            break;
        }

        lpszCurString += (strlen(lpszCurString) + 1);
    }

    return ('\0' != *lpszCurString);
}



BOOL
ParseAndFindString(
    LPSTR  lpszString,
    LPSTR  lpszSubString
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Parse the specified string for the first space and compares the result against the string

Arguments:

  lpszString - pointer to the string
  lpszSubString - pointer to the specified string

Return Value:

  BOOL:
    If the specified string is found, the return value is non-zero.
    If the specified string is not found, the return value is zero.

-----------------------------------------------------------------------------*/
{
    // lpszSpace is a pointer to the space
    LPSTR  lpszSpace = NULL;
    // lpszCurString is a pointer to the current string
    LPSTR  lpszCurString = lpszString;

    lpszSpace = strchr(lpszSubString, ' ');

    while ('\0' != *lpszCurString) {
        if ((strlen(lpszCurString) == (lpszSpace - lpszSubString)) && (0 == _strnicmp(lpszCurString, lpszSubString, lpszSpace - lpszSubString))) {
            break;
        }

        lpszCurString += (strlen(lpszCurString) + 1);
    }

    return ('\0' != *lpszCurString);
}

} // namespace XNetAPINamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\wsarecv.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  wsarecv.c

Abstract:

  This modules tests wsarecv

Author:

  Steven Kehrli (steveke) 13-Dev-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// WSARecv messages

#define WSARECV_REQUEST_MSG   NETSYNC_MSG_USER + 180 + 1
#define WSARECV_CANCEL_MSG    NETSYNC_MSG_USER + 180 + 2
#define WSARECV_COMPLETE_MSG  NETSYNC_MSG_USER + 180 + 3

typedef struct _WSARECV_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bServerAccept;
    BOOL     bRemoteShutdown;
    BOOL     bRemoteClose;
    int      nDataBuffers;
    int      nBufferlen;
} WSARECV_REQUEST, *PWSARECV_REQUEST;

typedef struct _WSARECV_COMPLETE {
    DWORD    dwMessageId;
} WSARECV_COMPLETE, *PWSARECV_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define BUFFER_10             0
#define BUFFER_LARGE          1
#define BUFFER_NULL           2
#define BUFFER_NULLZERO       3
#define BUFFER_ZERO           4
#define BUFFER_ZEROCOUNT      5
#define BUFFER_SMALL          6
#define BUFFER_TCPLARGE       7
#define BUFFER_UDPLARGE       8
#define BUFFER_UDPTOOLARGE    9
#define BUFFER_MULTI         10
#define BUFFER_SECOND        11
#define BUFFER_NONE          12

#define OVERLAPPED_IO_RESULT  1
#define OVERLAPPED_IO_EVENT   2



typedef struct WSARECVBUFFER_TABLE {
    DWORD  dwBuffer;
} WSARECVBUFFER_TABLE, *PWSARECVBUFFER_TABLE;

WSARECVBUFFER_TABLE WSARecvBufferTcpTable[] = { { BUFFER_10        },
                                                { BUFFER_NULLZERO  },
                                                { BUFFER_TCPLARGE  } };

#define WSARecvBufferTcpTableCount  (sizeof(WSARecvBufferTcpTable) / sizeof(WSARECVBUFFER_TABLE));

WSARECVBUFFER_TABLE WSARecvBufferUdpTable[] = { { BUFFER_10        },
                                                { BUFFER_NULLZERO  },
                                                { BUFFER_UDPLARGE  } };

#define WSARecvBufferUdpTableCount  (sizeof(WSARecvBufferUdpTable) / sizeof(WSARECVBUFFER_TABLE));



typedef struct WSARECV_TABLE {
    CHAR           szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL           bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL           bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD          dwSocket;                                // dwSocket indicates the socket to be created
    BOOL           bNonblock;                               // bNonblock indicates if the socket is to be set as non-blocking for the recv
    BOOL           bBind;                                   // bBind indicates if the socket is to be bound
    BOOL           bListen;                                 // bListen indicates if the socket is to be placed in the listening state
    BOOL           bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL           bConnect;                                // bConnect indicates if the socket is connected
    BOOL           bRemoteShutdown;                         // bRemoteShutdown indicates if the remote shutsdown the connection
    BOOL           bRemoteClose;                            // bRemoteClose indicates if the remote closes the connection
    BOOL           bShutdown;                               // bShutdown indicates if the connection is shutdown
    int            nShutdown;                               // nShutdown indicates how the connection is shutdown
    int            nDataBuffers;                            // nDataBuffers indicates the number of data buffers to be received
    DWORD          dwBuffer;                                // dwBuffer specifies the recv data structure
    BOOL           bBytesRecv;                              // bFlags indicates if dwBytes is used
    BOOL           bFlags;                                  // bFlags indicates if dwFlags is used
    DWORD          dwFlags;                                 // dwFlags specifies the recv flags
    BOOL           bSecondRecv;                             // bSecondRecv indicates if a second recv should occur
    int            nOverlapped;                             // nOverlapped specifies if overlapped I/O is used
    BOOL           bCompletionRoutine;                      // bCompletionRoutine specifies if completion routine is used
    int            iReturnCode;                             // iReturnCode is the return code of recv
    int            iLastError;                              // iLastError is the error code if the operation failed
    BOOL           bRIP;                                    // Specifies a RIP test case
} WSARECV_TABLE, *PWSARECV_TABLE;

static WSARECV_TABLE WSARecvTable[] =
{
    { "18.1 Not Initialized",            FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "18.2 s = INT_MIN",                TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "18.3 s = -1",                     TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "18.4 s = 0",                      TRUE,  TRUE,  SOCKET_ZERO,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "18.5 s = INT_MAX",                TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "18.6 s = INVALID_SOCKET",         TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "18.7 Not Bound TCP",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "18.8 Listening TCP",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "18.9 Accepted TCP",               TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.10 Connected TCP",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.11 Second Receive TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SECOND,    TRUE,  TRUE,  0, TRUE,  0,                    FALSE, 0,            0,                 FALSE },
    { "18.12 I/O TCP",                   TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, OVERLAPPED_IO_RESULT, FALSE, 0,            0,                 FALSE },
    { "18.13 Event TCP",                 TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "18.14 Event Event TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,        TRUE,  TRUE,  0, FALSE, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "18.15 SD_RECEIVE Accept TCP",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "18.16 SD_SEND Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.17 SD_BOTH Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "18.18 SD_RECEIVE Connect TCP",    TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "18.19 SD_SEND Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.20 SD_BOTH Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "18.21 Shutdown Accept TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.22 Shutdown Connect TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.23 Close Accept TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "18.24 Close Connect TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "18.25 NULL Buffer TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.26 NULL 0 Bufferlen TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,  TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.27 0 Bufferlen TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.28 Small Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,     TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.29 Exact Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.30 Large Buffer TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_TCPLARGE,  TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.31 Multi Buffer TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_MULTI,     TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.32 Switch Recv TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.33 Iterative Recv TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.34 NULL Buffer Ptr TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.35 0 Buffer Count TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT, TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.36 NULL dwBytes TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        FALSE, TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.37 NULL flags TCP",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  FALSE, 0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.38 flags != 0 TCP",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  4, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.39 Callback != NULL TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.40 Not Bound NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "18.41 Listening NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "18.42 Accepted NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.43 Connected NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.44 Second Receive NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SECOND,    TRUE,  TRUE,  0, TRUE,  0,                    FALSE, 0,            0,                 FALSE },
    { "18.45 I/O NB TCP",                TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, OVERLAPPED_IO_RESULT, FALSE, 0,            0,                 FALSE },
    { "18.46 Event NB TCP",              TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "18.47 Event Event NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,        TRUE,  TRUE,  0, FALSE, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "18.48 SD_RECEIVE Accept NB TCP",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "18.49 SD_SEND Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.50 SD_BOTH Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "18.51 SD_RECEIVE Connect NB TCP", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "18.52 SD_SEND Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.53 SD_BOTH Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "18.54 Shutdown Accept NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.55 Shutdown Connect NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.56 Close Accept NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "18.57 Close Connect NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "18.58 NULL Buffer NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.59 NULL 0 Bufferlen NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,  TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.60 0 Bufferlen NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.61 Small Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,     TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.62 Exact Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.63 Large Buffer NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_TCPLARGE,  TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.64 Multi Buffer NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_MULTI,     TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.65 Switch Recv NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.66 Iterative Recv NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.67 NULL Buffer Ptr NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.68 0 Buffer Count NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT, TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.69 NULL dwBytes NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        FALSE, TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.70 NULL flags NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  FALSE, 0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.71 flags != 0 NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  4, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.72 Callback != NULL NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.73 Not Bound UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "18.74 Not Connected UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.75 Connected UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.76 Second Receive UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SECOND,    TRUE,  TRUE,  0, TRUE,  0,                    FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "18.77 SD_RECEIVE Conn UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "18.78 SD_SEND Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.79 SD_BOTH Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "18.80 I/O UDP",                   TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, OVERLAPPED_IO_RESULT, FALSE, 0,            0,                 FALSE },
    { "18.81 Event UDP",                 TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "18.82 Event Event UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,        TRUE,  TRUE,  0, FALSE, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "18.83 NULL Buffer UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.84 NULL 0 Bufferlen UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,  TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.85 0 Bufferlen UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.86 Small Bufferlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,     TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "18.87 Exact Bufferlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.88 Large Buffer UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPLARGE,  TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.89 Multi Buffer UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_MULTI,     TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.90 Switch Recv UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.91 Iterative Recv UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.92 Null Buffer Ptr UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.93 0 Buffer Count UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT, TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.94 NULL dwBytes UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        FALSE, TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.95 NULL flags UDP",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  FALSE, 0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.96 flags != 0 UDP",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  4, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.97 Callback != NULL UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.98 Not Bound NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "18.99 Not Connected NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.100 Connected NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.101 Second Receive NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SECOND,    TRUE,  TRUE,  0, TRUE,  0,                    FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "18.102 SD_RECEIVE Conn NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "18.103 SD_SEND Conn NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.104 SD_BOTH Conn NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "18.105 I/O NB UDP",               TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, OVERLAPPED_IO_RESULT, FALSE, 0,            0,                 FALSE },
    { "18.106 Event NB UDP",             TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "18.107 Event Event NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,        TRUE,  TRUE,  0, FALSE, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "18.108 NULL Buffer NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.109 NULL 0 Bufferlen NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,  TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.110 0 Bufferlen NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.111 Small Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,     TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "18.112 Exact Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.113 Large Buffer NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPLARGE,  TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.114 Multi Buffer NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_MULTI,     TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.115 Switch Recv NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.116 Iterative Recv NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    FALSE, 0,            0,                 FALSE },
    { "18.117 Null Buffer Ptr NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.118 0 Buffer Count NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT, TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.119 NULL dwBytes NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        FALSE, TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.120 NULL flags NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  FALSE, 0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.121 flags != 0 NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  4, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.122 Callback != NULL NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, 0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "18.123 Closed Socket TCP",        TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "18.124 Closed Socket UDP",        TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "18.125 Not Initialized",          FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, 0,                    FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define WSARecvTableCount (sizeof(WSARecvTable) / sizeof(WSARECV_TABLE))

NETSYNC_TYPE_THREAD  WSARecvTestSessionNt =
{
    1,
    WSARecvTableCount,
    L"xnetapi_nt.dll",
    "WSARecvTestServer"
};

NETSYNC_TYPE_THREAD  WSARecvTestSessionXbox =
{
    1,
    WSARecvTableCount,
    L"xnetapi_xbox.dll",
    "WSARecvTestServer"
};



// Callback routine

VOID CALLBACK WSARecvCompletionRoutine(IN DWORD  dwError, IN DWORD  cbTransferred, IN LPWSAOVERLAPPED  lpOverlapped, IN DWORD  dwFlags) { return; }



VOID
WSARecvTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests WSARecv - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // WSARecvRequest is the request sent to the server
    WSARECV_REQUEST        WSARecvRequest;

    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int                    iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL                   bNagle = FALSE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                   bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename is the remote address
    SOCKADDR_IN            remotename;

    // readfds is the set of sockets to check for a read condition
    fd_set                 readfds;
    // writefds is the set of sockets to check for a write condition
    fd_set                 writefds;
    // timeout is the timeout for select
    timeval                fdstimeout = { 1, 0 };

    // SendBuffer10 is the send buffer
    char                   SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                   SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBuffer10 is the recv buffer
    char                   RecvBuffer10[BUFFER_10_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                   RecvBufferLarge[BUFFER_LARGE_LEN + 1];
    // WSABuf is an array of send data structures
    WSABUF                 WSABuf[3];
    // dwBufferCount is the number of send data structures
    DWORD                  dwBufferCount;
    // nBufferlen is the total size of the data
    int                    nBufferlen;
    // dwFillBuffer is a counter to fill the buffers
    DWORD                  dwFillBuffer;
    // dwBytes is the number of bytes received
    DWORD                  dwBytes;
    // nRecvCount is a counter to enumerate each recv
    int                    nRecvCount;

    // dwFirstTime is the first tick count
    DWORD                  dwFirstTime;
    // dwSecondTime is the second tick count
    DWORD                  dwSecondTime;

    // WSARecvBufferTable is the test buffer table to use for iterative send
    PWSARECVBUFFER_TABLE   WSARecvBufferTable;
    // WSARecvBufferTableCount is the number of elements within the test buffer table
    size_t                 WSARecvBufferTableCount;
    // WSAOverlapped is the overlapped I/O structure
    WSAOVERLAPPED          WSAOverlapped;
    // dwFlags specifies the receive flags
    DWORD                  dwFlags;
    // dwTotalBytes specifies the total bytes
    DWORD                  dwTotalBytes;

    // dwReturnCode is the return code of WaitForSingleObject
    DWORD                  dwReturnCode;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "WSARecv v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_WSARecv+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_WSARecv-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = WSARecvTestSessionXbox;
    }
    else {
        NetsyncTypeSession = WSARecvTestSessionNt;
    }

    // Initialize the overlapped I/O structure
    ZeroMemory(&WSAOverlapped, sizeof(WSAOverlapped));
    WSAOverlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < WSARecvTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, WSARecvTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, WSARecvTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != WSARecvTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, WSARecvTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == WSARecvTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != WSARecvTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == WSARecvTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = WSARecvTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == WSARecvTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == WSARecvTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == WSARecvTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == WSARecvTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == WSARecvTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == WSARecvTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & WSARecvTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Set the send and receive timeout values to 5 sec
        if ((0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP && WSARecvTable[dwTableIndex].dwSocket))) {
            setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the socket to non-blocking mode
        if (TRUE == WSARecvTable[dwTableIndex].bNonblock) {
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);
            bNonblocking = TRUE;
        }
        else {
            bNonblocking = FALSE;
        }

        // Bind the socket
        if (TRUE == WSARecvTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if (TRUE == WSARecvTable[dwTableIndex].bListen) {
            listen(sSocket, SOMAXCONN);
        }

        if (0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) {
            WSARecvBufferTable = WSARecvBufferTcpTable;
            WSARecvBufferTableCount = WSARecvBufferTcpTableCount;
        }
        else {
            WSARecvBufferTable = WSARecvBufferUdpTable;
            WSARecvBufferTableCount = WSARecvBufferUdpTableCount;
        }

        if ((TRUE == WSARecvTable[dwTableIndex].bAccept) || (TRUE == WSARecvTable[dwTableIndex].bConnect) || (0 == WSARecvTable[dwTableIndex].iReturnCode)) {
            // Initialize the recv request
            WSARecvRequest.dwMessageId = WSARECV_REQUEST_MSG;
            if (0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) {
                WSARecvRequest.nSocketType = SOCK_STREAM;
            }
            else {
                WSARecvRequest.nSocketType = SOCK_DGRAM;
            }
            WSARecvRequest.Port = CurrentPort;
            WSARecvRequest.bServerAccept = WSARecvTable[dwTableIndex].bConnect;
            WSARecvRequest.bRemoteShutdown = WSARecvTable[dwTableIndex].bRemoteShutdown;
            WSARecvRequest.bRemoteClose = WSARecvTable[dwTableIndex].bRemoteClose;
            if (100 == WSARecvTable[dwTableIndex].nDataBuffers) {
                WSARecvRequest.nDataBuffers = WSARecvTable[dwTableIndex].nDataBuffers * WSARecvBufferTableCount;
            }
            else {
                WSARecvRequest.nDataBuffers = ((0 == WSARecvTable[dwTableIndex].iReturnCode) || (WSAEMSGSIZE == WSARecvTable[dwTableIndex].iLastError)) ? WSARecvTable[dwTableIndex].nDataBuffers : 0;
            }

            WSARecvRequest.nBufferlen = BUFFER_10_LEN;
            if (BUFFER_TCPLARGE == WSARecvTable[dwTableIndex].dwBuffer) {
                WSARecvRequest.nBufferlen = BUFFER_TCPLARGE_LEN;
            }
            else if (BUFFER_UDPLARGE == WSARecvTable[dwTableIndex].dwBuffer) {
                WSARecvRequest.nBufferlen = BUFFER_UDPLARGE_LEN;
            }
            else if ((BUFFER_NULL == WSARecvTable[dwTableIndex].dwBuffer) || ((0 != (SOCKET_UDP & WSARecvTable[dwTableIndex].dwSocket)) && ((BUFFER_NULLZERO == WSARecvTable[dwTableIndex].dwBuffer) || (BUFFER_ZERO == WSARecvTable[dwTableIndex].dwBuffer)))) {
                WSARecvRequest.nBufferlen = 0;
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvRequest), (char *) &WSARecvRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == WSARecvTable[dwTableIndex].bConnect) {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = NetsyncInAddr;
                remotename.sin_port = htons(CurrentPort);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));

                if (0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&writefds);
                    FD_SET(sSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }
            }
            else if (TRUE == WSARecvTable[dwTableIndex].bAccept) {
                if (0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&readfds);
                    FD_SET(sSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);
                }

                // Accept the socket
                nsSocket = accept(sSocket, NULL, NULL);
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvRequest), (char *) &WSARecvRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == WSARecvTable[dwTableIndex].bRemoteShutdown) {
                if (TRUE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (0 != recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBuffer10, sizeof(RecvBuffer10), 0));

                if (TRUE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }

            if (TRUE == WSARecvTable[dwTableIndex].bRemoteClose) {
                if (TRUE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0));

                if (TRUE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }
        }

        // Shutdown the connection
        if (TRUE == WSARecvTable[dwTableIndex].bShutdown) {
            shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSARecvTable[dwTableIndex].nShutdown);
        }

        // Zero the receive buffer
        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

        // Initialize the buffers
        sprintf(SendBuffer10, "%05d%05d", 1, 1);
        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
        }

        dwBufferCount = 1;
        if (BUFFER_10 == WSARecvTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = BUFFER_10_LEN;
        }
        else if (BUFFER_NULL == WSARecvTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = NULL;

            nBufferlen = 0;
        }
        else if (BUFFER_NULLZERO == WSARecvTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = 0;
            WSABuf[0].buf = NULL;

            nBufferlen = 0;
        }
        else if (BUFFER_ZERO == WSARecvTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = 0;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = 0;
        }
        else if (BUFFER_ZEROCOUNT == WSARecvTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = 0;
            WSABuf[0].buf = RecvBufferLarge;

            dwBufferCount = 0;
            nBufferlen = 0;
        }
        else if (BUFFER_SMALL == WSARecvTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN - 1;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = BUFFER_10_LEN - 1;
        }
        else if (BUFFER_TCPLARGE == WSARecvTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_TCPLARGE_LEN;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = BUFFER_TCPLARGE_LEN;
        }
        else if (BUFFER_UDPLARGE == WSARecvTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_UDPLARGE_LEN;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = BUFFER_UDPLARGE_LEN;
        }
        else if (BUFFER_UDPTOOLARGE == WSARecvTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_UDPLARGE_LEN + 1;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = 0;
        }
        else if (BUFFER_MULTI == WSARecvTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = RecvBufferLarge;

            WSABuf[1].len = BUFFER_10_LEN;
            WSABuf[1].buf = &RecvBufferLarge[BUFFER_10_LEN];

            WSABuf[2].len = BUFFER_10_LEN;
            WSABuf[2].buf = &RecvBufferLarge[BUFFER_10_LEN + BUFFER_10_LEN];

            dwBufferCount = 3;
            nBufferlen = BUFFER_10_LEN + BUFFER_10_LEN + BUFFER_10_LEN;
        }
        else if (BUFFER_SECOND == WSARecvTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN / 2;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = BUFFER_10_LEN;
        }

        // Initialize the flags
        dwFlags = WSARecvTable[dwTableIndex].dwFlags;

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & WSARecvTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        // Get the current tick count
        dwFirstTime = GetTickCount();

        __try {
            // Call WSARecv
            iReturnCode = WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (BUFFER_NONE != WSARecvTable[dwTableIndex].dwBuffer) ? WSABuf : NULL, (BUFFER_NONE != WSARecvTable[dwTableIndex].dwBuffer) ? dwBufferCount : 0, (TRUE == WSARecvTable[dwTableIndex].bBytesRecv) ? &dwBytes : NULL, (TRUE == WSARecvTable[dwTableIndex].bFlags) ? &dwFlags : NULL, (0 == WSARecvTable[dwTableIndex].nOverlapped) ? NULL : &WSAOverlapped, (FALSE == WSARecvTable[dwTableIndex].bCompletionRoutine) ? NULL : WSARecvCompletionRoutine);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == WSARecvTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "WSARecv RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "WSARecv caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (0 != WSARecvTable[dwTableIndex].nOverlapped) {
                if (-1 != WSARecvTable[dwTableIndex].nDataBuffers) {
                    if (SOCKET_ERROR != iReturnCode) {
                        bTestPassed = FALSE;
                        WSARecvRequest.dwMessageId = WSARECV_CANCEL_MSG;
                        WSARecvRequest.nDataBuffers = 0;
                    }
                    else {
                        // Get the last error code
                        iLastError = WSAGetLastError();

                        if (iLastError != WSA_IO_PENDING) {
                            xLog(hLog, XLL_FAIL, "WSARecv iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, iLastError);
                            bTestPassed = FALSE;
                        }
                        else {
                            if (OVERLAPPED_IO_EVENT == WSARecvTable[dwTableIndex].nOverlapped) {
                                // Wait on the overlapped I/O event
                                WaitForSingleObject(WSAOverlapped.hEvent, INFINITE);
                            }
                            // Get the overlapped I/O result
                            if (FALSE == WSAGetOverlappedResult((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSAOverlapped, &dwBytes, (OVERLAPPED_IO_RESULT == WSARecvTable[dwTableIndex].nOverlapped) ? TRUE : FALSE, &dwFlags)) {
                                xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            }
                            else {
                                iReturnCode = 0;
                            }
                        }
                    }
                }
                else {
                    if (SOCKET_ERROR == iReturnCode) {
                        bTestPassed = FALSE;
                        WSARecvRequest.dwMessageId = WSARECV_CANCEL_MSG;
                        WSARecvRequest.nDataBuffers = 0;
                    }
                    else {
                        dwReturnCode = WaitForSingleObject(WSAOverlapped.hEvent, 0);
                        if (WAIT_OBJECT_0 != dwReturnCode) {
                            xLog(hLog, XLL_FAIL, "WaitForSingleObject - EXPECTED: %u; RECEIVED: %u", WAIT_OBJECT_0, dwReturnCode);
                        }

                        // Get the overlapped I/O result
                        if (FALSE == WSAGetOverlappedResult((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSAOverlapped, &dwBytes, (OVERLAPPED_IO_RESULT == WSARecvTable[dwTableIndex].nOverlapped) ? TRUE : FALSE, &dwFlags)) {
                            xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        }
                        else {
                            iReturnCode = 0;
                        }

                        // Spoof the sleep time
                        Sleep(SLEEP_MEAN_TIME);
                    }
                }
            }
            else if ((TRUE == bNonblocking) && (FALSE == WSARecvTable[dwTableIndex].bRemoteShutdown) && ((0 == WSARecvTable[dwTableIndex].iReturnCode) || (WSAEMSGSIZE == WSARecvTable[dwTableIndex].iLastError))) {
                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "WSARecv returned non-SOCKET_ERROR");
                    bTestPassed = FALSE;
                }
                else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                    xLog(hLog, XLL_FAIL, "WSARecv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
                    bTestPassed = FALSE;
                }
                else {
                    xLog(hLog, XLL_PASS, "WSARecv iLastError - OUT: %u", WSAGetLastError());

                    FD_ZERO(&readfds);
                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);

                    // Call WSARecv
                    iReturnCode = WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL);
                }
            }
            
            // Get the current tick count
            dwSecondTime = GetTickCount();

            if (TRUE == WSARecvTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "WSARecv did not RIP");
            }

            if (TRUE == WSARecvTable[dwTableIndex].bRemoteShutdown) {
                if (SOCKET_ERROR == iReturnCode) {
                    xLog(hLog, XLL_FAIL, "WSARecv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                }
                else if (0 != dwBytes) {
                    xLog(hLog, XLL_FAIL, "WSARecv dwBytes - EXPECTED: %u; RECEIVED: %u", 0, dwBytes);
                }
                else {
                    xLog(hLog, XLL_PASS, "WSARecv succeeded");
                }
            }
            else if (WSAEMSGSIZE == WSARecvTable[dwTableIndex].iLastError) {
                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "WSARecv returned non-SOCKET_ERROR");
                }
                else if (WSAEMSGSIZE != WSAGetLastError()) {
                    xLog(hLog, XLL_FAIL, "WSARecv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEMSGSIZE, WSAGetLastError());
                }
                else {
                    if (MSG_PARTIAL != dwFlags) {
                        xLog(hLog, XLL_FAIL, "flags != MSG_PARTIAL");
                        bTestPassed = FALSE;
                    }

                    dwFlags = 0;
                    iReturnCode = WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL);

                    if (SOCKET_ERROR != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "WSARecv returned non-SOCKET_ERROR");
                        bTestPassed = FALSE;
                    }
                    else if (((TRUE == bNonblocking) && (WSAEWOULDBLOCK != WSAGetLastError())) || ((FALSE == bNonblocking) && (WSAETIMEDOUT != WSAGetLastError()))) {
                        xLog(hLog, XLL_FAIL, "WSARecv iLastError - EXPECTED: %u; RECEIVED: %u", (TRUE == bNonblocking) ? WSAEWOULDBLOCK : WSAETIMEDOUT, WSAGetLastError());
                        bTestPassed = FALSE;
                    }

                    if (TRUE == bTestPassed) {
                        xLog(hLog, XLL_PASS, "WSARecv succeeded");
                    }
                }
            }
            else if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == WSARecvTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != WSARecvTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "WSARecv iLastError - EXPECTED: %u; RECEIVED: %u", WSARecvTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "WSARecv iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSARecv returned SOCKET_ERROR - ec = %u", WSAGetLastError());

                if (1 < WSARecvRequest.nDataBuffers) {
                    // Send the WSARecv cancel
                    WSARecvRequest.dwMessageId = WSARECV_CANCEL_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvRequest), (char *) &WSARecvRequest);
                }
            }
            else if (SOCKET_ERROR == WSARecvTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSARecv returned non-SOCKET_ERROR");
            }
            else {
                dwTotalBytes = dwBytes;

                if (((dwSecondTime - dwFirstTime) < SLEEP_LOW_TIME) || ((dwSecondTime - dwFirstTime) > SLEEP_HIGH_TIME)) {
                    xLog(hLog, XLL_FAIL, "WSARecv nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME, dwSecondTime - dwFirstTime);
                    bTestPassed = FALSE;
                }

                if (0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) {
                    if (TRUE == WSARecvTable[dwTableIndex].bSecondRecv) {
                        if (WSABuf[0].len != dwBytes) {
                            xLog(hLog, XLL_FAIL, "WSARecv return value - EXPECTED: %d; RECEIVED: %d", WSABuf[0].len, dwBytes);
                            bTestPassed = FALSE;
                        }
                        else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, WSABuf[0].len)) {
                            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                            bTestPassed = FALSE;
                        }

                        WSABuf[0].buf = &RecvBufferLarge[dwTotalBytes];
                        WSABuf[0].len = nBufferlen - dwTotalBytes;
                        iReturnCode = WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL);
                        WSABuf[0].buf = RecvBufferLarge;
                        WSABuf[0].len = BUFFER_10_LEN / 2;

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "WSARecv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            if (WSABuf[0].len != dwBytes) {
                                xLog(hLog, XLL_FAIL, "WSARecv return value - EXPECTED: %d; RECEIVED: %d", WSABuf[0].len, dwBytes);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(&SendBufferLarge[dwTotalBytes], &RecvBufferLarge[dwTotalBytes], WSABuf[0].len)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }

                            dwTotalBytes += dwBytes;
                        }
                    }

                    if (BUFFER_10_LEN <= nBufferlen) {
                        do {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                            iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                            if (1 == iReturnCode) {
                                WSABuf[0].buf = &RecvBufferLarge[dwTotalBytes];
                                WSABuf[0].len = nBufferlen - dwTotalBytes;
                                if (SOCKET_ERROR != WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL)) {
                                    dwTotalBytes += dwBytes;
                                }
                                WSABuf[0].buf = RecvBufferLarge;
                                WSABuf[0].len = nBufferlen;
                            }
                        } while (0 != iReturnCode);
                    }
                }

                if (nBufferlen != dwTotalBytes) {
                    xLog(hLog, XLL_FAIL, "WSARecv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwTotalBytes);
                    bTestPassed = FALSE;
                }
                else {
                    if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                        xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                        bTestPassed = FALSE;
                    }
                }

                if (3 == WSARecvTable[dwTableIndex].nDataBuffers) {
                    // Zero the receive buffer
                    ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvRequest), (char *) &WSARecvRequest);

                    if (WSARECV_CANCEL_MSG != WSARecvRequest.dwMessageId) {
                        // Wait for the read complete
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);

                        // Switch the blocking mode
                        Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                        ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                        bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                        iReturnCode = WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL);

                        if (TRUE == bNonblocking) {
                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "WSARecv returned non-SOCKET_ERROR");
                                bTestPassed = FALSE;
                            }
                            else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "WSARecv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "WSARecv iLastError - OUT: %u", WSAGetLastError());

                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);

                                // Call WSARecv
                                iReturnCode = WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL);
                            }
                        }

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                            WSARecvRequest.dwMessageId = WSARECV_CANCEL_MSG;
                        }
                        else {
                            dwTotalBytes = dwBytes;

                            if (0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) {
                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        WSABuf[0].buf = &RecvBufferLarge[dwTotalBytes];
                                        WSABuf[0].len = nBufferlen - dwTotalBytes;
                                        if (SOCKET_ERROR != WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL)) {
                                            dwTotalBytes += dwBytes;
                                        }
                                        WSABuf[0].buf = RecvBufferLarge;
                                        WSABuf[0].len = nBufferlen;
                                    }
                                } while (0 != iReturnCode);
                            }

                            if (nBufferlen != dwTotalBytes) {
                                xLog(hLog, XLL_FAIL, "WSARecv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwTotalBytes);
                                bTestPassed = FALSE;
                            }
                            else {
                                if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }

                            WSARecvRequest.dwMessageId = WSARECV_REQUEST_MSG;
                        }

                        // Zero the receive buffer
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                        // Initialize the buffers
                        sprintf(SendBuffer10, "%05d%05d", 3, 3);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                        }

                        // Send the read request
                        NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvRequest), (char *) &WSARecvRequest);

                        if (WSARECV_CANCEL_MSG != WSARecvRequest.dwMessageId) {
                            // Wait for the read complete
                            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                            NetsyncFreeMessage(pMessage);

                            // Switch the blocking mode
                            Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                            bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                            // Call WSARecv
                            iReturnCode = WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL);

                            if (TRUE == bNonblocking) {
                                if (SOCKET_ERROR != iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "WSARecv returned non-SOCKET_ERROR");
                                    bTestPassed = FALSE;
                                }
                                else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                                    xLog(hLog, XLL_FAIL, "WSARecv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else {
                                    xLog(hLog, XLL_PASS, "WSARecv iLastError - OUT: %u", WSAGetLastError());

                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                    select(0, &readfds, NULL, NULL, NULL);

                                    // Call WSARecv
                                    iReturnCode = WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL);
                                }
                            }

                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                                WSARecvRequest.dwMessageId = WSARECV_CANCEL_MSG;
                            }
                            else {
                                dwTotalBytes = dwBytes;

                                if (0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) {
                                    do {
                                        FD_ZERO(&readfds);
                                        FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                        iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                        if (1 == iReturnCode) {
                                            WSABuf[0].buf = &RecvBufferLarge[dwTotalBytes];
                                            WSABuf[0].len = nBufferlen - dwTotalBytes;
                                            if (SOCKET_ERROR != WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL)) {
                                                dwTotalBytes += dwBytes;
                                            }
                                            WSABuf[0].buf = RecvBufferLarge;
                                            WSABuf[0].len = nBufferlen;
                                        }
                                    } while (0 != iReturnCode);
                                }

                                if (nBufferlen != dwTotalBytes) {
                                    xLog(hLog, XLL_FAIL, "WSARecv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwTotalBytes);
                                    bTestPassed = FALSE;
                                }
                                else {
                                    if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                        xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                        bTestPassed = FALSE;
                                    }
                                }
                            }
                        }
                    }
                }
                else if (100 == WSARecvTable[dwTableIndex].nDataBuffers) {
                    for (nRecvCount = 0; nRecvCount < (int) (WSARecvTable[dwTableIndex].nDataBuffers * WSARecvBufferTableCount); nRecvCount++) {
                        // Zero the receive buffer
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                        // Initialize the buffers
                        sprintf(SendBuffer10, "%05d%05d", 2 + nRecvCount, 2 + nRecvCount);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                        }

                        xLog(hLog, XLL_INFO, "Iteration %d", nRecvCount);

                        dwBufferCount = 1;
                        if (BUFFER_10 == WSARecvTable[dwTableIndex].dwBuffer) {
                            WSABuf[0].len = BUFFER_10_LEN;
                            WSABuf[0].buf = RecvBufferLarge;

                            nBufferlen = BUFFER_10_LEN;
                        }
                        else if (BUFFER_NULLZERO == WSARecvTable[dwTableIndex].dwBuffer) {
                            WSABuf[0].len = 0;
                            WSABuf[0].buf = NULL;

                            nBufferlen = 0;
                        }
                        else if (BUFFER_TCPLARGE == WSARecvTable[dwTableIndex].dwBuffer) {
                            WSABuf[0].len = BUFFER_TCPLARGE_LEN;
                            WSABuf[0].buf = RecvBufferLarge;

                            nBufferlen = BUFFER_TCPLARGE_LEN;
                        }
                        else if (BUFFER_UDPLARGE == WSARecvTable[dwTableIndex].dwBuffer) {
                            WSABuf[0].len = BUFFER_UDPLARGE_LEN;
                            WSABuf[0].buf = RecvBufferLarge;

                            nBufferlen = BUFFER_UDPLARGE_LEN;
                        }

                        // Send the WSARecv request
                        WSARecvRequest.nBufferlen = nBufferlen;
                        NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvRequest), (char *) &WSARecvRequest);

                        if (WSARECV_CANCEL_MSG == WSARecvRequest.dwMessageId) {
                            break;
                        }

                        // Wait for the read complete
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);

                        if ((0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) && (0 == nBufferlen)) {
                            iReturnCode = 0;
                            dwBytes = 0;
                        }
                        else {
                            if (TRUE == bNonblocking) {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);
                            }

                            // Call WSARecv
                            iReturnCode = WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL);
                        }

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "WSARecv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            WSARecvRequest.dwMessageId = WSARECV_CANCEL_MSG;
                            bTestPassed = FALSE;
                        }
                        else {
                            dwTotalBytes = dwBytes;

                            if (0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) {
                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        WSABuf[0].buf = &RecvBufferLarge[dwTotalBytes];
                                        WSABuf[0].len = nBufferlen - dwTotalBytes;
                                        if (SOCKET_ERROR != WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL)) {
                                            dwTotalBytes += dwBytes;
                                        }
                                        WSABuf[0].buf = RecvBufferLarge;
                                        WSABuf[0].len = nBufferlen;
                                    }
                                } while (0 != iReturnCode);
                            }

                            if (nBufferlen != dwTotalBytes) {
                                xLog(hLog, XLL_FAIL, "WSARecv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwTotalBytes);
                                bTestPassed = FALSE;
                            }
                            else {
                                if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "WSARecv succeeded");
                }
            }
        }

        // Switch the blocking mode
        if (WSARecvTable[dwTableIndex].bNonblock != bNonblocking) {
            Nonblock = (TRUE == WSARecvTable[dwTableIndex].bNonblock) ? 1 : 0;
            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
            bNonblocking = WSARecvTable[dwTableIndex].bNonblock;
        }

        if ((TRUE == WSARecvTable[dwTableIndex].bAccept) || (TRUE == WSARecvTable[dwTableIndex].bConnect) || (0 == WSARecvTable[dwTableIndex].iReturnCode)) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvRequest), (char *) &WSARecvRequest);
        }

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & WSARecvTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & WSARecvTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & WSARecvTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    CloseHandle(WSAOverlapped.hEvent);

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
WSARecvTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests recv - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long            FromInAddr;
    // dwMessageType is the type of received message
    DWORD             dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD             dwMessageSize;
    // pMessage is a pointer to the received message
    char              *pMessage;
    // WSARecvRequest is the request
    WSARECV_REQUEST   WSARecvRequest;
    // WSARecvComplete is the result
    WSARECV_COMPLETE  WSARecvComplete;

    // sSocket is the socket descriptor
    SOCKET            sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET            nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int               iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL              bNagle = FALSE;

    // localname is the local address
    SOCKADDR_IN       localname;
    // remotename is the remote address
    SOCKADDR_IN       remotename;

    // SendBuffer10 is the send buffer
    char              SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char              SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // dwFillBuffer is a counter to fill the buffers
    DWORD             dwFillBuffer;
    // nSendCount is a counter to enumerate each send
    int               nSendCount;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&WSARecvRequest, pMessage, sizeof(WSARecvRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, WSARecvRequest.nSocketType, 0);

        // Set the send and receive timeout values to 5 sec
        setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

        if (SOCK_STREAM == WSARecvRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(WSARecvRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if ((SOCK_STREAM == WSARecvRequest.nSocketType) && (TRUE == WSARecvRequest.bServerAccept)) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(WSARecvRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        WSARecvComplete.dwMessageId = WSARECV_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSARecvComplete), (char *) &WSARecvComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if ((SOCK_STREAM == WSARecvRequest.nSocketType) && (TRUE == WSARecvRequest.bServerAccept)) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        if (TRUE == WSARecvRequest.bRemoteShutdown) {
            // Shutdown the sockets
            if (INVALID_SOCKET != nsSocket) {
                shutdown(nsSocket, SD_BOTH);
            }

            if (INVALID_SOCKET != sSocket) {
                shutdown(sSocket, SD_BOTH);
            }
        }

        if (TRUE == WSARecvRequest.bRemoteClose) {
            // Close the sockets
            if (INVALID_SOCKET != nsSocket) {
                shutdown(nsSocket, SD_BOTH);
                closesocket(nsSocket);
                nsSocket = INVALID_SOCKET;
            }

            if (INVALID_SOCKET != sSocket) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
                sSocket = INVALID_SOCKET;
            }
        }

        if (-1 == WSARecvRequest.nDataBuffers) {
            // Initialize the buffer
            sprintf(SendBuffer10, "%05d%05d", 1, 1);
            for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
            }

            // Send the buffer
            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, WSARecvRequest.nBufferlen, 0);
        }

        // Send the complete
        WSARecvComplete.dwMessageId = WSARECV_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSARecvComplete), (char *) &WSARecvComplete);

        if (0 < WSARecvRequest.nDataBuffers) {
            // Sleep
            Sleep(SLEEP_MIDLOW_TIME);

            // Initialize the buffer
            sprintf(SendBuffer10, "%05d%05d", 1, 1);
            for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
            }

            // Send the buffer
            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, WSARecvRequest.nBufferlen, 0);

            if (3 == WSARecvRequest.nDataBuffers) {
                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                
                if (WSARECV_CANCEL_MSG != ((PWSARECV_REQUEST) pMessage)->dwMessageId) {
                    // Send the complete
                    WSARecvComplete.dwMessageId = WSARECV_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSARecvComplete), (char *) &WSARecvComplete);

                    // Sleep
                    Sleep(SLEEP_MIDLOW_TIME);

                    // Initialize the buffer
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                    }

                    // Send the buffer
                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, WSARecvRequest.nBufferlen, 0);

                    NetsyncFreeMessage(pMessage);

                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                    if (WSARECV_CANCEL_MSG != ((PWSARECV_REQUEST) pMessage)->dwMessageId) {
                        // Send the complete
                        WSARecvComplete.dwMessageId = WSARECV_COMPLETE_MSG;
                        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSARecvComplete), (char *) &WSARecvComplete);

                        // Sleep
                        Sleep(SLEEP_MIDLOW_TIME);

                        // Initialize the buffer
                        sprintf(SendBuffer10, "%05d%05d", 3, 3);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                        }

                        // Send the buffer
                        send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, WSARecvRequest.nBufferlen, 0);
                    }
                }

                NetsyncFreeMessage(pMessage);
            }
            else if (100 <= WSARecvRequest.nDataBuffers) {
                for (nSendCount = 0; nSendCount < WSARecvRequest.nDataBuffers; nSendCount++) {
                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                    if (WSARECV_CANCEL_MSG == ((PWSARECV_REQUEST) pMessage)->dwMessageId) {
                        NetsyncFreeMessage(pMessage);
                        break;
                    }

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 2 + nSendCount, 2 + nSendCount);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                    }

                    // Send the buffer
                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, ((PWSARECV_REQUEST) pMessage)->nBufferlen, 0);

                    NetsyncFreeMessage(pMessage);

                    // Send the complete
                    WSARecvComplete.dwMessageId = WSARECV_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSARecvComplete), (char *) &WSARecvComplete);
                }
            }
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\wsasendto.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  wsasendto.c

Abstract:

  This modules tests wsasendto

Author:

  Steven Kehrli (steveke) 1-Dec-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// WSASendTo messages

#define WSASENDTO_REQUEST_MSG   NETSYNC_MSG_USER + 160 + 1
#define WSASENDTO_CANCEL_MSG    NETSYNC_MSG_USER + 160 + 2
#define WSASENDTO_COMPLETE_MSG  NETSYNC_MSG_USER + 160 + 3

typedef struct _WSASENDTO_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  ReceivePort;
    u_short  SendPort;
    BOOL     bServerAccept;
    BOOL     bFillQueue;
    INT      nQueueLen;
    BOOL     bRemoteClose;
    int      nDataBuffers;
    int      nBufferlen;
} WSASENDTO_REQUEST, *PWSASENDTO_REQUEST;

typedef struct _WSASENDTO_COMPLETE {
    DWORD    dwMessageId;
} WSASENDTO_COMPLETE, *PWSASENDTO_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define NAME_ANY              0
#define NAME_ANYADDR          1
#define NAME_ANYPORT          2
#define NAME_LOCAL            3
#define NAME_LOOPBACK         4
#define NAME_BROADCAST        5
#define NAME_MULTICAST        6
#define NAME_UNAVAIL          7
#define NAME_BAD              8
#define NAME_NULL             9
#define NAME_REMOTE_1        10
#define NAME_REMOTE_2        11

#define BUFFER_10             0
#define BUFFER_LARGE          1
#define BUFFER_NULL           2
#define BUFFER_NULLZERO       3
#define BUFFER_ZERO           4
#define BUFFER_ZEROCOUNT      5
#define BUFFER_SMALL          6
#define BUFFER_TCPLARGE       7
#define BUFFER_UDPLARGE       8
#define BUFFER_UDPTOOLARGE    9
#define BUFFER_TCPMULTI      10
#define BUFFER_UDPMULTI      11
#define BUFFER_NONE          12

#define OVERLAPPED_IO_RESULT  1
#define OVERLAPPED_IO_EVENT   2



typedef struct WSASENDTOBUFFER_TABLE {
    DWORD  dwBuffer;
} WSASENDTOBUFFER_TABLE, *PWSASENDTOBUFFER_TABLE;

WSASENDTOBUFFER_TABLE WSASendToBufferTcpTable[] = { { BUFFER_10        },
                                                    { BUFFER_NULLZERO  },
                                                    { BUFFER_TCPLARGE  },
                                                    { BUFFER_TCPMULTI  } };

#define WSASendToBufferTcpTableCount  (sizeof(WSASendToBufferTcpTable) / sizeof(WSASENDTOBUFFER_TABLE));

WSASENDTOBUFFER_TABLE WSASendToBufferUdpTable[] = { { BUFFER_10        },
                                                    { BUFFER_NULLZERO  },
                                                    { BUFFER_UDPLARGE  },
                                                    { BUFFER_UDPMULTI  } };
#define WSASendToBufferUdpTableCount  (sizeof(WSASendToBufferUdpTable) / sizeof(WSASENDTOBUFFER_TABLE));



typedef struct WSASENDTO_TABLE {
    CHAR           szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL           bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL           bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD          dwSocket;                                // dwSocket indicates the socket to be created
    BOOL           bNonblock;                               // bNonblock indicates if the socket is to be set as non-blocking for the send
    BOOL           bBind;                                   // bBind indicates if the socket is to be bound
    BOOL           bListen;                                 // bListen indicates if the socket is to be placed in the listening state
    BOOL           bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL           bConnect;                                // bConnect indicates if the socket is connected
    BOOL           bFillQueue;                              // bFillQueue indicates if the buffer should be filled
    BOOL           bRemoteClose;                            // bRemoteClose indicates if the remote closes the connection
    BOOL           bShutdown;                               // bShutdown indicates if the connection is shutdown
    int            nShutdown;                               // nShutdown indicates how the connection is shutdown
    int            nDataBuffers;                            // nDataBuffers indicates the number of data buffers to be sent
    DWORD          dwBuffer;                                // dwBuffer specifies the send data structure
    int            nFlags;                                  // nFlags specifies the WSASendTo flags
    DWORD          dwName;                                  // dwName indicates the address
    int            namelen;                                 // namelen is the length of the address buffer
    int            nOverlapped;                             // nOverlapped specifies if overlapped I/O is used
    BOOL           bCompletionRoutine;                      // bCompletionRoutine specifies if completion routine is used
    int            iReturnCode;                             // iReturnCode is the return code of WSASendTo
    int            iLastError;                              // iLastError is the error code if the operation failed
    BOOL           bRIP;                                    // Specifies a RIP test case
} WSASENDTO_TABLE, *PWSASENDTO_TABLE;

static WSASENDTO_TABLE WSASendToTable[] =
{
    { "16.1 Not Initialized",            FALSE, FALSE, SOCKET_INVALID_SOCKET,         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "16.2 s = INT_MIN",                TRUE,  TRUE,  SOCKET_INT_MIN,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "16.3 s = -1",                     TRUE,  TRUE,  SOCKET_NEG_ONE,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "16.4 s = 0",                      TRUE,  TRUE,  SOCKET_ZERO,                   FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "16.5 s = INT_MAX",                TRUE,  TRUE,  SOCKET_INT_MAX,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "16.6 s = INVALID_SOCKET",         TRUE,  TRUE,  SOCKET_INVALID_SOCKET,         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "16.7 Not Bound TCP",              TRUE,  TRUE,  SOCKET_TCP,                    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "16.8 Listening TCP",              TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "16.9 Accepted TCP",               TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.10 Connected TCP",             TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.11 Fill Queue TCP",            TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.12 Fill Queue I/O TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       OVERLAPPED_IO_RESULT, FALSE, 0,            0,                 FALSE },
    { "16.13 Fill Queue Event TCP",      TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "16.14 Event Event TCP",           TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,          0, NAME_NULL,      0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "16.15 SD_RECEIVE Accept TCP",     TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.16 SD_SEND Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "16.17 SD_BOTH Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "16.18 SD_RECEIVE Connect TCP",    TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.19 SD_SEND Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "16.20 SD_BOTH Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "16.21 Close Accept TCP",          TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "16.22 Close Connect TCP",         TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "16.23 NULL Buffer TCP",           TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.24 NULL 0 Bufferlen TCP",      TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,    0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.25 0 Bufferlen TCP",           TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,        0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.26 Small Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,       0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.27 Exact Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.28 Large Buffer TCP",          TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_TCPLARGE,    0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.29 Multi Buffer TCP",          TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_TCPMULTI,    0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.30 Switch Send TCP",           TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.31 Iterative Send TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.32 NULL Buffer Ptr TCP",       TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.33 0 Buffer Count TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT,   0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.34 flags != 0 TCP",            TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          4, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.35 Same addr TCP",             TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.36 Different addr TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_2,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.37 Broadcast addr TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_BROADCAST, sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.38 Multicast addr TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_MULTICAST, sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.39 Bad addr TCP",              TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_BAD,       sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "16.40 Zero addr TCP",             TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_ANY,       sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.41 Any addr TCP",              TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.42 Zero port addr TCP",        TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_ANYPORT,   sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.43 Large addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) + 1, 0,                    FALSE, 0,            0,                 FALSE },
    { "16.44 Exact addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.45 Small addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) - 1, 0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "16.46 Zero addrlen TCP",          TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  0,                       0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "16.47 Neg addrlen TCP",           TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  -1,                      0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "16.48 Callback != NULL TCP",      TRUE,  TRUE,  SOCKET_TCP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.49 Not Bound NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "16.50 Listening NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "16.51 Accepted NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.52 Connected NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.53 Fill Queue NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.54 Fill Queue I/O NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       OVERLAPPED_IO_RESULT, FALSE, 0,            0,                 FALSE },
    { "16.55 Fill Queue Event NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "16.56 Event Event NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,          0, NAME_NULL,      0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "16.57 SD_RECEIVE Accept NB TCP",  TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.58 SD_SEND Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "16.59 SD_BOTH Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "16.60 SD_RECEIVE Connect NB TCP", TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.61 SD_SEND Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "16.62 SD_BOTH Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "16.63 Close Accept NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "16.64 Close Connect NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "16.65 NULL Buffer NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.66 NULL 0 Bufferlen NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,    0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.67 0 Bufferlen NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,        0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.68 Small Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,       0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.69 Exact Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.70 Large Buffer NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_TCPLARGE,    0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.71 Multi Buffer NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_TCPMULTI,    0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.72 Switch Send NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.73 Iterative Send NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.74 NULL Buffer Ptr NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.75 0 Buffer Count NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT,   0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.76 flags != 0 NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          4, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.77 Same addr NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.78 Different addr NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_2,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.79 Broadcast addr NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_BROADCAST, sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.80 Multicast addr NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_MULTICAST, sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.81 Bad addr NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_BAD,       sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "16.82 Zero addr NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_ANY,       sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.83 Any addr NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.84 Zero port addr NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_ANYPORT,   sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.85 Large addrlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) + 1, 0,                    FALSE, 0,            0,                 FALSE },
    { "16.86 Exact addrlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.87 Small addrlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) - 1, 0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "16.88 Zero addrlen NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  0,                       0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "16.89 Neg addrlen NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  -1,                      0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "16.90 Callback != NULL NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.91 Not Bound UDP",             TRUE,  TRUE,  SOCKET_UDP,                    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "16.92 Not Connected UDP",         TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "16.93 Connected UDP",             TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.94 Event Event UDP",           TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,          0, NAME_NULL,      0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "16.95 SD_RECEIVE Conn UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.96 SD_SEND Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "16.97 SD_BOTH Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "16.98 NULL Buffer UDP",           TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.99 NULL 0 Bufferlen UDP",      TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,    0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.100 0 Bufferlen UDP",          TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,        0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.101 Small Bufferlen UDP",      TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,       0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.102 Exact Bufferlen UDP",      TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.103 Large Buffer UDP",         TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPLARGE,    0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.104 Too Large Buffer UDP",     TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPTOOLARGE, 0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "16.105 Multi Buffer UDP",         TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPMULTI,    0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.106 Switch Send UDP",          TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.107 Iterative Send UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.108 NULL Buffer Ptr UDP",      TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.109 0 Buffer Count UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT,   0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.110 flags != 0 UDP",           TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          4, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.111 Not Bound Addr UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.112 Bound Addr UDP",           TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.113 Same addr UDP",            TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.114 Different addr UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_2,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.115 Broadcast addr UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_BROADCAST, sizeof(SOCKADDR_IN),     0,                    FALSE, SOCKET_ERROR, WSAEACCES,         FALSE },
    { "16.116 Broadcast enabled UDP",    TRUE,  TRUE,  SOCKET_UDP | SOCKET_BROADCAST, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_BROADCAST, sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.117 Multicast addr UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_MULTICAST, sizeof(SOCKADDR_IN),     0,                    FALSE, SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "16.118 Bad addr UDP",             TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_BAD,       sizeof(SOCKADDR_IN),     0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.119 Zero addr UDP",            TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_ANY,       sizeof(SOCKADDR_IN),     0,                    FALSE, SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "16.120 Any addr UDP",             TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     0,                    FALSE, SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "16.121 Zero port addr UDP",       TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_ANYPORT,   sizeof(SOCKADDR_IN),     0,                    FALSE, SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "16.122 Large addrlen UDP",        TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) + 1, 0,                    FALSE, 0,            0,                 FALSE },
    { "16.123 Exact addrlen UDP",        TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.124 Small addrlen UDP",        TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) - 1, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.125 Zero addrlen UDP",         TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.126 Neg addrlen UDP",          TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  -1,                      0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.127 Callback != NULL UDP",     TRUE,  TRUE,  SOCKET_UDP,                    FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.128 Not Bound NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "16.129 Not Connected NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "16.130 Connected NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.131 Event Event NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,          0, NAME_NULL,      0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "16.132 SD_RECEIVE Conn NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.133 SD_SEND Conn NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "16.134 SD_BOTH Conn NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "16.135 NULL Buffer NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.136 NULL 0 Bufferlen NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,    0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.137 0 Bufferlen NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,        0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.138 Small Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,       0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.139 Exact Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.140 Large Buffer NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPLARGE,    0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.141 Too Large Buffer NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPTOOLARGE, 0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "16.142 Multi Buffer NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPMULTI,    0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.143 Switch Send NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.144 Iterative Send NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,          0, NAME_NULL,      0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "16.145 NULL Buffer Ptr NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.146 0 Buffer Count NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT,   0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.147 flags != 0 NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          4, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.148 Not Bound Addr NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.149 Bound Addr NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.150 Same addr NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.151 Different addr NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_2,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.152 Broadcast addr NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_BROADCAST, sizeof(SOCKADDR_IN),     0,                    FALSE, SOCKET_ERROR, WSAEACCES,         FALSE },
    { "16.153 Broadcast enabled NB UDP", TRUE,  TRUE,  SOCKET_UDP | SOCKET_BROADCAST, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_BROADCAST, sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.154 Multicast addr NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_MULTICAST, sizeof(SOCKADDR_IN),     0,                    FALSE, SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "16.155 Bad addr NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_BAD,       sizeof(SOCKADDR_IN),     0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.156 Zero addr NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_ANY,       sizeof(SOCKADDR_IN),     0,                    FALSE, SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "16.157 Any addr NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_ANYADDR,   sizeof(SOCKADDR_IN),     0,                    FALSE, SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "16.158 Zero port addr NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_ANYPORT,   sizeof(SOCKADDR_IN),     0,                    FALSE, SOCKET_ERROR, WSAEADDRNOTAVAIL,  FALSE },
    { "16.159 Large addrlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) + 1, 0,                    FALSE, 0,            0,                 FALSE },
    { "16.160 Exact addrlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "16.161 Small addrlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  sizeof(SOCKADDR_IN) - 1, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.162 Zero addrlen NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.163 Neg addrlen NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_REMOTE_1,  -1,                      0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.164 Callback != NULL NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                    TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, NAME_NULL,      0,                       0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "16.165 Closed Socket TCP",        TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED,    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "16.166 Closed Socket UDP",        TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED,    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "16.167 Not Initialized",          FALSE, FALSE, SOCKET_INVALID_SOCKET,         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, NAME_NULL,      0,                       0,                    FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define WSASendToTableCount (sizeof(WSASendToTable) / sizeof(WSASENDTO_TABLE))

NETSYNC_TYPE_THREAD  WSASendToTestSessionNt =
{
    1,
    WSASendToTableCount * 2,
    L"xnetapi_nt.dll",
    "WSASendToTestServer"
};

NETSYNC_TYPE_THREAD  WSASendToTestSessionXbox =
{
    1,
    WSASendToTableCount * 2,
    L"xnetapi_xbox.dll",
    "WSASendToTestServer"
};



// Callback routine

VOID CALLBACK WSASendToCompletionRoutine(IN DWORD  dwError, IN DWORD  cbTransferred, IN LPWSAOVERLAPPED  lpOverlapped, IN DWORD  dwFlags) { return; }



VOID
WSASendToTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests WSASendTo - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // WSASendToRequest is the request sent to the server
    WSASENDTO_REQUEST      WSASendToRequest;

    // HostXnAddr is the host xnet address
    XNADDR                 HostXnAddr;
    // hostaddr is the local host address
    u_long                 hostaddr = 0;

    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD                  dwBufferSize = 1;
    // iTimeout is the send and receive timeout value for the socket
    int                    iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL                   bNagle = FALSE;
    // bBroadcast indicates the socket is enabled to send broadcast data
    BOOL                   bBroadcast = TRUE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                   bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename1 is the first remote address
    SOCKADDR_IN            remotename1;
    // remotename2 is the second remote address
    SOCKADDR_IN            remotename2;

    // readfds is the set of sockets to check for a read condition
    fd_set                 readfds;
    // writefds is the set of sockets to check for a write condition
    fd_set                 writefds;
    // timeout is the timeout for select
    timeval                fdstimeout = { 1, 0 };

    // SendBuffer10 is the send buffer
    char                   SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                   SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                   RecvBufferLarge[BUFFER_LARGE_LEN + 1];
    // WSABuf is an array of send data structures
    WSABUF                 WSABuf[3];
    // dwBufferCount is the number of send data structures
    DWORD                  dwBufferCount;
    // nBufferlen is the total size of the data
    int                    nBufferlen;
    // dwFillBuffer is a counter to fill the buffers
    DWORD                  dwFillBuffer;
    // dwBytes is the number of bytes sent
    DWORD                  dwBytes;
    // nBytes is the number of bytes received
    int                    nBytes;
    // nSendCount is a counter to enumerate each send/recv
    int                    nSendCount;

    // WSASendToBufferTable is the test buffer table to use for iterative send
    PWSASENDTOBUFFER_TABLE WSASendToBufferTable;
    // WSASendToBufferTableCount is the number of elements within the test buffer table
    size_t                 WSASendToBufferTableCount;
    // WSAOverlapped is the overlapped I/O structure
    WSAOVERLAPPED          WSAOverlapped;
    // dwFlags is the flags
    DWORD                  dwFlags;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // dwReturnCode is the return code of the operation
    DWORD                  dwReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "WSASendTo v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_WSASendTo+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_WSASendTo-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = WSASendToTestSessionXbox;
    }
    else {
        NetsyncTypeSession = WSASendToTestSessionNt;
    }

    // Initialize the overlapped I/O structure
    ZeroMemory(&WSAOverlapped, sizeof(WSAOverlapped));
    WSAOverlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Initialize the net subsystem
    XNetAddRef();

    // Get the local xnaddr
    do {
        dwReturnCode = XNetGetTitleXnAddr(&HostXnAddr);
        if (0 == dwReturnCode) {
            Sleep(SLEEP_ZERO_TIME);
        }
    } while (0 == dwReturnCode);
    hostaddr = HostXnAddr.ina.s_addr;

    for (dwTableIndex = 0; dwTableIndex < WSASendToTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, WSASendToTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, WSASendToTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != WSASendToTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, WSASendToTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == WSASendToTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != WSASendToTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == WSASendToTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = WSASendToTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == WSASendToTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == WSASendToTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == WSASendToTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == WSASendToTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == WSASendToTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == WSASendToTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & WSASendToTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Set the socket for broadcast
        if (0 != (SOCKET_BROADCAST & WSASendToTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, SOL_SOCKET, SO_BROADCAST, (char *) &bBroadcast, sizeof(bBroadcast));
        }

        if (TRUE == WSASendToTable[dwTableIndex].bFillQueue) {
            // Set the buffer size
            setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
            setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
        }

        // Set the send and receive timeout values to 5 sec
        if ((0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & WSASendToTable[dwTableIndex].dwSocket))) {
            setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the socket to non-blocking mode
        if (TRUE == WSASendToTable[dwTableIndex].bNonblock) {
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);
            bNonblocking = TRUE;
        }
        else {
            bNonblocking = FALSE;
        }

        // Bind the socket
        if (TRUE == WSASendToTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if (TRUE == WSASendToTable[dwTableIndex].bListen) {
            listen(sSocket, SOMAXCONN);
        }

        if (0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) {
            WSASendToBufferTable = WSASendToBufferTcpTable;
            WSASendToBufferTableCount = WSASendToBufferTcpTableCount;
        }
        else {
            WSASendToBufferTable = WSASendToBufferUdpTable;
            WSASendToBufferTableCount = WSASendToBufferUdpTableCount;
        }

        if ((TRUE == WSASendToTable[dwTableIndex].bAccept) || (TRUE == WSASendToTable[dwTableIndex].bConnect) || (0 == WSASendToTable[dwTableIndex].iReturnCode)) {
            // Initialize the send request
            WSASendToRequest.dwMessageId = WSASENDTO_REQUEST_MSG;
            if (0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) {
                WSASendToRequest.nSocketType = SOCK_STREAM;
            }
            else {
                WSASendToRequest.nSocketType = SOCK_DGRAM;
            }
            WSASendToRequest.ReceivePort = (NAME_REMOTE_2 != WSASendToTable[dwTableIndex].dwName) || (0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) ? CurrentPort : CurrentPort + 1;
            WSASendToRequest.SendPort = (TRUE == WSASendToTable[dwTableIndex].bBind) ? CurrentPort : 0;
            WSASendToRequest.bServerAccept = WSASendToTable[dwTableIndex].bConnect;
            WSASendToRequest.bFillQueue = WSASendToTable[dwTableIndex].bFillQueue;
            WSASendToRequest.nQueueLen = 0;
            WSASendToRequest.bRemoteClose = WSASendToTable[dwTableIndex].bRemoteClose;
            if (100 == WSASendToTable[dwTableIndex].nDataBuffers) {
                WSASendToRequest.nDataBuffers = WSASendToTable[dwTableIndex].nDataBuffers * WSASendToBufferTableCount;
            }
            else {
                WSASendToRequest.nDataBuffers = (0 == WSASendToTable[dwTableIndex].iReturnCode) ? WSASendToTable[dwTableIndex].nDataBuffers : 0;
            }
            if (BUFFER_10 == WSASendToTable[dwTableIndex].dwBuffer) {
                WSASendToRequest.nBufferlen = BUFFER_10_LEN;
            }
            else if (BUFFER_SMALL == WSASendToTable[dwTableIndex].dwBuffer) {
                WSASendToRequest.nBufferlen = BUFFER_10_LEN - 1;
            }
            else if (BUFFER_TCPLARGE == WSASendToTable[dwTableIndex].dwBuffer) {
                WSASendToRequest.nBufferlen = BUFFER_TCPLARGE_LEN;
            }
            else if (BUFFER_UDPLARGE == WSASendToTable[dwTableIndex].dwBuffer) {
                WSASendToRequest.nBufferlen = BUFFER_UDPLARGE_LEN;
            }
            else if (BUFFER_UDPTOOLARGE == WSASendToTable[dwTableIndex].dwBuffer) {
                WSASendToRequest.nBufferlen = BUFFER_UDPLARGE_LEN + 1;
            }
            else if (BUFFER_TCPMULTI == WSASendToTable[dwTableIndex].dwBuffer) {
                WSASendToRequest.nBufferlen = BUFFER_TCPLARGE_LEN;
            }
            else if (BUFFER_UDPMULTI == WSASendToTable[dwTableIndex].dwBuffer) {
                WSASendToRequest.nBufferlen = BUFFER_UDPLARGE_LEN;
            }
            else {
                WSASendToRequest.nBufferlen = 0;
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendToRequest), (char *) &WSASendToRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == WSASendToTable[dwTableIndex].bConnect) {
                // Connect the socket
                ZeroMemory(&remotename1, sizeof(remotename1));
                remotename1.sin_family = AF_INET;
                remotename1.sin_addr.s_addr = NetsyncInAddr;
                remotename1.sin_port = htons(CurrentPort);

                connect(sSocket, (SOCKADDR *) &remotename1, sizeof(remotename1));

                if (0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&writefds);
                    FD_SET(sSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }
            }
            else if (TRUE == WSASendToTable[dwTableIndex].bAccept) {
                if (0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&readfds);
                    FD_SET(sSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);
                }

                // Accept the socket
                nsSocket = accept(sSocket, NULL, NULL);
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendToRequest), (char *) &WSASendToRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == WSASendToTable[dwTableIndex].bFillQueue) {
                if (FALSE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                // Fill the queue
                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0)) {
                    WSASendToRequest.nQueueLen++;
                    Sleep(SLEEP_ZERO_TIME);
                }
            }

            if (TRUE == WSASendToTable[dwTableIndex].bRemoteClose) {
                if (TRUE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0));

                if (TRUE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }
        }

        // Shutdown the connection
        if (TRUE == WSASendToTable[dwTableIndex].bShutdown) {
            shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSASendToTable[dwTableIndex].nShutdown);
        }

        // Set the remote name
        ZeroMemory(&remotename1, sizeof(remotename1));
        remotename1.sin_family = AF_INET;

        if (NAME_ANYADDR == WSASendToTable[dwTableIndex].dwName) {
            remotename1.sin_port = htons(CurrentPort);
        }
        else if (NAME_ANYPORT == WSASendToTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = NetsyncInAddr;
        }
        else if (NAME_LOCAL == WSASendToTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = hostaddr;
            remotename1.sin_port = htons(CurrentPort + 1);
        }
        else if (NAME_LOOPBACK == WSASendToTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
            remotename1.sin_port = htons(CurrentPort + 1);
        }
        else if (NAME_BROADCAST == WSASendToTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = htonl(INADDR_BROADCAST);
            remotename1.sin_port = htons(CurrentPort);
        }
        else if (NAME_MULTICAST == WSASendToTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = inet_addr("224.0.0.0");
            remotename1.sin_port = htons(CurrentPort);
        }
        else if (NAME_UNAVAIL == WSASendToTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = inet_addr("127.0.0.0");
            remotename1.sin_port = htons(CurrentPort);
        }
        else if (NAME_BAD == WSASendToTable[dwTableIndex].dwName) {
            remotename1.sin_family = AF_UNIX;
            remotename1.sin_addr.s_addr = NetsyncInAddr;
            remotename1.sin_port = htons(CurrentPort);
        }
        else if (NAME_REMOTE_1 == WSASendToTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = NetsyncInAddr;
            remotename1.sin_port = htons(CurrentPort);
        }
        else if (NAME_REMOTE_2 == WSASendToTable[dwTableIndex].dwName) {
            remotename1.sin_addr.s_addr = NetsyncInAddr;
            remotename1.sin_port = htons(CurrentPort + 1);
        }

        // Initialize the buffers
        sprintf(SendBuffer10, "%05d%05d", 1, 1);
        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
        }

        dwBufferCount = 1;
        if (BUFFER_10 == WSASendToTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = SendBuffer10;

            nBufferlen = BUFFER_10_LEN;
        }
        else if (BUFFER_NULL == WSASendToTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = NULL;

            nBufferlen = 0;
        }
        else if (BUFFER_NULLZERO == WSASendToTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = 0;
            WSABuf[0].buf = NULL;

            nBufferlen = 0;
        }
        else if (BUFFER_ZERO == WSASendToTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = 0;
            WSABuf[0].buf = SendBuffer10;

            nBufferlen = 0;
        }
        else if (BUFFER_ZEROCOUNT == WSASendToTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = 0;
            WSABuf[0].buf = SendBuffer10;

            dwBufferCount = 0;
            nBufferlen = 0;
        }
        else if (BUFFER_SMALL == WSASendToTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN - 1;
            WSABuf[0].buf = SendBuffer10;

            nBufferlen = BUFFER_10_LEN - 1;
        }
        else if (BUFFER_TCPLARGE == WSASendToTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_TCPLARGE_LEN;
            WSABuf[0].buf = SendBufferLarge;

            nBufferlen = BUFFER_TCPLARGE_LEN;
        }
        else if (BUFFER_UDPLARGE == WSASendToTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_UDPLARGE_LEN;
            WSABuf[0].buf = SendBufferLarge;

            nBufferlen = BUFFER_UDPLARGE_LEN;
        }
        else if (BUFFER_UDPTOOLARGE == WSASendToTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_UDPLARGE_LEN + 1;
            WSABuf[0].buf = SendBufferLarge;

            nBufferlen = 0;
        }
        else if (BUFFER_TCPMULTI == WSASendToTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = SendBufferLarge;

            WSABuf[1].len = 0;
            WSABuf[1].buf = NULL;

            WSABuf[2].len = BUFFER_TCPLARGE_LEN - BUFFER_10_LEN;
            WSABuf[2].buf = &SendBufferLarge[BUFFER_10_LEN];

            dwBufferCount = 3;
            nBufferlen = BUFFER_TCPLARGE_LEN;
        }
        else if (BUFFER_UDPMULTI == WSASendToTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = SendBufferLarge;

            WSABuf[1].len = 0;
            WSABuf[1].buf = NULL;

            WSABuf[2].len = BUFFER_UDPLARGE_LEN - BUFFER_10_LEN;
            WSABuf[2].buf = &SendBufferLarge[BUFFER_10_LEN];

            dwBufferCount = 3;
            nBufferlen = BUFFER_UDPLARGE_LEN;
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & WSASendToTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        __try {
            // Call WSASendTo
            iReturnCode = WSASendTo((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (BUFFER_NONE != WSASendToTable[dwTableIndex].dwBuffer) ? WSABuf : NULL, (BUFFER_NONE != WSASendToTable[dwTableIndex].dwBuffer) ? dwBufferCount : 0, &dwBytes, WSASendToTable[dwTableIndex].nFlags, (NAME_NULL != WSASendToTable[dwTableIndex].dwName) ? (SOCKADDR *) &remotename1 : NULL, WSASendToTable[dwTableIndex].namelen, (0 == WSASendToTable[dwTableIndex].nOverlapped) ? NULL : &WSAOverlapped, (FALSE == WSASendToTable[dwTableIndex].bCompletionRoutine) ? NULL : WSASendToCompletionRoutine);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == WSASendToTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "WSASendTo RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "WSASendTo caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == WSASendToTable[dwTableIndex].bFillQueue) {
                if (0 != WSASendToTable[dwTableIndex].nOverlapped) {
                    if (SOCKET_ERROR != iReturnCode) {
                        bTestPassed = FALSE;
                        WSASendToRequest.dwMessageId = WSASENDTO_CANCEL_MSG;
                        WSASendToRequest.nDataBuffers = 0;
                    }
                    else {
                        // Get the last error code
                        iLastError = WSAGetLastError();

                        if (iLastError != WSA_IO_PENDING) {
                            xLog(hLog, XLL_FAIL, "WSASendTo iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, iLastError);
                            bTestPassed = FALSE;
                            WSASendToRequest.dwMessageId = WSASENDTO_CANCEL_MSG;
                        }
                    }

                    // Send the send cancel
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendToRequest), (char *) &WSASendToRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (FALSE != bTestPassed) {
                        if (OVERLAPPED_IO_EVENT == WSASendToTable[dwTableIndex].nOverlapped) {
                            // Wait on the overlapped I/O event
                            WaitForSingleObject(WSAOverlapped.hEvent, INFINITE);
                        }

                        // Get the overlapped I/O result
                        if (FALSE == WSAGetOverlappedResult((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSAOverlapped, &dwBytes, (OVERLAPPED_IO_RESULT == WSASendToTable[dwTableIndex].nOverlapped) ? TRUE : FALSE, &dwFlags)) {
                            xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        }
                        else {
                            iReturnCode = 0;
                        }
                    }
                }
                else {
                    if (SOCKET_ERROR != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "WSASendTo returned non-SOCKET_ERROR");
                    }
                    else {
                        // Get the last error code
                        iLastError = WSAGetLastError();

                        if (iLastError != WSAEWOULDBLOCK) {
                            xLog(hLog, XLL_FAIL, "WSASendTo iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                        }
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendToRequest), (char *) &WSASendToRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (FALSE == bNonblocking) {
                        Nonblock = 0;
                        ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                    }
                    else {
                        FD_ZERO(&writefds);
                        FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &writefds);
                        select(0, NULL, &writefds, NULL, NULL);
                    }

                    // Call WSASendTo
                    iReturnCode = WSASendTo((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, dwBufferCount, &dwBytes, WSASendToTable[dwTableIndex].nFlags, (NAME_NULL != WSASendToTable[dwTableIndex].dwName) ? (SOCKADDR *) &remotename1 : NULL, WSASendToTable[dwTableIndex].namelen, NULL, NULL);
                }
            }

            if (-1 == WSASendToTable[dwTableIndex].nDataBuffers) {
                if (SOCKET_ERROR == iReturnCode) {
                    bTestPassed = FALSE;
                    WSASendToRequest.dwMessageId = WSASENDTO_CANCEL_MSG;
                    WSASendToRequest.nDataBuffers = 0;
                }
                else {
                    dwReturnCode = WaitForSingleObject(WSAOverlapped.hEvent, 0);
                    if (WAIT_OBJECT_0 != dwReturnCode) {
                        xLog(hLog, XLL_FAIL, "WaitForSingleObject - EXPECTED: %u; RECEIVED: %u", WAIT_OBJECT_0, dwReturnCode);
                    }

                    // Get the overlapped I/O result
                    if (FALSE == WSAGetOverlappedResult((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSAOverlapped, &dwBytes, (OVERLAPPED_IO_RESULT == WSASendToTable[dwTableIndex].nOverlapped) ? TRUE : FALSE, &dwFlags)) {
                        xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                    }
                    else {
                        iReturnCode = 0;
                    }
                }
            }

            if (TRUE == WSASendToTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "WSASendTo did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == WSASendToTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != WSASendToTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "WSASendTo iLastError - EXPECTED: %u; RECEIVED: %u", WSASendToTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "WSASendTo iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSASendTo returned SOCKET_ERROR - ec = %u", WSAGetLastError());

                if (0 != WSASendToRequest.nDataBuffers) {
                    // Send the send cancel
                    WSASendToRequest.dwMessageId = WSASENDTO_CANCEL_MSG;
                    WSASendToRequest.nDataBuffers = 0;
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendToRequest), (char *) &WSASendToRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);
                }
            }
            else if (SOCKET_ERROR == WSASendToTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSASendTo returned non-SOCKET_ERROR");
            }
            else {
                if (nBufferlen != (int) dwBytes) {
                    xLog(hLog, XLL_FAIL, "WSASendTo return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwBytes);
                    bTestPassed = FALSE;
                }

                if ((NAME_REMOTE_2 == WSASendToTable[dwTableIndex].dwName) && (0 != (SOCKET_UDP & WSASendToTable[dwTableIndex].dwSocket))) {
                    // Reset the default connection
                    ZeroMemory(&remotename2, sizeof(remotename2));
                    remotename2.sin_family = AF_INET;

                    connect((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (SOCKADDR *) &remotename2, sizeof(remotename2));
                }

                // Send the read request
                NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendToRequest), (char *) &WSASendToRequest);

                // Wait for the read complete
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                NetsyncFreeMessage(pMessage);

                if ((TRUE != WSASendToTable[dwTableIndex].bFillQueue) && (TRUE != WSASendToTable[dwTableIndex].bShutdown)) {
                    // Call recv/recvfrom
                    if (0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) {
                        if (0 != nBufferlen) {
                            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                            nBytes = 0;

                            do {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                if (1 == iReturnCode) {
                                    iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], 10, 0);
                                }
                                else if (0 == iReturnCode) {
                                    iReturnCode = SOCKET_ERROR;
                                    SetLastError(WSAETIMEDOUT);
                                }

                                if (SOCKET_ERROR != iReturnCode) {
                                    nBytes += iReturnCode;
                                }
                            } while (SOCKET_ERROR != iReturnCode);

                            if (WSAETIMEDOUT != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else if (nBufferlen != nBytes) {
                                xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, nBytes);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }
                    }
                    else {
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                        if (TRUE == bNonblocking) {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                            select(0, &readfds, NULL, NULL, NULL);
                        }

                        iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0, NULL, NULL);
                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv/recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else if (nBufferlen != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv/recvfrom return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, iReturnCode);
                            bTestPassed = FALSE;
                        }
                        else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                            bTestPassed = FALSE;
                        }
                    }
                }

                if (3 == WSASendToTable[dwTableIndex].nDataBuffers) {
                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }

                    // Switch the blocking mode
                    Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                    bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                    // Call WSASendTo
                    iReturnCode = WSASendTo((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, dwBufferCount, &dwBytes, WSASendToTable[dwTableIndex].nFlags, (NAME_NULL != WSASendToTable[dwTableIndex].dwName) ? (SOCKADDR *) &remotename1 : NULL, WSASendToTable[dwTableIndex].namelen, NULL, NULL);

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "WSASendTo returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                        WSASendToRequest.dwMessageId = WSASENDTO_CANCEL_MSG;
                    }
                    else {
                        if (nBufferlen != (int) dwBytes) {
                            xLog(hLog, XLL_FAIL, "WSASendTo return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwBytes);
                            bTestPassed = FALSE;
                        }

                        WSASendToRequest.dwMessageId = WSASENDTO_REQUEST_MSG;
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendToRequest), (char *) &WSASendToRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (SOCKET_ERROR != iReturnCode) {
                        // Call recv/recvfrom
                        if (0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) {
                            if (0 != nBufferlen) {
                                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                                nBytes = 0;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], 10, 0);
                                    }
                                    else if (0 == iReturnCode) {
                                        iReturnCode = SOCKET_ERROR;
                                        SetLastError(WSAETIMEDOUT);
                                    }

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                } while (SOCKET_ERROR != iReturnCode);

                                if (WSAETIMEDOUT != WSAGetLastError()) {
                                    xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else if (nBufferlen != nBytes) {
                                    xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, nBytes);
                                    bTestPassed = FALSE;
                                }
                                else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                        else {
                            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                            if (TRUE == bNonblocking) {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);
                            }

                            iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0, NULL, NULL);
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv/recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else if (nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv/recvfrom return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 3, 3);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }

                    // Switch the blocking mode
                    Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                    bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                    // Call WSASendTo
                    iReturnCode = WSASendTo((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, dwBufferCount, &dwBytes, WSASendToTable[dwTableIndex].nFlags, (NAME_NULL != WSASendToTable[dwTableIndex].dwName) ? (SOCKADDR *) &remotename1 : NULL, WSASendToTable[dwTableIndex].namelen, NULL, NULL);

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "WSASendTo returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                        WSASendToRequest.dwMessageId = WSASENDTO_CANCEL_MSG;
                    }
                    else {
                        if (nBufferlen != (int) dwBytes) {
                            xLog(hLog, XLL_FAIL, "WSASendTo return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwBytes);
                            bTestPassed = FALSE;
                        }

                        WSASendToRequest.dwMessageId = WSASENDTO_REQUEST_MSG;
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendToRequest), (char *) &WSASendToRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (SOCKET_ERROR != iReturnCode) {
                        // Call recv/recvfrom
                        if (0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) {
                            if (0 != nBufferlen) {
                                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                                nBytes = 0;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], 10, 0);
                                    }
                                    else if (0 == iReturnCode) {
                                        iReturnCode = SOCKET_ERROR;
                                        SetLastError(WSAETIMEDOUT);
                                    }

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                } while (SOCKET_ERROR != iReturnCode);

                                if (WSAETIMEDOUT != WSAGetLastError()) {
                                    xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else if (nBufferlen != nBytes) {
                                    xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, nBytes);
                                    bTestPassed = FALSE;
                                }
                                else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                        else {
                            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                            if (TRUE == bNonblocking) {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);
                            }

                            iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0, NULL, NULL);
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv/recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else if (nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv/recvfrom return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }
                    }
                }
                else if (100 == WSASendToTable[dwTableIndex].nDataBuffers) {
                    for (nSendCount = 0; nSendCount < (int) (WSASendToTable[dwTableIndex].nDataBuffers * WSASendToBufferTableCount); nSendCount++) {
                        // Initialize the buffers
                        sprintf(SendBuffer10, "%05d%05d", 3, 3);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                        }

                        dwBufferCount = 1;
                        if (BUFFER_10 == WSASendToBufferTable[nSendCount % WSASendToBufferTableCount].dwBuffer) {
                            WSABuf[0].len = BUFFER_10_LEN;
                            WSABuf[0].buf = SendBuffer10;

                            nBufferlen = BUFFER_10_LEN;
                        }
                        else if (BUFFER_NULLZERO == WSASendToBufferTable[nSendCount % WSASendToBufferTableCount].dwBuffer) {
                            WSABuf[0].len = 0;
                            WSABuf[0].buf = NULL;

                            nBufferlen = 0;
                        }
                        else if (BUFFER_TCPLARGE == WSASendToBufferTable[nSendCount % WSASendToBufferTableCount].dwBuffer) {
                            WSABuf[0].len = BUFFER_TCPLARGE_LEN;
                            WSABuf[0].buf = SendBufferLarge;

                            nBufferlen = BUFFER_TCPLARGE_LEN;
                        }
                        else if (BUFFER_UDPLARGE == WSASendToBufferTable[nSendCount % WSASendToBufferTableCount].dwBuffer) {
                            WSABuf[0].len = BUFFER_UDPLARGE_LEN;
                            WSABuf[0].buf = SendBufferLarge;

                            nBufferlen = BUFFER_UDPLARGE_LEN;
                        }
                        else if (BUFFER_TCPMULTI == WSASendToBufferTable[nSendCount % WSASendToBufferTableCount].dwBuffer) {
                            WSABuf[0].len = BUFFER_10_LEN;
                            WSABuf[0].buf = SendBufferLarge;

                            WSABuf[1].len = 0;
                            WSABuf[1].buf = NULL;

                            WSABuf[2].len = BUFFER_TCPLARGE_LEN - BUFFER_10_LEN;
                            WSABuf[2].buf = &SendBufferLarge[BUFFER_10_LEN];

                            dwBufferCount = 3;
                            nBufferlen = BUFFER_TCPLARGE_LEN;
                        }
                        else if (BUFFER_UDPMULTI == WSASendToBufferTable[nSendCount % WSASendToBufferTableCount].dwBuffer) {
                            WSABuf[0].len = BUFFER_10_LEN;
                            WSABuf[0].buf = SendBufferLarge;

                            WSABuf[1].len = 0;
                            WSABuf[1].buf = NULL;

                            WSABuf[2].len = BUFFER_UDPLARGE_LEN - BUFFER_10_LEN;
                            WSABuf[2].buf = &SendBufferLarge[BUFFER_10_LEN];

                            dwBufferCount = 3;
                            nBufferlen = BUFFER_UDPLARGE_LEN;
                        }

                        xLog(hLog, XLL_INFO, "Iteration %d", nSendCount);

                        // Call WSASendTo
                        iReturnCode = WSASendTo((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, dwBufferCount, &dwBytes, 0, (NAME_NULL != WSASendToTable[dwTableIndex].dwName) ? (SOCKADDR *) &remotename1 : NULL, WSASendToTable[dwTableIndex].namelen, NULL, NULL);

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "WSASendTo returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                            WSASendToRequest.dwMessageId = WSASENDTO_CANCEL_MSG;
                        }
                        else {
                            if (nBufferlen != (int) dwBytes) {
                                xLog(hLog, XLL_FAIL, "WSASendTo return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwBytes);
                                bTestPassed = FALSE;
                            }

                            WSASendToRequest.dwMessageId = WSASENDTO_REQUEST_MSG;
                        }

                        // Send the read request
                        WSASendToRequest.nBufferlen = nBufferlen;
                        NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendToRequest), (char *) &WSASendToRequest);

                        // Wait for the read complete
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);

                        if (SOCKET_ERROR != iReturnCode) {
                            // Call recv/recvfrom
                            if (0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) {
                                if (0 != nBufferlen) {
                                    ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                                    nBytes = 0;

                                    do {
                                        FD_ZERO(&readfds);
                                        FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                        iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                        if (1 == iReturnCode) {
                                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], 10, 0);
                                        }
                                        else if (0 == iReturnCode) {
                                            iReturnCode = SOCKET_ERROR;
                                            SetLastError(WSAETIMEDOUT);
                                        }

                                        if (SOCKET_ERROR != iReturnCode) {
                                            nBytes += iReturnCode;
                                        }
                                    } while (SOCKET_ERROR != iReturnCode);

                                    if (WSAETIMEDOUT != WSAGetLastError()) {
                                        xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                        bTestPassed = FALSE;
                                    }
                                    else if (nBufferlen != nBytes) {
                                        xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, nBytes);
                                        bTestPassed = FALSE;
                                    }
                                    else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                        xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                        bTestPassed = FALSE;
                                    }
                                }
                            }
                            else {
                                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                                if (TRUE == bNonblocking) {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                    select(0, &readfds, NULL, NULL, NULL);
                                }

                                iReturnCode = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0, NULL, NULL);
                                if (SOCKET_ERROR == iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "recv/recvfrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else if (nBufferlen != iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "recv/recvfrom return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, iReturnCode);
                                    bTestPassed = FALSE;
                                }
                                else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "WSASendTo succeeded");
                }
            }
        }

        // Switch the blocking mode
        if (WSASendToTable[dwTableIndex].bNonblock != bNonblocking) {
            Nonblock = (TRUE == WSASendToTable[dwTableIndex].bNonblock) ? 1 : 0;
            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
            bNonblocking = WSASendToTable[dwTableIndex].bNonblock;
        }

        if ((TRUE == WSASendToTable[dwTableIndex].bAccept) || (TRUE == WSASendToTable[dwTableIndex].bConnect) || (0 == WSASendToTable[dwTableIndex].iReturnCode)) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendToRequest), (char *) &WSASendToRequest);
        }

        // Close the socket
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & WSASendToTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & WSASendToTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & WSASendToTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort += 2;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    CloseHandle(WSAOverlapped.hEvent);

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
WSASendToTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests WSASendTo - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long              FromInAddr;
    // dwMessageType is the type of received message
    DWORD               dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD               dwMessageSize;
    // pMessage is a pointer to the received message
    char                *pMessage;
    // WSASendToRequest is the request
    WSASENDTO_REQUEST   WSASendToRequest;
    // WSASendToComplete is the result
    WSASENDTO_COMPLETE  WSASendToComplete;

    // sSocket is the socket descriptor
    SOCKET              sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET              nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD               dwBufferSize = 1;
    // iTimeout is the send and receive timeout value for the socket
    int                 iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL                bNagle = FALSE;
    // nQueueLen is the size of the queue
    int                 nQueueLen;

    // localname is the local address
    SOCKADDR_IN         localname;
    // remotename is the remote address
    SOCKADDR_IN         remotename;
    // namelen is the size of namelen
    int                 namelen;

    // readfds is the set of sockets to check for a read condition
    fd_set              readfds;
    // timeout is the timeout for select
    timeval             fdstimeout = { 1, 0 };

    // SendBufferLarge is the large send buffer
    char                SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // nBytes is the number of bytes sent/received
    int                 nBytes;
    // nSendCount is a counter to enumerate each send
    int                 nSendCount;

    // iReturnCode is the return code of the operation
    int                 iReturnCode;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&WSASendToRequest, pMessage, sizeof(WSASendToRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, WSASendToRequest.nSocketType, 0);

        if (TRUE == WSASendToRequest.bFillQueue) {
            // Set the buffer size
            setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
            setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
        }

        // Set the send and receive timeout values to 5 sec
        setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

        if (SOCK_STREAM == WSASendToRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(WSASendToRequest.ReceivePort);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if (SOCK_STREAM == WSASendToRequest.nSocketType) {
            if (TRUE == WSASendToRequest.bServerAccept) {
                // Place the socket in listening mode
                listen(sSocket, SOMAXCONN);
            }
            else {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = FromInAddr;
                remotename.sin_port = htons(WSASendToRequest.SendPort);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
            }
        }

        // Send the complete
        WSASendToComplete.dwMessageId = WSASENDTO_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendToComplete), (char *) &WSASendToComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if ((SOCK_STREAM == WSASendToRequest.nSocketType) && (TRUE == WSASendToRequest.bServerAccept)) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        if (TRUE == WSASendToRequest.bRemoteClose) {
            // Close the sockets
            if (INVALID_SOCKET != nsSocket) {
                shutdown(nsSocket, SD_BOTH);
                closesocket(nsSocket);
                nsSocket = INVALID_SOCKET;
            }

            if (INVALID_SOCKET != sSocket) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
                sSocket = INVALID_SOCKET;
            }
        }

        // Send the complete
        WSASendToComplete.dwMessageId = WSASENDTO_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendToComplete), (char *) &WSASendToComplete);

        if (TRUE == WSASendToRequest.bFillQueue) {
            // Wait for the request
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            nQueueLen = ((PWSASENDTO_REQUEST) pMessage)->nQueueLen;
            CopyMemory(&WSASendToRequest, pMessage, sizeof(WSASendToRequest));
            NetsyncFreeMessage(pMessage);

            if (WSASENDTO_CANCEL_MSG != WSASendToRequest.dwMessageId) {
                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                for (nSendCount = 0; nSendCount < nQueueLen; nSendCount++) {
                    recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0);
                }
            }

            // Send the complete
            WSASendToComplete.dwMessageId = WSASENDTO_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendToComplete), (char *) &WSASendToComplete);
        }

        if ((0 < WSASendToRequest.nDataBuffers) || (-1 == WSASendToRequest.nDataBuffers)) {
            // Wait for the request
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            CopyMemory(&WSASendToRequest, pMessage, sizeof(WSASendToRequest));
            NetsyncFreeMessage(pMessage);

            if ((WSASENDTO_CANCEL_MSG != WSASendToRequest.dwMessageId) && ((0 != WSASendToRequest.nBufferlen) || (SOCK_STREAM != WSASendToRequest.nSocketType))) {
                if (SOCK_DGRAM == WSASendToRequest.nSocketType) {
                    ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                    ZeroMemory(&remotename, sizeof(remotename));
                    namelen = sizeof(remotename);

                    if (SOCKET_ERROR != recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, sizeof(SendBufferLarge), 0, (SOCKADDR *) &remotename, &namelen)) {
                        remotename.sin_addr.s_addr = FromInAddr;
                        sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, strlen(SendBufferLarge), 0, (SOCKADDR *) &remotename, sizeof(remotename));
                    }
                }
                else {
                    ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                    nBytes = 0;

                    do {
                        FD_ZERO(&readfds);
                        FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                        iReturnCode = SOCKET_ERROR;
                        if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], 10, 0);
                        }

                        if (SOCKET_ERROR != iReturnCode) {
                            nBytes += iReturnCode;
                        }
                    } while ((SOCKET_ERROR != iReturnCode) && (nBytes < WSASendToRequest.nBufferlen));

                    if (nBytes == WSASendToRequest.nBufferlen) {
                        send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                    }
                }
            }

            // Send the complete
            WSASendToComplete.dwMessageId = WSASENDTO_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendToComplete), (char *) &WSASendToComplete);

            if (3 == WSASendToRequest.nDataBuffers) {
                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                if (WSASENDTO_CANCEL_MSG != ((PWSASENDTO_REQUEST) pMessage)->dwMessageId) {
                    if (SOCK_DGRAM == WSASendToRequest.nSocketType) {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                        ZeroMemory(&remotename, sizeof(remotename));
                        namelen = sizeof(remotename);

                        if (SOCKET_ERROR != recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, sizeof(SendBufferLarge), 0, (SOCKADDR *) &remotename, &namelen)) {
                            remotename.sin_addr.s_addr = FromInAddr;
                            sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, strlen(SendBufferLarge), 0, (SOCKADDR *) &remotename, sizeof(remotename));
                        }
                    }
                    else {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                        nBytes = 0;

                        do {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                            iReturnCode = SOCKET_ERROR;
                            if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                                iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], 10, 0);
                            }

                            if (SOCKET_ERROR != iReturnCode) {
                                nBytes += iReturnCode;
                            }
                        } while ((SOCKET_ERROR != iReturnCode) && (nBytes < WSASendToRequest.nBufferlen));

                        if (nBytes == WSASendToRequest.nBufferlen) {
                            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                        }
                    }
                }
                NetsyncFreeMessage(pMessage);

                // Send the complete
                WSASendToComplete.dwMessageId = WSASENDTO_COMPLETE_MSG;
                NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendToComplete), (char *) &WSASendToComplete);

                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                if (WSASENDTO_CANCEL_MSG != ((PWSASENDTO_REQUEST) pMessage)->dwMessageId) {
                    if (SOCK_DGRAM == WSASendToRequest.nSocketType) {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                        ZeroMemory(&remotename, sizeof(remotename));
                        namelen = sizeof(remotename);

                        if (SOCKET_ERROR != recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, sizeof(SendBufferLarge), 0, (SOCKADDR *) &remotename, &namelen)) {
                            remotename.sin_addr.s_addr = FromInAddr;
                            sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, strlen(SendBufferLarge), 0, (SOCKADDR *) &remotename, sizeof(remotename));
                        }
                    }
                    else {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                        nBytes = 0;

                        do {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                            iReturnCode = SOCKET_ERROR;
                            if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                                iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], 10, 0);
                            }

                            if (SOCKET_ERROR != iReturnCode) {
                                nBytes += iReturnCode;
                            }
                        } while ((SOCKET_ERROR != iReturnCode) && (nBytes < WSASendToRequest.nBufferlen));

                        if (nBytes == WSASendToRequest.nBufferlen) {
                            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                        }
                    }
                }
                NetsyncFreeMessage(pMessage);

                // Send the complete
                WSASendToComplete.dwMessageId = WSASENDTO_COMPLETE_MSG;
                NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendToComplete), (char *) &WSASendToComplete);
            }
            else if (100 <= WSASendToRequest.nDataBuffers) {
                for (nSendCount = 0; nSendCount < WSASendToRequest.nDataBuffers; nSendCount++) {
                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                    if ((0 != ((PWSASENDTO_REQUEST) pMessage)->nBufferlen) || (SOCK_STREAM != WSASendToRequest.nSocketType)) {
                        if (WSASENDTO_CANCEL_MSG != ((PWSASENDTO_REQUEST) pMessage)->dwMessageId) {
                            if (SOCK_DGRAM == WSASendToRequest.nSocketType) {
                                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                                ZeroMemory(&remotename, sizeof(remotename));
                                namelen = sizeof(remotename);

                                if (SOCKET_ERROR != recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, sizeof(SendBufferLarge), 0, (SOCKADDR *) &remotename, &namelen)) {
                                    remotename.sin_addr.s_addr = FromInAddr;
                                    sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, strlen(SendBufferLarge), 0, (SOCKADDR *) &remotename, sizeof(remotename));
                                }
                            }
                            else {
                                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                                nBytes = 0;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = SOCKET_ERROR;
                                    if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], 10, 0);
                                    }

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                } while ((SOCKET_ERROR != iReturnCode) && (nBytes < ((PWSASENDTO_REQUEST) pMessage)->nBufferlen));

                                if (nBytes == ((PWSASENDTO_REQUEST) pMessage)->nBufferlen) {
                                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                                }
                            }
                        }
                    }
                    NetsyncFreeMessage(pMessage);

                    // Send the complete
                    WSASendToComplete.dwMessageId = WSASENDTO_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendToComplete), (char *) &WSASendToComplete);
                }
            }
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\wsasend.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  wsasend.c

Abstract:

  This modules tests wsasend

Author:

  Steven Kehrli (steveke) 28-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// WSASend messages

#define WSASEND_REQUEST_MSG   NETSYNC_MSG_USER + 140 + 1
#define WSASEND_CANCEL_MSG    NETSYNC_MSG_USER + 140 + 2
#define WSASEND_COMPLETE_MSG  NETSYNC_MSG_USER + 140 + 3

typedef struct _WSASEND_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bServerAccept;
    BOOL     bFillQueue;
    INT      nQueueLen;
    BOOL     bRemoteClose;
    int      nDataBuffers;
    int      nBufferlen;
} WSASEND_REQUEST, *PWSASEND_REQUEST;

typedef struct _WSASEND_COMPLETE {
    DWORD    dwMessageId;
} WSASEND_COMPLETE, *PWSASEND_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define BUFFER_10             0
#define BUFFER_LARGE          1
#define BUFFER_NULL           2
#define BUFFER_NULLZERO       3
#define BUFFER_ZERO           4
#define BUFFER_ZEROCOUNT      5
#define BUFFER_SMALL          6
#define BUFFER_TCPLARGE       7
#define BUFFER_UDPLARGE       8
#define BUFFER_UDPTOOLARGE    9
#define BUFFER_TCPMULTI      10
#define BUFFER_UDPMULTI      11
#define BUFFER_NONE          12

#define OVERLAPPED_IO_RESULT  1
#define OVERLAPPED_IO_EVENT   2



typedef struct WSASENDBUFFER_TABLE {
    DWORD  dwBuffer;
} WSASENDBUFFER_TABLE, *PWSASENDBUFFER_TABLE;

WSASENDBUFFER_TABLE WSASendBufferTcpTable[] = { { BUFFER_10        },
                                                { BUFFER_NULLZERO  },
                                                { BUFFER_TCPLARGE  },
                                                { BUFFER_TCPMULTI  } };

#define WSASendBufferTcpTableCount  (sizeof(WSASendBufferTcpTable) / sizeof(WSASENDBUFFER_TABLE));

WSASENDBUFFER_TABLE WSASendBufferUdpTable[] = { { BUFFER_10        },
                                                { BUFFER_NULLZERO  },
                                                { BUFFER_UDPLARGE  },
                                                { BUFFER_UDPMULTI  } };

#define WSASendBufferUdpTableCount  (sizeof(WSASendBufferUdpTable) / sizeof(WSASENDBUFFER_TABLE));



typedef struct WSASEND_TABLE {
    CHAR           szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL           bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL           bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD          dwSocket;                                // dwSocket indicates the socket to be created
    BOOL           bNonblock;                               // bNonblock indicates if the socket is to be set as non-blocking for the send
    BOOL           bBind;                                   // bBind indicates if the socket is to be bound
    BOOL           bListen;                                 // bListen indicates if the socket is to be placed in the listening state
    BOOL           bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL           bConnect;                                // bConnect indicates if the socket is connected
    BOOL           bFillQueue;                              // bFillQueue indicates if the buffer should be filled
    BOOL           bRemoteClose;                            // bRemoteClose indicates if the remote closes the connection
    BOOL           bShutdown;                               // bShutdown indicates if the connection is shutdown
    int            nShutdown;                               // nShutdown indicates how the connection is shutdown
    int            nDataBuffers;                            // nDataBuffers indicates the number of data buffers to be sent
    DWORD          dwBuffer;                                // dwBuffer specifies the send data structure
    int            nFlags;                                  // nFlags specifies the WSASend flags
    int            nOverlapped;                             // nOverlapped specifies if overlapped I/O is used
    BOOL           bCompletionRoutine;                      // bCompletionRoutine specifies if completion routine is used
    int            iReturnCode;                             // iReturnCode is the return code of WSASend
    int            iLastError;                              // iLastError is the error code if the operation failed
    BOOL           bRIP;                                    // Specifies a RIP test case
} WSASEND_TABLE, *PWSASEND_TABLE;

static WSASEND_TABLE WSASendTable[] =
{
    { "14.1 Not Initialized",            FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "14.2 s = INT_MIN",                TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "14.3 s = -1",                     TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "14.4 s = 0",                      TRUE,  TRUE,  SOCKET_ZERO,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "14.5 s = INT_MAX",                TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "14.6 s = INVALID_SOCKET",         TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "14.7 Not Bound TCP",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "14.8 Listening TCP",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "14.9 Accepted TCP",               TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.10 Connected TCP",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.11 Fill Queue TCP",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.12 Fill Queue I/O TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,          0, OVERLAPPED_IO_RESULT, FALSE, 0,            0,                 FALSE },
    { "14.13 Fill Queue Event TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,          0, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "14.14 Event Event TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,          0, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "14.15 SD_RECEIVE Accept TCP",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.16 SD_SEND Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "14.17 SD_BOTH Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "14.18 SD_RECEIVE Connect TCP",    TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.19 SD_SEND Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "14.20 SD_BOTH Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "14.21 Close Accept TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "14.22 Close Connect TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "14.23 NULL Buffer TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,        0, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.24 NULL 0 Bufferlen TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,    0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.25 0 Bufferlen TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,        0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.26 Small Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,       0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.27 Exact Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.28 Large Buffer TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_TCPLARGE,    0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.29 Multi Buffer TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_TCPMULTI,    0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.30 Switch Send TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.31 Iterative Send TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.32 NULL Buffer Ptr TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.33 0 Buffer Count TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT,   0, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.34 flags != 0 TCP",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          4, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.35 Callback != NULL TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.36 Not Bound NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "14.37 Listening NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "14.38 Accepted NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.39 Connected NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.40 Fill Queue NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.41 Fill Queue I/O NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,          0, OVERLAPPED_IO_RESULT, FALSE, 0,            0,                 FALSE },
    { "14.42 Fill Queue Event NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,          0, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "14.43 Event Event NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,          0, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "14.44 SD_RECEIVE Accept NB TCP",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.45 SD_SEND Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "14.46 SD_BOTH Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "14.47 SD_RECEIVE Connect NB TCP", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.48 SD_SEND Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "14.49 SD_BOTH Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "14.50 Close Accept NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "14.51 Close Connect NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "14.52 NULL Buffer NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,        0, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.53 NULL 0 Bufferlen NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,    0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.54 0 Bufferlen NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,        0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.55 Small Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,       0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.56 Exact Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.57 Large Buffer NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_TCPLARGE,    0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.58 Multi Buffer NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_TCPMULTI,    0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.59 Switch Send NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.60 Iterative Send NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.61 NULL Buffer Ptr NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.62 0 Buffer Count NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT,   0, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.63 flags != 0 NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          4, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.64 Callback != NULL NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.65 Not Bound UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "14.66 Not Connected UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "14.67 Connected UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.68 Event Event UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,          0, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "14.69 SD_RECEIVE Conn UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.70 SD_SEND Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "14.71 SD_BOTH Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "14.72 NULL Buffer UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,        0, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.73 NULL 0 Bufferlen UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,    0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.74 0 Bufferlen UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,        0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.75 Small Bufferlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,       0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.76 Exact Bufferlen UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.77 Large Buffer UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPLARGE,    0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.78 Too Large Buffer UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPTOOLARGE, 0, 0,                    FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "14.79 Multi Buffer UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPMULTI,    0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.80 Switch Send UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.81 Iterative Send UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.82 NULL Buffer Ptr UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.83 0 Buffer Count UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT,   0, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.84 flags != 0 UDP",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          4, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.85 Callback != NULL UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.86 Not Bound NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "14.87 Not Connected NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "14.88 Connected NB UDP",          TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.89 Event Event NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,          0, OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "14.90 SD_RECEIVE Conn NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.91 SD_SEND Conn NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "14.92 SD_BOTH Conn NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,          0, 0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "14.93 NULL Buffer NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,        0, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.94 NULL 0 Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,    0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.95 0 Bufferlen NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,        0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.96 Small Bufferlen NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,       0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.97 Exact Bufferlen NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.98 Large Buffer NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPLARGE,    0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.99 Too Large Buffer NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPTOOLARGE, 0, 0,                    FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "14.100 Multi Buffer NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPMULTI,    0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.101 Switch Send NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.102 Iterative Send NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,          0, 0,                    FALSE, 0,            0,                 FALSE },
    { "14.103 NULL Buffer Ptr NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.104 0 Buffer Count NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT,   0, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.105 flags != 0 NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          4, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.106 Callback != NULL NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,          0, 0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "14.107 Closed Socket TCP",        TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "14.108 Closed Socket UDP",        TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "14.109 Not Initialized",          FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,        0, 0,                    FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define WSASendTableCount (sizeof(WSASendTable) / sizeof(WSASEND_TABLE))

NETSYNC_TYPE_THREAD  WSASendTestSessionNt =
{
    1,
    WSASendTableCount,
    L"xnetapi_nt.dll",
    "WSASendTestServer"
};

NETSYNC_TYPE_THREAD  WSASendTestSessionXbox =
{
    1,
    WSASendTableCount,
    L"xnetapi_xbox.dll",
    "WSASendTestServer"
};



// Callback routine

VOID CALLBACK WSASendCompletionRoutine(IN DWORD  dwError, IN DWORD  cbTransferred, IN LPWSAOVERLAPPED  lpOverlapped, IN DWORD  dwFlags) { return; }



VOID
WSASendTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests WSASend - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                  dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                   bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                 hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD    NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                 NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                 FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // WSASendRequest is the request sent to the server
    WSASEND_REQUEST        WSASendRequest;
    
    // sSocket is the socket descriptor
    SOCKET                 sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                 nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD                  dwBufferSize = 1;
    // iTimeout is the send and receive timeout value for the socket
    int                    iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL                   bNagle = FALSE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                 Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                   bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN            localname;
    // remotename is the remote address
    SOCKADDR_IN            remotename;

    // readfds is the set of sockets to check for a read condition
    fd_set                 readfds;
    // writefds is the set of sockets to check for a write condition
    fd_set                 writefds;
    // timeout is the timeout for select
    timeval                fdstimeout = { 1, 0 };

    // SendBuffer10 is the send buffer
    char                   SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                   SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                   RecvBufferLarge[BUFFER_LARGE_LEN + 1];
    // WSABuf is an array of send data structures
    WSABUF                 WSABuf[3];
    // dwBufferCount is the number of send data structures
    DWORD                  dwBufferCount;
    // nBufferlen is the total size of the data
    int                    nBufferlen;
    // dwFillBuffer is a counter to fill the buffers
    DWORD                  dwFillBuffer;
    // dwBytes is the number of bytes sent
    DWORD                  dwBytes;
    // nBytes is the number of bytes received
    int                    nBytes;
    // nSendCount is a counter to enumerate each send/recv
    int                    nSendCount;

    // WSASendBufferTable is the test buffer table to use for iterative send
    PWSASENDBUFFER_TABLE   WSASendBufferTable;
    // WSASendBufferTableCount is the number of elements within the test buffer table
    size_t                 WSASendBufferTableCount;
    // WSAOverlapped is the overlapped I/O structure
    WSAOVERLAPPED          WSAOverlapped;
    // dwFlags is the flags
    DWORD                  dwFlags;

    // dwReturnCode is the return code of WaitForSingleObject
    DWORD                  dwReturnCode;

    // bException indicates if an exception occurred
    BOOL                   bException;
    // iReturnCode is the return code of the operation
    int                    iReturnCode;
    // iLastError is the error code if the operation failed
    int                    iLastError;
    // bTestPassed indicates if the test passed
    BOOL                   bTestPassed;

    // szFunctionName is the function name
    CHAR                   szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "WSASend v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_WSASend+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_WSASend-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = WSASendTestSessionXbox;
    }
    else {
        NetsyncTypeSession = WSASendTestSessionNt;
    }

    // Initialize the overlapped I/O structure
    ZeroMemory(&WSAOverlapped, sizeof(WSAOverlapped));
    WSAOverlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < WSASendTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, WSASendTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, WSASendTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != WSASendTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, WSASendTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == WSASendTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != WSASendTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == WSASendTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = WSASendTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == WSASendTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == WSASendTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == WSASendTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == WSASendTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == WSASendTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == WSASendTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & WSASendTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & WSASendTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        if (TRUE == WSASendTable[dwTableIndex].bFillQueue) {
            // Set the buffer size
            setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
            setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
        }

        // Set the send and receive timeout values to 5 sec
        if ((0 != (SOCKET_TCP & WSASendTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & WSASendTable[dwTableIndex].dwSocket))) {
            setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & WSASendTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the socket to non-blocking mode
        if (TRUE == WSASendTable[dwTableIndex].bNonblock) {
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);
            bNonblocking = TRUE;
        }
        else {
            bNonblocking = FALSE;
        }

        // Bind the socket
        if (TRUE == WSASendTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if (TRUE == WSASendTable[dwTableIndex].bListen) {
            listen(sSocket, SOMAXCONN);
        }

        if (0 != (SOCKET_TCP & WSASendTable[dwTableIndex].dwSocket)) {
            WSASendBufferTable = WSASendBufferTcpTable;
            WSASendBufferTableCount = WSASendBufferTcpTableCount;
        }
        else {
            WSASendBufferTable = WSASendBufferUdpTable;
            WSASendBufferTableCount = WSASendBufferUdpTableCount;
        }

        if ((TRUE == WSASendTable[dwTableIndex].bAccept) || (TRUE == WSASendTable[dwTableIndex].bConnect)) {
            // Initialize the send request
            WSASendRequest.dwMessageId = WSASEND_REQUEST_MSG;
            if (0 != (SOCKET_TCP & WSASendTable[dwTableIndex].dwSocket)) {
                WSASendRequest.nSocketType = SOCK_STREAM;
            }
            else {
                WSASendRequest.nSocketType = SOCK_DGRAM;
            }
            WSASendRequest.Port = CurrentPort;
            WSASendRequest.bServerAccept = WSASendTable[dwTableIndex].bConnect;
            WSASendRequest.bFillQueue = WSASendTable[dwTableIndex].bFillQueue;
            WSASendRequest.nQueueLen = 0;
            WSASendRequest.bRemoteClose = WSASendTable[dwTableIndex].bRemoteClose;
            if (100 == WSASendTable[dwTableIndex].nDataBuffers) {
                WSASendRequest.nDataBuffers = WSASendTable[dwTableIndex].nDataBuffers * WSASendBufferTableCount;
            }
            else {
                WSASendRequest.nDataBuffers = (0 == WSASendTable[dwTableIndex].iReturnCode) ? WSASendTable[dwTableIndex].nDataBuffers : 0;
            }
            if (BUFFER_10 == WSASendTable[dwTableIndex].dwBuffer) {
                WSASendRequest.nBufferlen = BUFFER_10_LEN;
            }
            else if (BUFFER_SMALL == WSASendTable[dwTableIndex].dwBuffer) {
                WSASendRequest.nBufferlen = BUFFER_10_LEN - 1;
            }
            else if (BUFFER_TCPLARGE == WSASendTable[dwTableIndex].dwBuffer) {
                WSASendRequest.nBufferlen = BUFFER_TCPLARGE_LEN;
            }
            else if (BUFFER_UDPLARGE == WSASendTable[dwTableIndex].dwBuffer) {
                WSASendRequest.nBufferlen = BUFFER_UDPLARGE_LEN;
            }
            else if (BUFFER_UDPTOOLARGE == WSASendTable[dwTableIndex].dwBuffer) {
                WSASendRequest.nBufferlen = BUFFER_UDPLARGE_LEN + 1;
            }
            else if (BUFFER_TCPMULTI == WSASendTable[dwTableIndex].dwBuffer) {
                WSASendRequest.nBufferlen = BUFFER_TCPLARGE_LEN;
            }
            else if (BUFFER_UDPMULTI == WSASendTable[dwTableIndex].dwBuffer) {
                WSASendRequest.nBufferlen = BUFFER_UDPLARGE_LEN;
            }
            else {
                WSASendRequest.nBufferlen = 0;
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendRequest), (char *) &WSASendRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == WSASendTable[dwTableIndex].bConnect) {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = NetsyncInAddr;
                remotename.sin_port = htons(CurrentPort);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));

                if (0 != (SOCKET_TCP & WSASendTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&writefds);
                    FD_SET(sSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }
            }
            else {
                if (0 != (SOCKET_TCP & WSASendTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&readfds);
                    FD_SET(sSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);
                }

                // Accept the socket
                nsSocket = accept(sSocket, NULL, NULL);
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendRequest), (char *) &WSASendRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == WSASendTable[dwTableIndex].bFillQueue) {
                if (FALSE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                // Fill the queue
                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0)) {
                    WSASendRequest.nQueueLen++;
                    Sleep(SLEEP_ZERO_TIME);
                }
            }

            if (TRUE == WSASendTable[dwTableIndex].bRemoteClose) {
                if (TRUE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0));

                if (TRUE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }
        }

        // Shutdown the connection
        if (TRUE == WSASendTable[dwTableIndex].bShutdown) {
            shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSASendTable[dwTableIndex].nShutdown);
        }

        // Initialize the buffers
        sprintf(SendBuffer10, "%05d%05d", 1, 1);
        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
        }

        dwBufferCount = 1;
        if (BUFFER_10 == WSASendTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = SendBuffer10;

            nBufferlen = BUFFER_10_LEN;
        }
        else if (BUFFER_NULL == WSASendTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = NULL;

            nBufferlen = 0;
        }
        else if (BUFFER_NULLZERO == WSASendTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = 0;
            WSABuf[0].buf = NULL;

            nBufferlen = 0;
        }
        else if (BUFFER_ZERO == WSASendTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = 0;
            WSABuf[0].buf = SendBuffer10;

            nBufferlen = 0;
        }
        else if (BUFFER_ZEROCOUNT == WSASendTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = 0;
            WSABuf[0].buf = SendBuffer10;

            dwBufferCount = 0;
            nBufferlen = 0;
        }
        else if (BUFFER_SMALL == WSASendTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN - 1;
            WSABuf[0].buf = SendBuffer10;

            nBufferlen = BUFFER_10_LEN - 1;
        }
        else if (BUFFER_TCPLARGE == WSASendTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_TCPLARGE_LEN;
            WSABuf[0].buf = SendBufferLarge;

            nBufferlen = BUFFER_TCPLARGE_LEN;
        }
        else if (BUFFER_UDPLARGE == WSASendTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_UDPLARGE_LEN;
            WSABuf[0].buf = SendBufferLarge;

            nBufferlen = BUFFER_UDPLARGE_LEN;
        }
        else if (BUFFER_UDPTOOLARGE == WSASendTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_UDPLARGE_LEN + 1;
            WSABuf[0].buf = SendBufferLarge;

            nBufferlen = 0;
        }
        else if (BUFFER_TCPMULTI == WSASendTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = SendBufferLarge;

            WSABuf[1].len = 0;
            WSABuf[1].buf = NULL;

            WSABuf[2].len = BUFFER_TCPLARGE_LEN - BUFFER_10_LEN;
            WSABuf[2].buf = &SendBufferLarge[BUFFER_10_LEN];

            dwBufferCount = 3;
            nBufferlen = BUFFER_TCPLARGE_LEN;
        }
        else if (BUFFER_UDPMULTI == WSASendTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = SendBufferLarge;

            WSABuf[1].len = 0;
            WSABuf[1].buf = NULL;

            WSABuf[2].len = BUFFER_UDPLARGE_LEN - BUFFER_10_LEN;
            WSABuf[2].buf = &SendBufferLarge[BUFFER_10_LEN];

            dwBufferCount = 3;
            nBufferlen = BUFFER_UDPLARGE_LEN;
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & WSASendTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        __try {
            // Call WSASend
            iReturnCode = WSASend((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (BUFFER_NONE != WSASendTable[dwTableIndex].dwBuffer) ? WSABuf : NULL, (BUFFER_NONE != WSASendTable[dwTableIndex].dwBuffer) ? dwBufferCount : 0, &dwBytes, WSASendTable[dwTableIndex].nFlags, (0 == WSASendTable[dwTableIndex].nOverlapped) ? NULL : &WSAOverlapped, (FALSE == WSASendTable[dwTableIndex].bCompletionRoutine) ? NULL : WSASendCompletionRoutine);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == WSASendTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "WSASend RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "WSASend caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == WSASendTable[dwTableIndex].bFillQueue) {
                if (0 != WSASendTable[dwTableIndex].nOverlapped) {
                    if (SOCKET_ERROR != iReturnCode) {
                        bTestPassed = FALSE;
                        WSASendRequest.dwMessageId = WSASEND_CANCEL_MSG;
                        WSASendRequest.nDataBuffers = 0;
                    }
                    else {
                        // Get the last error code
                        iLastError = WSAGetLastError();

                        if (iLastError != WSA_IO_PENDING) {
                            xLog(hLog, XLL_FAIL, "WSASend iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, iLastError);
                            bTestPassed = FALSE;
                            WSASendRequest.dwMessageId = WSASEND_CANCEL_MSG;
                        }
                    }

                    // Send the send cancel
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendRequest), (char *) &WSASendRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (FALSE != bTestPassed) {
                        if (OVERLAPPED_IO_EVENT == WSASendTable[dwTableIndex].nOverlapped) {
                            // Wait on the overlapped I/O event
                            WaitForSingleObject(WSAOverlapped.hEvent, INFINITE);
                        }

                        // Get the overlapped I/O result
                        if (FALSE == WSAGetOverlappedResult((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSAOverlapped, &dwBytes, (OVERLAPPED_IO_RESULT == WSASendTable[dwTableIndex].nOverlapped) ? TRUE : FALSE, &dwFlags)) {
                            xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult returned FALSE - ec = %u", WSAGetLastError());
                        }
                        else {
                            iReturnCode = 0;
                        }
                    }
                }
                else {
                    if (SOCKET_ERROR != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "WSASend returned non-SOCKET_ERROR");
                    }
                    else {
                        // Get the last error code
                        iLastError = WSAGetLastError();

                        if (iLastError != WSAEWOULDBLOCK) {
                            xLog(hLog, XLL_FAIL, "WSASend iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, iLastError);
                        }
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendRequest), (char *) &WSASendRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (FALSE == bNonblocking) {
                        Nonblock = 0;
                        ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                    }
                    else {
                        FD_ZERO(&writefds);
                        FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &writefds);
                        select(0, NULL, &writefds, NULL, NULL);
                    }

                    // Call WSASend
                    iReturnCode = WSASend((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, dwBufferCount, &dwBytes, 0, NULL, NULL);
                }
            }

            if (-1 == WSASendTable[dwTableIndex].nDataBuffers) {
                if (SOCKET_ERROR == iReturnCode) {
                    bTestPassed = FALSE;
                    WSASendRequest.dwMessageId = WSASEND_CANCEL_MSG;
                    WSASendRequest.nDataBuffers = 0;
                }
                else {
                    dwReturnCode = WaitForSingleObject(WSAOverlapped.hEvent, 0);
                    if (WAIT_OBJECT_0 != dwReturnCode) {
                        xLog(hLog, XLL_FAIL, "WaitForSingleObject - EXPECTED: %u; RECEIVED: %u", WAIT_OBJECT_0, dwReturnCode);
                    }

                    // Get the overlapped I/O result
                    if (FALSE == WSAGetOverlappedResult((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSAOverlapped, &dwBytes, (OVERLAPPED_IO_RESULT == WSASendTable[dwTableIndex].nOverlapped) ? TRUE : FALSE, &dwFlags)) {
                        xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                    }
                    else {
                        iReturnCode = 0;
                    }
                }
            }

            if (TRUE == WSASendTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "WSASend did not RIP");
            }

            if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == WSASendTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != WSASendTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "WSASend iLastError - EXPECTED: %u; RECEIVED: %u", WSASendTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "WSASend iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSASend returned SOCKET_ERROR - ec = %u", WSAGetLastError());

                if (0 != WSASendRequest.nDataBuffers) {
                    // Send the send cancel
                    WSASendRequest.dwMessageId = WSASEND_CANCEL_MSG;
                    WSASendRequest.nDataBuffers = 0;
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendRequest), (char *) &WSASendRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);
                }
            }
            else if (SOCKET_ERROR == WSASendTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSASend returned non-SOCKET_ERROR");
            }
            else {
                if (nBufferlen != (int) dwBytes) {
                    xLog(hLog, XLL_FAIL, "WSASend return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwBytes);
                    bTestPassed = FALSE;
                }

                // Send the read request
                NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendRequest), (char *) &WSASendRequest);

                // Wait for the read complete
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                NetsyncFreeMessage(pMessage);

                if ((TRUE != WSASendTable[dwTableIndex].bFillQueue) && (TRUE != WSASendTable[dwTableIndex].bShutdown)) {
                    // Call recv
                    if (0 != (SOCKET_TCP & WSASendTable[dwTableIndex].dwSocket)) {
                        if (0 != nBufferlen) {
                            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                            nBytes = 0;

                            do {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                if (1 == iReturnCode) {
                                    iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                }
                                else if (0 == iReturnCode) {
                                    iReturnCode = SOCKET_ERROR;
                                    SetLastError(WSAETIMEDOUT);
                                }

                                if (SOCKET_ERROR != iReturnCode) {
                                    nBytes += iReturnCode;
                                }
                            } while (SOCKET_ERROR != iReturnCode);

                            if (WSAETIMEDOUT != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else if (nBufferlen != nBytes) {
                                xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, nBytes);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }
                    }
                    else {
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                        if (TRUE == bNonblocking) {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                            select(0, &readfds, NULL, NULL, NULL);
                        }

                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0);
                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else if (nBufferlen != iReturnCode) {
                            xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, iReturnCode);
                            bTestPassed = FALSE;
                        }
                        else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                            bTestPassed = FALSE;
                        }
                    }
                }

                if (3 == WSASendTable[dwTableIndex].nDataBuffers) {
                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }

                    // Switch the blocking mode
                    Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                    bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                    // Call WSASend
                    iReturnCode = WSASend((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, dwBufferCount, &dwBytes, WSASendTable[dwTableIndex].nFlags, NULL, NULL);

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "WSASend returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                        WSASendRequest.dwMessageId = WSASEND_CANCEL_MSG;
                    }
                    else {
                        if (nBufferlen != (int) dwBytes) {
                            xLog(hLog, XLL_FAIL, "WSASend return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwBytes);
                            bTestPassed = FALSE;
                        }

                        WSASendRequest.dwMessageId = WSASEND_REQUEST_MSG;
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendRequest), (char *) &WSASendRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (SOCKET_ERROR != iReturnCode) {
                        // Call recv
                        if (0 != (SOCKET_TCP & WSASendTable[dwTableIndex].dwSocket)) {
                            if (0 != nBufferlen) {
                                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                                nBytes = 0;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                    }
                                    else if (0 == iReturnCode) {
                                        iReturnCode = SOCKET_ERROR;
                                        SetLastError(WSAETIMEDOUT);
                                    }

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                } while (SOCKET_ERROR != iReturnCode);

                                if (WSAETIMEDOUT != WSAGetLastError()) {
                                    xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else if (nBufferlen != nBytes) {
                                    xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, nBytes);
                                    bTestPassed = FALSE;
                                }
                                else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                        else {
                            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                            if (TRUE == bNonblocking) {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);
                            }

                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0);
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else if (nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }
                    }

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 3, 3);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }

                    // Switch the blocking mode
                    Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                    bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                    // Call WSASend
                    iReturnCode = WSASend((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, dwBufferCount, &dwBytes, WSASendTable[dwTableIndex].nFlags, NULL, NULL);

                    if (SOCKET_ERROR == iReturnCode) {
                        xLog(hLog, XLL_FAIL, "WSASend returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        bTestPassed = FALSE;
                        WSASendRequest.dwMessageId = WSASEND_CANCEL_MSG;
                    }
                    else {
                        if (nBufferlen != (int) dwBytes) {
                            xLog(hLog, XLL_FAIL, "WSASend return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwBytes);
                            bTestPassed = FALSE;
                        }

                        WSASendRequest.dwMessageId = WSASEND_REQUEST_MSG;
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendRequest), (char *) &WSASendRequest);

                    // Wait for the read complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if (SOCKET_ERROR != iReturnCode) {
                        // Call recv
                        if (0 != (SOCKET_TCP & WSASendTable[dwTableIndex].dwSocket)) {
                            if (0 != nBufferlen) {
                                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                                nBytes = 0;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                    }
                                    else if (0 == iReturnCode) {
                                        iReturnCode = SOCKET_ERROR;
                                        SetLastError(WSAETIMEDOUT);
                                    }

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                } while (SOCKET_ERROR != iReturnCode);

                                if (WSAETIMEDOUT != WSAGetLastError()) {
                                    xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else if (nBufferlen != nBytes) {
                                    xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, nBytes);
                                    bTestPassed = FALSE;
                                }
                                else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                        else {
                            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                            if (TRUE == bNonblocking) {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);
                            }

                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0);
                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else if (nBufferlen != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, iReturnCode);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }
                        }
                    }
                }
                else if (100 == WSASendTable[dwTableIndex].nDataBuffers) {
                    for (nSendCount = 0; nSendCount < (int) (WSASendTable[dwTableIndex].nDataBuffers * WSASendBufferTableCount); nSendCount++) {
                        // Initialize the buffers
                        sprintf(SendBuffer10, "%05d%05d", 2 + nSendCount, 2 + nSendCount);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                        }

                        dwBufferCount = 1;
                        if (BUFFER_10 == WSASendBufferTable[nSendCount % WSASendBufferTableCount].dwBuffer) {
                            WSABuf[0].len = BUFFER_10_LEN;
                            WSABuf[0].buf = SendBuffer10;

                            nBufferlen = BUFFER_10_LEN;
                        }
                        else if (BUFFER_NULLZERO == WSASendBufferTable[nSendCount % WSASendBufferTableCount].dwBuffer) {
                            WSABuf[0].len = 0;
                            WSABuf[0].buf = NULL;

                            nBufferlen = 0;
                        }
                        else if (BUFFER_TCPLARGE == WSASendBufferTable[nSendCount % WSASendBufferTableCount].dwBuffer) {
                            WSABuf[0].len = BUFFER_TCPLARGE_LEN;
                            WSABuf[0].buf = SendBufferLarge;

                            nBufferlen = BUFFER_TCPLARGE_LEN;
                        }
                        else if (BUFFER_UDPLARGE == WSASendBufferTable[nSendCount % WSASendBufferTableCount].dwBuffer) {
                            WSABuf[0].len = BUFFER_UDPLARGE_LEN;
                            WSABuf[0].buf = SendBufferLarge;

                            nBufferlen = BUFFER_UDPLARGE_LEN;
                        }
                        else if (BUFFER_TCPMULTI == WSASendBufferTable[nSendCount % WSASendBufferTableCount].dwBuffer) {
                            WSABuf[0].len = BUFFER_10_LEN;
                            WSABuf[0].buf = SendBufferLarge;

                            WSABuf[1].len = 0;
                            WSABuf[1].buf = NULL;

                            WSABuf[2].len = BUFFER_TCPLARGE_LEN - BUFFER_10_LEN;
                            WSABuf[2].buf = &SendBufferLarge[BUFFER_10_LEN];

                            dwBufferCount = 3;
                            nBufferlen = BUFFER_TCPLARGE_LEN;
                        }
                        else if (BUFFER_UDPMULTI == WSASendBufferTable[nSendCount % WSASendBufferTableCount].dwBuffer) {
                            WSABuf[0].len = BUFFER_10_LEN;
                            WSABuf[0].buf = SendBufferLarge;

                            WSABuf[1].len = 0;
                            WSABuf[1].buf = NULL;

                            WSABuf[2].len = BUFFER_UDPLARGE_LEN - BUFFER_10_LEN;
                            WSABuf[2].buf = &SendBufferLarge[BUFFER_10_LEN];

                            dwBufferCount = 3;
                            nBufferlen = BUFFER_UDPLARGE_LEN;
                        }

                        xLog(hLog, XLL_INFO, "Iteration %d", nSendCount);

                        // Call WSASend
                        iReturnCode = WSASend((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, dwBufferCount, &dwBytes, 0, NULL, NULL);

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "WSASend returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                            WSASendRequest.dwMessageId = WSASEND_CANCEL_MSG;
                        }
                        else {
                            if (nBufferlen != (int) dwBytes) {
                                xLog(hLog, XLL_FAIL, "WSASend return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwBytes);
                                bTestPassed = FALSE;
                            }

                            WSASendRequest.dwMessageId = WSASEND_REQUEST_MSG;
                        }

                        // Send the read request
                        WSASendRequest.nBufferlen = nBufferlen;
                        NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendRequest), (char *) &WSASendRequest);

                        // Wait for the read complete
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);

                        if (SOCKET_ERROR != iReturnCode) {
                            // Call recv
                            if (0 != (SOCKET_TCP & WSASendTable[dwTableIndex].dwSocket)) {
                                if (0 != nBufferlen) {
                                    ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
                                    nBytes = 0;

                                    do {
                                        FD_ZERO(&readfds);
                                        FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                        iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                        if (1 == iReturnCode) {
                                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &RecvBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                        }
                                        else if (0 == iReturnCode) {
                                            iReturnCode = SOCKET_ERROR;
                                            SetLastError(WSAETIMEDOUT);
                                        }

                                        if (SOCKET_ERROR != iReturnCode) {
                                            nBytes += iReturnCode;
                                        }
                                    } while (SOCKET_ERROR != iReturnCode);

                                    if (WSAETIMEDOUT != WSAGetLastError()) {
                                        xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                        bTestPassed = FALSE;
                                    }
                                    else if (nBufferlen != nBytes) {
                                        xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, nBytes);
                                        bTestPassed = FALSE;
                                    }
                                    else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                        xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                        bTestPassed = FALSE;
                                    }
                                }
                            }
                            else {
                                ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                                if (TRUE == bNonblocking) {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                    select(0, &readfds, NULL, NULL, NULL);
                                }

                                iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0);
                                if (SOCKET_ERROR == iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "recv returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else if (nBufferlen != iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "recv return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, iReturnCode);
                                    bTestPassed = FALSE;
                                }
                                else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "WSASend succeeded");
                }
            }
        }

        // Switch the blocking mode
        if (WSASendTable[dwTableIndex].bNonblock != bNonblocking) {
            Nonblock = (TRUE == WSASendTable[dwTableIndex].bNonblock) ? 1 : 0;
            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
            bNonblocking = WSASendTable[dwTableIndex].bNonblock;
        }

        if ((TRUE == WSASendTable[dwTableIndex].bAccept) || (TRUE == WSASendTable[dwTableIndex].bConnect)) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSASendRequest), (char *) &WSASendRequest);
        }

        // Close the socket
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & WSASendTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & WSASendTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & WSASendTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    CloseHandle(WSAOverlapped.hEvent);

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
WSASendTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests WSASend - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long            FromInAddr;
    // dwMessageType is the type of received message
    DWORD             dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD             dwMessageSize;
    // pMessage is a pointer to the received message
    char              *pMessage;
    // WSASendRequest is the request
    WSASEND_REQUEST   WSASendRequest;
    // WSASendComplete is the result
    WSASEND_COMPLETE  WSASendComplete;

    // sSocket is the socket descriptor
    SOCKET            sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET            nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD             dwBufferSize = 1;
    // iTimeout is the send and receive timeout value for the socket
    int               iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL              bNagle = FALSE;
    // nQueueLen is the size of the queue
    int               nQueueLen;

    // localname is the local address
    SOCKADDR_IN       localname;
    // remotename is the remote address
    SOCKADDR_IN       remotename;

    // readfds is the set of sockets to check for a read condition
    fd_set            readfds;
    // timeout is the timeout for select
    timeval           fdstimeout = { 1, 0 };

    // SendBufferLarge is the large send buffer
    char              SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // nBytes is the number of bytes sent/received
    int               nBytes;
    // nSendCount is a counter to enumerate each send
    int               nSendCount;

    // iReturnCode is the return code of the operation
    int               iReturnCode;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&WSASendRequest, pMessage, sizeof(WSASendRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, WSASendRequest.nSocketType, 0);

        if (TRUE == WSASendRequest.bFillQueue) {
            // Set the buffer size
            setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
            setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
        }

        // Set the send and receive timeout values to 5 sec
        setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

        if (SOCK_STREAM == WSASendRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(WSASendRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if ((SOCK_STREAM == WSASendRequest.nSocketType) && (TRUE == WSASendRequest.bServerAccept)) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(WSASendRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        WSASendComplete.dwMessageId = WSASEND_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendComplete), (char *) &WSASendComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if ((SOCK_STREAM == WSASendRequest.nSocketType) && (TRUE == WSASendRequest.bServerAccept)) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        if (TRUE == WSASendRequest.bRemoteClose) {
            // Close the sockets
            if (INVALID_SOCKET != nsSocket) {
                shutdown(nsSocket, SD_BOTH);
                closesocket(nsSocket);
                nsSocket = INVALID_SOCKET;
            }

            if (INVALID_SOCKET != sSocket) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
                sSocket = INVALID_SOCKET;
            }
        }

        // Send the complete
        WSASendComplete.dwMessageId = WSASEND_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendComplete), (char *) &WSASendComplete);

        if (TRUE == WSASendRequest.bFillQueue) {
            // Wait for the request
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            nQueueLen = ((PWSASEND_REQUEST) pMessage)->nQueueLen;
            CopyMemory(&WSASendRequest, pMessage, sizeof(WSASendRequest));
            NetsyncFreeMessage(pMessage);

            if (WSASEND_CANCEL_MSG != WSASendRequest.dwMessageId) {
                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                for (nSendCount = 0; nSendCount < nQueueLen; nSendCount++) {
                    recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0);
                }
            }

            // Send the complete
            WSASendComplete.dwMessageId = WSASEND_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendComplete), (char *) &WSASendComplete);
        }

        if ((0 < WSASendRequest.nDataBuffers) || (-1 == WSASendRequest.nDataBuffers)) {
            // Wait for the request
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            CopyMemory(&WSASendRequest, pMessage, sizeof(WSASendRequest));
            NetsyncFreeMessage(pMessage);

            if ((WSASEND_CANCEL_MSG != WSASendRequest.dwMessageId) && ((0 != WSASendRequest.nBufferlen) || (SOCK_STREAM != WSASendRequest.nSocketType))) {
                if (SOCK_DGRAM == WSASendRequest.nSocketType) {
                    ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));

                    if (SOCKET_ERROR != recv(sSocket, SendBufferLarge, sizeof(SendBufferLarge), 0)) {
                        send(sSocket, SendBufferLarge, strlen(SendBufferLarge), 0);
                    }
                }
                else {
                    ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                    nBytes = 0;

                    do {
                        FD_ZERO(&readfds);
                        FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                        iReturnCode = SOCKET_ERROR;
                        if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                            iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], BUFFER_10_LEN, 0);
                        }

                        if (SOCKET_ERROR != iReturnCode) {
                            nBytes += iReturnCode;
                        }
                    } while ((SOCKET_ERROR != iReturnCode) && (nBytes < WSASendRequest.nBufferlen));

                    if (nBytes == WSASendRequest.nBufferlen) {
                        send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                    }
                }
            }

            // Send the complete
            WSASendComplete.dwMessageId = WSASEND_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendComplete), (char *) &WSASendComplete);

            if (3 == WSASendRequest.nDataBuffers) {
                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                if (WSASEND_CANCEL_MSG != ((PWSASEND_REQUEST) pMessage)->dwMessageId) {
                    if (SOCK_DGRAM == WSASendRequest.nSocketType) {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));

                        if (SOCKET_ERROR != recv(sSocket, SendBufferLarge, sizeof(SendBufferLarge), 0)) {
                            send(sSocket, SendBufferLarge, strlen(SendBufferLarge), 0);
                        }
                    }
                    else {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                        nBytes = 0;

                        do {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                            iReturnCode = SOCKET_ERROR;
                            if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                                iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], BUFFER_10_LEN, 0);
                            }

                            if (SOCKET_ERROR != iReturnCode) {
                                nBytes += iReturnCode;
                            }
                        } while ((SOCKET_ERROR != iReturnCode) && (nBytes < WSASendRequest.nBufferlen));

                        if (nBytes == WSASendRequest.nBufferlen) {
                            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                        }
                    }
                }
                NetsyncFreeMessage(pMessage);

                // Send the complete
                WSASendComplete.dwMessageId = WSASEND_COMPLETE_MSG;
                NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendComplete), (char *) &WSASendComplete);

                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                if (WSASEND_CANCEL_MSG != ((PWSASEND_REQUEST) pMessage)->dwMessageId) {
                    if (SOCK_DGRAM == WSASendRequest.nSocketType) {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));

                        if (SOCKET_ERROR != recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, sizeof(SendBufferLarge), 0)) {
                            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, strlen(SendBufferLarge), 0);
                        }
                    }
                    else {
                        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                        nBytes = 0;

                        do {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                            iReturnCode = SOCKET_ERROR;
                            if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                                iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], BUFFER_10_LEN, 0);
                            }

                            if (SOCKET_ERROR != iReturnCode) {
                                nBytes += iReturnCode;
                            }
                        } while ((SOCKET_ERROR != iReturnCode) && (nBytes < WSASendRequest.nBufferlen));

                        if (nBytes == WSASendRequest.nBufferlen) {
                            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                        }
                    }
                }
                NetsyncFreeMessage(pMessage);

                // Send the complete
                WSASendComplete.dwMessageId = WSASEND_COMPLETE_MSG;
                NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendComplete), (char *) &WSASendComplete);
            }
            else if (100 <= WSASendRequest.nDataBuffers) {
                for (nSendCount = 0; nSendCount < WSASendRequest.nDataBuffers; nSendCount++) {
                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                    if ((0 != ((PWSASEND_REQUEST) pMessage)->nBufferlen) || (SOCK_STREAM != WSASendRequest.nSocketType)) {
                        if (WSASEND_CANCEL_MSG != ((PWSASEND_REQUEST) pMessage)->dwMessageId) {
                            if (SOCK_DGRAM == WSASendRequest.nSocketType) {
                                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));

                                if (SOCKET_ERROR != recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, sizeof(SendBufferLarge), 0)) {
                                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, strlen(SendBufferLarge), 0);
                                }
                            }
                            else {
                                ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
                                nBytes = 0;

                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = SOCKET_ERROR;
                                    if (1 == select(0, &readfds, NULL, NULL, &fdstimeout)) {
                                        iReturnCode = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &SendBufferLarge[nBytes], BUFFER_10_LEN, 0);
                                    }

                                    if (SOCKET_ERROR != iReturnCode) {
                                        nBytes += iReturnCode;
                                    }
                                } while ((SOCKET_ERROR != iReturnCode) && (nBytes < ((PWSASEND_REQUEST) pMessage)->nBufferlen));

                                if (nBytes == ((PWSASEND_REQUEST) pMessage)->nBufferlen) {
                                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, nBytes, 0);
                                }
                            }
                        }
                    }
                    NetsyncFreeMessage(pMessage);

                    // Send the complete
                    WSASendComplete.dwMessageId = WSASEND_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSASendComplete), (char *) &WSASendComplete);
                }
            }
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\wsagetoverlappedresult.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  wsagetoverlappedresult.c

Abstract:

  This modules tests WSAGetOverlappedResult

Author:

  Steven Kehrli (steveke) 29-Jan-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// WSAGetOverlappedResult messages

#define WSAGETOVERLAPPEDRESULT_REQUEST_MSG   NETSYNC_MSG_USER + 240 + 1
#define WSAGETOVERLAPPEDRESULT_COMPLETE_MSG  NETSYNC_MSG_USER + 240 + 2

typedef struct _WSAGETOVERLAPPEDRESULT_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bServerSend;
    BOOL     bServerRecv;
    int      nQueueLen;
    BOOL     bComplete;
} WSAGETOVERLAPPEDRESULT_REQUEST, *PWSAGETOVERLAPPEDRESULT_REQUEST;

typedef struct _WSAGETOVERLAPPEDRESULT_COMPLETE {
    DWORD    dwMessageId;
} WSAGETOVERLAPPEDRESULT_COMPLETE, *PWSAGETOVERLAPPEDRESULT_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define WSAOVERLAPPED_NULL           1
#define WSAOVERLAPPED_NULL_EVENT     2
#define WSAOVERLAPPED_VALID          3

#define WSA_CANCEL                   0x00000001
#define WSA_SECOND_CALL              0x00000002
#define WSASEND_FUNCTION             0x00000010
#define WSASENDTO_FUNCTION           0x00000020
#define WSARECV_FUNCTION             0x00000040
#define WSARECVFROM_FUNCTION         0x00000080

typedef struct WSAGETOVERLAPPEDRESULT_TABLE {
    CHAR   szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL   bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL   bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD  dwSocket;                                // dwSocket indicates the socket to be created
    DWORD  dwFunction;                              // dwFunction specifies the function to start the pending overlapped operation
    DWORD  dwOverlapped;                            // dwOverlapped specifies the overlapped structure
    BOOL   bPartial;                                // bPartial indicates if the MSG_PARTIAL flag should be present
    BOOL   bComplete;                               // bComplete indicates if the operation completes before the result call
    BOOL   bBytes;                                  // bBytes indicates pdwBytes is valid
    BOOL   bWait;                                   // bWait specifies if the function waits until the pending overlapped operation is complete
    BOOL   bFlags;                                  // bFlags indicates pdwFlags is valid
    BOOL   bReturnCode;                             // bReturnCode is the return code of WSAGetOverlappedResult
    int    iLastError;                              // iLastError is the error code if the operation failed
    BOOL   bRIP;                                    // Specifies a RIP test case
} WSAGETOVERLAPPEDRESULT_TABLE, *PWSAGETOVERLAPPEDRESULT_TABLE;

static WSAGETOVERLAPPEDRESULT_TABLE WSAGetOverlappedResultTable[] =
{
    { "24.1 Not Initialized",            FALSE, FALSE, SOCKET_INVALID_SOCKET,      0,                                                      WSAOVERLAPPED_NULL,       FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, WSANOTINITIALISED, FALSE },
    { "24.2 s = INT_MIN",                TRUE,  TRUE,  SOCKET_INT_MIN,             0,                                                      WSAOVERLAPPED_NULL,       FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, WSAENOTSOCK,       FALSE },
    { "24.3 s = -1",                     TRUE,  TRUE,  SOCKET_NEG_ONE,             0,                                                      WSAOVERLAPPED_NULL,       FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, WSAENOTSOCK,       FALSE },
    { "24.4 s = 0",                      TRUE,  TRUE,  SOCKET_ZERO,                0,                                                      WSAOVERLAPPED_NULL,       FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, WSAENOTSOCK,       FALSE },
    { "24.5 s = INT_MAX",                TRUE,  TRUE,  SOCKET_INT_MAX,             0,                                                      WSAOVERLAPPED_NULL,       FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, WSAENOTSOCK,       FALSE },
    { "24.6 s = INVALID_SOCKET",         TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      0,                                                      WSAOVERLAPPED_NULL,       FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, WSAENOTSOCK,       FALSE },
    { "24.7 TCP Send WDone",             TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.8 TCP Send WPend",             TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.9 TCP Send 2 WDone",           TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.10 TCP Send 2 WPend",          TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.11 TCP Send WCanc",            TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSA_CANCEL,                          WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.12 TCP Send Done",             TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.13 TCP Send Pend",             TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.14 TCP Send 2 Done",           TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.15 TCP Send 2 Pend",           TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.16 TCP Send Canc",             TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSA_CANCEL,                          WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.17 TCP Send NULL IO",          TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION,                                       WSAOVERLAPPED_NULL,       FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.18 TCP Send NULL Event",       TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION,                                       WSAOVERLAPPED_NULL_EVENT, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.19 TCP Send NULL Bytes",       TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  FALSE, TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.20 TCP Send NULL Flags",       TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, WSAEFAULT,         TRUE  },
    { "24.21 TCP SendTo WDone",          TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION,                                     WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.22 TCP SendTo WPend",          TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION,                                     WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.23 TCP SendTo 2 WDone",        TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSA_SECOND_CALL,                   WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.24 TCP SendTo 2 WPend",        TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSA_SECOND_CALL,                   WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.25 TCP SendTo WCanc",          TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSA_CANCEL,                        WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.26 TCP SendTo Done",           TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION,                                     WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.27 TCP SendTo Pend",           TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION,                                     WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.28 TCP SendTo 2 Done",         TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSA_SECOND_CALL,                   WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.29 TCP SendTo 2 Pend",         TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSA_SECOND_CALL,                   WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.30 TCP SendTo Canc",           TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSA_CANCEL,                        WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.31 TCP SendTo NULL IO",        TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION,                                     WSAOVERLAPPED_NULL,       FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.32 TCP SendTo NULL Event",     TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION,                                     WSAOVERLAPPED_NULL_EVENT, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.33 TCP SendTo NULL Bytes",     TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION,                                     WSAOVERLAPPED_VALID,      FALSE, TRUE,  FALSE, TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.34 TCP SendTo NULL Flags",     TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION,                                     WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, WSAEFAULT,         TRUE  },
    { "24.35 TCP Recv WDone",            TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.36 TCP Recv WPend",            TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.37 TCP Recv 2 WDone",          TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.38 TCP Recv 2 WPend",          TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.39 TCP Recv WCanc",            TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION | WSA_CANCEL,                          WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.40 TCP Recv Done",             TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.41 TCP Recv Pend",             TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.42 TCP Recv 2 Done",           TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.43 TCP Recv 2 Pend",           TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.44 TCP Recv Canc",             TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION | WSA_CANCEL,                          WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.45 TCP Recv NULL IO",          TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_NULL,       FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.46 TCP Recv NULL Event",       TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_NULL_EVENT, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.47 TCP Recv NULL Bytes",       TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  FALSE, TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.48 TCP Recv NULL Flags",       TRUE,  TRUE,  SOCKET_TCP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, WSAEFAULT,         TRUE  },
    { "24.49 TCP RecvFrom WDone",        TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION,                                   WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.50 TCP RecvFrom WPend",        TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION,                                   WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.51 TCP RecvFrom 2 WDone",      TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION | WSA_SECOND_CALL,                 WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.52 TCP RecvFrom 2 WPend",      TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION | WSA_SECOND_CALL,                 WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.53 TCP RecvFrom WCanc",        TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION | WSA_CANCEL,                      WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.54 TCP RecvFrom Done",         TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION,                                   WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.55 TCP RecvFrom Pend",         TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION,                                   WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.56 TCP RecvFrom 2 Done",       TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION | WSA_SECOND_CALL,                 WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.57 TCP RecvFrom 2 Pend",       TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION | WSA_SECOND_CALL,                 WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.58 TCP RecvFrom Canc",         TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION | WSA_CANCEL,                      WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.59 TCP RecvFrom NULL IO",      TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION,                                   WSAOVERLAPPED_NULL,       FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.60 TCP RecvFrom NULL Event",   TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION,                                   WSAOVERLAPPED_NULL_EVENT, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.61 TCP RecvFrom NULL Bytes",   TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION,                                   WSAOVERLAPPED_VALID,      FALSE, TRUE,  FALSE, TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.62 TCP RecvFrom NULL Flags",   TRUE,  TRUE,  SOCKET_TCP,                 WSARECVFROM_FUNCTION,                                   WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, WSAEFAULT,         TRUE  },
    { "24.63 TCP Send/Recv WDone",       TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECV_FUNCTION,                    WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.64 TCP Send/Recv WPend",       TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECV_FUNCTION,                    WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.65 TCP Send/Recv WCanc",       TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECV_FUNCTION | WSA_CANCEL,       WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.66 TCP Send/Recv Done",        TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECV_FUNCTION,                    WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.67 TCP Send/Recv Pend",        TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECV_FUNCTION,                    WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.68 TCP Send/Recv Canc",        TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECV_FUNCTION | WSA_CANCEL,       WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.69 TCP SendTo/Recv WDone",     TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECV_FUNCTION,                  WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.70 TCP SendTo/Recv WPend",     TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECV_FUNCTION,                  WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.71 TCP SendTo/Recv WCanc",     TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECV_FUNCTION | WSA_CANCEL,     WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.72 TCP SendTo/Recv Done",      TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECV_FUNCTION,                  WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.73 TCP SendTo/Recv Pend",      TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECV_FUNCTION,                  WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.74 TCP SendTo/Recv Canc",      TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECV_FUNCTION | WSA_CANCEL,     WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.75 TCP Send/RecvFrom WDone",   TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECVFROM_FUNCTION,                WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.76 TCP Send/RecvFrom WPend",   TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECVFROM_FUNCTION,                WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.77 TCP Send/RecvFrom WCanc",   TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECVFROM_FUNCTION | WSA_CANCEL,   WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.78 TCP Send/RecvFrom Done",    TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECVFROM_FUNCTION,                WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.79 TCP Send/RecvFrom Pend",    TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECVFROM_FUNCTION,                WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.80 TCP Send/RecvFrom Canc",    TRUE,  TRUE,  SOCKET_TCP,                 WSASEND_FUNCTION | WSARECVFROM_FUNCTION | WSA_CANCEL,   WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.81 TCP SendTo/RecvFrom WDone", TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECVFROM_FUNCTION,              WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.82 TCP SendTo/RecvFrom WPend", TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECVFROM_FUNCTION,              WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.83 TCP SendTo/RecvFrom WCanc", TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECVFROM_FUNCTION | WSA_CANCEL, WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.84 TCP SendTo/RecvFrom Done",  TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECVFROM_FUNCTION,              WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.85 TCP SendTo/RecvFrom Pend",  TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECVFROM_FUNCTION,              WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.86 TCP SendTo/RecvFrom Canc",  TRUE,  TRUE,  SOCKET_TCP,                 WSASENDTO_FUNCTION | WSARECVFROM_FUNCTION | WSA_CANCEL, WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.87 UDP Recv WDone",            TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.88 UDP Recv WPend",            TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.89 UDP Recv WPart",            TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEMSGSIZE,       FALSE },
    { "24.90 UDP Recv 2 WDone",          TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.91 UDP Recv 2 WPend",          TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.92 UDP Recv 2 WPart",          TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEMSGSIZE,       FALSE },
    { "24.93 UDP Recv WCanc",            TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_CANCEL,                          WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.94 UDP Recv Done",             TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.95 UDP Recv Pend",             TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.96 UDP Recv Part",             TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, WSAEMSGSIZE,       FALSE },
    { "24.97 UDP Recv 2 Done",           TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.98 UDP Recv 2 Pend",           TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.99 UDP Recv 2 Part",           TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, WSAEMSGSIZE,       FALSE },
    { "24.100 UDP Recv Canc",            TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_CANCEL,                          WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.101 UDP Recv NULL IO",         TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_NULL,       FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.102 UDP Recv NULL Event",      TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_NULL_EVENT, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.103 UDP Recv NULL Bytes",      TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  FALSE, TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.104 UDP Recv NULL Flags",      TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, WSAEFAULT,         TRUE  },
    { "24.105 UDP RecvFrom WDone",       TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.106 UDP RecvFrom WPend",       TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.107 UDP RecvFrom WPart",       TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEMSGSIZE,       FALSE },
    { "24.108 UDP RecvFrom 2 WDone",     TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.109 UDP RecvFrom 2 WPend",     TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "24.110 UDP RecvFrom 2 WPart",     TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEMSGSIZE,       FALSE },
    { "24.111 UDP RecvFrom WCanc",       TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_CANCEL,                          WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.112 UDP RecvFrom Done",        TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.113 UDP RecvFrom Pend",        TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.114 UDP RecvFrom Part",        TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, WSAEMSGSIZE,       FALSE },
    { "24.115 UDP RecvFrom 2 Done",      TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "24.116 UDP RecvFrom 2 Pend",      TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSA_IO_INCOMPLETE, FALSE },
    { "24.117 UDP RecvFrom 2 Part",      TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_SECOND_CALL,                     WSAOVERLAPPED_VALID,      TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, WSAEMSGSIZE,       FALSE },
    { "24.118 UDP RecvFrom Canc",        TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION | WSA_CANCEL,                          WSAOVERLAPPED_VALID,      FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, WSAECANCELLED,     FALSE },
    { "24.119 UDP RecvFrom NULL IO",     TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_NULL,       FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.120 UDP RecvFrom NULL Event",  TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_NULL_EVENT, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.121 UDP RecvFrom NULL Bytes",  TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  FALSE, TRUE,  TRUE,  FALSE, WSAEFAULT,         TRUE  },
    { "24.122 UDP RecvFrom NULL Flags",  TRUE,  TRUE,  SOCKET_UDP,                 WSARECV_FUNCTION,                                       WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, WSAEFAULT,         TRUE  },
    { "24.123 Closed Socket TCP",        TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, 0,                                                      WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAENOTSOCK,       FALSE },
    { "24.124 Closed Socket UDP",        TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, 0,                                                      WSAOVERLAPPED_VALID,      FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAENOTSOCK,       FALSE },
    { "24.125 Not Initialized",          FALSE, FALSE, SOCKET_INVALID_SOCKET,      0,                                                      WSAOVERLAPPED_NULL,       FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, WSANOTINITIALISED, FALSE }
};

#define WSAGetOverlappedResultTableCount (sizeof(WSAGetOverlappedResultTable) / sizeof(WSAGETOVERLAPPEDRESULT_TABLE))

NETSYNC_TYPE_THREAD  WSAGetOverlappedResultTestSessionNt =
{
    1,
    WSAGetOverlappedResultTableCount,
    L"xnetapi_nt.dll",
    "WSAGetOverlappedResultTestServer"
};

NETSYNC_TYPE_THREAD  WSAGetOverlappedResultTestSessionXbox =
{
    1,
    WSAGetOverlappedResultTableCount,
    L"xnetapi_xbox.dll",
    "WSAGetOverlappedResultTestServer"
};



VOID
WSAGetOverlappedResultTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests WSAGetOverlappedResult - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                           lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                           lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                           dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                            bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                         WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                          hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD             NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                          NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                         LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                         HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                         CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                          FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                           dwMessageSize;
    // pMessage is a pointer to the received message
    char                            *pMessage;
    // WSAGetOverlappedResultRequest is the request sent to the server
    WSAGETOVERLAPPEDRESULT_REQUEST  WSAGetOverlappedResultRequest;
    
    // sSocket is the socket descriptor
    SOCKET                          sSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD                           dwBufferSize = BUFFER_10_LEN;
    // bNagle indicates if Nagle is enabled
    BOOL                            bNagle = FALSE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                          Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                            bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN                     localname;
    // remotename1 is the first remote address
    SOCKADDR_IN                     remotename1;
    // remotename2 is the second remote address
    SOCKADDR_IN                     remotename2;
    // namelen is the size of the address buffer
    int                             namelen;

    // writefds is the set of sockets to check for a write condition
    fd_set                          writefds;

    // SendBuffer10 is the send buffer
    char                            SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                            SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBuffer10 is the recv buffer
    char                            RecvBuffer10[BUFFER_10_LEN + 1];

    // dwFirstTime is the first tick count
    DWORD                           dwFirstTime;
    // dwSecondTime is the second tick count
    DWORD                           dwSecondTime;

    // WSASendBuf is the send WSABUF structure
    WSABUF                          WSASendBuf;
    // WSARecvBuf is the recv WSABUF structure
    WSABUF                          WSARecvBuf;

    // dwSendBytes1 is the number of bytes transferred for the function call
    DWORD                           dwSendBytes1;
    // dwSendBytes2 is the number of bytes transferred for the result call
    DWORD                           dwSendBytes2;
    // dwRecvBytes1 is the number of bytes transferred for the function call
    DWORD                           dwRecvBytes1;
    // dwRecvBytes2 is the number of bytes transferred for the result call
    DWORD                           dwRecvBytes2;

    // dwSendFlags2 is the transfer flags for the result call
    DWORD                           dwSendFlags2;
    // dwRecvFlags1 is the transfer flags for the function call
    DWORD                           dwRecvFlags1;
    // dwRecvFlags2 is the transfer flags for the result call
    DWORD                           dwRecvFlags2;

    // hSendEvent1 is a handle to the overlapped event
    HANDLE                          hSendEvent1;
    // hSendEvent2 is a handle to the overlapped event
    HANDLE                          hSendEvent2;
    // hRecvEvent1 is a handle to the overlapped event
    HANDLE                          hRecvEvent1;
    // hRecvEvent2 is a handle to the overlapped event
    HANDLE                          hRecvEvent2;

    // WSASendOverlapped1 is the overlapped structure
    WSAOVERLAPPED                   WSASendOverlapped1;
    // WSASendOverlapped2 is the overlapped structure
    WSAOVERLAPPED                   WSASendOverlapped2;
    // WSARecvOverlapped1 is the overlapped structure
    WSAOVERLAPPED                   WSARecvOverlapped1;
    // WSARecvOverlapped2 is the overlapped structure
    WSAOVERLAPPED                   WSARecvOverlapped2;

    // bSendReturnCode is the send return code
    BOOL                            bSendReturnCode;
    // bRecvReturnCode is the recv return code
    BOOL                            bRecvReturnCode;
    // bReturnCode is the return code
    BOOL                            bReturnCode;

    // bException indicates if an exception occurred
    BOOL                            bException;
    // iReturnCode is the return code of the operation
    int                             iReturnCode;
    // iLastError is the error code if the operation failed
    int                             iLastError;
    // bTestPassed indicates if the test passed
    BOOL                            bTestPassed;

    // szFunctionName is the function name
    CHAR                            szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "WSAGetOverlapped... v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_WSAGetOverlappedResult+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_WSAGetOverlappedResult-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = WSAGetOverlappedResultTestSessionXbox;
    }
    else {
        NetsyncTypeSession = WSAGetOverlappedResultTestSessionNt;
    }

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < WSAGetOverlappedResultTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, WSAGetOverlappedResultTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, WSAGetOverlappedResultTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != WSAGetOverlappedResultTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, WSAGetOverlappedResultTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == WSAGetOverlappedResultTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != WSAGetOverlappedResultTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = WSAGetOverlappedResultTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the overlapped events
        hSendEvent1 = CreateEvent(NULL, FALSE, FALSE, NULL);
        hSendEvent2 = CreateEvent(NULL, FALSE, FALSE, NULL);
        hRecvEvent1 = CreateEvent(NULL, FALSE, FALSE, NULL);
        hRecvEvent2 = CreateEvent(NULL, FALSE, FALSE, NULL);

        // Setup the overlapped structures
        ZeroMemory(&WSASendOverlapped1, sizeof(WSASendOverlapped1));
        WSASendOverlapped1.hEvent = hSendEvent1;

        ZeroMemory(&WSASendOverlapped2, sizeof(WSASendOverlapped2));
        WSASendOverlapped2.hEvent = hSendEvent2;

        ZeroMemory(&WSARecvOverlapped1, sizeof(WSARecvOverlapped1));
        WSARecvOverlapped1.hEvent = hRecvEvent1;

        ZeroMemory(&WSARecvOverlapped2, sizeof(WSARecvOverlapped2));
        WSARecvOverlapped2.hEvent = hRecvEvent2;

        // Create the socket
        sSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == WSAGetOverlappedResultTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == WSAGetOverlappedResultTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == WSAGetOverlappedResultTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == WSAGetOverlappedResultTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == WSAGetOverlappedResultTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & WSAGetOverlappedResultTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & WSAGetOverlappedResultTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & WSAGetOverlappedResultTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        if ((0 != (SOCKET_TCP & WSAGetOverlappedResultTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & WSAGetOverlappedResultTable[dwTableIndex].dwSocket))) {
            // Set the buffer size
            dwBufferSize = 10;
            setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

            dwBufferSize = 10;
            setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

            // Set the socket to non-blocking mode
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);

            // Bind the socket
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        if (0 != WSAGetOverlappedResultTable[dwTableIndex].dwFunction) {
            // Initialize the WSAGetOverlappedResult request
            WSAGetOverlappedResultRequest.dwMessageId = WSAGETOVERLAPPEDRESULT_REQUEST_MSG;
            if (0 != (SOCKET_TCP & WSAGetOverlappedResultTable[dwTableIndex].dwSocket)) {
                WSAGetOverlappedResultRequest.nSocketType = SOCK_STREAM;
            }
            else {
                WSAGetOverlappedResultRequest.nSocketType = SOCK_DGRAM;
            }
            WSAGetOverlappedResultRequest.Port = CurrentPort;
            WSAGetOverlappedResultRequest.bServerSend = (0 != (WSARECV_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) || (0 != (WSARECVFROM_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction));
            WSAGetOverlappedResultRequest.bServerRecv = (0 != (WSASEND_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) || (0 != (WSASENDTO_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction));
            WSAGetOverlappedResultRequest.nQueueLen = 0;
            WSAGetOverlappedResultRequest.bComplete = WSAGetOverlappedResultTable[dwTableIndex].bComplete;

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSAGetOverlappedResultRequest), (char *) &WSAGetOverlappedResultRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            // Connect the socket
            ZeroMemory(&remotename1, sizeof(remotename1));
            remotename1.sin_family = AF_INET;
            remotename1.sin_addr.s_addr = FromInAddr;
            remotename1.sin_port = htons(CurrentPort);

            connect(sSocket, (SOCKADDR *) &remotename1, sizeof(remotename1));

            if (0 != (SOCKET_TCP & WSAGetOverlappedResultTable[dwTableIndex].dwSocket)) {
                FD_ZERO(&writefds);
                FD_SET(sSocket, &writefds);
                select(0, NULL, &writefds, NULL, NULL);
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSAGetOverlappedResultRequest), (char *) &WSAGetOverlappedResultRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);
        }

        // Setup the WSABuf structure
        ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
        WSASendBuf.len = BUFFER_TCPSEGMENT_LEN;
        WSASendBuf.buf = SendBufferLarge;

        ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
        if (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bPartial) {
            WSARecvBuf.len = 10 / 2;
        }
        else {
            WSARecvBuf.len = 10;
        }
        WSARecvBuf.buf = RecvBuffer10;

        // Initialize dwBytes and dwFlags
        dwSendBytes1 = 0;
        dwSendBytes2 = 0;
        dwRecvBytes1 = 0;
        dwRecvBytes2 = 0;

        dwSendFlags2 = 0;
        dwRecvFlags1 = 0;
        dwRecvFlags2 = 0;

        // Start the pending overlapped operation
        if (0 != (WSASEND_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) {
            // Fill the queue
            ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
            while (SOCKET_ERROR != send(sSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0)) {
                WSAGetOverlappedResultRequest.nQueueLen++;
                Sleep(SLEEP_ZERO_TIME);
            }

            // Call WSASend
            iReturnCode = WSASend(sSocket, &WSASendBuf, 1, &dwSendBytes1, 0, &WSASendOverlapped1, NULL);

            if (SOCKET_ERROR != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSASend returned non-SOCKET_ERROR");
            }
            else if (WSA_IO_PENDING != WSAGetLastError()) {
                xLog(hLog, XLL_FAIL, "WSASend iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, WSAGetLastError());
            }
        }
        else if (0 != (WSASENDTO_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) {
            // Fill the queue
            ZeroMemory(SendBufferLarge, sizeof(SendBufferLarge));
            while (SOCKET_ERROR != send(sSocket, SendBufferLarge, BUFFER_TCPSEGMENT_LEN, 0)) {
                WSAGetOverlappedResultRequest.nQueueLen++;
                Sleep(SLEEP_ZERO_TIME);
            }

            // Call WSASendTo
            ZeroMemory(&remotename1, sizeof(remotename1));
            remotename1.sin_family = AF_INET;
            remotename1.sin_addr.s_addr = FromInAddr;
            remotename1.sin_port = htons(CurrentPort);

            iReturnCode = WSASendTo(sSocket, &WSASendBuf, 1, &dwSendBytes1, 0, (SOCKADDR *) &remotename1, sizeof(remotename1), &WSASendOverlapped1, NULL);

            if (SOCKET_ERROR != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSASendTo returned non-SOCKET_ERROR");
            }
            else if (WSA_IO_PENDING != WSAGetLastError()) {
                xLog(hLog, XLL_FAIL, "WSASendTo iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, WSAGetLastError());
            }
        }

        if (0 != (WSARECV_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) {
            // Call WSARecv
            iReturnCode = WSARecv(sSocket, &WSARecvBuf, 1, &dwRecvBytes1, &dwRecvFlags1, &WSARecvOverlapped1, NULL);

            if (SOCKET_ERROR != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSARecv returned non-SOCKET_ERROR");
            }
            else if (WSA_IO_PENDING != WSAGetLastError()) {
                xLog(hLog, XLL_FAIL, "WSARecv iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, WSAGetLastError());
            }
        }
        else if (0 != (WSARECVFROM_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) {
            // Call WSARecvFrom
            namelen = sizeof(remotename2);
            ZeroMemory(&remotename2, sizeof(remotename2));

            iReturnCode = WSARecvFrom(sSocket, &WSARecvBuf, 1, &dwRecvBytes1, &dwRecvFlags1, (SOCKADDR *) &remotename2, &namelen, &WSARecvOverlapped1, NULL);

            if (SOCKET_ERROR != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSARecvFrom returned non-SOCKET_ERROR");
            }
            else if (WSA_IO_PENDING != WSAGetLastError()) {
                xLog(hLog, XLL_FAIL, "WSARecvFrom iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, WSAGetLastError());
            }
        }

        // Start another pending overlapped operation
        if ((0 != (WSASEND_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) && (0 != (WSA_SECOND_CALL & WSAGetOverlappedResultTable[dwTableIndex].dwFunction))) {
            // Call WSASend
            iReturnCode = WSASend(sSocket, &WSASendBuf, 1, &dwSendBytes2, 0, &WSASendOverlapped2, NULL);

            if (SOCKET_ERROR != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSASend returned non-SOCKET_ERROR");
            }
            else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                xLog(hLog, XLL_FAIL, "WSASend iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
            }
        }
        else if ((0 != (WSASENDTO_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) && (0 != (WSA_SECOND_CALL & WSAGetOverlappedResultTable[dwTableIndex].dwFunction))) {
            // Call WSASendTo
            ZeroMemory(&remotename1, sizeof(remotename1));
            remotename1.sin_family = AF_INET;
            remotename1.sin_addr.s_addr = FromInAddr;
            remotename1.sin_port = htons(CurrentPort);

            iReturnCode = WSASendTo(sSocket, &WSASendBuf, 1, &dwSendBytes2, 0, (SOCKADDR *) &remotename1, sizeof(remotename1), &WSASendOverlapped2, NULL);

            if (SOCKET_ERROR != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSASendTo returned non-SOCKET_ERROR");
            }
            else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                xLog(hLog, XLL_FAIL, "WSASendTo iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
            }
        }

        if ((0 != (WSARECV_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) && (0 != (WSA_SECOND_CALL & WSAGetOverlappedResultTable[dwTableIndex].dwFunction))) {
            // Call WSARecv
            iReturnCode = WSARecv(sSocket, &WSARecvBuf, 1, &dwRecvBytes2, &dwRecvFlags2, &WSARecvOverlapped2, NULL);

            if (SOCKET_ERROR != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSARecv returned non-SOCKET_ERROR");
            }
            else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                xLog(hLog, XLL_FAIL, "WSARecv iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
            }
        }
        else if ((0 != (WSARECVFROM_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) && (0 != (WSA_SECOND_CALL & WSAGetOverlappedResultTable[dwTableIndex].dwFunction))) {
            // Call WSARecvFrom
            namelen = sizeof(remotename2);
            ZeroMemory(&remotename2, sizeof(remotename2));

            iReturnCode = WSARecvFrom(sSocket, &WSARecvBuf, 1, &dwRecvBytes2, &dwRecvFlags2, (SOCKADDR *) &remotename2, &namelen, &WSARecvOverlapped2, NULL);

            if (SOCKET_ERROR != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSARecvFrom returned non-SOCKET_ERROR");
            }
            else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                xLog(hLog, XLL_FAIL, "WSARecvFrom iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
            }
        }

        // Cancel the pending overlapped operation
        if (0 != (WSA_CANCEL & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) {
            // Call WSACancelOverlappedIO
            iReturnCode = WSACancelOverlappedIO(sSocket);

            if (0 != iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSACancelOverlappedIO returned SOCKET_ERROR - ec = %u", WSAGetLastError());
            }
        }

        if (WSAOVERLAPPED_NULL_EVENT == WSAGetOverlappedResultTable[dwTableIndex].dwOverlapped) {
            WSASendOverlapped1.hEvent = NULL;
            WSARecvOverlapped1.hEvent = NULL;
        }

        if (0 != WSAGetOverlappedResultTable[dwTableIndex].dwFunction) {
            // Send the function request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSAGetOverlappedResultRequest), (char *) &WSAGetOverlappedResultRequest);

            // Wait for the function complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bComplete) {
                if ((0 != (WSASEND_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) || (0 != (WSASENDTO_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction))) {
                    FD_ZERO(&writefds);
                    FD_SET(sSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }
            }
        }

        bReturnCode = TRUE;
        bSendReturnCode = TRUE;
        bRecvReturnCode = TRUE;

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & WSAGetOverlappedResultTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        // Get the current tick count
        dwFirstTime = GetTickCount();

        __try {
            // Call WSAGetOverlappedResult
            if (0 == WSAGetOverlappedResultTable[dwTableIndex].dwFunction) {
                bReturnCode = WSAGetOverlappedResult(sSocket, (WSAOVERLAPPED_NULL != WSAGetOverlappedResultTable[dwTableIndex].dwOverlapped) ? &WSASendOverlapped1 : NULL, (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bBytes) ? &dwSendBytes2 : NULL, WSAGetOverlappedResultTable[dwTableIndex].bWait, (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bFlags) ? &dwSendFlags2 : NULL);
            }
            else {
                if ((0 != (WSASEND_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) || (0 != (WSASENDTO_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction))) {
                    bSendReturnCode = WSAGetOverlappedResult(sSocket, (WSAOVERLAPPED_NULL != WSAGetOverlappedResultTable[dwTableIndex].dwOverlapped) ? &WSASendOverlapped1 : NULL, (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bBytes) ? &dwSendBytes2 : NULL, WSAGetOverlappedResultTable[dwTableIndex].bWait, (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bFlags) ? &dwSendFlags2 : NULL);
                }

                if ((0 != (WSARECV_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) || (0 != (WSARECVFROM_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction))) {
                    bRecvReturnCode = WSAGetOverlappedResult(sSocket, (WSAOVERLAPPED_NULL != WSAGetOverlappedResultTable[dwTableIndex].dwOverlapped) ? &WSARecvOverlapped1 : NULL, (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bBytes) ? &dwRecvBytes2 : NULL, WSAGetOverlappedResultTable[dwTableIndex].bWait, (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bFlags) ? &dwRecvFlags2 : NULL);
                }

                bReturnCode = bSendReturnCode & bRecvReturnCode;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "WSAGetOverlappedResult RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "WSAGetOverlappedResult caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            // Get the current tick count
            dwSecondTime = GetTickCount();

            if (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult did not RIP");
            }

            if ((FALSE == bReturnCode) && (FALSE == WSAGetOverlappedResultTable[dwTableIndex].bReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != WSAGetOverlappedResultTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult iLastError - EXPECTED: %u; RECEIVED: %u", WSAGetOverlappedResultTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "WSAGetOverlappedResult iLastError - OUT: %u", iLastError);
                }
            }
            else if (FALSE == bReturnCode) {
                xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult returned FALSE - ec = %u", WSAGetLastError());
            }
            else if (FALSE == WSAGetOverlappedResultTable[dwTableIndex].bReturnCode) {
                xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult returned TRUE");
            }
            else {
                if (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bComplete) {
                    if ((dwSecondTime - dwFirstTime) > SLEEP_ZERO_TIME) {
                        xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_ZERO_TIME, dwSecondTime - dwFirstTime);
                        bTestPassed = FALSE;
                    }
                }
                else {
                    if (((dwSecondTime - dwFirstTime) < SLEEP_LOW_TIME) || ((dwSecondTime - dwFirstTime) > SLEEP_HIGH_TIME)) {
                        xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME, dwSecondTime - dwFirstTime);
                        bTestPassed = FALSE;
                    }
                }

                // Check return values
                if ((0 != (WSASEND_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) || (0 != (WSASENDTO_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction))) {
                    if (0 != dwSendBytes1) {
                        xLog(hLog, XLL_FAIL, "dwSendBytes1 - EXPECTED: %d; RECEIVED: %d", 0, dwSendBytes1);
                        bTestPassed = FALSE;
                    }

                    if (WSASendBuf.len != dwSendBytes2) {
                        xLog(hLog, XLL_FAIL, "dwSendBytes2 - EXPECTED: %d; RECEIVED: %d", WSASendBuf.len, dwSendBytes2);
                        bTestPassed = FALSE;
                    }

                    if (0 != dwSendFlags2) {
                        xLog(hLog, XLL_FAIL, "dwSendFlags2 - EXPECTED: %d; RECEIVED: %d", 0, dwSendFlags2);
                        bTestPassed = FALSE;
                    }
                }

                if ((0 != (WSARECV_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) || (0 != (WSARECVFROM_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction))) {
                    if (0 != dwRecvBytes1) {
                        xLog(hLog, XLL_FAIL, "dwRecvBytes1 - EXPECTED: %d; RECEIVED: %d", 0, dwRecvBytes1);
                        bTestPassed = FALSE;
                    }

                    if (WSARecvBuf.len != dwRecvBytes2) {
                        xLog(hLog, XLL_FAIL, "dwRecvBytes2 - EXPECTED: %d; RECEIVED: %d", WSARecvBuf.len, dwRecvBytes2);
                        bTestPassed = FALSE;
                    }

                    if (0 != dwRecvFlags1) {
                        xLog(hLog, XLL_FAIL, "dwRecvFlags1 - EXPECTED: %d; RECEIVED: %d", 0, dwRecvFlags1);
                        bTestPassed = FALSE;
                    }

                    if (TRUE == WSAGetOverlappedResultTable[dwTableIndex].bPartial) {
                        if (MSG_PARTIAL != dwRecvFlags2) {
                            xLog(hLog, XLL_FAIL, "dwRecvFlags2 - EXPECTED: %d; RECEIVED: %d", MSG_PARTIAL, dwRecvFlags2);
                            bTestPassed = FALSE;
                        }
                    }
                    else {
                        if (0 != dwRecvFlags2) {
                            xLog(hLog, XLL_FAIL, "dwRecvFlags2 - EXPECTED: %d; RECEIVED: %d", 0, dwRecvFlags2);
                            bTestPassed = FALSE;
                        }
                    }

                    if (0 != (WSARECVFROM_FUNCTION & WSAGetOverlappedResultTable[dwTableIndex].dwFunction)) {
                        if (sizeof(remotename2) != namelen) {
                            xLog(hLog, XLL_FAIL, "namelen - EXPECTED: %d; RECEIVED: %d", sizeof(remotename2), namelen);
                            bTestPassed = FALSE;
                        }

                        if (AF_INET != remotename2.sin_family) {
                            xLog(hLog, XLL_FAIL, "sin_family - EXPECTED: %d; RECEIVED: %d", AF_INET, remotename2.sin_family);
                            bTestPassed = FALSE;
                        }

                        if (NetsyncInAddr != remotename2.sin_addr.s_addr) {
                            xLog(hLog, XLL_FAIL, "sin_addr - EXPECTED: %u; RECEIVED: %u", NetsyncInAddr, remotename2.sin_addr.s_addr);
                            bTestPassed = FALSE;
                        }

                        if (htons(CurrentPort) != remotename2.sin_port) {
                            xLog(hLog, XLL_FAIL, "sin_port - EXPECTED: %d; RECEIVED: %d", htons(CurrentPort), remotename2.sin_port);
                            bTestPassed = FALSE;
                        }

                        sprintf(SendBuffer10, "%05d%05d", 1, 1);
                        if (0 != strncmp(SendBuffer10, WSARecvBuf.buf, WSARecvBuf.len)) {
                            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                            bTestPassed = FALSE;
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "WSAGetOverlappedResult succeeded");
                }
            }
        }

        if (0 != WSAGetOverlappedResultTable[dwTableIndex].dwFunction) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSAGetOverlappedResultRequest), (char *) &WSAGetOverlappedResultRequest);
        }

        // Close the socket
        if (0 == (SOCKET_CLOSED & WSAGetOverlappedResultTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & WSAGetOverlappedResultTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & WSAGetOverlappedResultTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Close the event
        CloseHandle(hRecvEvent2);
        CloseHandle(hRecvEvent1);
        CloseHandle(hSendEvent2);
        CloseHandle(hSendEvent1);

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
WSAGetOverlappedResultTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests WSAGetOverlappedResult - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long                           FromInAddr;
    // dwMessageType is the type of received message
    DWORD                            dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                            dwMessageSize;
    // pMessage is a pointer to the received message
    char                             *pMessage;
    // WSAGetOverlappedResultRequest is the request
    WSAGETOVERLAPPEDRESULT_REQUEST   WSAGetOverlappedResultRequest;
    // WSAGetOverlappedResultComplete is the result
    WSAGETOVERLAPPEDRESULT_COMPLETE  WSAGetOverlappedResultComplete;

    // sSocket is the socket descriptor
    SOCKET                           sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                           nsSocket;

    // dwBufferSize is the send/receive buffer size
    DWORD                            dwBufferSize = 1;
    // bNagle indicates if Nagle is enabled
    BOOL                             bNagle = FALSE;
    // nQueueLen is the size of the queue
    int                              nQueueLen;

    // localname is the local address
    SOCKADDR_IN                      localname;
    // remotename is the remote address
    SOCKADDR_IN                      remotename;

    // SendBuffer10 is the send buffer
    char                             SendBuffer10[BUFFER_10_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                             RecvBufferLarge[BUFFER_LARGE_LEN + 1];
    // dwFillBuffer is a counter to fill the buffers
    DWORD                            dwFillBuffer;
    // nBytes is the number of bytes sent/received
    int                              nBytes;
    // nSendCount is a counter to enumerate each send
    int                              nSendCount;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&WSAGetOverlappedResultRequest, pMessage, sizeof(WSAGetOverlappedResultRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, WSAGetOverlappedResultRequest.nSocketType, 0);

        if (SOCK_STREAM == WSAGetOverlappedResultRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the buffer size
        setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));
        setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwBufferSize, sizeof(dwBufferSize));

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(WSAGetOverlappedResultRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if (SOCK_STREAM == WSAGetOverlappedResultRequest.nSocketType) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }

        // Send the complete
        WSAGetOverlappedResultComplete.dwMessageId = WSAGETOVERLAPPEDRESULT_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSAGetOverlappedResultComplete), (char *) &WSAGetOverlappedResultComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if (SOCK_STREAM == WSAGetOverlappedResultRequest.nSocketType) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(WSAGetOverlappedResultRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        WSAGetOverlappedResultComplete.dwMessageId = WSAGETOVERLAPPEDRESULT_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSAGetOverlappedResultComplete), (char *) &WSAGetOverlappedResultComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        nQueueLen = ((PWSAGETOVERLAPPEDRESULT_REQUEST) pMessage)->nQueueLen;
        NetsyncFreeMessage(pMessage);

        if (FALSE == WSAGetOverlappedResultRequest.bComplete) {
            // Send the complete
            WSAGetOverlappedResultComplete.dwMessageId = WSAGETOVERLAPPEDRESULT_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSAGetOverlappedResultComplete), (char *) &WSAGetOverlappedResultComplete);

            // Sleep
            Sleep(SLEEP_MIDLOW_TIME);
        }

        // Complete the pending overlapped operation
        if (TRUE == WSAGetOverlappedResultRequest.bServerRecv) {
            ZeroMemory(&RecvBufferLarge, sizeof(RecvBufferLarge));
            for (nSendCount = 0; nSendCount < nQueueLen; nSendCount++) {
                recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, BUFFER_TCPSEGMENT_LEN, 0);
            }
        }

        if (TRUE == WSAGetOverlappedResultRequest.bServerSend) {
            // Call send
            sprintf(SendBuffer10, "%05d%05d", 1, 1);
            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0);
        }

        if (TRUE == WSAGetOverlappedResultRequest.bComplete) {
            // Send the complete
            WSAGetOverlappedResultComplete.dwMessageId = WSAGETOVERLAPPEDRESULT_COMPLETE_MSG;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSAGetOverlappedResultComplete), (char *) &WSAGetOverlappedResultComplete);
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\wsarecvfrom.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  wsarecvfrom.c

Abstract:

  This modules tests wsarecvfrom

Author:

  Steven Kehrli (steveke) 13-Dev-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// WSARecvFrom messages

#define WSARECVFROM_REQUEST_MSG   NETSYNC_MSG_USER + 200 + 1
#define WSARECVFROM_CANCEL_MSG    NETSYNC_MSG_USER + 200 + 2
#define WSARECVFROM_COMPLETE_MSG  NETSYNC_MSG_USER + 200 + 3

typedef struct _WSARECVFROM_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bServerAccept;
    BOOL     bRemoteShutdown;
    BOOL     bRemoteClose;
    int      nDataBuffers;
    int      nBufferlen;
} WSARECVFROM_REQUEST, *PWSARECVFROM_REQUEST;

typedef struct _WSARECVFROM_COMPLETE {
    DWORD    dwMessageId;
} WSARECVFROM_COMPLETE, *PWSARECVFROM_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define BUFFER_10             0
#define BUFFER_LARGE          1
#define BUFFER_NULL           2
#define BUFFER_NULLZERO       3
#define BUFFER_ZERO           4
#define BUFFER_ZEROCOUNT      5
#define BUFFER_SMALL          6
#define BUFFER_TCPLARGE       7
#define BUFFER_UDPLARGE       8
#define BUFFER_UDPTOOLARGE    9
#define BUFFER_MULTI         10
#define BUFFER_SECOND        11
#define BUFFER_NONE          12

#define OVERLAPPED_IO_RESULT  1
#define OVERLAPPED_IO_EVENT   2



typedef struct WSARECVFROMBUFFER_TABLE {
    DWORD  dwBuffer;
} WSARECVFROMBUFFER_TABLE, *PWSARECVFROMBUFFER_TABLE;

WSARECVFROMBUFFER_TABLE WSARecvFromBufferTcpTable[] = { { BUFFER_10        },
                                                        { BUFFER_NULLZERO  },
                                                        { BUFFER_TCPLARGE  } };

#define WSARecvFromBufferTcpTableCount  (sizeof(WSARecvFromBufferTcpTable) / sizeof(WSARECVFROMBUFFER_TABLE));

WSARECVFROMBUFFER_TABLE WSARecvFromBufferUdpTable[] = { { BUFFER_10        },
                                                        { BUFFER_NULLZERO  },
                                                        { BUFFER_UDPLARGE  } };

#define WSARecvFromBufferUdpTableCount  (sizeof(WSARecvFromBufferUdpTable) / sizeof(WSARECVFROMBUFFER_TABLE));



typedef struct WSARECVFROM_TABLE {
    CHAR           szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL           bWinsockInitialized;                     // bWinsockInitialized indicates if Winsock is initialized
    BOOL           bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD          dwSocket;                                // dwSocket indicates the socket to be created
    BOOL           bNonblock;                               // bNonblock indicates if the socket is to be set as non-blocking for the recv
    BOOL           bBind;                                   // bBind indicates if the socket is to be bound
    BOOL           bListen;                                 // bListen indicates if the socket is to be placed in the listening state
    BOOL           bAccept;                                 // bAccept indicates if the socket is accepted
    BOOL           bConnect;                                // bConnect indicates if the socket is connected
    BOOL           bRemoteShutdown;                         // bRemoteShutdown indicates if the remote shutsdown the connection
    BOOL           bRemoteClose;                            // bRemoteClose indicates if the remote closes the connection
    BOOL           bShutdown;                               // bShutdown indicates if the connection is shutdown
    int            nShutdown;                               // nShutdown indicates how the connection is shutdown
    int            nDataBuffers;                            // nDataBuffers indicates the number of data buffers to be received
    DWORD          dwBuffer;                                // dwBuffer specifies the recv data structure
    BOOL           bBytesRecv;                              // bFlags indicates if dwBytes is used
    BOOL           bFlags;                                  // bFlags indicates if dwFlags is used
    DWORD          dwFlags;                                 // dwFlags specifies the recv flags
    BOOL           bSecondRecv;                             // bSecondRecv indicates if a second recv should occur
    BOOL           bname;                                   // bname indicates if the address buffer is used
    BOOL           bnamelen;                                // bnamelen indicates if namelen is used
    int            namelen;                                 // namelen is the length of the address buffer
    int            nOverlapped;                             // nOverlapped specifies if overlapped I/O is used
    BOOL           bCompletionRoutine;                      // bCompletionRoutine specifies if completion routine is used
    int            iReturnCode;                             // iReturnCode is the return code of WSARecvFrom
    int            iLastError;                              // iLastError is the error code if the operation failed
    BOOL           bRIP;                                    // Specifies a RIP test case
} WSARECVFROM_TABLE, *PWSARECVFROM_TABLE;

static WSARECVFROM_TABLE WSARecvFromTable[] =
{
    { "20.1 Not Initialized",            FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE },
    { "20.2 s = INT_MIN",                TRUE,  TRUE,  SOCKET_INT_MIN,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "20.3 s = -1",                     TRUE,  TRUE,  SOCKET_NEG_ONE,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "20.4 s = 0",                      TRUE,  TRUE,  SOCKET_ZERO,                FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "20.5 s = INT_MAX",                TRUE,  TRUE,  SOCKET_INT_MAX,             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "20.6 s = INVALID_SOCKET",         TRUE,  TRUE,  SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "20.7 Not Bound TCP",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "20.8 Listening TCP",              TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "20.9 Accepted TCP",               TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.10 Connected TCP",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.11 Second Receive TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SECOND,    TRUE,  TRUE,  0, TRUE,  FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.12 I/O TCP",                   TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       OVERLAPPED_IO_RESULT, FALSE, 0,            0,                 FALSE },
    { "20.13 Event TCP",                 TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "20.14 Event Event TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "20.15 SD_RECEIVE Accept TCP",     TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "20.16 SD_SEND Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.17 SD_BOTH Accept TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "20.18 SD_RECEIVE Connect TCP",    TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "20.19 SD_SEND Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.20 SD_BOTH Connect TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "20.21 Shutdown Accept TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.22 Shutdown Connect TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.23 Close Accept TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "20.24 Close Connect TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "20.25 NULL Buffer TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.26 NULL 0 Bufferlen TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,  TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.27 0 Bufferlen TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.28 Small Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,     TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.29 Exact Bufferlen TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.30 Large Buffer TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_TCPLARGE,  TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.31 Multi Buffer TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_MULTI,     TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.32 Switch Recv TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.33 Iterative Recv TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.34 NULL Buffer Ptr TCP",       TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.35 0 Buffer Count TCP",        TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT, TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.36 NULL dwBytes TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        FALSE, TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.37 NULL flags TCP",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  FALSE, 0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.38 flags != 0 TCP",            TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  4, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.39 Callback != NULL TCP",      TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.40 NULL addr TCP",             TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.41 addr TCP",                  TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.42 Large addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) + 1, 0,                    FALSE, 0,            0,                 FALSE },
    { "20.43 Exact addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.44 Small addrlen TCP",         TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) - 1, 0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "20.45 Zero addrlen TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  0,                       0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "20.46 Neg addrlen TCP",           TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  -1,                      0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "20.47 NULL addrlen TCP",          TRUE,  TRUE,  SOCKET_TCP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  FALSE, 0,                       0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "20.48 Not Bound NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "20.49 Listening NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTCONN,       FALSE },
    { "20.50 Accepted NB TCP",           TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.51 Connected NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.52 Second Receive NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SECOND,    TRUE,  TRUE,  0, TRUE,  FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.53 I/O NB TCP",                TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       OVERLAPPED_IO_RESULT, FALSE, 0,            0,                 FALSE },
    { "20.54 Event NB TCP",              TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "20.55 Event Event NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "20.56 SD_RECEIVE Accept NB TCP",  TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "20.57 SD_SEND Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.58 SD_BOTH Accept NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "20.59 SD_RECEIVE Connect NB TCP", TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "20.60 SD_SEND Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.61 SD_BOTH Connect NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "20.62 Shutdown Accept NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.63 Shutdown Connect NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.64 Close Accept NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "20.65 Close Connect NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAECONNRESET,     FALSE },
    { "20.66 NULL Buffer NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.67 NULL 0 Bufferlen NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,  TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.68 0 Bufferlen NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.69 Small Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,     TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.70 Exact Bufferlen NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.71 Large Buffer NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_TCPLARGE,  TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.72 Multi Buffer NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_MULTI,     TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.73 Switch Recv NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.74 Iterative Recv NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.75 NULL Buffer Ptr NB TCP",    TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.76 0 Buffer Count NB TCP",     TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT, TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.77 NULL dwBytes NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        FALSE, TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.78 NULL flags NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  FALSE, 0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.79 flags != 0 NB TCP",         TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  4, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.80 Callback != NULL NB TCP",   TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.81 NULL addr NB TCP",          TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.82 addr NB TCP",               TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.83 Large addrlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) + 1, 0,                    FALSE, 0,            0,                 FALSE },
    { "20.84 Exact addrlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.85 Small addrlen NB TCP",      TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) - 1, 0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "20.86 Zero addrlen NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  0,                       0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "20.87 Neg addrlen NB TCP",        TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  -1,                      0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "20.88 NULL addrlen NB TCP",       TRUE,  TRUE,  SOCKET_TCP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  FALSE, 0,                       0,                    FALSE, 0,            WSAEFAULT,         TRUE  },
    { "20.89 Not Bound UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "20.90 Not Connected UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.91 Connected UDP",             TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.92 Second Receive UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SECOND,    TRUE,  TRUE,  0, TRUE,  FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "20.93 SD_RECEIVE Conn UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "20.94 SD_SEND Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.95 SD_BOTH Conn UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "20.96 I/O UDP",                   TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       OVERLAPPED_IO_RESULT, FALSE, 0,            0,                 FALSE },
    { "20.97 Event UDP",                 TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "20.98 Event Event UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "20.99 NULL Buffer UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.100 NULL 0 Bufferlen UDP",     TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,  TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.101 0 Bufferlen UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.102 Small Bufferlen UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,     TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "20.103 Exact Bufferlen UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.104 Large Buffer UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPLARGE,  TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.105 Multi Buffer UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_MULTI,     TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.106 Switch Recv UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.107 Iterative Recv UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.108 Null Buffer Ptr UDP",      TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.109 0 Buffer Count UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT, TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.110 NULL dwBytes UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        FALSE, TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.111 NULL flags UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  FALSE, 0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.112 flags != 0 UDP",           TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  4, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.113 Callback != NULL UDP",     TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.114 NULL addr UDP",            TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.115 Not Connect addr UDP",     TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.116 Connected addr UDP",       TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.117 Large addrlen UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) + 1, 0,                    FALSE, 0,            0,                 FALSE },
    { "20.118 Exact addrlen UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.119 Small addrlen UDP",        TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) - 1, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.120 Zero addrlen UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.121 Neg addrlen UDP",          TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  -1,                      0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.122 NULL addrlen UDP",         TRUE,  TRUE,  SOCKET_UDP,                 FALSE, TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.123 Not Bound NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEINVAL,         FALSE },
    { "20.124 Not Connected NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.125 Connected NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.126 Second Receive NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SECOND,    TRUE,  TRUE,  0, TRUE,  FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "20.127 SD_RECEIVE Conn NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_RECEIVE, 1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "20.128 SD_SEND Conn NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_SEND,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.129 SD_BOTH Conn NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  SD_BOTH,    1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAESHUTDOWN,      FALSE },
    { "20.130 I/O NB UDP",               TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       OVERLAPPED_IO_RESULT, FALSE, 0,            0,                 FALSE },
    { "20.131 Event NB UDP",             TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "20.132 Event Event NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          -1,  BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       OVERLAPPED_IO_EVENT,  FALSE, 0,            0,                 FALSE },
    { "20.133 NULL Buffer NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULL,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.134 NULL 0 Bufferlen NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NULLZERO,  TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.135 0 Bufferlen NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZERO,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.136 Small Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_SMALL,     TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEMSGSIZE,       FALSE },
    { "20.137 Exact Bufferlen NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.138 Large Buffer NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_UDPLARGE,  TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.139 Multi Buffer NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_MULTI,     TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.140 Switch Recv NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          3,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.141 Iterative Recv NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          100, BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, 0,            0,                 FALSE },
    { "20.142 Null Buffer Ptr NB UDP",   TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.143 0 Buffer Count NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_ZEROCOUNT, TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.144 NULL dwBytes NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        FALSE, TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.145 NULL flags NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  FALSE, 0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.146 flags != 0 NB UDP",        TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  4, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.147 Callback != NULL NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    TRUE,  SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.148 NULL addr NB UDP",         TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, FALSE, TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.149 Not Connect addr NB UDP",  TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.150 Connected addr NB UDP",    TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.151 Large addrlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) + 1, 0,                    FALSE, 0,            0,                 FALSE },
    { "20.152 Exact addrlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN),     0,                    FALSE, 0,            0,                 FALSE },
    { "20.153 Small addrlen NB UDP",     TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  sizeof(SOCKADDR_IN) - 1, 0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.154 Zero addrlen NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.155 Neg addrlen NB UDP",       TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  TRUE,  -1,                      0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.156 NULL addrlen NB UDP",      TRUE,  TRUE,  SOCKET_UDP,                 TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, 0,          1,   BUFFER_10,        TRUE,  TRUE,  0, FALSE, TRUE,  FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAEFAULT,         TRUE  },
    { "20.157 Closed Socket TCP",        TRUE,  TRUE,  SOCKET_TCP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "20.158 Closed Socket UDP",        TRUE,  TRUE,  SOCKET_UDP | SOCKET_CLOSED, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSAENOTSOCK,       FALSE },
    { "20.159 Not Initialized",          FALSE, FALSE, SOCKET_INVALID_SOCKET,      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,          1,   BUFFER_NONE,      TRUE,  TRUE,  0, FALSE, FALSE, FALSE, 0,                       0,                    FALSE, SOCKET_ERROR, WSANOTINITIALISED, FALSE }
};

#define WSARecvFromTableCount (sizeof(WSARecvFromTable) / sizeof(WSARECVFROM_TABLE))

NETSYNC_TYPE_THREAD  WSARecvFromTestSessionNt =
{
    1,
    WSARecvFromTableCount,
    L"xnetapi_nt.dll",
    "WSARecvFromTestServer"
};

NETSYNC_TYPE_THREAD  WSARecvFromTestSessionXbox =
{
    1,
    WSARecvFromTableCount,
    L"xnetapi_xbox.dll",
    "WSARecvFromTestServer"
};



// Callback routine

VOID CALLBACK WSARecvFromCompletionRoutine(IN DWORD  dwError, IN DWORD  cbTransferred, IN LPWSAOVERLAPPED  lpOverlapped, IN DWORD  dwFlags) { return; }



VOID
WSARecvFromTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN WORD    NetsyncRemoteType,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests WSARecvFrom - Client side

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  NetsyncRemoteType - remote netsync server type
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                     lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                     lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                     dwTableIndex;

    // bWinsockInitialized indicates if Winsock is initialized
    BOOL                      bWinsockInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                   WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                    hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD       NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                    NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                   LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                   HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                   CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                    FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                     dwMessageSize;
    // pMessage is a pointer to the received message
    char                      *pMessage;
    // WSARecvFromRequest is the request sent to the server
    WSARECVFROM_REQUEST       WSARecvFromRequest;
    
    // sSocket is the socket descriptor
    SOCKET                    sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                    nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int                       iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL                      bNagle = FALSE;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                    Nonblock;
    // bNonblocking indicates if the socket is in non-blocking mode
    BOOL                      bNonblocking = FALSE;

    // localname is the local address
    SOCKADDR_IN               localname;
    // remotename is the remote address
    SOCKADDR_IN               remotename;

    // readfds is the set of sockets to check for a read condition
    fd_set                    readfds;
    // writefds is the set of sockets to check for a write condition
    fd_set                    writefds;
    // timeout is the timeout for select
    timeval                   fdstimeout = { 1, 0 };

    // SendBuffer10 is the send buffer
    char                      SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                      SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // RecvBuffer10 is the recv buffer
    char                      RecvBuffer10[BUFFER_10_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                      RecvBufferLarge[BUFFER_LARGE_LEN + 1];
    // WSABuf is an array of send data structures
    WSABUF                    WSABuf[3];
    // dwBufferCount is the number of send data structures
    DWORD                     dwBufferCount;
    // nBufferlen is the total size of the data
    int                       nBufferlen;
    // dwFillBuffer is a counter to fill the buffers
    DWORD                     dwFillBuffer;
    // dwBytes is the number of bytes received
    DWORD                     dwBytes;
    // nRecvCount is a counter to enumerate each recv
    int                       nRecvCount;

    // dwFirstTime is the first tick count
    DWORD                     dwFirstTime;
    // dwSecondTime is the second tick count
    DWORD                     dwSecondTime;

    // WSARecvFromBufferTable is the test buffer table to use for iterative send
    PWSARECVFROMBUFFER_TABLE  WSARecvFromBufferTable;
    // WSARecvFromBufferTableCount is the number of elements within the test buffer table
    size_t                    WSARecvFromBufferTableCount;
    // WSAOverlapped is the overlapped I/O structure
    WSAOVERLAPPED             WSAOverlapped;
    // dwFlags specifies the receive flags
    DWORD                     dwFlags;
    // dwTotalBytes specifies the total bytes
    DWORD                     dwTotalBytes;
    // namelen is the size of the address buffer
    int                       namelen;

    // dwReturnCode is the return code of WaitForSingleObject
    DWORD                     dwReturnCode;

    // bException indicates if an exception occurred
    BOOL                      bException;
    // iReturnCode is the return code of the operation
    int                       iReturnCode;
    // iLastError is the error code if the operation failed
    int                       iLastError;
    // bTestPassed indicates if the test passed
    BOOL                      bTestPassed;

    // szFunctionName is the function name
    CHAR                      szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "WSARecvFrom v%04x vs %s", WinsockVersion, (VS_XBOX == NetsyncRemoteType) ? "Xbox" : "Nt");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_WSARecvFrom+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_WSARecvFrom-");

    // Determine the remote netsync server type
    if (VS_XBOX == NetsyncRemoteType) {
        NetsyncTypeSession = WSARecvFromTestSessionXbox;
    }
    else {
        NetsyncTypeSession = WSARecvFromTestSessionNt;
    }

    // Initialize the overlapped I/O structure
    ZeroMemory(&WSAOverlapped, sizeof(WSAOverlapped));
    WSAOverlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Initialize the net subsystem
    XNetAddRef();

    for (dwTableIndex = 0; dwTableIndex < WSARecvFromTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, WSARecvFromTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, WSARecvFromTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != WSARecvFromTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, WSARecvFromTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == WSARecvFromTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of Winsock
        if (bWinsockInitialized != WSARecvFromTable[dwTableIndex].bWinsockInitialized) {
            // Initialize or terminate Winsock as necessary
            if (TRUE == WSARecvFromTable[dwTableIndex].bWinsockInitialized) {
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
            }

            // Update the state of Winsock
            bWinsockInitialized = WSARecvFromTable[dwTableIndex].bWinsockInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == WSARecvFromTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INT_MIN == WSARecvFromTable[dwTableIndex].dwSocket) {
            sSocket = INT_MIN;
        }
        else if (SOCKET_NEG_ONE == WSARecvFromTable[dwTableIndex].dwSocket) {
            sSocket = -1;
        }
        else if (SOCKET_ZERO == WSARecvFromTable[dwTableIndex].dwSocket) {
            sSocket = 0;
        }
        else if (SOCKET_INT_MAX == WSARecvFromTable[dwTableIndex].dwSocket) {
            sSocket = INT_MAX;
        }
        else if (SOCKET_INVALID_SOCKET == WSARecvFromTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & WSARecvFromTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        // Set the send and receive timeout values to 5 sec
        if ((0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & WSARecvFromTable[dwTableIndex].dwSocket))) {
            setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));        }

        // Disable Nagle
        if (0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) {
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Set the socket to non-blocking mode
        if (TRUE == WSARecvFromTable[dwTableIndex].bNonblock) {
            Nonblock = 1;
            ioctlsocket(sSocket, FIONBIO, &Nonblock);
            bNonblocking = TRUE;
        }
        else {
            bNonblocking = FALSE;
        }

        // Bind the socket
        if (TRUE == WSARecvFromTable[dwTableIndex].bBind) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if (TRUE == WSARecvFromTable[dwTableIndex].bListen) {
            listen(sSocket, SOMAXCONN);
        }

        if (0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) {
            WSARecvFromBufferTable = WSARecvFromBufferTcpTable;
            WSARecvFromBufferTableCount = WSARecvFromBufferTcpTableCount;
        }
        else {
            WSARecvFromBufferTable = WSARecvFromBufferUdpTable;
            WSARecvFromBufferTableCount = WSARecvFromBufferUdpTableCount;
        }

        if ((TRUE == WSARecvFromTable[dwTableIndex].bAccept) || (TRUE == WSARecvFromTable[dwTableIndex].bConnect) || (0 == WSARecvFromTable[dwTableIndex].iReturnCode)) {
            // Initialize the recv request
            WSARecvFromRequest.dwMessageId = WSARECVFROM_REQUEST_MSG;
            if (0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) {
                WSARecvFromRequest.nSocketType = SOCK_STREAM;
            }
            else {
                WSARecvFromRequest.nSocketType = SOCK_DGRAM;
            }
            WSARecvFromRequest.Port = CurrentPort;
            WSARecvFromRequest.bServerAccept = WSARecvFromTable[dwTableIndex].bConnect;
            WSARecvFromRequest.bRemoteShutdown = WSARecvFromTable[dwTableIndex].bRemoteShutdown;
            WSARecvFromRequest.bRemoteClose = WSARecvFromTable[dwTableIndex].bRemoteClose;
            if (100 == WSARecvFromTable[dwTableIndex].nDataBuffers) {
                WSARecvFromRequest.nDataBuffers = WSARecvFromTable[dwTableIndex].nDataBuffers * WSARecvFromBufferTableCount;
            }
            else {
                WSARecvFromRequest.nDataBuffers = ((0 == WSARecvFromTable[dwTableIndex].iReturnCode) || (WSAEMSGSIZE == WSARecvFromTable[dwTableIndex].iLastError)) ? WSARecvFromTable[dwTableIndex].nDataBuffers : 0;
            }

            WSARecvFromRequest.nBufferlen = BUFFER_10_LEN;
            if (BUFFER_TCPLARGE == WSARecvFromTable[dwTableIndex].dwBuffer) {
                WSARecvFromRequest.nBufferlen = BUFFER_TCPLARGE_LEN;
            }
            else if (BUFFER_UDPLARGE == WSARecvFromTable[dwTableIndex].dwBuffer) {
                WSARecvFromRequest.nBufferlen = BUFFER_UDPLARGE_LEN;
            }
            else if ((BUFFER_NULL == WSARecvFromTable[dwTableIndex].dwBuffer) || ((0 != (SOCKET_UDP & WSARecvFromTable[dwTableIndex].dwSocket)) && ((BUFFER_NULLZERO == WSARecvFromTable[dwTableIndex].dwBuffer) || (BUFFER_ZERO == WSARecvFromTable[dwTableIndex].dwBuffer)))) {
                WSARecvFromRequest.nBufferlen = 0;
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvFromRequest), (char *) &WSARecvFromRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == WSARecvFromTable[dwTableIndex].bConnect) {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = NetsyncInAddr;
                remotename.sin_port = htons(CurrentPort);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));

                if (0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&writefds);
                    FD_SET(sSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }
            }
            else if (TRUE == WSARecvFromTable[dwTableIndex].bAccept) {
                if (0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&readfds);
                    FD_SET(sSocket, &writefds);
                    select(0, &readfds, NULL, NULL, NULL);
                }

                // Accept the socket
                nsSocket = accept(sSocket, NULL, NULL);
            }

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvFromRequest), (char *) &WSARecvFromRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == WSARecvFromTable[dwTableIndex].bRemoteShutdown) {
                if (TRUE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                ZeroMemory(RecvBuffer10, sizeof(RecvBuffer10));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (0 != recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBuffer10, sizeof(RecvBuffer10), 0));

                if (TRUE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }

            if (TRUE == WSARecvFromTable[dwTableIndex].bRemoteClose) {
                if (TRUE == bNonblocking) {
                    Nonblock = 0;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }

                ZeroMemory(SendBuffer10, sizeof(SendBuffer10));
                do {
                    Sleep(SLEEP_ZERO_TIME);
                } while (SOCKET_ERROR != send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0));

                if (TRUE == bNonblocking) {
                    Nonblock = 1;
                    ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                }
            }
        }

        // Shutdown the connection
        if (TRUE == WSARecvFromTable[dwTableIndex].bShutdown) {
            shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSARecvFromTable[dwTableIndex].nShutdown);
        }

        // Zero the receive buffer
        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

        // Initialize the buffers
        sprintf(SendBuffer10, "%05d%05d", 1, 1);
        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
        }

        dwBufferCount = 1;
        if (BUFFER_10 == WSARecvFromTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = BUFFER_10_LEN;
        }
        else if (BUFFER_NULL == WSARecvFromTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = NULL;

            nBufferlen = 0;
        }
        else if (BUFFER_NULLZERO == WSARecvFromTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = 0;
            WSABuf[0].buf = NULL;

            nBufferlen = 0;
        }
        else if (BUFFER_ZERO == WSARecvFromTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = 0;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = 0;
        }
        else if (BUFFER_ZEROCOUNT == WSARecvFromTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = 0;
            WSABuf[0].buf = RecvBufferLarge;

            dwBufferCount = 0;
            nBufferlen = 0;
        }
        else if (BUFFER_SMALL == WSARecvFromTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN - 1;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = BUFFER_10_LEN - 1;
        }
        else if (BUFFER_TCPLARGE == WSARecvFromTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_TCPLARGE_LEN;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = BUFFER_TCPLARGE_LEN;
        }
        else if (BUFFER_UDPLARGE == WSARecvFromTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_UDPLARGE_LEN;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = BUFFER_UDPLARGE_LEN;
        }
        else if (BUFFER_UDPTOOLARGE == WSARecvFromTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_UDPLARGE_LEN + 1;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = 0;
        }
        else if (BUFFER_MULTI == WSARecvFromTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN;
            WSABuf[0].buf = RecvBufferLarge;

            WSABuf[1].len = BUFFER_10_LEN;
            WSABuf[1].buf = &RecvBufferLarge[BUFFER_10_LEN];

            WSABuf[2].len = BUFFER_10_LEN;
            WSABuf[2].buf = &RecvBufferLarge[BUFFER_10_LEN + BUFFER_10_LEN];

            dwBufferCount = 3;
            nBufferlen = BUFFER_10_LEN + BUFFER_10_LEN + BUFFER_10_LEN;
        }
        else if (BUFFER_SECOND == WSARecvFromTable[dwTableIndex].dwBuffer) {
            WSABuf[0].len = BUFFER_10_LEN / 2;
            WSABuf[0].buf = RecvBufferLarge;

            nBufferlen = BUFFER_10_LEN;
        }

        // Initialize the remote name
        namelen = WSARecvFromTable[dwTableIndex].namelen;
        ZeroMemory(&remotename, sizeof(remotename));

        // Initialize the flags
        dwFlags = WSARecvFromTable[dwTableIndex].dwFlags;

        bTestPassed = TRUE;
        bException = FALSE;

        // Close the socket, if necessary
        if (0 != (SOCKET_CLOSED & WSARecvFromTable[dwTableIndex].dwSocket)) {
            closesocket(sSocket);
        }

        // Get the current tick count
        dwFirstTime = GetTickCount();

        __try {
            // Call WSARecvFrom
            iReturnCode = WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, (BUFFER_NONE != WSARecvFromTable[dwTableIndex].dwBuffer) ? WSABuf : NULL, (BUFFER_NONE != WSARecvFromTable[dwTableIndex].dwBuffer) ? dwBufferCount : 0, (TRUE == WSARecvFromTable[dwTableIndex].bBytesRecv) ? &dwBytes : NULL, (TRUE == WSARecvFromTable[dwTableIndex].bFlags) ? &dwFlags : NULL, (TRUE == WSARecvFromTable[dwTableIndex].bname) ? (SOCKADDR *) &remotename : NULL, (TRUE == WSARecvFromTable[dwTableIndex].bnamelen) ? &namelen : NULL, (0 == WSARecvFromTable[dwTableIndex].nOverlapped) ? NULL : &WSAOverlapped, (FALSE == WSARecvFromTable[dwTableIndex].bCompletionRoutine) ? NULL : WSARecvFromCompletionRoutine);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == WSARecvFromTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "WSARecvFrom RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "WSARecvFrom caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (0 != WSARecvFromTable[dwTableIndex].nOverlapped) {
                if (-1 != WSARecvFromTable[dwTableIndex].nDataBuffers) {
                    if (SOCKET_ERROR != iReturnCode) {
                        bTestPassed = FALSE;
                        WSARecvFromRequest.dwMessageId = WSARECVFROM_CANCEL_MSG;
                        WSARecvFromRequest.nDataBuffers = 0;
                    }
                    else {
                        // Get the last error code
                        iLastError = WSAGetLastError();

                        if (iLastError != WSA_IO_PENDING) {
                            xLog(hLog, XLL_FAIL, "WSARecvFrom iLastError - EXPECTED: %u; RECEIVED: %u", WSA_IO_PENDING, iLastError);
                            bTestPassed = FALSE;
                        }
                        else {
                            if (OVERLAPPED_IO_EVENT == WSARecvFromTable[dwTableIndex].nOverlapped) {
                                // Wait on the overlapped I/O event
                                WaitForSingleObject(WSAOverlapped.hEvent, INFINITE);
                            }
                            // Get the overlapped I/O result
                            if (FALSE == WSAGetOverlappedResult((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSAOverlapped, &dwBytes, (OVERLAPPED_IO_RESULT == WSARecvFromTable[dwTableIndex].nOverlapped) ? TRUE : FALSE, &dwFlags)) {
                                xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            }
                            else {
                                iReturnCode = 0;
                            }
                        }
                    }
                }
                else {
                    if (SOCKET_ERROR == iReturnCode) {
                        bTestPassed = FALSE;
                        WSARecvFromRequest.dwMessageId = WSARECVFROM_CANCEL_MSG;
                        WSARecvFromRequest.nDataBuffers = 0;
                    }
                    else {
                        dwReturnCode = WaitForSingleObject(WSAOverlapped.hEvent, 0);
                        if (WAIT_OBJECT_0 != dwReturnCode) {
                            xLog(hLog, XLL_FAIL, "WaitForSingleObject - EXPECTED: %u; RECEIVED: %u", WAIT_OBJECT_0, dwReturnCode);
                        }

                        // Get the overlapped I/O result
                        if (FALSE == WSAGetOverlappedResult((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSAOverlapped, &dwBytes, (OVERLAPPED_IO_RESULT == WSARecvFromTable[dwTableIndex].nOverlapped) ? TRUE : FALSE, &dwFlags)) {
                            xLog(hLog, XLL_FAIL, "WSAGetOverlappedResult returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                        }
                        else {
                            iReturnCode = 0;
                        }

                        // Spoof the sleep time
                        Sleep(SLEEP_MEAN_TIME);
                    }
                }
            }
            else if ((TRUE == bNonblocking) && (FALSE == WSARecvFromTable[dwTableIndex].bRemoteShutdown) && ((0 == WSARecvFromTable[dwTableIndex].iReturnCode) || (WSAEMSGSIZE == WSARecvFromTable[dwTableIndex].iLastError))) {
                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "WSARecvFrom returned non-SOCKET_ERROR");
                    bTestPassed = FALSE;
                }
                else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                    xLog(hLog, XLL_FAIL, "WSARecvFrom iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
                    bTestPassed = FALSE;
                }
                else {
                    xLog(hLog, XLL_PASS, "WSARecvFrom iLastError - OUT: %u", WSAGetLastError());

                    FD_ZERO(&readfds);
                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);

                    // Call WSARecvFrom
                    iReturnCode = WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, (TRUE == WSARecvFromTable[dwTableIndex].bname) ? (SOCKADDR *) &remotename : NULL, (TRUE == WSARecvFromTable[dwTableIndex].bnamelen) ? &namelen : NULL, NULL, NULL);
                }
            }
            
            // Get the current tick count
            dwSecondTime = GetTickCount();

            if (TRUE == WSARecvFromTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "WSARecvFrom did not RIP");
            }

            if (TRUE == WSARecvFromTable[dwTableIndex].bRemoteShutdown) {
                if (SOCKET_ERROR == iReturnCode) {
                    xLog(hLog, XLL_FAIL, "WSARecvFrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                }
                else if (0 != dwBytes) {
                    xLog(hLog, XLL_FAIL, "WSARecvFrom dwBytes - EXPECTED: %u; RECEIVED: %u", 0, dwBytes);
                }
                else {
                    xLog(hLog, XLL_PASS, "WSARecvFrom succeeded");
                }
            }
            else if (WSAEMSGSIZE == WSARecvFromTable[dwTableIndex].iLastError) {
                if (SOCKET_ERROR != iReturnCode) {
                    xLog(hLog, XLL_FAIL, "WSARecvFrom returned non-SOCKET_ERROR");
                }
                else if (WSAEMSGSIZE != WSAGetLastError()) {
                    xLog(hLog, XLL_FAIL, "WSARecvFrom iLastError - EXPECTED: %u; RECEIVED: %u", WSAEMSGSIZE, WSAGetLastError());
                }
                else {
                    if (MSG_PARTIAL != dwFlags) {
                        xLog(hLog, XLL_FAIL, "flags != MSG_PARTIAL");
                        bTestPassed = FALSE;
                    }

                    dwFlags = 0;
                    iReturnCode = WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL, NULL, NULL);

                    if (SOCKET_ERROR != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "WSARecvFrom returned non-SOCKET_ERROR");
                        bTestPassed = FALSE;
                    }
                    else if (((TRUE == bNonblocking) && (WSAEWOULDBLOCK != WSAGetLastError())) || ((FALSE == bNonblocking) && (WSAETIMEDOUT != WSAGetLastError()))) {
                        xLog(hLog, XLL_FAIL, "WSARecvFrom iLastError - EXPECTED: %u; RECEIVED: %u", (TRUE == bNonblocking) ? WSAEWOULDBLOCK : WSAETIMEDOUT, WSAGetLastError());
                        bTestPassed = FALSE;
                    }

                    if (TRUE == bTestPassed) {
                        xLog(hLog, XLL_PASS, "WSARecv succeeded");
                    }
                }
            }
            else if ((SOCKET_ERROR == iReturnCode) && (SOCKET_ERROR == WSARecvFromTable[dwTableIndex].iReturnCode)) {
                // Get the last error code
                iLastError = WSAGetLastError();

                if (iLastError != WSARecvFromTable[dwTableIndex].iLastError) {
                    xLog(hLog, XLL_FAIL, "WSARecvFrom iLastError - EXPECTED: %u; RECEIVED: %u", WSARecvFromTable[dwTableIndex].iLastError, iLastError);
                }
                else {
                    xLog(hLog, XLL_PASS, "WSARecvFrom iLastError - OUT: %u", iLastError);
                }
            }
            else if (SOCKET_ERROR == iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSARecvFrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());

                if (1 < WSARecvFromRequest.nDataBuffers) {
                    // Send the WSARecvFrom cancel
                    WSARecvFromRequest.dwMessageId = WSARECVFROM_CANCEL_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvFromRequest), (char *) &WSARecvFromRequest);
                }
            }
            else if (SOCKET_ERROR == WSARecvFromTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "WSARecvFrom returned non-SOCKET_ERROR");
            }
            else {
                dwTotalBytes = dwBytes;

                if (((dwSecondTime - dwFirstTime) < SLEEP_LOW_TIME) || ((dwSecondTime - dwFirstTime) > SLEEP_HIGH_TIME)) {
                    xLog(hLog, XLL_FAIL, "WSARecvFrom nTime - EXPECTED: %d; RECEIVED: %d", SLEEP_MEAN_TIME, dwSecondTime - dwFirstTime);
                    bTestPassed = FALSE;
                }

                if (TRUE == WSARecvFromTable[dwTableIndex].bname) {
                    if (AF_INET != remotename.sin_family) {
                        xLog(hLog, XLL_FAIL, "WSARecvFrom sin_family - EXPECTED: %d; RECEIVED: %d", AF_INET, remotename.sin_family);
                        bTestPassed = FALSE;
                    }

                    if (htons(CurrentPort) != remotename.sin_port) {
                        xLog(hLog, XLL_FAIL, "WSARecvFrom sin_port - EXPECTED: %d; RECEIVED: %d", htons(CurrentPort), remotename.sin_port);
                        bTestPassed = FALSE;
                    }

                    if (NetsyncInAddr != remotename.sin_addr.s_addr) {
                        xLog(hLog, XLL_FAIL, "WSARecvFrom sin_addr - EXPECTED: %u; RECEIVED: %u", NetsyncInAddr, remotename.sin_addr.s_addr);
                        bTestPassed = FALSE;
                    }
                }

                if (0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) {
                    if (TRUE == WSARecvFromTable[dwTableIndex].bSecondRecv) {
                        if (WSABuf[0].len != dwBytes) {
                            xLog(hLog, XLL_FAIL, "WSARecvFrom return value - EXPECTED: %d; RECEIVED: %d", WSABuf[0].len, dwBytes);
                            bTestPassed = FALSE;
                        }
                        else if (0 != strncmp(SendBufferLarge, RecvBufferLarge, WSABuf[0].len)) {
                            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                            bTestPassed = FALSE;
                        }

                        WSABuf[0].buf = &RecvBufferLarge[dwTotalBytes];
                        WSABuf[0].len = nBufferlen - dwTotalBytes;
                        iReturnCode = WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL, NULL, NULL);
                        WSABuf[0].buf = RecvBufferLarge;
                        WSABuf[0].len = nBufferlen / 2;

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "WSARecvFrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            if (WSABuf[0].len != dwBytes) {
                                xLog(hLog, XLL_FAIL, "WSARecvFrom return value - EXPECTED: %d; RECEIVED: %d", WSABuf[0].len, dwBytes);
                                bTestPassed = FALSE;
                            }
                            else if (0 != strncmp(&SendBufferLarge[dwTotalBytes], &RecvBufferLarge[dwTotalBytes], WSABuf[0].len)) {
                                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                bTestPassed = FALSE;
                            }

                            dwTotalBytes += dwBytes;
                        }
                    }

                    if (BUFFER_10_LEN <= nBufferlen) {
                        do {
                            FD_ZERO(&readfds);
                            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                            iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                            if (1 == iReturnCode) {
                                WSABuf[0].buf = &RecvBufferLarge[dwTotalBytes];
                                WSABuf[0].len = nBufferlen - dwTotalBytes;
                                if (SOCKET_ERROR != WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL, NULL, NULL)) {
                                    dwTotalBytes += dwBytes;
                                }
                                WSABuf[0].buf = RecvBufferLarge;
                                WSABuf[0].len = nBufferlen;
                            }
                        } while (0 != iReturnCode);
                    }
                }

                if (nBufferlen != dwTotalBytes) {
                    xLog(hLog, XLL_FAIL, "WSARecvFrom return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwTotalBytes);
                    bTestPassed = FALSE;
                }
                else {
                    if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                        xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                        bTestPassed = FALSE;
                    }
                }

                if (3 == WSARecvFromTable[dwTableIndex].nDataBuffers) {
                    // Zero the receive buffer
                    ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                    }

                    // Send the read request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvFromRequest), (char *) &WSARecvFromRequest);

                    if (WSARECVFROM_CANCEL_MSG != WSARecvFromRequest.dwMessageId) {
                        // Wait for the read complete
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);

                        // Switch the blocking mode
                        Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                        ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                        bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                        iReturnCode = WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL, NULL, NULL);

                        if (TRUE == bNonblocking) {
                            if (SOCKET_ERROR != iReturnCode) {
                                xLog(hLog, XLL_FAIL, "WSARecvFrom returned non-SOCKET_ERROR");
                                bTestPassed = FALSE;
                            }
                            else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                                xLog(hLog, XLL_FAIL, "WSARecvFrom iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
                                bTestPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_PASS, "WSARecvFrom iLastError - OUT: %u", WSAGetLastError());

                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);

                                // Call WSARecvFrom
                                iReturnCode = WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL, NULL, NULL);
                            }
                        }

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "WSARecvFrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                            WSARecvFromRequest.dwMessageId = WSARECVFROM_CANCEL_MSG;
                        }
                        else {
                            dwTotalBytes = dwBytes;

                            if (0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) {
                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        WSABuf[0].buf = &RecvBufferLarge[dwTotalBytes];
                                        WSABuf[0].len = nBufferlen - dwTotalBytes;
                                        if (SOCKET_ERROR != WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL, NULL, NULL)) {
                                            dwTotalBytes += dwBytes;
                                        }
                                        WSABuf[0].buf = RecvBufferLarge;
                                        WSABuf[0].len = nBufferlen;
                                    }
                                } while (0 != iReturnCode);
                            }

                            if (nBufferlen != dwTotalBytes) {
                                xLog(hLog, XLL_FAIL, "WSARecvFrom return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwTotalBytes);
                                bTestPassed = FALSE;
                            }
                            else {
                                if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }

                            WSARecvFromRequest.dwMessageId = WSARECVFROM_REQUEST_MSG;
                        }

                        // Zero the receive buffer
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                        // Initialize the buffers
                        sprintf(SendBuffer10, "%05d%05d", 3, 3);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                        }

                        // Send the read request
                        NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvFromRequest), (char *) &WSARecvFromRequest);

                        if (WSARECVFROM_CANCEL_MSG != WSARecvFromRequest.dwMessageId) {
                            // Wait for the read complete
                            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                            NetsyncFreeMessage(pMessage);

                            // Switch the blocking mode
                            Nonblock = (TRUE == bNonblocking) ? 0 : 1;
                            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
                            bNonblocking = (1 == Nonblock) ? TRUE : FALSE;

                            // Call WSARecvFrom
                            iReturnCode = WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL, NULL, NULL);

                            if (TRUE == bNonblocking) {
                                if (SOCKET_ERROR != iReturnCode) {
                                    xLog(hLog, XLL_FAIL, "WSARecvFrom returned non-SOCKET_ERROR");
                                    bTestPassed = FALSE;
                                }
                                else if (WSAEWOULDBLOCK != WSAGetLastError()) {
                                    xLog(hLog, XLL_FAIL, "WSARecvFrom iLastError - EXPECTED: %u; RECEIVED: %u", WSAEWOULDBLOCK, WSAGetLastError());
                                    bTestPassed = FALSE;
                                }
                                else {
                                    xLog(hLog, XLL_PASS, "WSARecvFrom iLastError - OUT: %u", WSAGetLastError());

                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                    select(0, &readfds, NULL, NULL, NULL);

                                    // Call WSARecvFrom
                                    iReturnCode = WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL, NULL, NULL);
                                }
                            }

                            if (SOCKET_ERROR == iReturnCode) {
                                xLog(hLog, XLL_FAIL, "WSARecvFrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                                bTestPassed = FALSE;
                                WSARecvFromRequest.dwMessageId = WSARECVFROM_CANCEL_MSG;
                            }
                            else {
                                dwTotalBytes = dwBytes;

                                if (0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) {
                                    do {
                                        FD_ZERO(&readfds);
                                        FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                        iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                        if (1 == iReturnCode) {
                                            WSABuf[0].buf = &RecvBufferLarge[dwTotalBytes];
                                            WSABuf[0].len = nBufferlen - dwTotalBytes;
                                            if (SOCKET_ERROR != WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL, NULL, NULL)) {
                                                dwTotalBytes += dwBytes;
                                            }
                                            WSABuf[0].buf = RecvBufferLarge;
                                            WSABuf[0].len = nBufferlen;
                                        }
                                    } while (0 != iReturnCode);
                                }

                                if (nBufferlen != dwTotalBytes) {
                                    xLog(hLog, XLL_FAIL, "WSARecvFrom return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwTotalBytes);
                                    bTestPassed = FALSE;
                                }
                                else {
                                    if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                        xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                        bTestPassed = FALSE;
                                    }
                                }
                            }
                        }
                    }
                }
                else if (100 == WSARecvFromTable[dwTableIndex].nDataBuffers) {
                    for (nRecvCount = 0; nRecvCount < (int) (WSARecvFromTable[dwTableIndex].nDataBuffers * WSARecvFromBufferTableCount); nRecvCount++) {
                        // Zero the receive buffer
                        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));

                        // Initialize the buffers
                        sprintf(SendBuffer10, "%05d%05d", 2 + nRecvCount, 2 + nRecvCount);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_LARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_LARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_LARGE_LEN - dwFillBuffer);
                        }

                        xLog(hLog, XLL_INFO, "Iteration %d", nRecvCount);

                        dwBufferCount = 1;
                        if (BUFFER_10 == WSARecvFromTable[dwTableIndex].dwBuffer) {
                            WSABuf[0].len = BUFFER_10_LEN;
                            WSABuf[0].buf = RecvBufferLarge;

                            nBufferlen = BUFFER_10_LEN;
                        }
                        else if (BUFFER_NULLZERO == WSARecvFromTable[dwTableIndex].dwBuffer) {
                            WSABuf[0].len = 0;
                            WSABuf[0].buf = NULL;

                            nBufferlen = 0;
                        }
                        else if (BUFFER_TCPLARGE == WSARecvFromTable[dwTableIndex].dwBuffer) {
                            WSABuf[0].len = BUFFER_TCPLARGE_LEN;
                            WSABuf[0].buf = RecvBufferLarge;

                            nBufferlen = BUFFER_TCPLARGE_LEN;
                        }
                        else if (BUFFER_UDPLARGE == WSARecvFromTable[dwTableIndex].dwBuffer) {
                            WSABuf[0].len = BUFFER_UDPLARGE_LEN;
                            WSABuf[0].buf = RecvBufferLarge;

                            nBufferlen = BUFFER_UDPLARGE_LEN;
                        }

                        // Send the WSARecv request
                        WSARecvFromRequest.nBufferlen = nBufferlen;
                        NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvFromRequest), (char *) &WSARecvFromRequest);

                        if (WSARECVFROM_CANCEL_MSG == WSARecvFromRequest.dwMessageId) {
                            break;
                        }

                        // Wait for the read complete
                        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                        NetsyncFreeMessage(pMessage);

                        if ((0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) && (0 == nBufferlen)) {
                            iReturnCode = 0;
                            dwBytes = 0;
                        }
                        else {
                            if (TRUE == bNonblocking) {
                                FD_ZERO(&readfds);
                                FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);
                                select(0, &readfds, NULL, NULL, NULL);
                            }

                            // Call WSARecvFrom
                            iReturnCode = WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL, NULL, NULL);
                        }

                        if (SOCKET_ERROR == iReturnCode) {
                            xLog(hLog, XLL_FAIL, "WSARecvFrom returned SOCKET_ERROR - ec = %u", WSAGetLastError());
                            WSARecvFromRequest.dwMessageId = WSARECVFROM_CANCEL_MSG;
                            bTestPassed = FALSE;
                        }
                        else {
                            dwTotalBytes = dwBytes;

                            if (0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) {
                                do {
                                    FD_ZERO(&readfds);
                                    FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

                                    iReturnCode = select(0, &readfds, NULL, NULL, &fdstimeout);
                                    if (1 == iReturnCode) {
                                        WSABuf[0].buf = &RecvBufferLarge[dwTotalBytes];
                                        WSABuf[0].len = nBufferlen - dwTotalBytes;
                                        if (SOCKET_ERROR != WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, WSABuf, 1, &dwBytes, &dwFlags, NULL, NULL, NULL, NULL)) {
                                            dwTotalBytes += dwBytes;
                                        }
                                        WSABuf[0].buf = RecvBufferLarge;
                                        WSABuf[0].len = nBufferlen;
                                    }
                                } while (0 != iReturnCode);
                            }

                            if (nBufferlen != dwTotalBytes) {
                                xLog(hLog, XLL_FAIL, "WSARecvFrom return value - EXPECTED: %d; RECEIVED: %d", nBufferlen, dwTotalBytes);
                                bTestPassed = FALSE;
                            }
                            else {
                                if (0 != strncmp(SendBufferLarge, RecvBufferLarge, nBufferlen)) {
                                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                                    bTestPassed = FALSE;
                                }
                            }
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "WSARecvFrom succeeded");
                }
            }
        }

        // Switch the blocking mode
        if (WSARecvFromTable[dwTableIndex].bNonblock != bNonblocking) {
            Nonblock = (TRUE == WSARecvFromTable[dwTableIndex].bNonblock) ? 1 : 0;
            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONBIO, &Nonblock);
            bNonblocking = WSARecvFromTable[dwTableIndex].bNonblock;
        }

        if ((TRUE == WSARecvFromTable[dwTableIndex].bAccept) || (TRUE == WSARecvFromTable[dwTableIndex].bConnect) || (0 == WSARecvFromTable[dwTableIndex].iReturnCode)) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(WSARecvFromRequest), (char *) &WSARecvFromRequest);
        }

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (0 == (SOCKET_CLOSED & WSARecvFromTable[dwTableIndex].dwSocket)) {
            if ((0 != (SOCKET_TCP & WSARecvFromTable[dwTableIndex].dwSocket)) || (0 != (SOCKET_UDP & WSARecvFromTable[dwTableIndex].dwSocket))) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
            }
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate Winsock if necessary
    if (TRUE == bWinsockInitialized) {
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    // Terminate net subsystem if necessary
    XNetRelease();

    CloseHandle(WSAOverlapped.hEvent);

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace



#else



VOID
WINAPI
WSARecvFromTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests recv - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long                FromInAddr;
    // dwMessageType is the type of received message
    DWORD                 dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                 dwMessageSize;
    // pMessage is a pointer to the received message
    char                  *pMessage;
    // WSARecvFromRequest is the request
    WSARECVFROM_REQUEST   WSARecvFromRequest;
    // WSARecvComplete is the result
    WSARECVFROM_COMPLETE  WSARecvComplete;

    // sSocket is the socket descriptor
    SOCKET                sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int                   iTimeout = 5000;
    // bNagle indicates if Nagle is enabled
    BOOL                  bNagle = FALSE;

    // localname is the local address
    SOCKADDR_IN           localname;
    // remotename is the remote address
    SOCKADDR_IN           remotename;

    // SendBuffer10 is the send buffer
    char                  SendBuffer10[BUFFER_10_LEN + 1];
    // SendBufferLarge is the large send buffer
    char                  SendBufferLarge[BUFFER_LARGE_LEN + 1];
    // dwFillBuffer is a counter to fill the buffers
    DWORD                 dwFillBuffer;
    // nSendCount is a counter to enumerate each send
    int                   nSendCount;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&WSARecvFromRequest, pMessage, sizeof(WSARecvFromRequest));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, WSARecvFromRequest.nSocketType, 0);

        // Set the send and receive timeout values to 5 sec
        setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

        if (SOCK_STREAM == WSARecvFromRequest.nSocketType) {
            // Disable Nagle
            setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));
        }

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(WSARecvFromRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if ((SOCK_STREAM == WSARecvFromRequest.nSocketType) && (TRUE == WSARecvFromRequest.bServerAccept)) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = FromInAddr;
            remotename.sin_port = htons(WSARecvFromRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        WSARecvComplete.dwMessageId = WSARECVFROM_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSARecvComplete), (char *) &WSARecvComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if ((SOCK_STREAM == WSARecvFromRequest.nSocketType) && (TRUE == WSARecvFromRequest.bServerAccept)) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        if (TRUE == WSARecvFromRequest.bRemoteShutdown) {
            // Shutdown the sockets
            if (INVALID_SOCKET != nsSocket) {
                shutdown(nsSocket, SD_BOTH);
            }

            if (INVALID_SOCKET != sSocket) {
                shutdown(sSocket, SD_BOTH);
            }
        }

        if (TRUE == WSARecvFromRequest.bRemoteClose) {
            // Close the sockets
            if (INVALID_SOCKET != nsSocket) {
                shutdown(nsSocket, SD_BOTH);
                closesocket(nsSocket);
                nsSocket = INVALID_SOCKET;
            }

            if (INVALID_SOCKET != sSocket) {
                shutdown(sSocket, SD_BOTH);
                closesocket(sSocket);
                sSocket = INVALID_SOCKET;
            }
        }

        if (-1 == WSARecvFromRequest.nDataBuffers) {
            // Initialize the buffer
            sprintf(SendBuffer10, "%05d%05d", 1, 1);
            for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
            }

            // Send the buffer
            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, WSARecvFromRequest.nBufferlen, 0);
        }

        // Send the complete
        WSARecvComplete.dwMessageId = WSARECVFROM_COMPLETE_MSG;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSARecvComplete), (char *) &WSARecvComplete);

        if (0 < WSARecvFromRequest.nDataBuffers) {
            // Sleep
            Sleep(SLEEP_MIDLOW_TIME);

            // Initialize the buffer
            sprintf(SendBuffer10, "%05d%05d", 1, 1);
            for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
            }

            // Send the buffer
            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, WSARecvFromRequest.nBufferlen, 0);

            if (3 == WSARecvFromRequest.nDataBuffers) {
                // Wait for the request
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                
                if (WSARECVFROM_CANCEL_MSG != ((PWSARECVFROM_REQUEST) pMessage)->dwMessageId) {
                    // Send the complete
                    WSARecvComplete.dwMessageId = WSARECVFROM_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSARecvComplete), (char *) &WSARecvComplete);

                    // Sleep
                    Sleep(SLEEP_MIDLOW_TIME);

                    // Initialize the buffer
                    sprintf(SendBuffer10, "%05d%05d", 2, 2);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                    }

                    // Send the buffer
                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, WSARecvFromRequest.nBufferlen, 0);

                    NetsyncFreeMessage(pMessage);

                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                    if (WSARECVFROM_CANCEL_MSG != ((PWSARECVFROM_REQUEST) pMessage)->dwMessageId) {
                        // Send the complete
                        WSARecvComplete.dwMessageId = WSARECVFROM_COMPLETE_MSG;
                        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSARecvComplete), (char *) &WSARecvComplete);

                        // Sleep
                        Sleep(SLEEP_MIDLOW_TIME);

                        // Initialize the buffer
                        sprintf(SendBuffer10, "%05d%05d", 3, 3);
                        for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                            CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                        }

                        // Send the buffer
                        send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, WSARecvFromRequest.nBufferlen, 0);
                    }
                }

                NetsyncFreeMessage(pMessage);
            }
            else if (100 <= WSARecvFromRequest.nDataBuffers) {
                for (nSendCount = 0; nSendCount < WSARecvFromRequest.nDataBuffers; nSendCount++) {
                    // Wait for the request
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);

                    if (WSARECVFROM_CANCEL_MSG == ((PWSARECVFROM_REQUEST) pMessage)->dwMessageId) {
                        NetsyncFreeMessage(pMessage);
                        break;
                    }

                    // Initialize the buffers
                    sprintf(SendBuffer10, "%05d%05d", 2 + nSendCount, 2 + nSendCount);
                    for (dwFillBuffer = 0; dwFillBuffer < BUFFER_TCPLARGE_LEN; dwFillBuffer += BUFFER_10_LEN) {
                        CopyMemory(&SendBufferLarge[dwFillBuffer], SendBuffer10, BUFFER_TCPLARGE_LEN - dwFillBuffer > BUFFER_10_LEN ? BUFFER_10_LEN : BUFFER_TCPLARGE_LEN - dwFillBuffer);
                    }

                    // Send the buffer
                    send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBufferLarge, ((PWSARECVFROM_REQUEST) pMessage)->nBufferlen, 0);

                    NetsyncFreeMessage(pMessage);

                    // Send the complete
                    WSARecvComplete.dwMessageId = WSARECVFROM_COMPLETE_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(WSARecvComplete), (char *) &WSARecvComplete);
                }
            }
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\wsastartup.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  WSAStartup.c

Abstract:

  This modules tests WSAStartup

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _WSASTARTUP_TABLE {
    CHAR       szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL       bXnetInitialized;                        // bXnetInitialized indicates if the net subsystem is initialized
    WORD       wVersionRequested;                       // wVersionRequested is the requested version of Winsock
    BOOL       bWSAData;                                // bWSAData indicates if lpWSAData is non-NULL
    BOOL       bReinitialize;                           // bReinitialize indicates if Winsock should be reinitialized to version 2.2
    int        iReturnCode;                             // iReturnCode is the return value of WSAStartup
    BOOL       bRIP;                                    // Specifies a RIP test case
} WSASTARTUP_TABLE, *PWSASTARTUP_TABLE;

static WSASTARTUP_TABLE WSAStartupTable[] =
{
    { "6.1 Not Initialized",     FALSE, MAKEWORD(2, 2),   TRUE,  FALSE, 0,              FALSE },
    { "6.2 Ver 0.0",             TRUE,  MAKEWORD(0, 0),   TRUE,  FALSE, 0,              FALSE },
    { "6.3 Ver 1.0",             TRUE,  MAKEWORD(1, 0),   TRUE,  FALSE, 0,              FALSE },
    { "6.4 Ver 1.1",             TRUE,  MAKEWORD(1, 1),   TRUE,  FALSE, 0,              FALSE },
    { "6.5 Ver 1.2",             TRUE,  MAKEWORD(1, 2),   TRUE,  FALSE, 0,              FALSE },
    { "6.6 Ver 2.0",             TRUE,  MAKEWORD(2, 0),   TRUE,  FALSE, 0,              FALSE },
    { "6.7 Ver 2.1",             TRUE,  MAKEWORD(2, 1),   TRUE,  FALSE, 0,              FALSE },
    { "6.8 Ver 2.2",             TRUE,  MAKEWORD(2, 2),   TRUE,  FALSE, 0,              FALSE },
    { "6.9 Ver 2.3",             TRUE,  MAKEWORD(2, 3),   TRUE,  FALSE, 0,              FALSE },
    { "6.10 Ver 15.15",          TRUE,  MAKEWORD(15, 15), TRUE,  FALSE, 0,              FALSE },
    { "6.11 Ver 1.1 -> Ver 2.2", TRUE,  MAKEWORD(1, 1),   TRUE,  TRUE,  0,              FALSE },
    { "6.12 NULL lpWSAData",     TRUE,  MAKEWORD(2, 2),   FALSE, FALSE, WSAEFAULT,      TRUE  },
    { "6.13 Not Initialized",    FALSE, MAKEWORD(2, 2),   TRUE,  FALSE, 0,              FALSE }
};

#define WSAStartupTableCount (sizeof(WSAStartupTable) / sizeof(WSASTARTUP_TABLE))



VOID
WSAStartupTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests WSAStartup

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR    lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR    lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD    dwTableIndex;

    // bXnetInitialized indicates if the net subsystem is initialized
    BOOL     bXnetInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA  WSAData;

    // sSocket1 is the first socket descriptor
    SOCKET   sSocket1;
    // sSocket2 is the second socket descriptor
    SOCKET   sSocket2;

    // bException indicates if an exception occurred
    BOOL     bException;
    // iReturnCode is the return code of the operation
    int      iReturnCode;
    // bTestPassed indicates if the test passed
    BOOL     bTestPassed;



    // Set the function name
    xSetFunctionName(hLog, "WSAStartup");

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_WSAStartup+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_WSAStartup-");

    for (dwTableIndex = 0; dwTableIndex < WSAStartupTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, WSAStartupTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, WSAStartupTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != WSAStartupTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, WSAStartupTable[dwTableIndex].szVariationName);

        // Check the state of the net subsystem
        if (bXnetInitialized != WSAStartupTable[dwTableIndex].bXnetInitialized) {
            // Initialize or terminate net subsystem as necessary
            if (TRUE == WSAStartupTable[dwTableIndex].bXnetInitialized) {
                XNetAddRef();
            }
            else {
                XNetRelease();
            }

            // Update the state of net subsystem
            bXnetInitialized = WSAStartupTable[dwTableIndex].bXnetInitialized;
        }

        bTestPassed = TRUE;
        bException = FALSE;

        // Initialize the WSAData
        ZeroMemory(&WSAData, sizeof(WSAData));

        __try {
            // Call WSAStartup
            iReturnCode = WSAStartup(WSAStartupTable[dwTableIndex].wVersionRequested, (TRUE == WSAStartupTable[dwTableIndex].bWSAData) ? &WSAData : NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == WSAStartupTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "WSAStartup RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "WSAStartup caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == WSAStartupTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "WSAStartup did not RIP");
            }

            if (iReturnCode != WSAStartupTable[dwTableIndex].iReturnCode) {
                xLog(hLog, XLL_FAIL, "iReturnCode - EXPECTED: %u; RECEIVED: %u", WSAStartupTable[dwTableIndex].iReturnCode, iReturnCode);
            }
            else {
                xLog(hLog, XLL_PASS, "iReturnCode - OUT: %u", iReturnCode);
            }

            if ((FALSE == WSAStartupTable[dwTableIndex].bRIP) && (0 == iReturnCode) && (0 == WSAStartupTable[dwTableIndex].iReturnCode)) {
                // Check wVersion
                if (WSAData.wVersion != WSAStartupTable[dwTableIndex].wVersionRequested) {
                    xLog(hLog, XLL_FAIL, "wVersion - EXPECTED: 0x%04x; RECEIVED: 0x%04x", WSAStartupTable[dwTableIndex].wVersionRequested, WSAData.wVersion);
                    bTestPassed = FALSE;
                }
                else {
                    xLog(hLog, XLL_PASS, "wVersion - OUT: 0x%04x", WSAData.wVersion);
                }

                // Check wHighVersion
                if (WSAData.wHighVersion != MAKEWORD(2, 2)) {
                    xLog(hLog, XLL_FAIL, "wHighVersion - EXPECTED: 0x%04x; RECEIVED: 0x%04x", MAKEWORD(2, 2), WSAData.wHighVersion);
                    bTestPassed = FALSE;
                }
                else {
                    xLog(hLog, XLL_PASS, "wHighVersion - OUT: 0x%04x", WSAData.wHighVersion);
                }

                // Check szDescription
                if (0 != strcmp(WSAData.szDescription, "")) {
                    xLog(hLog, XLL_FAIL, "szDescription - EXPECTED: %s; RECEIVED: %s", "", WSAData.szDescription);
                    bTestPassed = FALSE;
                }
                else {
                    xLog(hLog, XLL_PASS, "szDescription - OUT: %s", WSAData.szDescription);
                }

                // Check szSystemStatus
                if (0 != strcmp(WSAData.szSystemStatus, "")) {
                    xLog(hLog, XLL_FAIL, "szSystemStatus - EXPECTED: %s; RECEIVED: %s", "", WSAData.szSystemStatus);
                    bTestPassed = FALSE;
                }
                else {
                    xLog(hLog, XLL_PASS, "szSystemStatus - OUT: %s", WSAData.szSystemStatus);
                }

                // Check iMaxSockets
                if (WSAData.iMaxSockets != 0) {
                    xLog(hLog, XLL_FAIL, "iMaxSockets - EXPECTED: 0x%04x; RECEIVED: 0x%04x", 0, WSAData.iMaxSockets);
                    bTestPassed = FALSE;
                }
                else {
                    xLog(hLog, XLL_PASS, "iMaxSockets - OUT: 0x%04x", WSAData.iMaxSockets);
                }

                // Check iMaxUdpDg
                if (WSAData.iMaxUdpDg != 0) {
                    xLog(hLog, XLL_FAIL, "iMaxUdpDg - EXPECTED: 0x%04x; RECEIVED: 0x%04x", 0, WSAData.iMaxUdpDg);
                    bTestPassed = FALSE;
                }
                else {
                    xLog(hLog, XLL_PASS, "iMaxUdpDg - OUT: 0x%04x", WSAData.iMaxUdpDg);
                }

                // Check lpVendorInfo
                if (NULL != WSAData.lpVendorInfo) {
                    xLog(hLog, XLL_FAIL, "lpVendorInfo - EXPECTED: %s; RECEIVED: %s", NULL, WSAData.lpVendorInfo);
                    bTestPassed = FALSE;
                }
                else {
                    xLog(hLog, XLL_PASS, "lpVendorInfo - OUT: %s", WSAData.lpVendorInfo);
                }

                // Create a socket
                sSocket1 = INVALID_SOCKET;
                sSocket1 = socket(AF_INET, SOCK_DGRAM, 0);
                sSocket2 = INVALID_SOCKET;
                sSocket2 = socket(AF_INET, SOCK_STREAM, 0);

                if (INVALID_SOCKET == sSocket1) {
                    xLog(hLog, XLL_FAIL, "UDP socket failed - Call #1 - ec = %u", WSAGetLastError());
                    bTestPassed = FALSE;
                }
                else {
                    closesocket(sSocket1);
                }

                if (INVALID_SOCKET == sSocket2) {
                    xLog(hLog, XLL_FAIL, "TCP socket failed - Call #1 - ec = %u", WSAGetLastError());
                    bTestPassed = FALSE;
                }
                else {
                    closesocket(sSocket2);
                }

                if (TRUE == WSAStartupTable[dwTableIndex].bReinitialize) {
                    // Call WSAStartup
                    iReturnCode = WSAStartup(MAKEWORD(2, 2), &WSAData);

                    // Check iReturnCode
                    if (0 != iReturnCode) {
                        xLog(hLog, XLL_FAIL, "iReturnCode - EXPECTED: %u; RECEIVED: %u", 0, iReturnCode);
                        bTestPassed = FALSE;
                    }
                    else {
                        xLog(hLog, XLL_PASS, "iReturnCode - OUT: %u", iReturnCode);
                    }

                    // Check wVersion
                    if (WSAData.wVersion != MAKEWORD(2, 2)) {
                        xLog(hLog, XLL_FAIL, "wVersion - EXPECTED: 0x%04x; RECEIVED: 0x%04x", MAKEWORD(2, 2), WSAData.wVersion);
                        bTestPassed = FALSE;
                    }
                    else {
                        xLog(hLog, XLL_PASS, "wVersion - OUT: 0x%04x", WSAData.wVersion);

                        // Check wHighVersion
                        if (WSAData.wHighVersion != MAKEWORD(2, 2)) {
                            xLog(hLog, XLL_FAIL, "wHighVersion - EXPECTED: 0x%04x; RECEIVED: 0x%04x", MAKEWORD(2, 2), WSAData.wHighVersion);
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "wHighVersion - OUT: 0x%04x", WSAData.wHighVersion);
                        }

                        // Check szDescription
                        if (0 != strcmp(WSAData.szDescription, "")) {
                            xLog(hLog, XLL_FAIL, "szDescription - EXPECTED: %s; RECEIVED: %s", "", WSAData.szDescription);
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "szDescription - OUT: %s", WSAData.szDescription);
                        }

                        // Check szSystemStatus
                        if (0 != strcmp(WSAData.szSystemStatus, "")) {
                            xLog(hLog, XLL_FAIL, "szSystemStatus - EXPECTED: %s; RECEIVED: %s", "", WSAData.szSystemStatus);
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "szSystemStatus - OUT: %s", WSAData.szSystemStatus);
                        }

                        // Check iMaxSockets
                        if (WSAData.iMaxSockets != 0) {
                            xLog(hLog, XLL_FAIL, "iMaxSockets - EXPECTED: 0x%04x; RECEIVED: 0x%04x", 0, WSAData.iMaxSockets);
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "iMaxSockets - OUT: 0x%04x", WSAData.iMaxSockets);
                        }

                        // Check iMaxUdpDg
                        if (WSAData.iMaxUdpDg != 0) {
                            xLog(hLog, XLL_FAIL, "iMaxUdpDg - EXPECTED: 0x%04x; RECEIVED: 0x%04x", 0, WSAData.iMaxUdpDg);
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "iMaxUdpDg - OUT: 0x%04x", WSAData.iMaxUdpDg);
                        }

                        // Check lpVendorInfo
                        if (NULL != WSAData.lpVendorInfo) {
                            xLog(hLog, XLL_FAIL, "lpVendorInfo - EXPECTED: %s; RECEIVED: %s", NULL, WSAData.lpVendorInfo);
                            bTestPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_PASS, "lpVendorInfo - OUT: %s", WSAData.lpVendorInfo);
                        }

                        // Create a socket
                        sSocket1 = socket(AF_INET, SOCK_DGRAM, 0);
                        sSocket2 = socket(AF_INET, SOCK_STREAM, 0);

                        if (INVALID_SOCKET == sSocket1) {
                            xLog(hLog, XLL_FAIL, "UDP socket failed - Call #2 - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            closesocket(sSocket1);
                        }

                        if (INVALID_SOCKET == sSocket2) {
                            xLog(hLog, XLL_FAIL, "TCP socket failed - Call #2 - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            closesocket(sSocket2);
                        }

                        // Terminate Winsock
                        WSACleanup();

                        // Create a socket
                        sSocket1 = socket(AF_INET, SOCK_DGRAM, 0);
                        sSocket2 = socket(AF_INET, SOCK_STREAM, 0);

                        if (INVALID_SOCKET == sSocket1) {
                            xLog(hLog, XLL_FAIL, "UDP socket failed - Call #3 - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            closesocket(sSocket1);
                        }

                        if (INVALID_SOCKET == sSocket2) {
                            xLog(hLog, XLL_FAIL, "TCP socket failed - Call #3 - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else {
                            closesocket(sSocket2);
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "WSAStartup succeeded");
                }

                // Terminate Winsock
                WSACleanup();
            }
        }

        while (SOCKET_ERROR != WSACleanup());

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate net subsystem if necessary
    if (TRUE == bXnetInitialized) {
        XNetRelease();
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\XNetCreateKey.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  XNetCreateKey.c

Abstract:

  This modules tests XNetCreateKey

Author:

  Steven Kehrli (steveke) 5-Jul-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _XNETCREATEKEY_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL     bXnetInitialized;                        // bXnetInitialized indicates if the net subsystem is initialized
    BOOL     bXnKid;                                  // bXnKid indicates if the xnkid is valid
    BOOL     bXnKey;                                  // bXnKey indicates if the xnkey is valid
    DWORD    dwReturnCode;                            // dwReturnCode is the return code of the operation
    BOOL     bRIP;                                    // Specifies a RIP test case
} XNETCREATEKEY_TABLE, *PXNETCREATEKEY_TABLE;

static XNETCREATEKEY_TABLE XNetCreateKeyTable[] =
{
    { "34.1 Not Initialized",      FALSE, TRUE,  TRUE,  WSANOTINITIALISED, FALSE },
    { "34.2 Valid",                TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "34.3 NULL xnkid",           TRUE,  FALSE, TRUE,  0,                 TRUE  },
    { "34.4 NULL xnkey",           TRUE,  TRUE,  FALSE, 0,                 TRUE  },
    { "34.5 NULL xnkid and xnkey", TRUE,  TRUE,  FALSE, 0,                 TRUE  },
    { "34.6 Not Initialized",      FALSE, TRUE,  TRUE,  WSANOTINITIALISED, FALSE }
};

#define XNetCreateKeyTableCount (sizeof(XNetCreateKeyTable) / sizeof(XNETCREATEKEY_TABLE))



VOID
XNetCreateKeyTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetCreateKey

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR    lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR    lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD    dwTableIndex;

    // bXnetInitialized indicates if the net subsystem is initialized
    BOOL     bXnetInitialized = FALSE;

    // XnKid is the xnkid
    XNKID    XnKid;
    XNKID    XnKid0;
    // XnKey is the xnkey
    XNKEY    XnKey;
    XNKEY    XnKey0;

    // bException indicates if an exception occurred
    BOOL     bException;
    // dwReturnCode is the return code of the operation
    int      dwReturnCode;
    // bTestPassed indicates if the test passed
    BOOL     bTestPassed;



    // Set the function name
    xSetFunctionName(hLog, "XNetCreateKey");

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_XNetCreateKey+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_XNetCreateKey-");

    for (dwTableIndex = 0; dwTableIndex < XNetCreateKeyTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, XNetCreateKeyTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, XNetCreateKeyTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != XNetCreateKeyTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, XNetCreateKeyTable[dwTableIndex].szVariationName);

        // Check the state of the net subsystem
        if (bXnetInitialized != XNetCreateKeyTable[dwTableIndex].bXnetInitialized) {
            // Initialize or terminate net subsystem as necessary
            if (TRUE == XNetCreateKeyTable[dwTableIndex].bXnetInitialized) {
                XNetAddRef();
            }
            else {
                XNetRelease();
            }

            // Update the state of net subsystem
            bXnetInitialized = XNetCreateKeyTable[dwTableIndex].bXnetInitialized;
        }

        // Clear the xnkid and xnkey
        ZeroMemory(&XnKid, sizeof(XnKid));
        ZeroMemory(&XnKid0, sizeof(XnKid0));
        ZeroMemory(&XnKey, sizeof(XnKey));
        ZeroMemory(&XnKey0, sizeof(XnKey0));

        bTestPassed = TRUE;
        bException = FALSE;

        __try {
            // Call XNetCreateKey
            dwReturnCode = XNetCreateKey((TRUE == XNetCreateKeyTable[dwTableIndex].bXnKid) ? &XnKid : NULL, (TRUE == XNetCreateKeyTable[dwTableIndex].bXnKey) ? &XnKey : NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == XNetCreateKeyTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "XNetCreateKey RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "XNetCreateKey caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == XNetCreateKeyTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "XNetCreateKey did not RIP");
            }

            if (dwReturnCode != XNetCreateKeyTable[dwTableIndex].dwReturnCode) {
                xLog(hLog, XLL_FAIL, "dwReturnCode - EXPECTED: %u; RECEIVED: %u", XNetCreateKeyTable[dwTableIndex].dwReturnCode, dwReturnCode);
            }
            else if (0 == dwReturnCode) {
                // Check the xnkid
                if (0 == memcmp(&XnKid0, &XnKid, sizeof(XnKid))) {
                    xLog(hLog, XLL_FAIL, "XnKid zero buffer");
                    bTestPassed = FALSE;
                }

                // Check the xnkey
                if (0 == memcmp(&XnKey0, &XnKey, sizeof(XnKey))) {
                    xLog(hLog, XLL_FAIL, "XnKey zero buffer");
                    bTestPassed = FALSE;
                }

                // Copy the xnkid and xnkey
                CopyMemory(&XnKid0, &XnKid, sizeof(XnKid));
                CopyMemory(&XnKey0, &XnKey, sizeof(XnKey));

                // Call XNetCreateKey again
                dwReturnCode = XNetCreateKey(&XnKid, &XnKey);

                // Check the xnkid
                if (0 == memcmp(&XnKid0, &XnKid, sizeof(XnKid))) {
                    xLog(hLog, XLL_FAIL, "XnKid zero buffer");
                    bTestPassed = FALSE;
                }

                // Check the xnkey
                if (0 == memcmp(&XnKey0, &XnKey, sizeof(XnKey))) {
                    xLog(hLog, XLL_FAIL, "XnKey zero buffer");
                    bTestPassed = FALSE;
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "XNetCreateKey succeeded");
                }
            }
            else {
                xLog(hLog, XLL_PASS, "dwReturnCode - OUT: %u", dwReturnCode);
            }

        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate net subsystem if necessary
    if (TRUE == bXnetInitialized) {
        XNetRelease();
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\XNetDnsLookup.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  XNetDnsLookup.c

Abstract:

  This modules tests XNetDnsLookup

Author:

  Steven Kehrli (steveke) 12-Nov-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _XNETDNSLOOKUP_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL     bXnetInitialized;                        // bXnetInitialized indicates if the net subsystem is initialized
    BOOL     bHostName;                               // bHostName indicates if the hostname is non-NULL
    BOOL     bKnownHost;                              // bKnownHost indicates if the hostname is known
    BOOL     bEvent;                                  // bEvent indicates if the event is non-NULL
    BOOL     bXnDNS;                                  // bXnDNS indicates if the xndns pointer is non-NULL
    DWORD    dwReturnCode;                            // dwReturnCode is the return code of the operation
    INT      iStatus;                                 // iStatus is the status code of the operation
    BOOL     bRIP;                                    // Specifies a RIP test case
} XNETDNSLOOKUP_TABLE, *PXNETDNSLOOKUP_TABLE;

static XNETDNSLOOKUP_TABLE XNetDnsLookupInsecureTable[] =
{
    { "39.1 Not Initialized",       FALSE, TRUE,  TRUE,  FALSE, TRUE,  WSANOTINITIALISED, 0,                 FALSE },
    { "39.2 Known Host Event",      TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  0,                 0,                 FALSE },
    { "39.3 Known Host No Event",   TRUE,  TRUE,  TRUE,  FALSE, TRUE,  0,                 0,                 FALSE },
    { "39.4 Unknown Host Event",    TRUE,  TRUE,  FALSE, TRUE,  TRUE,  0,                 WSAHOST_NOT_FOUND, FALSE },
    { "39.5 Unknown Host No Event", TRUE,  TRUE,  FALSE, FALSE, TRUE,  0,                 WSAHOST_NOT_FOUND, FALSE },
    { "39.6 NULL Host",             TRUE,  FALSE, TRUE,  FALSE, FALSE, 0,                 0,                 TRUE  },
    { "39.7 NULL XNDNS",            TRUE,  TRUE,  TRUE,  FALSE, FALSE, 0,                 0,                 TRUE  },
    { "39.8 Not Initialized",       FALSE, TRUE,  TRUE,  TRUE,  TRUE,  WSANOTINITIALISED, 0,                 FALSE }
};

#define XNetDnsLookupInsecureTableCount (sizeof(XNetDnsLookupInsecureTable) / sizeof(XNETDNSLOOKUP_TABLE))

static XNETDNSLOOKUP_TABLE XNetDnsLookupSecureTable[] =
{
    { "39.1 Not Initialized",       FALSE, TRUE,  TRUE,  FALSE, TRUE,  WSANOTINITIALISED, 0,                 FALSE },
    { "39.2 WSAEACCES",             TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  WSAEACCES,         0,                 FALSE },
    { "39.3 Not Initialized",       FALSE, TRUE,  TRUE,  TRUE,  TRUE,  WSANOTINITIALISED, 0,                 FALSE }
};

#define XNetDnsLookupSecureTableCount (sizeof(XNetDnsLookupSecureTable) / sizeof(XNETDNSLOOKUP_TABLE))

typedef struct _HOSTADDR_ELEMENT {
    u_long                    HostAddr;
    BOOL                      bFound;
    struct _HOSTADDR_ELEMENT  *pNextHostAddr;
} HOSTADDR_ELEMENT, *PHOSTADDR_ELEMENT;

typedef struct _HOSTNAME_ELEMENT {
    LPSTR                     lpszHostName;
    UINT                      nHostAddrs;
    PHOSTADDR_ELEMENT         pHostAddr;
    struct _HOSTNAME_ELEMENT  *pNextHostName;
} HOSTNAME_ELEMENT, *PHOSTNAME_ELEMENT;



VOID
XNetDnsLookupTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetDnsLookup

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                 lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                 lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                 dwTableIndex;

    // XnAddr is the title xnet address
    XNADDR                XnAddr;
    // dwResult is the result of XNetGetTitleXnAddr
    DWORD                 dwResult = 0;
    
    // XNetDnsLookupTable is the test table
    XNETDNSLOOKUP_TABLE  *XNetDnsLookupTable;
    // XNetDnsReleaseTableCount is the test table count
    DWORD                 XNetDnsLookupTableCount;

    // bXnetInitialized indicates if the net subsystem is initialized
    BOOL                  bXnetInitialized = FALSE;
    // LocalXnAddr is the address of the client
    XNADDR                LocalXnAddr;

    // lpszKnownHosts is a pointer to the list of known hosts
    LPSTR                 lpszKnownHosts = NULL;
    // lpszUnknownHosts is a pointer to the list of unknown hosts
    LPSTR                 lpszUnknownHosts = NULL;

    // lpszHostName is a pointer to a host name within the list
    LPSTR                 lpszHostName = NULL;
    // lpszNextHostName is a pointer to the next host name within the list
    LPSTR                 lpszNextHostName = NULL;
    // lpszHostNameIp is a pointer to a host addr within the list
    LPSTR                 lpszHostAddr = NULL;
    // lpszNextHostNameIp is a pointer to the next host addr within the list
    LPSTR                 lpszNextHostAddr = NULL;

    // pKnownHostNameList is a pointer to the list of known hosts
    PHOSTNAME_ELEMENT     pKnownHostNameList = NULL;
    // pUnknownHostNameList is a pointer to the list of unknown hosts
    PHOSTNAME_ELEMENT     pUnknownHostNameList = NULL;
    // pHostNameElement is a pointer to the new host name element
    PHOSTNAME_ELEMENT     pHostNameElement = NULL;
    // pHostAddrElement is a pointer to the new host addr element
    PHOSTADDR_ELEMENT     pHostAddrElement = NULL;
    // nHostAddr is a counter to enumerate each host addr
    UINT                  nHostAddr = 0;

    // hEvent is a handle to the event
    HANDLE                hEvent = NULL;
    // pXnDNS is a pointer to the DNS entry
    XNDNS                 *pXnDNS = NULL;

    // bException indicates if an exception occurred
    BOOL                  bException;
    // dwReturnCode is the return code of the operation
    int                   dwReturnCode;
    // bTestPassed indicates if the test passed
    BOOL                  bTestPassed;
    // bHostPassed indicates if the host passed
    BOOL                  bHostPassed;



    // Set the function name
    xSetFunctionName(hLog, "XNetDnsLookup");

    // Initialize the net subsystem
    XNetAddRef();

    while (0 == (dwResult = XNetGetTitleXnAddr(&XnAddr))) {
        Sleep(1000);
    }

    // Determine the remote netsync server type
    if (0 != (XNET_GET_XNADDR_ETHERNET & dwResult)) {
        XNetDnsLookupTable = XNetDnsLookupSecureTable;
        XNetDnsLookupTableCount = XNetDnsLookupSecureTableCount;
    }
    else {
        XNetDnsLookupTable = XNetDnsLookupInsecureTable;
        XNetDnsLookupTableCount = XNetDnsLookupInsecureTableCount;
    }

    // Terminate the net subsystem
    XNetRelease();

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_XNetDnsLookup+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_XNetDnsLookup-");

    // Get the known hosts
    lpszKnownHosts = GetIniSection(hMemObject, "xnetapi_KnownHosts");

    // Enumerate each host
    if (NULL != lpszKnownHosts) {
        lpszHostName = lpszKnownHosts;
        while ('\0' != *lpszHostName) {
            lpszNextHostName = lpszHostName + strlen(lpszHostName) + 1;

            // Find the first host addr
            lpszHostAddr = strchr(lpszHostName, '=');
            if (NULL != lpszHostAddr) {
                *lpszHostAddr = '\0';
                lpszHostAddr++;
            }

            // Create the new host name element
            pHostNameElement = (PHOSTNAME_ELEMENT) xMemAlloc(hMemObject, sizeof(HOSTNAME_ELEMENT) + strlen(lpszHostName) + 1);
            if (NULL != pHostNameElement) {
                // Copy the host name
                pHostNameElement->lpszHostName = (LPSTR) ((UINT_PTR) pHostNameElement + sizeof(HOSTNAME_ELEMENT));
                strcpy(pHostNameElement->lpszHostName, lpszHostName);

                // Add the host name element to the list
                pHostNameElement->pNextHostName = pKnownHostNameList;
                pKnownHostNameList = pHostNameElement;

                while (NULL != lpszHostAddr) {
                    lpszNextHostAddr = strchr(lpszHostAddr, ';');
                    if (NULL != lpszNextHostAddr) {
                        *lpszNextHostAddr = '\0';
                        lpszNextHostAddr++;
                    }

                    // Create the new host addr element
                    pHostAddrElement = (PHOSTADDR_ELEMENT) xMemAlloc(hMemObject, sizeof(HOSTADDR_ELEMENT));
                    if (NULL != pHostAddrElement) {
                        // Copy the host addr
                        pHostAddrElement->HostAddr = inet_addr(lpszHostAddr);

                        // Add the host addr element to the list
                        pHostAddrElement->pNextHostAddr = pHostNameElement->pHostAddr;
                        pHostNameElement->pHostAddr = pHostAddrElement;

                        // Increment the number of host addrs
                        pHostNameElement->nHostAddrs++;
                    }

                    lpszHostAddr = lpszNextHostAddr;
                }
            }

            lpszHostName = lpszNextHostName;
        }
    }

    if (NULL == pKnownHostNameList) {
        xLog(hLog, XLL_BLOCK, "No Known Hosts for XNetDnsLookup");
        goto ExitTest;
    }

    // Get the unknown hosts
    lpszUnknownHosts = GetIniSection(hMemObject, "xnetapi_UnknownHosts");

    // Enumerate each host
    if (NULL != lpszUnknownHosts) {
        lpszHostName = lpszUnknownHosts;
        while ('\0' != *lpszHostName) {
            lpszNextHostName = lpszHostName + strlen(lpszHostName) + 1;

            // Create the new host name element
            pHostNameElement = (PHOSTNAME_ELEMENT) xMemAlloc(hMemObject, sizeof(HOSTNAME_ELEMENT) + strlen(lpszHostName) + 1);
            if (NULL != pHostNameElement) {
                // Copy the host name
                pHostNameElement->lpszHostName = (LPSTR) ((UINT_PTR) pHostNameElement + sizeof(HOSTNAME_ELEMENT));
                strcpy(pHostNameElement->lpszHostName, lpszHostName);

                // Add the host name element to the list
                pHostNameElement->pNextHostName = pUnknownHostNameList;
                pUnknownHostNameList = pHostNameElement;
            }

            lpszHostName = lpszNextHostName;
        }
    }

    if (NULL == pUnknownHostNameList) {
        xLog(hLog, XLL_BLOCK, "No Unknown Hosts for XNetDnsLookup");
        goto ExitTest;
    }

    // Create the event
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    for (dwTableIndex = 0; dwTableIndex < XNetDnsLookupTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, XNetDnsLookupTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, XNetDnsLookupTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != XNetDnsLookupTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, XNetDnsLookupTable[dwTableIndex].szVariationName);

        // Check the state of the net subsystem
        if (bXnetInitialized != XNetDnsLookupTable[dwTableIndex].bXnetInitialized) {
            // Initialize or terminate net subsystem as necessary
            if (TRUE == XNetDnsLookupTable[dwTableIndex].bXnetInitialized) {
                XNetAddRef();

                // Get the local xnaddr
                do {
                    dwReturnCode = XNetGetTitleXnAddr(&LocalXnAddr);
                    if (0 == dwReturnCode) {
                        Sleep(SLEEP_ZERO_TIME);
                    }
                } while (0 == dwReturnCode);
            }
            else {
                XNetRelease();
            }

            // Update the state of net subsystem
            bXnetInitialized = XNetDnsLookupTable[dwTableIndex].bXnetInitialized;
        }

        // Set the host name
        lpszHostName = NULL;
        if (TRUE == XNetDnsLookupTable[dwTableIndex].bKnownHost) {
            pHostNameElement = pKnownHostNameList;
            lpszHostName = pHostNameElement->lpszHostName;
        }
        else {
            pHostNameElement = pUnknownHostNameList;
            lpszHostName = pHostNameElement->lpszHostName;
        }

        bTestPassed = TRUE;
        bException = FALSE;

        do {
            bHostPassed = TRUE;

            __try {
                // Call XNetDnsLookup
                dwReturnCode = XNetDnsLookup(lpszHostName, (TRUE == XNetDnsLookupTable[dwTableIndex].bEvent) ? hEvent : NULL, (TRUE == XNetDnsLookupTable[dwTableIndex].bXnDNS) ? &pXnDNS : NULL);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                if (TRUE == XNetDnsLookupTable[dwTableIndex].bRIP) {
                    xLog(hLog, XLL_PASS, "XNetDnsLookup for %s RIP'ed", lpszHostName);
                }
                else {
                    xLog(hLog, XLL_EXCEPTION, "XNetDnsLookup for %s caused an exception - ec = 0x%08x", lpszHostName, GetExceptionCode());
                    bTestPassed = FALSE;
                }
                bException = TRUE;
            }

            if (FALSE == bException) {
                if (TRUE == XNetDnsLookupTable[dwTableIndex].bRIP) {
                    xLog(hLog, XLL_FAIL, "XNetDnsLookup for %s did not RIP", lpszHostName);
                    bTestPassed = FALSE;
                }

                if (dwReturnCode != XNetDnsLookupTable[dwTableIndex].dwReturnCode) {
                    xLog(hLog, XLL_FAIL, "dwReturnCode for %s - EXPECTED: %u; RECEIVED: %u", lpszHostName, XNetDnsLookupTable[dwTableIndex].dwReturnCode, dwReturnCode);
                    bTestPassed = FALSE;
                }
                else if (0 == dwReturnCode) {
                    // Wait for the DNS resolution
                    if (TRUE == XNetDnsLookupTable[dwTableIndex].bEvent) {
                        WaitForSingleObject(hEvent, INFINITE);
                    }
                    else {
                        while (WSAEINPROGRESS == pXnDNS->iStatus) {
                            Sleep(SLEEP_ZERO_TIME);
                        }
                    }

                    // Check the status
                    if (pXnDNS->iStatus != XNetDnsLookupTable[dwTableIndex].iStatus) {
                        xLog(hLog, XLL_FAIL, "iStatus for %s - EXPECTED: %u; RECEIVED: %u", lpszHostName, XNetDnsLookupTable[dwTableIndex].iStatus, pXnDNS->iStatus);
                        bTestPassed = FALSE;
                        bHostPassed = FALSE;
                    }
                    else {
                        xLog(hLog, XLL_INFO, "iStatus for %s - OUT: %u", lpszHostName, pXnDNS->iStatus);
                    }

                    if (NULL != pHostNameElement) {
                        // Check the number of addrs
                        if (pXnDNS->cina != pHostNameElement->nHostAddrs) {
                            xLog(hLog, XLL_FAIL, "cina for %s - EXPECTED: %u; RECEIVED: %u", lpszHostName, pHostNameElement->nHostAddrs, pXnDNS->cina);
                            bTestPassed = FALSE;
                            bHostPassed = FALSE;
                        }
                        else {
                            xLog(hLog, XLL_INFO, "cina for %s - OUT: %u", lpszHostName, pXnDNS->cina);
                        }

                        // Flag the addrs
                        for (nHostAddr = 0; nHostAddr < pXnDNS->cina; nHostAddr++) {
                            for (pHostAddrElement = pHostNameElement->pHostAddr; NULL != pHostAddrElement; pHostAddrElement = pHostAddrElement->pNextHostAddr) {
                                if (pXnDNS->aina[nHostAddr].s_addr == pHostAddrElement->HostAddr) {
                                    if (TRUE == pHostAddrElement->bFound) {
                                        xLog(hLog, XLL_FAIL, "Duplicate Ip for %s Found: 0x%08x", lpszHostName, pHostAddrElement->HostAddr);
                                        bTestPassed = FALSE;
                                        bHostPassed = FALSE;
                                    }

                                    pHostAddrElement->bFound = TRUE;
                                    pXnDNS->aina[nHostAddr].s_addr = 0;
                                    break;
                                }
                            }
                        }

                        // Check the addrs
                        for (pHostAddrElement = pHostNameElement->pHostAddr; NULL != pHostAddrElement; pHostAddrElement = pHostAddrElement->pNextHostAddr) {
                            if (FALSE == pHostAddrElement->bFound) {
                                xLog(hLog, XLL_FAIL, "Ip for %s Not Found: 0x%08x", lpszHostName, pHostAddrElement->HostAddr);
                                bTestPassed = FALSE;
                                bHostPassed = FALSE;
                            }
                            else {
                                xLog(hLog, XLL_INFO, "Ip for %s Found: 0x%08x", lpszHostName, pHostAddrElement->HostAddr);
                                pHostAddrElement->bFound = FALSE;
                            }
                        }

                        // Check the addrs
                        for (nHostAddr = 0; nHostAddr < pXnDNS->cina; nHostAddr++) {
                            if (0 != pXnDNS->aina[nHostAddr].s_addr) {
                                xLog(hLog, XLL_FAIL, "Extraneous Ip for %s Found: 0x%08x", lpszHostName, pXnDNS->aina[nHostAddr].s_addr);
                                bTestPassed = FALSE;
                                bHostPassed = FALSE;
                            }
                        }
                    }

                    XNetDnsRelease(pXnDNS);

                    if (TRUE == bHostPassed) {
                        xLog(hLog, XLL_PASS, "XNetDnsLookup for %s succeeded", lpszHostName);
                    }
                }
                else {
                    xLog(hLog, XLL_PASS, "dwReturnCode for %s - OUT: %u", lpszHostName, dwReturnCode);
                }
            }

            if ((0 == XNetDnsLookupTable[dwTableIndex].dwReturnCode) && (NULL != pHostNameElement)) {
                pHostNameElement = pHostNameElement->pNextHostName;
            }
            else {
                pHostNameElement = NULL;
            }

            if (NULL != pHostNameElement) {
                lpszHostName = pHostNameElement->lpszHostName;
            }
            else {
                lpszHostName = NULL;
            }
        } while (NULL != lpszHostName);

        if (TRUE == bHostPassed) {
            xLog(hLog, XLL_PASS, "XNetDnsLookup succeeded");
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate net subsystem if necessary
    if (TRUE == bXnetInitialized) {
        XNetRelease();
    }

    // Close the event
    CloseHandle(hEvent);

ExitTest:
    // Free the list of unknown host names
    while (NULL != pUnknownHostNameList) {
        pHostNameElement = pUnknownHostNameList;
        pUnknownHostNameList = pUnknownHostNameList->pNextHostName;

        while (NULL != pHostNameElement->pHostAddr) {
            pHostAddrElement = pHostNameElement->pHostAddr;
            pHostNameElement->pHostAddr = pHostNameElement->pHostAddr->pNextHostAddr;

            xMemFree(hMemObject, pHostAddrElement);
        }

        xMemFree(hMemObject, pHostNameElement);
    }

    // Free the list of known host names
    while (NULL != pKnownHostNameList) {
        pHostNameElement = pKnownHostNameList;
        pKnownHostNameList = pKnownHostNameList->pNextHostName;

        while (NULL != pHostNameElement->pHostAddr) {
            pHostAddrElement = pHostNameElement->pHostAddr;
            pHostNameElement->pHostAddr = pHostNameElement->pHostAddr->pNextHostAddr;

            xMemFree(hMemObject, pHostAddrElement);
        }

        xMemFree(hMemObject, pHostNameElement);
    }

    // Free the list of unknown hosts
    if (NULL != lpszUnknownHosts) {
        xMemFree(hMemObject, lpszUnknownHosts);
    }

    // Free the list of known hosts
    if (NULL != lpszKnownHosts) {
        xMemFree(hMemObject, lpszKnownHosts);
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\XNetInAddrToXnAddr.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  XNetInAddrToXnAddr.c

Abstract:

  This modules tests XNetInAddrToXnAddr

Author:

  Steven Kehrli (steveke) 23-Jul-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef _XBOX

using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// XNetInAddrToXnAddr messages

#define XNETINADDRTOXNADDR_REQUEST_MSG   NETSYNC_MSG_USER + 380 + 1
#define XNETINADDRTOXNADDR_COMPLETE_MSG  NETSYNC_MSG_USER + 380 + 2

typedef struct _XNETINADDRTOXNADDR_REQUEST {
    DWORD    dwMessageId;
} XNETINADDRTOXNADDR_REQUEST, *PXNETINADDRTOXNADDR_REQUEST;

typedef struct _XNETINADDRTOXNADDR_COMPLETE {
    DWORD    dwMessageId;
    XNADDR   XnAddr;
} XNETINADDRTOXNADDR_COMPLETE, *PXNETINADDRTOXNADDR_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _XNETINADDRTOXNADDR_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL     bXnetInitialized;                        // bXnetInitialized indicates if the net subsystem is initialized
    BOOL     bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    BOOL     bRegistered;                             // bRegistered indicates if the security association is registered
    BOOL     bLocal;                                  // bLocal indicates if the local xnaddr is used
    BOOL     bInAddr;                                 // bInAddr indicates if the inaddr is valid
    BOOL     bXnAddr;                                 // bXnAddr indicates if the xnaddr is valid
    BOOL     bXnKid;                                  // bXnKid indicates if the xnkid is valid
    BOOL     bAgain;                                  // bAgain indicates if the process should be repeated
    DWORD    dwReturnCode;                            // dwReturnCode is the return code of the operation
    BOOL     bRIP;                                    // Specifies a RIP test case
} XNETINADDRTOXNADDR_TABLE, *PXNETINADDRTOXNADDR_TABLE;

static XNETINADDRTOXNADDR_TABLE XNetInAddrToXnAddrTable[] =
{
    { "38.1 Not Initialized", FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSANOTINITIALISED, FALSE },
    { "38.2 Not Registered",  TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSAEINVAL,         FALSE },
    { "38.3 Valid",           TRUE,  TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  FALSE, 0,                 FALSE },
    { "38.4 Again",           TRUE,  TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "38.5 Local",           TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  FALSE, 0,                 FALSE },
    { "38.6 Zero inaddr",     TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  FALSE, 0,                 TRUE  },
    { "38.7 NULL xnaddr",     TRUE,  TRUE,  TRUE,  FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,                 TRUE  },
    { "38.8 NULL xnkid",      TRUE,  TRUE,  TRUE,  FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,                 FALSE },
    { "38.9 Not Initialized", FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSANOTINITIALISED, FALSE }
};

#define XNetInAddrToXnAddrTableCount (sizeof(XNetInAddrToXnAddrTable) / sizeof(XNETINADDRTOXNADDR_TABLE))

NETSYNC_TYPE_THREAD  XNetInAddrToXnAddrTestSessionXbox =
{
    1,
    XNetInAddrToXnAddrTableCount,
    L"xnetapi_xbox.dll",
    "XNetInAddrToXnAddrTestServer"
};



VOID
XNetInAddrToXnAddrTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN LPSTR   lpszNetsyncRemote,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetInAddrToXnAddr

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  lpszNetsyncRemote - pointer to the netsync remote address
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                       lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                       lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                       dwTableIndex;

    // bXnetInitialized indicates if the net subsystem is initialized
    BOOL                        bXnetInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                     WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                      hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD         NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                      NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                     LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                     HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                     CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                      FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                       dwMessageSize;
    // pMessage is a pointer to the received message
    char                        *pMessage;
    // XNetInAddrToXnAddrRequest is the request sent to the server
    XNETINADDRTOXNADDR_REQUEST  XNetInAddrToXnAddrRequest;

    // LocalXnAddr is the address of the client
    XNADDR                      LocalXnAddr;
    // ServerXnAddr is the address of the netsync server
    XNADDR                      ServerXnAddr;
    // ServerInAddr is the address of the netsync server
    IN_ADDR                     ServerInAddr;

    // XnKid1 is the first xnkid
    XNKID                       XnKid1;
    // XnKid2 is the second xnkid
    XNKID                       XnKid2;
    // XnKey is the xnkey
    XNKEY                       XnKey;
    // InAddr is the inaddr address
    IN_ADDR                     InAddr;
    // XnAddr1 is the first xnaddr address
    XNADDR                      XnAddr1;
    // XnAddr2 is the second xnaddr address
    XNADDR                      XnAddr2;

    // bException indicates if an exception occurred
    BOOL                        bException;
    // dwReturnCode is the return code of the operation
    int                         dwReturnCode;
    // bTestPassed indicates if the test passed
    BOOL                        bTestPassed;

    // szFunctionName is the function name
    CHAR                        szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "XNetInAddrToXnAddr");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_XNetInAddrToXnAddr+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_XNetInAddrToXnAddr-");

    // Determine the remote netsync server type
    NetsyncTypeSession = XNetInAddrToXnAddrTestSessionXbox;

    for (dwTableIndex = 0; dwTableIndex < XNetInAddrToXnAddrTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, XNetInAddrToXnAddrTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, XNetInAddrToXnAddrTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != XNetInAddrToXnAddrTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, XNetInAddrToXnAddrTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == XNetInAddrToXnAddrTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of the net subsystem
        if (bXnetInitialized != XNetInAddrToXnAddrTable[dwTableIndex].bXnetInitialized) {
            // Initialize or terminate net subsystem as necessary
            if (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bXnetInitialized) {
                XNetAddRef();
            }
            else {
                XNetRelease();
            }

            // Update the state of net subsystem
            bXnetInitialized = XNetInAddrToXnAddrTable[dwTableIndex].bXnetInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;

            // Get the server xnaddr
            XNetInAddrToXnAddrRequest.dwMessageId = XNETINADDRTOXNADDR_REQUEST_MSG;
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(XNetInAddrToXnAddrRequest), (char *) &XNetInAddrToXnAddrRequest);

            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            CopyMemory(&ServerXnAddr, &((XNETINADDRTOXNADDR_COMPLETE *) pMessage)->XnAddr, sizeof(ServerXnAddr));
            NetsyncFreeMessage(pMessage);
        }

        // Get the local xnaddr
        do {
            dwReturnCode = XNetGetTitleXnAddr(&LocalXnAddr);
            if (0 == dwReturnCode) {
                Sleep(SLEEP_ZERO_TIME);
            }
        } while (0 == dwReturnCode);

        // Clear the xnkid and xnkey
        ZeroMemory(&XnKid1, sizeof(XnKid1));
        ZeroMemory(&XnKid2, sizeof(XnKid2));
        ZeroMemory(&XnKey, sizeof(XnKey));

        // Register key pair
        XNetCreateKey(&XnKid1, &XnKey);
        XNetRegisterKey(&XnKid1, &XnKey);

        // Register security associations
        XNetXnAddrToInAddr(&ServerXnAddr, &XnKid1, &ServerInAddr);

        if (FALSE == XNetInAddrToXnAddrTable[dwTableIndex].bInAddr) {
            ZeroMemory(&InAddr, sizeof(InAddr));
        }
        else if (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bLocal) {
            InAddr.s_addr = htonl(INADDR_LOOPBACK);
        }
        else if (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bRegistered) {
            CopyMemory(&InAddr, &ServerInAddr, sizeof(InAddr));
        }
        else {
            InAddr.s_addr = INADDR_BROADCAST;
        }

        bTestPassed = TRUE;
        bException = FALSE;

        __try {
            // Call XNetInAddrToXnAddr
            dwReturnCode = XNetInAddrToXnAddr(InAddr, (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bXnAddr) ? &XnAddr1 : NULL, (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bXnKid) ? &XnKid2 : NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "XNetInAddrToXnAddr RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "XNetInAddrToXnAddr caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "XNetInAddrToXnAddr did not RIP");
            }

            if (dwReturnCode != XNetInAddrToXnAddrTable[dwTableIndex].dwReturnCode) {
                xLog(hLog, XLL_FAIL, "dwReturnCode - EXPECTED: %u; RECEIVED: %u", XNetInAddrToXnAddrTable[dwTableIndex].dwReturnCode, dwReturnCode);
            }
            else if (0 == dwReturnCode) {
                if (0 != memcmp((TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bLocal) ? &LocalXnAddr : &ServerXnAddr, &XnAddr1, sizeof(XnAddr1))) {
                    xLog(hLog, XLL_FAIL, "xnaddr difference");
                    bTestPassed = FALSE;
                }

                if ((FALSE == XNetInAddrToXnAddrTable[dwTableIndex].bLocal) && (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bXnKid)) {
                    if (0 != memcmp(&XnKid1, &XnKid2, sizeof(XnKid1))) {
                        xLog(hLog, XLL_FAIL, "xnkid difference");
                        bTestPassed = FALSE;
                    }
                }

                if (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bAgain) {
                    // Call XNetInAddrToXnAddr
                    dwReturnCode = XNetInAddrToXnAddr(InAddr, (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bXnAddr) ? &XnAddr2 : NULL, (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bXnKid) ? &XnKid2 : NULL);
                    if (0 != dwReturnCode) {
                        xLog(hLog, XLL_FAIL, "Second XNetInAddrToXnAddr - EXPECTED: %u; RECEIVED: %u", 0, dwReturnCode);
                        bTestPassed = FALSE;
                    }
                    else {
                        if (0 != memcmp(&XnAddr1, &XnAddr2, sizeof(XnAddr1))) {
                            xLog(hLog, XLL_FAIL, "Second xnaddr difference");
                            bTestPassed = FALSE;
                        }

                        if (TRUE == XNetInAddrToXnAddrTable[dwTableIndex].bXnKid) {
                            if (0 != memcmp(&XnKid1, &XnKid2, sizeof(XnKid1))) {
                                xLog(hLog, XLL_FAIL, "Second xnkid difference");
                                bTestPassed = FALSE;
                            }
                        }
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "XNetInAddrToXnAddr succeeded");
                }
            }
            else {
                xLog(hLog, XLL_PASS, "dwReturnCode - OUT: %u", dwReturnCode);
            }

        }

        // Unregister key pair
        XNetUnregisterKey(&XnKid1);

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate net subsystem if necessary
    if (TRUE == bXnetInitialized) {
        XNetRelease();
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace




#else



VOID
WINAPI
XNetInAddrToXnAddrTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetInAddrToXnAddr - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long                       FromInAddr;
    // dwMessageType is the type of received message
    DWORD                        dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                        dwMessageSize;
    // pMessage is a pointer to the received message
    char                         *pMessage;
    // XNetInAddrToXnAddrComplete is the result
    XNETINADDRTOXNADDR_COMPLETE  XNetInAddrToXnAddrComplete;

    // LocalXnAddr is the address of the local machine
    XNADDR                       LocalXnAddr;

    // dwReturnCode is the return code of the operation
    int                          dwReturnCode;



    // Get the local xnaddr
    do {
        dwReturnCode = XNetGetTitleXnAddr(&LocalXnAddr);
        if (0 == dwReturnCode) {
            Sleep(SLEEP_ZERO_TIME);
        }
    } while (0 == dwReturnCode);

    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if ((NETSYNC_MSGTYPE_SERVER == dwMessageType) && ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId))) {
            NetsyncFreeMessage(pMessage);
            break;
        }

        // Send the server xnaddr
        XNetInAddrToXnAddrComplete.dwMessageId = XNETINADDRTOXNADDR_COMPLETE_MSG;
        CopyMemory(&XNetInAddrToXnAddrComplete.XnAddr, &LocalXnAddr, sizeof(XNetInAddrToXnAddrComplete.XnAddr));
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(XNetInAddrToXnAddrComplete), (char *) &XNetInAddrToXnAddrComplete);

        NetsyncFreeMessage(pMessage);
    }
}

#endif

#endif // _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\XNetRegisterKey.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  XNetRegisterKey.c

Abstract:

  This modules tests XNetRegisterKey

Author:

  Steven Kehrli (steveke) 12-Jul-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef _XBOX

using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// XNetRegisterKey messages

#define XNETREGISTERKEY_REQUEST_MSG   NETSYNC_MSG_USER + 350 + 1
#define XNETREGISTERKEY_COMPLETE_MSG  NETSYNC_MSG_USER + 350 + 2

typedef struct _XNETREGISTERKEY_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bServerAccept;
    XNADDR   XnAddr;
    XNKID    XnKid;
    XNKEY    XnKey;
    BOOL     bAgain;
} XNETREGISTERKEY_REQUEST, *PXNETREGISTERKEY_REQUEST;

typedef struct _XNETREGISTERKEY_COMPLETE {
    DWORD    dwMessageId;
    XNADDR   XnAddr;
} XNETREGISTERKEY_COMPLETE, *PXNETREGISTERKEY_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

using namespace XNetAPINamespace;

namespace XNetAPINamespace {

typedef struct _XNETKEYPAIRS {
    XNKID                 XnKid;
    XNKEY                 XnKey;
    struct _XNETKEYPAIRS  *pNextPair;
} XNETKEYPAIRS, *PXNETKEYPAIRS;

typedef struct _XNETREGISTERKEY_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL     bXnetInitialized;                        // bXnetInitialized indicates if the net subsystem is initialized
    BOOL     bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD    dwSocket;                                // dwSocket indicates the socket to be created
    BOOL     bConnect;                                // bConnect indicates if the socket is connected
    BOOL     bMaxKeyPairs;                            // bMaxKeyPairs indicates if the maximum key pairs are registered
    BOOL     bXnKid;                                  // bXnKid indicates if the xnkid is valid
    BOOL     bXnKey;                                  // bXnKey indicates if the xnkey is valid
    BOOL     bAgain;                                  // bAgain indicates if the process should be repeated
    BOOL     bUnregister;                             // bUnregister indicates if the key pair is unregistered
    DWORD    dwReturnCode;                            // dwReturnCode is the return code of the operation
    BOOL     bRIP;                                    // Specifies a RIP test case
} XNETREGISTERKEY_TABLE, *PXNETREGISTERKEY_TABLE;

static XNETREGISTERKEY_TABLE XNetRegisterKeyTable[] =
{
    { "35.1 Not Initialized",       FALSE, FALSE, SOCKET_INVALID_SOCKET, FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  WSANOTINITIALISED, FALSE },
    { "35.2 Valid TCP A",           TRUE,  TRUE,  SOCKET_TCP,            FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  0,                 FALSE },
    { "35.3 Valid TCP C",           TRUE,  TRUE,  SOCKET_TCP,            TRUE,  FALSE, TRUE,  TRUE,  FALSE, TRUE,  0,                 FALSE },
    { "35.4 Valid UDP",             TRUE,  TRUE,  SOCKET_UDP,            TRUE,  FALSE, TRUE,  TRUE,  FALSE, TRUE,  0,                 FALSE },
    { "35.5 Again TCP A",           TRUE,  TRUE,  SOCKET_TCP,            FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "35.6 Again TCP C",           TRUE,  TRUE,  SOCKET_TCP,            TRUE,  FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "35.7 Again UDP",             TRUE,  TRUE,  SOCKET_UDP,            TRUE,  FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "35.8 Max Key Pairs",         TRUE,  TRUE,  SOCKET_INVALID_SOCKET, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  WSAENOMORE,        FALSE },
    { "35.9 NULL xnkid",            TRUE,  TRUE,  SOCKET_INVALID_SOCKET, FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE,  0,                 TRUE  },
    { "35.10 NULL xnkey",           TRUE,  TRUE,  SOCKET_INVALID_SOCKET, FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  0,                 TRUE  },
    { "35.11 NULL xnkid and xnkey", TRUE,  TRUE,  SOCKET_INVALID_SOCKET, FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  0,                 TRUE  },
    { "35.12 Persist Key Pair",     TRUE,  TRUE,  SOCKET_INVALID_SOCKET, FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,                 FALSE },
    { "35.13 Not Initialized",      FALSE, FALSE, SOCKET_INVALID_SOCKET, FALSE, FALSE, TRUE,  TRUE,  FALSE, TRUE,  WSANOTINITIALISED, FALSE }
};

#define XNetRegisterKeyTableCount (sizeof(XNetRegisterKeyTable) / sizeof(XNETREGISTERKEY_TABLE))

NETSYNC_TYPE_THREAD  XNetRegisterKeyTestSessionXbox =
{
    1,
    XNetRegisterKeyTableCount,
    L"xnetapi_xbox.dll",
    "XNetRegisterKeyTestServer"
};



VOID
XNetRegisterKeyTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetRegisterKey

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                    lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                    lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                    dwTableIndex;

    // bXnetInitialized indicates if the net subsystem is initialized
    BOOL                     bXnetInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                  WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                   hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD      NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                   NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                  LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                  HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                  CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                   FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                    dwMessageSize;
    // pMessage is a pointer to the received message
    char                     *pMessage;
    // XNetRegisterKeyRequest is the request sent to the server
    XNETREGISTERKEY_REQUEST  XNetRegisterKeyRequest;

    // pXnetKeyPairList is a pointer to the list of xnet key pairs
    PXNETKEYPAIRS            pXnetKeyPairList = NULL;
    // pXnetKeyPair is a pointer to the xnet key pair
    PXNETKEYPAIRS            pXnetKeyPair;

    // XnKid is the xnkid
    XNKID                    XnKid;
    // XnKey is the xnkey
    XNKEY                    XnKey;
    // LocalXnAddr is the address of the local machine
    XNADDR                   LocalXnAddr;
    // ServerXnAddr is the address of the netsync server
    XNADDR                   ServerXnAddr;
    // ServerInAddr is the address of the netsync server
    u_long                   ServerInAddr;

    // sSocket is the socket descriptor
    SOCKET                   sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                   nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int                      iTimeout;
    // Nonblock sets the socket to blocking or non-blocking mode
    u_long                   Nonblock;

    // localname is the local address
    SOCKADDR_IN              localname;
    // remotename is the remote address
    SOCKADDR_IN              remotename;

    // SendBuffer10 is the send buffer
    char                     SendBuffer10[BUFFER_10_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                     RecvBufferLarge[BUFFER_LARGE_LEN + 1];

    // bException indicates if an exception occurred
    BOOL                     bException;
    // dwReturnCode is the return code of the operation
    int                      dwReturnCode;
    // bTestPassed indicates if the test passed
    BOOL                     bTestPassed;

    // szFunctionName is the function name
    CHAR                     szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "XNetRegisterKey v%04x", WinsockVersion);
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_XNetRegisterKey+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_XNetRegisterKey-");

    // Determine the remote netsync server type
    NetsyncTypeSession = XNetRegisterKeyTestSessionXbox;

    for (dwTableIndex = 0; dwTableIndex < XNetRegisterKeyTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, XNetRegisterKeyTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, XNetRegisterKeyTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != XNetRegisterKeyTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, XNetRegisterKeyTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == XNetRegisterKeyTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of the net subsystem
        if (bXnetInitialized != XNetRegisterKeyTable[dwTableIndex].bXnetInitialized) {
            // Initialize or terminate net subsystem as necessary
            if (TRUE == XNetRegisterKeyTable[dwTableIndex].bXnetInitialized) {
                XNetAddRef();
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
                XNetRelease();
            }

            // Update the state of net subsystem
            bXnetInitialized = XNetRegisterKeyTable[dwTableIndex].bXnetInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == XNetRegisterKeyTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Get the local xnaddr
        do {
            dwReturnCode = XNetGetTitleXnAddr(&LocalXnAddr);
            if (0 == dwReturnCode) {
                Sleep(SLEEP_ZERO_TIME);
            }
        } while (0 == dwReturnCode);

        // Register key pairs
        if (TRUE == XNetRegisterKeyTable[dwTableIndex].bMaxKeyPairs) {
            do {
                // Allocate memory for the new key pair
                pXnetKeyPair = (PXNETKEYPAIRS) xMemAlloc(hMemObject, sizeof(XNETKEYPAIRS));

                // Create the new key pair
                XNetCreateKey(&pXnetKeyPair->XnKid, &pXnetKeyPair->XnKey);

                // Register the new key pair
                dwReturnCode = XNetRegisterKey(&pXnetKeyPair->XnKid, &pXnetKeyPair->XnKey);
                if (0 == dwReturnCode) {
                    // Add the new key pair to the list
                    pXnetKeyPair->pNextPair = pXnetKeyPairList;
                    pXnetKeyPairList = pXnetKeyPair;
                }
                else {
                    // Free the new key pair
                    xMemFree(hMemObject, pXnetKeyPair);
                }
            } while (0 == dwReturnCode);
        }

        // Clear the xnaddr, xnkid and xnkey
        ZeroMemory(&ServerXnAddr, sizeof(ServerXnAddr));
        ZeroMemory(&XnKid, sizeof(XnKid));
        ZeroMemory(&XnKey, sizeof(XnKey));
        XNetCreateKey(&XnKid, &XnKey);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INVALID_SOCKET == XNetRegisterKeyTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & XNetRegisterKeyTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & XNetRegisterKeyTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        if (INVALID_SOCKET != sSocket) {
            // Set the send and receive timeout values to 5 and 15 sec
            iTimeout = 15000;
            setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            iTimeout = 5000;
            setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        }

        // Bind the socket
        if (INVALID_SOCKET != sSocket) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if ((0 != (SOCKET_TCP & XNetRegisterKeyTable[dwTableIndex].dwSocket)) && (FALSE == XNetRegisterKeyTable[dwTableIndex].bConnect)) {
            listen(sSocket, SOMAXCONN);
        }

        if (SOCKET_INVALID_SOCKET != XNetRegisterKeyTable[dwTableIndex].dwSocket) {
            // Initialize the connect request
            XNetRegisterKeyRequest.dwMessageId = XNETREGISTERKEY_REQUEST_MSG;
            if (0 != (SOCKET_TCP & XNetRegisterKeyTable[dwTableIndex].dwSocket)) {
                XNetRegisterKeyRequest.nSocketType = SOCK_STREAM;
            }
            else {
                XNetRegisterKeyRequest.nSocketType = SOCK_DGRAM;
            }
            XNetRegisterKeyRequest.Port = CurrentPort;
            XNetRegisterKeyRequest.bServerAccept = (XNetRegisterKeyTable[dwTableIndex].bConnect) && (0 != (SOCKET_TCP & XNetRegisterKeyTable[dwTableIndex].dwSocket));
            CopyMemory(&XNetRegisterKeyRequest.XnAddr, &LocalXnAddr, sizeof(XNetRegisterKeyRequest.XnAddr));
            CopyMemory(&XNetRegisterKeyRequest.XnKid, &XnKid, sizeof(XnKid));
            CopyMemory(&XNetRegisterKeyRequest.XnKey, &XnKey, sizeof(XnKey));
            XNetRegisterKeyRequest.bAgain = XNetRegisterKeyTable[dwTableIndex].bAgain;

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(XNetRegisterKeyRequest), (char *) &XNetRegisterKeyRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            CopyMemory(&ServerXnAddr, &((XNETREGISTERKEY_COMPLETE *) pMessage)->XnAddr, sizeof(ServerXnAddr));
            NetsyncFreeMessage(pMessage);
        }

        // Initialize the buffers
        sprintf(SendBuffer10, "%05d%05d", 1, 1);

        bTestPassed = TRUE;
        bException = FALSE;

        __try {
            // Call XNetRegisterKey
            dwReturnCode = XNetRegisterKey((TRUE == XNetRegisterKeyTable[dwTableIndex].bXnKid) ? &XnKid : NULL, (TRUE == XNetRegisterKeyTable[dwTableIndex].bXnKey) ? &XnKey : NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == XNetRegisterKeyTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "XNetRegisterKey RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "XNetRegisterKey caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == XNetRegisterKeyTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "XNetRegisterKey did not RIP");
            }

            if (dwReturnCode != XNetRegisterKeyTable[dwTableIndex].dwReturnCode) {
                xLog(hLog, XLL_FAIL, "dwReturnCode - EXPECTED: %u; RECEIVED: %u", XNetRegisterKeyTable[dwTableIndex].dwReturnCode, dwReturnCode);
            }
            else if (0 == dwReturnCode) {
                if (SOCKET_INVALID_SOCKET != XNetRegisterKeyTable[dwTableIndex].dwSocket) {
                    // Resolve the address
                    XNetXnAddrToInAddr(&ServerXnAddr, &XnKid, (IN_ADDR *) &ServerInAddr);

                    if (TRUE == XNetRegisterKeyTable[dwTableIndex].bConnect) {
                        // Connect the socket
                        ZeroMemory(&remotename, sizeof(remotename));
                        remotename.sin_family = AF_INET;
                        remotename.sin_addr.s_addr = ServerInAddr;
                        remotename.sin_port = htons(CurrentPort);

                        if (SOCKET_ERROR == connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename))) {
                            xLog(hLog, XLL_FAIL, "connect failed - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                    }

                    // Send the connect request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(XNetRegisterKeyRequest), (char *) &XNetRegisterKeyRequest);

                    // Wait for the connect complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if ((FALSE == XNetRegisterKeyTable[dwTableIndex].bConnect) && (0 != (SOCKET_TCP & XNetRegisterKeyTable[dwTableIndex].dwSocket))) {
                        Nonblock = 1;
                        ioctlsocket(sSocket, FIONBIO, &Nonblock);

                        // Accept the socket
                        nsSocket = accept(sSocket, NULL, NULL);
                        if (INVALID_SOCKET == nsSocket) {
                            xLog(hLog, XLL_FAIL, "accept failed - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }

                        Nonblock = 0;
                        ioctlsocket(nsSocket, FIONBIO, &Nonblock);
                        ioctlsocket(sSocket, FIONBIO, &Nonblock);
                    }

                    if (TRUE == bTestPassed) {
                        if (SOCKET_ERROR == send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0)) {
                            xLog(hLog, XLL_FAIL, "send failed - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else if (SOCKET_ERROR == recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0)) {
                            xLog(hLog, XLL_FAIL, "recv failed - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else if (0 != strncmp(SendBuffer10, RecvBufferLarge, 10)) {
                            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                            bTestPassed = FALSE;
                        }
                    }
                }

                // Call XNetRegisterKey again
                dwReturnCode = XNetRegisterKey(&XnKid, &XnKey);
                if (WSAEALREADY != dwReturnCode) {
                    xLog(hLog, XLL_FAIL, "Second XNetRegisterKey - EXPECTED: %u; RECEIVED: %u", WSAEALREADY, dwReturnCode);
                    bTestPassed = FALSE;
                }

                if (TRUE == XNetRegisterKeyTable[dwTableIndex].bAgain) {
                    shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_BOTH);
                    if (INVALID_SOCKET != nsSocket) {
                        closesocket(nsSocket);
                    }
                    closesocket(sSocket);

                    // Send the disconnect request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(XNetRegisterKeyRequest), (char *) &XNetRegisterKeyRequest);

                    // Wait for the disconnect complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    // Unregister the key
                    XNetUnregisterKey(&XnKid);

                    // Create the socket
                    sSocket = INVALID_SOCKET;
                    nsSocket = INVALID_SOCKET;
                    if (SOCKET_INVALID_SOCKET == XNetRegisterKeyTable[dwTableIndex].dwSocket) {
                        sSocket = INVALID_SOCKET;
                    }
                    else if (0 != (SOCKET_TCP & XNetRegisterKeyTable[dwTableIndex].dwSocket)) {
                        sSocket = socket(AF_INET, SOCK_STREAM, 0);
                    }
                    else if (0 != (SOCKET_UDP & XNetRegisterKeyTable[dwTableIndex].dwSocket)) {
                        sSocket = socket(AF_INET, SOCK_DGRAM, 0);
                    }

                    if (INVALID_SOCKET != sSocket) {
                        // Set the send and receive timeout values to 5 and 15 sec
                        iTimeout = 15000;
                        setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
                        iTimeout = 5000;
                        setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));
                    }

                    // Bind the socket
                    CurrentPort++;
                    if (INVALID_SOCKET != sSocket) {
                        ZeroMemory(&localname, sizeof(localname));
                        localname.sin_family = AF_INET;
                        localname.sin_port = htons(CurrentPort);
                        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
                    }

                    // Place the socket in the listening state
                    if ((0 != (SOCKET_TCP & XNetRegisterKeyTable[dwTableIndex].dwSocket)) && (FALSE == XNetRegisterKeyTable[dwTableIndex].bConnect)) {
                        listen(sSocket, SOMAXCONN);
                    }

                    // Register the key
                    XNetRegisterKey(&XnKid, &XnKey);

                    // Resolve the address
                    XNetXnAddrToInAddr(&ServerXnAddr, &XnKid, (IN_ADDR *) &ServerInAddr);

                    if (TRUE == XNetRegisterKeyTable[dwTableIndex].bConnect) {
                        // Connect the socket
                        ZeroMemory(&remotename, sizeof(remotename));
                        remotename.sin_family = AF_INET;
                        remotename.sin_addr.s_addr = ServerInAddr;
                        remotename.sin_port = htons(CurrentPort);

                        if (SOCKET_ERROR == connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename))) {
                            xLog(hLog, XLL_FAIL, "connect failed - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                    }

                    // Send the connect request
                    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(XNetRegisterKeyRequest), (char *) &XNetRegisterKeyRequest);

                    // Wait for the connect complete
                    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                    NetsyncFreeMessage(pMessage);

                    if ((FALSE == XNetRegisterKeyTable[dwTableIndex].bConnect) && (0 != (SOCKET_TCP & XNetRegisterKeyTable[dwTableIndex].dwSocket))) {
                        Nonblock = 1;
                        ioctlsocket(sSocket, FIONBIO, &Nonblock);

                        // Accept the socket
                        nsSocket = accept(sSocket, NULL, NULL);
                        if (INVALID_SOCKET == nsSocket) {
                            xLog(hLog, XLL_FAIL, "accept failed - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }

                        Nonblock = 0;
                        ioctlsocket(nsSocket, FIONBIO, &Nonblock);
                        ioctlsocket(sSocket, FIONBIO, &Nonblock);
                    }

                    if (TRUE == bTestPassed) {
                        if (SOCKET_ERROR == send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0)) {
                            xLog(hLog, XLL_FAIL, "send failed - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else if (SOCKET_ERROR == recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0)) {
                            xLog(hLog, XLL_FAIL, "recv failed - ec = %u", WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                        else if (0 != strncmp(SendBuffer10, RecvBufferLarge, 10)) {
                            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer");
                            bTestPassed = FALSE;
                        }
                    }
                }

                if (TRUE == XNetRegisterKeyTable[dwTableIndex].bUnregister) {
                    XNetUnregisterKey(&XnKid);
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "XNetRegisterKey succeeded");
                }
            }
            else {
                xLog(hLog, XLL_PASS, "dwReturnCode - OUT: %u", dwReturnCode);
            }

        }

        if (SOCKET_INVALID_SOCKET != XNetRegisterKeyTable[dwTableIndex].dwSocket) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(XNetRegisterKeyRequest), (char *) &XNetRegisterKeyRequest);
        }

        if (SOCKET_INVALID_SOCKET != XNetRegisterKeyTable[dwTableIndex].dwSocket) {
            shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_BOTH);
            if (INVALID_SOCKET != nsSocket) {
                closesocket(nsSocket);
            }
            closesocket(sSocket);
        }

        // Free key pair list
        while (NULL != pXnetKeyPairList) {
            // Get the current key pair
            pXnetKeyPair = pXnetKeyPairList;

            // Unregister the current key pair
            XNetUnregisterKey(&pXnetKeyPair->XnKid);

            // Free the current key pair
            pXnetKeyPairList = pXnetKeyPairList->pNextPair;
            xMemFree(hMemObject, pXnetKeyPair);
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate net subsystem if necessary
    if (TRUE == bXnetInitialized) {
        WSACleanup();
        XNetRelease();
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace




#else



VOID
WINAPI
XNetRegisterKeyTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetRegisterKey - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long                    FromInAddr;
    // dwMessageType is the type of received message
    DWORD                     dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                     dwMessageSize;
    // pMessage is a pointer to the received message
    char                      *pMessage;
    // XNetRegisterKeyRequest is the request
    XNETREGISTERKEY_REQUEST   XNetRegisterKeyRequest;
    // XNetRegisterKeyComplete is the result
    XNETREGISTERKEY_COMPLETE  XNetRegisterKeyComplete;

    // LocalXnAddr is the address of the local machine
    XNADDR                    LocalXnAddr;
    // ClientXnAddr is the address of the netsync client
    XNADDR                    ClientXnAddr;
    // ClientInAddr is the address of the netsync client
    u_long                    ClientInAddr;

    // sSocket is the socket descriptor
    SOCKET                    sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                    nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int                       iTimeout = 5000;

    // localname is the local address
    SOCKADDR_IN               localname;
    // remotename is the remote address
    SOCKADDR_IN               remotename;

    // RecvBufferLarge is the large recv buffer
    char                      RecvBufferLarge[BUFFER_LARGE_LEN + 1];
    // nBytes is the number of bytes sent/received
    int                       nBytes;

    // dwReturnCode is the return code of the operation
    int                       dwReturnCode;



    // Get the local xnaddr
    do {
        dwReturnCode = XNetGetTitleXnAddr(&LocalXnAddr);
        if (0 == dwReturnCode) {
            Sleep(SLEEP_ZERO_TIME);
        }
    } while (0 == dwReturnCode);

    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&XNetRegisterKeyRequest, pMessage, sizeof(XNetRegisterKeyRequest));
        NetsyncFreeMessage(pMessage);

        CopyMemory(&ClientXnAddr, &XNetRegisterKeyRequest.XnAddr, sizeof(ClientXnAddr));

        // Register the key
        XNetRegisterKey(&XNetRegisterKeyRequest.XnKid, &XNetRegisterKeyRequest.XnKey);

        // Resolve the address
        XNetXnAddrToInAddr(&ClientXnAddr, &XNetRegisterKeyRequest.XnKid, (IN_ADDR *) &ClientInAddr);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, XNetRegisterKeyRequest.nSocketType, 0);

        // Set the send and receive timeout values to 5 sec
        setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(XNetRegisterKeyRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if (TRUE == XNetRegisterKeyRequest.bServerAccept) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }

        // Send the complete
        XNetRegisterKeyComplete.dwMessageId = XNETREGISTERKEY_COMPLETE_MSG;
        CopyMemory(&XNetRegisterKeyComplete.XnAddr, &LocalXnAddr, sizeof(XNetRegisterKeyComplete.XnAddr));
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(XNetRegisterKeyComplete), (char *) &XNetRegisterKeyComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if (TRUE == XNetRegisterKeyRequest.bServerAccept) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = ClientInAddr;
            remotename.sin_port = htons(XNetRegisterKeyRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        XNetRegisterKeyComplete.dwMessageId = XNETREGISTERKEY_COMPLETE_MSG;
        CopyMemory(&XNetRegisterKeyComplete.XnAddr, &LocalXnAddr, sizeof(XNetRegisterKeyComplete.XnAddr));
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(XNetRegisterKeyComplete), (char *) &XNetRegisterKeyComplete);

        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
        nBytes = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0);
        send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, (SOCKET_ERROR == nBytes) ? 10 : nBytes, 0);

        if (TRUE == XNetRegisterKeyRequest.bAgain) {
            // Wait for the request
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_BOTH);
            if (INVALID_SOCKET != nsSocket) {
                closesocket(nsSocket);
            }
            closesocket(sSocket);

            if ((SOCK_STREAM == XNetRegisterKeyRequest.nSocketType) && (FALSE == XNetRegisterKeyRequest.bServerAccept)) {
                // Unregister the key
                XNetUnregisterKey(&XNetRegisterKeyRequest.XnKid);

                // Register the key
                XNetRegisterKey(&XNetRegisterKeyRequest.XnKid, &XNetRegisterKeyRequest.XnKey);

                // Resolve the address
                XNetXnAddrToInAddr(&ClientXnAddr, &XNetRegisterKeyRequest.XnKid, (IN_ADDR *) &ClientInAddr);
            }

            // Create the socket
            sSocket = INVALID_SOCKET;
            nsSocket = INVALID_SOCKET;
            sSocket = socket(AF_INET, XNetRegisterKeyRequest.nSocketType, 0);

            // Set the send and receive timeout values to 5 sec
            setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

            // Bind the socket
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(XNetRegisterKeyRequest.Port + 1);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

            if (TRUE == XNetRegisterKeyRequest.bServerAccept) {
                // Place the socket in listening mode
                listen(sSocket, SOMAXCONN);
            }

            // Send the complete
            XNetRegisterKeyComplete.dwMessageId = XNETREGISTERKEY_COMPLETE_MSG;
            CopyMemory(&XNetRegisterKeyComplete.XnAddr, &LocalXnAddr, sizeof(XNetRegisterKeyComplete.XnAddr));
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(XNetRegisterKeyComplete), (char *) &XNetRegisterKeyComplete);

            // Wait for the request
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);

            if (TRUE == XNetRegisterKeyRequest.bServerAccept) {
                // Accept the connection
                nsSocket = accept(sSocket, NULL, NULL);
            }
            else {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = ClientInAddr;
                remotename.sin_port = htons(XNetRegisterKeyRequest.Port + 1);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
            }

            // Send the complete
            XNetRegisterKeyComplete.dwMessageId = XNETREGISTERKEY_COMPLETE_MSG;
            CopyMemory(&XNetRegisterKeyComplete.XnAddr, &LocalXnAddr, sizeof(XNetRegisterKeyComplete.XnAddr));
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(XNetRegisterKeyComplete), (char *) &XNetRegisterKeyComplete);

            ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
            nBytes = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0);
            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, (SOCKET_ERROR == nBytes) ? 10 : nBytes, 0);
        }

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }

        // Unregister the key
        XNetUnregisterKey(&XNetRegisterKeyRequest.XnKid);
    }
}

#endif

#endif // _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\XNetXnAddrToInAddr.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  XNetXnAddrToInAddr.c

Abstract:

  This modules tests XNetXnAddrToInAddr

Author:

  Steven Kehrli (steveke) 23-Jul-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef _XBOX

using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// XNetXnAddrToInAddr messages

#define XNETXNADDRTOINADDR_REQUEST_MSG   NETSYNC_MSG_USER + 370 + 1
#define XNETXNADDRTOINADDR_COMPLETE_MSG  NETSYNC_MSG_USER + 370 + 2

typedef struct _XNETXNADDRTOINADDR_REQUEST {
    DWORD    dwMessageId;
} XNETXNADDRTOINADDR_REQUEST, *PXNETXNADDRTOINADDR_REQUEST;

typedef struct _XNETXNADDRTOINADDR_COMPLETE {
    DWORD    dwMessageId;
    XNADDR   XnAddr;
} XNETXNADDRTOINADDR_COMPLETE, *PXNETXNADDRTOINADDR_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _XNETXNADDRTOINADDR_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL     bXnetInitialized;                        // bXnetInitialized indicates if the net subsystem is initialized
    BOOL     bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    BOOL     bRegistered;                             // bRegistered indicates if the key pair is registered
    BOOL     bLocal;                                  // bLocal indicates if the local xnaddr is used
    BOOL     bMaxSecReg;                              // bMaxSecReg indicates if the maximum security associations are registered
    BOOL     bXnAddr;                                 // bXnAddr indicates if the xnaddr is valid
    BOOL     bXnKid;                                  // bXnKid indicates if the xnkid is valid
    BOOL     bInAddr;                                 // bInAddr indicates if the inaddr is valid
    BOOL     bAgain;                                  // bAgain indicates if the process should be repeated
    DWORD    dwReturnCode;                            // dwReturnCode is the return code of the operation
    BOOL     bRIP;                                    // Specifies a RIP test case
} XNETXNADDRTOINADDR_TABLE, *PXNETXNADDRTOINADDR_TABLE;

static XNETXNADDRTOINADDR_TABLE XNetXnAddrToInAddrTable[] =
{
    { "37.1 Not Initialized",  FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSANOTINITIALISED, FALSE },
    { "37.2 Not Registered",   TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSAEINVAL,         FALSE },
    { "37.3 Valid",            TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, 0,                 FALSE },
    { "37.4 Again",            TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "37.5 Local",            TRUE,  TRUE,  TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  FALSE, 0,                 FALSE },
    { "37.6 Max Sec Assoc",    TRUE,  TRUE,  TRUE,  FALSE, TRUE,  TRUE,  TRUE,  TRUE,  FALSE, WSAENOMORE,        FALSE },
    { "37.7 NULL xnaddr",      TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE, 0,                 TRUE  },
    { "37.8 NULL xnkid",       TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, TRUE,  FALSE, 0,                 TRUE  },
    { "37.9 NULL inaddr",      TRUE,  TRUE,  TRUE,  FALSE, FALSE, TRUE,  TRUE,  FALSE, FALSE, 0,                 TRUE  },
    { "37.10 Not Initialized", FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  TRUE,  FALSE, WSANOTINITIALISED, FALSE }
};

#define XNetXnAddrToInAddrTableCount (sizeof(XNetXnAddrToInAddrTable) / sizeof(XNETXNADDRTOINADDR_TABLE))

NETSYNC_TYPE_THREAD  XNetXnAddrToInAddrTestSessionXbox =
{
    1,
    XNetXnAddrToInAddrTableCount,
    L"xnetapi_xbox.dll",
    "XNetXnAddrToInAddrTestServer"
};



VOID
XNetXnAddrToInAddrTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN LPSTR   lpszNetsyncRemote,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetXnAddrToInAddr

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  lpszNetsyncRemote - pointer to the netsync remote address
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                       lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                       lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                       dwTableIndex;

    // bXnetInitialized indicates if the net subsystem is initialized
    BOOL                        bXnetInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                     WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                      hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD         NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                      NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                     LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                     HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                     CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                      FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                       dwMessageSize;
    // pMessage is a pointer to the received message
    char                        *pMessage;
    // XNetXnAddrToInAddrRequest is the request sent to the server
    XNETXNADDRTOINADDR_REQUEST  XNetXnAddrToInAddrRequest;

    // LocalXnAddr is the address of the client
    XNADDR                      LocalXnAddr;
    // ServerXnAddr is the address of the netsync server
    XNADDR                      ServerXnAddr;

    // XnKid is the xnkid
    XNKID                       XnKid;
    // XnKey is the xnkey
    XNKEY                       XnKey;
    // XnAddr is the xnaddr address
    XNADDR                      XnAddr;
    // InAddr1 is the first inaddr address
    IN_ADDR                     InAddr1;
    // InAddr2 is the second inaddr address
    IN_ADDR                     InAddr2;

    // bException indicates if an exception occurred
    BOOL                        bException;
    // dwReturnCode is the return code of the operation
    int                         dwReturnCode;
    // bTestPassed indicates if the test passed
    BOOL                        bTestPassed;

    // szFunctionName is the function name
    CHAR                        szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "XNetXnAddrToInAddr");
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_XNetXnAddrToInAddr+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_XNetXnAddrToInAddr-");

    // Determine the remote netsync server type
    NetsyncTypeSession = XNetXnAddrToInAddrTestSessionXbox;

    for (dwTableIndex = 0; dwTableIndex < XNetXnAddrToInAddrTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, XNetXnAddrToInAddrTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, XNetXnAddrToInAddrTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != XNetXnAddrToInAddrTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, XNetXnAddrToInAddrTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == XNetXnAddrToInAddrTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of the net subsystem
        if (bXnetInitialized != XNetXnAddrToInAddrTable[dwTableIndex].bXnetInitialized) {
            // Initialize or terminate net subsystem as necessary
            if (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bXnetInitialized) {
                XNetAddRef();
            }
            else {
                XNetRelease();
            }

            // Update the state of net subsystem
            bXnetInitialized = XNetXnAddrToInAddrTable[dwTableIndex].bXnetInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;

            // Get the server xnaddr
            XNetXnAddrToInAddrRequest.dwMessageId = XNETXNADDRTOINADDR_REQUEST_MSG;
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(XNetXnAddrToInAddrRequest), (char *) &XNetXnAddrToInAddrRequest);

            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            CopyMemory(&ServerXnAddr, &((XNETXNADDRTOINADDR_COMPLETE *) pMessage)->XnAddr, sizeof(ServerXnAddr));
            NetsyncFreeMessage(pMessage);
        }

        // Get the local xnaddr
        do {
            dwReturnCode = XNetGetTitleXnAddr(&LocalXnAddr);
            if (0 == dwReturnCode) {
                Sleep(SLEEP_ZERO_TIME);
            }
        } while (0 == dwReturnCode);

        // Clear the xnkid and xnkey
        ZeroMemory(&XnKid, sizeof(XnKid));
        ZeroMemory(&XnKey, sizeof(XnKey));
        XNetCreateKey(&XnKid, &XnKey);

        // Register key pair
        if (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bRegistered) {
            XNetRegisterKey(&XnKid, &XnKey);
        }

        // Register security associations
        if (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bMaxSecReg) {
            ZeroMemory(&XnAddr, sizeof(XnAddr));
            do {
                // Generate random xnadrr
                XNetRandom(XnAddr.abEnet, sizeof(XnAddr.abEnet));

                // Call XNetXnAddrToInAddr
                dwReturnCode = XNetXnAddrToInAddr(&XnAddr, &XnKid, &InAddr1);
            } while (0 == dwReturnCode);
        }

        if (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bLocal) {
            CopyMemory(&XnAddr, &LocalXnAddr, sizeof(XnAddr));
        }
        else {
            CopyMemory(&XnAddr, &ServerXnAddr, sizeof(XnAddr));
        }

        bTestPassed = TRUE;
        bException = FALSE;

        __try {
            // Call XNetXnAddrToInAddr
            dwReturnCode = XNetXnAddrToInAddr((TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bXnAddr) ? &XnAddr : NULL, (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bXnKid) ? &XnKid : NULL, (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bInAddr) ? &InAddr1 : NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "XNetXnAddrToInAddr RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "XNetXnAddrToInAddr caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "XNetXnAddrToInAddr did not RIP");
            }

            if (dwReturnCode != XNetXnAddrToInAddrTable[dwTableIndex].dwReturnCode) {
                xLog(hLog, XLL_FAIL, "dwReturnCode - EXPECTED: %u; RECEIVED: %u", XNetXnAddrToInAddrTable[dwTableIndex].dwReturnCode, dwReturnCode);
            }
            else if (0 == dwReturnCode) {
                if (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bLocal) {
                    if (htonl(INADDR_LOOPBACK) != InAddr1.s_addr) {
                        xLog(hLog, XLL_FAIL, "in_addr - EXPECTED: 127.0.0.1; RECEIVED: %u.%u.%u.%u", InAddr1.S_un.S_un_b.s_b1, InAddr1.S_un.S_un_b.s_b2, InAddr1.S_un.S_un_b.s_b3, InAddr1.S_un.S_un_b.s_b4);
                        bTestPassed = FALSE;
                    }
                }
                else {
                    if (0 != InAddr1.S_un.S_un_b.s_b1) {
                        xLog(hLog, XLL_FAIL, "in_addr - EXPECTED: 0.b.c.d; RECEIVED: %u.%u.%u.%u", InAddr1.S_un.S_un_b.s_b1, InAddr1.S_un.S_un_b.s_b2, InAddr1.S_un.S_un_b.s_b3, InAddr1.S_un.S_un_b.s_b4);
                        bTestPassed = FALSE;
                    }
                }

                if (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bAgain) {
                    // Call XNetXnAddrToInAddr
                    dwReturnCode = XNetXnAddrToInAddr((TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bXnAddr) ? &XnAddr : NULL, (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bXnKid) ? &XnKid : NULL, (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bInAddr) ? &InAddr2 : NULL);
                    if (0 != dwReturnCode) {
                        xLog(hLog, XLL_FAIL, "Second XNetXnAddrToInAddr - EXPECTED: %u; RECEIVED: %u", 0, dwReturnCode);
                        bTestPassed = FALSE;
                    }
                    else if (0 != memcmp(&InAddr1, &InAddr2, sizeof(InAddr1))) {
                        xLog(hLog, XLL_FAIL, "Second in_addr - EXPECTED: %u.%u.%u.%u; RECEIVED: %u.%u.%u.%u", InAddr1.S_un.S_un_b.s_b1, InAddr1.S_un.S_un_b.s_b2, InAddr1.S_un.S_un_b.s_b3, InAddr1.S_un.S_un_b.s_b4, InAddr2.S_un.S_un_b.s_b1, InAddr2.S_un.S_un_b.s_b2, InAddr2.S_un.S_un_b.s_b3, InAddr2.S_un.S_un_b.s_b4);
                        bTestPassed = FALSE;
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "XNetXnAddrToInAddr succeeded");
                }
            }
            else {
                xLog(hLog, XLL_PASS, "dwReturnCode - OUT: %u", dwReturnCode);
            }

        }

        // Unregister key pair
        if (TRUE == XNetXnAddrToInAddrTable[dwTableIndex].bRegistered) {
            XNetUnregisterKey(&XnKid);
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate net subsystem if necessary
    if (TRUE == bXnetInitialized) {
        XNetRelease();
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace




#else



VOID
WINAPI
XNetXnAddrToInAddrTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetXnAddrToInAddr - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long                       FromInAddr;
    // dwMessageType is the type of received message
    DWORD                        dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                        dwMessageSize;
    // pMessage is a pointer to the received message
    char                         *pMessage;
    // XNetXnAddrToInAddrComplete is the result
    XNETXNADDRTOINADDR_COMPLETE  XNetXnAddrToInAddrComplete;

    // LocalXnAddr is the address of the local machine
    XNADDR                       LocalXnAddr;

    // dwReturnCode is the return code of the operation
    int                          dwReturnCode;



    // Get the local xnaddr
    do {
        dwReturnCode = XNetGetTitleXnAddr(&LocalXnAddr);
        if (0 == dwReturnCode) {
            Sleep(SLEEP_ZERO_TIME);
        }
    } while (0 == dwReturnCode);

    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if ((NETSYNC_MSGTYPE_SERVER == dwMessageType) && ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId))) {
            NetsyncFreeMessage(pMessage);
            break;
        }

        // Send the server xnaddr
        XNetXnAddrToInAddrComplete.dwMessageId = XNETXNADDRTOINADDR_COMPLETE_MSG;
        CopyMemory(&XNetXnAddrToInAddrComplete.XnAddr, &LocalXnAddr, sizeof(XNetXnAddrToInAddrComplete.XnAddr));
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(XNetXnAddrToInAddrComplete), (char *) &XNetXnAddrToInAddrComplete);

        NetsyncFreeMessage(pMessage);
    }
}

#endif

#endif // _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\bvt\client.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.c

Abstract:

  Entry points for xnetbvt.dll

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetBVTNamespace;

namespace XNetBVTNamespace {

VOID
WINAPI
StartTest(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Test entry point

Arguments:

  hLog - handle to the xLog log object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // hMemObject is the mem object
    HANDLE  hMemObject = INVALID_HANDLE_VALUE;
    // pNetsyncRemoteNt is a pointer to the remote netsync server
    LPSTR   pNetsyncRemote = NULL;



    // Create the private heap
    hMemObject = xMemCreate();
    if (INVALID_HANDLE_VALUE == hMemObject) {
        return;
    }

    // Set the component and subcomponent
    xSetComponent(hLog, "Network", "XNet");

    // Get the remote netsync addr
    pNetsyncRemote = GetIniString(hMemObject, "xnetbvt", "NetsyncRemote");

    // Test UDP
    BVT_UDPTest(hLog, pNetsyncRemote);

    // Test TCP
    BVT_TCPTest(hLog, pNetsyncRemote);

    if (NULL != pNetsyncRemote) {
        xMemFree(hMemObject, pNetsyncRemote);
    }

    // Free the private heap
    xMemClose(hMemObject);
}



VOID
WINAPI
EndTest(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Test exit point

Return Value:

  None

------------------------------------------------------------------------------*/
{
}

} // namespace XNetBVTNamespace



#ifdef __cplusplus
extern "C" {
#endif

// Export table for harness

#pragma data_seg(EXPORT_SECTION_NAME)
DECLARE_EXPORT_DIRECTORY(xnetbvt)
#pragma data_seg()

BEGIN_EXPORT_TABLE(xnetbvt)
    EXPORT_TABLE_ENTRY("StartTest", StartTest)
    EXPORT_TABLE_ENTRY("EndTest", EndTest)
END_EXPORT_TABLE(xnetbvt)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\XNetDnsRelease.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  XNetDnsRelease.c

Abstract:

  This modules tests XNetDnsRelease

Author:

  Steven Kehrli (steveke) 14-Nov-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _XNETDNSRELEASE_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL     bXnetInitialized;                        // bXnetInitialized indicates if the net subsystem is initialized
    BOOL     bKnownHost;                              // bKnownHost indicates if the hostname is known
    BOOL     bWait;                                   // bWait indicates if dns resolution completes
    BOOL     bXnDNS;                                  // bXnDNS indicates if the xndns pointer is non-NULL
    DWORD    dwReturnCode;                            // dwReturnCode is the return code of the operation
    BOOL     bRIP;                                    // Specifies a RIP test case
} XNETDNSRELEASE_TABLE, *PXNETDNSRELEASE_TABLE;

static XNETDNSRELEASE_TABLE XNetDnsReleaseInsecureTable[] =
{
    { "40.1 Not Initialized",      FALSE, TRUE,  TRUE,  TRUE,  WSANOTINITIALISED, FALSE },
    { "40.2 Known Host Wait",      TRUE,  TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "40.3 Unknown Host Wait",    TRUE,  FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "40.4 Known Host No Wait",   TRUE,  TRUE,  FALSE, TRUE,  0,                 FALSE },
    { "40.5 Unknown Host No Wait", TRUE,  FALSE, FALSE, TRUE,  0,                 FALSE },
    { "40.6 NULL XNDNS",           TRUE,  TRUE,  TRUE,  FALSE, 0,                 TRUE  },
    { "40.7 Not Initialized",      FALSE, TRUE,  TRUE,  TRUE,  WSANOTINITIALISED, FALSE }
};

#define XNetDnsReleaseInsecureTableCount (sizeof(XNetDnsReleaseInsecureTable) / sizeof(XNETDNSRELEASE_TABLE))

static XNETDNSRELEASE_TABLE XNetDnsReleaseSecureTable[] =
{
    { "40.1 Not Initialized",      FALSE, TRUE,  TRUE,  TRUE,  WSANOTINITIALISED, FALSE },
    { "40.2 WSAEACCES",            TRUE,  TRUE,  FALSE, TRUE,  WSAEACCES,         FALSE },
    { "40.3 Not Initialized",      FALSE, TRUE,  TRUE,  TRUE,  WSANOTINITIALISED, FALSE }
};

#define XNetDnsReleaseSecureTableCount (sizeof(XNetDnsReleaseSecureTable) / sizeof(XNETDNSRELEASE_TABLE))



VOID
XNetDnsReleaseTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetDnsRelease

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                 lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                 lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                 dwTableIndex;

    // XnAddr is the title xnet address
    XNADDR                XnAddr;
    // dwResult is the result of XNetGetTitleXnAddr
    DWORD                 dwResult = 0;
    
    // XNetDnsReleaseTable is the test table
    XNETDNSRELEASE_TABLE  *XNetDnsReleaseTable;
    // XNetDnsReleaseTableCount is the test table count
    DWORD                 XNetDnsReleaseTableCount;

    // bXnetInitialized indicates if the net subsystem is initialized
    BOOL                  bXnetInitialized = FALSE;
    // LocalXnAddr is the address of the client
    XNADDR                LocalXnAddr;

    // lpszKnownHosts is a pointer to the list of known hosts
    LPSTR                 lpszKnownHosts = NULL;
    // lpszUnknownHosts is a pointer to the list of unknown hosts
    LPSTR                 lpszUnknownHosts = NULL;
    // lpszHostName is a pointer to a host name within the list
    LPSTR                 lpszHostName = NULL;

    // hEvent is a handle to the event
    HANDLE                hEvent = NULL;
    // pXnDNS is a pointer to the DNS entry
    XNDNS                 *pXnDNS = NULL;

    // bException indicates if an exception occurred
    BOOL                  bException;
    // dwReturnCode is the return code of the operation
    int                   dwReturnCode;
    // bTestPassed indicates if the test passed
    BOOL                  bTestPassed;



    // Set the function name
    xSetFunctionName(hLog, "XNetDnsRelease");

    // Initialize the net subsystem
    XNetAddRef();

    while (0 == (dwResult = XNetGetTitleXnAddr(&XnAddr))) {
        Sleep(1000);
    }

    // Determine the remote netsync server type
    if (0 != (XNET_GET_XNADDR_ETHERNET & dwResult)) {
        XNetDnsReleaseTable = XNetDnsReleaseSecureTable;
        XNetDnsReleaseTableCount = XNetDnsReleaseSecureTableCount;
    }
    else {
        XNetDnsReleaseTable = XNetDnsReleaseInsecureTable;
        XNetDnsReleaseTableCount = XNetDnsReleaseInsecureTableCount;
    }

    // Terminate the net subsystem
    XNetRelease();

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_XNetDnsRelease+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_XNetDnsRelease-");

    // Get the known hosts
    lpszKnownHosts = GetIniSection(hMemObject, "xnetapi_KnownHosts");

    // Enumerate the host
    if (NULL != lpszKnownHosts) {
        lpszHostName = strchr(lpszKnownHosts, '=');
        if (NULL != lpszHostName) {
            *lpszHostName = '\0';
        }
    }

    if (NULL == lpszKnownHosts) {
        xLog(hLog, XLL_BLOCK, "No Known Hosts for XNetDnsRelease");
        goto ExitTest;
    }

    // Get the unknown hosts
    lpszUnknownHosts = GetIniSection(hMemObject, "xnetapi_UnknownHosts");

    if (NULL == lpszUnknownHosts) {
        xLog(hLog, XLL_BLOCK, "No Unknown Hosts for XNetDnsRelease");
        goto ExitTest;
    }

    // Create the event
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    for (dwTableIndex = 0; dwTableIndex < XNetDnsReleaseTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, XNetDnsReleaseTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, XNetDnsReleaseTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != XNetDnsReleaseTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, XNetDnsReleaseTable[dwTableIndex].szVariationName);

        // Check the state of the net subsystem
        if (bXnetInitialized != XNetDnsReleaseTable[dwTableIndex].bXnetInitialized) {
            // Initialize or terminate net subsystem as necessary
            if (TRUE == XNetDnsReleaseTable[dwTableIndex].bXnetInitialized) {
                XNetAddRef();

                // Get the local xnaddr
                do {
                    dwReturnCode = XNetGetTitleXnAddr(&LocalXnAddr);
                    if (0 == dwReturnCode) {
                        Sleep(SLEEP_ZERO_TIME);
                    }
                } while (0 == dwReturnCode);
            }
            else {
                XNetRelease();
            }

            // Update the state of net subsystem
            bXnetInitialized = XNetDnsReleaseTable[dwTableIndex].bXnetInitialized;
        }

        // Set the host name
        lpszHostName = NULL;
        if (TRUE == XNetDnsReleaseTable[dwTableIndex].bKnownHost) {
            lpszHostName = lpszKnownHosts;
        }
        else {
            lpszHostName = lpszUnknownHosts;
        }

        bTestPassed = TRUE;
        bException = FALSE;

        if ((TRUE == XNetDnsReleaseTable[dwTableIndex].bXnetInitialized) && (TRUE == XNetDnsReleaseTable[dwTableIndex].bXnDNS)) {
            // Call XNetDnsLookup
            dwReturnCode = XNetDnsLookup(lpszHostName, hEvent, &pXnDNS);

            if ((0 == dwReturnCode) && (TRUE == XNetDnsReleaseTable[dwTableIndex].bWait)) {
                WaitForSingleObject(hEvent, INFINITE);
            }
        }

        __try {
            // Call XNetDnsRelease
            dwReturnCode = XNetDnsRelease((TRUE == XNetDnsReleaseTable[dwTableIndex].bXnDNS) ? pXnDNS : NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == XNetDnsReleaseTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "XNetDnsRelease RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "XNetDnsRelease caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == XNetDnsReleaseTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "XNetDnsRelease did not RIP");
            }

            if (dwReturnCode != XNetDnsReleaseTable[dwTableIndex].dwReturnCode) {
                xLog(hLog, XLL_FAIL, "dwReturnCode - EXPECTED: %u; RECEIVED: %u", XNetDnsReleaseTable[dwTableIndex].dwReturnCode, dwReturnCode);
            }
            else if (0 == dwReturnCode) {
                // Call XNetDnsRelease again
                dwReturnCode = XNetDnsRelease(pXnDNS);

                if (WSAEINVAL != dwReturnCode) {
                    xLog(hLog, XLL_FAIL, "Second XNetDnsRelease - EXPECTED: %u; RECEIVED: %u", WSAEINVAL, dwReturnCode);
                    bTestPassed = FALSE;
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "XNetDnsRelease succeeded");
                }

            }
            else {
                xLog(hLog, XLL_PASS, "dwReturnCode - OUT: %u", dwReturnCode);
            }
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate net subsystem if necessary
    if (TRUE == bXnetInitialized) {
        XNetRelease();
    }

    // Close the event
    CloseHandle(hEvent);

ExitTest:
    // Free the list of unknown hosts
    if (NULL != lpszUnknownHosts) {
        xMemFree(hMemObject, lpszUnknownHosts);
    }

    // Free the list of known hosts
    if (NULL != lpszKnownHosts) {
        xMemFree(hMemObject, lpszKnownHosts);
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\XNetInAddrToString.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  XNetInAddrToString.c

Abstract:

  This modules tests XNetInAddrToString

Author:

  Steven Kehrli (steveke) 21-Jun-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

typedef struct _XNETINADDRTOSTRING_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    IN_ADDR  in;                                      // in is the IPv4 network address
    BOOL     bBuffer;                                 // bBuffer indicates if the string buffer is valid
    int      nBufferSize;                             // nBufferSize indicates the size of the string buffer
    char     *cp;                                     // cp is the IPv4 dotted address string
    DWORD    dwReturnCode;                            // dwReturnCode is the return code of the operation
    BOOL     bRIP;                                    // Specifies a RIP test case
} XNETINADDRTOSTRING_TABLE, *PXNETINADDRTOSTRING_TABLE;

static XNETINADDRTOSTRING_TABLE XNetInAddrToStringTable[] =
{
    { "32.1 0x10020304",      {0x04, 0x03, 0x02, 0x10}, TRUE,  16, "4.3.2.16",        0, FALSE },
    { "32.2 0x00000000",      {0x00, 0x00, 0x00, 0x00}, TRUE,  16, "0.0.0.0",         0, FALSE },
    { "32.3 0xFF020304",      {0x04, 0x03, 0x02, 0xFF}, TRUE,  16, "4.3.2.255",       0, FALSE },
    { "32.4 0x10FF0304",      {0x04, 0x03, 0xFF, 0x10}, TRUE,  16, "4.3.255.16",      0, FALSE },
    { "32.5 0x1002FF04",      {0x04, 0xFF, 0x02, 0x10}, TRUE,  16, "4.255.2.16",      0, FALSE },
    { "32.6 0x100203FF",      {0xFF, 0x03, 0x02, 0x10}, TRUE,  16, "255.3.2.16",      0, FALSE },
    { "32.7 0xFFFFFFFF",      {0xFF, 0xFF, 0xFF, 0xFF}, TRUE,  16, "255.255.255.255", 0, FALSE },
    { "32.8 0x9FBFDFFF",      {0x9F, 0xBF, 0xDF, 0xFF}, TRUE,  16, "159.191.223.255", 0, FALSE },
    { "32.9 NULL Buffer",     {0x9F, 0xBF, 0xDF, 0xFF}, FALSE, 16, "159.191.223.255", 0, TRUE  },
    { "32.10 Large Buffer",   {0x9F, 0xBF, 0xDF, 0xFF}, TRUE,  17, "159.191.223.255", 0, FALSE },
    { "32.11 Exact Buffer",   {0x9F, 0xBF, 0xDF, 0xFF}, TRUE,  16, "159.191.223.255", 0, FALSE },
    { "32.12 Small Buffer",   {0x9F, 0xBF, 0xDF, 0xFF}, TRUE,  15, "159.191.223.25",  0, FALSE },
    { "32.13 Zero Buffer",    {0x9F, 0xBF, 0xDF, 0xFF}, TRUE,  0,  "159.191.223.255", 0, TRUE  },
    { "32.14 Neg Buffer",     {0x9F, 0xBF, 0xDF, 0xFF}, TRUE,  -1, "159.191.223.255", 0, TRUE  },
};

#define XNetInAddrToStringTableCount (sizeof(XNetInAddrToStringTable) / sizeof(XNETINADDRTOSTRING_TABLE))



VOID
XNetInAddrToStringTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetInAddrToString

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR    lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR    lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD    dwTableIndex;

    // cpBuffer is the string buffer
    char     cpBuffer[16];

    // bException indicates if an exception occurred
    BOOL     bException;
    // dwReturnCode is the return code of the operation
    int      dwReturnCode;

    // szFunctionName is the function name
    CHAR     szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    xSetFunctionName(hLog, "XNetInAddrToString");

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_XNetInAddrToString+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_XNetInAddrToString-");

    for (dwTableIndex = 0; dwTableIndex < XNetInAddrToStringTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, XNetInAddrToStringTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, XNetInAddrToStringTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != XNetInAddrToStringTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, XNetInAddrToStringTable[dwTableIndex].szVariationName);

        // Clear the buffer
        ZeroMemory(cpBuffer, sizeof(cpBuffer));

        bException = FALSE;

        __try {
            // Call XNetInAddrToString
            dwReturnCode = XNetInAddrToString(XNetInAddrToStringTable[dwTableIndex].in, (TRUE == XNetInAddrToStringTable[dwTableIndex].bBuffer) ? cpBuffer : NULL, XNetInAddrToStringTable[dwTableIndex].nBufferSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == XNetInAddrToStringTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "XNetInAddrToString RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "XNetInAddrToString caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == XNetInAddrToStringTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "XNetInAddrToString did not RIP");
            }

            if (dwReturnCode != XNetInAddrToStringTable[dwTableIndex].dwReturnCode) {
                xLog(hLog, XLL_FAIL, "dwReturnCode - EXPECTED: %u; RECEIVED: %u", XNetInAddrToStringTable[dwTableIndex].dwReturnCode, dwReturnCode);
            }
            else if (0 == dwReturnCode) {
                if (0 != strcmp(cpBuffer, XNetInAddrToStringTable[dwTableIndex].cp)) {
                    xLog(hLog, XLL_FAIL, "EXPECTED: %s; RECEIVED: %s", XNetInAddrToStringTable[dwTableIndex].cp, cpBuffer);
                }
                else {
                    xLog(hLog, XLL_PASS, "OUT: %s", cpBuffer);
                }
            }
            else {
                xLog(hLog, XLL_PASS, "dwReturnCode - OUT: %u", dwReturnCode);
            }

        }

        // End the variation
        xEndVariation(hLog);
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\XNetRandom.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  XNetRandom.c

Abstract:

  This modules tests XNetRandom

Author:

  Steven Kehrli (steveke) 5-Jul-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetAPINamespace;

#ifdef XNETAPI_CLIENT

namespace XNetAPINamespace {

#define BUFFER_PATTERN       "feFEdcDCbaBA"
#define BUFFER_PATTERN_SIZE  12

typedef struct _XNETRANDOM_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL     bXnetInitialized;                        // bXnetInitialized indicates if the net subsystem is initialized
    BOOL     bBuffer;                                 // bBuffer indicates if the buffer is valid
    UINT     nBufferSize;                             // nBufferSize indicates the size of the buffer
    DWORD    dwReturnCode;                            // dwReturnCode is the return code of the operation
    BOOL     bRIP;                                    // Specifies a RIP test case
} XNETRANDOM_TABLE, *PXNETRANDOM_TABLE;

static XNETRANDOM_TABLE XNetRandomTable[] =
{
    { "33.1 Not Initialized",      FALSE, TRUE,  12,   WSANOTINITIALISED, FALSE },
    { "33.2 0 bytes",              TRUE,  TRUE,  0,    0,                 FALSE },
    { "33.3 12 bytes",             TRUE,  TRUE,  12,   0,                 FALSE },
    { "33.4 24 bytes",             TRUE,  TRUE,  24,   0,                 FALSE },
    { "33.5 1200 bytes",           TRUE,  TRUE,  1200, 0,                 FALSE },
    { "33.6 4800 bytes",           TRUE,  TRUE,  4800, 0,                 FALSE },
    { "33.7 NULL Buffer 0 bytes",  TRUE,  FALSE, 0,    0,                 FALSE },
    { "33.8 NULL Buffer",          TRUE,  FALSE, 12,   0,                 TRUE  },
    { "33.9 Not Initialized",      FALSE, TRUE,  12,   WSANOTINITIALISED, FALSE }
};

#define XNetRandomTableCount (sizeof(XNetRandomTable) / sizeof(XNETRANDOM_TABLE))



VOID
XNetRandomTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetRandom

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR  lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR  lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD  dwTableIndex;

    // bXnetInitialized indicates if the net subsystem is initialized
    BOOL   bXnetInitialized = FALSE;

    // pBuffer1 is the buffer
    BYTE   pBuffer1[6000];
    // pBuffer2 is the buffer
    BYTE   pBuffer2[6000];
    // dwFillBuffer is a counter to fill the buffer
    DWORD  dwFillBuffer;

    // bException indicates if an exception occurred
    BOOL   bException;
    // dwReturnCode is the return code of the operation
    int    dwReturnCode;
    // bTestPassed indicates if the test passed
    BOOL   bTestPassed;



    // Set the function name
    xSetFunctionName(hLog, "XNetRandom");

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_XNetRandom+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_XNetRandom-");

    for (dwTableIndex = 0; dwTableIndex < XNetRandomTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, XNetRandomTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, XNetRandomTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != XNetRandomTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, XNetRandomTable[dwTableIndex].szVariationName);

        // Check the state of the net subsystem
        if (bXnetInitialized != XNetRandomTable[dwTableIndex].bXnetInitialized) {
            // Initialize or terminate net subsystem as necessary
            if (TRUE == XNetRandomTable[dwTableIndex].bXnetInitialized) {
                XNetAddRef();
            }
            else {
                XNetRelease();
            }

            // Update the state of net subsystem
            bXnetInitialized = XNetRandomTable[dwTableIndex].bXnetInitialized;
        }

        // Clear the buffer
        ZeroMemory(pBuffer1, sizeof(pBuffer1));
        ZeroMemory(pBuffer2, sizeof(pBuffer2));

        // Initialize the buffer
        for (dwFillBuffer = 0; dwFillBuffer < sizeof(pBuffer1); dwFillBuffer += BUFFER_PATTERN_SIZE) {
            CopyMemory(&pBuffer1[dwFillBuffer], BUFFER_PATTERN, sizeof(pBuffer1) - dwFillBuffer > BUFFER_PATTERN_SIZE ? BUFFER_PATTERN_SIZE : sizeof(pBuffer1) - dwFillBuffer);
            CopyMemory(&pBuffer2[dwFillBuffer], BUFFER_PATTERN, sizeof(pBuffer2) - dwFillBuffer > BUFFER_PATTERN_SIZE ? BUFFER_PATTERN_SIZE : sizeof(pBuffer2) - dwFillBuffer);
        }

        bTestPassed = TRUE;
        bException = FALSE;

        __try {
            // Call XNetRandom
            dwReturnCode = XNetRandom((TRUE == XNetRandomTable[dwTableIndex].bBuffer) ? pBuffer1 : NULL, XNetRandomTable[dwTableIndex].nBufferSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == XNetRandomTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "XNetRandom RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "XNetRandom caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == XNetRandomTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "XNetRandom did not RIP");
            }

            if (dwReturnCode != XNetRandomTable[dwTableIndex].dwReturnCode) {
                xLog(hLog, XLL_FAIL, "dwReturnCode - EXPECTED: %u; RECEIVED: %u", XNetRandomTable[dwTableIndex].dwReturnCode, dwReturnCode);
            }
            else if (0 == dwReturnCode) {
                // Check the buffer
                for (dwFillBuffer = 0; dwFillBuffer < sizeof(pBuffer1); dwFillBuffer += BUFFER_PATTERN_SIZE) {
                    if (0 == memcmp(&pBuffer1[dwFillBuffer], BUFFER_PATTERN, sizeof(pBuffer1) - dwFillBuffer > BUFFER_PATTERN_SIZE ? BUFFER_PATTERN_SIZE : sizeof(pBuffer1) - dwFillBuffer)) {
                        break;
                    }
                }

                if (dwFillBuffer != XNetRandomTable[dwTableIndex].nBufferSize) {
                    xLog(hLog, XLL_FAIL, "Buffer pattern - EXPECTED: %u; FOUND: %u", XNetRandomTable[dwTableIndex].nBufferSize, dwFillBuffer);
                    bTestPassed = FALSE;
                }

                if (0 != XNetRandomTable[dwTableIndex].nBufferSize) {
                    // Call XNetRandom again
                    dwReturnCode = XNetRandom(pBuffer2, XNetRandomTable[dwTableIndex].nBufferSize);

                    if (0 == memcmp(pBuffer1, pBuffer2, XNetRandomTable[dwTableIndex].nBufferSize)) {
                        xLog(hLog, XLL_FAIL, "Same random bytes");
                        bTestPassed = FALSE;
                    }
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "XNetRandom succeeded");
                }
            }
            else {
                xLog(hLog, XLL_PASS, "dwReturnCode - OUT: %u", dwReturnCode);
            }

        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate net subsystem if necessary
    if (TRUE == bXnetInitialized) {
        XNetRelease();
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\api\XNetUnregisterKey.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  XNetUnregisterKey.c

Abstract:

  This modules tests XNetUnregisterKey

Author:

  Steven Kehrli (steveke) 19-Jul-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef _XBOX

using namespace XNetAPINamespace;

namespace XNetAPINamespace {

// XNetUnregisterKey messages

#define XNETUNREGISTERKEY_REQUEST_MSG   NETSYNC_MSG_USER + 360 + 1
#define XNETUNREGISTERKEY_COMPLETE_MSG  NETSYNC_MSG_USER + 360 + 2

typedef struct _XNETUNREGISTERKEY_REQUEST {
    DWORD    dwMessageId;
    int      nSocketType;
    u_short  Port;
    BOOL     bServerAccept;
    XNADDR   XnAddr;
    XNKID    XnKid;
    XNKEY    XnKey;
} XNETUNREGISTERKEY_REQUEST, *PXNETUNREGISTERKEY_REQUEST;

typedef struct _XNETUNREGISTERKEY_COMPLETE {
    DWORD    dwMessageId;
    XNADDR   XnAddr;
} XNETUNREGISTERKEY_COMPLETE, *PXNETUNREGISTERKEY_COMPLETE;

} // namespace XNetAPINamespace



#ifdef XNETAPI_CLIENT

using namespace XNetAPINamespace;

namespace XNetAPINamespace {

typedef struct _XNETUNREGISTERKEY_TABLE {
    CHAR     szVariationName[VARIATION_NAME_LENGTH];  // szVariationName is the variation name
    BOOL     bXnetInitialized;                        // bXnetInitialized indicates if the net subsystem is initialized
    BOOL     bNetsyncConnected;                       // bNetsyncConnected indicates if the netsync client is connected
    DWORD    dwSocket;                                // dwSocket indicates the socket to be created
    BOOL     bConnect;                                // bConnect indicates if the socket is connected
    BOOL     bXnKid;                                  // bXnKid indicates if the xnkid is valid
    BOOL     bRegister;                               // bRegister indicates if the xnkid is registered
    DWORD    dwReturnCode;                            // dwReturnCode is the return code of the operation
    BOOL     bRIP;                                    // Specifies a RIP test case
} XNETUNREGISTERKEY_TABLE, *PXNETUNREGISTERKEY_TABLE;

static XNETUNREGISTERKEY_TABLE XNetUnregisterKeyTable[] =
{
    { "36.1 Not Initialized", FALSE, FALSE, SOCKET_INVALID_SOCKET, FALSE, TRUE,  TRUE,  WSANOTINITIALISED, FALSE },
    { "36.2 TCP A",           TRUE,  TRUE,  SOCKET_TCP,            FALSE, TRUE,  TRUE,  0,                 FALSE },
    { "36.3 TCP C",           TRUE,  TRUE,  SOCKET_TCP,            TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "36.4 UDP",             TRUE,  TRUE,  SOCKET_UDP,            TRUE,  TRUE,  TRUE,  0,                 FALSE },
    { "36.5 NULL xnkid",      TRUE,  TRUE,  SOCKET_INVALID_SOCKET, FALSE, FALSE, TRUE,  0,                 TRUE  },
    { "36.6 Invalid xnkid",   TRUE,  TRUE,  SOCKET_INVALID_SOCKET, FALSE, TRUE,  FALSE, WSAEINVAL,         FALSE },
    { "36.7 Not Initialized", FALSE, FALSE, SOCKET_INVALID_SOCKET, FALSE, TRUE,  TRUE,  WSANOTINITIALISED, FALSE }
};

#define XNetUnregisterKeyTableCount (sizeof(XNetUnregisterKeyTable) / sizeof(XNETUNREGISTERKEY_TABLE))

NETSYNC_TYPE_THREAD  XNetUnregisterKeyTestSessionXbox =
{
    1,
    XNetUnregisterKeyTableCount,
    L"xnetapi_xbox.dll",
    "XNetUnregisterKeyTestServer"
};



VOID
XNetUnregisterKeyTest(
    IN HANDLE  hLog,
    IN HANDLE  hMemObject,
    IN WORD    WinsockVersion,
    IN LPSTR   lpszNetsyncRemote,
    IN BOOL    bRIPs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetUnregisterKey

Arguments:

  hLog - handle to the xLog log object
  hMemObject - handle to the memory object
  WinsockVersion - requested version of Winsock
  lpszNetsyncRemote - pointer to the netsync remote address
  bRIPs - specifies RIP testing

------------------------------------------------------------------------------*/
{
    // lpszCaseTest is a pointer to the list of cases to test
    LPSTR                      lpszCaseTest = NULL;
    // lpszCaseSkip is a pointer to the list of cases to skip
    LPSTR                      lpszCaseSkip = NULL;
    // dwTableIndex is a counter to enumerate each entry in a test table
    DWORD                      dwTableIndex;

    // bXnetInitialized indicates if the net subsystem is initialized
    BOOL                       bXnetInitialized = FALSE;
    // WSAData is the details of the Winsock implementation
    WSADATA                    WSAData;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                     hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD        NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long                     NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                    LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                    HighPort = 0;
    // CurrentPort is the current port in the netsync port range
    u_short                    CurrentPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                     FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                      dwMessageSize;
    // pMessage is a pointer to the received message
    char                       *pMessage;
    // XNetUnregisterKeyRequest is the request sent to the server
    XNETUNREGISTERKEY_REQUEST  XNetUnregisterKeyRequest;

    // ClientXnAddr is the address of the client
    XNADDR                     ClientXnAddr;

    // pXnKid is a pointer to the xnkid
    XNKID                      *pXnKid;
    // XnKid1 is the first xnkid
    XNKID                      XnKid1;
    // XnKid2 is the second xnkid
    XNKID                      XnKid2;
    // XnKey1 is the first xnkey
    XNKEY                      XnKey1;
    // XnKey2 is the second xnkey
    XNKEY                      XnKey2;
    // LocalXnAddr is the address of the local machine
    XNADDR                     LocalXnAddr;
    // ServerXnAddr is the address of the netsync server
    XNADDR                     ServerXnAddr;
    // ServerInAddr is the address of the netsync server
    u_long                     ServerInAddr;

    // sSocket is the socket descriptor
    SOCKET                     sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                     nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int                        iTimeout = 5000;

    // localname is the local address
    SOCKADDR_IN                localname;
    // remotename is the remote address
    SOCKADDR_IN                remotename;

    // readfds is the set of sockets to check for a read condition
    fd_set                     readfds;
    // writefds is the set of sockets to check for a write condition
    fd_set                     writefds;

    // SendBuffer10 is the send buffer
    char                       SendBuffer10[BUFFER_10_LEN + 1];
    // RecvBufferLarge is the large recv buffer
    char                       RecvBufferLarge[BUFFER_LARGE_LEN + 1];

    // bException indicates if an exception occurred
    BOOL                       bException;
    // dwReturnCode is the return code of the operation
    int                        dwReturnCode;
    // bTestPassed indicates if the test passed
    BOOL                       bTestPassed;

    // szFunctionName is the function name
    CHAR                       szFunctionName[FUNCTION_NAME_LENGTH];



    // Set the function name
    sprintf(szFunctionName, "XNetUnregisterKey v%04x", WinsockVersion);
    xSetFunctionName(hLog, szFunctionName);

    // Get the test cases
    lpszCaseTest = GetIniSection(hMemObject, "xnetapi_XNetUnregisterKey+");
    lpszCaseSkip = GetIniSection(hMemObject, "xnetapi_XNetUnregisterKey-");

    // Determine the remote netsync server type
    NetsyncTypeSession = XNetUnregisterKeyTestSessionXbox;

    for (dwTableIndex = 0; dwTableIndex < XNetUnregisterKeyTableCount; dwTableIndex++) {
        if ((NULL != lpszCaseSkip) && (TRUE == ParseAndFindString(lpszCaseSkip, XNetUnregisterKeyTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if ((NULL != lpszCaseTest) && (FALSE == ParseAndFindString(lpszCaseTest, XNetUnregisterKeyTable[dwTableIndex].szVariationName))) {
            continue;
        }

        if (bRIPs != XNetUnregisterKeyTable[dwTableIndex].bRIP) {
            continue;
        }

        // Start the variation
        xStartVariation(hLog, XNetUnregisterKeyTable[dwTableIndex].szVariationName);

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE != hNetsyncObject) && (FALSE == XNetUnregisterKeyTable[dwTableIndex].bNetsyncConnected)) {
            // Close the netsync client object
            NetsyncCloseClient(hNetsyncObject);
            hNetsyncObject = INVALID_HANDLE_VALUE;
        }

        // Check the state of the net subsystem
        if (bXnetInitialized != XNetUnregisterKeyTable[dwTableIndex].bXnetInitialized) {
            // Initialize or terminate net subsystem as necessary
            if (TRUE == XNetUnregisterKeyTable[dwTableIndex].bXnetInitialized) {
                XNetAddRef();
                WSAStartup(WinsockVersion, &WSAData);
            }
            else {
                WSACleanup();
                XNetRelease();
            }

            // Update the state of net subsystem
            bXnetInitialized = XNetUnregisterKeyTable[dwTableIndex].bXnetInitialized;
        }

        // Check the state of Netsync
        if ((INVALID_HANDLE_VALUE == hNetsyncObject) && (TRUE == XNetUnregisterKeyTable[dwTableIndex].bNetsyncConnected)) {
            // Connect to the session
            hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
            if (INVALID_HANDLE_VALUE == hNetsyncObject) {
                xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

                // End the variation
                xEndVariation(hLog);
                break;
            }

            CurrentPort = LowPort;
        }

        // Get the local xnaddr
        do {
            dwReturnCode = XNetGetTitleXnAddr(&LocalXnAddr);
            if (0 == dwReturnCode) {
                Sleep(SLEEP_ZERO_TIME);
            }
        } while (0 == dwReturnCode);

        // Clear the xnaddr, xnkid and xnkey
        ZeroMemory(&ServerXnAddr, sizeof(ServerXnAddr));
        ZeroMemory(&XnKid1, sizeof(XnKid1));
        ZeroMemory(&XnKid2, sizeof(XnKid2));
        ZeroMemory(&XnKey1, sizeof(XnKey1));
        ZeroMemory(&XnKey2, sizeof(XnKey2));
        XNetCreateKey(&XnKid1, &XnKey1);
        XNetCreateKey(&XnKid2, &XnKey2);

        // Register the key
        XNetRegisterKey(&XnKid1, &XnKey1);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        if (SOCKET_INVALID_SOCKET == XNetUnregisterKeyTable[dwTableIndex].dwSocket) {
            sSocket = INVALID_SOCKET;
        }
        else if (0 != (SOCKET_TCP & XNetUnregisterKeyTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_STREAM, 0);
        }
        else if (0 != (SOCKET_UDP & XNetUnregisterKeyTable[dwTableIndex].dwSocket)) {
            sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        }

        if (INVALID_SOCKET != sSocket) {
            // Set the send and receive timeout values to 5 sec
            setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
            setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        }

        // Bind the socket
        if (INVALID_SOCKET != sSocket) {
            ZeroMemory(&localname, sizeof(localname));
            localname.sin_family = AF_INET;
            localname.sin_port = htons(CurrentPort);
            bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));
        }

        // Place the socket in the listening state
        if ((0 != (SOCKET_TCP & XNetUnregisterKeyTable[dwTableIndex].dwSocket)) && (FALSE == XNetUnregisterKeyTable[dwTableIndex].bConnect)) {
            listen(sSocket, SOMAXCONN);
        }

        if (SOCKET_INVALID_SOCKET != XNetUnregisterKeyTable[dwTableIndex].dwSocket) {
            // Initialize the connect request
            XNetUnregisterKeyRequest.dwMessageId = XNETUNREGISTERKEY_REQUEST_MSG;
            if (0 != (SOCKET_TCP & XNetUnregisterKeyTable[dwTableIndex].dwSocket)) {
                XNetUnregisterKeyRequest.nSocketType = SOCK_STREAM;
            }
            else {
                XNetUnregisterKeyRequest.nSocketType = SOCK_DGRAM;
            }
            XNetUnregisterKeyRequest.Port = CurrentPort;
            XNetUnregisterKeyRequest.bServerAccept = (XNetUnregisterKeyTable[dwTableIndex].bConnect) && (0 != (SOCKET_TCP & XNetUnregisterKeyTable[dwTableIndex].dwSocket));
            CopyMemory(&XNetUnregisterKeyRequest.XnAddr, &LocalXnAddr, sizeof(XNetUnregisterKeyRequest.XnAddr));
            CopyMemory(&XNetUnregisterKeyRequest.XnKid, &XnKid1, sizeof(XnKid1));
            CopyMemory(&XNetUnregisterKeyRequest.XnKey, &XnKey1, sizeof(XnKey1));

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(XNetUnregisterKeyRequest), (char *) &XNetUnregisterKeyRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            CopyMemory(&ServerXnAddr, &((XNETUNREGISTERKEY_COMPLETE *) pMessage)->XnAddr, sizeof(ServerXnAddr));
            NetsyncFreeMessage(pMessage);

            // Resolve the address
            XNetXnAddrToInAddr(&ServerXnAddr, &XnKid1, (IN_ADDR *) &ServerInAddr);

            if (TRUE == XNetUnregisterKeyTable[dwTableIndex].bConnect) {
                // Connect the socket
                ZeroMemory(&remotename, sizeof(remotename));
                remotename.sin_family = AF_INET;
                remotename.sin_addr.s_addr = ServerInAddr;
                remotename.sin_port = htons(CurrentPort);

                connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));

                if (0 != (SOCKET_TCP & XNetUnregisterKeyTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&writefds);
                    FD_SET(sSocket, &writefds);
                    select(0, NULL, &writefds, NULL, NULL);
                }
            }
            else {
                if (0 != (SOCKET_TCP & XNetUnregisterKeyTable[dwTableIndex].dwSocket)) {
                    FD_ZERO(&readfds);
                    FD_SET(sSocket, &readfds);
                    select(0, &readfds, NULL, NULL, NULL);
                }

                // Accept the socket
                nsSocket = accept(sSocket, NULL, NULL);
            }

            // Send data
            sprintf(SendBuffer10, "%05d%05d", 1, 1);
            send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SendBuffer10, 10, 0);

            // Send the connect request
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(XNetUnregisterKeyRequest), (char *) &XNetUnregisterKeyRequest);

            // Wait for the connect complete
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
            NetsyncFreeMessage(pMessage);
        }

        if (FALSE == XNetUnregisterKeyTable[dwTableIndex].bXnKid) {
            pXnKid = NULL;
        }
        else {
            if (TRUE == XNetUnregisterKeyTable[dwTableIndex].bRegister) {
                pXnKid = &XnKid1;
            }
            else {
                pXnKid = &XnKid2;
            }
        }

        bTestPassed = TRUE;
        bException = FALSE;

        __try {
            // Call XNetUnregisterKey
            dwReturnCode = XNetUnregisterKey(pXnKid);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            if (TRUE == XNetUnregisterKeyTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_PASS, "XNetUnregisterKey RIP'ed");
            }
            else {
                xLog(hLog, XLL_EXCEPTION, "XNetUnregisterKey caused an exception - ec = 0x%08x", GetExceptionCode());
            }
            bException = TRUE;
        }

        if (FALSE == bException) {
            if (TRUE == XNetUnregisterKeyTable[dwTableIndex].bRIP) {
                xLog(hLog, XLL_FAIL, "XNetUnregisterKey did not RIP");
            }

            if (dwReturnCode != XNetUnregisterKeyTable[dwTableIndex].dwReturnCode) {
                xLog(hLog, XLL_FAIL, "dwReturnCode - EXPECTED: %u; RECEIVED: %u", XNetUnregisterKeyTable[dwTableIndex].dwReturnCode, dwReturnCode);
            }
            else if (0 == dwReturnCode) {
                // Send the send request
                NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(XNetUnregisterKeyRequest), (char *) &XNetUnregisterKeyRequest);

                // Wait for the send complete
                NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
                NetsyncFreeMessage(pMessage);

                if (SOCKET_ERROR != recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0)) {
                    xLog(hLog, XLL_FAIL, "recv passed");
                    bTestPassed = FALSE;
                }
                else {
                    if (0 != (SOCKET_TCP & XNetUnregisterKeyTable[dwTableIndex].dwSocket)) {
                        if (WSAECONNRESET != WSAGetLastError()) {
                            xLog(hLog, XLL_FAIL, "recv error code - EXPECTED: %u; RECEIVED: %u", WSAECONNRESET, WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                    }
                    else {
                        if (WSAETIMEDOUT != WSAGetLastError()) {
                            xLog(hLog, XLL_FAIL, "recv error code - EXPECTED: %u; RECEIVED: %u", WSAETIMEDOUT, WSAGetLastError());
                            bTestPassed = FALSE;
                        }
                    }
                }

                // Call XNetUnregisterKey again
                dwReturnCode = XNetUnregisterKey(pXnKid);
                if (WSAEINVAL != dwReturnCode) {
                    xLog(hLog, XLL_FAIL, "Second XNetUnregisterKey - EXPECTED: %u; RECEIVED: %u", WSAEINVAL, dwReturnCode);
                    bTestPassed = FALSE;
                }

                if (TRUE == bTestPassed) {
                    xLog(hLog, XLL_PASS, "XNetUnregisterKey succeeded");
                }
            }
            else {
                xLog(hLog, XLL_PASS, "dwReturnCode - OUT: %u", dwReturnCode);
            }

        }

        if (&XnKid2 == pXnKid) {
            XNetUnregisterKey(&XnKid1);
        }

        if (SOCKET_INVALID_SOCKET != XNetUnregisterKeyTable[dwTableIndex].dwSocket) {
            // Send the ack
            NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(XNetUnregisterKeyRequest), (char *) &XNetUnregisterKeyRequest);
        }

        if (SOCKET_INVALID_SOCKET != XNetUnregisterKeyTable[dwTableIndex].dwSocket) {
            shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_BOTH);
            if (INVALID_SOCKET != nsSocket) {
                closesocket(nsSocket);
            }
            closesocket(sSocket);
        }

        // Increment CurrentPort
        if (0 != CurrentPort) {
            CurrentPort++;
        }

        // End the variation
        xEndVariation(hLog);
    }

    // Terminate Netsync if necesssary
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    // Terminate net subsystem if necessary
    if (TRUE == bXnetInitialized) {
        WSACleanup();
        XNetRelease();
    }

    // Free the list of test cases
    if (NULL != lpszCaseSkip) {
        xMemFree(hMemObject, lpszCaseSkip);
    }

    if (NULL != lpszCaseTest) {
        xMemFree(hMemObject, lpszCaseTest);
    }
}

} // namespace XNetAPINamespace




#else



VOID
WINAPI
XNetUnregisterKeyTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests XNetUnregisterKey - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromInAddr is the address of the netsync sender
    u_long                      FromInAddr;
    // dwMessageType is the type of received message
    DWORD                       dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                       dwMessageSize;
    // pMessage is a pointer to the received message
    char                        *pMessage;
    // XNetUnregisterKeyRequest is the request
    XNETUNREGISTERKEY_REQUEST   XNetUnregisterKeyRequest;
    // XNetUnregisterKeyComplete is the result
    XNETUNREGISTERKEY_COMPLETE  XNetUnregisterKeyComplete;

    // LocalXnAddr is the address of the local machine
    XNADDR                      LocalXnAddr;
    // ClientXnAddr is the address of the netsync client
    XNADDR                      ClientXnAddr;
    // ClientInAddr is the address of the netsync client
    u_long                      ClientInAddr;

    // sSocket is the socket descriptor
    SOCKET                      sSocket;
    // nsSocket is the accepted socket descriptor
    SOCKET                      nsSocket;

    // iTimeout is the send and receive timeout value for the socket
    int                         iTimeout = 5000;

    // localname is the local address
    SOCKADDR_IN                 localname;
    // remotename is the remote address
    SOCKADDR_IN                 remotename;

    // RecvBufferLarge is the large recv buffer
    char                        RecvBufferLarge[BUFFER_LARGE_LEN + 1];
    // nBytes is the number of bytes sent/received
    int                         nBytes;

    // dwReturnCode is the return code of the operation
    DWORD                       dwReturnCode;



    // Get the local xnaddr
    do {
        dwReturnCode = XNetGetTitleXnAddr(&LocalXnAddr);
        if (0 == dwReturnCode) {
            Sleep(SLEEP_ZERO_TIME);
        }
    } while (0 == dwReturnCode);

    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&XNetUnregisterKeyRequest, pMessage, sizeof(XNetUnregisterKeyRequest));
        NetsyncFreeMessage(pMessage);

        CopyMemory(&ClientXnAddr, &XNetUnregisterKeyRequest.XnAddr, sizeof(ClientXnAddr));

        // Register the key
        XNetRegisterKey(&XNetUnregisterKeyRequest.XnKid, &XNetUnregisterKeyRequest.XnKey);

        // Resolve the address
        XNetXnAddrToInAddr(&ClientXnAddr, &XNetUnregisterKeyRequest.XnKid, (IN_ADDR *) &ClientInAddr);

        // Create the socket
        sSocket = INVALID_SOCKET;
        nsSocket = INVALID_SOCKET;
        sSocket = socket(AF_INET, XNetUnregisterKeyRequest.nSocketType, 0);

        // Set the send and receive timeout values to 5 sec
        setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));
        setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

        // Bind the socket
        ZeroMemory(&localname, sizeof(localname));
        localname.sin_family = AF_INET;
        localname.sin_port = htons(XNetUnregisterKeyRequest.Port);
        bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

        if (TRUE == XNetUnregisterKeyRequest.bServerAccept) {
            // Place the socket in listening mode
            listen(sSocket, SOMAXCONN);
        }
        else {
            // Connect the socket
            ZeroMemory(&remotename, sizeof(remotename));
            remotename.sin_family = AF_INET;
            remotename.sin_addr.s_addr = ClientInAddr;
            remotename.sin_port = htons(XNetUnregisterKeyRequest.Port);

            connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));
        }

        // Send the complete
        XNetUnregisterKeyComplete.dwMessageId = XNETUNREGISTERKEY_COMPLETE_MSG;
        CopyMemory(&XNetUnregisterKeyComplete.XnAddr, &LocalXnAddr, sizeof(XNetUnregisterKeyComplete.XnAddr));
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(XNetUnregisterKeyComplete), (char *) &XNetUnregisterKeyComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        if (TRUE == XNetUnregisterKeyRequest.bServerAccept) {
            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }

        ZeroMemory(RecvBufferLarge, sizeof(RecvBufferLarge));
        nBytes = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, sizeof(RecvBufferLarge), 0);

        // Send the complete
        XNetUnregisterKeyComplete.dwMessageId = XNETUNREGISTERKEY_COMPLETE_MSG;
        CopyMemory(&XNetUnregisterKeyComplete.XnAddr, &LocalXnAddr, sizeof(XNetUnregisterKeyComplete.XnAddr));
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(XNetUnregisterKeyComplete), (char *) &XNetUnregisterKeyComplete);

        // Wait for the request
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Send data
        send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, RecvBufferLarge, (SOCKET_ERROR == nBytes) ? 10 : nBytes, 0);

        // Send the complete
        XNetUnregisterKeyComplete.dwMessageId = XNETUNREGISTERKEY_COMPLETE_MSG;
        CopyMemory(&XNetUnregisterKeyComplete.XnAddr, &LocalXnAddr, sizeof(XNetUnregisterKeyComplete.XnAddr));
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(XNetUnregisterKeyComplete), (char *) &XNetUnregisterKeyComplete);

        // Wait for the ack
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        NetsyncFreeMessage(pMessage);

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }

        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }

        // Unregister the key
        XNetUnregisterKey(&XNetUnregisterKeyRequest.XnKid);
    }
}

#endif

#endif // _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\bvt\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 5-Oct-2000

------------------------------------------------------------------------------*/

#ifdef _XBOX

#include <xtl.h>
#include <xtestlib.h>

#else

#include <windows.h>
#include <winsock2.h>

#endif

#include <xmem.h>
#include <xnetref.h>
#include <xlog.h>
#include <netsync.h>

#include "util.h"
#include "client.h"
#include "server.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\bvt\client.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.h

Abstract:

  This module contains the definitions for client.h

Author:

  Steven Kehrli (steveke) 5-Oct-2000

------------------------------------------------------------------------------*/

#pragma once



namespace XNetBVTNamespace {

#define BVTBuffer "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"



// Function prototypes

BOOL
BVT_UDPTest(
    IN HANDLE  hLog,
    IN LPSTR   pNetsyncRemote
);

BOOL
BVT_TCPTest(
    IN HANDLE  hLog,
    IN LPSTR   pNetsyncRemote
);

} // namespace XNetBVTNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\bvt\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF



TARGETPATH=$(BASEDIR)\private\test\lib

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_CXX=1

USECXX_FLAG=/Tp

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\inc; \
    ..\; \
    
SOURCES=$(SOURCES) \
    udpclient.c    \
    tcpclient.c    \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\bvt\server.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  server.c

Abstract:

  This modules contains the server side exports

Author:

  Steven Kehrli (steveke) 5-Oct-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef _XBOX

#ifdef __cplusplus
extern "C" {
#endif

// Netsync export table for syncsrv

#pragma data_seg(NETSYNC_EXPORT_SECTION_NAME)
DECLARE_NETSYNC_EXPORT_DIRECTORY(xnetbvt_xbox)
#pragma data_seg()

BEGIN_NETSYNC_EXPORT_TABLE(xnetbvt_xbox)
    NETSYNC_EXPORT_TABLE_ENTRY("BVT_UDPTestServer", BVT_UDPTestServer)
    NETSYNC_EXPORT_TABLE_ENTRY("BVT_TCPTestServer", BVT_TCPTestServer)
END_NETSYNC_EXPORT_TABLE(xnetbvt_xbox)

#ifdef __cplusplus
}
#endif

#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\bvt\server.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  server.h

Abstract:

  This modules contains the definitions for server.c

Author:

  Steven Kehrli (steveke) 5-Oct-2000

------------------------------------------------------------------------------*/

#pragma once



// Function prototypes

VOID
WINAPI
BVT_UDPTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
BVT_TCPTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\bvt\udpclient.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  udpclient.c

Abstract:

  This modules tests UDP

Author:

  Steven Kehrli (steveke) 5-Oct-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetBVTNamespace;

namespace XNetBVTNamespace {

// UDP messages

typedef struct _BVT_UDP_MESSAGE {
    DWORD    dwMessageId;
    u_short  Port;
    int      iLastError;
} BVT_UDP_MESSAGE, *PBVT_UDP_MESSAGE;

#define BVT_UDP_SEND_MSG  NETSYNC_MSG_USER + 1
#define BVT_UDP_RECV_MSG  NETSYNC_MSG_USER + 2



NETSYNC_TYPE_THREAD  BVT_UDPSessionNt =
{
    1,
    4,
    L"xnetbvt_nt.dll",
    "BVT_UDPTestServer"
};

NETSYNC_TYPE_THREAD  BVT_UDPSessionXbox =
{
    1,
    4,
    L"xnetbvt_xbox.dll",
    "BVT_UDPTestServer"
};

} // namespace XNetBVTNamespace



#ifdef XNETBVT_CLIENT

namespace XNetBVTNamespace {

BOOL
BVT_UDPTest(
    IN HANDLE  hLog,
    IN LPSTR   pNetsyncRemote
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests UDP - Client side

Arguments:

  hLog - handle to the xLog log object
  pNetsyncRemote - pointer to the netsync remote name

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // iLastError is the last error code
    int                  iLastError = ERROR_SUCCESS;
    // iResult is the result of a function
    int                  iResult = 0;
    // uXNetRef is the reference count of xnet
    ULONG                uXNetRef = 0;
    // XnAddr is the title xnet address
    XNADDR               XnAddr;
    // dwResult is the result of XNetGetTitleXnAddr
    DWORD                dwResult = 0;
    
    // WSAData is the details of the Winsock implementation
    WSADATA              WSAData;
    // hNetsyncObject is a handle to the netsync object
    HANDLE               hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD  NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long               NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short              LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short              HighPort = 0;

    // sSocket1 is a socket descriptor
    SOCKET               sSocket1 = INVALID_SOCKET;
    // sSocket2 is a socket descriptor
    SOCKET               sSocket2 = INVALID_SOCKET;
    // sSocket3 is a socket descriptor
    SOCKET               sSocket3 = INVALID_SOCKET;
    // sSocket4 is a socket descriptor
    SOCKET               sSocket4 = INVALID_SOCKET;
    // Port1 is the port number of sSocket1
    u_short              Port1 = 0;
    // Port2 is the port number of sSocket2
    u_short              Port2 = 0;
    // Port3 is the port number of sSocket3
    u_short              Port3 = 0;
    // Port4 is the port number of sSocket4
    u_short              Port4 = 0;

    // iTimeout is the send and receive timeout value for the socket
    int                  iTimeout;
    // portname is the local address associated with a socket
    SOCKADDR_IN          portname = { AF_INET, 0, 0, {'\0'} };
    // toname is the recipient address information structure
    SOCKADDR_IN          toname = { AF_INET, 0, 0, {'\0'} };

    // ReceiveBuffer is the receive buffer
    char                 ReceiveBuffer[sizeof(BVTBuffer)];
    // nBytes is the number of bytes sent or received on the socket
    int                  nBytes;

    // FromInAddr is the address of the netsync sender
    u_long               FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                dwMessageSize;
    // pMessage is a pointer to the received message
    char                 *pMessage;
    // BVT_UDPMessage is a pointer to the message sent to the netsync server
    BVT_UDP_MESSAGE      BVT_UDPMessage;



    // Set the function name
    xSetFunctionName(hLog, "BVT UDP");

    // Start the variation
    xStartVariation(hLog, "BVT UDP Test");



    // Initialize the net subsystem
    uXNetRef = XNetAddRef();
    if (0 == uXNetRef) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "XNetAddRef failed - ec: %u", iLastError);

        goto FunctionExit0;
    }

    while (0 == (dwResult = XNetGetTitleXnAddr(&XnAddr))) {
        Sleep(1000);
    }

    // Determine the remote netsync server type
    if (0 != (XNET_GET_XNADDR_ETHERNET & dwResult)) {
        NetsyncTypeSession = BVT_UDPSessionXbox;
    }
    else {
        NetsyncTypeSession = BVT_UDPSessionNt;
    }

    // Initialize Winsock
    iLastError = WSAStartup(MAKEWORD(2, 2), &WSAData);
    if (ERROR_SUCCESS != iLastError) {
        xLog(hLog, XLL_FAIL, "WSAStartup failed - ec: %u", iLastError);

        goto FunctionExit1;
    }



    // Connect to the session
    hNetsyncObject = NetsyncCreateClient((NULL != pNetsyncRemote) ? inet_addr(pNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
    if (INVALID_HANDLE_VALUE == hNetsyncObject) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", iLastError);
    }
    else {
        Port1 = LowPort;
        Port2 = LowPort + 1;
        Port3 = LowPort + 2;
        Port4 = LowPort + 3;
    }

    if (INVALID_HANDLE_VALUE == hNetsyncObject) {
        goto FunctionExit2;
    }



    // Create socket
    sSocket1 = socket(AF_INET, SOCK_DGRAM, 0);
    if (INVALID_SOCKET == sSocket1) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot create socket 1 - ec = %u", iLastError);

        goto FunctionExit3;
    }

    sSocket2 = socket(AF_INET, SOCK_DGRAM, 0);
    if (INVALID_SOCKET == sSocket2) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot create socket 2 - ec = %u", iLastError);

        goto FunctionExit4;
    }

    sSocket3 = socket(AF_INET, SOCK_DGRAM, 0);
    if (INVALID_SOCKET == sSocket3) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot create socket 3 - ec = %u", iLastError);

        goto FunctionExit5;
    }

    sSocket4 = socket(AF_INET, SOCK_DGRAM, 0);
    if (INVALID_SOCKET == sSocket4) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot create socket 4 - ec = %u", iLastError);

        goto FunctionExit6;
    }

    // Set the receive timeout value to 5 sec
    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket1, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set receive timeout value for socket 1 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket2, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set receive timeout value for socket 2 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket3, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set receive timeout value for socket 3 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket4, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set receive timeout value for socket 4 - ec = %u", iLastError);

        goto FunctionExit7;
    }



    // Set the send timeout value to 5 sec
    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket1, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set send timeout value for socket 1 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket2, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set send timeout value for socket 2 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket3, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set send timeout value for socket 3 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket4, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set send timeout value for socket 4 - ec = %u", iLastError);

        goto FunctionExit7;
    }



    // Bind socket
    portname.sin_port = htons(Port1);
    if (SOCKET_ERROR == bind(sSocket1, (SOCKADDR *) &portname, sizeof(portname))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot bind socket 1 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    portname.sin_port = htons(Port2);
    if (SOCKET_ERROR == bind(sSocket2, (SOCKADDR *) &portname, sizeof(portname))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot bind socket 2 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    portname.sin_port = htons(Port3);
    if (SOCKET_ERROR == bind(sSocket3, (SOCKADDR *) &portname, sizeof(portname))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot bind socket 2 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    portname.sin_port = htons(Port4);
    if (SOCKET_ERROR == bind(sSocket4, (SOCKADDR *) &portname, sizeof(portname))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot bind socket 2 - ec = %u", iLastError);

        goto FunctionExit7;
    }



    // Start the variation
    xStartVariation(hLog, "Send Test 1");

    // Start the send test
    BVT_UDPMessage.dwMessageId = BVT_UDP_SEND_MSG;
    BVT_UDPMessage.Port = Port1;
    BVT_UDPMessage.iLastError = ERROR_SUCCESS;
    if (WAIT_OBJECT_0 != NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(BVT_UDPMessage), (char *) &BVT_UDPMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncSendClientMessage for socket 1 failed - ec = %u", iLastError);

        goto FunctionExit7;
    }

    // Wait for the ack
    if (WAIT_OBJECT_0 != NetsyncReceiveClientMessage(hNetsyncObject, 15000, &FromInAddr, NULL, &dwMessageSize, &pMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncReceiveClientMessage for socket 1 failed - ec = %u", iLastError);

        goto FunctionExit7;
    }
    NetsyncFreeMessage(pMessage);

    if (ERROR_SUCCESS != BVT_UDPMessage.iLastError) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "Netsync Server failed - ec = %u", iLastError);

        goto FunctionExit7;
    }

    // Initialize send
    toname.sin_port = htons(Port1);
    toname.sin_addr.s_addr = NetsyncInAddr;

    // Send first on socket 1
    nBytes = sendto(sSocket1, BVTBuffer, sizeof(BVTBuffer), 0, (SOCKADDR *) &toname, sizeof(toname));
    if (SOCKET_ERROR == nBytes) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "sendto on socket 1 failed - ec = %u", iLastError);
    }
    else {
        if (sizeof(BVTBuffer) != nBytes) {
            xLog(hLog, XLL_FAIL, "sendto return value on socket 1 - EXPECTED: %d; RECEIVED: %d", sizeof(BVTBuffer), nBytes);
        }

        // Initialize receive
        ZeroMemory(ReceiveBuffer, sizeof(ReceiveBuffer));

        // Receive on socket 1
        nBytes = recvfrom(sSocket1, ReceiveBuffer, sizeof(ReceiveBuffer), 0, NULL, NULL);
        if (SOCKET_ERROR == nBytes) {
            // Get the last error code
            iLastError = WSAGetLastError();

            xLog(hLog, XLL_FAIL, "recvfrom on socket 1 failed - ec = %u", iLastError);
        }
        else {
            if (sizeof(BVTBuffer) != nBytes) {
                xLog(hLog, XLL_FAIL, "recvfrom return value on socket 1 - EXPECTED: %d; RECEIVED: %d", sizeof(BVTBuffer), nBytes);
            }
            else if (0 != strcmp(BVTBuffer, ReceiveBuffer)) {
                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer on socket 1 - %s", ReceiveBuffer);
            }
            else {
                xLog(hLog, XLL_PASS, "sendto and recvfrom on socket 1 passed");
            }
        }
    }

    // End the variation
    xEndVariation(hLog);



    // Start the variation
    xStartVariation(hLog, "Send Test 2");

    // Start the send test
    BVT_UDPMessage.dwMessageId = BVT_UDP_SEND_MSG;
    BVT_UDPMessage.Port = Port2;
    BVT_UDPMessage.iLastError = ERROR_SUCCESS;
    if (WAIT_OBJECT_0 != NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(BVT_UDPMessage), (char *) &BVT_UDPMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncSendClientMessage for socket 2 failed - ec = %u", iLastError);

        goto FunctionExit7;
    }

    // Wait for the ack
    if (WAIT_OBJECT_0 != NetsyncReceiveClientMessage(hNetsyncObject, 15000, &FromInAddr, NULL, &dwMessageSize, &pMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncReceiveClientMessage for socket 2 failed - ec = %u", iLastError);

        goto FunctionExit7;
    }
    NetsyncFreeMessage(pMessage);

    if (ERROR_SUCCESS != BVT_UDPMessage.iLastError) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "Netsync Server failed - ec = %u", iLastError);

        goto FunctionExit7;
    }

    // Initialize send
    toname.sin_port = htons(Port2);
    toname.sin_addr.s_addr = NetsyncInAddr;

    // Send first on socket 2
    nBytes = sendto(sSocket2, BVTBuffer, sizeof(BVTBuffer), 0, (SOCKADDR *) &toname, sizeof(toname));
    if (SOCKET_ERROR == nBytes) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "sendto on socket 2 failed - ec = %u", iLastError);
    }
    else {
        if (sizeof(BVTBuffer) != nBytes) {
            xLog(hLog, XLL_FAIL, "sendto return value on socket 2 - EXPECTED: %d; RECEIVED: %d", sizeof(BVTBuffer), nBytes);
        }

        // Initialize receive
        ZeroMemory(ReceiveBuffer, sizeof(ReceiveBuffer));

        // Receive on socket 2
        nBytes = recvfrom(sSocket2, ReceiveBuffer, sizeof(ReceiveBuffer), 0, NULL, NULL);
        if (SOCKET_ERROR == nBytes) {
            // Get the last error code
            iLastError = WSAGetLastError();

            xLog(hLog, XLL_FAIL, "recvfrom on socket 2 failed - ec = %u", iLastError);
        }
        else {
            if (sizeof(BVTBuffer) != nBytes) {
                xLog(hLog, XLL_FAIL, "recvfrom return value on socket 2 - EXPECTED: %d; RECEIVED: %d", sizeof(BVTBuffer), nBytes);
            }
            else if (0 != strcmp(BVTBuffer, ReceiveBuffer)) {
                xLog(hLog, XLL_FAIL, "Received Unexpected Buffer on socket 2 - %s", ReceiveBuffer);
            }
            else {
                xLog(hLog, XLL_PASS, "sendto and recvfrom on socket 2 passed");
            }
        }
    }

    // End the variation
    xEndVariation(hLog);



    // Start the variation
    xStartVariation(hLog, "Receive Test 1");

    // Start the receive test
    BVT_UDPMessage.dwMessageId = BVT_UDP_RECV_MSG;
    BVT_UDPMessage.Port = Port3;
    BVT_UDPMessage.iLastError = ERROR_SUCCESS;
    if (WAIT_OBJECT_0 != NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(BVT_UDPMessage), (char *) &BVT_UDPMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncSendClientMessage for socket 3 failed - ec = %u", iLastError);

        goto FunctionExit5;
    }

    // Wait for the ack
    if (WAIT_OBJECT_0 != NetsyncReceiveClientMessage(hNetsyncObject, 15000, &FromInAddr, NULL, &dwMessageSize, &pMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncReceiveClientMessage for socket 3 failed - ec = %u", iLastError);

        goto FunctionExit5;
    }
    NetsyncFreeMessage(pMessage);

    if (ERROR_SUCCESS != BVT_UDPMessage.iLastError) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "Netsync Server failed - ec = %u", iLastError);

        goto FunctionExit5;
    }

    // Initialize receive
    ZeroMemory(ReceiveBuffer, sizeof(ReceiveBuffer));

    // Receive first on socket 3
    nBytes = recvfrom(sSocket3, ReceiveBuffer, sizeof(ReceiveBuffer), 0, NULL, NULL);
    if (SOCKET_ERROR == nBytes) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "recvfrom on socket 3 failed - ec = %u", iLastError);
    }
    else {
        if (sizeof(BVTBuffer) != nBytes) {
            xLog(hLog, XLL_FAIL, "recvfrom return value on socket 1 - EXPECTED: %d; RECEIVED: %d", sizeof(BVTBuffer), nBytes);
        }
        else if (0 != strcmp(BVTBuffer, ReceiveBuffer)) {
            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer on socket 3 - %s", ReceiveBuffer);
        }

        // Initialize send
        toname.sin_port = htons(Port3);
        toname.sin_addr.s_addr = NetsyncInAddr;

        // Send on socket 3
        nBytes = sendto(sSocket3, ReceiveBuffer, strlen(ReceiveBuffer) + 1, 0, (SOCKADDR *) &toname, sizeof(toname));
        if (SOCKET_ERROR == nBytes) {
            // Get the last error code
            iLastError = WSAGetLastError();

            xLog(hLog, XLL_FAIL, "sendto on socket 3 failed - ec = %u", iLastError);
        }
        else {
            if ((strlen(ReceiveBuffer) + 1) != (size_t) nBytes) {
                xLog(hLog, XLL_FAIL, "sendto return value on socket 3 - EXPECTED: %d: RECEIVED: %d", strlen(ReceiveBuffer) + 1, nBytes);
            }
            else {
                xLog(hLog, XLL_PASS, "recvfrom and sendto on socket 3 passed");
            }
        }
    }

    // End the variation
    xEndVariation(hLog);



    // Start the variation
    xStartVariation(hLog, "Receive Test 2");

    // Start the receive test
    BVT_UDPMessage.dwMessageId = BVT_UDP_RECV_MSG;
    BVT_UDPMessage.Port = Port4;
    BVT_UDPMessage.iLastError = ERROR_SUCCESS;
    if (WAIT_OBJECT_0 != NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(BVT_UDPMessage), (char *) &BVT_UDPMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncSendClientMessage for socket 4 failed - ec = %u", iLastError);

        goto FunctionExit5;
    }

    // Wait for the ack
    if (WAIT_OBJECT_0 != NetsyncReceiveClientMessage(hNetsyncObject, 15000, &FromInAddr, NULL, &dwMessageSize, &pMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncReceiveClientMessage for socket 4 failed - ec = %u", iLastError);

        goto FunctionExit5;
    }
    NetsyncFreeMessage(pMessage);

    if (ERROR_SUCCESS != BVT_UDPMessage.iLastError) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "Netsync Server failed - ec = %u", iLastError);

        goto FunctionExit5;
    }

    // Initialize receive
    ZeroMemory(ReceiveBuffer, sizeof(ReceiveBuffer));

    // Receive first on socket 4
    nBytes = recvfrom(sSocket4, ReceiveBuffer, sizeof(ReceiveBuffer), 0, NULL, NULL);
    if (SOCKET_ERROR == nBytes) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "recvfrom on socket 4 failed - ec = %u", iLastError);
    }
    else {
        if (sizeof(BVTBuffer) != nBytes) {
            xLog(hLog, XLL_FAIL, "recvfrom return value on socket 1 - EXPECTED: %d; RECEIVED: %d", sizeof(BVTBuffer), nBytes);
        }
        else if (0 != strcmp(BVTBuffer, ReceiveBuffer)) {
            xLog(hLog, XLL_FAIL, "Received Unexpected Buffer on socket 4 - %s", ReceiveBuffer);
        }

        // Initialize send
        toname.sin_port = htons(Port4);
        toname.sin_addr.s_addr = NetsyncInAddr;

        // Send on socket 4
        nBytes = sendto(sSocket4, ReceiveBuffer, strlen(ReceiveBuffer) + 1, 0, (SOCKADDR *) &toname, sizeof(toname));
        if (SOCKET_ERROR == nBytes) {
            // Get the last error code
            iLastError = WSAGetLastError();

            xLog(hLog, XLL_FAIL, "sendto on socket 4 failed - ec = %u", iLastError);
        }
        else {
            if ((strlen(ReceiveBuffer) + 1) != (size_t) nBytes) {
                xLog(hLog, XLL_FAIL, "sendto return value on socket 4 - EXPECTED: %d: RECEIVED: %d", strlen(ReceiveBuffer) + 1, nBytes);
            }
            else {
                xLog(hLog, XLL_PASS, "recvfrom and sendto on socket 4 passed");
            }
        }
    }

    // End the variation
    xEndVariation(hLog);



FunctionExit7:
    // Close the socket
    if (0 != closesocket(sSocket4)) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot close socket 4 - ec = %u", iLastError);
    }

FunctionExit6:
    // Close the socket
    if (0 != closesocket(sSocket3)) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot close socket 3 - ec = %u", iLastError);
    }

FunctionExit5:
    // Close the socket
    if (0 != closesocket(sSocket2)) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot close socket 2 - ec = %u", iLastError);
    }

FunctionExit4:
    // Close the socket
    if (0 != closesocket(sSocket1)) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot close socket 1 - ec = %u", iLastError);
    }

FunctionExit3:
    // Close the netsync client object
    NetsyncCloseClient(hNetsyncObject);

FunctionExit2:
    // Terminate Winsock
    if (0 != WSACleanup()) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "WSACleanup() failed - ec: %u", iLastError);
    }

FunctionExit1:
    // Terminate the net subsystem
    if ((uXNetRef - 1) != XNetRelease()) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "XNetRelease() failed - ec: %u", iLastError);
    }

FunctionExit0:
    if (ERROR_SUCCESS == iLastError) {
        xLog(hLog, XLL_PASS, "Test passed");
    }

    // End the variation
    xEndVariation(hLog);

    return (ERROR_SUCCESS == iLastError);
}

} // namespace XNetBVTNamespace



#else



VOID
WINAPI
BVT_UDPTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests UDP - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // s is a socket descriptor
    SOCKET           sSocket = INVALID_SOCKET;
    // iTimeout is the send and receive timeout value for the socket
    int              iTimeout;
    // portname is the local address associated with a socket
    SOCKADDR_IN      portname = { AF_INET, 0, 0, {'\0'} };
    // toname is the recipient address information structure
    SOCKADDR_IN      toname = { AF_INET, 0, 0, {'\0'} };
    // ReceiveBuffer is the receive buffer
    char             ReceiveBuffer[sizeof(BVTBuffer)];
    // nBytes is the number of bytes sent or received on the socket
    int              nBytes;

    // FromInAddr is the address of the netsync sender
    u_long           FromInAddr;
    // dwMessageType is the type of received message
    DWORD            dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD            dwMessageSize;
    // pMessage is a pointer to the received message
    char             *pMessage;
    // BVT_UDPMessage is the test message sent to the netsync server
    BVT_UDP_MESSAGE  BVT_UDPMessage;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&BVT_UDPMessage, pMessage, sizeof(BVT_UDPMessage));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = socket(AF_INET, SOCK_DGRAM, 0);
        if (INVALID_SOCKET == sSocket) {
            // Get the last error code
            BVT_UDPMessage.iLastError = WSAGetLastError();
        }

        // Bind the socket
        portname.sin_port = htons(BVT_UDPMessage.Port);
        if (SOCKET_ERROR == bind(sSocket, (SOCKADDR *) &portname, sizeof(portname))) {
            // Get the last error code
            BVT_UDPMessage.iLastError = WSAGetLastError();

            goto SendAck;
        }
        
        // Set the receive timeout value to 5 sec
        iTimeout = 5000;
        if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
            // Get the last error code
            BVT_UDPMessage.iLastError = WSAGetLastError();

            goto SendAck;
        }

        // Set the send timeout value to 5 sec
        iTimeout = 5000;
        if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
            // Get the last error code
            BVT_UDPMessage.iLastError = WSAGetLastError();

            goto SendAck;
        }

SendAck:
        // Send the ack
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, dwMessageSize, (char *) &BVT_UDPMessage);

        if (ERROR_SUCCESS == BVT_UDPMessage.iLastError) {
            if (BVT_UDP_SEND_MSG == BVT_UDPMessage.dwMessageId) {
                // Receive the buffer
                recvfrom(sSocket, ReceiveBuffer, sizeof(ReceiveBuffer), 0, NULL, NULL);

                // Initialize send
                toname.sin_port = htons(BVT_UDPMessage.Port);
                toname.sin_addr.s_addr = FromInAddr;

                // Send the buffer
                sendto(sSocket, ReceiveBuffer, strlen(ReceiveBuffer) + 1, 0, (SOCKADDR *) &toname, sizeof(toname));
            }
            else if (BVT_UDP_RECV_MSG == BVT_UDPMessage.dwMessageId) {
                // Initialize send
                toname.sin_port = htons(BVT_UDPMessage.Port);
                toname.sin_addr.s_addr = FromInAddr;

                // Send the buffer
                sendto(sSocket, BVTBuffer, sizeof(BVTBuffer), 0, (SOCKADDR *) &toname, sizeof(toname));

                // Receive the buffer
                recvfrom(sSocket, ReceiveBuffer, sizeof(ReceiveBuffer), 0, NULL, NULL);
            }
        }

        if (INVALID_SOCKET != sSocket) {
            // Close the socket
            closesocket(sSocket);
            sSocket = INVALID_SOCKET;
        }
    }
}

#endif // XNETBVT_CLIENT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\bvt\util.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module contains the utility functions for xnetbvt.dll

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetBVTNamespace;

namespace XNetBVTNamespace {

LPSTR
GetIniString(
    HANDLE  hMemObject,
    LPCSTR  lpszSectionName,
    LPCSTR  lpszKeyName
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the specified string of the .ini file

Arguments:

  hMemObject - handle to the memory object
  lpszSectionName - pointer to the ini section name
  lpszKeyName - pointer to the ini key name

Return Value:

  LPSTR:
    If the function succeeds, the return value is a pointer to the string.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

-----------------------------------------------------------------------------*/
{
    // lpszString is a pointer to the string
    LPSTR  lpszString = NULL;
    // dwBufferSize is the size of the buffer referenced by lpszString
    DWORD  dwBufferSize = 0;
    // dwResult is the result of the GetProfileString call
    DWORD  dwResult = 0;

    // Allocate the memory for the string
    dwBufferSize = 0x10;
    lpszString = (LPSTR) xMemAlloc(hMemObject, dwBufferSize);

    while (NULL != lpszString)
    {
        dwResult = GetProfileStringA(lpszSectionName, lpszKeyName, NULL, lpszString, dwBufferSize);

        if (0 == dwResult) {
            goto FunctionFailed;
        }

        if (dwResult < (dwBufferSize - 2))
        {
            break;
        }

        dwBufferSize += 0x10;
        lpszString = (LPSTR) xMemReAlloc(hMemObject, lpszString, dwBufferSize);
    }

    if (NULL == lpszString)
    {
        goto FunctionFailed;
    }

    return lpszString;

FunctionFailed:
    if (NULL != lpszString) {
        xMemFree(hMemObject, lpszString);
    }

    return NULL;
}

} // namespace XNetBVTNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\bvt\tcpclient.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  tcpclient.c

Abstract:

  This modules tests TCP

Author:

  Steven Kehrli (steveke) 18-Oct-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetBVTNamespace;
 
namespace XNetBVTNamespace {

// TCP messages

typedef struct _BVT_TCP_MESSAGE {
    DWORD    dwMessageId;
    u_short  Port;
    int      iLastError;
} BVT_TCP_MESSAGE, *PBVT_TCP_MESSAGE;

#define BVT_TCP_SEND_MSG  NETSYNC_MSG_USER + 1
#define BVT_TCP_RECV_MSG  NETSYNC_MSG_USER + 2



NETSYNC_TYPE_THREAD  BVT_TCPSessionNt =
{
    1,
    4,
    L"xnetbvt_nt.dll",
    "BVT_TCPTestServer"
};

NETSYNC_TYPE_THREAD  BVT_TCPSessionXbox =
{
    1,
    4,
    L"xnetbvt_xbox.dll",
    "BVT_TCPTestServer"
};

} // namespace XNetBVTNamespace



#ifdef XNETBVT_CLIENT

namespace XNetBVTNamespace {

BOOL
BVT_TCPTest(
    IN HANDLE  hLog,
    IN LPSTR   pNetsyncRemote
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests TCP - Client side

Arguments:

  hLog - handle to the xLog log object
  pNetsyncRemote - pointer to the netsync remote name

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // iLastError is the last error code
    int                  iLastError = ERROR_SUCCESS;
    // iResult is the result of a function
    int                  iResult = 0;
    // uXNetRef is the reference count of xnet
    ULONG                uXNetRef = 0;
    // XnAddr is the title xnet address
    XNADDR               XnAddr;
    // dwResult is the result of XNetGetTitleXnAddr
    DWORD                dwResult = 0;
    
    // WSAData is the details of the Winsock implementation
    WSADATA              WSAData;
    // hNetsyncObject is a handle to the netsync object
    HANDLE               hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_THREAD  NetsyncTypeSession;
    // NetsyncInAddr is the address of the netsync server
    u_long               NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short              LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short              HighPort = 0;

    // sSocket1 is a socket descriptor
    SOCKET               sSocket1 = INVALID_SOCKET;
    // sSocket2 is a socket descriptor
    SOCKET               sSocket2 = INVALID_SOCKET;
    // sSocket3 is a socket descriptor
    SOCKET               sSocket3 = INVALID_SOCKET;
    // nSocket3 is a connected socket descriptor
    SOCKET               nsSocket3 = INVALID_SOCKET;
    // sSocket4 is a socket descriptor
    SOCKET               sSocket4 = INVALID_SOCKET;
    // nSocket4 is a connected socket descriptor
    SOCKET               nsSocket4 = INVALID_SOCKET;
    // Port1 is the port number of sSocket1
    u_short              Port1 = 0;
    // Port2 is the port number of sSocket2
    u_short              Port2 = 0;
    // Port3 is the port number of sSocket3
    u_short              Port3 = 0;
    // Port4 is the port number of sSocket4
    u_short              Port4 = 0;

    // iTimeout is the send and receive timeout value for the socket
    int                  iTimeout;
    // portname is the local address associated with a socket
    SOCKADDR_IN          portname = { AF_INET, 0, 0, {'\0'} };
    // toname is the recipient address information structure
    SOCKADDR_IN          toname = { AF_INET, 0, 0, {'\0'} };
    // fromname is the sender address information structure
    SOCKADDR_IN          fromname = { AF_INET, 0, 0, {'\0'} };
    // fromnamelen is the sizeof of the fromname buffer
    int                  fromnamelen = sizeof(fromname);

    // readfds is the set of sockets to check for a pending connection
    fd_set               readfds;
    // timeout is the timeout of select
    timeval              timeout;
    // ReceiveBuffer is the receive buffer
    char                 ReceiveBuffer[sizeof(BVTBuffer)];
    // nBytes is the number of bytes sent or received on the socket
    int                  nBytes;

    // FromInAddr is the address of the netsync sender
    u_long               FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD                dwMessageSize;
    // pMessage is a pointer to the received message
    char                 *pMessage;
    // BVT_TCPMessage is the test message sent to the netsync server
    BVT_TCP_MESSAGE      BVT_TCPMessage;



    // Set the function name
    xSetFunctionName(hLog, "BVT TCP");

    // Start the variation
    xStartVariation(hLog, "BVT TCP Test");



    // Initialize the net subsystem
    uXNetRef = XNetAddRef();
    if (0 == uXNetRef) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "XNetAddRef failed - ec: %u", iLastError);

        goto FunctionExit0;
    }

    while (0 == (dwResult = XNetGetTitleXnAddr(&XnAddr))) {
        Sleep(1000);
    }

    // Determine the remote netsync server type
    if (0 != (XNET_GET_XNADDR_ETHERNET & dwResult)) {
        NetsyncTypeSession = BVT_TCPSessionXbox;
    }
    else {
        NetsyncTypeSession = BVT_TCPSessionNt;
    }

    // Initialize Winsock
    iLastError = WSAStartup(MAKEWORD(2, 2), &WSAData);
    if (ERROR_SUCCESS != iLastError) {
        xLog(hLog, XLL_FAIL, "WSAStartup failed - ec: %u", iLastError);

        goto FunctionExit1;
    }



    // Connect to the session
    hNetsyncObject = NetsyncCreateClient((NULL != pNetsyncRemote) ? inet_addr(pNetsyncRemote) : 0, NETSYNC_SESSION_THREAD, &NetsyncTypeSession, &NetsyncInAddr, NULL, &LowPort, &HighPort);
    if (INVALID_HANDLE_VALUE == hNetsyncObject) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", iLastError);
    }
    else {
        Port1 = LowPort;
        Port2 = LowPort + 1;
        Port3 = LowPort + 2;
        Port4 = LowPort + 3;
    }

    if (INVALID_HANDLE_VALUE == hNetsyncObject) {
        goto FunctionExit2;
    }



    // Create socket
    sSocket1 = socket(AF_INET, SOCK_STREAM, 0);
    if (INVALID_SOCKET == sSocket1) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot create socket 1 - ec = %u", iLastError);

        goto FunctionExit3;
    }

    sSocket2 = socket(AF_INET, SOCK_STREAM, 0);
    if (INVALID_SOCKET == sSocket2) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot create socket 2 - ec = %u", iLastError);

        goto FunctionExit4;
    }

    sSocket3 = socket(AF_INET, SOCK_STREAM, 0);
    if (INVALID_SOCKET == sSocket3) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot create socket 3 - ec = %u", iLastError);

        goto FunctionExit5;
    }

    sSocket4 = socket(AF_INET, SOCK_STREAM, 0);
    if (INVALID_SOCKET == sSocket4) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot create socket 4 - ec = %u", iLastError);

        goto FunctionExit6;
    }



    // Set the receive timeout value to 5 sec
    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket1, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set receive timeout value for socket 1 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket2, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set receive timeout value for socket 2 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket3, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set receive timeout value for socket 3 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket4, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set receive timeout value for socket 4 - ec = %u", iLastError);

        goto FunctionExit7;
    }



    // Set the send timeout value to 5 sec
    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket1, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set send timeout value for socket 1 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket2, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set send timeout value for socket 2 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket3, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set send timeout value for socket 3 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sSocket4, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot set send timeout value for socket 4 - ec = %u", iLastError);

        goto FunctionExit7;
    }



    // Bind socket
    portname.sin_port = htons(Port1);
    if (SOCKET_ERROR == bind(sSocket1, (SOCKADDR *) &portname, sizeof(portname))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot bind socket 1 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    portname.sin_port = htons(Port2);
    if (SOCKET_ERROR == bind(sSocket2, (SOCKADDR *) &portname, sizeof(portname))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot bind socket 2 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    portname.sin_port = htons(Port3);
    if (SOCKET_ERROR == bind(sSocket3, (SOCKADDR *) &portname, sizeof(portname))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot bind socket 3 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    portname.sin_port = htons(Port4);
    if (SOCKET_ERROR == bind(sSocket4, (SOCKADDR *) &portname, sizeof(portname))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot bind socket 4 - ec = %u", iLastError);

        goto FunctionExit7;
    }



    // Listen on socket
    if (SOCKET_ERROR == listen(sSocket3, 1)) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot listen on socket 3 - ec = %u", iLastError);

        goto FunctionExit7;
    }

    if (SOCKET_ERROR == listen(sSocket4, 1)) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot listen on socket 4 - ec = %u", iLastError);

        goto FunctionExit7;
    }



    // Start the variation
    xStartVariation(hLog, "Send Test 1");

    // Start the send test
    BVT_TCPMessage.dwMessageId = BVT_TCP_SEND_MSG;
    BVT_TCPMessage.Port = Port1;
    BVT_TCPMessage.iLastError = ERROR_SUCCESS;
    if (WAIT_OBJECT_0 != NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(BVT_TCPMessage), (char *) &BVT_TCPMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncSendClientMessage for socket 1 failed - ec = %u", iLastError);

        goto FunctionExit7;
    }

    // Wait for the ack
    if (WAIT_OBJECT_0 != NetsyncReceiveClientMessage(hNetsyncObject, 15000, &FromInAddr, NULL, &dwMessageSize, &pMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncReceiveClientMessage for socket 1 failed - ec = %u", iLastError);

        goto FunctionExit7;
    }
    NetsyncFreeMessage(pMessage);

    if (ERROR_SUCCESS != BVT_TCPMessage.iLastError) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "Netsync Server failed - ec = %u", iLastError);

        goto FunctionExit7;
    }

    // Initialize connect
    toname.sin_port = htons(Port1);
    toname.sin_addr.s_addr = NetsyncInAddr;

    // Connect on socket 1
    if (SOCKET_ERROR == connect(sSocket1, (SOCKADDR *) &toname, sizeof(toname))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "connect on socket 1 failed - ec = %u", iLastError);
    }
    else {
        // Send first on socket 1
        nBytes = send(sSocket1, BVTBuffer, sizeof(BVTBuffer), 0);
        if (SOCKET_ERROR == nBytes) {
            // Get the last error code
            iLastError = WSAGetLastError();

            xLog(hLog, XLL_FAIL, "send on socket 1 failed - ec = %u", iLastError);
        }
        else {
            if (sizeof(BVTBuffer) != nBytes) {
                xLog(hLog, XLL_FAIL, "send return value on socket 1 - EXPECTED: %d, RECEIVED: %d", sizeof(BVTBuffer), nBytes);
            }

            // Initialize receive
            ZeroMemory(ReceiveBuffer, sizeof(ReceiveBuffer));

            // Receive on socket 1
            nBytes = recv(sSocket1, ReceiveBuffer, sizeof(ReceiveBuffer), 0);
            if (SOCKET_ERROR == nBytes) {
                // Get the last error code
                iLastError = WSAGetLastError();

                xLog(hLog, XLL_FAIL, "recv on socket 1 failed - ec = %u", iLastError);
            }
            else {
                if (sizeof(BVTBuffer) != nBytes) {
                    xLog(hLog, XLL_FAIL, "recv return value on socket 1 - EXPECTED: %d; RECEIVED: %d", sizeof(BVTBuffer), nBytes);
                }
                else if (0 != strcmp(BVTBuffer, ReceiveBuffer)) {
                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer on socket 1 - %s", ReceiveBuffer);
                }
                else {
                    xLog(hLog, XLL_PASS, "send and recv on socket 1 passed");
                }
            }
        }
    }

    // End the variation
    xEndVariation(hLog);



    // Start the variation
    xStartVariation(hLog, "Send Test 2");

    // Start the send test
    BVT_TCPMessage.dwMessageId = BVT_TCP_SEND_MSG;
    BVT_TCPMessage.Port = Port2;
    BVT_TCPMessage.iLastError = ERROR_SUCCESS;
    if (WAIT_OBJECT_0 != NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(BVT_TCPMessage), (char *) &BVT_TCPMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncSendClientMessage for socket 2 failed - ec = %u", iLastError);

        goto FunctionExit7;
    }

    // Wait for the ack
    if (WAIT_OBJECT_0 != NetsyncReceiveClientMessage(hNetsyncObject, 15000, &FromInAddr, NULL, &dwMessageSize, &pMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncReceiveClientMessage for socket 2 failed - ec = %u", iLastError);

        goto FunctionExit7;
    }
    NetsyncFreeMessage(pMessage);

    if (ERROR_SUCCESS != BVT_TCPMessage.iLastError) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "Netsync Server failed - ec = %u", iLastError);

        goto FunctionExit7;
    }

    // Initialize connect
    toname.sin_port = htons(Port2);
    toname.sin_addr.s_addr = NetsyncInAddr;

    // Connect on socket 2
    if (SOCKET_ERROR == connect(sSocket2, (SOCKADDR *) &toname, sizeof(toname))) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "connect on socket 2 failed - ec = %u", iLastError);
    }
    else {
        // Send first on socket 2
        nBytes = send(sSocket2, BVTBuffer, sizeof(BVTBuffer), 0);
        if (SOCKET_ERROR == nBytes) {
            // Get the last error code
            iLastError = WSAGetLastError();

            xLog(hLog, XLL_FAIL, "send on socket 2 failed - ec = %u", iLastError);
        }
        else {
            if (sizeof(BVTBuffer) != nBytes) {
                xLog(hLog, XLL_FAIL, "send return value on socket 2 - EXPECTED: %d, RECEIVED: %d", sizeof(BVTBuffer), nBytes);
            }

            // Initialize receive
            ZeroMemory(ReceiveBuffer, sizeof(ReceiveBuffer));

            // Receive on socket 2
            nBytes = recv(sSocket2, ReceiveBuffer, sizeof(ReceiveBuffer), 0);
            if (SOCKET_ERROR == nBytes) {
                // Get the last error code
                iLastError = WSAGetLastError();

                xLog(hLog, XLL_FAIL, "recv on socket 2 failed - ec = %u", iLastError);
            }
            else {
                if (sizeof(BVTBuffer) != nBytes) {
                    xLog(hLog, XLL_FAIL, "recv return value on socket 2 - EXPECTED: %d; RECEIVED: %d", sizeof(BVTBuffer), nBytes);
                }
                else if (0 != strcmp(BVTBuffer, ReceiveBuffer)) {
                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer on socket 2 - %s", ReceiveBuffer);
                }
                else {
                    xLog(hLog, XLL_PASS, "send and recv on socket 2 passed");
                }
            }
        }
    }

    // End the variation
    xEndVariation(hLog);



    // Start the variation
    xStartVariation(hLog, "Receive Test 1");

    // Start the receive test
    BVT_TCPMessage.dwMessageId = BVT_TCP_RECV_MSG;
    BVT_TCPMessage.Port = Port3;
    BVT_TCPMessage.iLastError = ERROR_SUCCESS;
    if (WAIT_OBJECT_0 != NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(BVT_TCPMessage), (char *) &BVT_TCPMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncSendClientMessage for socket 3 failed - ec = %u", iLastError);

        goto FunctionExit7;
    }

    // Wait for the ack
    if (WAIT_OBJECT_0 != NetsyncReceiveClientMessage(hNetsyncObject, 15000, &FromInAddr, NULL, &dwMessageSize, &pMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncReceiveClientMessage for socket 3 failed - ec = %u", iLastError);

        goto FunctionExit7;
    }
    NetsyncFreeMessage(pMessage);

    if (ERROR_SUCCESS != BVT_TCPMessage.iLastError) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "Netsync Server failed - ec = %u", iLastError);

        goto FunctionExit7;
    }

    // Initialize readfds
    FD_ZERO(&readfds);
    FD_SET(sSocket3, &readfds);

    // Initialize timeout
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;

    // Select on socket 3
    iResult = select(0, &readfds, NULL, NULL, &timeout);
    if (SOCKET_ERROR == iResult) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "select on socket 3 failed - ec = %u", iLastError);
    }
    else if (0 == iResult) {
        xLog(hLog, XLL_FAIL, "select timed out on socket 3");
    }
    else if (0 == FD_ISSET(sSocket3, &readfds)) {
        xLog(hLog, XLL_FAIL, "socket 3 not in readfds");
    }
    else {
        // Accept on socket 3
        fromnamelen = sizeof(fromname);
        nsSocket3 = accept(sSocket3, (SOCKADDR *) &fromname, &fromnamelen);
        if (INVALID_SOCKET == nsSocket3) {
            // Get the last error code
            iLastError = WSAGetLastError();

            xLog(hLog, XLL_FAIL, "accept on socket 3 failed - ec = %u", iLastError);
        }
        else {
            // Initialize receive
            ZeroMemory(ReceiveBuffer, sizeof(ReceiveBuffer));

            // Receive first on socket 3
            nBytes = recv(nsSocket3, ReceiveBuffer, sizeof(ReceiveBuffer), 0);
            if (SOCKET_ERROR == nBytes) {
                // Get the last error code
                iLastError = WSAGetLastError();

                xLog(hLog, XLL_FAIL, "recv on socket 3 failed - ec = %u", iLastError);
            }
            else {
                if (sizeof(BVTBuffer) != nBytes) {
                    xLog(hLog, XLL_FAIL, "recv return value on socket 3 - EXPECTED: %d; RECEIVED: %d", sizeof(BVTBuffer), nBytes);
                }
                else if (0 != strcmp(BVTBuffer, ReceiveBuffer)) {
                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer on socket 3 - %s", ReceiveBuffer);
                }

                // Send on socket 3
                nBytes = send(nsSocket3, ReceiveBuffer, strlen(ReceiveBuffer) + 1, 0);
                if (SOCKET_ERROR == nBytes) {
                    // Get the last error code
                    iLastError = WSAGetLastError();

                    xLog(hLog, XLL_FAIL, "send on socket 3 failed - ec = %u", iLastError);
                }
                else {
                    if ((strlen(ReceiveBuffer) + 1) != (size_t) nBytes) {
                        xLog(hLog, XLL_FAIL, "send return value on socket 3 - EXPECTED: %d: RECEIVED: %d", strlen(ReceiveBuffer) + 1, nBytes);
                    }
                    else {
                        xLog(hLog, XLL_PASS, "recv and send on socket 3 passed");
                    }
                }
            }

            // Close the connected socket
            closesocket(nsSocket3);
            nsSocket3 = INVALID_SOCKET;
        }
    }

    // End the variation
    xEndVariation(hLog);



    // Start the variation
    xStartVariation(hLog, "Receive Test 2");

    // Start the receive test
    BVT_TCPMessage.dwMessageId = BVT_TCP_RECV_MSG;
    BVT_TCPMessage.Port = Port4;
    BVT_TCPMessage.iLastError = ERROR_SUCCESS;
    if (WAIT_OBJECT_0 != NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(BVT_TCPMessage), (char *) &BVT_TCPMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncSendClientMessage for socket 4 failed - ec = %u", iLastError);

        goto FunctionExit7;
    }

    // Wait for the ack
    if (WAIT_OBJECT_0 != NetsyncReceiveClientMessage(hNetsyncObject, 15000, &FromInAddr, NULL, &dwMessageSize, &pMessage)) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "NetsyncReceiveClientMessage for socket 4 failed - ec = %u", iLastError);

        goto FunctionExit7;
    }
    NetsyncFreeMessage(pMessage);

    if (ERROR_SUCCESS != BVT_TCPMessage.iLastError) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "Netsync Server failed - ec = %u", iLastError);

        goto FunctionExit7;
    }

    // Initialize readfds
    FD_ZERO(&readfds);
    FD_SET(sSocket4, &readfds);

    // Initialize timeout
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;

    // Select on socket 4
    iResult = select(0, &readfds, NULL, NULL, &timeout);
    if (SOCKET_ERROR == iResult) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "select on socket 4 failed - ec = %u", iLastError);
    }
    else if (0 == iResult) {
        xLog(hLog, XLL_FAIL, "select timed out on socket 4");
    }
    else if (0 == FD_ISSET(sSocket4, &readfds)) {
        xLog(hLog, XLL_FAIL, "socket 4 not in readfds");
    }
    else {
        // Accept on socket 4
        fromnamelen = sizeof(fromname);
        nsSocket4 = accept(sSocket4, (SOCKADDR *) &fromname, &fromnamelen);
        if (INVALID_SOCKET == nsSocket4) {
            // Get the last error code
            iLastError = WSAGetLastError();

            xLog(hLog, XLL_FAIL, "accept on socket 4 failed - ec = %u", iLastError);
        }
        else {
            // Initialize receive
            ZeroMemory(ReceiveBuffer, sizeof(ReceiveBuffer));

            // Receive first on socket 4
            nBytes = recv(nsSocket4, ReceiveBuffer, sizeof(ReceiveBuffer), 0);
            if (SOCKET_ERROR == nBytes) {
                // Get the last error code
                iLastError = WSAGetLastError();

                xLog(hLog, XLL_FAIL, "recv on socket 4 failed - ec = %u", iLastError);
            }
            else {
                if (sizeof(BVTBuffer) != nBytes) {
                    xLog(hLog, XLL_FAIL, "recv return value on socket 4 - EXPECTED: %d; RECEIVED: %d", sizeof(BVTBuffer), nBytes);
                }
                else if (0 != strcmp(BVTBuffer, ReceiveBuffer)) {
                    xLog(hLog, XLL_FAIL, "Received Unexpected Buffer on socket 4 - %s", ReceiveBuffer);
                }

                // Send on socket 4
                nBytes = send(nsSocket4, ReceiveBuffer, strlen(ReceiveBuffer) + 1, 0);
                if (SOCKET_ERROR == nBytes) {
                    // Get the last error code
                    iLastError = WSAGetLastError();

                    xLog(hLog, XLL_FAIL, "send on socket 4 failed - ec = %u", iLastError);
                }
                else {
                    if ((strlen(ReceiveBuffer) + 1) != (size_t) nBytes) {
                        xLog(hLog, XLL_FAIL, "send return value on socket 4 - EXPECTED: %d: RECEIVED: %d", strlen(ReceiveBuffer) + 1, nBytes);
                    }
                    else {
                        xLog(hLog, XLL_PASS, "recv and send on socket 4 passed");
                    }
                }
            }

            // Close the connected socket
            closesocket(nsSocket4);
            nsSocket4 = INVALID_SOCKET;
        }
    }

    // End the variation
    xEndVariation(hLog);



FunctionExit7:
    // Close the socket
    if (0 != closesocket(sSocket4)) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot close socket 4 - ec = %u", iLastError);
    }

FunctionExit6:
    // Close the socket
    if (0 != closesocket(sSocket3)) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot close socket 3 - ec = %u", iLastError);
    }

FunctionExit5:
    // Close the socket
    if (0 != closesocket(sSocket2)) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot close socket 2 - ec = %u", iLastError);
    }

FunctionExit4:
    // Close the socket
    if (0 != closesocket(sSocket1)) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "Cannot close socket 1 - ec = %u", iLastError);
    }

FunctionExit3:
    // Close the netsync client object
    NetsyncCloseClient(hNetsyncObject);

FunctionExit2:
    // Terminate Winsock
    if (0 != WSACleanup()) {
        // Get the last error code
        iLastError = WSAGetLastError();

        xLog(hLog, XLL_FAIL, "WSACleanup failed - ec: %u", iLastError);
    }

FunctionExit1:
    // Terminate the net subsystem
    if ((uXNetRef - 1) != XNetRelease()) {
        // Get the last error code
        iLastError = GetLastError();

        xLog(hLog, XLL_FAIL, "XNetRelease failed - ec: %u", iLastError);
    }

FunctionExit0:
    if (ERROR_SUCCESS == iLastError) {
        xLog(hLog, XLL_PASS, "Test passed");
    }

    // End the variation
    xEndVariation(hLog);

    return (ERROR_SUCCESS == iLastError);
}

} // namespace XNetBVTNamespace



#else



VOID
WINAPI
BVT_TCPTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests TCP - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // sSocket is a socket descriptor
    SOCKET           sSocket = INVALID_SOCKET;
    // nsSocket is a connected socket descriptor
    SOCKET           nsSocket = INVALID_SOCKET;
    // iTimeout is the send and receive timeout value for the socket
    int              iTimeout;
    // portname is the local address associated with a socket
    SOCKADDR_IN      portname = { AF_INET, 0, 0, {'\0'} };
    // toname is the recipient address information structure
    SOCKADDR_IN      toname = { AF_INET, 0, 0, {'\0'} };
    // fromname is the sender address information structure
    SOCKADDR_IN      fromname = { AF_INET, 0, 0, {'\0'} };
    // fromnamelen is the sizeof of the fromname buffer
    int              fromnamelen = sizeof(fromname);

    // readfds is the set of sockets to check for a pending connection
    fd_set           readfds;
    // timeout is the timeout of select
    timeval          timeout;
    // iResult is the result of select
    int              iResult;
    // ReceiveBuffer is the receive buffer
    char             ReceiveBuffer[sizeof(BVTBuffer)];
    // nBytes is the number of bytes sent or received on the socket
    int              nBytes;

    // FromInAddr is the address of the netsync sender
    u_long           FromInAddr;
    // dwMessageType is the type of received message
    DWORD            dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD            dwMessageSize;
    // pMessage is a pointer to the received message
    char             *pMessage;
    // BVT_TCPMessage is the test message sent to the netsync server
    BVT_TCP_MESSAGE  BVT_TCPMessage;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage);
        if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
            if ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                NetsyncFreeMessage(pMessage);
                break;
            }

            NetsyncFreeMessage(pMessage);
            continue;
        }
        CopyMemory(&BVT_TCPMessage, pMessage, sizeof(BVT_TCPMessage));
        NetsyncFreeMessage(pMessage);

        // Create the socket
        sSocket = socket(AF_INET, SOCK_STREAM, 0);
        if (INVALID_SOCKET == sSocket) {
            // Get the last error code
            BVT_TCPMessage.iLastError = WSAGetLastError();

            goto SendAck;
        }
        
        // Bind the socket
        portname.sin_port = htons(BVT_TCPMessage.Port);
        if (SOCKET_ERROR == bind(sSocket, (SOCKADDR *) &portname, sizeof(portname))) {
            // Get the last error code
            BVT_TCPMessage.iLastError = WSAGetLastError();

            goto SendAck;
        }
        
        if (BVT_TCP_SEND_MSG == BVT_TCPMessage.dwMessageId) {
            // Listen on the socket
            if (SOCKET_ERROR == listen(sSocket, 1)) {
                // Get the last error code
                BVT_TCPMessage.iLastError = WSAGetLastError();

                goto SendAck;
            }
        }
        
        // Set the receive timeout value to 5 sec
        iTimeout = 5000;
        if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
            // Get the last error code
            BVT_TCPMessage.iLastError = WSAGetLastError();

            goto SendAck;
        }

        // Set the send timeout value to 5 sec
        iTimeout = 5000;
        if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
            // Get the last error code
            BVT_TCPMessage.iLastError = WSAGetLastError();

            goto SendAck;
        }

SendAck:
        // Send the ack
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, dwMessageSize, (char *) &BVT_TCPMessage);

        if (ERROR_SUCCESS == BVT_TCPMessage.iLastError) {
            if (BVT_TCP_SEND_MSG == BVT_TCPMessage.dwMessageId) {
                // Initialize readfds
                FD_ZERO(&readfds);
                FD_SET(sSocket, &readfds);

                // Initialize timeout
                timeout.tv_sec = 5;
                timeout.tv_usec = 0;

                // Select on socket
                iResult = select(0, &readfds, NULL, NULL, &timeout);
                if ((SOCKET_ERROR != iResult) && (0 != iResult) && (0 != FD_ISSET(sSocket, &readfds))) {
                    // Accept on the socket
                    fromnamelen = sizeof(fromname);
                    nsSocket = accept(sSocket, (SOCKADDR *) &fromname, &fromnamelen);
                    if (INVALID_SOCKET != nsSocket) {
                        // Receive the buffer
                        recv(nsSocket, ReceiveBuffer, sizeof(ReceiveBuffer), 0);

                        // Send the buffer
                        send(nsSocket, ReceiveBuffer, strlen(ReceiveBuffer) + 1, 0);

                        // Close the connected socket
                        closesocket(nsSocket);
                        nsSocket = INVALID_SOCKET;
                    }
                }
            }
            else if (BVT_TCP_RECV_MSG == BVT_TCPMessage.dwMessageId) {
                // Connect the socket
                toname.sin_port = htons(BVT_TCPMessage.Port);
                toname.sin_addr.s_addr = FromInAddr;
                if (SOCKET_ERROR != connect(sSocket, (SOCKADDR *) &toname, sizeof(toname))) {
                    // Send the buffer
                    send(sSocket, BVTBuffer, sizeof(BVTBuffer), 0);

                    // Receive the buffer
                    recv(sSocket, ReceiveBuffer, sizeof(ReceiveBuffer), 0);
                }
            }
        }

        if (INVALID_SOCKET != sSocket) {
            // Close the socket
            closesocket(sSocket);
            sSocket = INVALID_SOCKET;
        }
    }
}

#endif // XNETBVT_CLIENT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\bvt\util.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.h

Abstract:

  This module contains the definitions for util.c

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#pragma once



namespace XNetBVTNamespace {

LPSTR
GetIniString(
    HANDLE  hMemObject,
    LPCSTR  lpszSectionName,
    LPCSTR  lpszKeyName
);

} // namespace XNetBVTNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\keys\client.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.c

Abstract:

  Entry point for xboxkeys

Author:

  Steven Kehrli (steveke) 9-Jul-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XboxKeysNamespace;

namespace XboxKeysNamespace {

VOID
XboxKeysMain()
{
    // LaunchData is the title launch data
    LAUNCH_DATA  LaunchData;
    // dwDataType is the type of title launch data
    DWORD        dwDataType;
    // hLog is a handle to the xLog log file
    HANDLE       hLog;



    // Get the launch info
    XGetLaunchInfo(&dwDataType, &LaunchData);

    // Create the xLog log file
    hLog = xCreateLog(L"T:\\xboxkeys.log", NULL, INVALID_SOCKET, XLL_LOGDEFAULT, XLO_DEBUG | XLO_CONFIG | XLO_STATE | (LDT_TITLE == dwDataType ? 0 : XLO_REFRESH));

    // Test keys
    XboxKeysTest(hLog, (LDT_TITLE == dwDataType), (PXBOXKEYS) &LaunchData);

    // Test keys over network
    XboxKeysNetworkTest(hLog, (LDT_TITLE == dwDataType));

    xCloseLog(hLog);

    if (LDT_TITLE == dwDataType) {
        XLaunchNewImage(NULL, NULL);
    }
    else {
        XLaunchNewImage("D:\\xboxkeys2.xbe", &LaunchData);
    }
}

} // namespace XboxKeysNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\keys\client.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.h

Abstract:

  This modules contains the definitions for client.c

Author:

  Steven Kehrli (steveke) 9-Jul-2001

------------------------------------------------------------------------------*/

#pragma once



namespace XboxKeysNamespace {



// Function prototypes

VOID
XboxKeysMain();

} // namespace XboxKeysNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\keys\keys.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  keys.c

Abstract:

  This modules tests the xbox lan key and xbox sig key

Author:

  Steven Kehrli (steveke) 9-Jul-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XboxKeysNamespace;

namespace XboxKeysNamespace {

VOID
XboxKeysTest(
    IN HANDLE     hLog,
    IN BOOL       bKeys,
    IN PXBOXKEYS  pXboxKeys
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests xbox lan key and xbox sig key

Arguments:

  hLog - handle to the xLog log object
  bKeys - specifies if the xbox keys structure is valid
  pXboxKeys - pointer to the xbox keys structure

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // szXboxKey is the string representation of the xbox key
    char   szXboxKey[XBOX_KEY_LENGTH * 2 + 1];
    // dwByteIndex is a counter to enumerate each byte of the key
    DWORD  dwByteIndex = 0;



    // Set the component and subcomponent
    xSetComponent(hLog, "Kernel(S)", "Certificate-SignatureValidation(S-k)");

    // Set the function name
    xSetFunctionName(hLog, "XboxSignatureKey & XboxLANKey");

    // Start the variation
    xStartVariation(hLog, "XboxSignatureKey Cert");

    // Format the xbox sig key
    for (dwByteIndex = 0; dwByteIndex < XBOX_KEY_LENGTH; dwByteIndex++) {
        sprintf(&szXboxKey[dwByteIndex * 2], "%02x", (*XboxSignatureKey)[dwByteIndex]);
    }
    xLog(hLog, XLL_INFO, "XboxSignatureKey: %s", szXboxKey);

    // Compare the xbox sig key
    if (FALSE == bKeys) {
        CopyMemory(pXboxKeys->XboxSignatureKey, XboxSignatureKey, XBOX_KEY_LENGTH * sizeof(UCHAR));

        if (0 != memcmp(pXboxKeys->XboxSignatureKey, XboxSignatureKey, XBOX_KEY_LENGTH * sizeof(UCHAR))) {
            xLog(hLog, XLL_FAIL, "XboxSignatureKey was changed");
        }
        else {
            xLog(hLog, XLL_PASS, "XboxSignatureKey passed");
        }
    }
    else {
        if (0 == memcmp(pXboxKeys->XboxSignatureKey, XboxSignatureKey, XBOX_KEY_LENGTH * sizeof(UCHAR))) {
            xLog(hLog, XLL_FAIL, "XboxSignatureKey was not changed");
        }
        else {
            xLog(hLog, XLL_PASS, "XboxSignatureKey passed");
        }
    }

    // End the variation
    xEndVariation(hLog);

    // Start the variation
    xStartVariation(hLog, "XboxLANKey Cert");

    // Format the xbox lan key
    for (dwByteIndex = 0; dwByteIndex < XBOX_KEY_LENGTH; dwByteIndex++) {
        sprintf(&szXboxKey[dwByteIndex * 2], "%02x", (*XboxLANKey)[dwByteIndex]);
    }
    xLog(hLog, XLL_INFO, "XboxLANKey: %s", szXboxKey);

    // Compare the xbox lan key
    if (FALSE == bKeys) {
        CopyMemory(pXboxKeys->XboxLANKey, XboxLANKey, XBOX_KEY_LENGTH * sizeof(UCHAR));

        if (0 != memcmp(pXboxKeys->XboxLANKey, XboxLANKey, XBOX_KEY_LENGTH * sizeof(UCHAR))) {
            xLog(hLog, XLL_FAIL, "XboxLANKey was changed");
        }
        else {
            xLog(hLog, XLL_PASS, "XboxLANKey passed");
        }
    }
    else {
        if (0 == memcmp(pXboxKeys->XboxLANKey, XboxLANKey, XBOX_KEY_LENGTH * sizeof(UCHAR))) {
            xLog(hLog, XLL_FAIL, "XboxLANKey was not changed");
        }
        else {
            xLog(hLog, XLL_PASS, "XboxLANKey passed");
        }
    }

    // End the variation
    xEndVariation(hLog);
}

} // namespace XboxKeysNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\keys\server.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright Microsoft Corporation

Module Name:

  server.c

Abstract:

  This modules contains the server side exports

Author:

  Steven Kehrli (steveke) 17-Apr-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef __cplusplus
extern "C" {
#endif

// Netsync export table for syncsrv

#pragma data_seg(NETSYNC_EXPORT_SECTION_NAME)
DECLARE_NETSYNC_EXPORT_DIRECTORY(xboxkeys_xbox)
#pragma data_seg()

BEGIN_NETSYNC_EXPORT_TABLE(xboxkeys_xbox)
    NETSYNC_EXPORT_TABLE_ENTRY("XboxKeysTestServer", XboxKeysTestServer)
END_NETSYNC_EXPORT_TABLE(xboxkeys_xbox)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\keys\keys.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  xboxkeys.h

Abstract:

  This module contains the function definitions

Author:

  Steven Kehrli (steveke) 9-Jul-2001

------------------------------------------------------------------------------*/

#pragma once



namespace XboxKeysNamespace {

typedef struct _XBOXKEYS {
    UCHAR  XboxSignatureKey[XBOX_KEY_LENGTH];  // XboxSignatureKey is the xbox sig key
    UCHAR  XboxLANKey[XBOX_KEY_LENGTH];        // XboxLANKey is the xbox lan key
} XBOXKEYS, *PXBOXKEYS;



// Function prototypes

VOID
XboxKeysTest(
    IN HANDLE     hLog,
    IN BOOL       bKeys,
    IN PXBOXKEYS  pXboxKeys
);

VOID
XboxKeysNetworkTest(
    IN HANDLE  hLog,
    IN BOOL    bKeys
);

} // namespace XboxKeysNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\keys\client\main.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  main.c

Abstract:

  Entry point for xboxkeys

Author:

  Steven Kehrli (steveke) 9-Jul-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XboxKeysNamespace;

void __cdecl main()
{
    XboxKeysMain();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\keys\keysnet.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  keysnet.c

Abstract:

  This modules tests the xbox lan key during broadcast and lan key exchange

Author:

  Steven Kehrli (steveke) 9-Jul-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef XBOXKEYS_CLIENT

using namespace XboxKeysNamespace;

namespace XboxKeysNamespace {

NETSYNC_TYPE_THREAD  XboxKeysTestSessionXbox =
{
    1,
    1,
    L"xboxkeys_xbox.dll",
    "XboxKeysTestServer"
};



VOID
XboxKeysNetworkTest(
    IN HANDLE  hLog,
    IN BOOL    bKeys
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests xbox lan key during broadcast and lan key exchange

Arguments:

  hLog - handle to the xLog log object
  bKeys - specifies if the xbox keys structure is valid

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // hNetsyncObject is a handle to the netsync object
    HANDLE   hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncAddr is the address of the netsync server
    u_long   NetsyncAddr = 0;



    // Set the component and subcomponent
    xSetComponent(hLog, "Network(S)", "Others(S-n)");

    // Set the function name
    xSetFunctionName(hLog, "XboxLANKey");

    // Start the variation
    xStartVariation(hLog, "XboxLANKey");

    // Connect to the session
    hNetsyncObject = NetsyncCreateClient(0, NETSYNC_SESSION_THREAD, &XboxKeysTestSessionXbox, &NetsyncAddr, NULL, NULL, NULL);

    // Check the xbox sig key
    if (TRUE == bKeys) {
        if (INVALID_HANDLE_VALUE != hNetsyncObject) {
            xLog(hLog, XLL_FAIL, "Netsync response: XboxLANKey failed");
        }
        else {
            xLog(hLog, XLL_PASS, "XboxLANKey passed");
        }
    }
    else {
        if (INVALID_HANDLE_VALUE == hNetsyncObject) {
            xLog(hLog, XLL_FAIL, "Netsync no response: XboxLANKey failed");
        }
        else {
            xLog(hLog, XLL_PASS, "XboxLANKey passed");
        }
    }

    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync client object
        NetsyncCloseClient(hNetsyncObject);
    }

    // End the variation
    xEndVariation(hLog);
}

} // namespace XboxKeysNamespace



#else



VOID
WINAPI
XboxKeysTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests xboxkeys - Server side

Arguments:

  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // FromAddr is the address of the netsync sender
    u_long                    FromAddr;
    // dwMessageType is the type of received message
    DWORD                     dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                     dwMessageSize;
    // pMessage is a pointer to the received message
    char                      *pMessage;



    while (TRUE) {
        // Receive a message
        NetsyncReceiveMessage(hNetsyncObject, INFINITE, &dwMessageType, &FromAddr, NULL, &dwMessageSize, &pMessage);
        if ((NETSYNC_MSGTYPE_SERVER == dwMessageType) && ((NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId))) {
            NetsyncFreeMessage(pMessage);
            break;
        }

        NetsyncFreeMessage(pMessage);
    }
}

#endif // XBOXKEYS_CLIENT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\keys\client\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 9-Jul-2001

------------------------------------------------------------------------------*/

#include <xtl.h>

#include "client.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\keys\server.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  server.h

Abstract:

  This module contains the definitions for server.c

Author:

  Steven Kehrli (steveke) 17-Apr-2001

------------------------------------------------------------------------------*/

#pragma once



// Function prototypes

VOID
WINAPI
XboxKeysTestServer(
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\keys\client\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF



TARGETPATH=obj
TARGETTYPE=PROGRAM

UMTYPE=xboxapp

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_CXX=1

USECXX_FLAG=/Tp

INCLUDES=\
    $(INCLUDES); \
    ..\; \
    ..\..\; \

TARGETLIBS=\
    $(LIBRARY_PATH)\xnet$(S)$(D).lib \
    $(BASEDIR)\private\test\lib\*\xtestlib.lib    \
    $(BASEDIR)\private\test\lib\*\xmem.lib        \
    $(BASEDIR)\private\test\lib\*\xnetref$(D).lib \
    $(BASEDIR)\private\test\lib\*\xlog.lib        \
    $(BASEDIR)\private\test\lib\*\netsync.lib     \
    ..\..\lib\*\xboxkeys.lib                      \

SOURCES=\
    main.c      \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\client\client.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.h

Abstract:

  This module contains the definitions for client.c

Author:

  Steven Kehrli (steveke) 5-Feb-2002

------------------------------------------------------------------------------*/

#pragma once



namespace SGDataNamespace {



// Function prototypes

BOOL
SGDataTest(
    IN HANDLE  hLog
);

} // namespace SGDataNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\keys\lib\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 9-Jul-2001

------------------------------------------------------------------------------*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>

#include <xtl.h>
#include <stdio.h>

#include <xnetref.h>
#include <xlog.h>
#include <netsync.h>

#include "keys.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\client\main.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  main.c

Abstract:

  This modules tests SG Data Validation - executable

Author:

  Steven Kehrli (steveke) 5-Feb-2002

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace SGDataNamespace;

void __cdecl main()
{
    // hLog is the handle to the xLog object
    HANDLE  hLog = INVALID_HANDLE_VALUE;



    // Initialize the devices
    XInitDevices(0, NULL);

    // Create the xLog object
    hLog = xCreateLog(L"T:\\sgdata.log", NULL, INVALID_SOCKET, XLL_LOGDEFAULT, XLO_DEBUG | XLO_CONFIG | XLO_STATE | XLO_REFRESH);

    // Run the test
    StartTest(hLog);
    EndTest();

    // Close the xLog object
    xCloseLog(hLog);

    // Launch the dashboard
    XLaunchNewImage(NULL, NULL);

    __asm int 3;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\client\client.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.c

Abstract:

  Entry points for sgdata.dll

Author:

  Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace SGDataNamespace;

namespace SGDataNamespace {

VOID
WINAPI
StartTest(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Test entry point

Arguments:

  hLog - handle to the xLog log object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Run the test
    SGDataTest(hLog);
}



VOID
WINAPI
EndTest(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Test exit point

Return Value:

  None

------------------------------------------------------------------------------*/
{
}

} // namespace SGDataNamespace



#ifdef __cplusplus
extern "C" {
#endif

// Export table for harness

#pragma data_seg(EXPORT_SECTION_NAME)
DECLARE_EXPORT_DIRECTORY(sgdata)
#pragma data_seg()

BEGIN_EXPORT_TABLE(sgdata)
    EXPORT_TABLE_ENTRY("StartTest", StartTest)
    EXPORT_TABLE_ENTRY("EndTest", EndTest)
END_EXPORT_TABLE(sgdata)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\client\main.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  main.h

Abstract:

  This module contains the definitions for main.c

Author:

  Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#pragma once



namespace SGDataNamespace {



// Function prototypes

VOID
WINAPI
StartTest(
    IN HANDLE  hLog
);

VOID
WINAPI
EndTest(
);

} // namespace SGDataNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\keys\server\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 9-Jul-2001

------------------------------------------------------------------------------*/

#include <xtl.h>

#include <netsync.h>

#include "server.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\client\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF



TARGETNAME=sgdata

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_CXX=1

USECXX_FLAG=/Tp

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\inc; \
    ..; \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\server\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 24-Jan-2002

------------------------------------------------------------------------------*/

#include <windows.h>
#include <winsock2.h>
#include <commctrl.h>
#include <stdio.h>

#include <xmem.h>
#include <datamask.h>

#include "resource.h"
#include "util.h"
#include "sgdata.h"
#include "sgdatap.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\server\resource.h ===
#define IDI_SGDATA_ICON              1001
#define IDD_DIALOG                   1002
#define IDC_STATUS_LIST              1003

#define IDS_SGDATA_CAPTION           2001
#define IDS_MEMORY_INIT_FAILED       2002
#define IDS_LOGFILE_INIT_FAILED      2003
#define IDS_WINSOCK_INIT_FAILED      2004
#define IDS_SESSION_INIT_FAILED      2005
#define IDS_REMOTENAME_LABEL         2006
#define IDS_UDPBYTECOUNT_LABEL       2007
#define IDS_TCPBYTECOUNT_LABEL       2008
#define IDS_FIRSTACTIVITYTIME_LABEL  2009
#define IDS_LASTACTIVITYTIME_LABEL   2010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\client\lib\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 24-Jan-2002

------------------------------------------------------------------------------*/

#include <xtl.h>
#include <xonlinep.h>
#include <xonline.h>

#include <OnlineAccounts.h>

#include <xtestlib.h>
#include <xmem.h>
#include <xonlineref.h>
#include <xlog.h>
#include <datamask.h>

#include "sgdata.h"
#include "sgdatap.h"
#include "client.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\inc\sgdata.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  sgdata.h

Abstract:

  This module defines the common data for the sgdata client and server

Author:

  Steven Kehrli (steveke) 24-Jan-2002

------------------------------------------------------------------------------*/

#pragma once



namespace SGDataNamespace {



// Messages

#define SGDATA_ENUM_MSG          1
#define SGDATA_ENUM_REPLY        2
#define SGDATA_CONNECT_MSG       3
#define SGDATA_CONNECT_SUCCESS   4
#define SGDATA_CONNECT_FAILED    5
#define SGDATA_DISCONNECT_MSG    6
#define SGDATA_DISCONNECT_REPLY  7

typedef struct _SGDATA_MESSAGE {
    DWORD  dwMessageId;  // Specifies the message id
    DWORD  dwErrorCode;  // Specifies the error code
} SGDATA_MESSAGE, *PSGDATA_MESSAGE;

} // namespace SGDataNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\client\sgdatap.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  sgdata.h

Abstract:

  This module defines the common data

Author:

  Steven Kehrli (steveke) 5-Feb-2002

------------------------------------------------------------------------------*/

#pragma once



namespace SGDataNamespace {

// Buffers

#define BUFFER_10_LEN   10
#define BUFFER_UDP_LEN  1430
#define BUFFER_TCP_LEN  1418

typedef struct _TEST_OBJECT {
    HANDLE   hMemObject;                 // Handle to the memory object
    SOCKET   sSessionSocket;             // Specifies the session socket descriptor
    SOCKET   sUDPSocket;                 // Specifies the UDP socket descriptor
    SOCKET   sTCPSocket;                 // Specifies the TCP socket descriptor
} TEST_OBJECT, *PTEST_OBJECT;



// Functions

BOOL
SGDataTest(
    IN HANDLE  hLog
);

} // namespace SGDataNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\client\exe\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 24-Jan-2002

------------------------------------------------------------------------------*/

#include <xtl.h>
#include <xlog.h>

#include "main.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\client\sgdata.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  sgdata.c

Abstract:

  This modules tests SG Data Validation - library

Author:

  Steven Kehrli (steveke) 5-Feb-2002

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace SGDataNamespace;

namespace SGDataNamespace {



ULONG
AddRefNet(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Initializes the online subsystem

Arguments:

  hLog - Handle to the xLog log object

Return Value:

  ULONG:
    If the function succeeds, the return value is a non-zero
    If the function fails, the return value is 0.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // iLastError is the last error code
    int     iLastError = ERROR_SUCCESS;
    // uXOnlineRef is the reference count of xonline
    ULONG   uXOnlineRef = 0;
    // XnAddr is the title xnet address
    XNADDR  XnAddr;
    // dwResult is the result of XNetGetTitleXnAddr
    DWORD   dwResult = 0;



    // Start the variation
    xStartVariation(hLog, "SG Data Net Stack");

    // Initialize the online subsystem
    uXOnlineRef = XOnlineAddRef();
    if (0 == uXOnlineRef) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "XOnlineAddRef failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    while (0 == (dwResult = XNetGetTitleXnAddr(&XnAddr))) {
        Sleep(1000);
    }

    xLog(hLog, XLL_PASS, "Net Stack passed");

FunctionExit:
    // End the variation
    xEndVariation(hLog);

    if (ERROR_SUCCESS != iLastError) {
        SetLastError(iLastError);
    }

    return uXOnlineRef;
}



VOID
ReleaseNet(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Terminates the online subsystem

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Terminate the online subsystem
    XOnlineRelease();
}



BOOL
SGUsers(
    IN     HANDLE         hLog,
    IN     PXONLINE_USER  pOnlineUsers,
    IN OUT LPDWORD        lpdwNumUsers
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the online users

Arguments:

  hLog - Handle to the xLog log object
  pOnlineUsers - Pointer to the array of online users
  dwNumUsers - Pointer to the number of online users

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // iLastError is the last error code
    int           iLastError = ERROR_SUCCESS;
    // hResult is the return code of a function
    HRESULT       hResult;

    // OnlineAllUsers is the array of all online user accounts
    XONLINE_USER  OnlineAllUsers[XONLINE_MAX_STORED_ONLINE_USERS];



    // Start the variation
    xStartVariation(hLog, "SG Data Users");

    // Initialize the users
    ZeroMemory(pOnlineUsers, *lpdwNumUsers * sizeof(XONLINE_USER));

    // Populate user accounts
    hResult = COnlineAccounts::Instance()->PopulateUserAccountsHD(NULL, *lpdwNumUsers);
    if (FAILED(hResult)) {
        iLastError = HRESULT_CODE(hResult);
        xLog(hLog, XLL_FAIL, "PopulateUserAccountsHD failed - hResult: 0x%08x - ec: %u", hResult, iLastError);

        goto FunctionExit;
    }

    // Get the user accounts
    ZeroMemory(&OnlineAllUsers, sizeof(OnlineAllUsers));
    hResult = XOnlineGetUsers(OnlineAllUsers, lpdwNumUsers);
    if (FAILED(hResult)) {
        iLastError = HRESULT_CODE(hResult);
        xLog(hLog, XLL_FAIL, "XOnlineGetUsers failed - hResult: 0x%08x - ec: %u", hResult, iLastError);

        goto FunctionExit;
    }

    if (0 == *lpdwNumUsers) {
        hResult = XONLINE_E_NO_USER;
        iLastError = HRESULT_CODE(hResult);
        xLog(hLog, XLL_FAIL, "No Users");

        goto FunctionExit;
    }

    // Copy the user accounts
    *lpdwNumUsers = __min(*lpdwNumUsers, XONLINE_MAX_LOGON_USERS);
    CopyMemory(pOnlineUsers, &OnlineAllUsers, *lpdwNumUsers * sizeof(XONLINE_USER));

    xLog(hLog, XLL_PASS, "Users passed");

FunctionExit:
    // End the variation
    xEndVariation(hLog);

    if (ERROR_SUCCESS != iLastError) {
        SetLastError(iLastError);
    }

    return (ERROR_SUCCESS == iLastError);
}



XONLINETASK_HANDLE
SGLogon(
    IN HANDLE        hLog,
    IN XONLINE_USER  *pOnlineUsers,
    IN DWORD         dwNumUsers
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Connects to the SG Data Validation Service

Arguments:

  hLog - Handle to the xLog log object
  pOnlineUsers - Pointer to the array of online users

Return Value:

  XONLINETASK_HANDLE: Online task handle

------------------------------------------------------------------------------*/
{
    // iLastError is the last error code
    int                 iLastError = ERROR_SUCCESS;
    // hResult is the return code of a function
    HRESULT             hResult;

    // OnlineLogonUsers is the array of all online user accounts
    XONLINE_USER        OnlineLogonUsers[XONLINE_MAX_LOGON_USERS];
    // dwOnlineServices is the array of online services
    DWORD               dwOnlineServices[] = { XONLINE_SG_DATA_ENUM_SERVICE, XONLINE_SG_DATA_TEST_SERVICE };
    // dwNumServices is the number of online services
    DWORD               dwNumServices = sizeof(dwOnlineServices) / sizeof(dwOnlineServices[0]);

    // hOnlineLogonEvent is the handle to the XOnlineLogon work event
    HANDLE              hOnlineLogonEvent = NULL;
    // OnlineLogonHandle is the pointer to the XOnlineLogon task handle
    XONLINETASK_HANDLE  OnlineLogonHandle = NULL;



    // Start the variation
    xStartVariation(hLog, "SG Data Logon");

    // Copy the users
    ZeroMemory(&OnlineLogonUsers, sizeof(OnlineLogonUsers));
    memcpy(&OnlineLogonUsers, pOnlineUsers, __min(dwNumUsers * sizeof(XONLINE_USER), sizeof(OnlineLogonUsers)));

    // Create the XOnlineLogon work event
    hOnlineLogonEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == hOnlineLogonEvent) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "hOnlineLogonEvent failed - ec: %u ", iLastError);

        goto FunctionExit;
    }

    // Logon to the services
    hResult = XOnlineLogon((PXONLINE_USER) &OnlineLogonUsers, dwOnlineServices, dwNumServices, hOnlineLogonEvent, &OnlineLogonHandle);
    if (FAILED(hResult)) {
        iLastError = HRESULT_CODE(hResult);
        xLog(hLog, XLL_FAIL, "XOnlineLogon failed - hResult: 0x%08x - ec: %u", hResult, iLastError);

        goto FunctionExit;
    }

    do {
        WaitForSingleObject(hOnlineLogonEvent, INFINITE);

        hResult = XOnlineTaskContinue(OnlineLogonHandle);
    } while (XONLINETASK_S_RUNNING == hResult);

    if (XONLINE_S_LOGON_CONNECTION_ESTABLISHED != hResult) {
        iLastError = HRESULT_CODE(hResult);
        xLog(hLog, XLL_FAIL, "XOnlineTaskContinue (Logon) failed - hResult: 0x%08x - ec: %u", hResult, iLastError);

        goto FunctionExit;
    }

    // Get the logon results
    hResult = XOnlineLogonTaskGetResults(OnlineLogonHandle);
    if (FAILED(hResult)) {
        iLastError = HRESULT_CODE(hResult);
        xLog(hLog, XLL_FAIL, "XOnlineLogonTaskGetResults failed - hResult: 0x%08x - ec: %u", hResult, iLastError);

        goto FunctionExit;
    }

    xLog(hLog, XLL_PASS, "Logon passed");

FunctionExit:
    if (ERROR_SUCCESS != iLastError) {
        if (NULL != OnlineLogonHandle) {
            XOnlineTaskClose(OnlineLogonHandle);
            OnlineLogonHandle = NULL;
        }

    }

    if (NULL != hOnlineLogonEvent) {
        CloseHandle(hOnlineLogonEvent);
    }

    // End the variation
    xEndVariation(hLog);

    if (ERROR_SUCCESS != iLastError) {
        SetLastError(iLastError);
    }

    return OnlineLogonHandle;
}



SOCKET
CreateSocket(
    IN int     type,
    IN u_short sin_port
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Creates and binds a socket

Arguments:

  type - Specifies the type of socket (SOCK_DGRAM or SOCK_STREAM)
  sin_port - Specifies the bind port of socket

Return Value:

  SOCKET:
    If the function succeeds, the return value is a socket descriptor
    If the function fails, the return value is INVALID_SOCKET.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // sSocket is the new socket
    SOCKET       sSocket = INVALID_SOCKET;
    // iTimeout is the timeout value of the socket
    int          iTimeout;
    // localname is the local address
    SOCKADDR_IN  localname;
    // dwErrorCode is the last error code
    DWORD        dwErrorCode = ERROR_SUCCESS;



    // Create the socket
    sSocket = socket(AF_INET, type, 0);
    if (INVALID_SOCKET == sSocket) {
        // Get the last error code
        dwErrorCode = WSAGetLastError();

        goto FunctionExit;
    }

    // Set the socket timeouts
    iTimeout = 15000;
    if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

    iTimeout = 15000;
    if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

    // Setup the local address
    ZeroMemory(&localname, sizeof(localname));
    localname.sin_family = AF_INET;
    localname.sin_port = htons(sin_port);

    // Bind the socket
    if (SOCKET_ERROR == bind(sSocket, (SOCKADDR *) &localname, sizeof(localname))) {
        // Get the last error code
        dwErrorCode = WSAGetLastError();

        goto FunctionExit;
    }

FunctionExit:
    if (ERROR_SUCCESS != dwErrorCode) {
        if (INVALID_SOCKET != sSocket) {
            closesocket(sSocket);
            sSocket = INVALID_SOCKET;
        }

        SetLastError(dwErrorCode);
    }

    return sSocket;
}



VOID
SGClose(
    IN PTEST_OBJECT  pTestObject
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Closes the test object

Arguments:

  pTestObject - Pointer to the test object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // hMemObject is the handle to the memory object
    HANDLE  hMemObject = pTestObject->hMemObject;



    // Close the session socket
    if (INVALID_SOCKET != pTestObject->sSessionSocket) {
        shutdown(pTestObject->sSessionSocket, SD_BOTH);
        closesocket(pTestObject->sSessionSocket);
    }

    // Close the UDP socket
    if (INVALID_SOCKET != pTestObject->sUDPSocket) {
        shutdown(pTestObject->sUDPSocket, SD_BOTH);
        closesocket(pTestObject->sUDPSocket);
    }

    // Close the TCP socket
    if (INVALID_SOCKET != pTestObject->sTCPSocket) {
        shutdown(pTestObject->sTCPSocket, SD_BOTH);
        closesocket(pTestObject->sTCPSocket);
    }

    // Close the test object
    xMemFree(hMemObject, pTestObject);

    // Close the memory object
    xMemClose(hMemObject);
}



PTEST_OBJECT
SGOpen(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Opens the test object

Arguments:

  hLog - Handle to the xLog log object

Return Value:

  PTEST_OBJECT - Pointer to the test object

------------------------------------------------------------------------------*/
{
    // iLastError is the last error code
    int           iLastError = ERROR_SUCCESS;

    // hMemObject is the handle to the memory object
    HANDLE        hMemObject = INVALID_HANDLE_VALUE;
    // pTestObject is the pointer to the test object
    PTEST_OBJECT  pTestObject = NULL;
    // sin_port is the port
    u_short       sin_port = 0;



    // Create the memory object
    hMemObject = xMemCreate();
    if (INVALID_HANDLE_VALUE == hMemObject) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "xMemCreate failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Create the test object
    pTestObject = (PTEST_OBJECT) xMemAlloc(hMemObject, sizeof(TEST_OBJECT));
    if (NULL == pTestObject) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "pTestObject failed - ec = %u", iLastError);

        // Close the memory object
        xMemClose(hMemObject);

        goto FunctionExit;
    }

    // Set the memory object
    pTestObject->hMemObject = hMemObject;

    // Generate a random port
    XNetRandom((BYTE *) &sin_port, sizeof(sin_port));

    // Create the session socket
    pTestObject->sSessionSocket = CreateSocket(SOCK_DGRAM, sin_port);
    if (INVALID_SOCKET == pTestObject->sSessionSocket) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "sSessionSocket failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Create the UDP socket
    pTestObject->sUDPSocket = CreateSocket(SOCK_DGRAM, sin_port + 1);
    if (INVALID_SOCKET == pTestObject->sUDPSocket) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "sUDPSocket failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Create the TCP socket
    pTestObject->sTCPSocket = CreateSocket(SOCK_STREAM, sin_port + 1);
    if (INVALID_SOCKET == pTestObject->sTCPSocket) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "sTCPSocket failed - ec: %u", iLastError);

        goto FunctionExit;
    }

FunctionExit:
    if (ERROR_SUCCESS != iLastError) {
        SGClose(pTestObject);
        pTestObject = NULL;
    }

    if (ERROR_SUCCESS != iLastError) {
        SetLastError(iLastError);
    }

    return pTestObject;
}



PTEST_OBJECT
SGConnect(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Connects to the SG Data Validation Service

Arguments:

  hLog - Handle to the xLog log object

Return Value:

  SOCKET - Socket descriptor

------------------------------------------------------------------------------*/
{
    // iLastError is the last error code
    int                   iLastError = ERROR_SUCCESS;
    // hResult is the return code of a function
    HRESULT               hResult;
    // iResult is the return code of a function
    int                   iResult;

    // pTestObject is the pointer to the test object
    PTEST_OBJECT          pTestObject = NULL;

    // OnlineServiceInfo is the online service info
    XONLINE_SERVICE_INFO  OnlineServiceInfo;
    // SGEnumName is the host name of the sg enum service
    SOCKADDR_IN           SGEnumName;

    // SessionMessage is the session message
    SGDATA_MESSAGE        SGDataMessage;



    // Start the variation
    xStartVariation(hLog, "SG Data Connect");

    // Create the test object
    pTestObject = SGOpen(hLog);
    if (NULL == pTestObject) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "pTestObject failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Get the service info
    hResult = XOnlineGetServiceInfo(XONLINE_SG_DATA_ENUM_SERVICE, &OnlineServiceInfo);
    if (FAILED(hResult)) {
        iLastError = HRESULT_CODE(hResult);
        xLog(hLog, XLL_FAIL, "XOnlineGetServiceInfo failed - hResult: 0x%08x - ec: %u", hResult, iLastError);

        goto FunctionExit;
    }

    // Set the enum name
    ZeroMemory(&SGEnumName, sizeof(SGEnumName));
    SGEnumName.sin_family = AF_INET;
    SGEnumName.sin_addr.s_addr = OnlineServiceInfo.serviceIP.s_addr;
    SGEnumName.sin_port = htons(OnlineServiceInfo.wServicePort);

    // Connect the session socket
    iResult = connect(pTestObject->sSessionSocket, (SOCKADDR *) &SGEnumName, sizeof(SGEnumName));
    if (SOCKET_ERROR == iResult) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "connect failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Set the session message
    ZeroMemory(&SGDataMessage, sizeof(SGDataMessage));
    SGDataMessage.dwMessageId = SGDATA_ENUM_MSG;

    // Send the message
    iResult = send(pTestObject->sSessionSocket, (char *) &SGDataMessage, sizeof(SGDataMessage), 0);
    if (SOCKET_ERROR == iResult) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "send failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Receive the reply
    iResult = recv(pTestObject->sSessionSocket, (char *) &SGDataMessage, sizeof(SGDataMessage), 0);
    if (SOCKET_ERROR == iResult) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "recv failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Check the reply
    if (SGDATA_ENUM_REPLY != SGDataMessage.dwMessageId) {
        iLastError = SGDataMessage.dwErrorCode;
        xLog(hLog, XLL_FAIL, "Enum failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    xLog(hLog, XLL_PASS, "Enum passed");

    // Get the service info
    hResult = XOnlineGetServiceInfo(XONLINE_SG_DATA_TEST_SERVICE, &OnlineServiceInfo);
    if (FAILED(hResult)) {
        iLastError = HRESULT_CODE(hResult);
        xLog(hLog, XLL_FAIL, "XOnlineGetServiceInfo failed - hResult: 0x%08x - ec: %u", hResult, iLastError);

        goto FunctionExit;
    }

    // Set the enum name
    ZeroMemory(&SGEnumName, sizeof(SGEnumName));
    SGEnumName.sin_family = AF_INET;
    SGEnumName.sin_addr.s_addr = OnlineServiceInfo.serviceIP.s_addr;
    SGEnumName.sin_port = htons(OnlineServiceInfo.wServicePort);

    // Connect the UDP socket
    iResult = connect(pTestObject->sUDPSocket, (SOCKADDR *) &SGEnumName, sizeof(SGEnumName));
    if (SOCKET_ERROR == iResult) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "connect failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Connect the TCP socket
    iResult = connect(pTestObject->sTCPSocket, (SOCKADDR *) &SGEnumName, sizeof(SGEnumName));
    if (SOCKET_ERROR == iResult) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "connect failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Set the session message
    ZeroMemory(&SGDataMessage, sizeof(SGDataMessage));
    SGDataMessage.dwMessageId = SGDATA_CONNECT_MSG;

    // Send the message
    iResult = send(pTestObject->sSessionSocket, (char *) &SGDataMessage, sizeof(SGDataMessage), 0);
    if (SOCKET_ERROR == iResult) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "send failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Receive the reply
    iResult = recv(pTestObject->sSessionSocket, (char *) &SGDataMessage, sizeof(SGDataMessage), 0);
    if (SOCKET_ERROR == iResult) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "recv failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Check the reply
    if (SGDATA_CONNECT_SUCCESS != SGDataMessage.dwMessageId) {
        iLastError = SGDataMessage.dwErrorCode;
        xLog(hLog, XLL_FAIL, "Connect failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    xLog(hLog, XLL_PASS, "Connect passed");

FunctionExit:
    if (ERROR_SUCCESS != iLastError) {
        SGClose(pTestObject);
        pTestObject = NULL;
    }

    // End the variation
    xEndVariation(hLog);

    if (ERROR_SUCCESS != iLastError) {
        SetLastError(iLastError);
    }

    return pTestObject;
}



VOID
SGDisconnect(
    IN HANDLE        hLog,
    IN PTEST_OBJECT  pTestObject
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Disconnects from the SG Data Validation Service

Arguments:

  hLog - Handle to the xLog log object,
  pTestObject - Pointer to the test object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // iLastError is the last error code
    int             iLastError = ERROR_SUCCESS;
    // iResult is the return code of a function
    int             iResult;

    // SGDataMessage is the session message
    SGDATA_MESSAGE  SGDataMessage;



    // Start the variation
    xStartVariation(hLog, "SG Data Disconnect");

    // Set the session message
    ZeroMemory(&SGDataMessage, sizeof(SGDataMessage));
    SGDataMessage.dwMessageId = SGDATA_DISCONNECT_MSG;

    // Send the message
    iResult = send(pTestObject->sSessionSocket, (char *) &SGDataMessage, sizeof(SGDataMessage), 0);
    if (SOCKET_ERROR == iResult) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "send failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Receive the reply
    iResult = recv(pTestObject->sSessionSocket, (char *) &SGDataMessage, sizeof(SGDataMessage), 0);
    if (SOCKET_ERROR == iResult) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "recv failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    xLog(hLog, XLL_PASS, "Disconnect passed");

FunctionExit:
    // Close the test object
    SGClose(pTestObject);

    // End the variation
    xEndVariation(hLog);

    if (ERROR_SUCCESS != iLastError) {
        SetLastError(iLastError);
    }
}



BOOL
SGTest(
    IN HANDLE        hLog,
    IN PTEST_OBJECT  pTestObject,
    IN int           type,
    IN int           len
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests SG Data Validation

Arguments:

  hLog - Handle to the xLog log object
  pTestObject - Pointer to the test object
  type - Specifies the type of socket (SOCK_DGRAM or SOCK_STREAM)
  len - Specifies the data length

Return Value:

  BOOL:
    If the function succeeds, the return value is a non-zero
    If the function fails, the return value is 0.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // iLastError is the last error code
    int     iLastError = ERROR_SUCCESS;
    // iResult is the return code of a function
    int     iResult;

    // sTestSocket is the test socket
    SOCKET  sTestSocket = INVALID_SOCKET;

    // Data Buffers
    CHAR    SendMessage[1500];
    CHAR    SendMaskMessage[1500];
    CHAR    RecvMessage[1500];
    CHAR    RecvMaskMessage[1500];


    // szVariationName is the variation name
    CHAR    szVariationName[LOG_STRING_LENGTH];



    // Set the variation name
    sprintf(szVariationName, "SG Test %s %d", (SOCK_DGRAM == type) ? "UDP" : "TCP", len);
    xStartVariation(hLog, szVariationName);

    // Get the test socket
    if (SOCK_DGRAM == type) {
        sTestSocket = pTestObject->sUDPSocket;
    }
    else {
        sTestSocket = pTestObject->sTCPSocket;
    }

    // Initialize data
    ZeroMemory(SendMessage, sizeof(SendMessage));
    ZeroMemory(SendMaskMessage, sizeof(SendMaskMessage));
    ZeroMemory(RecvMessage, sizeof(RecvMessage));
    ZeroMemory(RecvMaskMessage, sizeof(RecvMaskMessage));

    // Generate data
    XNetRandom((BYTE *) SendMessage, len);

    CopyMemory(SendMaskMessage, SendMessage, len);
    DataMask((BYTE *) SendMaskMessage, len);

    // Send data
    iResult = send(sTestSocket, SendMessage, len, 0);
    if (SOCKET_ERROR == iResult) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "send failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    // Recv data
    iResult = recv(sTestSocket, RecvMessage, sizeof(RecvMessage), 0);
    if (SOCKET_ERROR == iResult) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "recv failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    if (len != iResult) {
        iLastError = HRESULT_CODE(E_UNEXPECTED);
        xLog(hLog, XLL_FAIL, "Data len diff - EXPECTED: %u; RECEIVED: %u", len, iResult);
    }

    if (0 != memcmp(SendMessage, RecvMessage, len)) {
        iLastError = HRESULT_CODE(E_UNEXPECTED);
        xLog(hLog, XLL_FAIL, "Data diff");
    }

    // Recv data mask
    iResult = recv(sTestSocket, RecvMaskMessage, sizeof(RecvMaskMessage), 0);
    if (SOCKET_ERROR == iResult) {
        iLastError = GetLastError();
        xLog(hLog, XLL_FAIL, "recv mask failed - ec: %u", iLastError);

        goto FunctionExit;
    }

    if (len != iResult) {
        iLastError = HRESULT_CODE(E_UNEXPECTED);
        xLog(hLog, XLL_FAIL, "Data Mask len diff - EXPECTED: %u; RECEIVED: %u", len, iResult);
    }

    if (0 != memcmp(SendMaskMessage, RecvMaskMessage, len)) {
        iLastError = HRESULT_CODE(E_UNEXPECTED);
        xLog(hLog, XLL_FAIL, "Data Mask diff");
    }

    if (ERROR_SUCCESS == iLastError) {
        // Test succeeded
        xLog(hLog, XLL_PASS, "Test passed");
    }

FunctionExit:
    // End the variation
    xEndVariation(hLog);

    if (ERROR_SUCCESS != iLastError) {
        SetLastError(iLastError);
    }

    return (ERROR_SUCCESS == iLastError);
}



BOOL
SGDataTest(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Tests SG Data Validation

Arguments:

  hLog - Handle to the xLog log object

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // iLastError is the last error code
    int                 iLastError = ERROR_SUCCESS;

    // uXOnlineRef is the reference count of xonline
    ULONG               uXOnlineRef = 0;
    // OnlineLogonUsers is the array of logon online user accounts
    XONLINE_USER        OnlineUsers[XONLINE_MAX_LOGON_USERS];
    // dwNumUsers is the number of online users
    DWORD               dwNumUsers = XONLINE_MAX_LOGON_USERS;
    // OnlineLogonHandle is the pointer to the XOnlineLogon task handle
    XONLINETASK_HANDLE  OnlineLogonHandle = NULL;

    // pTestObject is the pointer to the test object
    PTEST_OBJECT        pTestObject = NULL;



    // Set the component and subcomponent
    xSetComponent(hLog, "Online", "Security Gateway");

    // Set the function name
    xSetFunctionName(hLog, "SG Data");

    // Start the variation
    xStartVariation(hLog, "SG Data Test");

    // Initialize the online subsystem
    uXOnlineRef = AddRefNet(hLog);
    if (0 == uXOnlineRef) {
        iLastError = GetLastError();

        goto FunctionExit;
    }

    // Get the user accounts
    if (FALSE == SGUsers(hLog, OnlineUsers, &dwNumUsers)) {
        iLastError = GetLastError();

        goto FunctionExit;
    }

    // Logon
    OnlineLogonHandle = SGLogon(hLog, OnlineUsers, dwNumUsers);
    if (NULL == OnlineLogonHandle) {
        iLastError = GetLastError();

        goto FunctionExit;
    }

    // Connect session
    pTestObject = SGConnect(hLog);
    if (NULL == pTestObject) {
        iLastError = GetLastError();

        goto FunctionExit;
    }

    // Run test
    if (FALSE == SGTest(hLog, pTestObject, SOCK_DGRAM, BUFFER_10_LEN)) {
        iLastError = GetLastError();

        goto FunctionExit;
    }

    if (FALSE == SGTest(hLog, pTestObject, SOCK_DGRAM, BUFFER_UDP_LEN)) {
        iLastError = GetLastError();

        goto FunctionExit;
    }

    if (FALSE == SGTest(hLog, pTestObject, SOCK_STREAM, BUFFER_10_LEN)) {
        iLastError = GetLastError();

        goto FunctionExit;
    }

    if (FALSE == SGTest(hLog, pTestObject, SOCK_STREAM, BUFFER_TCP_LEN)) {
        iLastError = GetLastError();

        goto FunctionExit;
    }

FunctionExit:
    // Disconnect session
    if (NULL != pTestObject) {
        SGDisconnect(hLog, pTestObject);
    }

    // Close the XOnlineLogon task handle
    if (NULL != OnlineLogonHandle) {
        XOnlineTaskClose(OnlineLogonHandle);
    }

    // Terminate the online subsystem
    if (0 != uXOnlineRef) {
        ReleaseNet();
    }

    if (ERROR_SUCCESS == iLastError) {
        xLog(hLog, XLL_PASS, "SG Data Test passed");
    }
    else {
        xLog(hLog, XLL_FAIL, "SG Data Test failed - ec: %u", iLastError);
    }

    // End the variation
    xEndVariation(hLog);

    return (ERROR_SUCCESS == iLastError);
}

} // namespace SGDataNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\client\client.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.h

Abstract:

  This module contains the definitions for client.c

Author:

  Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#pragma once



namespace XNetStreamNamespace {



// Function prototypes

VOID
StreamTest(
    IN HANDLE  hLog
);

} // namespace XNetStreamNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\client\client.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.c

Abstract:

  Entry points for xnetstream.dll

Author:

  Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetStreamNamespace;

namespace XNetStreamNamespace {

VOID
WINAPI
StartTest(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Test entry point

Arguments:

  hLog - handle to the xLog log object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Run the test
    StreamTest(hLog);
}



VOID
WINAPI
EndTest(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Test exit point

Return Value:

  None

------------------------------------------------------------------------------*/
{
}

} // namespace XNetStreamNamespace



#ifdef __cplusplus
extern "C" {
#endif

// Export table for harness

#pragma data_seg(EXPORT_SECTION_NAME)
DECLARE_EXPORT_DIRECTORY(xnetstream)
#pragma data_seg()

BEGIN_EXPORT_TABLE(xnetstream)
    EXPORT_TABLE_ENTRY("StartTest", StartTest)
    EXPORT_TABLE_ENTRY("EndTest", EndTest)
END_EXPORT_TABLE(xnetstream)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\client\main.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  main.c

Abstract:

  This module streams data between client and server - executable

Author:

  Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetStreamNamespace;

void __cdecl main()
{
    // hLog is the handle to the xLog object
    HANDLE  hLog = INVALID_HANDLE_VALUE;



    // Create the xLog object
    hLog = xCreateLog(L"T:\\xnetstream.log", NULL, INVALID_SOCKET, XLL_LOGDEFAULT, XLO_DEBUG | XLO_CONFIG | XLO_STATE | XLO_REFRESH);

    // Run the test
    StartTest(hLog);
    EndTest();

    // Close the xLog object
    xCloseLog(hLog);

    // Launch the dashboard
    XLaunchNewImage(NULL, NULL);

    __asm int 3;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\server\sgdatap.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  sgdatap.h

Abstract:

  This module defines private data for sgdata_nt.exe

Author:

  Steven Kehrli (steveke) 24-Jan-2002

------------------------------------------------------------------------------*/

#pragma once



namespace SGDataNamespace {



// Ports

#define PORT_SESSION         65473
#define PORT_UDP             65474
#define PORT_TCP             65474



// Values

#define TIMER_TIMEOUT        15000       // 15 Seconds
#define ACTIVITY_TIMEOUT     1200000000  // 2 Minutes

#define SGDATA_CLASS_NAME    L"SGDataClassName"

#define SGDATA_LOGFILE_NAME  L"sgdata.csv"



// Structures

typedef struct _TEST_OBJECT {
    CRITICAL_SECTION     *pcs;                       // Pointer to the object to synchronize access to the test objects
    HWND                 hWnd;                       // Handle to the parent window
    HANDLE               hMemObject;                 // Handle to the memory object
    HANDLE               hFile;                      // Handle to the log file
    WCHAR                RemoteName[22];             // Specifies the remote name
    SOCKADDR_IN          Session_remotename;         // Specifies the session remote name
    SOCKADDR_IN          Test_remotename;            // Specifies the test remote name
    int                  type;                       // Specifies the type of socket
    SOCKET               sSocket;                    // Specifies the socket descriptor
    u_short              sin_port;                   // Specifies the port
    DWORD                dwUDPBytes;                 // Specifies the number of UDP bytes
    DWORD                dwTCPBytes;                 // Specifies the number of TCP bytes
    SYSTEMTIME           FirstActivityTime;          // Specifies the first time of activity
    SYSTEMTIME           LastActivityTime;           // Specifies the last time of activity
    HANDLE               hStopEvent;                 // Handle to the stop event
    HANDLE               hRecvEvent;                 // Handle to the recv event
    HANDLE               hTestThread;                // Handle to the test thread
    struct _TEST_OBJECT  *pPrevTestObject;           // Pointer to the prev test object
    struct _TEST_OBJECT  *pNextTestObject;           // Pointer to the next test object
} TEST_OBJECT, *PTEST_OBJECT;



typedef struct _SESSION_OBJECT {
    CRITICAL_SECTION     *pcs;                       // Pointer to the object to synchronize access to the test objects
    HWND                 hWnd;                       // Handle to the parent window
    HANDLE               hMemObject;                 // Handle to the memory object
    HANDLE               hFile;                      // Handle to the log file
    SOCKET               sSessionSocket;             // Specifies the session socket descriptor
    u_short              sin_SessionPort;            // Specifies the session port
    SOCKET               sUDPSocket;                 // Specifies the UDP socket descriptor
    u_short              sin_UDPPort;                // Specifies the UDP port
    SOCKET               sTCPSocket;                 // Specifies the TCP socket descriptor
    u_short              sin_TCPPort;                // Specifies the TCP port
    HANDLE               hStopEvent;                 // Handle to the stop event
    HANDLE               hRecvEvent;                 // Handle to the recv event
    HANDLE               hSessionThread;             // Handle to the session thread
    PTEST_OBJECT         pTestObject;                // Pointer to the list of test objects
} SESSION_OBJECT, *PSESSION_OBJECT;



// Dialog messages

#define UM_DIALOG_INITIALIZE  (WM_USER + 1)
#define UM_UPDATE_TEST        (WM_USER + 10)
#define UM_DELETE_TEST        (WM_USER + 11)



// The following enum is used to identify the column indexes

enum eColumnIndex {
    eColumnRemoteName = 0,
    eColumnUDPBytes,
    eColumnTCPBytes,
    eColumnFirstActivityTime,
    eColumnLastActivityTime,
    eColumnIllegal
};



// The following enum is used to identify the sort method

enum eSortMethod {
    eSortRemoteNameAscending = 0,
    eSortRemoteNameDescending,
    eSortUDPBytesAscending,
    eSortUDPBytesDescending,
    eSortTCPBytesAscending,
    eSortTCPBytesDescending,
    eSortFirstActivityTimeAscending,
    eSortFirstActivityTimeDescending,
    eSortLastActivityTimeAscending,
    eSortLastActivityTimeDescending,
    eSortIllegal
};

} // namespace SGDataNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\server\sgdata.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  sgdata.c

Abstract:

  This module validates the data through a security gateway

Author:

  Steven Kehrli (steveke) 24-Jan-2002

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace SGDataNamespace;

namespace SGDataNamespace {

SOCKET
CreateSocket(
    IN int     type,
    IN u_short sin_port
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Creates and binds a socket

Arguments:

  type - Specifies the type of socket (SOCK_DGRAM or SOCK_STREAM)
  sin_port - Specifies the bind port of socket

Return Value:

  SOCKET:
    If the function succeeds, the return value is a socket descriptor
    If the function fails, the return value is INVALID_SOCKET.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // sSocket is the new socket
    SOCKET       sSocket = INVALID_SOCKET;
    // iTimeout is the timeout value of the socket
    int          iTimeout;
    // localname is the local address
    SOCKADDR_IN  localname;
    // dwErrorCode is the last error code
    DWORD        dwErrorCode = ERROR_SUCCESS;



    // Create the socket
    sSocket = socket(AF_INET, type, 0);
    if (INVALID_SOCKET == sSocket) {
        // Get the last error code
        dwErrorCode = WSAGetLastError();

        goto FunctionExit;
    }

    // Set the socket timeouts
    iTimeout = 15000;
    if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

    iTimeout = 15000;
    if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

    // Setup the local address
    ZeroMemory(&localname, sizeof(localname));
    localname.sin_family = AF_INET;
    localname.sin_port = htons(sin_port);

    // Bind the socket
    if (SOCKET_ERROR == bind(sSocket, (SOCKADDR *) &localname, sizeof(localname))) {
        // Get the last error code
        dwErrorCode = WSAGetLastError();

        goto FunctionExit;
    }

FunctionExit:
    if (ERROR_SUCCESS != dwErrorCode) {
        if (INVALID_SOCKET != sSocket) {
            closesocket(sSocket);
            sSocket = INVALID_SOCKET;
        }

        SetLastError(dwErrorCode);
    }

    return sSocket;
}



DWORD
TestThread(
    IN LPVOID  lpv
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Thread to handle the test logic

Arguments:

  lpv - Pointer to the TEST_OBJECT

------------------------------------------------------------------------------*/
{
    // pTestObject is a pointer to the test object
    PTEST_OBJECT   pTestObject = (PTEST_OBJECT) lpv;
    // pUpdateTestObject is a pointer to the update test object
    PTEST_OBJECT   pUpdateTestObject;
    // SystemTime is the system time
    SYSTEMTIME     SystemTime;

    // hEvents is an array of events
    HANDLE         hEvents[2] = { pTestObject->hStopEvent, pTestObject->hRecvEvent };

    // RecvMessage is the recv message
    char           RecvMessage[1500];
    // MaskMessage is the mask message
    char           MaskMessage[1500];

    // WSAOverlapped is the overlapped I/O structure
    WSAOVERLAPPED  WSAOverlapped;
    // WSABuffer is the WSABUF structures
    WSABUF         WSABuffer;
    // fromname is the source address
    SOCKADDR_IN    fromname;
    // fromnamelen is the size of the source address
    int            fromnamelen;
    // dwBytes is the number of bytes received on the socket
    DWORD          dwBytes;
    // dwFlags is a bitmask of MSG_ values
    DWORD          dwFlags;
    // dwWaitResult is the result of the wait on the overlapped I/O event
    DWORD          dwWaitResult;
    // dwErrorCode is the last error code
    DWORD          dwErrorCode;



    do {
        // Setup the WSABUF structure
        ZeroMemory(RecvMessage, sizeof(RecvMessage));
        ZeroMemory(MaskMessage, sizeof(MaskMessage));
        WSABuffer.len = sizeof(RecvMessage);
        WSABuffer.buf = RecvMessage;

        // Setup the flags
        dwBytes = 0;
        dwFlags = 0;

        // Setup the address
        ZeroMemory(&fromname, sizeof(fromname));
        fromnamelen = sizeof(fromname);

        // Setup the overlapped I/O
        ZeroMemory(&WSAOverlapped, sizeof(WSAOverlapped));
        WSAOverlapped.hEvent = pTestObject->hRecvEvent;

        // Setup the result
        dwWaitResult = WAIT_FAILED;
        dwErrorCode = ERROR_SUCCESS;

        // Post the WSARecv request
        if (SOCKET_ERROR == WSARecvFrom(pTestObject->sSocket, &WSABuffer, 1, &dwBytes, &dwFlags, (SOCKADDR *) &fromname, &fromnamelen, &WSAOverlapped, NULL)) {
            if (WSA_IO_PENDING != WSAGetLastError()) {
                dwErrorCode = WSAGetLastError();

                continue;
            }

            // Wait for the overlapped I/O request to complete
            dwWaitResult = WaitForMultipleObjects(sizeof(hEvents) / sizeof(hEvents[0]), hEvents, FALSE, INFINITE);

            if ((WAIT_OBJECT_0 + 1) == dwWaitResult) {
                // Get the status of the overlapped I/O request
                if (FALSE == WSAGetOverlappedResult(pTestObject->sSocket, &WSAOverlapped, &dwBytes, FALSE, &dwFlags)) {
                    dwErrorCode = WSAGetLastError();

                    dwWaitResult = WAIT_FAILED;
                }
            }
            else if (WAIT_OBJECT_0 != dwWaitResult) {
                dwErrorCode = GetLastError();
            }

            if (ERROR_SUCCESS != dwErrorCode) {
                // Cancel the pending IO request
                CancelIo((HANDLE) pTestObject->sSocket);
            }
        }
        else {
            // WSARecv request completed immediately
            dwWaitResult = (WAIT_OBJECT_0 + 1);
        }

        if ((WAIT_OBJECT_0 + 1) == dwWaitResult) {
            // Update the test object
            EnterCriticalSection(pTestObject->pcs);

            if (SOCK_STREAM != pTestObject->type) {
                // Find the test object
                pUpdateTestObject = pTestObject->pPrevTestObject;

                while ((NULL != pUpdateTestObject) && (0 != memcmp(&pUpdateTestObject->Test_remotename, &fromname, sizeof(pUpdateTestObject->Test_remotename)))) {
                    pUpdateTestObject = pUpdateTestObject->pPrevTestObject;
                }

                if (NULL != pUpdateTestObject) {
                    // Update the byte count
                    pUpdateTestObject->dwUDPBytes += dwBytes;
                }
            }
            else {
                // Find the test object
                pUpdateTestObject = pTestObject;

                // Update the byte count
                pUpdateTestObject->dwTCPBytes += dwBytes;
            }

            if (NULL != pUpdateTestObject) {
                // Update the time
                GetSystemTime(&SystemTime);
                SystemTimeToTzSpecificLocalTime(NULL, &SystemTime, &pUpdateTestObject->LastActivityTime);

                // Update the test object
                SendMessage(pTestObject->hWnd, UM_UPDATE_TEST, 0, (LPARAM) pUpdateTestObject);

                // Write the activity to the log file
                LogActivity(pTestObject->hFile, &pUpdateTestObject->LastActivityTime, pUpdateTestObject->RemoteName, (SOCK_DGRAM == pTestObject->type) ? LOG_UDP_DATA : LOG_TCP_DATA, dwBytes);
            }

            LeaveCriticalSection(pTestObject->pcs);

            // Copy the message to the mask buffer
            CopyMemory(MaskMessage, RecvMessage, dwBytes);

            // Mask the message
            DataMask((BYTE *) MaskMessage, dwBytes);

            // Echo the message
            sendto(pTestObject->sSocket, RecvMessage, dwBytes, 0, (SOCKADDR *) &fromname, fromnamelen);
            sendto(pTestObject->sSocket, MaskMessage, dwBytes, 0, (SOCKADDR *) &fromname, fromnamelen);
        }
    } while (WAIT_OBJECT_0 != dwWaitResult);

    return 0;
}



VOID
CloseTest(
    IN PTEST_OBJECT  pTestObject
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Closes a test object

Arguments:

  pTestObject - Pointer to the test object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // hMemObject is a handle to the memory object
    HANDLE  hMemObject = pTestObject->hMemObject;



    // Signal the stop event
    if (NULL != pTestObject->hStopEvent) {
        SetEvent(pTestObject->hStopEvent);
    }

    if (NULL != pTestObject->hTestThread) {
        // Wait for the test thread to exit
        WaitForSingleObject(pTestObject->hTestThread, INFINITE);

        // Close the thread handle
        CloseHandle(pTestObject->hTestThread);
    }

    // Close the recv event
    if (NULL != pTestObject->hRecvEvent) {
        CloseHandle(pTestObject->hRecvEvent);
    }

    // Close the stop event
    if (NULL != pTestObject->hStopEvent) {
        CloseHandle(pTestObject->hStopEvent);
    }

    // Close the socket
    if ((SOCK_STREAM == pTestObject->type) && (INVALID_SOCKET != pTestObject->sSocket)) {
        shutdown(pTestObject->sSocket, SD_BOTH);
        closesocket(pTestObject->sSocket);
    }

    // Free the test object
    xMemFree(hMemObject, pTestObject);
}



PTEST_OBJECT
CreateTest(
    IN CRITICAL_SECTION  *pcs,
    IN HWND              hWnd,
    IN HANDLE            hMemObject,
    IN HANDLE            hFile,
    IN SOCKADDR_IN       *remotename,
    IN int               type,
    IN SOCKET            sSocket,
    IN u_short           sin_port
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Create a session

Arguments:

  pcs - Pointer to the object to synchronize access to the test objects
  hWnd - Handle to the parent window
  hMemObject - Handle to the memory object
  hFile - Handle to the log file
  remotename - Specifies the session remote name
  type - Specifies the type of socket (SOCK_DGRAM or SOCK_STREAM)
  sSocket - Specifies the socket descriptor
  sin_port - Specifies the port

Return Value:

  PTEST_OBJECT:
    If the function succeeds, the return value is a pointer to the test object.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pTestObject is a pointer to the test object
    PTEST_OBJECT  pTestObject = NULL;
    // readfds is the read socket set
    fd_set        readfds;
    // timeout it the select timeout
    timeval       timeout = { 0, 0 };
    // remotenamelen is the remote name len
    int           remotenamelen;
    // SystemTime is the current system time
    SYSTEMTIME    SystemTime;
    // dwErrorCode is the last error code
    DWORD         dwErrorCode = ERROR_SUCCESS;



    // Create the test object
    pTestObject = (PTEST_OBJECT) xMemAlloc(hMemObject, sizeof(TEST_OBJECT));
    if (NULL == pTestObject) {
        // Get the last error
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

    // Set the session object
    pTestObject->pcs = pcs;
    pTestObject->hWnd = hWnd;
    pTestObject->hMemObject = hMemObject;
    pTestObject->hFile = hFile;
    pTestObject->type = type;
    pTestObject->sSocket = INVALID_SOCKET;
    pTestObject->sin_port = sin_port;

    // Get the session remote name
    if (NULL != remotename) {
        CopyMemory(&pTestObject->Session_remotename, remotename, sizeof(pTestObject->Session_remotename));
    }

    // Get the socket
    if (SOCK_STREAM == type) {
        // Check for pending connection
        FD_ZERO(&readfds);
        FD_SET(sSocket, &readfds);

        select(0, &readfds, NULL, NULL, &timeout);

        if (0 == FD_ISSET(sSocket, &readfds)) {
            // Get the last error
            dwErrorCode = WSAEWOULDBLOCK;

            goto FunctionExit;
        }

        // Accept pending connection
        remotenamelen = sizeof(pTestObject->Test_remotename);
        pTestObject->sSocket = accept(sSocket, (SOCKADDR *) &pTestObject->Test_remotename, &remotenamelen);
        if (INVALID_SOCKET == pTestObject->sSocket) {
            // Get the last error
            dwErrorCode = WSAGetLastError();

            goto FunctionExit;
        }

        wsprintf(pTestObject->RemoteName, L"%d.%d.%d.%d:%u", pTestObject->Test_remotename.sin_addr.S_un.S_un_b.s_b1, pTestObject->Test_remotename.sin_addr.S_un.S_un_b.s_b2, pTestObject->Test_remotename.sin_addr.S_un.S_un_b.s_b3, pTestObject->Test_remotename.sin_addr.S_un.S_un_b.s_b4, ntohs(pTestObject->Test_remotename.sin_port));
    }
    else {
        pTestObject->sSocket = sSocket;
    }

    // Create the stop event
    pTestObject->hStopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == pTestObject->hStopEvent) {
        // Get the last error
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

    // Create the recv event
    pTestObject->hRecvEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == pTestObject->hRecvEvent) {
        // Get the last error
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

    // Set the times
    GetSystemTime(&SystemTime);
    SystemTimeToTzSpecificLocalTime(NULL, &SystemTime, &pTestObject->FirstActivityTime);
    CopyMemory(&pTestObject->LastActivityTime, &pTestObject->FirstActivityTime, sizeof(pTestObject->LastActivityTime));

    // Create the test thread
    pTestObject->hTestThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) TestThread, pTestObject, 0, NULL);
    if (NULL == pTestObject->hTestThread) {
        // Get the last error
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

FunctionExit:
    if (ERROR_SUCCESS != dwErrorCode) {
        if (NULL != pTestObject) {
            // Close the test object
            CloseTest(pTestObject);
            pTestObject = NULL;
        }

        // Set the last error code
        SetLastError(dwErrorCode);
    }

    return pTestObject;
}



DWORD
SessionThread(
    IN LPVOID  lpv
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Thread to handle the session logic

Arguments:

  lpv - Pointer to the SESSION_OBJECT

------------------------------------------------------------------------------*/
{
    // pSessionObject is a pointer to the session object
    PSESSION_OBJECT  pSessionObject = (PSESSION_OBJECT) lpv;
    // pTestObject is a pointer to the test object
    PTEST_OBJECT     pTestObject;

    // hEvents is an array of events
    HANDLE           hEvents[2] = { pSessionObject->hStopEvent, pSessionObject->hRecvEvent };

    // SGDataMessage is the session message
    SGDATA_MESSAGE   SGDataMessage;

    // WSAOverlapped is the overlapped I/O structure
    WSAOVERLAPPED    WSAOverlapped;
    // WSABuffer is the WSABUF structures
    WSABUF           WSABuffer;
    // fromname is the source address
    SOCKADDR_IN      fromname;
    // fromnamelen is the size of the source address
    int              fromnamelen;
    // dwBytes is the number of bytes received on the socket
    DWORD            dwBytes;
    // dwFlags is a bitmask of MSG_ values
    DWORD            dwFlags;
    // dwWaitResult is the result of the wait on the overlapped I/O event
    DWORD            dwWaitResult;
    // dwErrorCode is the last error code
    DWORD            dwErrorCode;



    do {
        // Setup the WSABUF structure
        ZeroMemory(&SGDataMessage, sizeof(SGDataMessage));
        WSABuffer.len = sizeof(SGDataMessage);
        WSABuffer.buf = (char *) &SGDataMessage;

        // Setup the flags
        dwBytes = 0;
        dwFlags = 0;

        // Setup the address
        ZeroMemory(&fromname, sizeof(fromname));
        fromnamelen = sizeof(fromname);

        // Setup the overlapped I/O
        ZeroMemory(&WSAOverlapped, sizeof(WSAOverlapped));
        WSAOverlapped.hEvent = pSessionObject->hRecvEvent;

        // Setup the result
        dwWaitResult = WAIT_FAILED;
        dwErrorCode = ERROR_SUCCESS;

        // Post the WSARecv request
        if (SOCKET_ERROR == WSARecvFrom(pSessionObject->sSessionSocket, &WSABuffer, 1, &dwBytes, &dwFlags, (SOCKADDR *) &fromname, &fromnamelen, &WSAOverlapped, NULL)) {
            if (WSA_IO_PENDING != WSAGetLastError()) {
                dwErrorCode = WSAGetLastError();

                continue;
            }

            // Wait for the overlapped I/O request to complete
            dwWaitResult = WaitForMultipleObjects(sizeof(hEvents) / sizeof(hEvents[0]), hEvents, FALSE, INFINITE);

            if ((WAIT_OBJECT_0 + 1) == dwWaitResult) {
                // Get the status of the overlapped I/O request
                if (FALSE == WSAGetOverlappedResult(pSessionObject->sSessionSocket, &WSAOverlapped, &dwBytes, FALSE, &dwFlags)) {
                    dwErrorCode = WSAGetLastError();

                    dwWaitResult = WAIT_FAILED;
                }
            }
            else if (WAIT_OBJECT_0 != dwWaitResult) {
                dwErrorCode = GetLastError();
            }

            if (ERROR_SUCCESS != dwErrorCode) {
                // Cancel the pending IO request
                CancelIo((HANDLE) pSessionObject->sSessionSocket);
            }
        }
        else {
            // WSARecv request completed immediately
            dwWaitResult = (WAIT_OBJECT_0 + 1);
        }

        if ((WAIT_OBJECT_0 + 1) == dwWaitResult) {
            if (SGDATA_ENUM_MSG == SGDataMessage.dwMessageId) {
                // Send the reply
                ZeroMemory(&SGDataMessage, sizeof(SGDataMessage));
                SGDataMessage.dwMessageId = SGDATA_ENUM_REPLY;
                sendto(pSessionObject->sSessionSocket, (char *) &SGDataMessage, sizeof(SGDataMessage), 0, (SOCKADDR *) &fromname, fromnamelen);
            }
            else if (SGDATA_CONNECT_MSG == SGDataMessage.dwMessageId) {
                // Create the test object
                EnterCriticalSection(pSessionObject->pcs);

                ZeroMemory(&SGDataMessage, sizeof(SGDataMessage));

                pTestObject = CreateTest(pSessionObject->pcs, pSessionObject->hWnd, pSessionObject->hMemObject, pSessionObject->hFile, &fromname, SOCK_STREAM, pSessionObject->sTCPSocket, pSessionObject->sin_TCPPort);

                // Add the test object to the list of test objects
                if (NULL != pTestObject) {
                    pTestObject->pNextTestObject = pSessionObject->pTestObject;
                    pSessionObject->pTestObject->pPrevTestObject = pTestObject;
                    pSessionObject->pTestObject = pTestObject;

                    // Write the activity to the log file
                    LogActivity(pTestObject->hFile, &pTestObject->LastActivityTime, pTestObject->RemoteName, LOG_CONNECTED, 0);

                    // Update the test object
                    SendMessage(pSessionObject->hWnd, UM_UPDATE_TEST, 0, (LPARAM) pTestObject);

                    SGDataMessage.dwMessageId = SGDATA_CONNECT_SUCCESS;
                    SGDataMessage.dwErrorCode = ERROR_SUCCESS;
                }
                else {
                    SGDataMessage.dwMessageId = SGDATA_CONNECT_FAILED;
                    SGDataMessage.dwErrorCode = GetLastError();
                }

                LeaveCriticalSection(pSessionObject->pcs);

                // Send the reply
                sendto(pSessionObject->sSessionSocket, (char *) &SGDataMessage, sizeof(SGDataMessage), 0, (SOCKADDR *) &fromname, fromnamelen);
            }
            else if (SGDATA_DISCONNECT_MSG == SGDataMessage.dwMessageId) {
                // Find the test object
                EnterCriticalSection(pSessionObject->pcs);

                pTestObject = pSessionObject->pTestObject;

                while ((NULL != pTestObject) && (0 != memcmp(&pTestObject->Session_remotename, &fromname, sizeof(pTestObject->Session_remotename)))) {
                    pTestObject = pTestObject->pNextTestObject;
                }

                // Close the test object
                if (NULL != pTestObject) {
                    // Write the activity to the log file
                    LogActivity(pTestObject->hFile, &pTestObject->LastActivityTime, pTestObject->RemoteName, LOG_DISCONNECTED, 0);

                    SendMessage(pSessionObject->hWnd, UM_DELETE_TEST, 0, (LPARAM) pTestObject);
                }

                LeaveCriticalSection(pSessionObject->pcs);

                // Send the reply
                ZeroMemory(&SGDataMessage, sizeof(SGDataMessage));
                SGDataMessage.dwMessageId = SGDATA_DISCONNECT_REPLY;
                sendto(pSessionObject->sSessionSocket, (char *) &SGDataMessage, sizeof(SGDataMessage), 0, (SOCKADDR *) &fromname, fromnamelen);
            }
        }
    } while (WAIT_OBJECT_0 != dwWaitResult);

    return 0;
}



VOID
CloseSession(
    IN PSESSION_OBJECT  pSessionObject
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Closes a session object

Arguments:

  pSessionObject - Pointer to the session object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // hMemObject is a handle to the memory object
    HANDLE        hMemObject = pSessionObject->hMemObject;
    // pTestObject is a pointer to the test object
    PTEST_OBJECT  pTestObject = NULL;



    // Signal the stop event
    if (NULL != pSessionObject->hStopEvent) {
        SetEvent(pSessionObject->hStopEvent);
    }

    if (NULL != pSessionObject->hSessionThread) {
        // Wait for the session thread to exit
        WaitForSingleObject(pSessionObject->hSessionThread, INFINITE);

        // Close the thread handle
        CloseHandle(pSessionObject->hSessionThread);
    }

    // Close the test objects
    EnterCriticalSection(pSessionObject->pcs);

    pTestObject = pSessionObject->pTestObject;
    while (NULL != pTestObject) {
        // Get the next test object
        pSessionObject->pTestObject = pSessionObject->pTestObject->pNextTestObject;

        // Close the test object
        CloseTest(pTestObject);

        // Set the next test object
        pTestObject = pSessionObject->pTestObject;
    }

    LeaveCriticalSection(pSessionObject->pcs);

    // Close the TCP socket
    if (INVALID_SOCKET != pSessionObject->sTCPSocket) {
        shutdown(pSessionObject->sTCPSocket, SD_BOTH);
        closesocket(pSessionObject->sTCPSocket);
    }

    // Close the UDP socket
    if (INVALID_SOCKET != pSessionObject->sUDPSocket) {
        shutdown(pSessionObject->sUDPSocket, SD_BOTH);
        closesocket(pSessionObject->sUDPSocket);
    }

    // Close the session socket
    if (INVALID_SOCKET != pSessionObject->sSessionSocket) {
        shutdown(pSessionObject->sSessionSocket, SD_BOTH);
        closesocket(pSessionObject->sSessionSocket);
    }

    // Close the recv event
    if (NULL != pSessionObject->hRecvEvent) {
        CloseHandle(pSessionObject->hRecvEvent);
    }

    // Close the stop event
    if (NULL != pSessionObject->hStopEvent) {
        CloseHandle(pSessionObject->hStopEvent);
    }

    // Free the session object
    xMemFree(hMemObject, pSessionObject);
}



PSESSION_OBJECT
CreateSession(
    IN CRITICAL_SECTION  *pcs,
    IN HWND              hWnd,
    IN HANDLE            hMemObject,
    IN HANDLE            hFile
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Create a session

Arguments:

  pcs - Pointer to the object to synchronize access to the test objects
  hWnd - Handle to the parent window
  hMemObject - Handle to the memory object
  hFile - Handle to the log file

Return Value:

  PSESSION_OBJECT:
    If the function succeeds, the return value is a pointer to the session object.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pSessionObject is a pointer to the session object
    PSESSION_OBJECT  pSessionObject = NULL;
    // dwErrorCode is the last error code
    DWORD            dwErrorCode = ERROR_SUCCESS;



    // Create the session object
    pSessionObject = (PSESSION_OBJECT) xMemAlloc(hMemObject, sizeof(SESSION_OBJECT));
    if (NULL == pSessionObject) {
        // Get the last error
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

    // Set the session object
    pSessionObject->pcs = pcs;
    pSessionObject->hWnd = hWnd;
    pSessionObject->hMemObject = hMemObject;
    pSessionObject->hFile = hFile;
    pSessionObject->sSessionSocket = INVALID_SOCKET;
    pSessionObject->sin_SessionPort = PORT_SESSION;
    pSessionObject->sSessionSocket = INVALID_SOCKET;
    pSessionObject->sin_UDPPort = PORT_UDP;
    pSessionObject->sSessionSocket = INVALID_SOCKET;
    pSessionObject->sin_TCPPort = PORT_TCP;

    // Create the stop event
    pSessionObject->hStopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == pSessionObject->hStopEvent) {
        // Get the last error
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

    // Create the recv event
    pSessionObject->hRecvEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == pSessionObject->hRecvEvent) {
        // Get the last error
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

    // Create the session socket
    pSessionObject->sSessionSocket = CreateSocket(SOCK_DGRAM, pSessionObject->sin_SessionPort);
    if (INVALID_SOCKET == pSessionObject->sSessionSocket) {
        // Get the last error
        dwErrorCode = WSAGetLastError();

        goto FunctionExit;
    }

    // Create the UDP socket
    pSessionObject->sUDPSocket = CreateSocket(SOCK_DGRAM, pSessionObject->sin_UDPPort);
    if (INVALID_SOCKET == pSessionObject->sUDPSocket) {
        // Get the last error
        dwErrorCode = WSAGetLastError();

        goto FunctionExit;
    }

    // Create the TCP socket
    pSessionObject->sTCPSocket = CreateSocket(SOCK_STREAM, pSessionObject->sin_TCPPort);
    if (INVALID_SOCKET == pSessionObject->sTCPSocket) {
        // Get the last error
        dwErrorCode = WSAGetLastError();

        goto FunctionExit;
    }

    // Listen on the TCP socket
    if (SOCKET_ERROR == listen(pSessionObject->sTCPSocket, 0)) {
        // Get the last error
        dwErrorCode = WSAGetLastError();

        goto FunctionExit;
    }

    // Enter the critical section
    EnterCriticalSection(pSessionObject->pcs);

    // Create the test object
    pSessionObject->pTestObject = CreateTest(pSessionObject->pcs, pSessionObject->hWnd, pSessionObject->hMemObject, pSessionObject->hFile, NULL, SOCK_DGRAM, pSessionObject->sUDPSocket, pSessionObject->sin_UDPPort);
    if (NULL == pSessionObject->pTestObject) {
        // Get the last error
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

    // Leave the critical section
    LeaveCriticalSection(pSessionObject->pcs);

    // Create the session thread
    pSessionObject->hSessionThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) SessionThread, pSessionObject, 0, NULL);
    if (NULL == pSessionObject->hSessionThread) {
        // Get the last error
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

FunctionExit:
    if (ERROR_SUCCESS != dwErrorCode) {
        if (NULL != pSessionObject) {
            // Close the session object
            CloseSession(pSessionObject);
            pSessionObject = NULL;
        }

        // Set the last error code
        SetLastError(dwErrorCode);
    }

    return pSessionObject;
}



int CALLBACK
SortTestObjects(
    LPARAM  lParam1,
    LPARAM  lParam2,
    LPARAM  lParamSort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sorts the test objects in the status list

Arguments:

  lParam1 - Specifies the first lParam (pointer to the first test object)
  lParam2 - Specifies the second lParam (pointer to the second test object)
  lParamSort - Specifies the sort method

Return Value:

  int:
    If the first item should precede the second, negative value (-1)
    If the second item should precede the first, positive value (+1)
    If the two items are equivalent, 0

------------------------------------------------------------------------------*/
{
    // ActivityTime1 is the time of activity for the first test object
    ULARGE_INTEGER  ActivityTime1;
    // LastActivityTime2 is the time of activity for the second test object
    ULARGE_INTEGER  ActivityTime2;



    switch (lParamSort) {
        case eSortRemoteNameAscending:
            return lstrcmp(((PTEST_OBJECT) lParam1)->RemoteName, ((PTEST_OBJECT) lParam2)->RemoteName);
            break;

        case eSortRemoteNameDescending:
            return lstrcmp(((PTEST_OBJECT) lParam2)->RemoteName, ((PTEST_OBJECT) lParam1)->RemoteName);
            break;

        case eSortUDPBytesAscending:
            if (((PTEST_OBJECT) lParam1)->dwUDPBytes < ((PTEST_OBJECT) lParam2)->dwUDPBytes) {
                return -1;
            }
            else if (((PTEST_OBJECT) lParam1)->dwUDPBytes > ((PTEST_OBJECT) lParam2)->dwUDPBytes) {
                return 1;
            }

            break;

        case eSortUDPBytesDescending:
            if (((PTEST_OBJECT) lParam2)->dwUDPBytes < ((PTEST_OBJECT) lParam1)->dwUDPBytes) {
                return -1;
            }
            else if (((PTEST_OBJECT) lParam2)->dwUDPBytes > ((PTEST_OBJECT) lParam1)->dwUDPBytes) {
                return 1;
            }

            break;


        case eSortTCPBytesAscending:
            if (((PTEST_OBJECT) lParam1)->dwTCPBytes < ((PTEST_OBJECT) lParam2)->dwTCPBytes) {
                return -1;
            }
            else if (((PTEST_OBJECT) lParam1)->dwTCPBytes > ((PTEST_OBJECT) lParam2)->dwTCPBytes) {
                return 1;
            }

            break;


        case eSortTCPBytesDescending:
            if (((PTEST_OBJECT) lParam2)->dwTCPBytes < ((PTEST_OBJECT) lParam1)->dwTCPBytes) {
                return -1;
            }
            else if (((PTEST_OBJECT) lParam2)->dwTCPBytes > ((PTEST_OBJECT) lParam1)->dwTCPBytes) {
                return 1;
            }

            break;

        case eSortFirstActivityTimeAscending:
            // Get the time of activity
            SystemTimeToFileTime(&((PTEST_OBJECT) lParam1)->FirstActivityTime, (FILETIME *) &ActivityTime1);
            SystemTimeToFileTime(&((PTEST_OBJECT) lParam2)->FirstActivityTime, (FILETIME *) &ActivityTime2);

            if (ActivityTime1.QuadPart < ActivityTime2.QuadPart) {
                return -1;
            }
            else if (ActivityTime1.QuadPart > ActivityTime2.QuadPart) {
                return 1;
            }

            break;

        case eSortFirstActivityTimeDescending:
            // Get the time of activity
            SystemTimeToFileTime(&((PTEST_OBJECT) lParam1)->FirstActivityTime, (FILETIME *) &ActivityTime1);
            SystemTimeToFileTime(&((PTEST_OBJECT) lParam2)->FirstActivityTime, (FILETIME *) &ActivityTime2);

            if (ActivityTime2.QuadPart < ActivityTime1.QuadPart) {
                return -1;
            }
            else if (ActivityTime2.QuadPart > ActivityTime1.QuadPart) {
                return 1;
            }

            break;

        case eSortLastActivityTimeAscending:
            // Get the time of last activity
            SystemTimeToFileTime(&((PTEST_OBJECT) lParam1)->LastActivityTime, (FILETIME *) &ActivityTime1);
            SystemTimeToFileTime(&((PTEST_OBJECT) lParam2)->LastActivityTime, (FILETIME *) &ActivityTime2);

            if (ActivityTime1.QuadPart < ActivityTime2.QuadPart) {
                return -1;
            }
            else if (ActivityTime1.QuadPart > ActivityTime2.QuadPart) {
                return 1;
            }

            break;

        case eSortLastActivityTimeDescending:
            // Get the time of last activity
            SystemTimeToFileTime(&((PTEST_OBJECT) lParam1)->LastActivityTime, (FILETIME *) &ActivityTime1);
            SystemTimeToFileTime(&((PTEST_OBJECT) lParam2)->LastActivityTime, (FILETIME *) &ActivityTime2);

            if (ActivityTime2.QuadPart < ActivityTime1.QuadPart) {
                return -1;
            }
            else if (ActivityTime2.QuadPart > ActivityTime1.QuadPart) {
                return 1;
            }

            break;

        default:
            break;
    }

    return 0;
}



LRESULT CALLBACK DialogProc (HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Dialog procedure for the main window

-----------------------------------------------------------------------------*/
{
    // cs is the object to synchronize access to the test objects
    static CRITICAL_SECTION  cs;
    // bcsInitialized indicates the cs is initialized
    static BOOL              bcsInitialized = FALSE;
    // hMemObject is the handle to the memory object
    static HANDLE            hMemObject = INVALID_HANDLE_VALUE;
    // hFile is the handle to the log file
    static HANDLE            hFile = INVALID_HANDLE_VALUE;
    // WSAData is the details of the Winsock implementation
    WSADATA                  WSAData;
    // bWinsockInitialized indicates Winsock is initialized
    static BOOL              bWinsockInitialized = FALSE;
    // pSessionObject is the pointer to the session object
    static PSESSION_OBJECT   pSessionObject = NULL;
    // bTimerInitialized indicates the timer is initialized
    static BOOL              bTimerInitialized = FALSE;
    // bDlgInitialized indicates the dialog is initialized
    static BOOL              bDlgInitialized = TRUE;

    // pTestObject is a pointer to the test object
    PTEST_OBJECT             pTestObject;
    // pNextTestObject is a pointer to the next test object
    PTEST_OBJECT             pNextTestObject;
    // SystemTime is the system time
    SYSTEMTIME               SystemTime;
    // CurrentTime is the local time
    SYSTEMTIME               CurrentTime;
    // CurrentActivityTime is the current time of activity
    ULARGE_INTEGER           CurrentActivityTime;
    // LastActivityTime is the last time of activity
    ULARGE_INTEGER           LastActivityTime;

    // hWndList is a handle to the status list
    static HWND              hWndList = NULL;
    // eCurrentSortMethod is the current sort method of the status list
    static eSortMethod       eCurrentSortMethod = eSortRemoteNameAscending;
    // rcClient is the WindowRect of the status list
    RECT                     rcClient;
    // lvc specifies the attributes of a particular column of the status list
    LV_COLUMN                lvc;
    // lvi specifies the attributes of a particular item of the status list
    LV_ITEM                  lvi;
    // lvfi specifies the attributes of a particular item to find in the status list
    LV_FINDINFO              lvfi;
    // dwListIndex is the index of a particular item in the status list
    DWORD                    dwListIndex;
    // pnmhdr is a pointer to the WM_NOTIFY message header
    LPNMHDR                  pnmhdr;
    // pnmlistview is a pointer to the LVN_COLUMNCLICK message
    LPNMLISTVIEW             pnmlistview;
    // bSort indicates status list needs to be sorted
    BOOL                     bSort;

    // szText is the text string buffer
    WCHAR                    szText[256];
    // dwTextLen is the length of the text string buffer
    DWORD                    dwTextLen;
    // szError is the error string buffer
    WCHAR                    szError[256];
    // dwErrorCode is the last error code
    DWORD                    dwErrorCode = ERROR_SUCCESS;



    switch (iMsg) {

        case UM_DIALOG_INITIALIZE:
            // Get the handle to the status list
            hWndList = GetDlgItem(hDlg, IDC_STATUS_LIST);

            // Set the status list to select the full row
            ListView_SetExtendedListViewStyle(hWndList, LVS_EX_FULLROWSELECT);

            // Get the Rect of the Status List
            GetWindowRect(hWndList, &rcClient);

            // Set common attributes for each column
            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.fmt = LVCFMT_LEFT;

            // Remote Name Column
            // Load the text
            GetResourceString(IDS_REMOTENAME_LABEL, szText, sizeof(szText) / sizeof(WCHAR));
            // Set the column text
            lvc.pszText = szText;
            // Set the width of the column to be about 1 / 7 of the width of the status list, allowing for the width of the borders and scroll bar
            lvc.cx = (rcClient.right - rcClient.left - 4 * GetSystemMetrics(SM_CXBORDER) - GetSystemMetrics(SM_CXVSCROLL)) / 7;
            // Indicate this is the first column
            lvc.iSubItem = eColumnRemoteName;
            // Insert column
            ListView_InsertColumn(hWndList, lvc.iSubItem, &lvc);

            // Set common attributes for each column
            lvc.fmt = LVCFMT_RIGHT;

            // UDP Byte Count Column
            // Load the text
            GetResourceString(IDS_UDPBYTECOUNT_LABEL, szText, sizeof(szText) / sizeof(WCHAR));
            // Set the column text
            lvc.pszText = szText;
            // Indicate this is the second column
            lvc.iSubItem = eColumnUDPBytes;
            // Insert column
            ListView_InsertColumn(hWndList, lvc.iSubItem, &lvc);

            // TCP Byte Count Column
            // Load the text
            GetResourceString(IDS_TCPBYTECOUNT_LABEL, szText, sizeof(szText) / sizeof(WCHAR));
            // Set the column text
            lvc.pszText = szText;
            // Indicate this is the third column
            lvc.iSubItem = eColumnTCPBytes;
            // Insert column
            ListView_InsertColumn(hWndList, lvc.iSubItem, &lvc);

            // First Activity Time Column
            // Load the text
            GetResourceString(IDS_FIRSTACTIVITYTIME_LABEL, szText, sizeof(szText) / sizeof(WCHAR));
            // Set the column text
            lvc.pszText = szText;
            // Set the width of the column to be about 2 / 7 of the width of the status list, allowing for the width of the borders and scroll bar
            lvc.cx *= 2;
            // Indicate this is the fourth column
            lvc.iSubItem = eColumnFirstActivityTime;
            // Insert column
            ListView_InsertColumn(hWndList, lvc.iSubItem, &lvc);

            // Last Activity Time Column
            // Load the text
            GetResourceString(IDS_LASTACTIVITYTIME_LABEL, szText, sizeof(szText) / sizeof(WCHAR));
            // Set the column text
            lvc.pszText = szText;
            // Indicate this is the fourth column
            lvc.iSubItem = eColumnLastActivityTime;
            // Insert column
            ListView_InsertColumn(hWndList, lvc.iSubItem, &lvc);

            // Initialize the critical section
            InitializeCriticalSection(&cs);
            bcsInitialized = TRUE;

            // Set the caption
            GetResourceString(IDS_SGDATA_CAPTION, szText, sizeof(szText) / sizeof(WCHAR));
            SetWindowText(hDlg, szText);

            // Create the memory object
            hMemObject = xMemCreate();
            if (INVALID_HANDLE_VALUE == hMemObject) {
                // Get the last error
                dwErrorCode = GetLastError();

                // Get the resource string buffer
                GetResourceString(IDS_MEMORY_INIT_FAILED, szError, sizeof(szError) / sizeof(WCHAR), dwErrorCode);

                goto UM_DIALOG_INITIALIZE_Exit;
            }

            // Create the log file
            hFile = CreateFile(SGDATA_LOGFILE_NAME, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (INVALID_HANDLE_VALUE == hFile) {
                // Get the last error
                dwErrorCode = GetLastError();

                // Get the resource string buffer
                GetResourceString(IDS_LOGFILE_INIT_FAILED, szError, sizeof(szError) / sizeof(WCHAR), dwErrorCode);

                goto UM_DIALOG_INITIALIZE_Exit;
            }

            // Write the log file header
            LogActivityHeader(hFile);

            // Initialize Winsock
            ZeroMemory(&WSAData, sizeof(WSAData));
            dwErrorCode = WSAStartup(MAKEWORD(2, 2), &WSAData);
            if (ERROR_SUCCESS != dwErrorCode) {
                // Get the resource string buffer
                GetResourceString(IDS_WINSOCK_INIT_FAILED, szError, sizeof(szError) / sizeof(WCHAR), dwErrorCode);

                goto UM_DIALOG_INITIALIZE_Exit;
            }
            else {
                bWinsockInitialized = TRUE;
            }

            // Create the session
            pSessionObject = CreateSession(&cs, hDlg, hMemObject, hFile);
            if (NULL == pSessionObject) {
                // Get the last error
                dwErrorCode = GetLastError();

                // Get the resource string buffer
                GetResourceString(IDS_SESSION_INIT_FAILED, szError, sizeof(szError) / sizeof(WCHAR), dwErrorCode);

                goto UM_DIALOG_INITIALIZE_Exit;
            }

            // Create the timer
            SetTimer(hDlg, 0, TIMER_TIMEOUT, NULL);
            bTimerInitialized = TRUE;

UM_DIALOG_INITIALIZE_Exit:
            if (ERROR_SUCCESS != dwErrorCode) {
                // Display the error message
                GetResourceString(IDS_SGDATA_CAPTION, szText, sizeof(szText) / sizeof(WCHAR));
                MessageBox(NULL, szError, szText, MB_OK | MB_ICONERROR);

                // End the dialog
                bDlgInitialized = FALSE;
                DestroyWindow(hDlg);
                PostQuitMessage(dwErrorCode);
            }


            break;

        case UM_UPDATE_TEST:
            // Get the test object
            pTestObject = (PTEST_OBJECT) lParam;

            // Search the lParam
            lvfi.flags = LVFI_PARAM;

            // Set the search criteria
            lvfi.lParam = (long) pTestObject;

            // Find the item in the status list
            dwListIndex = ListView_FindItem(hWndList, -1, &lvfi);
            if (-1 == dwListIndex) {
                // Insert the item

                // Indicate pszText and lParam are valid
                lvi.mask = LVIF_TEXT | LVIF_PARAM;

                // Set the text
                lvi.pszText = pTestObject->RemoteName;
                // Set the lParam
                lvi.lParam = (long) pTestObject;
                // Set the item number
                lvi.iItem = ListView_GetItemCount(hWndList);
                // Indicate this is the first column
                lvi.iSubItem = eColumnRemoteName;
                // Insert item
                ListView_InsertItem(hWndList, &lvi);

                bSort = TRUE;
            }
            else {
                // Set the item number
                lvi.iItem = dwListIndex;

                bSort = FALSE;
            }

            // Indicate only pszText is valid
            lvi.mask = LVIF_TEXT;

            // Set the text
            wsprintf(szText, L"%u", pTestObject->dwUDPBytes);
            lvi.pszText = szText;
            // Indicate this is the second column
            lvi.iSubItem = eColumnUDPBytes;
            // Set item
            ListView_SetItem(hWndList, &lvi);

            // Set the text
            wsprintf(szText, L"%u", pTestObject->dwTCPBytes);
            lvi.pszText = szText;
            // Indicate this is the third column
            lvi.iSubItem = eColumnTCPBytes;
            // Set item
            ListView_SetItem(hWndList, &lvi);

            // Get the date and time string
            GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &pTestObject->FirstActivityTime, NULL, szText, (sizeof(szText) / sizeof(WCHAR)) - 2);
            lstrcat(szText, TEXT(" "));
            dwTextLen = lstrlen(szText);
            GetTimeFormat(LOCALE_USER_DEFAULT, 0, &pTestObject->FirstActivityTime, NULL, &szText[dwTextLen], (sizeof(szText) / sizeof(WCHAR)) - dwTextLen - 1);

            // Set the text
            lvi.pszText = szText;
            // Indicate this is the fourth column
            lvi.iSubItem = eColumnFirstActivityTime;
            // Set item
            ListView_SetItem(hWndList, &lvi);

            // Get the date and time string
            GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &pTestObject->LastActivityTime, NULL, szText, sizeof(szText) / sizeof(WCHAR) - 2);
            lstrcat(szText, TEXT(" "));
            dwTextLen = lstrlen(szText);
            GetTimeFormat(LOCALE_USER_DEFAULT, 0, &pTestObject->LastActivityTime, NULL, &szText[dwTextLen], (sizeof(szText) / sizeof(WCHAR)) - dwTextLen - 1);

            // Set the text
            lvi.pszText = szText;
            // Indicate this is the fifth column
            lvi.iSubItem = eColumnLastActivityTime;
            // Set item
            ListView_SetItem(hWndList, &lvi);

            // Sort the status list
            if (TRUE == bSort) {
                ListView_SortItems(hWndList, SortTestObjects, eCurrentSortMethod);
            }

            break;

        case UM_DELETE_TEST:
            // Get the test object
            pTestObject = (PTEST_OBJECT) lParam;

            // Search the lParam
            lvfi.flags = LVFI_PARAM;

            // Set the search criteria
            lvfi.lParam = (long) pTestObject;

            // Find the item in the status list
            dwListIndex = ListView_FindItem(hWndList, -1, &lvfi);
            if (-1 != dwListIndex) {
                // Delete the item
                ListView_DeleteItem(hWndList, dwListIndex);
            }

            // Close the test object
            if (NULL != pTestObject->pPrevTestObject) {
                pTestObject->pPrevTestObject->pNextTestObject = pTestObject->pNextTestObject;
            }
            else {
                pSessionObject->pTestObject = pTestObject->pNextTestObject;
            }

            if (NULL != pTestObject->pNextTestObject) {
                pTestObject->pNextTestObject->pPrevTestObject = pTestObject->pPrevTestObject;
            }

            CloseTest(pTestObject);

            break;

        case WM_TIMER:
            EnterCriticalSection(pSessionObject->pcs);

            // Get the current time
            GetSystemTime(&SystemTime);
            SystemTimeToTzSpecificLocalTime(NULL, &SystemTime, &CurrentTime);
            SystemTimeToFileTime(&CurrentTime, (FILETIME *) &CurrentActivityTime);

            pTestObject = pSessionObject->pTestObject;
            while (NULL != pTestObject) {
                // Get the next test object
                pNextTestObject = pTestObject->pNextTestObject;

                if (SOCK_STREAM == pTestObject->type) {
                    // Convert the last activity time
                    SystemTimeToFileTime(&pTestObject->LastActivityTime, (FILETIME *) &LastActivityTime);

                    if (ACTIVITY_TIMEOUT < (CurrentActivityTime.QuadPart - LastActivityTime.QuadPart)) {
                        // Write the activity to the log file
                        LogActivity(pTestObject->hFile, &CurrentTime, pTestObject->RemoteName, LOG_TIMEOUT, 0);

                        SendMessage(hDlg, UM_DELETE_TEST, 0, (LPARAM) pTestObject);
                    }
                }

                // Get the next test object
                pTestObject = pNextTestObject;
            }

            LeaveCriticalSection(pSessionObject->pcs);

            break;

        case WM_NOTIFY:
            // Get the WM_NOTIFY message header
            pnmhdr = (LPNMHDR) lParam;

            if ((hWndList == pnmhdr->hwndFrom) && (LVN_COLUMNCLICK == pnmhdr->code)) {
                // Get the LVN_COLUMNCLICK message
                pnmlistview = (LPNMLISTVIEW) lParam;

                // Update the sort method
                switch (pnmlistview->iSubItem) {
                    case eColumnRemoteName:
                        if (eSortRemoteNameAscending != eCurrentSortMethod) {
                            eCurrentSortMethod = eSortRemoteNameAscending;
                        }
                        else {
                            eCurrentSortMethod = eSortRemoteNameDescending;
                        }

                        break;

                    case eColumnUDPBytes:
                        if (eSortUDPBytesAscending != eCurrentSortMethod) {
                            eCurrentSortMethod = eSortUDPBytesAscending;
                        }
                        else {
                            eCurrentSortMethod = eSortUDPBytesDescending;
                        }

                        break;

                    case eColumnTCPBytes:
                        if (eSortTCPBytesAscending != eCurrentSortMethod) {
                            eCurrentSortMethod = eSortTCPBytesAscending;
                        }
                        else {
                            eCurrentSortMethod = eSortTCPBytesDescending;
                        }

                        break;

                    case eColumnFirstActivityTime:
                        if (eSortFirstActivityTimeAscending != eCurrentSortMethod) {
                            eCurrentSortMethod = eSortFirstActivityTimeAscending;
                        }
                        else {
                            eCurrentSortMethod = eSortFirstActivityTimeDescending;
                        }

                        break;

                    case eColumnLastActivityTime:
                        if (eSortLastActivityTimeAscending != eCurrentSortMethod) {
                            eCurrentSortMethod = eSortLastActivityTimeAscending;
                        }
                        else {
                            eCurrentSortMethod = eSortLastActivityTimeDescending;
                        }

                        break;

                    default:
                        break;
                }

                // Sort the status list
                ListView_SortItems(hWndList, SortTestObjects, eCurrentSortMethod);
            }

            break;

        case WM_QUERYENDSESSION:
        case WM_ENDSESSION:
        case WM_CLOSE:
        case WM_DESTROY:
            // Destroy the timer
            if (TRUE == bTimerInitialized) {
                KillTimer(hDlg, 0);
                bTimerInitialized = FALSE;
            }

            // Close the session
            if (NULL != pSessionObject) {
                CloseSession(pSessionObject);
                pSessionObject = NULL;
            }

            // Terminate Winsock
            if (TRUE == bWinsockInitialized) {
                WSACleanup();
                bWinsockInitialized = FALSE;
            }

            // Close the log file
            if (INVALID_HANDLE_VALUE != hFile) {
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
            }

            // Free the memory object
            if (INVALID_HANDLE_VALUE != hMemObject) {
                xMemClose(hMemObject);
                hMemObject = INVALID_HANDLE_VALUE;
            }

            // Delete the critical section
            if (TRUE == bcsInitialized) {
                DeleteCriticalSection(&cs);
                bcsInitialized = FALSE;
            }

            // End the dialog
            if (TRUE == bDlgInitialized) {
                bDlgInitialized = FALSE;
                DestroyWindow(hDlg);
                PostQuitMessage(ERROR_SUCCESS);
            }

            break;

    }

    return DefDlgProc(hDlg, iMsg, wParam, lParam);
}

} // namespace SGDataNamespace



int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Window procedure for the main window

-----------------------------------------------------------------------------*/
{
    // hDlg is the handle to the dialog
    HWND        hDlg = NULL;
    // wndclass is the window class of the dialog
    WNDCLASSEX  wndclass;
    // msg is the window message
    MSG         msg;
    // dwErrorCode is the error code
    DWORD       dwErrorCode = ERROR_SUCCESS;



    // Initialize the common controls
    InitCommonControls();

    // Initialize the window class
    ZeroMemory(&wndclass, sizeof(wndclass));
    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = DialogProc;
    wndclass.cbWndExtra = DLGWINDOWEXTRA;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_SGDATA_ICON));
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH) (COLOR_INACTIVEBORDER + 1);
    wndclass.lpszClassName = SGDATA_CLASS_NAME;
    wndclass.hIconSm = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_SGDATA_ICON));

    // Register the class
    RegisterClassEx(&wndclass);

    // Create the dialog
    hDlg = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_DIALOG), NULL, NULL);

    // Initialize the dialog
    SendMessage(hDlg, UM_DIALOG_INITIALIZE, 0, 0);

    // Show the dialog
    ShowWindow(hDlg, iCmdShow);
    UpdateWindow(hDlg);

    // Pump the message handler
    while (0 != GetMessage(&msg, NULL, 0, 0)) {
        if (FALSE == IsDialogMessage(hDlg, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // Get the error code
    dwErrorCode = msg.wParam;

    return dwErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\server\util.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.h

Abstract:

  This module contains the definitions for util.c

Author:

  Steven Kehrli (steveke) 24-Jan-2002

-----------------------------------------------------------------------------*/

#pragma once



BOOL
GetResourceString(
    UINT    uResource,
    LPWSTR  lpszString,
    DWORD   dwStringSize
    ...
);



#define LOG_CONNECTED     1
#define LOG_DISCONNECTED  2
#define LOG_TIMEOUT       3
#define LOG_UDP_DATA      4
#define LOG_TCP_DATA      5

VOID
LogActivityHeader(
    HANDLE      hFile
);

VOID
LogActivity(
    HANDLE      hFile,
    SYSTEMTIME  *ActivityTime,
    LPWSTR      RemoteName,
    DWORD       dwLogType,
    DWORD       dwBytes
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\client\main.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  main.h

Abstract:

  This module contains the definitions for main.c

Author:

  Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#pragma once



namespace XNetStreamNamespace {



// Function prototypes

VOID
WINAPI
StartTest(
    IN HANDLE  hLog
);

VOID
WINAPI
EndTest(
);

} // namespace XNetStreamNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\sgdata\server\util.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module contains the utility functions for sgdata_nt.exe

Author:

  Steven Kehrli (steveke) 24-Jan-2002

-----------------------------------------------------------------------------*/

#include "precomp.h"



BOOL
FormatResourceString(
    UINT     uResource,
    LPWSTR   lpszString,
    DWORD    dwStringSize,
    va_list  varg_ptr
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Formats a resource string using a variable argument list

Arguments:

  uResource - Specifies the resource id
  lpszString - Pointer to the resource string buffer
  dwStringSize - Specifies the resource string buffer size
  varg_ptr - Pointer to the variable argument list

Return Value:

  BOOL:
    If the function succeeds, the return value is non-zero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

-----------------------------------------------------------------------------*/
{
    // hModule is a handle to the module
    HMODULE  hModule = NULL;
    // szResourceBuffer is a buffer for the string resource
    WCHAR    szResourceBuffer[256];
    // dwResult is the result code
    DWORD    dwResult = 0;



    // Get the module handle
    hModule = GetModuleHandle(NULL);
    if (hModule == NULL)
    {
        return FALSE;
    }

    // Initialize the string resource buffer
    ZeroMemory(szResourceBuffer, sizeof(szResourceBuffer));

    // Load the string resource
    if (0 != LoadString(hModule, uResource, szResourceBuffer, sizeof(szResourceBuffer) / sizeof(WCHAR))) {
        // Copy the string resource
        dwResult = _vsnwprintf(lpszString, dwStringSize, szResourceBuffer, varg_ptr);
    }

    return ((0 != dwResult) && (dwStringSize != dwResult));
}



BOOL
GetResourceString(
    UINT    uResource,
    LPWSTR  lpszString,
    DWORD   dwStringSize
    ...
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets a resource string by calling FormatResourceString()

Arguments:

  uResource - Resource id
  lpszString - Pointer to the resource string buffer
  dwStringSize - Specifies the resource string buffer size

Return Value:

  BOOL:
    If the function succeeds, the return value is non-zero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

-----------------------------------------------------------------------------*/
{
    // varg_ptr is a pointer to the variable argument list
    va_list  varg_ptr;



    // Get the variable argument list
    va_start(varg_ptr, dwStringSize);

    // Call FormatResourceString
    return FormatResourceString(uResource, lpszString, dwStringSize, varg_ptr);
}



VOID
LogActivityHeader(
    HANDLE      hFile
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Writes activity header to the log file

Arguments:

  hFile - Handle to the log file

Return Value:

  None

-----------------------------------------------------------------------------*/
{
    // cUnicodeBOM is the Unicode BOM
    WCHAR   cUnicodeBOM = 0xFEFF;
    // lpszHeader is the header
    LPWSTR  lpszHeader = L"Date,Time,Remote,Activity,UDP Bytes,TCP Bytes\r\n";
    // cb is the number of bytes written to the log file
    DWORD   cb = 0;



    // Write the header to the file
    WriteFile(hFile, &cUnicodeBOM, sizeof(cUnicodeBOM), &cb, NULL);
    WriteFile(hFile, lpszHeader, wcslen(lpszHeader) * sizeof(WCHAR), &cb, NULL);
}



VOID
LogActivity(
    HANDLE      hFile,
    SYSTEMTIME  *ActivityTime,
    LPWSTR      RemoteName,
    DWORD       dwLogType,
    DWORD       dwBytes
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Writes activity to the log file

Arguments:

  hFile - Handle to the log file
  ActivityTime - Pointer to the activity time
  RemoteName - Pointer to the remote name
  dwLogType - Specifies the log type
  dwBytes - Specifies the number of bytes

Return Value:

  None

-----------------------------------------------------------------------------*/
{
    // szDateString is the date string
    WCHAR   szDateString[128];
    // szTimeString is the time string
    WCHAR   szTimeString[128];
    // szDataString is the data string
    WCHAR   szDataString[128];
    // szLogString is the log string
    WCHAR   szLogString[1024];
    // lpszAction is the action string
    LPWSTR  lpszAction = NULL;
    // cb is the number of bytes written to the log file
    DWORD   cb = 0;

    // Get the date and time string
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, ActivityTime, NULL, szDateString, (sizeof(szDateString) / sizeof(WCHAR)) - 1);
    GetTimeFormat(LOCALE_USER_DEFAULT, 0, ActivityTime, NULL, szTimeString, (sizeof(szTimeString) / sizeof(WCHAR)) - 1);

    // Get the action string
    switch (dwLogType) {
        case LOG_CONNECTED:
            lpszAction = L"Connected";
            break;

        case LOG_DISCONNECTED:
            lpszAction = L"Disconnected";
            break;

        case LOG_TIMEOUT:
            lpszAction = L"Timeout";
            break;

        case LOG_UDP_DATA:
            lpszAction = L"UDP Data";
            break;

        case LOG_TCP_DATA:
            lpszAction = L"TCP Data";
            break;

        default:
            lpszAction = L"Unknown";
            break;
    }

    // Format the log string
    wsprintf(szLogString, L"%s,%s,%s,%s", szDateString, szTimeString, RemoteName, lpszAction);

    if ((LOG_UDP_DATA == dwLogType) || (LOG_TCP_DATA == dwLogType)) {
        wsprintf(szDataString, L",%u,%u", (LOG_UDP_DATA == dwLogType) ? dwBytes : 0, (LOG_TCP_DATA == dwLogType) ? dwBytes : 0);

        wcscat(szLogString, szDataString);
    }

    wcscat(szLogString, L"\r\n");

    // Write the log string to the file
    WriteFile(hFile, szLogString, wcslen(szLogString) * sizeof(WCHAR), &cb, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\client\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF



TARGETNAME=xnetstream

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_CXX=1

USECXX_FLAG=/Tp

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\inc; \
    ..; \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\server\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#ifdef _XBOX

#include <xtl.h>

#else

#include <windows.h>
#include <winsock2.h>

#endif

#include <xmem.h>
#include <netsync.h>

#include "server.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\server\server.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  server.c

Abstract:

  This module contains the server side exports

Author:

  Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef _XBOX

#ifdef __cplusplus
extern "C" {
#endif

// Netsync export table for syncsrv

#pragma data_seg(NETSYNC_EXPORT_SECTION_NAME)
DECLARE_NETSYNC_EXPORT_DIRECTORY(xnetstream_xbox)
#pragma data_seg()

BEGIN_NETSYNC_EXPORT_TABLE(xnetstream_xbox)
    NETSYNC_EXPORT_TABLE_ENTRY("StreamServerStart", StreamServerStart)
    NETSYNC_EXPORT_TABLE_ENTRY("StreamServerMain", StreamServerMain)
    NETSYNC_EXPORT_TABLE_ENTRY("StreamServerStop", StreamServerStop)
END_NETSYNC_EXPORT_TABLE(xnetstream_xbox)

#ifdef __cplusplus
}
#endif

#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\client\exe\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#include <xtl.h>

#include <xlog.h>

#include "main.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\client\lib\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#include <xtl.h>

#include <xtestlib.h>
#include <xnetref.h>
#include <xlog.h>
#include <netsync.h>

#include "client.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\client\stream.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  stream.c

Abstract:

  This module streams data between client and server - library

Author:

  Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#include "precomp.h"



namespace XNetStreamNamespace {

#define TestBuffer "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

NETSYNC_TYPE_CALLBACK  StreamSessionNt =
{
    1,
    1,
    2,
    L"xboxstream_nt.dll",
    "StreamServerMain",
    "StreamServerStart",
    "StreamServerStop"
};

NETSYNC_TYPE_CALLBACK  StreamSessionXbox =
{
    1,
    1,
    2,
    L"xboxstream_xbox.dll",
    "StreamServerMain",
    "StreamServerStart",
    "StreamServerStop"
};



VOID
StreamTest(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Send and receive data over the network

Arguments:

  hLog - handle to the xLog log object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // uXNetRef is the reference count of xnet
    ULONG        uXNetRef = 0;
    // WSAData is the Winsock startup data
    WSADATA      WSAData;
    // OldTitleXnAddr is the old title XNADDR
    XNADDR       OldTitleXnAddr;
    // NewTitleXnAddr is the new title XNADDR
    XNADDR       NewTitleXnAddr;

    // hNetsyncObject is a handle to the netsync object
    HANDLE       hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncInAddr is the address of the netsync server
    u_long       NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short      LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short      HighPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long       FromInAddr;
    // dwMessageSize is the size of the received message
    DWORD        dwMessageSize;
    // pMessage is a pointer to the received message
    char         *pMessage;

    // sTCPSocket is a TCP socket descriptor
    SOCKET       sTCPSocket = INVALID_SOCKET;
    // sUDPSocket is a UDP socket descriptor
    SOCKET       sUDPSocket = INVALID_SOCKET;
    // iTimeout is the send and receive timeout value for the socket
    int          iTimeout;
    // portname is the local address associated with a socket
    SOCKADDR_IN  portname = { AF_INET, 0, 0, {'\0'} };
    // toname is the recipient address information structure
    SOCKADDR_IN  toname = { AF_INET, 0, 0, {'\0'} };
    // TCPRecvBuffer is the TCP receive buffer
    char         TCPRecvBuffer[sizeof(TestBuffer)];
    // UDPRecvBuffer is the UDP receive buffer
    char         UDPRecvBuffer[sizeof(TestBuffer)];
    // nBytes is the number of bytes sent or received on the socket
    int          nBytes;

    // dwResult is the result of a function call
    DWORD        dwResult;
    // iLastError is the last error code
    int          iLastError;



    // Initialize the net subsystem
    uXNetRef = XNetAddRef();
    if (0 == uXNetRef) {
        xLog(hLog, XLL_FAIL, "XNetAddRef failed - ec: %u", GetLastError());

        goto FunctionExit0;
    }

    while (0 == (dwResult = XNetGetTitleXnAddr(&OldTitleXnAddr))) {
        Sleep(1000);
    }

    // Initialize Winsock
    iLastError = WSAStartup(MAKEWORD(2, 2), &WSAData);
    if (ERROR_SUCCESS != iLastError) {
        xLog(hLog, XLL_FAIL, "WSAStartup failed - ec: %u", iLastError);

        goto FunctionExit1;
    }

    // Connect to the session
    hNetsyncObject = NetsyncCreateClient(0, NETSYNC_SESSION_CALLBACK, &StreamSessionNt, &NetsyncInAddr, NULL, &LowPort, &HighPort);
    if (INVALID_HANDLE_VALUE == hNetsyncObject) {
        xLog(hLog, XLL_BLOCK, "Cannot create Netsync client - ec = %u", GetLastError());

        goto FunctionExit2;
    }

    // Wait for session to initialize
    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &FromInAddr, NULL, &dwMessageSize, &pMessage);
    NetsyncFreeMessage(pMessage);

    // Create a TCP socket
    sTCPSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (INVALID_SOCKET == sTCPSocket) {
        xLog(hLog, XLL_FAIL, "Cannot create TCP socket - ec = %u", GetLastError());

        goto FunctionExit3;
    }

    // Create a UDP socket
    sUDPSocket = socket(AF_INET, SOCK_DGRAM, 0);
    if (INVALID_SOCKET == sUDPSocket) {
        xLog(hLog, XLL_FAIL, "Cannot create UDP socket - ec = %u", GetLastError());

        goto FunctionExit4;
    }

    // Set the receive timeout value to 5 sec
    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sTCPSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        xLog(hLog, XLL_FAIL, "Cannot set receive timeout value for TCP socket - ec = %u", GetLastError());

        goto FunctionExit5;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sUDPSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        xLog(hLog, XLL_FAIL, "Cannot set receive timeout value for UDP socket - ec = %u", GetLastError());

        goto FunctionExit5;
    }

    // Set the send timeout value to 5 sec
    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sTCPSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        xLog(hLog, XLL_FAIL, "Cannot set send timeout value for TCP socket - ec = %u", GetLastError());

        goto FunctionExit5;
    }

    iTimeout = 5000;
    if (SOCKET_ERROR == setsockopt(sUDPSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout))) {
        xLog(hLog, XLL_FAIL, "Cannot set send timeout value for UDP socket - ec = %u", GetLastError());

        goto FunctionExit5;
    }

    // Bind TCP socket
    portname.sin_port = htons(LowPort);
    if (SOCKET_ERROR == bind(sTCPSocket, (SOCKADDR *) &portname, sizeof(portname))) {
        xLog(hLog, XLL_FAIL, "Cannot bind TCP socket - ec = %u", GetLastError());

        goto FunctionExit5;
    }

    // Bind UDP socket
    portname.sin_port = htons(LowPort);
    if (SOCKET_ERROR == bind(sUDPSocket, (SOCKADDR *) &portname, sizeof(portname))) {
        xLog(hLog, XLL_FAIL, "Cannot bind UDP socket - ec = %u", GetLastError());

        goto FunctionExit5;
    }

    // Connect the TCP socket
    toname.sin_port = htons(LowPort);
    toname.sin_addr.s_addr = NetsyncInAddr;

    if (SOCKET_ERROR == connect(sTCPSocket, (SOCKADDR *) &toname, sizeof(toname))) {
        xLog(hLog, XLL_FAIL, "connect on TCP socket failed - ec = %u", GetLastError());

        goto FunctionExit5;
    }

    // Connect the UDP socket
    toname.sin_port = htons(LowPort);
    toname.sin_addr.s_addr = NetsyncInAddr;

    if (SOCKET_ERROR == connect(sUDPSocket, (SOCKADDR *) &toname, sizeof(toname))) {
        xLog(hLog, XLL_FAIL, "connect on UDP socket failed - ec = %u", GetLastError());

        goto FunctionExit5;
    }

    while (TRUE) {
        // Get XNADDR
        XNetGetTitleXnAddr(&NewTitleXnAddr);
        if (0 != memcmp(&OldTitleXnAddr, &NewTitleXnAddr, sizeof(NewTitleXnAddr))) {
            xLog(hLog, XLL_BREAK, "XNADDR changed");
            break;
        }

        // Pump Netsync
        NetsyncSendClientMessage(hNetsyncObject, 0, 0, NULL);

        // Send Data
        nBytes = send(sTCPSocket, TestBuffer, sizeof(TestBuffer), 0);
        if (SOCKET_ERROR == nBytes) {
            xLog(hLog, XLL_BREAK, "send on TCP socket failed - ec = %u", GetLastError());
        }

        nBytes = send(sUDPSocket, TestBuffer, sizeof(TestBuffer), 0);
        if (SOCKET_ERROR == nBytes) {
            xLog(hLog, XLL_BREAK, "send on UDP socket failed - ec = %u", GetLastError());
        }

        // Receive Data
        nBytes = recv(sTCPSocket, TCPRecvBuffer, sizeof(TCPRecvBuffer), 0);
        if (SOCKET_ERROR == nBytes) {
            xLog(hLog, XLL_BREAK, "recv on TCP socket failed - ec = %u", GetLastError());
        }

        nBytes = recv(sUDPSocket, UDPRecvBuffer, sizeof(UDPRecvBuffer), 0);
        if (SOCKET_ERROR == nBytes) {
            xLog(hLog, XLL_BREAK, "recv on UDP socket failed - ec = %u", GetLastError());
        }

        // Verify Data
        if (0 != memcmp(TestBuffer, TCPRecvBuffer, sizeof(TestBuffer))) {
            xLog(hLog, XLL_BREAK, "Buffer data on TCP socket does not match");
        }

        if (0 != memcmp(TestBuffer, UDPRecvBuffer, sizeof(TestBuffer))) {
            xLog(hLog, XLL_BREAK, "Buffer data on UDP socket does not match");
        }
    }

FunctionExit5:
    // Close the UDP socket
    if (0 != closesocket(sUDPSocket)) {
        xLog(hLog, XLL_FAIL, "Cannot close UDP socket - ec = %u", GetLastError());
    }

FunctionExit4:
    // Close the TCP socket
    if (0 != closesocket(sTCPSocket)) {
        xLog(hLog, XLL_FAIL, "Cannot close TCP socket - ec = %u", GetLastError());
    }

FunctionExit3:
    // Close the netsync client object
    NetsyncCloseClient(hNetsyncObject);

FunctionExit2:
    // Terminate Winsock
    if (0 != WSACleanup()) {
        xLog(hLog, XLL_FAIL, "WSACleanup failed - ec: %u", GetLastError());
    }

FunctionExit1:
    // Terminate the net subsystem
    if ((uXNetRef - 1) != XNetRelease()) {
        xLog(hLog, XLL_FAIL, "XNetRelease failed - ec: %u", GetLastError());
    }

FunctionExit0:
    return;
}

} // namespace XNetStreamNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\server\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF



TARGETPATH=$(BASEDIR)\private\test\lib

USECXX_FLAG=/Tp

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\inc; \

SOURCES=$(SOURCES) \
    stream.c       \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\server\server.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  server.h

Abstract:

  This module contains the definitions for server.c

Author:

  Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#pragma once



// Function prototypes

LPVOID
WINAPI
StreamServerStart(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientInAddrs,
    IN XNADDR   *ClientXnAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

BOOL
WINAPI
StreamServerMain(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN u_long   FromInAddr,
    IN XNADDR   *FromXnAddr,
    IN DWORD    dwMessageType,
    IN DWORD    dwMessageSize,
    IN char     *pMessage,
    IN LPVOID   lpContext
);

VOID
WINAPI
StreamServerStop(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN LPVOID   lpContext
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\client\main.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.c

Abstract:

  This module tests XNet stress - executable

Author:

  Steven Kehrli (steveke) 17-Apr-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetStressNamespace;

void __cdecl main()
{
    // hLog is the handle to the xLog object
    HANDLE  hLog = INVALID_HANDLE_VALUE;



    // Create the xLog object
    hLog = xCreateLog(L"T:\\xnetstress.log", NULL, INVALID_SOCKET, XLL_LOGDEFAULT, XLO_DEBUG | XLO_CONFIG | XLO_STATE | XLO_REFRESH);

    // Run the test
    StartTest(hLog);
    EndTest();

    // Close the xLog object
    xCloseLog(hLog);

    // Launch the dashboard
    XLaunchNewImage(NULL, NULL);

    __asm int 3;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\client\main.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  main.h

Abstract:

  This module contains the definitions for main.c

Author:

  Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#pragma once



namespace XNetStressNamespace {



// Function prototypes

VOID
WINAPI
StartTest(
    IN HANDLE  hLog
);

VOID
WINAPI
EndTest(
);

} // namespace XNetStressNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\client\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF



TARGETNAME=xnetstress

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_CXX=1

USE_LIBCMT=1

USECXX_FLAG=/Tp

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\inc; \
    ..; \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stream\server\stream.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  server.c

Abstract:

  This module streams data between client and server

Author:

  Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#include "precomp.h"



namespace XNetStreamNamespace {

typedef struct _TEST_INFO {
    HANDLE  hMemObject;
    SOCKET  sTCPSocket;
    SOCKET  nsTCPSocket;
    SOCKET  sUDPSocket;
} TEST_INFO, *PTEST_INFO;

} // namespace XNetStreamNamespace



using namespace XNetStreamNamespace;

LPVOID
WINAPI
StreamServerStart(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientInAddrs,
    IN XNADDR   *ClientXnAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Start Function - Send and receive data over the network

Arguments:

  hSessionObject - Handle to the session object
  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientAddrs - Pointer to an array of client addresses
  ClientXnAddrs - Pointer to an array of client addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  LPVOID - Pointer to the context

------------------------------------------------------------------------------*/
{
    // hMemObject is the handle to the memory object
    HANDLE       hMemObject = INVALID_HANDLE_VALUE;
    // PTEST_INFO is a pointer to the test info
    PTEST_INFO   pTestInfo = NULL;
    // iTimeout is the send and receive timeout value for the socket
    int          iTimeout;
    // portname is the local address associated with a socket
    SOCKADDR_IN  portname = { AF_INET, 0, 0, {'\0'} };
    // toname is the recipient address information structure
    SOCKADDR_IN  toname = { AF_INET, 0, 0, {'\0'} };



    // Create the memory object
    hMemObject = xMemCreate();
    if (INVALID_HANDLE_VALUE == hMemObject) {
        return NULL;
    }

    // Create the test info structure
    pTestInfo = (PTEST_INFO) xMemAlloc(hMemObject, sizeof(TEST_INFO));
    if (NULL == pTestInfo) {
        // Close the memory object
        xMemClose(hMemObject);

        return NULL;
    }

    // Set the test info structure
    pTestInfo->hMemObject = hMemObject;
    pTestInfo->nsTCPSocket = INVALID_SOCKET;

    // Create a TCP socket
    pTestInfo->sTCPSocket = socket(AF_INET, SOCK_STREAM, 0);

    // Create a UDP socket
    pTestInfo->sUDPSocket = socket(AF_INET, SOCK_DGRAM, 0);

    // Set the receive timeout value to 5 sec
    iTimeout = 5000;
    setsockopt(pTestInfo->sTCPSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));

    iTimeout = 5000;
    setsockopt(pTestInfo->sUDPSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &iTimeout, sizeof(iTimeout));

    // Set the send timeout value to 5 sec
    iTimeout = 5000;
    setsockopt(pTestInfo->sTCPSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

    iTimeout = 5000;
    setsockopt(pTestInfo->sUDPSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &iTimeout, sizeof(iTimeout));

    // Bind TCP socket
    portname.sin_port = htons(LowPort);
    bind(pTestInfo->sTCPSocket, (SOCKADDR *) &portname, sizeof(portname));

    // Bind UDP socket
    portname.sin_port = htons(LowPort);
    bind(pTestInfo->sUDPSocket, (SOCKADDR *) &portname, sizeof(portname));

    // Listen on TCP socket
    listen(pTestInfo->sTCPSocket, 1);

    // Send the session initialized message
    NetsyncSendClientMessage(hNetsyncObject, ClientInAddrs[0], 0, NULL);

    return pTestInfo;
}



BOOL
WINAPI
StreamServerMain(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN u_long   FromInAddr,
    IN XNADDR   *FromXnAddr,
    IN DWORD    dwMessageType,
    IN DWORD    dwMessageSize,
    IN char     *pMessage,
    IN LPVOID   lpContext
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Main Function - Send and receive data over the network

Arguments:

  hSessionObject - Handle to the session object
  hNetsyncObject - Handle to the netsync object
  FromInAddr - Sender address
  FromXnAddr - Sender address
  dwMessageType - Specifies the message type
  dwMessageSize - Specifies the message size
  pMessage - Pointer to the message
  lpContext - Pointer to the context

Return Value:

  BOOL - FALSE on exit

------------------------------------------------------------------------------*/
{
    // PTEST_INFO is a pointer to the test info
    PTEST_INFO   pTestInfo = (PTEST_INFO) lpContext;
    // fromname is the sender/recipient address information structure
    SOCKADDR_IN  fromname = { AF_INET, 0, 0, {'\0'} };
    // fromnamelen is the size of fromname
    int          fromnamelen;
    // RecvBuffer is the receive buffer
    char         RecvBuffer[1024];
    // nBytes is the number of bytes sent or received on the socket
    int          nBytes;



    if (NULL == pTestInfo) {
        return FALSE;
    }

    if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
        return FALSE;
    }

    if (INVALID_SOCKET == pTestInfo->nsTCPSocket) {
        pTestInfo->nsTCPSocket = accept(pTestInfo->sTCPSocket, NULL, NULL);
    }

    // Receive and send data
    nBytes = recv(pTestInfo->nsTCPSocket, RecvBuffer, sizeof(RecvBuffer), 0);
    send(pTestInfo->nsTCPSocket, RecvBuffer, nBytes, 0);

    fromnamelen = sizeof(fromname);
    nBytes = recvfrom(pTestInfo->sUDPSocket, RecvBuffer, sizeof(RecvBuffer), 0, (SOCKADDR *) &fromname, &fromnamelen);
    sendto(pTestInfo->sUDPSocket, RecvBuffer, nBytes, 0, (SOCKADDR *) &fromname, fromnamelen);

    return TRUE;
}



VOID
WINAPI
StreamServerStop(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN LPVOID   lpContext
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Main Function - Send and receive data over the network

Arguments:

  hSessionObject - Handle to the session object
  hNetsyncObject - Handle to the netsync object
  lpContext - Pointer to the context

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // hMemObject is the handle to the memory object
    HANDLE       hMemObject = INVALID_HANDLE_VALUE;
    // PTEST_INFO is a pointer to the test info
    PTEST_INFO   pTestInfo = (PTEST_INFO) lpContext;



    if (NULL != pTestInfo) {
        // Get the memory object
        hMemObject = pTestInfo->hMemObject;

        // Close the sockets
        shutdown(pTestInfo->sTCPSocket, SD_BOTH);
        shutdown(pTestInfo->nsTCPSocket, SD_BOTH);
        shutdown(pTestInfo->sUDPSocket, SD_BOTH);

        closesocket(pTestInfo->sTCPSocket);
        closesocket(pTestInfo->nsTCPSocket);
        closesocket(pTestInfo->sUDPSocket);

        // Free the test info
        xMemFree(hMemObject, pTestInfo);

        // Close the memory object
        xMemClose(hMemObject);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\client\exe\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 24-Jan-2002

------------------------------------------------------------------------------*/

#include <xtl.h>
#include <xlog.h>

#include "main.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\client\client.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.h

Abstract:

  This module contains the definitions for client.c

Author:

  Steven Kehrli (steveke) 5-Feb-2002

------------------------------------------------------------------------------*/

#pragma once



namespace XNetStressNamespace {



// Function prototypes

VOID
StressTest(
    IN HANDLE  hLog
);

} // namespace XNetStressNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\client\client.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  client.c

Abstract:

  Entry points for xnetstress.dll

Author:

  Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetStressNamespace;

namespace XNetStressNamespace {

VOID
WINAPI
StartTest(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Test entry point

Arguments:

  hLog - handle to the xLog log object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Run the test
    StressTest(hLog);
}



VOID
WINAPI
EndTest(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Test exit point

Return Value:

  None

------------------------------------------------------------------------------*/
{
}

} // namespace XNetStressNamespace



#ifdef __cplusplus
extern "C" {
#endif

// Export table for harness

#pragma data_seg(EXPORT_SECTION_NAME)
DECLARE_EXPORT_DIRECTORY(xnetstress)
#pragma data_seg()

BEGIN_EXPORT_TABLE(xnetstress)
    EXPORT_TABLE_ENTRY("StartTest", StartTest)
    EXPORT_TABLE_ENTRY("EndTest", EndTest)
END_EXPORT_TABLE(xnetstress)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\client\util.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.h

Abstract:

  This module contains the definitions for util.c

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#pragma once



namespace XNetStressNamespace {

LPSTR
GetIniString(
    HANDLE  hMemObject,
    LPCSTR  lpszSectionName,
    LPCSTR  lpszKeyName
);

} // namespace XNetStressNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\server\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 5-Oct-2000

------------------------------------------------------------------------------*/

#ifdef _XBOX

#include <xtl.h>
#include <xtestlib.h>
#include <xnetref.h>
#include <xlog.h>

#else

#include <windows.h>
#include <winsock2.h>

#endif

#include <xmem.h>
#include <netsync.h>

#include "stress.h"
#include "server.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\server\server.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright Microsoft Corporation

Module Name:

  server.c

Abstract:

  This modules contains the server side exports

Author:

  Steven Kehrli (steveke) 17-Apr-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef _XBOX

#ifdef __cplusplus
extern "C" {
#endif

//
// Netsync export table for syncsrv
//
#pragma data_seg(NETSYNC_EXPORT_SECTION_NAME)
DECLARE_NETSYNC_EXPORT_DIRECTORY(xnetstress_xbox)
#pragma data_seg()

BEGIN_NETSYNC_EXPORT_TABLE(xnetstress_xbox)
    NETSYNC_EXPORT_TABLE_ENTRY( "XNetStressMain",        XNetStressMain        )
    NETSYNC_EXPORT_TABLE_ENTRY( "XNetStressStart",       XNetStressStart       )
    NETSYNC_EXPORT_TABLE_ENTRY( "XNetStressStop",        XNetStressStop        )
    NETSYNC_EXPORT_TABLE_ENTRY( "XNetStressStatusMain",  XNetStressStatusMain  )
    NETSYNC_EXPORT_TABLE_ENTRY( "XNetStressStatusStart", XNetStressStatusStart )
    NETSYNC_EXPORT_TABLE_ENTRY( "XNetStressStatusStop",  XNetStressStatusStop  )
END_NETSYNC_EXPORT_TABLE(xnetstress_xbox)

#ifdef __cplusplus
}
#endif

#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\client\stress.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright Microsoft Corporation

Module Name:

  stress.c

Abstract:

  This module tests XNet stress - library

Author:

  Steven Kehrli (steveke) 17-Apr-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetStressNamespace;

namespace XNetStressNamespace {

#define LARGE_TCP_BUFFER            5672
#define LARGE_UDP_BUFFER            1430
#define LARGE_BUFFER                __max(LARGE_TCP_BUFFER, LARGE_UDP_BUFFER)

int     nTCPBufferSize[3]           = {10, LARGE_TCP_BUFFER, 0};
int     nUDPBufferSize[3]           = {10, LARGE_UDP_BUFFER, 0};
#define nTCPBufferSizes             sizeof(nTCPBufferSize) / sizeof(nTCPBufferSize[0])
#define nUDPBufferSizes             sizeof(nUDPBufferSize) / sizeof(nUDPBufferSize[0])

#define CONNECT_FUNC                1
#define ACCEPT_FUNC                 2
#define SEND_RECV_FUNC              3
#define WSASEND_WSARECV_FUNC        4
#define SENDTO_RECVFROM_FUNC        5
#define WSASENDTO_WSARECVFROM_FUNC  6

#define OVERLAPPED_NONE             0
#define OVERLAPPED_WAIT             1
#define OVERLAPPED_RESULT           2
#define OVERLAPPED_CANCEL           3

#define STATE_ANY_DATA              0
#define STATE_SEND_DATA             1
#define STATE_RECV_DATA             2



typedef struct _STRESS_THREAD {
    u_short  uIndex;
    HANDLE   hExitEvent;
    int      socket_type;
    BOOL     bNonblocking;
    in_addr  sin_addr;
    u_short  sin_port;
    BOOL     bListen;
    DWORD    dwFunction;
    BOOL     bOverlapped;
    DWORD    dwOverlapped;
} STRESS_THREAD, *PSTRESS_THREAD;

static STRESS_THREAD StressThreads1[] =
{
    {   1, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  ACCEPT_FUNC,                FALSE, OVERLAPPED_NONE   },
    {   2, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  SEND_RECV_FUNC,             FALSE, OVERLAPPED_NONE   },
    {   3, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       FALSE, OVERLAPPED_NONE   },
    {   4, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_WAIT   },
    {   5, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_RESULT },
    {   6, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_CANCEL },
    {   7, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  SENDTO_RECVFROM_FUNC,       FALSE, OVERLAPPED_NONE   },
    {   8, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, FALSE, OVERLAPPED_NONE   },
    {   9, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_WAIT   },
    {  10, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_RESULT },
    {  11, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_CANCEL },
    {  12, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  ACCEPT_FUNC,                FALSE, OVERLAPPED_NONE   },
    {  13, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  SEND_RECV_FUNC,             FALSE, OVERLAPPED_NONE   },
    {  14, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       FALSE, OVERLAPPED_NONE   },
    {  15, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_WAIT   },
    {  16, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_RESULT },
    {  17, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_CANCEL },
    {  18, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  SENDTO_RECVFROM_FUNC,       FALSE, OVERLAPPED_NONE   },
    {  19, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, FALSE, OVERLAPPED_NONE   },
    {  20, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_WAIT   },
    {  21, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_RESULT },
    {  22, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_CANCEL },
    {  23, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, CONNECT_FUNC,               FALSE, OVERLAPPED_NONE   },
    {  24, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, SEND_RECV_FUNC,             FALSE, OVERLAPPED_NONE   },
    {  25, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       FALSE, OVERLAPPED_NONE   },
    {  26, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_WAIT   },
    {  27, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_RESULT },
    {  28, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_CANCEL },
    {  29, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, SENDTO_RECVFROM_FUNC,       FALSE, OVERLAPPED_NONE   },
    {  30, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, FALSE, OVERLAPPED_NONE   },
    {  31, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_WAIT   },
    {  32, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_RESULT },
    {  33, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_CANCEL },
    {  34, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, CONNECT_FUNC,               FALSE, OVERLAPPED_NONE   },
    {  35, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, SEND_RECV_FUNC,             FALSE, OVERLAPPED_NONE   },
    {  36, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       FALSE, OVERLAPPED_NONE   },
    {  37, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_WAIT   },
    {  38, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_RESULT },
    {  39, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_CANCEL },
    {  40, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, SENDTO_RECVFROM_FUNC,       FALSE, OVERLAPPED_NONE   },
    {  41, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, FALSE, OVERLAPPED_NONE   },
    {  42, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_WAIT   },
    {  43, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_RESULT },
    {  44, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_CANCEL },
    {  45, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, SEND_RECV_FUNC,             FALSE, OVERLAPPED_NONE   },
    {  46, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       FALSE, OVERLAPPED_NONE   },
    {  47, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_WAIT   },
    {  48, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_RESULT },
    {  49, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_CANCEL },
    {  50, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, SENDTO_RECVFROM_FUNC,       FALSE, OVERLAPPED_NONE   },
    {  51, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, FALSE, OVERLAPPED_NONE   },
    {  52, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_WAIT   },
    {  53, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_RESULT },
    {  54, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_CANCEL }
};

static STRESS_THREAD StressThreads2[] =
{
    { 101, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, CONNECT_FUNC,               FALSE, OVERLAPPED_NONE   },
    { 102, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, SEND_RECV_FUNC,             FALSE, OVERLAPPED_NONE   },
    { 103, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       FALSE, OVERLAPPED_NONE   },
    { 104, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_WAIT   },
    { 105, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_RESULT },
    { 106, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_CANCEL },
    { 107, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, SENDTO_RECVFROM_FUNC,       FALSE, OVERLAPPED_NONE   },
    { 108, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, FALSE, OVERLAPPED_NONE   },
    { 109, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_WAIT   },
    { 110, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_RESULT },
    { 111, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_CANCEL },
    { 112, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, CONNECT_FUNC,               FALSE, OVERLAPPED_NONE   },
    { 113, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, SEND_RECV_FUNC,             FALSE, OVERLAPPED_NONE   },
    { 114, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       FALSE, OVERLAPPED_NONE   },
    { 115, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_WAIT   },
    { 116, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_RESULT },
    { 117, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_CANCEL },
    { 118, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, SENDTO_RECVFROM_FUNC,       FALSE, OVERLAPPED_NONE   },
    { 119, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, FALSE, OVERLAPPED_NONE   },
    { 120, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_WAIT   },
    { 121, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_RESULT },
    { 122, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_CANCEL },
    { 123, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  ACCEPT_FUNC,                FALSE, OVERLAPPED_NONE   },
    { 124, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  SEND_RECV_FUNC,             FALSE, OVERLAPPED_NONE   },
    { 125, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       FALSE, OVERLAPPED_NONE   },
    { 126, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_WAIT   },
    { 127, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_RESULT },
    { 128, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_CANCEL },
    { 129, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  SENDTO_RECVFROM_FUNC,       FALSE, OVERLAPPED_NONE   },
    { 130, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, FALSE, OVERLAPPED_NONE   },
    { 131, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_WAIT   },
    { 132, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_RESULT },
    { 133, NULL, SOCK_STREAM, FALSE, { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_CANCEL },
    { 134, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  ACCEPT_FUNC,                FALSE, OVERLAPPED_NONE   },
    { 135, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  SEND_RECV_FUNC,             FALSE, OVERLAPPED_NONE   },
    { 136, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       FALSE, OVERLAPPED_NONE   },
    { 137, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_WAIT   },
    { 138, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_RESULT },
    { 139, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_CANCEL },
    { 140, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  SENDTO_RECVFROM_FUNC,       FALSE, OVERLAPPED_NONE   },
    { 141, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, FALSE, OVERLAPPED_NONE   },
    { 142, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_WAIT   },
    { 143, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_RESULT },
    { 144, NULL, SOCK_STREAM, TRUE,  { 0, 0, 0, 0}, 0, TRUE,  WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_CANCEL },
    { 145, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, SEND_RECV_FUNC,             FALSE, OVERLAPPED_NONE   },
    { 146, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       FALSE, OVERLAPPED_NONE   },
    { 147, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_WAIT   },
    { 148, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_RESULT },
    { 149, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASEND_WSARECV_FUNC,       TRUE,  OVERLAPPED_CANCEL },
    { 150, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, SENDTO_RECVFROM_FUNC,       FALSE, OVERLAPPED_NONE   },
    { 151, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, FALSE, OVERLAPPED_NONE   },
    { 152, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_WAIT   },
    { 153, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_RESULT },
    { 154, NULL, SOCK_DGRAM,  FALSE, { 0, 0, 0, 0}, 0, FALSE, WSASENDTO_WSARECVFROM_FUNC, TRUE,  OVERLAPPED_CANCEL }
};

#define StressThreadCount1      (sizeof(StressThreads1) / sizeof(STRESS_THREAD))
#define StressThreadCount2      (sizeof(StressThreads2) / sizeof(STRESS_THREAD))
#define StressThreadCountEqual  (StressThreadCount1 == StressThreadCount2)
#define StressThreadCount       __max(StressThreadCount1, StressThreadCount2)

NETSYNC_TYPE_CALLBACK  XNetStressSessionNt =
{
    1,
    NUM_STRESS_CLIENTS,
    StressThreadCount,
    L"xnetstress_nt.dll",
    "XNetStressMain",
    "XNetStressStart",
    "XNetStressStop"
};

NETSYNC_TYPE_CALLBACK  XNetStressSessionXbox =
{
    1,
    NUM_STRESS_CLIENTS,
    StressThreadCount,
    L"xnetstress_xbox.dll",
    "XNetStressMain",
    "XNetStressStart",
    "XNetStressStop"
};



SOCKET
CreateSocket(
    IN PSTRESS_THREAD  pStressThread
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Creates and binds a socket

Arguments:

  pStressThread - Pointer to the stress thread object

Return Value:

  SOCKET:
    If the function succeeds, the return value is a socket descriptor
    If the function fails, the return value is INVALID_SOCKET.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // sSocket is the socket descriptor
    SOCKET       sSocket;

    // dwSendBufferSize and dwRecvBufferSize are the size of the send and receive buffers
    DWORD        dwSendBufferSize;
    DWORD        dwRecvBufferSize;

    // dwSendTimeout and dwRecvTimeout are the send and receive timeouts
    DWORD        dwSendTimeout;
    DWORD        dwRecvTimeout;

    // bNagle indicates if Nagle is on (TRUE) or off (FALSE)
    BOOL         bNagle;

    // localname is the local host name
    SOCKADDR_IN  localname;



    // Seed the pseudorandom-number generator
    srand(GetTickCount());

    // Create the socket
    sSocket = INVALID_SOCKET;
    sSocket = socket(AF_INET, pStressThread->socket_type, 0);

    // Set the blocking mode of the socket
    ioctlsocket(sSocket, FIONBIO, (u_long *) &pStressThread->bNonblocking);

    // Set the size of the send and receive buffers
    dwSendBufferSize = (rand() % 0x2000) + 1;  // Range is 1 to 8192 (bytes)
    dwRecvBufferSize = (rand() % 0x2000) + 1;  // Range is 1 to 8192 (bytes)
    setsockopt(sSocket, SOL_SOCKET, SO_SNDBUF, (char *) &dwSendBufferSize, sizeof(dwSendBufferSize));
    setsockopt(sSocket, SOL_SOCKET, SO_RCVBUF, (char *) &dwRecvBufferSize, sizeof(dwRecvBufferSize));

    // Set the send and receive timeout
    dwSendTimeout = (rand() % 59) + 1;         // Range is 1 to 60 (seconds)
    dwRecvTimeout = (rand() % 59) + 1;         // Range is 1 to 60 (seconds)
    setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &dwSendTimeout, sizeof(dwSendTimeout));
    setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &dwRecvTimeout, sizeof(dwRecvTimeout));

    // Enable or disable Nagle
    bNagle = rand() % 1;                       // Range is 0 or 1
    setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &bNagle, sizeof(bNagle));

    // Bind the socket
    ZeroMemory(&localname, sizeof(localname));
    localname.sin_family = AF_INET;
    localname.sin_port = htons(pStressThread->sin_port);
    bind(sSocket, (SOCKADDR *) &localname, sizeof(localname));

    return sSocket;
}



DWORD
ConnectThread(
    IN LPVOID  lpv
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Thread to handle the connect logic

Arguments:

  lpv - Pointer to the STRESS_THREAD

------------------------------------------------------------------------------*/
{
    // pStressThread is a pointer to the STRESS_THREAD object
    PSTRESS_THREAD  pStressThread = (PSTRESS_THREAD) lpv;

    // sSocket is the socket descriptor
    SOCKET          sSocket;

    // remotename is the remote host name
    SOCKADDR_IN     remotename;

    // writefds is the set of sockets for write
    fd_set          writefds;
    // exceptfds is the set of sockets for write
    fd_set          exceptfds;
    // select_timeout is the timeout for select
    timeval         select_timeout;
    // iResult is the result of the operation
    int             iResult;



    do {
        // Create the socket
        sSocket = CreateSocket(pStressThread);;

        // Initialize the remote name
        ZeroMemory(&remotename, sizeof(remotename));
        remotename.sin_family = AF_INET;
        remotename.sin_addr = pStressThread->sin_addr;
        remotename.sin_port = htons(pStressThread->sin_port);

        // Connect the socket
        iResult = connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));

        if (TRUE == pStressThread->bNonblocking) {
            do {
                // Wait for the connection
                FD_ZERO(&writefds);
                FD_ZERO(&exceptfds);
                FD_SET(sSocket, &writefds);
                FD_SET(sSocket, &exceptfds);

                select_timeout.tv_sec = 60;
                select_timeout.tv_usec = 0;

                select(0, NULL, &writefds, &exceptfds, &select_timeout);
            } while ((0 == FD_ISSET(sSocket, &exceptfds)) && (0 == FD_ISSET(sSocket, &writefds)) && (WAIT_OBJECT_0 != WaitForSingleObject(pStressThread->hExitEvent, 0)));
        }

        // Close the socket
        if (INVALID_SOCKET != sSocket) {
            shutdown(sSocket, SD_BOTH);
            closesocket(sSocket);
        }
    } while (WAIT_OBJECT_0 != WaitForSingleObject(pStressThread->hExitEvent, 0));

    return 0;
}



DWORD
AcceptThread(
    IN LPVOID  lpv
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Thread to handle the accept logic

Arguments:

  lpv - Pointer to the STRESS_THREAD

------------------------------------------------------------------------------*/
{
    // pStressThread is a pointer to the STRESS_THREAD object
    PSTRESS_THREAD  pStressThread = (PSTRESS_THREAD) lpv;

    // sSocket and nsSocket are the socket descriptors
    SOCKET          sSocket;
    SOCKET          nsSocket;

    // readfds is the set of sockets for read
    fd_set          readfds;
    // select_timeout is the timeout for select
    timeval         select_timeout;
    // iResult is the result of the operation
    int             iResult;



    // Create the socket
    sSocket = CreateSocket(pStressThread);

    // Place the socket in listening mode
    listen(sSocket, SOMAXCONN);

    do {
        do {
            // Wait for a connection
            FD_ZERO(&readfds);
            FD_SET(sSocket, &readfds);

            select_timeout.tv_sec = 60;
            select_timeout.tv_usec = 0;

            select(0, &readfds, NULL, NULL, &select_timeout);
        } while ((0 == FD_ISSET(sSocket, &readfds)) && (WAIT_OBJECT_0 != WaitForSingleObject(pStressThread->hExitEvent, 0)));

        if (WAIT_OBJECT_0 == WaitForSingleObject(pStressThread->hExitEvent, 0)) {
            goto AcceptLoopEnd;
        }

        // Accept the connection
        nsSocket = INVALID_SOCKET;
        nsSocket = accept(sSocket, NULL, NULL);

AcceptLoopEnd:
        // Close the socket
        if (INVALID_SOCKET != nsSocket) {
            shutdown(nsSocket, SD_BOTH);
            closesocket(nsSocket);
        }
    } while (WAIT_OBJECT_0 != WaitForSingleObject(pStressThread->hExitEvent, 0));

    // Close the socket
    closesocket(sSocket);

    return 0;
}



DWORD
SendReceiveThread(
    IN LPVOID  lpv
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Thread to handle the send/receive logic

Arguments:

  lpv - Pointer to the STRESS_THREAD

------------------------------------------------------------------------------*/
{
    // pStressThread is a pointer to the STRESS_THREAD object
    PSTRESS_THREAD  pStressThread = (PSTRESS_THREAD) lpv;

    // sSocket and nsSocket are the socket descriptors
    SOCKET          sSocket = INVALID_SOCKET;
    SOCKET          nsSocket = INVALID_SOCKET;

    // StressSendBuffer is the send buffer
    char            StressSendBuffer[LARGE_BUFFER];
    // StressReceiveBuffer is the receive buffer
    char            StressReceiveBuffer[LARGE_BUFFER];

    // remotename is the remote host name
    SOCKADDR_IN     remotename;
    // fromname is the remote sender name
    SOCKADDR_IN     fromname;
    // fromnamelen is the size of the remote send name
    int             fromnamelen;

    // readfds is the set of sockets for read
    fd_set          readfds;
    // writefds is the set of sockets for write
    fd_set          writefds;
    // exceptfds is the set of sockets for write
    fd_set          exceptfds;
    // select_timeout is the timeout for select
    timeval         select_timeout;
    // iResult is the result of the operation
    int             iResult;

    // dwStartTime is the start time of the send/receive loop
    DWORD           dwStartTime;
    // dwRunTime is the run time of the send/receive loop
    DWORD           dwRunTime;

    // nStressBufferSize is the stress buffer size
    int             *nStressBufferSize;
    // nStressBufferSizes is the number of stress buffer sizes
    int             nStressBufferSizes;
    // dwBufferIndex is a counter to enumerate the stress buffer sizes
    DWORD           dwBufferIndex;
    // dwIndex is a counter
    DWORD           dwIndex;

    // WSASendBuf is the send buffer
    WSABUF          WSASendBuf;
    // WSARecvBuf is the receive buffer
    WSABUF          WSARecvBuf;
    // dwBytesSent is the number of bytes sent
    DWORD           dwBytesSent;
    // dwBytesReceived is the number of bytes received
    DWORD           dwBytesReceived;
    // WSASendOverlapped is the send overlapped i/o structure
    WSAOVERLAPPED   WSASendOverlapped;
    // WSARecvOverlapped is the receive overlapped i/o structure
    WSAOVERLAPPED   WSARecvOverlapped;
    // hSendEvent is a handle to the send overlapped i/o event
    HANDLE          hSendEvent;
    // hRecvEvent is a handle to the receive overlapped i/o event
    HANDLE          hRecvEvent;
    // dwFlags is the flags of the send/receive operation
    DWORD           dwFlags;
    // dwBytes is the number of bytes in the buffer
    DWORD           dwBytes;



    // Seed the pseudorandom-number generator
    srand(GetTickCount());

    // Initialize the stress buffer
    for (dwIndex = 0; dwIndex < sizeof(StressSendBuffer); dwIndex++) {
        StressSendBuffer[dwIndex] = (char) (dwIndex % 256);
    }

    // Initialize the stress buffer sizes
    if (SOCK_STREAM == pStressThread->socket_type) {
        nStressBufferSize = nTCPBufferSize;
        nStressBufferSizes = nTCPBufferSizes;
    }
    else {
        nStressBufferSize = nUDPBufferSize;
        nStressBufferSizes = nUDPBufferSizes;
    }

    // Initialize the overlapped i/o structures
    if (TRUE == pStressThread->bOverlapped) {
        hSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        hRecvEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        ZeroMemory(&WSASendOverlapped, sizeof(WSASendOverlapped));
        ZeroMemory(&WSARecvOverlapped, sizeof(WSARecvOverlapped));

        WSASendOverlapped.hEvent = hSendEvent;
        WSARecvOverlapped.hEvent = hRecvEvent;
    }
    else {
        hSendEvent = NULL;
        hRecvEvent = NULL;
    }

    do {
        if (INVALID_SOCKET == sSocket) {
            // Create the socket
            sSocket = CreateSocket(pStressThread);

            // Place the socket in listening mode
            if (TRUE == pStressThread->bListen) {
                listen(sSocket, SOMAXCONN);
            }
        }

        // Initialize the remote name
        ZeroMemory(&remotename, sizeof(remotename));
        remotename.sin_family = AF_INET;
        remotename.sin_addr = pStressThread->sin_addr;
        remotename.sin_port = htons(pStressThread->sin_port);

        if ((SOCK_STREAM == pStressThread->socket_type) && (TRUE == pStressThread->bListen)) {
            do {
                // Wait for a connection
                FD_ZERO(&readfds);
                FD_SET(sSocket, &readfds);

                select_timeout.tv_sec = 60;
                select_timeout.tv_usec = 0;

                select(0, &readfds, NULL, NULL, &select_timeout);
            } while ((0 == FD_ISSET(sSocket, &readfds)) && (WAIT_OBJECT_0 != WaitForSingleObject(pStressThread->hExitEvent, 0)));

            if (WAIT_OBJECT_0 == WaitForSingleObject(pStressThread->hExitEvent, 0)) {
                goto SendReceiveLoopEnd;
            }

            // Accept the connection
            nsSocket = accept(sSocket, NULL, NULL);
        }
        else if ((SOCK_STREAM == pStressThread->socket_type) || (SEND_RECV_FUNC == pStressThread->dwFunction) || (WSASEND_WSARECV_FUNC == pStressThread->dwFunction)) {
            // Connect the socket
            iResult = connect(sSocket, (SOCKADDR *) &remotename, sizeof(remotename));

            if ((SOCK_STREAM == pStressThread->socket_type) && (TRUE == pStressThread->bNonblocking)) {
                do {
                    // Wait for the connection
                    FD_ZERO(&writefds);
                    FD_ZERO(&exceptfds);
                    FD_SET(sSocket, &writefds);
                    FD_SET(sSocket, &exceptfds);

                    select_timeout.tv_sec = 60;
                    select_timeout.tv_usec = 0;

                    select(0, NULL, &writefds, &exceptfds, &select_timeout);
                } while ((0 == FD_ISSET(sSocket, &exceptfds)) && (0 == FD_ISSET(sSocket, &writefds)) && (WAIT_OBJECT_0 != WaitForSingleObject(pStressThread->hExitEvent, 0)));

                if (1 == FD_ISSET(sSocket, &exceptfds)) {
                    iResult = SOCKET_ERROR;
                }
                else {
                    iResult = 0;
                }
            }

            if ((WAIT_OBJECT_0 == WaitForSingleObject(pStressThread->hExitEvent, 0)) || (SOCKET_ERROR == iResult)) {
                goto SendReceiveLoopEnd;
            }
        }

        // Initialize the buffer index
        dwBufferIndex = (rand() % nStressBufferSizes);

        // Get the run time
        dwRunTime = (rand() % 6) + 1;          // Range is 1 to 6 (5 minute intervals)
        dwRunTime = dwRunTime * 5;             // Range is 5, 10, 15, 20, 25, or 30 (minutes)
        dwRunTime = dwRunTime * 60 * 1000;     // Range is 300000, 600000, 900000, 1200000, 1500000, 1800000 (milli-seconds)

        // Get the start time
        dwStartTime = GetTickCount();

        do {
            if (WAIT_OBJECT_0 == WaitForSingleObject(pStressThread->hExitEvent, 0)) {
                goto SendReceiveLoopEnd;
            }

            // Check for the write
            FD_ZERO(&writefds);
            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &writefds);

            select_timeout.tv_sec = 0;
            select_timeout.tv_usec = 0;

            select(0, NULL, &writefds, NULL, &select_timeout);

            // Send
            if (SEND_RECV_FUNC == pStressThread->dwFunction) {
                iResult = send((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, StressSendBuffer, nStressBufferSize[dwBufferIndex], 0);
            }
            else if (WSASEND_WSARECV_FUNC == pStressThread->dwFunction) {
                WSASendBuf.buf = StressSendBuffer;
                WSASendBuf.len = nStressBufferSize[dwBufferIndex];
                iResult = WSASend((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSASendBuf, 1, &dwBytesSent, 0, (TRUE == pStressThread->bOverlapped) ? &WSASendOverlapped : NULL, NULL);
            }
            else if (SENDTO_RECVFROM_FUNC == pStressThread->dwFunction) {
                iResult = sendto((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, StressSendBuffer, nStressBufferSize[dwBufferIndex], 0, (SOCKADDR *) &remotename, sizeof(remotename));
            }
            else {
                WSASendBuf.buf = StressSendBuffer;
                WSASendBuf.len = nStressBufferSize[dwBufferIndex];
                iResult = WSASendTo((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSASendBuf, 1, &dwBytesSent, 0, (SOCKADDR *) &remotename, sizeof(remotename), (TRUE == pStressThread->bOverlapped) ? &WSASendOverlapped : NULL, NULL);
            }

            if ((SOCKET_ERROR == iResult) && (WSAECONNRESET == WSAGetLastError())) {
                goto SendReceiveLoopEnd;
            }

            // Overlapped I/O
            if (TRUE == pStressThread->bOverlapped) {
                if (OVERLAPPED_WAIT == pStressThread->dwOverlapped) {
                    // Wait for event
                    WaitForSingleObject(WSASendOverlapped.hEvent, 60 * 1000);
                }
                else if (OVERLAPPED_RESULT == pStressThread->dwOverlapped) {
                    for (dwIndex = 0; dwIndex < 60; dwIndex++) {
                        dwFlags = 0;
                        if (TRUE == WSAGetOverlappedResult((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSASendOverlapped, &dwBytesSent, FALSE, &dwFlags)) {
                            break;
                        }

                        if (WAIT_OBJECT_0 == WaitForSingleObject(pStressThread->hExitEvent, 0)) {
                            break;
                        }

                        Sleep(1000);
                    }
                }
                else {
                    // Cancel overlapped i/o
                    WSACancelOverlappedIO((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket);
                }
            }

            if (WAIT_OBJECT_0 == WaitForSingleObject(pStressThread->hExitEvent, 0)) {
                goto SendReceiveLoopEnd;
            }

            // Check for the read
            FD_ZERO(&readfds);
            FD_SET((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &readfds);

            select_timeout.tv_sec = 0;
            select_timeout.tv_usec = 0;

            select(0, &readfds, NULL, NULL, &select_timeout);

            // Receive
            if (SEND_RECV_FUNC == pStressThread->dwFunction) {
                iResult = recv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, StressReceiveBuffer, nStressBufferSize[dwBufferIndex], 0);
            }
            else if (WSASEND_WSARECV_FUNC == pStressThread->dwFunction) {
                WSARecvBuf.buf = StressReceiveBuffer;
                WSARecvBuf.len = nStressBufferSize[dwBufferIndex];
                dwFlags = 0;
                iResult = WSARecv((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSARecvBuf, 1, &dwBytesReceived, &dwFlags, (TRUE == pStressThread->bOverlapped) ? &WSARecvOverlapped : NULL, NULL);
            }
            else if (SENDTO_RECVFROM_FUNC == pStressThread->dwFunction) {
                fromnamelen = sizeof(fromname);
                iResult = recvfrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, StressReceiveBuffer, nStressBufferSize[dwBufferIndex], 0, (SOCKADDR *) &fromname, &fromnamelen);
            }
            else {
                WSARecvBuf.buf = StressReceiveBuffer;
                WSARecvBuf.len = nStressBufferSize[dwBufferIndex];
                dwFlags = 0;
                fromnamelen = sizeof(fromname);
                iResult = WSARecvFrom((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSARecvBuf, 1, &dwBytesReceived, &dwFlags, (SOCKADDR *) &fromname, &fromnamelen, (TRUE == pStressThread->bOverlapped) ? &WSARecvOverlapped : NULL, NULL);
            }

            if ((SOCKET_ERROR == iResult) && (WSAECONNRESET == WSAGetLastError())) {
                goto SendReceiveLoopEnd;
            }

            // Overlapped I/O
            if (TRUE == pStressThread->bOverlapped) {
                if (OVERLAPPED_WAIT == pStressThread->dwOverlapped) {
                    // Wait for event
                    WaitForSingleObject(WSARecvOverlapped.hEvent, 60 * 1000);
                }
                else if (OVERLAPPED_RESULT == pStressThread->dwOverlapped) {
                    for (dwIndex = 0; dwIndex < 60; dwIndex++) {
                        dwFlags = 0;
                        if (TRUE == WSAGetOverlappedResult((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, &WSARecvOverlapped, &dwBytesReceived, FALSE, &dwFlags)) {
                            break;
                        }
                        
                        if (WAIT_OBJECT_0 == WaitForSingleObject(pStressThread->hExitEvent, 0)) {
                            break;
                        }

                        Sleep(1000);
                    }
                }
                else {
                    // Cancel overlapped i/o
                    WSACancelOverlappedIO((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket);
                }
            }

            // Check the amount of read data
            ioctlsocket((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, FIONREAD, &dwBytes);

            // Increment the buffer index
            dwBufferIndex = (dwBufferIndex + 1) % nStressBufferSizes;

            // Surrender quantum
            Sleep(0);
        } while ((dwRunTime > (GetTickCount() - dwStartTime)) && (WAIT_OBJECT_0 != WaitForSingleObject(pStressThread->hExitEvent, 0)));

SendReceiveLoopEnd:
        // Shutdown the socket
        if (SOCK_STREAM == pStressThread->socket_type) {
            shutdown((INVALID_SOCKET == nsSocket) ? sSocket : nsSocket, SD_BOTH);
        }

        // Close the sockets
        if (INVALID_SOCKET != nsSocket) {
            closesocket(nsSocket);
            nsSocket = INVALID_SOCKET;
        }

        if (FALSE == pStressThread->bListen) {
            closesocket(sSocket);
            sSocket = INVALID_SOCKET;
        }
    } while (WAIT_OBJECT_0 != WaitForSingleObject(pStressThread->hExitEvent, 0));

    // Close the socket
    if (INVALID_SOCKET != sSocket) {
        closesocket(sSocket);
    }

    // Close send/receive overlapped i/o events
    if (NULL != hRecvEvent) {
        CloseHandle(hRecvEvent);
    }

    if (NULL != hSendEvent) {
        CloseHandle(hSendEvent);
    }

    return 0;
}



VOID
StressTest(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Test entry point

Arguments:

  hLog - handle to the xLog log object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // hMemObject is the mem object
    HANDLE                  hMemObject = INVALID_HANDLE_VALUE;

    // bXnetInitialized indicates if Xnet is initialized
    BOOL                    bXnetInitialized = FALSE;
    // WSAData is the Winsock init data
    WSADATA                 WSAData;
    // bWinsockInitialized indicated is Winsock is initialized
    BOOL                    bWinsockInitialized = FALSE;

    // hNetsyncObject is a handle to the netsync object
    HANDLE                  hNetsyncObject = INVALID_HANDLE_VALUE;
    // NetsyncTypeSession is the session type descriptor
    NETSYNC_TYPE_CALLBACK   NetsyncTypeSession;
    // bSecure indicates if remote netsync server is secure or insecure
    BOOL                    bSecure = FALSE;
    // lpszNetsyncRemote is a pointer to the remote netsync server
    LPSTR                   lpszNetsyncRemote = NULL;
    // lpszRemote is a pointer to the remote netsync server type
    LPSTR                   lpszRemote = NULL;
    // NetsyncInAddr is the netsync server address
    u_long                  NetsyncInAddr = 0;
    // LowPort is the low bound of the netsync port range
    u_short                 LowPort = 0;
    // HighPort is the high bound of the netsync port range
    u_short                 HighPort = 0;
    // FromInAddr is the address of the netsync sender
    u_long                  FromInAddr;
    // dwMessageType is the type of received message
    DWORD                   dwMessageType;
    // dwMessageSize is the size of the received message
    DWORD                   dwMessageSize;
    // pMessage is a pointer to the received message
    char                    *pMessage;
    // StressSessionMessage is a message sent to/received from the stress session
    STRESS_SESSION_MESSAGE  StressSessionMessage;

    // sin_addr is the in_addr structure
    IN_ADDR                 sin_addr;
    // RemoteInAddr is the address of the remote host
    u_long                  RemoteInAddr;
    // RemoteXnAddr is the xnet address of the remote host
    XNADDR                  RemoteXnAddr;
    // XnKid is the xnet key id
    XNKID                   XnKid;
    // XnKid is the xnet key
    XNKEY                   XnKey;
    // bKeyPairOwner indicates this client owns the key-pair
    BOOL                    bKeyPairOwner;

    // hExitEvent is a handle to the exit event
    HANDLE                  hExitEvent = NULL;
    // hThreads is an array of the stress thread handles
    HANDLE                  hThreads[StressThreadCount];
    // uIndex is a counter to enumerate the stress threads
    u_short                 uIndex;



    // Set the xLog info
    xSetComponent(hLog, "Network", "XNet");
    xSetFunctionName(hLog, "Stress");
    xStartVariation(hLog, "Stress Test");

    if (FALSE == StressThreadCountEqual) {
        xLog(hLog, XLL_FAIL, "Stress thread count is not equal");

        goto FunctionExit;
    }

    // Create the private heap
    hMemObject = xMemCreate();
    if (INVALID_HANDLE_VALUE == hMemObject) {
        xLog(hLog, XLL_FAIL, "xMemCreate failed - ec: %u", GetLastError());

        goto FunctionExit;
    }

    // Get the remote info
    bSecure = (BOOL) GetProfileIntA("xnetstress", "bSecure", 0);
    if (FALSE == bSecure) {
        lpszNetsyncRemote = GetIniString(hMemObject, "xnetstress", "Secure");
    }

    lpszRemote = GetIniString(hMemObject, "xnetstress", "Remote");
    if ((NULL != lpszRemote) && (0 == strcmp("xbox", lpszRemote))) {
        NetsyncTypeSession = XNetStressSessionXbox;
    }
    else {
        NetsyncTypeSession = XNetStressSessionNt;
    }

    // Create the exit event
    hExitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == hExitEvent) {
        xLog(hLog, XLL_FAIL, "CreateEvent failed - ec: %u", GetLastError());

        goto FunctionExit;
    }

    while (TRUE) {
        // Initialize Xnet
        if (0 == XNetAddRef()) {
            break;
        }
        bXnetInitialized = TRUE;

        // Initialize Winsock
        if (0 != WSAStartup(MAKEWORD(2, 2), &WSAData)) {
            break;
        }
        bWinsockInitialized = TRUE;

        // Initialize the key-pair
        ZeroMemory(&XnKid, sizeof(XnKid));
        ZeroMemory(&XnKey, sizeof(XnKey));
        bKeyPairOwner = FALSE;

        // Connect to the stress session
        hNetsyncObject = NetsyncCreateClient((NULL != lpszNetsyncRemote) ? inet_addr(lpszNetsyncRemote) : 0, NETSYNC_SESSION_CALLBACK, &XNetStressSessionNt, &NetsyncInAddr, NULL, &LowPort, &HighPort);
        if (INVALID_HANDLE_VALUE == hNetsyncObject) {
            xLog(hLog, XLL_FAIL, "Connect Netsync session failed - ec: 0x%08x", GetLastError());

            break;
        }

        while (WAIT_OBJECT_0 != WaitForSingleObject(hExitEvent, 0)) {
            // Send a keep-alive message
            ZeroMemory(&StressSessionMessage, sizeof(StressSessionMessage));
            StressSessionMessage.dwMessageId = CLIENT_KEEPALIVE_MSG;
            if (WAIT_OBJECT_0 != NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(StressSessionMessage), (char *) &StressSessionMessage)) {
                xLog(hLog, XLL_FAIL, "Send Keep-Alive failed - ec: 0x%08x", GetLastError());

                break;
            }

            // Check for messages
            if (WAIT_OBJECT_0 == NetsyncReceiveMessage(hNetsyncObject, 60000, &dwMessageType, &FromInAddr, NULL, &dwMessageSize, &pMessage)) {
                if (SERVER_KEYPAIR_MSG == ((PSTRESS_SESSION_MESSAGE) pMessage)->dwMessageId) {
                    if (FALSE == bKeyPairOwner) {
                        // Create and register the key pair
                        XNetCreateKey(&XnKid, &XnKey);
                        XNetRegisterKey(&XnKid, &XnKey);
                        bKeyPairOwner = TRUE;
                    }

                    // Send the key-pair message
                    ZeroMemory(&StressSessionMessage, sizeof(StressSessionMessage));
                    StressSessionMessage.dwMessageId = CLIENT_KEYPAIR_MSG;
                    CopyMemory(&StressSessionMessage.XnKid, &XnKid, sizeof(StressSessionMessage.XnKid));
                    CopyMemory(&StressSessionMessage.XnKey, &XnKey, sizeof(StressSessionMessage.XnKey));

                    if (WAIT_OBJECT_0 != NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(StressSessionMessage), (char *) &StressSessionMessage)) {
                        xLog(hLog, XLL_FAIL, "Send Key-Pair failed - ec: 0x%08x", GetLastError());

                        break;
                    }
                }
                else if (SERVER_REGISTER_MSG == ((PSTRESS_SESSION_MESSAGE) pMessage)->dwMessageId) {
                    // Copy the key
                    CopyMemory(&XnKid, &((PSTRESS_SESSION_MESSAGE) pMessage)->XnKid, sizeof(XnKid));
                    CopyMemory(&XnKey, &((PSTRESS_SESSION_MESSAGE) pMessage)->XnKey, sizeof(XnKey));

                    // Register the key pair
                    XNetRegisterKey(&XnKid, &XnKey);

                    // Send the ready message
                    ZeroMemory(&StressSessionMessage, sizeof(StressSessionMessage));
                    StressSessionMessage.dwMessageId = CLIENT_REGISTER_MSG;
                    if (WAIT_OBJECT_0 != NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(StressSessionMessage), (char *) &StressSessionMessage)) {
                        xLog(hLog, XLL_FAIL, "Send Ready failed - ec: 0x%08x", GetLastError());

                        break;
                    }
                }
                else if (SERVER_START_MSG == ((PSTRESS_SESSION_MESSAGE) pMessage)->dwMessageId) {
                    // Get the remote address
                    CopyMemory(&RemoteXnAddr, &((PSTRESS_SESSION_MESSAGE) pMessage)->XnAddr, sizeof(RemoteXnAddr));
                    XNetXnAddrToInAddr(&RemoteXnAddr, &XnKid, &sin_addr);
                    RemoteInAddr = sin_addr.s_addr;

                    // Initialize the stress threads
                    ZeroMemory(hThreads, sizeof(hThreads));
                    for (uIndex = 0; uIndex < StressThreadCount; uIndex++) {
                        if (STRESS_TYPE_1 == ((PSTRESS_SESSION_MESSAGE) pMessage)->dwStressType) {
                            StressThreads1[uIndex].hExitEvent = hExitEvent;
                            StressThreads1[uIndex].sin_addr.s_addr = RemoteInAddr;
                            StressThreads1[uIndex].sin_port = LowPort + uIndex;

                            if (CONNECT_FUNC == StressThreads1[uIndex].dwFunction) {
                                hThreads[uIndex] = CreateThread(NULL, 0, ConnectThread, &StressThreads1[uIndex], 0, NULL);
                            }
                            else if (ACCEPT_FUNC == StressThreads1[uIndex].dwFunction) {
                                hThreads[uIndex] = CreateThread(NULL, 0, AcceptThread, &StressThreads1[uIndex], 0, NULL);
                            }
                            else {
                                hThreads[uIndex] = CreateThread(NULL, 0, SendReceiveThread, &StressThreads1[uIndex], 0, NULL);
                            }
                        }
                        else {
                            StressThreads2[uIndex].hExitEvent = hExitEvent;
                            StressThreads2[uIndex].sin_addr.s_addr = RemoteInAddr;
                            StressThreads2[uIndex].sin_port = LowPort + uIndex;

                            if (CONNECT_FUNC == StressThreads2[uIndex].dwFunction) {
                                hThreads[uIndex] = CreateThread(NULL, 0, ConnectThread, &StressThreads2[uIndex], 0, NULL);
                            }
                            else if (ACCEPT_FUNC == StressThreads2[uIndex].dwFunction) {
                                hThreads[uIndex] = CreateThread(NULL, 0, AcceptThread, &StressThreads2[uIndex], 0, NULL);
                            }
                            else {
                                hThreads[uIndex] = CreateThread(NULL, 0, SendReceiveThread, &StressThreads2[uIndex], 0, NULL);
                            }
                        }
                    }
                }
                else if (SERVER_STOP_MSG == ((PSTRESS_SESSION_MESSAGE) pMessage)->dwMessageId) {
                    // Free the message
                    NetsyncFreeMessage(pMessage);

                    break;
                }

                // Free the message
                NetsyncFreeMessage(pMessage);
            }
        }

        // Signal the exit event
        SetEvent(hExitEvent);

        // Wait for the stress threads to exit
        WaitForMultipleObjects(StressThreadCount, hThreads, TRUE, INFINITE);

        // Reset the exit event
        ResetEvent(hExitEvent);

        // Unregister the key pair
        XNetUnregisterKey(&XnKid);

        // Close the netsync object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;

        // Terminate Winsock
        WSACleanup();
        bWinsockInitialized = FALSE;

        // Terminate Xnet
        XNetRelease();
        bXnetInitialized = FALSE;
    };

FunctionExit:
    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Close the netsync object
        NetsyncCloseClient(hNetsyncObject);
        hNetsyncObject = INVALID_HANDLE_VALUE;
    }

    if (TRUE == bWinsockInitialized) {
        // Terminate Winsock
        WSACleanup();
        bWinsockInitialized = FALSE;
    }

    if (TRUE == bXnetInitialized) {
        // Terminate Xnet
        XNetRelease();
        bXnetInitialized = FALSE;
    }

    if (NULL != hExitEvent) {
        // Close the exit event
        CloseHandle(hExitEvent);
    }

    if (NULL != lpszRemote) {
        xMemFree(hMemObject, lpszRemote);
    }

    if (NULL != lpszNetsyncRemote) {
        xMemFree(hMemObject, lpszNetsyncRemote);
    }

    // Free the private heap
    xMemClose(hMemObject);

    xEndVariation(hLog);
}

} // namespace XNetStressNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\client\lib\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 5-Oct-2000

------------------------------------------------------------------------------*/

#include <xtl.h>

#include <xtestlib.h>
#include <xmem.h>
#include <xnetref.h>
#include <xlog.h>
#include <netsync.h>

#include "util.h"
#include "stress.h"
#include "client.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\inc\stress.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    stress.h

Abstract:

    This module defines the common data for the xnetstress client and server

Author:

    Steven Kehrli (steveke) 8-Feb-2000

------------------------------------------------------------------------------*/

#pragma once



namespace XNetStressNamespace {



// Structures & Defines

typedef struct _STRESS_CLIENT {
    u_long  NetsyncClientInAddr;
    XNADDR  ClientXnAddr;
    DWORD   dwLastKeepAlive;
    XNKID   XnKid;
    XNKEY   XnKey;
    u_long  NetsyncRemoteInAddr;
    XNADDR  RemoteXnAddr;
    DWORD   dwStressType;
    DWORD   dwStatus;
} STRESS_CLIENT, *PSTRESS_CLIENT;



#define NUM_STRESS_CLIENTS         64

#define STRESS_TYPE_1              1
#define STRESS_TYPE_2              2

#define STATUS_REGISTERED          1
#define STATUS_STARTED             2



// Session Messages

typedef struct _STRESS_SESSION_MESSAGE {
    DWORD   dwMessageId;
    DWORD   dwStressType;
    XNADDR  XnAddr;
    XNKID   XnKid;
    XNKEY   XnKey;
} STRESS_SESSION_MESSAGE, *PSTRESS_SESSION_MESSAGE;



#define SERVER_KEYPAIR_MSG         NETSYNC_MSG_USER + 11
#define SERVER_REGISTER_MSG        NETSYNC_MSG_USER + 12
#define SERVER_START_MSG           NETSYNC_MSG_USER + 13
#define SERVER_STOP_MSG            NETSYNC_MSG_USER + 14

#define CLIENT_KEYPAIR_MSG         NETSYNC_MSG_USER + 21
#define CLIENT_REGISTER_MSG        NETSYNC_MSG_USER + 22
#define CLIENT_KEEPALIVE_MSG       NETSYNC_MSG_USER + 23



// Status Messages

typedef struct _STRESS_STATUS_REQUEST_MESSAGE {
    DWORD          dwMessageId;
} STRESS_STATUS_REQUEST_MESSAGE, *PSTRESS_STATUS_REQUEST_MESSAGE;

typedef struct _STRESS_STATUS_REPLY_MESSAGE {
    DWORD          dwMessageId;
    DWORD          dwNumStressSessions;
} STRESS_STATUS_REPLY_MESSAGE, *PSTRESS_STATUS_REPLY_MESSAGE;

typedef struct _STRESS_STATUS_SESSION_MESSAGE {
    DWORD          dwMessageId;
    DWORD          dwNumStressSessions;
    DWORD          dwCurStressSession;
    DWORD          dwNumStressClients;
} STRESS_STATUS_SESSION_MESSAGE, *PSTRESS_STATUS_SESSION_MESSAGE;

typedef struct _STRESS_STATUS_CLIENT_MESSAGE {
    DWORD          dwMessageId;
    DWORD          dwNumStressSessions;
    DWORD          dwCurStressSession;
    DWORD          dwNumStressClients;
    DWORD          dwCurStressClient;
    STRESS_CLIENT  StressClient;
} STRESS_STATUS_CLIENT_MESSAGE, *PSTRESS_STATUS_CLIENT_MESSAGE;



#define STRESS_STATUS_REQUEST_MSG  NETSYNC_MSG_USER + 1
#define STRESS_STATUS_REPLY_MSG    NETSYNC_MSG_USER + 2
#define STRESS_STATUS_SESSION_MSG  NETSYNC_MSG_USER + 3
#define STRESS_STATUS_CLIENT_MSG   NETSYNC_MSG_USER + 4

} // namespace XNetStressNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\server\server.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  server.h

Abstract:

  This module contains the definitions for server.c

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#pragma once



// Function prototypes


BOOL
WINAPI
XNetStressMain(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN u_long   FromInAddr,
    IN XNADDR   *FromXnAddr,
    IN DWORD    dwMessageType,
    IN DWORD    dwMessageSize,
    IN char     *pMessage,
    IN LPVOID   lpContext
);

LPVOID
WINAPI
XNetStressStart(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientInAddrs,
    IN XNADDR   *ClientXnAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
XNetStressStop(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN LPVOID   lpContext
);

BOOL
WINAPI
XNetStressStatusMain(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN u_long   FromInAddr,
    IN XNADDR   *FromXnAddr,
    IN DWORD    dwMessageType,
    IN DWORD    dwMessageSize,
    IN char     *pMessage,
    IN LPVOID   lpContext
);

LPVOID
WINAPI
XNetStressStatusStart(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientInAddrs,
    IN XNADDR   *ClientXnAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
);

VOID
WINAPI
XNetStressStatusStop(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN LPVOID   lpContext
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\client\util.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module contains the utility functions for xnetstress.dll

Author:

  Steven Kehrli (steveke) 11-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetStressNamespace;

namespace XNetStressNamespace {

LPSTR
GetIniString(
    HANDLE  hMemObject,
    LPCSTR  lpszSectionName,
    LPCSTR  lpszKeyName
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the specified string of the .ini file

Arguments:

  hMemObject - handle to the memory object
  lpszSectionName - pointer to the ini section name
  lpszKeyName - pointer to the ini key name

Return Value:

  LPSTR:
    If the function succeeds, the return value is a pointer to the string.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

-----------------------------------------------------------------------------*/
{
    // lpszString is a pointer to the string
    LPSTR  lpszString = NULL;
    // dwBufferSize is the size of the buffer referenced by lpszString
    DWORD  dwBufferSize = 0;
    // dwResult is the result of the GetProfileString call
    DWORD  dwResult = 0;



    // Allocate the memory for the string
    dwBufferSize = 0x10;
    lpszString = (LPSTR) xMemAlloc(hMemObject, dwBufferSize);

    while (NULL != lpszString)
    {
        dwResult = GetProfileStringA(lpszSectionName, lpszKeyName, NULL, lpszString, dwBufferSize);

        if (0 == dwResult) {
            goto FunctionFailed;
        }

        if (dwResult < (dwBufferSize - 2))
        {
            break;
        }

        dwBufferSize += 0x10;
        lpszString = (LPSTR) xMemReAlloc(hMemObject, lpszString, dwBufferSize);
    }

    if (NULL == lpszString)
    {
        goto FunctionFailed;
    }

    return lpszString;

FunctionFailed:
    if (NULL != lpszString) {
        xMemFree(hMemObject, lpszString);
    }

    return NULL;
}

} // namespace XNetStressNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\server\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF



TARGETPATH=$(BASEDIR)\private\test\lib

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_CXX=1

USECXX_FLAG=/Tp

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\inc; \
    ..\..\inc; \
    ..\; \

SOURCES=$(SOURCES) \
    stress.c   \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\status\resource.h ===
#define IDI_STATUS_ICON          1001
#define IDD_DIALOG               1002
#define IDC_STATUS_LIST          1003
#define IDC_HOST_NAME_STATIC     1004
#define IDC_HOST_NAME_TEXT       1005
#define IDC_QUERY_BUTTON         1006

#define IDS_STATUS_CAPTION       2001
#define IDS_MEMORY_INIT_FAILED   2002
#define IDS_WINSOCK_INIT_FAILED  2003
#define IDS_NAME_GET_FAILED      2004
#define IDS_NAME_RESOLVE_FAILED  2005
#define IDS_NAME_NETSYNC_FAILED  2006
#define IDS_LOCALNAME_LABEL      2007
#define IDS_REMOTENAME_LABEL     2008
#define IDS_STRESSTYPE_LABEL     2009
#define IDS_STATUS_LABEL         2010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\status\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 8-Feb-2002

------------------------------------------------------------------------------*/

#include <windows.h>
#include <winsock2.h>
#include <commctrl.h>
#include <stdlib.h>
#include <stdio.h>

#include <wsockntp.h>

#include <xmem.h>
#include <netsync.h>

#include "resource.h"
#include "util.h"
#include "status.h"
#include "stress.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\server\stress.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright Microsoft Corporation

Module Name:

  stress.c

Abstract:

  This modules tests XNet stress

Author:

  Steven Kehrli (steveke) 17-Apr-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetStressNamespace;

namespace XNetStressNamespace {

typedef struct _STRESS_CLIENT_LIST {
    BYTE                    byClientCount;
    STRESS_CLIENT           StressClients[NUM_STRESS_CLIENTS];
} STRESS_CLIENT_LIST, *PSTRESS_CLIENT_LIST;

typedef struct _STRESS_SESSION {
    HANDLE                  hMemObject;
    CRITICAL_SECTION        cs;
    HANDLE                  hThread;
    HANDLE                  hSessionObject;
    HANDLE                  hNetsyncObject;
    BOOL                    bExit;
    STRESS_CLIENT_LIST      StressClientList;
    struct _STRESS_SESSION  *pNextStressSession;
} STRESS_SESSION, *PSTRESS_SESSION;

HANDLE            g_hStressSessionsMutex = NULL;
DWORD             g_dwNumStressSessions = 0;
PSTRESS_SESSION   g_pStressSessions = NULL;



DWORD
XNetStressKeepAlive(
    IN LPVOID  lpv
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Thread to handle the server keep-alive logic

Arguments:

  lpv - Pointer to the stress session structure

------------------------------------------------------------------------------*/
{
    // pStressSession is a pointer to the stress session
    PSTRESS_SESSION         pStressSession = (PSTRESS_SESSION) lpv;
    // StressSessionMessage is a message sent to the stress session
    STRESS_SESSION_MESSAGE  StressSessionMessage;
    // NetsyncRemoteInAddr is the netsync address of the partner stress client
    u_long                  NetsyncRemoteInAddr;
    // byIndex is a counter to enumerate each stress client
    BYTE                    byIndex;



    do {
        Sleep(60000);

        // Wait for the critical section
        EnterCriticalSection(&pStressSession->cs);

        for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
            if ((0 != pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) && (600000 < (GetTickCount() - pStressSession->StressClientList.StressClients[byIndex].dwLastKeepAlive))) {
                // Client failed to send keep-alive so remove client from session
                NetsyncRemoveClientFromSession(pStressSession->hSessionObject, pStressSession->hNetsyncObject, pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr);

                // And remove client from list
                pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr = 0;
                ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].ClientXnAddr, sizeof(pStressSession->StressClientList.StressClients[byIndex].ClientXnAddr));
                pStressSession->StressClientList.StressClients[byIndex].dwLastKeepAlive = 0;
                ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].XnKid, sizeof(pStressSession->StressClientList.StressClients[byIndex].XnKid));
                ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].XnKey, sizeof(pStressSession->StressClientList.StressClients[byIndex].XnKey));
                NetsyncRemoteInAddr = pStressSession->StressClientList.StressClients[byIndex].NetsyncRemoteInAddr;
                pStressSession->StressClientList.StressClients[byIndex].NetsyncRemoteInAddr = 0;
                ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr, sizeof(pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr));
                pStressSession->StressClientList.StressClients[byIndex].dwStressType = 0;
                pStressSession->StressClientList.byClientCount--;

                // And shutdown partner
                ZeroMemory(&StressSessionMessage, sizeof(StressSessionMessage));
                StressSessionMessage.dwMessageId = SERVER_STOP_MSG;
                NetsyncSendClientMessage(pStressSession->hNetsyncObject, NetsyncRemoteInAddr, sizeof(StressSessionMessage), (char *) &StressSessionMessage);
            }
        }

        // Release critical section
        LeaveCriticalSection(&pStressSession->cs);
    } while (FALSE == pStressSession->bExit);

    return 0;
}

} // namespace XNetStressNamespace



BOOL
WINAPI
XNetStressMain(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN u_long   FromInAddr,
    IN XNADDR   *FromXnAddr,
    IN DWORD    dwMessageType,
    IN DWORD    dwMessageSize,
    IN char     *pMessage,
    IN LPVOID   lpContext
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Callback for the stress session

Arguments:

  hSessionObject - Handle to the session object
  hNetsyncObject - Handle to the netsync object
  FromAddr - Specifies the address of the netsync sender
  dwMessageType - Specifies the type of received message
  dwMessageSize - Specifies the size of the received message
  pMessage - Pointer to the received message
  lpContext - Pointer to the context structure

Return Value:

  BOOL:
    If the session should continue, the return value is TRUE.
    If the session should exit, the return value is FALSE.

------------------------------------------------------------------------------*/
{
    // pStressSession is a pointer to the stress session
    PSTRESS_SESSION         pStressSession = (PSTRESS_SESSION) lpContext;
    // StressSessionMessage is a message sent to the stress session
    STRESS_SESSION_MESSAGE  StressSessionMessage;
    // NetsyncRemoteInAddr is the netsync address of the partner stress client
    u_long                  NetsyncRemoteInAddr;
    // RemoteXnAddr is the xnet address of the partner stress client
    XNADDR                  RemoteXnAddr;
    // byIndex is a counter to enumerate each stress client
    BYTE                    byIndex;



    if (NULL == lpContext) {
        return FALSE;
    }

    // Wait for the critical section
    EnterCriticalSection(&pStressSession->cs);

    if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
        if (NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) {
            // Shutdown all clients
            for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
                if (0 != pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) {
                    ZeroMemory(&StressSessionMessage, sizeof(StressSessionMessage));
                    StressSessionMessage.dwMessageId = SERVER_STOP_MSG;
                    NetsyncSendClientMessage(hNetsyncObject, pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr, sizeof(StressSessionMessage), (char *) &StressSessionMessage);

                    pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr = 0;
                    ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].ClientXnAddr, sizeof(pStressSession->StressClientList.StressClients[byIndex].ClientXnAddr));
                    pStressSession->StressClientList.StressClients[byIndex].dwLastKeepAlive = 0;
                    ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].XnKid, sizeof(pStressSession->StressClientList.StressClients[byIndex].XnKid));
                    ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].XnKey, sizeof(pStressSession->StressClientList.StressClients[byIndex].XnKey));
                    pStressSession->StressClientList.StressClients[byIndex].NetsyncRemoteInAddr = 0;
                    ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr, sizeof(pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr));
                    pStressSession->StressClientList.StressClients[byIndex].dwStressType = 0;
                    pStressSession->StressClientList.StressClients[byIndex].dwStatus = 0;
                    pStressSession->StressClientList.byClientCount--;
                }
            }
        }
        else if (NETSYNC_MSG_DUPLICATECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) {
            // Search for duplicate client
            for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
                if (FromInAddr == pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) {
                    if (0 != pStressSession->StressClientList.StressClients[byIndex].dwStatus) {
                        // Flag the status
                        pStressSession->StressClientList.StressClients[byIndex].dwStatus = 0;

                        // Send the message
                        ZeroMemory(&StressSessionMessage, sizeof(StressSessionMessage));
                        StressSessionMessage.dwMessageId = SERVER_REGISTER_MSG;
                        CopyMemory(&StressSessionMessage.XnKid, &pStressSession->StressClientList.StressClients[byIndex].XnKid, sizeof(StressSessionMessage.XnKid));
                        CopyMemory(&StressSessionMessage.XnKey, &pStressSession->StressClientList.StressClients[byIndex].XnKey, sizeof(StressSessionMessage.XnKey));
                        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(StressSessionMessage), (char *) &StressSessionMessage);
                    }

                    break;
                }
            }
        }
        else if (NETSYNC_MSG_ADDCLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) {
            // Initiate partner address
            NetsyncRemoteInAddr = 0;
            ZeroMemory(&RemoteXnAddr, sizeof(RemoteXnAddr));

            // Find a partner for the stress client
            for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
                if ((0 != pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) && (0 == pStressSession->StressClientList.StressClients[byIndex].NetsyncRemoteInAddr)) {
                    NetsyncRemoteInAddr = pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr;
                    pStressSession->StressClientList.StressClients[byIndex].NetsyncRemoteInAddr = FromInAddr;
                    CopyMemory(&RemoteXnAddr, &pStressSession->StressClientList.StressClients[byIndex].ClientXnAddr, sizeof(RemoteXnAddr));
                    CopyMemory(&pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr, FromXnAddr, sizeof(pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr));
                    pStressSession->StressClientList.StressClients[byIndex].dwStressType = STRESS_TYPE_1;

                    break;
                }
            }

            // Add the new client to the list of stress clients
            for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
                if (0 == pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) {
                    pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr = FromInAddr;
                    CopyMemory(&pStressSession->StressClientList.StressClients[byIndex].ClientXnAddr, FromXnAddr, sizeof(pStressSession->StressClientList.StressClients[byIndex].ClientXnAddr));
                    pStressSession->StressClientList.StressClients[byIndex].dwLastKeepAlive = GetTickCount();
                    pStressSession->StressClientList.StressClients[byIndex].NetsyncRemoteInAddr = NetsyncRemoteInAddr;
                    CopyMemory(&pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr, &RemoteXnAddr, sizeof(pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr));

                    break;
                }
            }

            pStressSession->StressClientList.byClientCount++;

            if (0 != NetsyncRemoteInAddr) {
                // Send key-pair message
                ZeroMemory(&StressSessionMessage, sizeof(StressSessionMessage));
                StressSessionMessage.dwMessageId = SERVER_KEYPAIR_MSG;
                NetsyncSendClientMessage(hNetsyncObject, NetsyncRemoteInAddr, sizeof(StressSessionMessage), (char *) &StressSessionMessage);
            }
        }
        else if (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) {
            // Initiate partner address
            NetsyncRemoteInAddr = 0;

            // Find the old client
            for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
                if (FromInAddr == pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) {
                    // Remove the old client from the list of stress clients
                    pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr = 0;
                    ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].ClientXnAddr, sizeof(pStressSession->StressClientList.StressClients[byIndex].ClientXnAddr));
                    pStressSession->StressClientList.StressClients[byIndex].dwLastKeepAlive = 0;
                    ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].XnKid, sizeof(pStressSession->StressClientList.StressClients[byIndex].XnKid));
                    ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].XnKey, sizeof(pStressSession->StressClientList.StressClients[byIndex].XnKey));
                    NetsyncRemoteInAddr = pStressSession->StressClientList.StressClients[byIndex].NetsyncRemoteInAddr;
                    pStressSession->StressClientList.StressClients[byIndex].NetsyncRemoteInAddr = 0;
                    ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr, sizeof(pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr));
                    pStressSession->StressClientList.StressClients[byIndex].dwStressType = 0;
                    pStressSession->StressClientList.byClientCount--;

                    break;
                }
            }

            if (0 != NetsyncRemoteInAddr) {
                // Shutdown partner
                for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
                    if (NetsyncRemoteInAddr == pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) {
                        ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].XnKid, sizeof(pStressSession->StressClientList.StressClients[byIndex].XnKid));
                        ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].XnKey, sizeof(pStressSession->StressClientList.StressClients[byIndex].XnKey));
                        pStressSession->StressClientList.StressClients[byIndex].NetsyncRemoteInAddr = 0;
                        ZeroMemory(&pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr, sizeof(pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr));
                        pStressSession->StressClientList.StressClients[byIndex].dwStressType = 0;
                        pStressSession->StressClientList.StressClients[byIndex].dwStatus = 0;

                        ZeroMemory(&StressSessionMessage, sizeof(StressSessionMessage));
                        StressSessionMessage.dwMessageId = SERVER_STOP_MSG;
                        NetsyncSendClientMessage(hNetsyncObject, NetsyncRemoteInAddr, sizeof(StressSessionMessage), (char *) &StressSessionMessage);

                        break;
                    }
                }
            }
        }
    }
    else if (NETSYNC_MSGTYPE_CLIENT == dwMessageType) {
        if (CLIENT_KEYPAIR_MSG == ((PSTRESS_SESSION_MESSAGE) pMessage)->dwMessageId) {
            // Initiate partner address
            NetsyncRemoteInAddr = 0;

            // Find the old client
            for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
                if (FromInAddr == pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) {
                    // Copy the key-pair
                    CopyMemory(&pStressSession->StressClientList.StressClients[byIndex].XnKid, &((PSTRESS_SESSION_MESSAGE) pMessage)->XnKid, sizeof(pStressSession->StressClientList.StressClients[byIndex].XnKid));
                    CopyMemory(&pStressSession->StressClientList.StressClients[byIndex].XnKey, &((PSTRESS_SESSION_MESSAGE) pMessage)->XnKey, sizeof(pStressSession->StressClientList.StressClients[byIndex].XnKey));
                    NetsyncRemoteInAddr = pStressSession->StressClientList.StressClients[byIndex].NetsyncRemoteInAddr;
                    pStressSession->StressClientList.StressClients[byIndex].dwStatus = STATUS_REGISTERED;

                    break;
                }
            }

            if (0 != NetsyncRemoteInAddr) {
                // Find the partner
                for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
                    if (NetsyncRemoteInAddr == pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) {
                        // Copy the key-pair
                        CopyMemory(&pStressSession->StressClientList.StressClients[byIndex].XnKid, &((PSTRESS_SESSION_MESSAGE) pMessage)->XnKid, sizeof(pStressSession->StressClientList.StressClients[byIndex].XnKid));
                        CopyMemory(&pStressSession->StressClientList.StressClients[byIndex].XnKey, &((PSTRESS_SESSION_MESSAGE) pMessage)->XnKey, sizeof(pStressSession->StressClientList.StressClients[byIndex].XnKey));

                        // Send register message
                        ZeroMemory(&StressSessionMessage, sizeof(StressSessionMessage));
                        StressSessionMessage.dwMessageId = SERVER_REGISTER_MSG;
                        CopyMemory(&StressSessionMessage.XnKid, &pStressSession->StressClientList.StressClients[byIndex].XnKid, sizeof(StressSessionMessage.XnKid));
                        CopyMemory(&StressSessionMessage.XnKey, &pStressSession->StressClientList.StressClients[byIndex].XnKey, sizeof(StressSessionMessage.XnKey));
                        NetsyncSendClientMessage(hNetsyncObject, NetsyncRemoteInAddr, sizeof(StressSessionMessage), (char *) &StressSessionMessage);

                        break;
                    }
                }
            }
        }
        else if (CLIENT_REGISTER_MSG == ((PSTRESS_SESSION_MESSAGE) pMessage)->dwMessageId) {
            // Initiate partner address
            NetsyncRemoteInAddr = 0;

            // Find the old client
            for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
                if (FromInAddr == pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) {
                    // Update the status
                    NetsyncRemoteInAddr = pStressSession->StressClientList.StressClients[byIndex].NetsyncRemoteInAddr;
                    pStressSession->StressClientList.StressClients[byIndex].dwStatus = STATUS_STARTED;

                    // Send start message
                    ZeroMemory(&StressSessionMessage, sizeof(StressSessionMessage));
                    StressSessionMessage.dwMessageId = SERVER_START_MSG;
                    StressSessionMessage.dwStressType = pStressSession->StressClientList.StressClients[byIndex].dwStressType;
                    CopyMemory(&StressSessionMessage.XnAddr, &pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr, sizeof(StressSessionMessage.XnAddr));
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(StressSessionMessage), (char *) &StressSessionMessage);

                    break;
                }
            }

            if (0 != NetsyncRemoteInAddr) {
                // Find the partner
                for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
                    if (NetsyncRemoteInAddr == pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) {
                        if (STATUS_STARTED != pStressSession->StressClientList.StressClients[byIndex].dwStatus) {
                            // Update the status
                            pStressSession->StressClientList.StressClients[byIndex].dwStatus = STATUS_STARTED;

                            // Send start message
                            ZeroMemory(&StressSessionMessage, sizeof(StressSessionMessage));
                            StressSessionMessage.dwMessageId = SERVER_START_MSG;
                            StressSessionMessage.dwStressType = pStressSession->StressClientList.StressClients[byIndex].dwStressType;
                            CopyMemory(&StressSessionMessage.XnAddr, &pStressSession->StressClientList.StressClients[byIndex].RemoteXnAddr, sizeof(StressSessionMessage.XnAddr));
                            NetsyncSendClientMessage(hNetsyncObject, NetsyncRemoteInAddr, sizeof(StressSessionMessage), (char *) &StressSessionMessage);
                        }

                        break;
                    }
                }
            }
        }
        else if (CLIENT_KEEPALIVE_MSG == ((PSTRESS_SESSION_MESSAGE) pMessage)->dwMessageId) {
            for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
                // Update the keep-alive for the client
                if (FromInAddr == pStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) {
                    pStressSession->StressClientList.StressClients[byIndex].dwLastKeepAlive = GetTickCount();

                    break;
                }
            }
        }
    }

    // Release critical section
    LeaveCriticalSection(&pStressSession->cs);

    return (0 != pStressSession->StressClientList.byClientCount);
}



LPVOID
WINAPI
XNetStressStart(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientInAddrs,
    IN XNADDR   *ClientXnAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Start the stress session

Arguments:

  hSessionObject - Handle to the session object
  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientInAddrs - Pointer to an array of client ip addresses
  ClientXnAddrs - Pointer to an array of client xnet addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  LPVOID - Pointer to a context structure

------------------------------------------------------------------------------*/
{
    // hMemObject is a handle to the memory object
    HANDLE                   hMemObject = INVALID_HANDLE_VALUE;
    // pStressSession is a pointer to the stress session
    PSTRESS_SESSION          pStressSession = NULL;
    // StressSessionMessage is a message sent to the stress session
    STRESS_SESSION_MESSAGE   StressSessionMessage;
    // GenericMessage is a message sent to the main function
    NETSYNC_GENERIC_MESSAGE  GenericMessage;
    // byCurrentClient is a counter to enumerate the client list
    BYTE                     byCurrentClient;



    // Create the memory object
    hMemObject = xMemCreate();
    if (INVALID_HANDLE_VALUE == hMemObject) {
        return NULL;
    }

    // Create the stress session structure
    pStressSession = (PSTRESS_SESSION) xMemAlloc(hMemObject, sizeof(STRESS_SESSION));
    if (NULL == pStressSession) {
        // Close the memory object
        xMemClose(hMemObject);

        return NULL;
    }

    // Initialize the critical section
    InitializeCriticalSection(&pStressSession->cs);

    // Set the netsync object
    pStressSession->hSessionObject = hSessionObject;
    pStressSession->hNetsyncObject = hNetsyncObject;
    pStressSession->bExit = FALSE;

    // Create the server keep-alive thread
    pStressSession->hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) XNetStressKeepAlive, pStressSession, 0, NULL);
    if (NULL == pStressSession->hThread) {
        // Free the stress session structure
        xMemFree(hMemObject, pStressSession);

        // Close the memory object
        xMemClose(hMemObject);

        return NULL;
    }

    // Create the stress sessions mutex
    g_hStressSessionsMutex = CreateMutexA(NULL, FALSE, "XNetStressMutex");

    // Wait for access to the stress sessions
    WaitForSingleObject(g_hStressSessionsMutex, INFINITE);

    // Increment the count of stress sessions
    g_dwNumStressSessions++;

    // Add the stress session to the list
    pStressSession->pNextStressSession = g_pStressSessions;
    g_pStressSessions = pStressSession;

    // Release the stress sessions mutex
    ReleaseMutex(g_hStressSessionsMutex);

    // Send add client messages to the main function
    ZeroMemory(&GenericMessage, sizeof(GenericMessage));
    GenericMessage.dwMessageId = NETSYNC_MSG_ADDCLIENT;
    for (byCurrentClient = 0; byCurrentClient < byClientCount; byCurrentClient++) {
        XNetStressMain(hSessionObject, hNetsyncObject, ClientInAddrs[byCurrentClient], &ClientXnAddrs[byCurrentClient], NETSYNC_MSGTYPE_SERVER, sizeof(NETSYNC_GENERIC_MESSAGE), (char *) &GenericMessage, pStressSession);
    }

    return pStressSession;
}



VOID
WINAPI
XNetStressStop(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN LPVOID   lpContext
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Stops the stress session

Arguments:

  hSessionObject - Handle to the session object
  hNetsyncObject - Handle to the netsync object
  lpContext - Pointer to the context structure

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // hMemObject is a handle to the memory object
    HANDLE           hMemObject = INVALID_HANDLE_VALUE;

    // pStressSession is a pointer to the stress session
    PSTRESS_SESSION  pStressSession = (PSTRESS_SESSION) lpContext;
    // pPrevStressSession is a pointer to the previous stress session in the list
    PSTRESS_SESSION  pPrevStressSession = NULL;
    // pCurStressSession is a pointer to the current stress session in the list
    PSTRESS_SESSION  pCurStressSession = NULL;



    if (NULL != lpContext) {
        // Exit the keep-alive thread
        pStressSession->bExit = TRUE;
        WaitForSingleObject(pStressSession->hThread, INFINITE);
        CloseHandle(pStressSession->hThread);

        // Delete the critical section
        DeleteCriticalSection(&pStressSession->cs);

        // Create the stress sessions mutex
        g_hStressSessionsMutex = CreateMutexA(NULL, FALSE, "XNetStressMutex");

        // Wait for access to the stress sessions
        WaitForSingleObject(g_hStressSessionsMutex, INFINITE);

        // Set pCurStressSession to the head of the list
        pCurStressSession = g_pStressSessions;

        // Search the list for the current stress session
        while ((NULL != pCurStressSession) && (pCurStressSession != pStressSession)) {
            pPrevStressSession = pCurStressSession;
            pCurStressSession = pCurStressSession->pNextStressSession;
        }

        // Remove stress session from the list
        if ((NULL == pCurStressSession->pNextStressSession) && (NULL == pPrevStressSession)) {
            // Only stress session in the list
            g_pStressSessions = NULL;
        }
        else if (NULL == pCurStressSession->pNextStressSession) {
            // Stress session is tail of the list
            pPrevStressSession->pNextStressSession = NULL;
        }
        else if (NULL == pPrevStressSession) {
            // Stress session is head of the list
            g_pStressSessions = pCurStressSession->pNextStressSession;
        }
        else {
            // Stress session is middle of the list
            pPrevStressSession->pNextStressSession = pCurStressSession->pNextStressSession;
        }

        // Decrement the count of stress sessions
        g_dwNumStressSessions--;

        // Release the stress sessions mutex
        ReleaseMutex(g_hStressSessionsMutex);

        // Free the stress session structure
        hMemObject = pStressSession->hMemObject;
        xMemFree(hMemObject, pStressSession);

        // Close the memory object
        xMemClose(hMemObject);
    }
}



BOOL
WINAPI
XNetStressStatusMain(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN u_long   FromInAddr,
    IN XNADDR   *FromXnAddr,
    IN DWORD    dwMessageType,
    IN DWORD    dwMessageSize,
    IN char     *pMessage,
    IN LPVOID   lpContext
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the status of the stress sessions

Routine Description:

  Callback for the stress session

Arguments:

  hSessionObject - Handle to the session object
  hNetsyncObject - Handle to the netsync object
  FromAddr - Specifies the address of the netsync sender
  dwMessageType - Specifies the type of received message
  dwMessageSize - Specifies the size of the received message
  pMessage - Pointer to the received message
  lpContext - Pointer to the context structure

Return Value:

  BOOL:
    If the session should continue, the return value is TRUE.
    If the session should exit, the return value is FALSE.

------------------------------------------------------------------------------*/
{
    // StressStatusReplyMessage is the stress status reply message
    STRESS_STATUS_REPLY_MESSAGE    StressStatusReplyMessage;
    // StressStatusSessionMessage is the stress status session message
    STRESS_STATUS_SESSION_MESSAGE  StressStatusSessionMessage;
    // StressStatusClientMessage is the stress status client message
    STRESS_STATUS_CLIENT_MESSAGE   StressStatusClientMessage;
    // pCurStressSession is a pointer to the current stress session in the list
    PSTRESS_SESSION                pCurStressSession = NULL;
    // dwCurStressSession is the current stress session in the list
    DWORD                          dwCurStressSession = 0;
    // byIndex is a counter to enumerate each stress client
    BYTE                           byIndex;



    // Check if netsync server is stopping
    if ((NETSYNC_MSGTYPE_SERVER == dwMessageType) && (NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
        return FALSE;
    }

    if ((NETSYNC_MSGTYPE_CLIENT == dwMessageType) && (STRESS_STATUS_REQUEST_MSG == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
        // Create the stress sessions mutex
        g_hStressSessionsMutex = CreateMutexA(NULL, FALSE, "XNetStressMutex");

        // Wait for access to the stress sessions
        WaitForSingleObject(g_hStressSessionsMutex, INFINITE);

        // Set pCurStressSession to the head of the list
        pCurStressSession = g_pStressSessions;

        // Send the number of stress sessions
        StressStatusReplyMessage.dwMessageId = STRESS_STATUS_REPLY_MSG;
        StressStatusReplyMessage.dwNumStressSessions = g_dwNumStressSessions;
        NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(StressStatusReplyMessage), (char *) &StressStatusReplyMessage);

        // Search the list for the current stress session
        while (NULL != pCurStressSession) {
            dwCurStressSession++;

            // Wait for the critical section
            EnterCriticalSection(&pCurStressSession->cs);

            StressStatusSessionMessage.dwMessageId = STRESS_STATUS_SESSION_MSG;
            StressStatusSessionMessage.dwNumStressSessions = g_dwNumStressSessions;
            StressStatusSessionMessage.dwCurStressSession = dwCurStressSession;
            StressStatusSessionMessage.dwNumStressClients = pCurStressSession->StressClientList.byClientCount;
            NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(StressStatusSessionMessage), (char *) &StressStatusSessionMessage);

            StressStatusClientMessage.dwMessageId = STRESS_STATUS_CLIENT_MSG;
            StressStatusClientMessage.dwNumStressSessions = g_dwNumStressSessions;
            StressStatusClientMessage.dwCurStressSession = dwCurStressSession;
            StressStatusClientMessage.dwNumStressClients = pCurStressSession->StressClientList.byClientCount;

            // Enumerate the stress clients
            for (byIndex = 0; byIndex < NUM_STRESS_CLIENTS; byIndex++) {
                if (0 != pCurStressSession->StressClientList.StressClients[byIndex].NetsyncClientInAddr) {
                    StressStatusClientMessage.dwCurStressClient = byIndex + 1;

                    CopyMemory(&StressStatusClientMessage.StressClient, &pCurStressSession->StressClientList.StressClients[byIndex], sizeof(StressStatusClientMessage.StressClient));
                    NetsyncSendClientMessage(hNetsyncObject, FromInAddr, sizeof(StressStatusClientMessage), (char *) &StressStatusClientMessage);
                }
            }

            // Release critical section
            LeaveCriticalSection(&pCurStressSession->cs);

            // Get the next stress session
            pCurStressSession = pCurStressSession->pNextStressSession;
        }

        // Release the stress sessions mutex
        ReleaseMutex(g_hStressSessionsMutex);
    }

    return TRUE;
}



LPVOID
WINAPI
XNetStressStatusStart(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN BYTE     byClientCount,
    IN u_long   *ClientInAddrs,
    IN XNADDR   *ClientXnAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Start the stress status session

Arguments:

  hSessionObject - Handle to the session object
  hNetsyncObject - Handle to the netsync object
  byClientCount - Specifies the number of clients in the session
  ClientInAddrs - Pointer to an array of client ip addresses
  ClientXnAddrs - Pointer to an array of client xnet addresses
  LowPort - Specifies the low bound of the netsync port range
  HighPort - Specifies the high bound of the netsync port range

Return Value:

  LPVOID - Pointer to a context structure

------------------------------------------------------------------------------*/
{
    return NULL;
}



VOID
WINAPI
XNetStressStatusStop(
    IN HANDLE   hSessionObject,
    IN HANDLE   hNetsyncObject,
    IN LPVOID   lpContext
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Stops the stress status session

Arguments:

  hSessionObject - Handle to the session object
  hNetsyncObject - Handle to the netsync object
  lpContext - Pointer to the context structure

Return Value:

  None

------------------------------------------------------------------------------*/
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\status\util.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.h

Abstract:

  This module contains the definitions for util.c

Author:

  Steven Kehrli (steveke) 8-Feb-2002

-----------------------------------------------------------------------------*/

#pragma once



BOOL
GetResourceString(
    UINT    uResource,
    LPWSTR  lpszString,
    DWORD   dwStringSize
    ...
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\status\status.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  status.h

Abstract:

  This module defines private data for xnetstressstatus.exe

Author:

  Steven Kehrli (steveke) 8-Feb-2002

------------------------------------------------------------------------------*/

#pragma once



// Structures

typedef struct _CLIENT_OBJECT {
    IN_ADDR  LocalAddr;
    IN_ADDR  RemoteAddr;
    DWORD    dwStressType;
    DWORD    dwStatus;
} CLIENT_OBJECT, *PCLIENT_OBJECT;



// Values

#define MAX_IP_LENGTH         16
#define STATUS_CLASS_NAME     L"XNetStressStatusClassName"



// Dialog messages

#define UM_DIALOG_INITIALIZE  (WM_USER + 1)
#define UM_DIALOG_ENABLE      (WM_USER + 2)
#define UM_DIALOG_ADD         (WM_USER + 3)
#define UM_DIALOG_DELETE      (WM_USER + 4)



// The following enum is used to identify the column indexes

enum eColumnIndex {
    eColumnLocalName = 0,
    eColumnRemoteName,
    eColumnStressType,
    eColumnStatus,
    eColumnIllegal
};



// The following enum is used to identify the sort method

enum eSortMethod {
    eSortLocalNameAscending = 0,
    eSortLocalNameDescending,
    eSortRemoteNameAscending,
    eSortRemoteNameDescending,
    eSortStressTypeAscending,
    eSortStressTypeDescending,
    eSortStatusAscending,
    eSortStatusDescending,
    eSortIllegal
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\status\status.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  status.c

Abstract:

  This module queries the status of an xnet stress session

Author:

  Steven Kehrli (steveke) 8-Feb-2002

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace XNetStressNamespace;

NETSYNC_TYPE_CALLBACK StressStatusSession = {
    1,
    1,
    0,
    L"xnetstress_nt.dll",
    "XNetStressStatusMain",
    "XNetStressStatusStart",
    "XNetStressStatusStop"
};



LRESULT CALLBACK DialogProc (HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Window procedure for the main window

-----------------------------------------------------------------------------*/
{
    // wndclass is the window class of the dialog
    WNDCLASSEX  wndclass;
    // hDlg is the handle to the dialog
    HWND        hDlg = NULL;
    // msg is the window message
    MSG         msg;
    // dwErrorCode is the error code
    DWORD       dwErrorCode = ERROR_SUCCESS;



    // Initialize the common controls
    InitCommonControls();


    // Initialize the window class
    ZeroMemory(&wndclass, sizeof(wndclass));
    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = DialogProc;
    wndclass.cbWndExtra = DLGWINDOWEXTRA;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_STATUS_ICON));
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH) (COLOR_INACTIVEBORDER + 1);
    wndclass.lpszClassName = STATUS_CLASS_NAME;
    wndclass.hIconSm = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_STATUS_ICON));

    // Check if window is open
    hDlg = FindWindow(STATUS_CLASS_NAME, NULL);
    if (NULL != hDlg) {
        // Switch to the open window
        ShowWindow(hDlg, SW_RESTORE);
        SetForegroundWindow(hDlg);

        return 0;
    }

    // Register the class
    RegisterClassEx(&wndclass);

    // Create the dialog
    hDlg = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_DIALOG), NULL, NULL);

    // Initialize the dialog
    SendMessage(hDlg, UM_DIALOG_INITIALIZE, 0, 0);

    // Show the dialog
    ShowWindow(hDlg, iCmdShow);
    UpdateWindow(hDlg);

    // Pump the message handler
    while (0 != GetMessage(&msg, NULL, 0, 0)) {
        if (FALSE == IsDialogMessage(hDlg, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // Get the error code
    dwErrorCode = msg.wParam;

    return dwErrorCode;
}



int CALLBACK
SortClientObjects(
    LPARAM  lParam1,
    LPARAM  lParam2,
    LPARAM  lParamSort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sorts the client objects in the status list

Arguments:

  lParam1 - Specifies the first lParam (pointer to the first client object)
  lParam2 - Specifies the second lParam (pointer to the second client object)
  lParamSort - Specifies the sort method

Return Value:

  int:
    If the first item should precede the second, negative value (-1)
    If the second item should precede the first, positive value (+1)
    If the two items are equivalent, 0

------------------------------------------------------------------------------*/
{
    // szName1 is the name in the first lParam
    char  *szName1;
    // szName2 is the name in the second lParam
    char  *szName2;



    switch (lParamSort) {
        case eSortLocalNameAscending:
            // Get the names
            szName1 = inet_ntoa(((PCLIENT_OBJECT) lParam1)->LocalAddr);
            szName2 = inet_ntoa(((PCLIENT_OBJECT) lParam1)->RemoteAddr);

            return strcmp(szName1, szName2);

            break;

        case eSortLocalNameDescending:
            szName1 = inet_ntoa(((PCLIENT_OBJECT) lParam1)->LocalAddr);
            szName2 = inet_ntoa(((PCLIENT_OBJECT) lParam1)->RemoteAddr);

            return strcmp(szName2, szName1);

            break;

        case eSortRemoteNameAscending:
            szName1 = inet_ntoa(((PCLIENT_OBJECT) lParam1)->LocalAddr);
            szName2 = inet_ntoa(((PCLIENT_OBJECT) lParam1)->RemoteAddr);

            return strcmp(szName1, szName2);

            break;

        case eSortRemoteNameDescending:
            szName1 = inet_ntoa(((PCLIENT_OBJECT) lParam1)->LocalAddr);
            szName2 = inet_ntoa(((PCLIENT_OBJECT) lParam1)->RemoteAddr);

            return strcmp(szName2, szName1);

            break;

        case eSortStressTypeAscending:
            if (((PCLIENT_OBJECT) lParam1)->dwStressType < ((PCLIENT_OBJECT) lParam2)->dwStressType) {
                return -1;
            }
            else if (((PCLIENT_OBJECT) lParam1)->dwStressType > ((PCLIENT_OBJECT) lParam2)->dwStressType) {
                return 1;
            }

            break;

        case eSortStressTypeDescending:
            if (((PCLIENT_OBJECT) lParam2)->dwStressType < ((PCLIENT_OBJECT) lParam1)->dwStressType) {
                return -1;
            }
            else if (((PCLIENT_OBJECT) lParam2)->dwStressType > ((PCLIENT_OBJECT) lParam1)->dwStressType) {
                return 1;
            }

            break;


        case eSortStatusAscending:
            if (((PCLIENT_OBJECT) lParam1)->dwStatus < ((PCLIENT_OBJECT) lParam2)->dwStatus) {
                return -1;
            }
            else if (((PCLIENT_OBJECT) lParam1)->dwStatus > ((PCLIENT_OBJECT) lParam2)->dwStatus) {
                return 1;
            }

            break;


        case eSortStatusDescending:
            if (((PCLIENT_OBJECT) lParam2)->dwStatus < ((PCLIENT_OBJECT) lParam1)->dwStatus) {
                return -1;
            }
            else if (((PCLIENT_OBJECT) lParam2)->dwStatus > ((PCLIENT_OBJECT) lParam1)->dwStatus) {
                return 1;
            }

            break;

        default:
            break;
    }

    return 0;
}



DWORD WINAPI QueryThreadProc (LPVOID lpv)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Thread to query a netsync server

Return Value:

  DWORD - exit code

-----------------------------------------------------------------------------*/
{
    // hDlg is the handle to the dialog
    HWND                            hDlg = (HWND) lpv;
    // szHostName is the host name
    CHAR                            szHostName[__max(MAX_COMPUTERNAME_LENGTH, MAX_IP_LENGTH) + 1];
    // pHostEntry is a pointer to the hostent structure
    HOSTENT                         *pHostEntry = NULL;
    // uHostAddr is the host name address
    ULONG                           uHostAddr = 0;

    // hNetsyncObject is the handle to the netsync object
    HANDLE                          hNetsyncObject = INVALID_HANDLE_VALUE;
    // uNetsyncInAddr is the netsync address
    ULONG                           uNetsyncInAddr = 0;
    // bNetsyncSucceeded indicates if the netsync session is found
    BOOL                            bNetsyncSucceeded = FALSE;

    // StressStatusRequestMessage is the stress status request message
    STRESS_STATUS_REQUEST_MESSAGE   StressStatusRequestMessage;
    // pStressStatusReplyMessage is a pointer to the stress status reply message
    PSTRESS_STATUS_REPLY_MESSAGE    pStressStatusReplyMessage;
    // pStressStatusSessionMessage is a pointer to the stress status session message
    PSTRESS_STATUS_SESSION_MESSAGE  pStressStatusSessionMessage;
    // pStressStatusClientMessage is a pointer to the stress status client message
    PSTRESS_STATUS_CLIENT_MESSAGE   pStressStatusClientMessage;
    // dwMessageSize is the size of the message
    DWORD                           dwMessageSize;
    // dwSession is a counter to enumerate each session
    DWORD                           dwSession;
    // dwClient is a counter to enumerate each client
    DWORD                           dwClient;

    // szText is the text string buffer
    WCHAR                           szText[256];
    // szError is the error string buffer
    WCHAR                           szError[256];



    // Disable the UI
    SendMessage(hDlg, UM_DIALOG_ENABLE, 0, (LPARAM) FALSE);

    // Delete the items in the list view
    SendMessage(hDlg, UM_DIALOG_DELETE, 0, 0);

    // Get the computer name
    if (0 == GetDlgItemTextA(hDlg, IDC_HOST_NAME_TEXT, szHostName, sizeof(szHostName))) {
        // Get the resource string buffer
        GetResourceString(IDS_NAME_GET_FAILED, szError, sizeof(szError) / sizeof(WCHAR));

        goto QueryThreadProc_Exit;
    }

    // Get the IP address
    uHostAddr = inet_addr(szHostName);
    if (INADDR_NONE == uHostAddr) {
        // Resolve the computer name
        pHostEntry = gethostbyname(szHostName);
        if (NULL == pHostEntry) {
            // Get the resource string buffer
            GetResourceString(IDS_NAME_RESOLVE_FAILED, szError, sizeof(szError) / sizeof(WCHAR), GetLastError());

            goto QueryThreadProc_Exit;
        }

        // Get the IP address
        CopyMemory(&uHostAddr, pHostEntry->h_addr, sizeof(uHostAddr));
    }

    // Connect to the session
    hNetsyncObject = NetsyncCreateClient(uHostAddr, NETSYNC_SESSION_CALLBACK, &StressStatusSession, &uNetsyncInAddr, NULL, NULL, NULL);
    if (INVALID_HANDLE_VALUE == hNetsyncObject) {
        // Get the resource string buffer
        GetResourceString(IDS_NAME_NETSYNC_FAILED, szError, sizeof(szError) / sizeof(WCHAR), GetLastError());

        goto QueryThreadProc_Exit;
    }

    // Send the request message
    ZeroMemory(&StressStatusRequestMessage, sizeof(StressStatusRequestMessage));
    StressStatusRequestMessage.dwMessageId = STRESS_STATUS_REQUEST_MSG;
    NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(StressStatusRequestMessage), (char *) &StressStatusRequestMessage);

    // Receive the reply message
    NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &uNetsyncInAddr, NULL, &dwMessageSize, (char **) &pStressStatusReplyMessage);
    for (dwSession = 0; dwSession < pStressStatusReplyMessage->dwNumStressSessions; dwSession++) {
        // Receive the session message
        NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &uNetsyncInAddr, NULL, &dwMessageSize, (char **) &pStressStatusSessionMessage);
        for (dwClient = 0; dwClient < pStressStatusSessionMessage->dwNumStressClients; dwClient++) {
            // Receive the client message
            NetsyncReceiveClientMessage(hNetsyncObject, INFINITE, &uNetsyncInAddr, NULL, &dwMessageSize, (char **) &pStressStatusClientMessage);

            // Add the client
            SendMessage(hDlg, UM_DIALOG_ADD, 0, (LPARAM) pStressStatusClientMessage);

            // Free the client message
            NetsyncFreeMessage((char *) pStressStatusClientMessage);
        }

        // Free the session message
        NetsyncFreeMessage((char *) pStressStatusSessionMessage);
    }

    // Free the reply message
    NetsyncFreeMessage((char *) pStressStatusReplyMessage);

    // Close the session
    NetsyncCloseClient(hNetsyncObject);

    // Session succeeded
    bNetsyncSucceeded = TRUE;

QueryThreadProc_Exit:
    if (FALSE == bNetsyncSucceeded) {
        // Display the error message
        GetResourceString(IDS_STATUS_CAPTION, szText, sizeof(szText) / sizeof(WCHAR));
        MessageBox(NULL, szError, szText, MB_OK | MB_ICONERROR);
    }

    // Enable the UI
    SendMessage(hDlg, UM_DIALOG_ENABLE, 0, (LPARAM) TRUE);

    return 0;
}


    
LRESULT CALLBACK DialogProc (HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Dialog procedure for the main window

-----------------------------------------------------------------------------*/
{
    // hMemObject is the handle to the memory object
    static HANDLE       hMemObject = INVALID_HANDLE_VALUE;
    // WSAData is the details of the Winsock implementation
    WSADATA             WSAData;
    // bWinsockInitialized indicates Winsock is initialized
    static BOOL         bWinsockInitialized = FALSE;
    // bDlgInitialized indicates the dialog is initialized
    static BOOL         bDlgInitialized = TRUE;
    // dwErrorCode is the last error code
    DWORD               dwErrorCode = ERROR_SUCCESS;

    // hWndList is a handle to the status list
    static HWND         hWndList = NULL;
    // eCurrentSortMethod is the current sort method of the status list
    static eSortMethod  eCurrentSortMethod = eSortLocalNameAscending;
    // rcClient is the WindowRect of the status list
    RECT                rcClient;
    // lvc specifies the attributes of a particular column of the status list
    LV_COLUMN           lvc;
    // lvi specifies the attributes of a particular item of the status list
    LV_ITEM             lvi;
    // dwItemCount is the number of items in the status list
    DWORD               dwItemCount;
    // dwItem is a counter to enumerate each item in the status list
    DWORD               dwItem;
    // pnmhdr is a pointer to the WM_NOTIFY message header
    LPNMHDR             pnmhdr;
    // pnmlistview is a pointer to the LVN_COLUMNCLICK message
    LPNMLISTVIEW        pnmlistview;

    // pClientObject is a pointer to the client object
    PCLIENT_OBJECT      pClientObject;

    // hQueryThread is the handle to the query thread
    static HANDLE       hQueryThread = NULL;
    // dwExitCode is the exit code of the query thread
    DWORD               dwExitCode;

    // szText is the text string buffer
    WCHAR               szText[256];
    // szError is the error string buffer
    WCHAR               szError[256];



    switch (iMsg) {

        case UM_DIALOG_INITIALIZE:
            // Limit the length of the text box
            SendMessage(GetDlgItem(hDlg, IDC_HOST_NAME_TEXT), EM_SETLIMITTEXT, __max(MAX_COMPUTERNAME_LENGTH, MAX_IP_LENGTH), 0);

            // Get the handle to the status list
            hWndList = GetDlgItem(hDlg, IDC_STATUS_LIST);

            // Set the status list to select the full row
            ListView_SetExtendedListViewStyle(hWndList, LVS_EX_FULLROWSELECT);

            // Get the Rect of the Status List
            GetWindowRect(hWndList, &rcClient);

            // Set common attributes for each column
            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.fmt = LVCFMT_LEFT;

            // Local Name Column
            // Load the text
            GetResourceString(IDS_LOCALNAME_LABEL, szText, sizeof(szText) / sizeof(WCHAR));
            // Set the column text
            lvc.pszText = szText;
            // Set the width of the column to be about 1 / 3 of the width of the status list, allowing for the width of the borders and scroll bar
            lvc.cx = (rcClient.right - rcClient.left - 4 * GetSystemMetrics(SM_CXBORDER) - GetSystemMetrics(SM_CXVSCROLL)) / 3;
            // Indicate this is the first column
            lvc.iSubItem = eColumnLocalName;
            // Insert column
            ListView_InsertColumn(hWndList, lvc.iSubItem, &lvc);

            // Remote Name Column
            // Load the text
            GetResourceString(IDS_REMOTENAME_LABEL, szText, sizeof(szText) / sizeof(WCHAR));
            // Set the column text
            lvc.pszText = szText;
            // Indicate this is the second column
            lvc.iSubItem = eColumnRemoteName;
            // Insert column
            ListView_InsertColumn(hWndList, lvc.iSubItem, &lvc);

            // Stress Type Column
            // Load the text
            GetResourceString(IDS_STRESSTYPE_LABEL, szText, sizeof(szText) / sizeof(WCHAR));
            // Set the column text
            lvc.pszText = szText;
            // Set the width of the column to be about 1 / 6 of the width of the status list, allowing for the width of the borders and scroll bar
            lvc.cx /= 2;
            // Indicate this is the third column
            lvc.iSubItem = eColumnStressType;
            // Insert column
            ListView_InsertColumn(hWndList, lvc.iSubItem, &lvc);

            // Status Column
            // Load the text
            GetResourceString(IDS_STATUS_LABEL, szText, sizeof(szText) / sizeof(WCHAR));
            // Set the column text
            lvc.pszText = szText;
            // Indicate this is the fourth column
            lvc.iSubItem = eColumnStatus;
            // Insert column
            ListView_InsertColumn(hWndList, lvc.iSubItem, &lvc);

            // Set the caption
            GetResourceString(IDS_STATUS_CAPTION, szText, sizeof(szText) / sizeof(WCHAR));
            SetWindowText(hDlg, szText);

            // Create the memory object
            hMemObject = xMemCreate();
            if (INVALID_HANDLE_VALUE == hMemObject) {
                // Get the last error
                dwErrorCode = GetLastError();

                // Get the resource string buffer
                GetResourceString(IDS_MEMORY_INIT_FAILED, szError, sizeof(szError) / sizeof(WCHAR), dwErrorCode);

                goto UM_DIALOG_INITIALIZE_Exit;
            }

            // Initialize Winsock
            ZeroMemory(&WSAData, sizeof(WSAData));
            dwErrorCode = WSAStartup(MAKEWORD(2, 2), &WSAData);
            if (ERROR_SUCCESS != dwErrorCode) {
                // Get the resource string buffer
                GetResourceString(IDS_WINSOCK_INIT_FAILED, szError, sizeof(szError) / sizeof(WCHAR), dwErrorCode);

                goto UM_DIALOG_INITIALIZE_Exit;
            }
            else {
                bWinsockInitialized = TRUE;
            }

UM_DIALOG_INITIALIZE_Exit:
            if (ERROR_SUCCESS != dwErrorCode) {
                // Display the error message
                GetResourceString(IDS_STATUS_CAPTION, szText, sizeof(szText) / sizeof(WCHAR));
                MessageBox(NULL, szError, szText, MB_OK | MB_ICONERROR);

                // End the dialog
                bDlgInitialized = FALSE;
                DestroyWindow(hDlg);
                PostQuitMessage(dwErrorCode);
            }


            break;

        case UM_DIALOG_ENABLE:
            // Enable \ Disable the UI
            EnableWindow(GetDlgItem(hDlg, IDC_HOST_NAME_STATIC), (BOOL) lParam);
            EnableWindow(GetDlgItem(hDlg, IDC_HOST_NAME_TEXT), (BOOL) lParam);
            EnableWindow(GetDlgItem(hDlg, IDC_QUERY_BUTTON), (BOOL) lParam);

            if (FALSE == (BOOL) lParam) {
                SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM) hWndList, MAKELONG(TRUE, 0));
            }

            break;

        case UM_DIALOG_ADD:
            // Allocate the memory for the client object
            pClientObject = (PCLIENT_OBJECT) xMemAlloc(hMemObject, sizeof(CLIENT_OBJECT));

            // Set the client object
            CopyMemory(&pClientObject->LocalAddr, &((PSTRESS_STATUS_CLIENT_MESSAGE) lParam)->StressClient.ClientXnAddr.ina, sizeof(pClientObject->LocalAddr));
            CopyMemory(&pClientObject->RemoteAddr, &((PSTRESS_STATUS_CLIENT_MESSAGE) lParam)->StressClient.RemoteXnAddr.ina, sizeof(pClientObject->RemoteAddr));
            pClientObject->dwStressType = ((PSTRESS_STATUS_CLIENT_MESSAGE) lParam)->StressClient.dwStressType;
            pClientObject->dwStatus = ((PSTRESS_STATUS_CLIENT_MESSAGE) lParam)->StressClient.dwStatus;

            // Insert the item

            // Indicate pszText and lParam are valid
            lvi.mask = LVIF_TEXT | LVIF_PARAM;

            // Set the text
            wsprintf(szText, L"%d.%d.%d.%d", pClientObject->LocalAddr.S_un.S_un_b.s_b1, pClientObject->LocalAddr.S_un.S_un_b.s_b2, pClientObject->LocalAddr.S_un.S_un_b.s_b3, pClientObject->LocalAddr.S_un.S_un_b.s_b4);
            lvi.pszText = szText;
            // Set the lParam
            lvi.lParam = (long) pClientObject;
            // Set the item number
            lvi.iItem = ListView_GetItemCount(hWndList);
            // Indicate this is the first column
            lvi.iSubItem = eColumnLocalName;
            // Insert item
            ListView_InsertItem(hWndList, &lvi);

            // Indicate only pszText is valid
            lvi.mask = LVIF_TEXT;

            // Set the text
            wsprintf(szText, L"%d.%d.%d.%d", pClientObject->RemoteAddr.S_un.S_un_b.s_b1, pClientObject->RemoteAddr.S_un.S_un_b.s_b2, pClientObject->RemoteAddr.S_un.S_un_b.s_b3, pClientObject->RemoteAddr.S_un.S_un_b.s_b4);
            lvi.pszText = szText;
            // Indicate this is the second column
            lvi.iSubItem = eColumnRemoteName;
            // Set item
            ListView_SetItem(hWndList, &lvi);

            // Set the text
            wsprintf(szText, L"Type %d", pClientObject->dwStressType);
            lvi.pszText = szText;
            // Indicate this is the third column
            lvi.iSubItem = eColumnStressType;
            // Set item
            ListView_SetItem(hWndList, &lvi);

            // Set the text
            if (STATUS_REGISTERED == pClientObject->dwStatus) {
                wcscpy(szText, L"Registered");
            }
            else if (STATUS_STARTED == pClientObject->dwStatus) {
                wcscpy(szText, L"Started");
            }
            else {
                wcscpy(szText, L"Waiting");
            }
            lvi.pszText = szText;
            // Indicate this is the fourth column
            lvi.iSubItem = eColumnStatus;
            // Set item
            ListView_SetItem(hWndList, &lvi);

            // Sort the status list
            ListView_SortItems(hWndList, SortClientObjects, eCurrentSortMethod);

            break;

        case UM_DIALOG_DELETE:
            // Delete the items in the list

            // Set the item mask
            lvi.mask = LVIF_PARAM;

            // Get the number of items in the list
            dwItemCount = ListView_GetItemCount(hWndList);
            for (dwItem = dwItemCount; dwItem > 0; dwItem--) {
                // Get the item
                lvi.iItem = dwItem - 1;
                ListView_GetItem(hWndList, &lvi);

                // Get the client message
                pClientObject = (PCLIENT_OBJECT) lvi.lParam;

                // Delete the item
                ListView_DeleteItem(hWndList, lvi.iItem);

                // Free the client object
                xMemFree(hMemObject, pClientObject);
            }

        case WM_NOTIFY:
            // Get the WM_NOTIFY message header
            pnmhdr = (LPNMHDR) lParam;

            if ((NULL != pnmhdr) && (hWndList == pnmhdr->hwndFrom) && (LVN_COLUMNCLICK == pnmhdr->code)) {
                // Get the LVN_COLUMNCLICK message
                pnmlistview = (LPNMLISTVIEW) lParam;

                // Update the sort method
                switch (pnmlistview->iSubItem) {
                    case eColumnLocalName:
                        if (eSortLocalNameAscending != eCurrentSortMethod) {
                            eCurrentSortMethod = eSortLocalNameAscending;
                        }
                        else {
                            eCurrentSortMethod = eSortLocalNameDescending;
                        }

                        break;

                    case eColumnRemoteName:
                        if (eSortRemoteNameAscending != eCurrentSortMethod) {
                            eCurrentSortMethod = eSortRemoteNameAscending;
                        }
                        else {
                            eCurrentSortMethod = eSortRemoteNameDescending;
                        }

                        break;

                    case eColumnStressType:
                        if (eSortStressTypeAscending != eCurrentSortMethod) {
                            eCurrentSortMethod = eSortStressTypeAscending;
                        }
                        else {
                            eCurrentSortMethod = eSortStressTypeDescending;
                        }

                        break;

                    case eColumnStatus:
                        if (eSortStatusAscending != eCurrentSortMethod) {
                            eCurrentSortMethod = eSortStatusAscending;
                        }
                        else {
                            eCurrentSortMethod = eSortStatusDescending;
                        }

                        break;

                    default:
                        break;
                }

                // Sort the status list
                ListView_SortItems(hWndList, SortClientObjects, eCurrentSortMethod);
            }

            break;

        case WM_COMMAND:
            if (IDC_QUERY_BUTTON == LOWORD(wParam)) {
                // Close the query thread, if necessary
                if (NULL == hQueryThread) {
                    CloseHandle(hQueryThread);
                    hQueryThread = NULL;
                }

                // Create the query thread
                hQueryThread = CreateThread(NULL, 0, QueryThreadProc, (LPVOID) hDlg, 0, NULL);
            }

            break;

        case WM_QUERYENDSESSION:
        case WM_ENDSESSION:
        case WM_CLOSE:
        case WM_DESTROY:
            if (TRUE == bDlgInitialized) {
                // Delete the items in the list view
                SendMessage(hDlg, UM_DIALOG_DELETE, 0, 0);
            }

            // Check if query thread is still running
            if (hQueryThread != NULL) {
                if ((GetExitCodeThread(hQueryThread, &dwExitCode) == FALSE) || (dwExitCode == STILL_ACTIVE)) {
                    return FALSE;
                }

                CloseHandle(hQueryThread);
                hQueryThread = NULL;
            }

            // Terminate Winsock
            if (TRUE == bWinsockInitialized) {
                WSACleanup();
                bWinsockInitialized = FALSE;
            }

            // Free the memory object
            if (INVALID_HANDLE_VALUE != hMemObject) {
                xMemClose(hMemObject);
                hMemObject = INVALID_HANDLE_VALUE;
            }

            // End the dialog
            if (TRUE == bDlgInitialized) {
                bDlgInitialized = FALSE;
                DestroyWindow(hDlg);
                PostQuitMessage(ERROR_SUCCESS);
            }

            break;

    }

    return DefDlgProc(hDlg, iMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\xnet\stress\status\util.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module contains the utility functions for xnetstressstatus.exe

Author:

  Steven Kehrli (steveke) 8-Feb-2002

-----------------------------------------------------------------------------*/

#include "precomp.h"



BOOL
FormatResourceString(
    UINT     uResource,
    LPWSTR   lpszString,
    DWORD    dwStringSize,
    va_list  varg_ptr
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Formats a resource string using a variable argument list

Arguments:

  uResource - Specifies the resource id
  lpszString - Pointer to the resource string buffer
  dwStringSize - Specifies the resource string buffer size
  varg_ptr - Pointer to the variable argument list

Return Value:

  BOOL:
    If the function succeeds, the return value is non-zero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

-----------------------------------------------------------------------------*/
{
    // hModule is a handle to the module
    HMODULE  hModule = NULL;
    // szResourceBuffer is a buffer for the string resource
    WCHAR    szResourceBuffer[256];
    // dwResult is the result code
    DWORD    dwResult = 0;



    // Get the module handle
    hModule = GetModuleHandle(NULL);
    if (hModule == NULL)
    {
        return FALSE;
    }

    // Initialize the string resource buffer
    ZeroMemory(szResourceBuffer, sizeof(szResourceBuffer));

    // Load the string resource
    if (0 != LoadString(hModule, uResource, szResourceBuffer, sizeof(szResourceBuffer) / sizeof(WCHAR))) {
        // Copy the string resource
        dwResult = _vsnwprintf(lpszString, dwStringSize, szResourceBuffer, varg_ptr);
    }

    return ((0 != dwResult) && (dwStringSize != dwResult));
}



BOOL
GetResourceString(
    UINT    uResource,
    LPWSTR  lpszString,
    DWORD   dwStringSize
    ...
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets a resource string by calling FormatResourceString()

Arguments:

  uResource - Resource id
  lpszString - Pointer to the resource string buffer
  dwStringSize - Specifies the resource string buffer size

Return Value:

  BOOL:
    If the function succeeds, the return value is non-zero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

-----------------------------------------------------------------------------*/
{
    // varg_ptr is a pointer to the variable argument list
    va_list  varg_ptr;



    // Get the variable argument list
    va_start(varg_ptr, dwStringSize);

    // Call FormatResourceString
    return FormatResourceString(uResource, lpszString, dwStringSize, varg_ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dash\makefile.inc ===
$(TARGETPATH)\xipsums.bin: $(XIPS)
    -md obj
    xipsign $@ $(XIPS)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dash\dvd\dvd_paneltex.h ===
// Automatically generated by the bundler tool from dvd_paneltex.txt

#define dvd_paneltex_NUM_RESOURCES 1UL

#define dvd_paneltex_MyTex_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dashst\dshstpch.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    dshstpch.h

Abstract:

    precompiled header for dash soundtrack support.

--*/

#ifndef _DASHST_
#define _DASHST_

#include <xtl.h>
#include <xboxp.h>
#include <xdbg.h>

#endif // _DASHST_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dashst\dashst.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dashst.c

Abstract:

    Dash soundtrack library

Notes:

    Provides support for creating and managing soundtracks.

--*/

#include "dshstpch.h"
#include "stdio.h"

#define STDB_MUSICDIR "T:\\MUSIC\\"
#define STDB_FILE "T:\\MUSIC\\ST.DB"

#define SEEKTOSOUNDTRACK(block) (SetFilePointer (g_DashStGlobals.DbHandle, ((block) + 1) * STDB_PAGE_SIZE, 0, FILE_BEGIN))
#define SEEKTOLISTSEGMENT(block) (SetFilePointer (g_DashStGlobals.DbHandle, (MAX_SOUNDTRACKS + 1 + (block)) * STDB_PAGE_SIZE, 0, FILE_BEGIN))
#define SEEKBYPAGE(page) (SetFilePointer (g_DashStGlobals.DbHandle, (page) * STDB_PAGE_SIZE, 0, FILE_CURRENT))


//
// These are cache variables used by the enumeration/info routines in XTL. Need to clear them on some operations.
//
extern STDB_LIST XapiListLookaside;
extern STDB_STDESC XapiStLookaside;


struct {

    HANDLE DbHandle;
    STDB_HDR Header;
    BYTE Buffer[STDB_PAGE_SIZE];

} g_DashStGlobals;

VOID
DashClearStCaches (
    VOID
    )
{

    XapiListLookaside.StId = INVALID_STID;
    XapiStLookaside.Id = INVALID_STID;
}


BOOL
DashReadFromStDb (
    DWORD Signature
    )
{

    DWORD byteCount;
    return ReadFile (g_DashStGlobals.DbHandle, g_DashStGlobals.Buffer, STDB_PAGE_SIZE, &byteCount, NULL)
        && byteCount == STDB_PAGE_SIZE
        && (!Signature || (*(PDWORD) g_DashStGlobals.Buffer) == Signature);
}


BOOL
DashBeginUsingSoundtracks (
    VOID
    )
{
    PBYTE buf;
    DWORD byteCount;

    memset (&g_DashStGlobals, 0, sizeof (g_DashStGlobals));

    //
    // Create the Soundtrack Music Directory if it does not exist
    //
    CreateDirectory( STDB_MUSICDIR, NULL );

    //
    // Open the soundtrack database and read in header.
    //
    g_DashStGlobals.DbHandle = CreateFile (
                                    STDB_FILE,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

    if (g_DashStGlobals.DbHandle != INVALID_HANDLE_VALUE) {
        if (!DashReadFromStDb (0)) {

            CloseHandle (g_DashStGlobals.DbHandle);
            g_DashStGlobals.DbHandle = INVALID_HANDLE_VALUE;
        }
        else {
            memcpy (&g_DashStGlobals.Header, g_DashStGlobals.Buffer, sizeof (STDB_HDR));
        }
    }





    if (g_DashStGlobals.DbHandle == INVALID_HANDLE_VALUE) {
        if (GetLastError () == ERROR_FILE_NOT_FOUND) {
            //
            // Need to create the database file.
            //
            g_DashStGlobals.DbHandle = CreateFile (
                                    STDB_FILE,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

            if (g_DashStGlobals.DbHandle != INVALID_HANDLE_VALUE) {

                buf = (PBYTE) LocalAlloc (LPTR, STDB_PAGE_SIZE * (MAX_SOUNDTRACKS + 1) * sizeof (BYTE));


                ((PSTDB_HDR) buf)->Version = STDB_VERSION;
                if (WriteFile (g_DashStGlobals.DbHandle, buf, STDB_PAGE_SIZE * (MAX_SOUNDTRACKS + 1), &byteCount, NULL) &&
                    byteCount == STDB_PAGE_SIZE * (MAX_SOUNDTRACKS + 1)) {

                    CloseHandle (g_DashStGlobals.DbHandle);
                    LocalFree (buf);
                    return DashBeginUsingSoundtracks ();
                }
                else {
                    CloseHandle (g_DashStGlobals.DbHandle);
                    LocalFree (buf);
                    g_DashStGlobals.DbHandle = INVALID_HANDLE_VALUE;
                }
            }
        }
    }

    return g_DashStGlobals.DbHandle != INVALID_HANDLE_VALUE;
}

VOID
DashEndUsingSoundtracks (
    VOID
    )
{
    CloseHandle (g_DashStGlobals.DbHandle);
}

BOOL
DashWriteToStDb (
    VOID
    )

{
    DWORD byteCount;
    return WriteFile (g_DashStGlobals.DbHandle, g_DashStGlobals.Buffer, STDB_PAGE_SIZE, &byteCount, NULL) && byteCount == STDB_PAGE_SIZE;
}

BOOL
DashUpdateHeaderInStDb (
    VOID
    )
{
    memcpy (g_DashStGlobals.Buffer, &g_DashStGlobals.Header, sizeof (STDB_HDR));
    SetFilePointer (g_DashStGlobals.DbHandle, 0, 0, FILE_BEGIN);
    return DashWriteToStDb ();
}


BOOL
DashAddSoundtrack (
    PCWSTR SoundtrackName,
    PDWORD Stid
    )
{
    PSTDB_STDESC pst = (PSTDB_STDESC) g_DashStGlobals.Buffer;
    UINT block;
    BOOL b;
    CHAR newDir[MAX_PATH];


    //
    // Ensure that the global data is up to date.
    //
    if (g_DashStGlobals.DbHandle == INVALID_HANDLE_VALUE) {
        XDBGWRN ("Dash Soundtracks", "Soundtrack DB not open. Use DashBeginUsingSoundtracks ()");
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (g_DashStGlobals.Header.StCount == MAX_SOUNDTRACKS) {
        XDBGWRN ("Dash Soundtracks", "Soundtrack DB full. Delete soundtracks first.");
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // Create the new soundtrack data for the database.
    //
    memset (pst, 0, sizeof (STDB_STDESC));
    pst->Id = g_DashStGlobals.Header.NextStId++;
    *Stid = pst->Id;
    pst->Signature = STDB_STSIG;

    lstrcpyn (pst->Name, SoundtrackName, MAX_SOUNDTRACK_NAME);

    block = g_DashStGlobals.Header.StCount++;


    g_DashStGlobals.Header.StBlocks[block] = pst->Id;
    SEEKTOSOUNDTRACK(block);

    //
    // Create the soundtrack directory. This is where the songs themselves will eventually live.
    //
    sprintf (newDir, "%s%04x", STDB_MUSICDIR, *Stid);
    b = CreateDirectory (newDir, NULL);

    //
    // If the directory already exists, we will trust that the dash knows what it is doing.
    //
    if (!b && GetLastError () == ERROR_ALREADY_EXISTS) {
        b = TRUE;
    }


    //
    // Update information in soundtrack database.
    //
    if (b) {
        b = DashWriteToStDb () && DashUpdateHeaderInStDb ();
    }

    return b;
}

DWORD
DashFindStBlock (
    DWORD Stid
    )
{
    int i;
    for (i = 0; i < MAX_SOUNDTRACKS; i++) {
        if (g_DashStGlobals.Header.StBlocks[i] == Stid) {
            break;
        }
    }

    return i;
}

BOOL
DashDeleteSoundtrack (
    DWORD Stid
    )
{

    UINT i;
    BOOL b = TRUE;
    UINT block;
    STDB_STDESC st;
    CHAR buf[MAX_PATH];
    HANDLE h;
    WIN32_FIND_DATA fd;


    if (g_DashStGlobals.DbHandle == INVALID_HANDLE_VALUE) {
        XDBGWRN ("Dash Soundtracks", "Soundtrack DB not open. Use DashBeginUsingSoundtracks ()");
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }


    block = DashFindStBlock (Stid);
    if (block == MAX_SOUNDTRACKS) {
        XDBGWRN ("Dash Soundtracks", "Soundtrack %u not found in database.", Stid);
        SetLastError (ERROR_INVALID_INDEX);
        return FALSE;
    }




    SEEKTOSOUNDTRACK(block);
    b = DashReadFromStDb (STDB_STSIG);

    //
    // Mark all list segments of this soundtrack as !InUse.
    //
    if (b) {

        memcpy (&st, g_DashStGlobals.Buffer, sizeof (STDB_STDESC));
        for (i = 0; i * WMADESC_LIST_SIZE < st.SongCount; i++) {
            SEEKTOLISTSEGMENT (st.ListBlocks[i]);
            b = DashReadFromStDb (STDB_LISTSIG);
            if (b) {

                ((PSTDB_LIST) g_DashStGlobals.Buffer)->InUse = FALSE;
                SEEKBYPAGE(-1);
                b = DashWriteToStDb ();
            }
        }
    }

    //
    // Update position of all following soundtrakcs and remove this
    // soundtrack from the list.
    //
    if (b) {
        for (i = block + 1; b && i < g_DashStGlobals.Header.StCount; i++) {

            g_DashStGlobals.Header.StBlocks[i-1] = g_DashStGlobals.Header.StBlocks[i];

            SEEKTOSOUNDTRACK(i);
            b = DashReadFromStDb (STDB_STSIG);
            if (b) {
                SEEKBYPAGE(-2);
                b = DashWriteToStDb ();
            }
        }
    }


    if (b) {

        g_DashStGlobals.Header.StCount--;
        DashUpdateHeaderInStDb ();
    }

    if (b) {

        //
        // Delete the directory and all contents.
        // BUGBUG -- currently assumes there are no subdirectories. function needs to
        // cnange if this assumption is wrong.
        //
        sprintf (buf, "%s%04x\\*.*", STDB_MUSICDIR, Stid);
        h = FindFirstFile (buf, &fd);
        if (h != INVALID_HANDLE_VALUE) {
            do {

                if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    sprintf (buf, "%s%04x\\%s", STDB_MUSICDIR, Stid, fd.cFileName);
                    if( !DeleteFile (buf) )
                    {
                        if( !SetFileAttributes( buf, FILE_ATTRIBUTE_NORMAL ) )
                        {
                            XDBGWRN ("Dash Soundtracks", "Failed to set file attributes!! - '%hs', Error - '0x%0.8X (%d)'", buf, GetLastError(), GetLastError() );
                        }

                        if( !( b = DeleteFile (buf) ) )
                        {
                            XDBGWRN ("Dash Soundtracks", "Failed to delete a second time!! - '%hs', Error - '0x%0.8X (%d)'", buf, GetLastError(), GetLastError() );
                        }
                    }
                }

            } while (FindNextFile (h, &fd));

            FindClose( h );
        }

        if( b )
        {
            sprintf (buf, "%s%04x", STDB_MUSICDIR, Stid);
            if( !( b = RemoveDirectory (buf) ) )
            {
                XDBGWRN ("Dash Soundtracks", "Failed to remove the directory!! - '%hs', Error - '0x%0.8X (%d)'", buf, GetLastError(), GetLastError() );
            }
        }
    }


    return b;

}

UINT
DashFindNewListBlock (
    VOID
    )
{
    UINT block = 0;
    BOOL found = FALSE;


    SEEKTOLISTSEGMENT(0);

    while (DashReadFromStDb (STDB_LISTSIG)) {
        if (!((PSTDB_LIST) g_DashStGlobals.Buffer)->InUse) {
            found = TRUE;
            break;
        }

        block++;
    }

    if (!found) {
        //
        // No empty list block found. Fix that problem.
        //
        SetFilePointer (g_DashStGlobals.DbHandle, 0, 0, FILE_END);
        ((PSTDB_LIST) g_DashStGlobals.Buffer)->InUse = FALSE;
        ((PSTDB_LIST) g_DashStGlobals.Buffer)->Signature = STDB_LISTSIG;
        DashWriteToStDb ();
        return DashFindNewListBlock ();
    }

    return block;

}

BOOL
DashDeleteSongFromSoundtrack (
    IN DWORD Stid,
    IN UINT Index
    )
{
    STDB_STDESC st;
    UINT stBlock;
    BOOL b = TRUE;
    UINT listIndex;
    UINT aryIndex;
    STDB_LIST curList;
    STDB_LIST nextList;
    UINT songId;
    CHAR path[MAX_PATH];

    if (g_DashStGlobals.DbHandle == INVALID_HANDLE_VALUE) {
        XDBGWRN ("Dash Soundtracks", "Soundtrack DB not open. Use DashBeginUsingSoundtracks ()");
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Find the appropriate soundtrack.
    //
    stBlock = DashFindStBlock (Stid);
    if (stBlock == MAX_SOUNDTRACKS) {
        SetLastError (ERROR_INVALID_INDEX);
        XDBGWRN ("Dash Soundtracks", "Soundtrack %u not found in database.", Stid);
        return FALSE;
    }

    SEEKTOSOUNDTRACK(stBlock);
    if (!DashReadFromStDb (STDB_STSIG)) {
        SetLastError (ERROR_INVALID_PARAMETER);
        XDBGWRN ("Dash Soundtracks", "Unable to read in soundtrack %u to be modified.", Stid);
        return FALSE;
    }

    memcpy (&st, g_DashStGlobals.Buffer, sizeof (STDB_STDESC));

    if (Index >= st.SongCount) {
        XDBGWRN ("Dash Soundtracks", "Song index %u outside range in soundtrack %u.", Index, Stid);
        SetLastError (ERROR_INVALID_INDEX);
        return FALSE;
    }




    listIndex = Index / WMADESC_LIST_SIZE;
    aryIndex = Index % WMADESC_LIST_SIZE;
    SEEKTOLISTSEGMENT (st.ListBlocks[listIndex]);
    b = DashReadFromStDb (STDB_LISTSIG);

    if (b) {





        memcpy (&curList, g_DashStGlobals.Buffer, sizeof (STDB_LIST));
        st.SoundtrackLength -= curList.SongLengths[aryIndex];
        aryIndex = Index % WMADESC_LIST_SIZE;
        songId = curList.SongIds[aryIndex];

        //
        // Shift first list segment data.
        //
        memcpy (curList.SongLengths + aryIndex, curList.SongLengths + aryIndex + 1, (WMADESC_LIST_SIZE - aryIndex - 1) * sizeof (DWORD));
        memcpy (curList.SongIds + aryIndex, curList.SongIds + aryIndex + 1, (WMADESC_LIST_SIZE - aryIndex - 1) * sizeof (DWORD));
        memcpy (curList.SongNames + aryIndex, curList.SongNames + aryIndex + 1, (WMADESC_LIST_SIZE - aryIndex - 1) * sizeof (WCHAR) * MAX_SONG_NAME);

        Index += WMADESC_LIST_SIZE - aryIndex;
        while (st.SongCount > Index) {
            SEEKTOLISTSEGMENT (st.ListBlocks[listIndex + 1]);
            b = DashReadFromStDb (STDB_LISTSIG);
            memcpy (&nextList, g_DashStGlobals.Buffer, sizeof (STDB_LIST));
            if (b) {


                curList.SongIds[WMADESC_LIST_SIZE - 1] = nextList.SongIds[0];
                lstrcpyn (curList.SongNames[WMADESC_LIST_SIZE - 1], nextList.SongNames[0], MAX_SONG_NAME);
                curList.SongLengths[WMADESC_LIST_SIZE - 1] = nextList.SongLengths[0];

                memcpy (g_DashStGlobals.Buffer, &curList, sizeof (STDB_LIST));
                SEEKTOLISTSEGMENT (st.ListBlocks[listIndex]);
                b = DashWriteToStDb ();

                memcpy (&curList, &nextList, sizeof (STDB_LIST));
                listIndex++;
                if (st.SongCount == Index + 1) {
                    curList.InUse = FALSE;
                }

                aryIndex = 0;
                memcpy (curList.SongLengths + aryIndex, curList.SongLengths + aryIndex + 1, (WMADESC_LIST_SIZE - aryIndex - 1) * sizeof (DWORD));
                memcpy (curList.SongIds + aryIndex, curList.SongIds + aryIndex + 1, (WMADESC_LIST_SIZE - aryIndex - 1) * sizeof (DWORD));
                memcpy (curList.SongNames + aryIndex, curList.SongNames + aryIndex + 1, (WMADESC_LIST_SIZE - aryIndex - 1) * sizeof (WCHAR) * MAX_SONG_NAME);

                Index += WMADESC_LIST_SIZE - aryIndex;
            }
        }

        memcpy (g_DashStGlobals.Buffer, &curList, sizeof (STDB_LIST));
        SEEKTOLISTSEGMENT (st.ListBlocks[listIndex]);
        b = DashWriteToStDb ();


    }


    if (b) {


        //
        // Update soundtrack description information.
        //
        st.SongCount--;
        memcpy (g_DashStGlobals.Buffer, &st, sizeof (STDB_STDESC));
        SEEKTOSOUNDTRACK (stBlock);
        if (!DashWriteToStDb ()) {
            XDBGWRN ("Dash Soundtracks", "Unable to update soundtrack.");
            return FALSE;
        }
    }

    if (b) {

        sprintf (path, "T:\\MUSIC\\%04x\\%08x.WMA", HIWORD(songId), songId);
        if (!DeleteFile(path)) {
            if( !SetFileAttributes(path, FILE_ATTRIBUTE_NORMAL) ) {
                XDBGWRN ("Dash Soundtracks", "Failed to set file attributes!! - '%hs', Error - '0x%0.8X (%d)'", path, GetLastError(), GetLastError() );
            }

            if( !(b = DeleteFile(path)) )
            {
                XDBGWRN ("Dash Soundtracks", "Failed to delete a second time!! - '%hs', Error - '0x%0.8X (%d)'", path, GetLastError(), GetLastError() );
            }
        }
    }


    DashClearStCaches ();


    return b;
}


BOOL
DashAddSongToSoundtrack (
    IN DWORD Stid,
    IN DWORD Songid,
    IN DWORD Length,
    IN PCWSTR Name
    )
{

    UINT stBlock;
    UINT listBlock;
    STDB_STDESC st;
    UINT listIndex;
    UINT index;
    PSTDB_LIST plist;
    BOOL b = TRUE;



    if (g_DashStGlobals.DbHandle == INVALID_HANDLE_VALUE) {
        XDBGWRN ("Dash Soundtracks", "Soundtrack DB not open. Use DashBeginUsingSoundtracks ()");
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }


    //
    // Find the appropriate soundtrack.
    //
    stBlock = DashFindStBlock (Stid);
    if (stBlock == MAX_SOUNDTRACKS) {
        SetLastError (ERROR_INVALID_INDEX);
        XDBGWRN ("Dash Soundtracks", "Soundtrack %u not found in database.", Stid);
        return FALSE;
    }

    SEEKTOSOUNDTRACK(stBlock);
    if (!DashReadFromStDb (STDB_STSIG)) {
        XDBGWRN ("Dash Soundtracks", "Unable to read in soundtrack %u to be modified.", Stid);
        return FALSE;
    }

    memcpy (&st, g_DashStGlobals.Buffer, sizeof (STDB_STDESC));

    //
    // Ensure that greater than max_songs is not created.
    //
    if (st.SongCount >= MAX_SONGS) {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        XDBGWRN ("Dash Soundtracks", "Too many songs in soundtrack %u.", Stid);
        return FALSE;
    }

    st.SongCount++;
    st.SoundtrackLength += Length;
    index = ((st.SongCount - 1) % WMADESC_LIST_SIZE);
    listIndex = (st.SongCount - 1) / WMADESC_LIST_SIZE;


    //
    // Find list segment that will hold this new song.
    //
    if (index == 0) {
        //
        // Need a new list segment.
        //
        listBlock = DashFindNewListBlock ();
        st.ListBlocks[listIndex] = listBlock;
    }
    else {

        listBlock = st.ListBlocks[listIndex];
    }

    //
    // Update the soundtrack data.
    //
    SEEKTOSOUNDTRACK(stBlock);
    memcpy (g_DashStGlobals.Buffer, &st, sizeof (STDB_STDESC));
    b = DashWriteToStDb ();

    //
    // Update the list segment data.
    //

    if (b) {

        SEEKTOLISTSEGMENT(listBlock);
        b = DashReadFromStDb (STDB_LISTSIG);
        plist = (PSTDB_LIST) g_DashStGlobals.Buffer;
    }

    if (b) {
        if (index == 0) {

            memset (plist, 0, sizeof (STDB_LIST));
            plist->InUse = TRUE;
            plist->Signature = STDB_LISTSIG;
            plist->StId = Stid;
            plist->ListIndex = listIndex;
        }

        plist->SongIds[index] = Songid;
        plist->SongLengths[index] = Length;
        lstrcpyn (plist->SongNames[index], Name, MAX_SONG_NAME);

        SEEKBYPAGE(-1);
        DashWriteToStDb ();
    }

    DashClearStCaches ();

    return b;
}

BOOL
DashSwapSoundtracks (
    UINT Stid1,
    UINT Stid2
    )
{

    UINT stBlock1, stBlock2;
    STDB_STDESC stTemp;



    if (g_DashStGlobals.DbHandle == INVALID_HANDLE_VALUE) {
        XDBGWRN ("Dash Soundtracks", "Soundtrack DB not open. Use DashBeginUsingSoundtracks ()");
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }


    //
    // Find the appropriate soundtracks.
    //
    stBlock1 = DashFindStBlock (Stid1);
    if (stBlock1 == MAX_SOUNDTRACKS) {
        SetLastError (ERROR_INVALID_INDEX);
        XDBGWRN ("Dash Soundtracks", "Soundtrack %u not found in database.", Stid1);
        return FALSE;
    }

    SEEKTOSOUNDTRACK(stBlock1);
    if (!DashReadFromStDb (STDB_STSIG)) {
        XDBGWRN ("Dash Soundtracks", "Unable to read in soundtrack %u to be modified.", Stid1);
        return FALSE;
    }

    memcpy (&stTemp, g_DashStGlobals.Buffer, sizeof (STDB_STDESC));

    stBlock2 = DashFindStBlock (Stid2);
    if (stBlock2 == MAX_SOUNDTRACKS) {
        XDBGWRN ("Dash Soundtracks", "Soundtrack %u not found in database.", Stid2);
        return FALSE;
    }

    SEEKTOSOUNDTRACK(stBlock2);
    if (!DashReadFromStDb (STDB_STSIG)) {
        XDBGWRN ("Dash Soundtracks", "Unable to read in soundtrack %u to be modified.", Stid2);
        return FALSE;
    }

    SEEKTOSOUNDTRACK(stBlock1);
    if (!DashWriteToStDb ()) {
        XDBGWRN ("Dash Soundtracks", "Unable to write soundtrack %u back to db.", Stid2);
        return FALSE;
    }

    SEEKTOSOUNDTRACK(stBlock2);
    memcpy (g_DashStGlobals.Buffer, &stTemp, sizeof (STDB_STDESC));
    if (!DashWriteToStDb ()) {
        XDBGWRN ("Dash Soundtracks", "Unable to write soundtrack %u back to db.", Stid1);
        return FALSE;
    }

    g_DashStGlobals.Header.StBlocks[stBlock1] = g_DashStGlobals.Header.StBlocks[stBlock2];
    g_DashStGlobals.Header.StBlocks[stBlock2] = stTemp.Id;
    DashUpdateHeaderInStDb ();

    return TRUE;

}


BOOL
DashSwapSongs (
    DWORD Stid,
    DWORD Index1,
    DWORD Index2
    )
{

    UINT stBlock;
    PSTDB_STDESC pst;
    PSTDB_LIST plist;
    STDB_LIST tempList;
    UINT songBlock1;
    UINT songBlock2;
    UINT tempId;
    UINT tempLength;
    WCHAR tempName[MAX_SONG_NAME + 1];
    BOOL b = TRUE;

    if (g_DashStGlobals.DbHandle == INVALID_HANDLE_VALUE) {
        XDBGWRN ("Dash Soundtracks", "Soundtrack DB not open. Use DashBeginUsingSoundtracks ()");
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }


    //
    // Find the appropriate soundtracks.
    //
    stBlock = DashFindStBlock (Stid);
    if (stBlock == MAX_SOUNDTRACKS) {
        SetLastError (ERROR_INVALID_INDEX);
        XDBGWRN ("Dash Soundtracks", "Soundtrack %u not found in database.", Stid);
        return FALSE;
    }

    SEEKTOSOUNDTRACK(stBlock);
    if (!DashReadFromStDb (STDB_STSIG)) {
        XDBGWRN ("Dash Soundtracks", "Unable to read in soundtrack %u to be modified.", Stid);
        return FALSE;
    }

    pst = (PSTDB_STDESC) g_DashStGlobals.Buffer;

    if (Index1 >= pst->SongCount || Index2 >= pst->SongCount) {
        XDBGWRN ("Dash Soundtracks", "Indexes out of range.");
        return FALSE;
    }

    songBlock1 = pst->ListBlocks[Index1 / WMADESC_LIST_SIZE];
    songBlock2 = pst->ListBlocks[Index2 / WMADESC_LIST_SIZE];

    Index1 %= WMADESC_LIST_SIZE;
    Index2 %= WMADESC_LIST_SIZE;

    SEEKTOLISTSEGMENT (songBlock1);
    if (!DashReadFromStDb (STDB_LISTSIG)) {
        XDBGWRN ("Dash Soundtracks", "Unable to read list segment.");
        return FALSE;
    }



    if (songBlock1 == songBlock2) {
        //
        // Update within same block.
        //
        plist = (PSTDB_LIST) g_DashStGlobals.Buffer;

        tempId = plist->SongIds[Index1];
        tempLength = plist->SongLengths[Index1];
        lstrcpyn (tempName, plist->SongNames[Index1], MAX_SONG_NAME);

        plist->SongIds[Index1] = plist->SongIds[Index2];
        plist->SongLengths[Index1] = plist->SongLengths[Index2];
        lstrcpyn (plist->SongNames[Index1], plist->SongNames[Index2], MAX_SONG_NAME);

        plist->SongIds[Index2] = tempId;
        plist->SongLengths[Index2] = tempLength;
        lstrcpyn (plist->SongNames[Index2], tempName, MAX_SONG_NAME);

        SEEKBYPAGE(-1);
        b = DashWriteToStDb ();
    }
    else {

        memcpy (&tempList, g_DashStGlobals.Buffer, sizeof (STDB_LIST));
        SEEKTOLISTSEGMENT (songBlock2);
        if (!DashReadFromStDb (STDB_LISTSIG)) {
            XDBGWRN ("Dash Soundtracks", "Unable read list segment.");
            return FALSE;
        }

        plist = (PSTDB_LIST) g_DashStGlobals.Buffer;

        tempId = tempList.SongIds[Index1];
        tempLength = tempList.SongLengths[Index1];
        lstrcpyn (tempName, tempList.SongNames[Index1], MAX_SONG_NAME);

        tempList.SongIds[Index1] = plist->SongIds[Index2];
        lstrcpyn (tempList.SongNames[Index1], plist->SongNames[Index2], MAX_SONG_NAME);
        tempList.SongLengths[Index1] = plist->SongLengths[Index2];

        plist->SongIds[Index2] = tempId;
        plist->SongLengths[Index2] = tempLength;
        lstrcpyn (plist->SongNames[Index2], tempName, MAX_SONG_NAME);

        SEEKBYPAGE(-1);
        b = DashWriteToStDb ();

        if (b) {

            SEEKTOLISTSEGMENT (songBlock1);
            memcpy (g_DashStGlobals.Buffer, &tempList, sizeof (STDB_LIST));
            b = DashWriteToStDb ();
        }
    }

    DashClearStCaches ();

    return b;
}

DashEditSoundtrackName (
    UINT Stid,
    PCWSTR NewName
    )
{
    UINT stBlock;
    PSTDB_STDESC pst;

    if (g_DashStGlobals.DbHandle == INVALID_HANDLE_VALUE) {
        XDBGWRN ("Dash Soundtracks", "Soundtrack DB not open. Use DashBeginUsingSoundtracks ()");
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }


    //
    // Find the appropriate soundtrack.
    //
    stBlock = DashFindStBlock (Stid);
    if (stBlock == MAX_SOUNDTRACKS) {
        SetLastError (ERROR_INVALID_INDEX);
        XDBGWRN ("Dash Soundtracks", "Soundtrack %u not found in database.", Stid);
        return FALSE;
    }

    SEEKTOSOUNDTRACK(stBlock);
    if (!DashReadFromStDb (STDB_STSIG)) {
        XDBGWRN ("Dash Soundtracks", "Unable to read in soundtrack %u to be modified.", Stid);
        return FALSE;
    }

    pst = (PSTDB_STDESC) g_DashStGlobals.Buffer;
    lstrcpyn (pst->Name, NewName, MAX_SOUNDTRACK_NAME);
    SEEKBYPAGE(-1);

    DashClearStCaches ();

    return DashWriteToStDb ();

}

DashEditSongName (
    UINT Stid,
    UINT Index,
    PCWSTR NewName
    )
{
    UINT stBlock;
    PSTDB_STDESC pst;
    UINT songBlock;

    if (g_DashStGlobals.DbHandle == INVALID_HANDLE_VALUE) {
        SetLastError (ERROR_INVALID_HANDLE);
        XDBGWRN ("Dash Soundtracks", "Soundtrack DB not open. Use DashBeginUsingSoundtracks ()");
        return FALSE;
    }


    //
    // Find the appropriate soundtrack.
    //
    stBlock = DashFindStBlock (Stid);
    if (stBlock == MAX_SOUNDTRACKS) {
        SetLastError (ERROR_INVALID_INDEX);
        XDBGWRN ("Dash Soundtracks", "Soundtrack %u not found in database.", Stid);
        return FALSE;
    }

    SEEKTOSOUNDTRACK(stBlock);
    if (!DashReadFromStDb (STDB_STSIG)) {
        XDBGWRN ("Dash Soundtracks", "Unable to read in soundtrack %u to be modified.", Stid);
        return FALSE;
    }

    pst = (PSTDB_STDESC) g_DashStGlobals.Buffer;

    if (Index >= pst->SongCount) {
        SetLastError (ERROR_INVALID_INDEX);
        XDBGWRN ("Dash Soundtracks", "Index out of range for soundtrack %u.", Stid);
        return FALSE;
    }

    SEEKTOLISTSEGMENT (pst->ListBlocks[Index / WMADESC_LIST_SIZE]);
    if (!DashReadFromStDb (STDB_LISTSIG)) {
        XDBGWRN ("Dash Soundtracks", "Unable to read in list segment.");
        return FALSE;
    }

    lstrcpyn (((PSTDB_LIST) g_DashStGlobals.Buffer)->SongNames[Index % WMADESC_LIST_SIZE], NewName, MAX_SONG_NAME);
    SEEKBYPAGE(-1);

    DashClearStCaches ();
    return DashWriteToStDb ();


}

DWORD
DashGetSoundtrackCount (
    VOID
    )
{
    if (g_DashStGlobals.DbHandle == INVALID_HANDLE_VALUE) {
        XDBGWRN ("Dash Soundtracks", "Soundtrack DB not open. Use DashBeginUsingSoundtracks ()");
        SetLastError (ERROR_INVALID_HANDLE);
        return 0;
    }

    return g_DashStGlobals.Header.StCount;
}




DWORD
DashGetNewSongId (
    DWORD Stid
    )
{
    DWORD rid;


    if (g_DashStGlobals.DbHandle == INVALID_HANDLE_VALUE) {
        XDBGWRN ("Dash Soundtracks", "Soundtrack DB not open. Use DashBeginUsingSoundtracks ()");
        SetLastError (ERROR_INVALID_HANDLE);
        return 0xFFFFFFFF;
    }

    //
    // HIWORD(songId) == STID. LOWORD(songId) == songid. Song should be saved using the following template:
    // sprintf (path, "T:\\MUSIC\\%04x\\%08x.WMA", HIWORD(songId), SongId);
    //
    rid = (Stid << 16) | (g_DashStGlobals.Header.NextSongId & 0xFFFF);
    g_DashStGlobals.Header.NextSongId++;

    DashUpdateHeaderInStDb ();

    return rid;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbapp.h ===
//-----------------------------------------------------------------------------
// File: XBApp.h
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBInput.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;




//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
#define XBAPPERR_MEDIANOTFOUND       0x82000003




//-----------------------------------------------------------------------------
// Name: class CXBApplication
// Desc: A base class for creating sample Xbox applications. To create a simple
//       Xbox application, simply derive this class and override the following
//       functions:
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class CXBApplication
{
protected:
    // Main objects used for creating and rendering the 3D scene
    D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer
    LPDIRECT3DSURFACE8    m_pDepthBuffer;      // The depthbuffer

    // Variables for timing
    FLOAT      m_fTime;             // Current absolute time in seconds
    FLOAT      m_fElapsedTime;      // Elapsed absolute time since last frame
    FLOAT      m_fAppTime;          // Current app time in seconds
    FLOAT      m_fElapsedAppTime;   // Elapsed app time since last frame
    BOOL       m_bPaused;           // Whether app time is paused by user
    FLOAT      m_fFPS;              // Instanteous frame rate
    WCHAR      m_strFrameRate[20];  // Frame rate written to a string
    HANDLE     m_hFrameCounter;     // Handle to framerate perf counter

    // Members to init the XINPUT devices.
    XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
    DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;

    // Helper functions
    HRESULT RenderGradientBackground( DWORD dwTopColor, DWORD dwBottomColor );

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize()            { return S_OK; }
    virtual HRESULT FrameMove()             { return S_OK; }
    virtual HRESULT Render()                { return S_OK; }
    virtual HRESULT Cleanup()               { return S_OK; }

public:
    // Functions to create, run, and clean up the application
    HRESULT Create();
    INT     Run();
    VOID    Destroy();

    // Internal constructor
    CXBApplication();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\langcode.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// langcode.h -- maps a two character country code to an English string in accordance with ISO-639

#ifndef __LANGCODE_H__
#define __LANGCODE_H__


struct LANGUAGESTRUCT
{
	WORD    code;
	char*   string;
};

const LANGUAGESTRUCT LanguageStrings[] =
{
	{	0, "Unknown" },
    { (WORD)'a' << 8 | (BYTE)'a', "Afar" },
    { (WORD)'a' << 8 | (BYTE)'b', "Abkhazian" },
    { (WORD)'a' << 8 | (BYTE)'f', "Afrikaans" },
    { (WORD)'a' << 8 | (BYTE)'m', "Amharic" },
    { (WORD)'a' << 8 | (BYTE)'r', "Arabic" },
    { (WORD)'a' << 8 | (BYTE)'s', "Assamese" },
    { (WORD)'a' << 8 | (BYTE)'y', "Aymara" },
    { (WORD)'a' << 8 | (BYTE)'z', "Azerbaijani" },
    { (WORD)'b' << 8 | (BYTE)'a', "Bashkir" },
    { (WORD)'b' << 8 | (BYTE)'e', "Byelorussian" },
    { (WORD)'b' << 8 | (BYTE)'g', "Bulgarian" },
    { (WORD)'b' << 8 | (BYTE)'h', "Bihari" },
    { (WORD)'b' << 8 | (BYTE)'i', "Bislama" },
    { (WORD)'b' << 8 | (BYTE)'n', "Bengali" },
    { (WORD)'b' << 8 | (BYTE)'o', "Tibetan" },
    { (WORD)'b' << 8 | (BYTE)'r', "Breton" },
    { (WORD)'c' << 8 | (BYTE)'a', "Catalan" },
    { (WORD)'c' << 8 | (BYTE)'o', "Corsican" },
    { (WORD)'c' << 8 | (BYTE)'s', "Czech" },
    { (WORD)'c' << 8 | (BYTE)'y', "Welsh" },
    { (WORD)'d' << 8 | (BYTE)'a', "Danish" },
    { (WORD)'d' << 8 | (BYTE)'e', "German" },
    { (WORD)'d' << 8 | (BYTE)'z', "Bhutani" },
    { (WORD)'e' << 8 | (BYTE)'l', "Greek" },
    { (WORD)'e' << 8 | (BYTE)'n', "English"  },
    { (WORD)'e' << 8 | (BYTE)'o', "Esperanto" },
    { (WORD)'e' << 8 | (BYTE)'s', "Spanish" },
    { (WORD)'e' << 8 | (BYTE)'t', "Estonian" },
    { (WORD)'e' << 8 | (BYTE)'u', "Basque" },
    { (WORD)'f' << 8 | (BYTE)'a', "Persian" },
    { (WORD)'f' << 8 | (BYTE)'i', "Finnish" },
    { (WORD)'f' << 8 | (BYTE)'j', "Fiji" },
    { (WORD)'f' << 8 | (BYTE)'o', "Faeroese" },
    { (WORD)'f' << 8 | (BYTE)'r', "French" },
    { (WORD)'f' << 8 | (BYTE)'y', "Frisian" },
    { (WORD)'g' << 8 | (BYTE)'a', "Irish" },
    { (WORD)'g' << 8 | (BYTE)'d', "Gaelic"  },
    { (WORD)'g' << 8 | (BYTE)'l', "Galician" },
    { (WORD)'g' << 8 | (BYTE)'n', "Guarani" },
    { (WORD)'g' << 8 | (BYTE)'u', "Gujarati" },
    { (WORD)'h' << 8 | (BYTE)'a', "Hausa" },
    { (WORD)'h' << 8 | (BYTE)'i', "Hindi" },
    { (WORD)'h' << 8 | (BYTE)'r', "Croatian" },
    { (WORD)'h' << 8 | (BYTE)'u', "Hungarian" },
    { (WORD)'h' << 8 | (BYTE)'y', "Armenian" },
    { (WORD)'i' << 8 | (BYTE)'a', "Interlingua" },
    { (WORD)'i' << 8 | (BYTE)'e', "Interlingue" },
    { (WORD)'i' << 8 | (BYTE)'k', "Inupiak" },
    { (WORD)'i' << 8 | (BYTE)'n', "Indonesian" },
    { (WORD)'i' << 8 | (BYTE)'s', "Icelandic"  },
    { (WORD)'i' << 8 | (BYTE)'t', "Italian" },
    { (WORD)'i' << 8 | (BYTE)'w', "Hebrew" },
    { (WORD)'j' << 8 | (BYTE)'a', "Japanese" },
    { (WORD)'j' << 8 | (BYTE)'i', "Yiddish" },
    { (WORD)'j' << 8 | (BYTE)'w', "Javanese" },
    { (WORD)'k' << 8 | (BYTE)'a', "Georgian" },
    { (WORD)'k' << 8 | (BYTE)'k', "Kazakh" },
    { (WORD)'k' << 8 | (BYTE)'l', "Greenlandic" },
    { (WORD)'k' << 8 | (BYTE)'m', "Cambodian" },
    { (WORD)'k' << 8 | (BYTE)'n', "Kannada" },
    { (WORD)'k' << 8 | (BYTE)'o', "Korean" },
    { (WORD)'k' << 8 | (BYTE)'s', "Kashmiri" },
    { (WORD)'k' << 8 | (BYTE)'u', "Kurdish" },
    { (WORD)'k' << 8 | (BYTE)'y', "Kirghiz" },
    { (WORD)'l' << 8 | (BYTE)'a', "Latin" },
    { (WORD)'l' << 8 | (BYTE)'n', "Lingala" },
    { (WORD)'l' << 8 | (BYTE)'o', "Laothian" },
    { (WORD)'l' << 8 | (BYTE)'t', "Lithuanian" },
    { (WORD)'l' << 8 | (BYTE)'v', "Latvian"  },
    { (WORD)'m' << 8 | (BYTE)'g', "Malagasy" },
    { (WORD)'m' << 8 | (BYTE)'i', "Maori" },
    { (WORD)'m' << 8 | (BYTE)'k', "Macedonian" },
    { (WORD)'m' << 8 | (BYTE)'l', "Malayalam" },
    { (WORD)'m' << 8 | (BYTE)'n', "Mongolian" },
    { (WORD)'m' << 8 | (BYTE)'o', "Moldavian" },
    { (WORD)'m' << 8 | (BYTE)'r', "Marathi" },
    { (WORD)'m' << 8 | (BYTE)'s', "Malay" },
    { (WORD)'m' << 8 | (BYTE)'t', "Maltese" },
    { (WORD)'m' << 8 | (BYTE)'y', "Burmese" },
    { (WORD)'n' << 8 | (BYTE)'a', "Nauru" },
    { (WORD)'n' << 8 | (BYTE)'e', "Nepali" },
    { (WORD)'n' << 8 | (BYTE)'l', "Dutch" },
    { (WORD)'n' << 8 | (BYTE)'o', "Norwegian" },
    { (WORD)'o' << 8 | (BYTE)'c', "Occitan" },
    { (WORD)'o' << 8 | (BYTE)'m', "Oromo"  },
    { (WORD)'o' << 8 | (BYTE)'r', "Oriya" },
    { (WORD)'p' << 8 | (BYTE)'a', "Punjabi" },
    { (WORD)'p' << 8 | (BYTE)'l', "Polish" },
    { (WORD)'p' << 8 | (BYTE)'s', "Pashto" },
    { (WORD)'p' << 8 | (BYTE)'t', "Portuguese" },
    { (WORD)'q' << 8 | (BYTE)'u', "Quechua" },
    { (WORD)'r' << 8 | (BYTE)'m', "Rhaeto-Romance" },
    { (WORD)'r' << 8 | (BYTE)'n', "Kirundi" },
    { (WORD)'r' << 8 | (BYTE)'o', "Romanian" },
    { (WORD)'r' << 8 | (BYTE)'u', "Russian" },
    { (WORD)'r' << 8 | (BYTE)'w', "Kinyarwanda" },
    { (WORD)'s' << 8 | (BYTE)'a', "Sanskrit" },
    { (WORD)'s' << 8 | (BYTE)'d', "Sindhi" },
    { (WORD)'s' << 8 | (BYTE)'g', "Sangro" },
    { (WORD)'s' << 8 | (BYTE)'h', "Serbo-Croatian" },
    { (WORD)'s' << 8 | (BYTE)'i', "Singhalese" },
    { (WORD)'s' << 8 | (BYTE)'k', "Slovak" },
    { (WORD)'s' << 8 | (BYTE)'l', "Slovenian" },
    { (WORD)'s' << 8 | (BYTE)'m', "Samoan" },
    { (WORD)'s' << 8 | (BYTE)'n', "Shona" },
    { (WORD)'s' << 8 | (BYTE)'o', "Somali" },
    { (WORD)'s' << 8 | (BYTE)'q', "Albanian" },
    { (WORD)'s' << 8 | (BYTE)'r', "Serbian" },
    { (WORD)'s' << 8 | (BYTE)'s', "Siswati" },
    { (WORD)'s' << 8 | (BYTE)'t', "Sesotho" },
    { (WORD)'s' << 8 | (BYTE)'u', "Sudanese" },
    { (WORD)'s' << 8 | (BYTE)'v', "Swedish" },
    { (WORD)'s' << 8 | (BYTE)'w', "Swahili" },
    { (WORD)'t' << 8 | (BYTE)'a', "Tamil" },
    { (WORD)'t' << 8 | (BYTE)'e', "Tegulu" },
    { (WORD)'t' << 8 | (BYTE)'g', "Tajik" },
    { (WORD)'t' << 8 | (BYTE)'h', "Thai" },
    { (WORD)'t' << 8 | (BYTE)'i', "Tigrinya" },
    { (WORD)'t' << 8 | (BYTE)'k', "Turkmen" },
    { (WORD)'t' << 8 | (BYTE)'l', "Tagalog" },
    { (WORD)'t' << 8 | (BYTE)'n', "Setswana" },
    { (WORD)'t' << 8 | (BYTE)'o', "Tonga" },
    { (WORD)'t' << 8 | (BYTE)'r', "Turkish" },
    { (WORD)'t' << 8 | (BYTE)'s', "Tsonga" },
    { (WORD)'t' << 8 | (BYTE)'t', "Tatar" },
    { (WORD)'t' << 8 | (BYTE)'w', "Twi" },
    { (WORD)'u' << 8 | (BYTE)'k', "Ukrainian" },
    { (WORD)'u' << 8 | (BYTE)'r', "Urdu" },
    { (WORD)'u' << 8 | (BYTE)'z', "Uzbek" },
    { (WORD)'v' << 8 | (BYTE)'i', "Vietnamese" },
    { (WORD)'v' << 8 | (BYTE)'o', "Volapuk" },
    { (WORD)'w' << 8 | (BYTE)'o', "Wolof" },
    { (WORD)'x' << 8 | (BYTE)'h', "Xhosa" },
    { (WORD)'y' << 8 | (BYTE)'o', "Yoruba" },
    { (WORD)'z' << 8 | (BYTE)'h', "Chinese" },
    { (WORD)'z' << 8 | (BYTE)'u', "Zulu" }
};



void GetLanguageStringFromCode(WORD dwTwoCharCode, char* pLanguage, UINT nMaxChar)
{
	int isize = sizeof( LanguageStrings ) / sizeof( LanguageStrings[0] );

	for( int i=0; i < isize; i++ )
	{
		if( dwTwoCharCode == LanguageStrings[i].code )
			break;
	}

	if( i == isize ) // if we didn't find a match, use lang_neutral
		i = 0;

	strncpy(pLanguage, LanguageStrings[i].string, nMaxChar);
}


#endif // #ifdef __LANGCODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\DVDMediaPlayer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  $Workfile: DVDMediaPlayer.cpp $
//
//  Copyright (c) 1999  Quadrant International, Inc.
//  All Rights Reserved.
//
//////////////////////////////////////////////////////////////////////////////
//
// $Archive: /Tproj/Apps/xbDVD/DVDMediaPlayer.cpp $
// $Author: Mpeteritas $
// $Modtime: 7/26/01 11:28a $
// $Date: 7/26/01 11:35a $
// $Revision: 62 $
//
////////////////////////////////////$NoKeywords: $////////////////////////////

#include "QError.h"
#include "QProperties.h"
#include "DVDMediaPlayer.h"
#include "langcode.h"
#include "xbDVDStrings.h"
#include <stdio.h>

int MessageBox(HWND hwnd, LPCTSTR s, LPCTSTR t, UINT i)
{
	return 0;
}

// module scope function for handling events sent by the DDP layer
void WINAPI DDPCaptureEvent(DWORD dwEvent, VOID* pvBuffer, DWORD dwInfo);

PEVENT_CALLBACK DVDMediaPlayer::m_pEventCallback = NULL;

HWND DVDMediaPlayer::m_eventWindow = NULL;
DVDMediaPlayer* pMediaPlayer = NULL;
char* DVD_PATH = "E";
char* DVD_FULL_PATH = "E";

DVDMediaPlayer::DVDMediaPlayer(HINSTANCE hinst = NULL) :
	m_ddpThePlayer(NULL), // this is a pointer to class CDVDDiskPlayer
	m_bFSInitMode(true), // only true once per instance.
	m_bSubPicOn(false),
	m_bFullScreenMode(false),
	m_iWindowLeft(0),
	m_iWindowTop(0),
	m_iWindowWidth(0),
	m_iWindowHeight(0),
	m_lWindowStyle(0L),
	m_lWindowStyleEx(0L),
	m_wCurrentTitle(0),
	m_wCurrentChapter(0),
	m_lCurrentVolume(50),
	m_iHasSPDIFSupport(0),
	m_bCheckedForPassthrough(false),
	m_dScanSpeed(1.0),       // Speed used during scan (2.0X and greater)
	m_dPlaySpeed(1.0),       // Speed used during playback (Less than 2.0X)
	m_bForwardPlayback(true),// Global so callback function can change its value
	m_lMode(QMODE_STOPPED),
	m_lCurrentDisplayMode(DPM_16BY9),
	m_dwCurrentUOPs(0),
	// Driver variables
	m_hVdrDriver(NULL),
	m_Units(NULL),
	m_hParentWindow(NULL),
	m_bAcceptParentalLevelChange(true),
	m_bChangeRatio(false),
	m_iDisplayMode(DPM_4BY3),
	m_PreferredAudioLanguage(0),
	m_PreferredSubpicLanguage(0)
{
	pMediaPlayer = this;

	m_currentRatio.cx = 4;
	m_currentRatio.cy = 3;

	m_rVideoRect.top = 0;
	m_rVideoRect.bottom = 0;
	m_rVideoRect.left = 0;
	m_rVideoRect.right = 0;

//wmpx	videoWindow = NULL;

	if(hinst)
		m_appInstance = hinst;
	else
		m_appInstance = NULL;
}



void DVDMediaPlayer::Shutdown()
{
	if( m_ddpThePlayer )
	{
		DDP_Stop(m_ddpThePlayer);
		EventHandlerRemove();
		DDP_ClosePlayer( m_ddpThePlayer );
		m_ddpThePlayer = NULL;
	}
	if ( m_Units )
	{
		VDR_CloseUnits( m_Units );
		m_Units = NULL;
	}
	if ( m_hVdrDriver )
	{
		VDR_CloseDriver( m_hVdrDriver );
		m_hVdrDriver = NULL;
	}
}


DVDMediaPlayer::~DVDMediaPlayer()
{


	//shutdown the ddp and vdr layers
	this->Shutdown();

	m_eventWindow = NULL;
}


///////////////////////////////////////////////////////////////////////////////
//  Function: Initialize() -  initializes the decode and navigator engines for
//								playback of media type and creates a window for
//								display of the resulting decoded video.
// Return:    HRESULT  - S_OK or appropriate error code.
///////////////////////////////////////////////////////////////////////////////
//HRESULT DVDMediaPlayer::Initialize(HWND parent, char driveLetter, char* drivePath)
HRESULT DVDMediaPlayer::Initialize(HWND parent, char driveLetter, BYTE region)
{
	// wmp - hard code media string.


	if (IS_ERROR(DDP_Initialize()))
		{
		OutputDebugString("DDP_Initilize failed from DVDMediaPlayer!\n");
		return E_FAIL;
		}

	if (!m_hVdrDriver)
		{
		if (IS_ERROR(VDR_OpenDriver("CINEMAST", 0, m_hVdrDriver)))
			{
			OutputDebugString("Could not open Cinemaster!\n");
			return E_FAIL;
			}
		}

	if(!m_Units)
		{
			if (IS_ERROR(VDR_OpenUnits(m_hVdrDriver, MPEG_DECODER_UNIT | VIDEO_ENCODER_UNIT | PIP_UNIT, m_Units)))
			{
			OutputDebugString("Could not open units\n");
			return E_FAIL;
			}
		}
	//
	// Configure the lowlevel driver for our need
	//

	VDR_ConfigureUnitsTags(m_Units,
									SET_VID_MODE(VMOD_PLAYBACK),
									SET_PIP_VIDEOSTANDARD(VSTD_NTSC),
									SET_PIP_WINDOW(NULL),
									SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
									SET_PIP_ADAPT_CLIENT_SIZE(FALSE),
									SET_VID_VIDEOSTANDARD(VSTD_NTSC),
									TAGDONE);

	if(region != NULL)
	{
		SetSystemRegion(driveLetter, region);
	}

	if (!IS_ERROR(DDP_OpenPlayer(m_Units, driveLetter, m_ddpThePlayer)))
		return S_OK;

	else
	{
		OutputDebugString("Could not open player!\n");
		m_ddpThePlayer = NULL;
		return E_FAIL;
	}
	return S_OK;
}


HRESULT DVDMediaPlayer::CheckDrive(char driveLetter, char __far* id)
{
	return ConvertError(DDP_CheckDrive(driveLetter,id));
}

HRESULT DVDMediaPlayer::CheckDrive(char* drivePath, char __far* id)
{
	return ConvertError(DDP_CheckDriveWithPath(drivePath,id));
}

DVDPlayerMode DVDMediaPlayer::GetPlayerMode(void)
{
	if( !m_ddpThePlayer )
	{
		return DVDPlayerMode();
	}

	return DDP_GetPlayerMode(m_ddpThePlayer);
}

HRESULT DVDMediaPlayer::StartPresentation(void)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	return ConvertError(DDP_StartPresentation(m_ddpThePlayer));
}

DVDDiskType DVDMediaPlayer::GetDiskType(void)
{
	if( !m_ddpThePlayer )
	{
		return DVDDiskType();
	}

	return DDP_GetDiskType(m_ddpThePlayer);
}

HRESULT DVDMediaPlayer::ForwardScan(short speed)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	return ConvertError(DDP_ForwardScan(m_ddpThePlayer,speed));
}

HRESULT DVDMediaPlayer::BackwardScan(short speed)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	return ConvertError(DDP_BackwardScan(m_ddpThePlayer,speed));
}

HRESULT DVDMediaPlayer::Get_VideoSize(WORD& x, WORD& y)
{
	ULONG ulError;
	HRESULT hr;
	unsigned short          iSourceHeight;
	unsigned short          iSourceWidth;


	ulError = VDR_ConfigureUnitsTags(m_Units, GET_MPEG_DISPLAY_HEIGHT(iSourceHeight), TAGDONE);
	hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}

	// Get the actual video width
	ulError = VDR_ConfigureUnitsTags(m_Units, GET_MPEG_DISPLAY_WIDTH(iSourceWidth), TAGDONE);
	hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}

	x = iSourceWidth;
	y = iSourceHeight;

	if (x <= 0 || y <= 0)
		return E_FAIL;

	return hr;
}

ULONG DVDMediaPlayer::GetNumberOfTitles(void)
{
	if( !m_ddpThePlayer )
	{
//		return (ULONG) E_FAIL;
		return (ULONG) 0;
	}

	return DDP_GetNumberOfTitles(m_ddpThePlayer);
}

HRESULT DVDMediaPlayer::GetExtendedPlayerState(ExtendedPlayerState& eps)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	ULONG ulErr;
	HRESULT hr;
	ulErr = DDP_GetExtendedPlayerState(m_ddpThePlayer, eps);
	hr = ConvertError(ulErr);
	return hr;
}

HRESULT DVDMediaPlayer::GetAvailStreams(BYTE& af, ULONG& spf)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	ULONG ulErr;
	HRESULT hr;
	ulErr = DDP_GetAvailStreams(m_ddpThePlayer, af, spf);
	hr = ConvertError(ulErr);
	return hr;
}

HRESULT DVDMediaPlayer::EnableCC(bool enable)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_CC_ENABLE(enable), TAGDONE));
}


HRESULT DVDMediaPlayer::GetAudioDynRngCompMode(AC3DynamicRange& drm)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, GET_MPEG2_AC3_DYNAMIC_RANGE(drm), TAGDONE));
}

HRESULT DVDMediaPlayer::SetAudioDynRngCompMode(const AC3DynamicRange& drm)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_AC3_DYNAMIC_RANGE(drm), TAGDONE));
}

HRESULT DVDMediaPlayer::GetAudioDownmixMode(AC3SpeakerConfig& dmm)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, GET_MPEG2_AC3_SPEAKER_CONFIG(dmm), TAGDONE));
}

HRESULT DVDMediaPlayer::SetAudioDownmixMode(const AC3SpeakerConfig& dmm)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_AC3_SPEAKER_CONFIG(dmm), TAGDONE));
}

HRESULT DVDMediaPlayer::GetAudioDualMode(AC3DualModeConfig& dm)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, GET_MPEG2_AC3_DUAL_MODE_CONFIG(dm), TAGDONE));
}

HRESULT DVDMediaPlayer::SetAudioDualMode(const AC3DualModeConfig& dm)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_AC3_DUAL_MODE_CONFIG(dm), TAGDONE));
}

HRESULT DVDMediaPlayer::GetAudioSpdifOutMode(SPDIFOutputMode& dmm)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, GET_MPEG2_SPDIF_OUTPUT_MODE(dmm), TAGDONE));
}

HRESULT DVDMediaPlayer::SetAudioSpdifOutMode(const SPDIFOutputMode& dmm)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;


	ULONG uops;
	DVD_PLAYBACK_LOCATION2 LastDvdLoc;

	if (S_OK != GetCurrentLocation(&LastDvdLoc))
		{
		ZeroMemory(&LastDvdLoc, sizeof(LastDvdLoc));
		}

	Stop();


	Error err = VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_SPDIF_OUTPUT_MODE(dmm), TAGDONE);

	PlayAtTimeInTitle(LastDvdLoc.TitleNum, &LastDvdLoc.TimeCode);

	return ConvertError(err);

//	return ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_SPDIF_OUTPUT_MODE(dmm), TAGDONE));

}

HRESULT DVDMediaPlayer::GetAudioLFEMode(BOOL& lfe)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, GET_MPEG2_DECODE_LFE(lfe), TAGDONE));
}

HRESULT DVDMediaPlayer::SetAudioLFEMode(const BOOL& lfe)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_DECODE_LFE(lfe), TAGDONE));
}

HRESULT DVDMediaPlayer::GetAudioDialogNormMode(AC3DialogNorm& dn)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, GET_MPEG2_AC3_DIALOG_NORM(dn), TAGDONE));
}

HRESULT DVDMediaPlayer::SetAudioDialogNormMode(const AC3DialogNorm& dn)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_AC3_DIALOG_NORM(dn), TAGDONE));
}

HRESULT DVDMediaPlayer::GetAudioCompMode(AC3OperationalMode& opm)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, GET_MPEG2_AC3_OPERATIONAL_MODE(opm), TAGDONE));
}

HRESULT DVDMediaPlayer::SetAudioCompMode(const AC3OperationalMode& opm)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_AC3_OPERATIONAL_MODE(opm), TAGDONE));
}

HRESULT DVDMediaPlayer::GetAudioCompSFHigh(WORD& sfh)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, GET_MPEG2_AC3_HIGH_DYNAMIC_RANGE(sfh), TAGDONE));
}

HRESULT DVDMediaPlayer::SetAudioCompSFHigh(const WORD& sfh)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_AC3_HIGH_DYNAMIC_RANGE(sfh), TAGDONE));
}

HRESULT DVDMediaPlayer::GetAudioCompSFLow(WORD& sfl)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, GET_MPEG2_AC3_LOW_DYNAMIC_RANGE(sfl), TAGDONE));
}

HRESULT DVDMediaPlayer::SetAudioCompSFLow(const WORD& sfl)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_AC3_LOW_DYNAMIC_RANGE(sfl), TAGDONE));
}


// 0x0000 == stereo, 0x0001 == mono, 0x0002 == surround.
HRESULT DVDMediaPlayer::GetSpeakerOutputMode(WORD& config)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	AC3SpeakerConfig speakerConfig;
	HRESULT hr = S_OK;

	hr = ConvertError(VDR_ConfigureUnitsTags(m_Units, GET_MPEG2_AC3_SPEAKER_CONFIG(speakerConfig), TAGDONE));

	if(hr != S_OK)
	{
		return hr;
	}

	switch(speakerConfig)
	{
		case AC3SC_20_NORMAL: // stereo
		{
			config = XC_AUDIO_FLAGS_STEREO;
			break;
		}
		case AC3SC_10: // mono
		{
			config = XC_AUDIO_FLAGS_MONO;
			break;
		}
		default:
		case AC3SC_20_SURROUND_COMPATIBLE: // surround
		{
			config = XC_AUDIO_FLAGS_SURROUND;
			break;
		}
	}
	return hr;
}

// 0x0000 == surround, 0x0001 == stereo, 0x0002 == mono.
HRESULT DVDMediaPlayer::SetSpeakerOutputMode(const WORD& config)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	HRESULT hr = S_OK;

	switch(config)
	{
		case XC_AUDIO_FLAGS_STEREO: // stereo
		{
			hr = ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_AC3_SPEAKER_CONFIG(AC3SC_20_NORMAL), TAGDONE));
			break;
		}
		case XC_AUDIO_FLAGS_MONO: // mono
		{
			hr = ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_AC3_SPEAKER_CONFIG(AC3SC_10), TAGDONE));
			break;
		}
		case XC_AUDIO_FLAGS_SURROUND: // surround
		{
			hr = ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_AC3_SPEAKER_CONFIG(AC3SC_20_SURROUND_COMPATIBLE), TAGDONE));
			break;
		}
	}
	return hr;
}

// 0x0000 == PCM, 0x0001 == AC3, 0x0002 == DTS
HRESULT DVDMediaPlayer::GetDigitalOutputMode(WORD& config)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	AudioTypeConfig digitalConfig;
	HRESULT hr;

	config = 0x0000; // clear current settings

	hr = ConvertError(VDR_ConfigureUnitsTags(m_Units, GET_MPEG2_DTS_AUDIO_TYPE_CONFIG(digitalConfig), TAGDONE));

	if(hr != S_OK)
	{
		return hr;
	}

	if(digitalConfig.config.spdifOutMode == SPDIFOM_DEFAULT )
	{
		config |= (XC_AUDIO_FLAGS_ENABLE_DTS >> 16);
	}

	hr = ConvertError(VDR_ConfigureUnitsTags(m_Units, GET_MPEG2_AC3_AUDIO_TYPE_CONFIG(digitalConfig), TAGDONE));

	if(hr != S_OK)
	{
		return hr;
	}

	if(digitalConfig.config.spdifOutMode == SPDIFOM_DEFAULT )
	{
		config |= (XC_AUDIO_FLAGS_ENABLE_AC3 >> 16);
	}

	return S_OK;
}

// 0x0000 == PCM, 0x0001 == AC3, 0x0002 == DTS
HRESULT DVDMediaPlayer::SetDigitalOutputMode(const WORD& config)
{
	if(!m_hVdrDriver || !m_Units)
		return E_FAIL;

	AudioTypeConfig digitalConfig;
	HRESULT hr;

	if(config & (XC_AUDIO_FLAGS_ENABLE_DTS >> 16))
	{
		digitalConfig.config.spdifOutMode = SPDIFOM_DEFAULT;
	}
	else
	{
		digitalConfig.config.spdifOutMode = SPDIFOM_MUTE_NULL;
	}

	hr = ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_DTS_AUDIO_TYPE_CONFIG(digitalConfig), TAGDONE));

	if(hr != S_OK)
	{
		return hr;
	}

	if(config & (XC_AUDIO_FLAGS_ENABLE_AC3 >> 16))
	{
		digitalConfig.config.spdifOutMode = SPDIFOM_DEFAULT;
	}
	else
	{
		digitalConfig.config.spdifOutMode = SPDIFOM_MUTE_NULL;
	}

	return ConvertError(VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_AC3_AUDIO_TYPE_CONFIG(digitalConfig), TAGDONE));

//	return E_NOTIMPL;
}


void DVDMediaPlayer::UpdateDisplay(bool forceUpdate)
{
//	CSize newRatio;
//	if(m_bChangeRatio)
//	{
//		newRatio = this->m_newRatio;
//		m_bChangeRatio = false;
//	}
//	else
//		this->Get_AspectRatios(newRatio.cx, newRatio.cy);
//
//	if(forceUpdate || newRatio.cx != m_currentRatio.cx || newRatio.cy != m_currentRatio.cy)
//	{
//		m_currentRatio = newRatio;
////		DVD_DOMAIN dom;
////		HRESULT hr;
////		ULONG ulerr;
//
//
//		if(!m_Units)
//		{
//			OutputDebugString("DVDMediaPlayer::UpdateDisplay - Units not initialized!");
//			return;
//		}
//
////		else if(this->GetCurrentDomain(&dom) != S_OK)
////		{
////			OutputDebugString("DVDMediaPlayer::UpdateDisplay - No ddp layer!");
////			return;
////		}
////
////		if(dom == DVD_DOMAIN_FirstPlay)
////		{
////			OutputDebugString("DVDMediaPlayer::UpdateDisplay - In warning screens, so don't resize!");
////			return;
////		}
//
//		if(m_iDisplayMode == DPM_16BY9)
//		{
//			ULONG uops;
//			this->GetCurrentUOPS(&uops);
//			if(!(uops & UOP_BUTTON)) // we are in a menu, so pan and scan.
//			{
//				// wmp - TBD - fix - should be MPM_PANSCAN, but highlights are not scaled properly.
//				VDR_ConfigureUnitsTags(m_Units,
//									SET_MPEG2_PRESENTATION_MODE(MPM_FULLSIZE),
//									TAGDONE);
//			}
//			else
//			{
//				VDR_ConfigureUnitsTags(m_Units,
//									SET_MPEG2_PRESENTATION_MODE(MPM_LETTERBOXED),
//									TAGDONE);
//			}
//		}
//		else if(m_iDisplayMode == DPM_PANSCAN)
//		{
//			VDR_ConfigureUnitsTags(m_Units,
//								SET_MPEG2_PRESENTATION_MODE(MPM_PANSCAN),
//								TAGDONE);
//		}
//		else
//		{
//			VDR_ConfigureUnitsTags(m_Units,
//								SET_MPEG2_PRESENTATION_MODE(MPM_FULLSIZE),
//								TAGDONE);
//		}
//
//	}
//	else
//	{
//	}
//
//
}



BOOL DVDMediaPlayer::CalcVideoPos(CSize sizeMonitor, CSize sizeVideo, CPoint& pntVideo)
{
	pntVideo.x = (sizeMonitor.cx - sizeVideo.cx) / 2;
	pntVideo.y = (sizeMonitor.cy - sizeVideo.cy) / 2;
    return TRUE;
}

BOOL DVDMediaPlayer::CalcVideoSize(CSize sizeMonitor, CSize& sizeVideo)
{
    CSize   sizeClient;
	CSize   sizeActualVideo;

    sizeClient.cx = sizeMonitor.cx;// - nHorzBorders;
    sizeClient.cy = sizeMonitor.cy;// - nVertBorders;

	sizeActualVideo = sizeClient;

    double  dblVidLockAspect = 0;
	CSize	sizeTestActual;
	CSize   sizeTestCropped;

	// Get Locked Video aspect ratio
    dblVidLockAspect = (((double)this->m_currentRatio.cx) / ((double)this->m_currentRatio.cy));

    // Video Aspect ratio is locked, so adjust video size according to
    // the current locked aspect ratio so that video completely (less cropping)
    // fits in the monitors client area

	// First try adjusting the actual video width to match the vid lock aspect
	sizeTestActual = sizeActualVideo;
	sizeTestActual.cx = (long)(dblVidLockAspect * ((double)sizeTestActual.cy));
	sizeTestCropped = sizeTestActual;

	if (sizeTestCropped.cx <= sizeClient.cx)
	{
		// Good! The new cropped width fits in client....
		// So set this to the new size
		sizeVideo = sizeTestActual;
	}
	else
	{
		// No Good! We must adjust the height instead
		sizeTestActual = sizeActualVideo;
		sizeTestActual.cy = (long)(((double)sizeTestActual.cx) / dblVidLockAspect);
		sizeTestCropped = sizeTestActual;

		sizeVideo = sizeTestActual;
	}

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: Play() - Starts or restarts playback of the DVD video.  If video
//                     successfully plays, the video will play in the forward
//                     direction at 1X speed.
//                     The actions of the function are determined by the current
//                     mode.  Based on the current mode, the function will have
//                     to perform different tasks to ensure video plays in the
//                     forward direction at 1X speed. Below is a description of
//                     the procedure for the various modes:
//	                   DPM_STOPPED, PDM_STILL: Presentation is started.
//                     DPM_PLAYING: Video is playing forward, but it may not be
//                                  playing at the correct 1X speed. Video is
//                                  set to 1X speed if playing at another speed. Video
//                                  could be playing at the wrong rate if DDP_SetPlaybackSpeed()
//                                  had been used before this call to set slow motion.
//                     DPM_PAUSED: Pause state is ended by performing a call to Resume().
//                                 If pause did not resume the mode into playback mode,
//                                 the new mode is ended with a call to DDP_StopScan().
//                                 Once mode is known to be playing, playback speed is
//                                 found.  If speed isn't 1X, speed will be changed to
//                                 1X.
//                     DPM_SCANNING: A mode of scanning first requires a call to
//                                   DDP_StopScan() to end the current scan. Then, since
//                                   playback speed could resume at the wrong speed,
//                                   proper 1X speed is set.
//	                   DPM_REVERSEPLAY: First, reverse play is stopped with a call to
//                                      DDP_StopScan(). Then, proper 1X playback speed
//                                      is set.
//	                   DPM_TRICKPLAY: First, trick play mode is ended with a call to
//                                    DDP_StopScan(). Then proper 1X playback speed
//                                    is ensured with call to EnsureNormalPlaybackSpeed()
//                     All other modes cause function to return failure.
//                     Once playback has been set, function will check the final command
//                     for an error, and if everything was completed successfully,
//                     m_bForwardPlayback is set to TRUE.
// Arguments: None
//    Return: HRESULT  - S_OK or appropriate error code
///////////////////////////////////////////////////////////////////////////////
HRESULT DVDMediaPlayer::Play()
{
	ULONG          ulError = 0;
	DVDPlayerMode  lMode;
	HRESULT        hr;

	if (!m_ddpThePlayer)
	{
		return QI_E_NOTINITIALIZED;
	}

	// Get the current mode state
	lMode = DDP_GetPlayerMode(m_ddpThePlayer);

	// Based on the current mode, determine which function to call
	// to re/start playback.
	//
	switch (lMode)
	{
		case DPM_STOPPED:
		case DPM_STILL:
			// Video stopped. Starting video from the beginning.
//			QI_OUTPUT_DEBUG(5, "Video stopped. Starting video from the beginning.");
			ulError = (ULONG)DDP_StartPresentation(m_ddpThePlayer);
			// This "if" statement forwards a message to the application saying that
			// playback failed because parental levels were too low
/*			if (ulError == GNR_INVALID_NAV_INFO  &&  ::IsWindow(g_hEventWnd))
			{
				::PostMessage(	g_hEventWnd,
								WM_QI_EVENT,
								EC_DVD_ERROR,
								DVD_ERROR_LowParentalLevel);
			}
*/
			break;

		case DPM_PAUSED:
			{
				ExtendedPlayerState oPlayer;
				// Current mode is paused.  Unpause (i.e. Resume) from this point.
				hr = Resume();
				if (FAILED(hr))
				{
//					return hr;
				}
				// Get the current mode
				lMode = DDP_GetPlayerMode(m_ddpThePlayer);

				// Since you want the video to play forward at normal speed, it is necessary
				// to find out if resume brought you back into play mode or another mode like
				// reverse playback.
				if (lMode != DPM_PLAYING)
				{
					ulError = (ULONG)DDP_StopScan(m_ddpThePlayer);
					hr = ConvertError(ulError);
					if (FAILED(hr))
					{
//						return hr;
					}
				}

				if (lMode != DPM_PLAYING)
				{
					ulError = (ULONG)DDP_PauseOff(m_ddpThePlayer);
					hr = ConvertError(ulError);
					if (FAILED(hr))
					{
						return hr;
					}
				}
				// There is no guarantee that you are running at a speed of 1X.
				// The following code will make sure that you are.
				if (m_dPlaySpeed != 1.0)
				{
					// Change playback speed to 1X
					ulError = DDP_SetPlaybackSpeed(m_ddpThePlayer, C_NORMAL_PLAYBACK_SPEED);
				}
			}
			break;

		case DPM_SCANNING:

			// If you were playing backwards before beginning the seek or are
			// currently seeking faster than 1.0 rate, stop the current scan.
			ulError = (ULONG)DDP_StopScan(m_ddpThePlayer);
			hr = ConvertError(ulError);
			if (FAILED(hr))
			{
				return hr;
			}

			// The video is now seeking in a forward direction.  Set playback speed
			// to normal 1x
			ulError = (ULONG)DDP_SetPlaybackSpeed(m_ddpThePlayer, C_NORMAL_PLAYBACK_SPEED);
			break;

		case DPM_REVERSEPLAY:
			// Ending current mode and resuming playback from this point

			ulError = (ULONG)DDP_StopScan(m_ddpThePlayer);
			hr = ConvertError(ulError);
			if (FAILED(hr))
			{
				return hr;
			}

			// Ensure normal playback speed
			ulError = (ULONG)DDP_SetPlaybackSpeed(m_ddpThePlayer, C_NORMAL_PLAYBACK_SPEED);
			break;

		case DPM_PLAYING:
			// Since mode is already playing, we only want to ensure that playback is at
			// the proper speed
			if (m_dPlaySpeed != 1.0)
			{
				// Change playback speed to 1X
				ulError = DDP_SetPlaybackSpeed(m_ddpThePlayer, C_NORMAL_PLAYBACK_SPEED);
			}
			break;

		case DPM_TRICKPLAY:
			// In trick play mode.  This mode must end and standard playback must begin
			ulError = (ULONG)DDP_StopScan(m_ddpThePlayer);
			hr = ConvertError(ulError);
			if (FAILED(hr))
			{
				return hr;
			}

			// We need to ensure proper playback speed
			if (m_dPlaySpeed != 1.0)
			{
				// Change playback speed to 1X
				ulError = DDP_SetPlaybackSpeed(m_ddpThePlayer, C_NORMAL_PLAYBACK_SPEED);
			}
			break;

		default:
			// Unknown mode encountered
			return E_FAIL;
	}

	// Check for an error
	hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}

	// Set the member variables which store that current status is
	// forward playback at normal speed.
	m_bForwardPlayback = TRUE;
	m_lMode = QMODE_PLAYING;
	return hr;

}

///////////////////////////////////////////////////////////////////////////////
//  Function: TimeSearch() - Jumps to the specified location in the video disc.
//                           Video will resume playback from the new point at
//                           1X speed.  If currently scanning or playing in reverse,
//                           the scan is stopped.  If paused, video playback is resumed.
//                           After jumping to the new location, if the playback
//                           speed is not 1X, the speed will be changed to 1X.
// Arguments: INT iHours - hour to jump to. Playback continues from this new location.
//            INT iMinutes - fractional hour in minute format to jump to
//            INT iSeconds - fractionl minute in second format to jump to
//    Return: HRESULT  - S_OK or appropriate error code
///////////////////////////////////////////////////////////////////////////////
HRESULT  DVDMediaPlayer::TimeSearch(INT iHours, INT iMinutes, INT iSeconds)
{
	ExtendedPlayerState oPlayer;
	DVDPlayerMode       ddp;
	ULONG               ulError;
	HRESULT             hr;

	if (!m_ddpThePlayer)
	{
		return E_FAIL;
	}

	// Make sure we are not seeking or paused
	ddp = DDP_GetPlayerMode(m_ddpThePlayer);
	switch (ddp)
	{
		case DPM_PAUSED:
			Resume();
			break;

		case DPM_SCANNING:
		case DPM_REVERSEPLAY:
			ulError = DDP_StopScan(m_ddpThePlayer);
			hr = ConvertError(ulError);
			if (FAILED(hr))
			{
				return hr;
			}
			break;
	}

	// Go to the new location
	DVDTime dvdTime = DVDTime( (int)iHours, (int)iMinutes, (int)iSeconds, 0, 1 );
	ulError = (ULONG)DDP_TimeSearch( m_ddpThePlayer, dvdTime );
	hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}

	// The jump we just performed will shut off scanning but it will not notify the
	// callback function of this change.  This statement does the same job.
	m_dScanSpeed = 1.0;

	// That jump would have ended forward/backward scan playback if it was occuring, but
	// the jump would not affect any playback changes made with DDP_SetPlaybackSpeed. The
	// following code will fix that.
	if (m_dPlaySpeed != 1.0)
	{
		// Change playback speed to 1X
		ulError = DDP_SetPlaybackSpeed(m_ddpThePlayer, C_NORMAL_PLAYBACK_SPEED);
		hr = ConvertError(ulError);
	}
	m_bForwardPlayback = TRUE;
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Function: NextChapter() - advances to the next chapter on the disc.
// Arguments: None
//    Return: HRESULT  - S_OK or appropriate error code
///////////////////////////////////////////////////////////////////////////////
HRESULT  DVDMediaPlayer::NextChapter()
{

	ULONG               ulError;
	ExtendedPlayerState oPlayer;
	HRESULT             hr;

	if (!m_ddpThePlayer)
	{
		return QI_E_NOTINITIALIZED;
	}

	// Jump to the next chapter
	ulError = DDP_NextPGSearch(m_ddpThePlayer);
	hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}

	// The jump we just performed will shut off scanning but it will not notify the
	// callback function of this change.  This statement does the same job.
	m_dScanSpeed = 1.0;

	// Video should now be playing, so ensure proper playback speed
	// Since mode is already playing, we only want to ensure that playback is at
	// the proper speed
	if (m_dPlaySpeed != 1.0)
	{
		// Change playback speed to 1X
		ulError = DDP_SetPlaybackSpeed(m_ddpThePlayer, C_NORMAL_PLAYBACK_SPEED);
		hr = ConvertError(ulError);
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: PreviousChapter() - seeks back to the previous chapter on the disc
// Arguments: None
//    Return: HRESULT  - S_OK or appropriate error code
///////////////////////////////////////////////////////////////////////////////
HRESULT  DVDMediaPlayer::PreviousChapter()
{
	ULONG               ulError;
	HRESULT             hr;

	if (!m_ddpThePlayer)
	{
		return QI_E_NOTINITIALIZED;
	}

	// Go to the previous chapter
	ulError = DDP_PrevPGSearch(m_ddpThePlayer);
	hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}

	// The jump we just performed will shut off scanning but it will not notify the
	// callback function of this change.  This statement does the same job.
	m_dScanSpeed = 1.0;

	// Video should now be playing, so ensure proper playback speed
	// Since mode is already playing, we only want to ensure that playback is at
	// the proper speed
	if (m_dPlaySpeed != 1.0)
	{
		// Change playback speed to 1X
		ulError = DDP_SetPlaybackSpeed(m_ddpThePlayer, C_NORMAL_PLAYBACK_SPEED);
		hr = ConvertError(ulError);
	}
	m_bForwardPlayback = TRUE;
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: NextTitle() - advances forward to the next DVD-Video title.
// Arguments: None
//    Return: HRESULT  - S_OK or appropriate error code
///////////////////////////////////////////////////////////////////////////////
HRESULT  DVDMediaPlayer::NextTitle()
{
	if(!m_ddpThePlayer)
	{
		return E_FAIL;
	}

	ULONG ulerr;
	HRESULT hr;
	DVDLocation loc;

	short stitleCount = DDP_GetNumberOfTitles( m_ddpThePlayer );
	ulerr = DDP_GetCurrentLocation( m_ddpThePlayer, loc );
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return hr;

	if(loc.title < stitleCount)
	{
		m_wCurrentTitle++;
		ulerr = DDP_TitlePlay( m_ddpThePlayer, loc.title + 1 );
		hr = ConvertError( ulerr );
		if( FAILED(hr) )
			return hr;
		m_bForwardPlayback = TRUE;
		return S_OK;
	}
	return E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: PreviousTitle() - seeks back to the previous DVD-Video title
// Arguments: None
//    Return: HRESULT  - S_OK or appropriate error code
///////////////////////////////////////////////////////////////////////////////
HRESULT  DVDMediaPlayer::PreviousTitle()
{
	if(!m_ddpThePlayer)
	{
		return E_FAIL;
	}

	ULONG ulerr;
	HRESULT hr;
	DVDLocation loc;

	ulerr = DDP_GetCurrentLocation( m_ddpThePlayer, loc );
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return hr;

	if(loc.title > 0)
	{
		m_wCurrentTitle--;
		ulerr = DDP_TitlePlay( m_ddpThePlayer, loc.title - 1 );
		hr = ConvertError( ulerr );
		if( FAILED(hr) )
			return hr;
		m_bForwardPlayback = TRUE;
		return S_OK;
	}
	return E_FAIL;

}


HRESULT DVDMediaPlayer::ShowMenu (LONG lMenu)
{

	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	HRESULT hr;
	ULONG ulerr;
	DVDLocation loc;

	// Make sure we are not scanning, not playing reverse and not playing in slow-motion

	ulerr = DDP_GetCurrentLocation( m_ddpThePlayer, loc );
	hr = ConvertError( ulerr );
	if(FAILED(hr))
	{
		return E_FAIL;
	}

	// Get the current mode state
	DVDPlayerMode  lMode = DDP_GetPlayerMode(m_ddpThePlayer);
	if (lMode == DPM_SCANNING)
	{
		// If you were playing backwards before beginning the seek or are
		// currently seeking faster than 1.0 rate, stop the current scan.
		ulerr = (ULONG)DDP_StopScan(m_ddpThePlayer);
		hr = ConvertError(ulerr);
		if (FAILED(hr))
		{
			return hr;
		}
	}

	// The video is now seeking in a forward direction.  Set playback speed
	// to normal 1x
	ulerr = (ULONG)DDP_SetPlaybackSpeed(m_ddpThePlayer, C_NORMAL_PLAYBACK_SPEED);

	switch( loc.domain )
	{
		case FP_DOM:
			return E_FAIL;

		case TT_DOM:
		case VTSM_DOM:
		case VMGM_DOM:
		case STOP_DOM:
			{
				VTSMenuType vtsmenu;
				switch( lMenu )
				{
					case QMENU_TITLE:
						vtsmenu = VMT_TITLE_MENU;
						break;
					case QMENU_ROOT:
						vtsmenu = VMT_ROOT_MENU;
						break;
					case QMENU_SUBPIC:
						vtsmenu = VMT_SUBPICTURE_MENU;
						break;
					case QMENU_AUDIO:
						vtsmenu = VMT_AUDIO_MENU;
						break;
					case QMENU_ANGLE:
						vtsmenu = VMT_ANGLE_MENU;
						break;
					case QMENU_CHAPTER:
						vtsmenu = VMT_PTT_MENU;
						break;
					default:
						return E_FAIL;
				}

				ulerr = (ULONG)DDP_MenuCall( m_ddpThePlayer, vtsmenu );
				hr = ConvertError( ulerr );
				return hr;
			}
	} // end switch domain
	return hr;
}


bool DVDMediaPlayer::IsPlaying(void)
{
	if(!m_ddpThePlayer)
		return FALSE;

	DVDPlayerMode	lDdpMode = DDP_GetPlayerMode(m_ddpThePlayer);

    if ((lDdpMode != DPM_STOPPED) && (lDdpMode != DPM_NONE))
    {
        return TRUE;
    }

    return FALSE;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::PlayTitle(
    /* [in] */ ULONG ulTitle)
{
	if (ulTitle == 0)
	{
		return E_INVALIDARG;
	}

	if ( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	if (ulTitle >= 1 && ulTitle <= DDP_GetNumberOfTitles(m_ddpThePlayer))
	{
		ULONG ulerr = DDP_TitlePlay( m_ddpThePlayer, (SHORT)ulTitle );
		HRESULT hr = ConvertError( ulerr );
		if( FAILED(hr) )
			return hr;
		m_wCurrentTitle = (SHORT)ulTitle;
		return hr;
	}
	return E_FAIL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::PlayChapterInTitle(
    /* [in] */ ULONG ulTitle,
    /* [in] */ ULONG ulChapter)
{
	HRESULT ret = this->PlayTitle(ulTitle);
	ret |= this->PlayChapter(ulChapter);
	return ret;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::PlayAtTimeInTitle(
    /* [in] */ ULONG ulTitle,
    /* [in] */ DVD_HMSF_TIMECODE *pStartTime)
{
	HRESULT ret = this->PlayTitle(ulTitle);
	ret |= this->TimeSearch(pStartTime->bHours, pStartTime->bMinutes, pStartTime->bSeconds);
	return ret;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::PlayAtTimeInTitleForced(
    /* [in] */ ULONG ulTitle,
    /* [in] */ DVD_HMSF_TIMECODE *pStartTime)
{
	HRESULT hr;
	ULONG ulerr;
	DVDLocation loc;

	ulerr = DDP_GetCurrentLocation( m_ddpThePlayer, loc );
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return hr;
	if(loc.title != ulTitle)
	{
		ulerr = DDP_TimePlayForced( m_ddpThePlayer, (WORD) ulTitle, DVDTime() );
		hr = ConvertError( ulerr );
		if( FAILED(hr) )
			return hr;
	}

	ulerr = DDP_TimeSearchForced( m_ddpThePlayer, DVDTime(pStartTime->bHours, pStartTime->bMinutes, pStartTime->bSeconds, pStartTime->bFrames, 25 ));
	hr = ConvertError( ulerr );
	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::Stop( void)
{

	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}
	ULONG ulerr;
	HRESULT hr;
	DVDLocation loc;
	ExtendedPlayerState oPlayer;

	ulerr = (ULONG)DDP_GetCurrentLocation( m_ddpThePlayer, loc );
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
	{
		return hr;
	}

	switch( loc.domain )
	{
		case STOP_DOM:
		case FP_DOM:
			return S_OK; // no need to stop

		case VMGM_DOM:
		case VTSM_DOM:
			ulerr = (ULONG)DDP_Stop( m_ddpThePlayer );
			hr = ConvertError( ulerr );
			if( FAILED(hr) )
				return E_FAIL;
			m_bForwardPlayback = TRUE;
			return hr; // stop altogether

		case TT_DOM:
			// If this is not here, restarting presentation
			// could cause the video to play back at the wrong speed.
			// Get information about the playback speed
			if (m_dPlaySpeed != 1.0)
			{
				// Change playback speed to 1X
				ulerr = DDP_SetPlaybackSpeed(m_ddpThePlayer, C_NORMAL_PLAYBACK_SPEED);
				hr = ConvertError(ulerr);
				if (FAILED(hr))
				{
					return hr;
				}
			}

			// Stop the presentation
			if( RAV_STOP_TO_MENU )
			{
				ulerr = DDP_MenuCall( m_ddpThePlayer, VMT_ROOT_MENU );
			}
			else
			{
				ulerr = DDP_Stop( m_ddpThePlayer );
			}
			m_bForwardPlayback = TRUE;
			hr = ConvertError( ulerr );
			return hr; // stop altogether

		default:
			return S_OK;
	} // end switch loc.domain
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::ReturnFromSubmenu(void)
{
	if(!m_ddpThePlayer)
		return E_FAIL;

	return ConvertError(DDP_GoUp(m_ddpThePlayer));
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::PlayAtTime(
    /* [in] */ DVD_HMSF_TIMECODE *pTime)
{
	return this->TimeSearch(pTime->bHours, pTime->bMinutes, pTime->bSeconds);
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::PlayChapter(
    /* [in] */ ULONG ulChapter)
{
	if ( !m_ddpThePlayer )
	{
		return E_FAIL;
	}
	DVDLocation dvdl_loc;

	ULONG ulerr = DDP_GetCurrentLocation( m_ddpThePlayer, dvdl_loc );
	HRESULT hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return hr;
	m_wCurrentTitle  = (short)dvdl_loc.title;

	unsigned short numChapters = 0;
	numChapters = (SHORT)DDP_GetNumberOfPartOfTitle( m_ddpThePlayer, m_wCurrentTitle );

	if(ulChapter > numChapters)
		return E_FAIL;

	ulerr = DDP_PTTPlay( m_ddpThePlayer, m_wCurrentTitle, (SHORT)ulChapter );
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	m_wCurrentChapter = (SHORT)ulChapter;

	return hr;
}

HRESULT DVDMediaPlayer::PlayPrevChapter(void)
{
	return this->PreviousChapter();
}

HRESULT DVDMediaPlayer::ReplayChapter(void)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	ULONG ulerr = DDP_TopPGSearch( m_ddpThePlayer);
	HRESULT hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	return hr;
}

HRESULT DVDMediaPlayer::PlayNextChapter(void)
{
	return this->NextChapter();
}

HRESULT DVDMediaPlayer::PlayForwards(
    /* [in] */ double dSpeed)
{
#ifdef _DEBUG
	char buf[100];

	wsprintf(buf, "PlayForwards(%f)", dSpeed);
	OutputDebugString(buf);
#endif _DEBUG

	if(!m_ddpThePlayer)
	{
		return E_FAIL;
	}

	DVDPlayerMode lDdpMode;
	ULONG         ulError;
	WORD		  wSpeed;
	HRESULT       hr;

	lDdpMode = DDP_GetPlayerMode(m_ddpThePlayer);

	// If you want to increase the speed a lot, use DDP_ForwardScan.  For speeds
	// slower than 2X, use SetPlaybackSpeed
	//
	if (dSpeed > 2.0)
	{
		// FAST SCAN //
		wSpeed = (WORD)dSpeed; // could lose some resolution, ie, if 2.5, will most likely be 2...
#ifdef _DEBUG
		wsprintf(buf, "DDP_ForwardScan(%x)", wSpeed);
		OutputDebugString(buf);
#endif _DEBUG
		ulError = (ULONG)DDP_ForwardScan(m_ddpThePlayer, wSpeed);
		m_dScanSpeed = (double)wSpeed;
	}
	else
	{
		// SLOW SEEK //
		m_dPlaySpeed = dSpeed; // event handler needs to know the speed we're going to

		// Must turn off scan if it is on.  Scan is only on when the mode is either
		// QMODE_SEEKING or QMODE_TRICKREVERSE.
//		if (lDdpMode != DPM_PLAYING)
		if (lDdpMode == DPM_SCANNING
			|| lDdpMode == DPM_TRICKPLAY
			|| lDdpMode == DPM_REVERSEPLAY)
		{
#ifdef _DEBUG
			wsprintf(buf, "DDP_StopScan()");
			OutputDebugString(buf);
#endif _DEBUG
			ulError = (ULONG)DDP_StopScan(m_ddpThePlayer);
			hr = ConvertError(ulError);
			if( FAILED(hr) )
			{
				m_dPlaySpeed = 1.0;
				return hr;
			}
		}
		// Now that scan is off, adjust the playback speed to the desired rate.
		wSpeed = (WORD)(dSpeed * C_NORMAL_PLAYBACK_SPEED);
#ifdef _DEBUG
		wsprintf(buf, "DDP_SetPlaybackSpeed(%d)", wSpeed);
		OutputDebugString(buf);
#endif _DEBUG
		ulError = (ULONG)DDP_SetPlaybackSpeed(m_ddpThePlayer, wSpeed);
	}

	// Check for an error
	hr = ConvertError(ulError);
	if( FAILED(hr) )
	{
		return hr;
	}

	// If paused, turn pause off
	if (lDdpMode == DPM_PAUSED)
	{
		// Ending current mode and resuming playback from this point
#ifdef _DEBUG
		wsprintf(buf, "DDP_PauseOff");
		OutputDebugString(buf);
#endif _DEBUG
		ulError = (ULONG)DDP_PauseOff(m_ddpThePlayer);
		hr = ConvertError(ulError);
		if (FAILED(hr))
		{
			return hr;
		}

	}

	// Playback speed was changed successfully
	m_bForwardPlayback = TRUE;
	return hr;
}

HRESULT DVDMediaPlayer::PlayBackwards(
    /* [in] */ double dSpeed)
{
#ifdef _DEBUG
	char buf[100];
#endif _DEBUG

	WORD          wSpeed;
	DVDPlayerMode lMode;
	ULONG         ulError;
	HRESULT       hr;

	// Ensure proper initialization
	if (!m_ddpThePlayer)
	{
		return QI_E_NOTINITIALIZED;
	}

	// Get the current mode
//	lMode = DDP_GetPlayerMode(m_ddpThePlayer);
//
//	// If the video is paused, unpause it
//	if (lMode == DPM_PAUSED)
//	{
//		ulError = (ULONG)DDP_PauseOff( m_ddpThePlayer );
//		hr = ConvertError(ulError);
////		hr = Resume();
//		if (FAILED(hr))
//		{
//			return hr;
//		}
//	}

	// If you want to increase the RATE a lot, use DDP_BackwardScan.  For speeds
	// slower than standard 1X, use SetPlaybackSpeed
	//
	if( dSpeed > 2.0 )
	{
		// FAST SEEK //

		wSpeed = (WORD)dSpeed; // could lose some resolution, ie, if 2.5, will most likely be 2...
#ifdef _DEBUG
		wsprintf(buf, "DDP_BackwardScan(%x)", wSpeed);
		OutputDebugString(buf);
#endif _DEBUG
		ulError = DDP_BackwardScan( m_ddpThePlayer, wSpeed );
		m_dScanSpeed = (double)wSpeed;
	}
	else
	{
		// SLOW SEEK //


		// Create the new speed in thousands, i.e. 2x speed is 2000, half speed is 500
		wSpeed = (WORD)(dSpeed * C_NORMAL_PLAYBACK_SPEED);

		// Go to trick reverse play
		hr = Trick_ReversePlay(wSpeed);
		if (FAILED(hr))
		{
			return hr;
		}

		m_dPlaySpeed = dSpeed;
	}

	// Check for an error in the reverse play
	hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}
	m_bForwardPlayback = FALSE;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::ShowMenu(
    /* [in] */ DVD_MENU_ID MenuID)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}
	HRESULT hr;
	ULONG ulerr;
	DVDLocation loc;

	ulerr = DDP_GetCurrentLocation( m_ddpThePlayer, loc );
	hr = ConvertError( ulerr );
	if(FAILED(hr))
	{
		return E_FAIL;
	}

	switch( loc.domain )
	{
		case FP_DOM:
			return E_FAIL;

		case TT_DOM:
		case VTSM_DOM:
		case VMGM_DOM:
		case STOP_DOM:
			{
				VTSMenuType vtsmenu;
				switch( MenuID )
				{
					case QMENU_TITLE:
						vtsmenu = VMT_TITLE_MENU;
						break;
					case QMENU_ROOT:
						vtsmenu = VMT_ROOT_MENU;
						break;
					case QMENU_SUBPIC:
						vtsmenu = VMT_SUBPICTURE_MENU;
						break;
					case QMENU_AUDIO:
						vtsmenu = VMT_AUDIO_MENU;
						break;
					case QMENU_ANGLE:
						vtsmenu = VMT_ANGLE_MENU;
						break;
					case QMENU_CHAPTER:
						vtsmenu = VMT_PTT_MENU;
						break;
					default:
						return E_FAIL;
				}

				ulerr = (ULONG)DDP_MenuCall( m_ddpThePlayer, vtsmenu );
				hr = ConvertError( ulerr );
				return hr;
			}
	} // end switch domain
	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::Resume(void)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	HRESULT hr;
	ULONG ulerr;
	ulerr = DDP_Resume(m_ddpThePlayer);
	hr = ConvertError(ulerr);
	return hr;
}


HRESULT STDMETHODCALLTYPE DVDMediaPlayer::SelectRelativeButton(
    DVD_RELATIVE_BUTTON buttonDir)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	HRESULT hr;
	ULONG ulerr = 0;

	switch(buttonDir)
	{
	case DVD_Relative_Upper:
		ulerr = DDP_UpperButtonSelect( m_ddpThePlayer );
		break;
	case DVD_Relative_Lower:
		ulerr = DDP_LowerButtonSelect( m_ddpThePlayer );
		break;
	case DVD_Relative_Left:
		ulerr = DDP_LeftButtonSelect( m_ddpThePlayer );
		break;
	case DVD_Relative_Right:
		ulerr = DDP_RightButtonSelect( m_ddpThePlayer );
		break;
	}

	hr = ConvertError( ulerr );
	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::ActivateButton(void)
{
	if (!m_ddpThePlayer)
	{
		return QI_E_NOTINITIALIZED;
	}

	ULONG   ulError;
	HRESULT hr;

	// Trigger an "enter" command upon whatever DVD option is highlighted
	ulError = (ULONG)DDP_ButtonActivate( m_ddpThePlayer );
	hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::SelectAndActivateButton(
    /* [in] */ ULONG ulButton)
{	if (!m_ddpThePlayer)
	{
		return QI_E_NOTINITIALIZED;
	}

	return ConvertError(DDP_ButtonSelectAndActivate(m_ddpThePlayer,(WORD)ulButton));
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::StillOff( void)
{
	if (!m_ddpThePlayer)
	{
		return E_FAIL;
	}
	ULONG   ulError;
	HRESULT hr;

	ulError = DDP_StillOff(m_ddpThePlayer);
	hr = ConvertError(ulError);
	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::Pause(
    /* [in] */ BOOL bState)
{
	if (!m_ddpThePlayer)
	{
		return QI_E_NOTINITIALIZED;
	}

	ULONG         ulError;
	DVDPlayerMode lMode;
	HRESULT       hr;

	if(bState)
	{
		// Get the current mode state
		lMode = DDP_GetPlayerMode(m_ddpThePlayer);

		// If the mode is already paused, return S_OK.  If the mode is
		// an unpausable mode, return E_FAIL
		//
		switch (lMode)
		{
			case DPM_NONE:
			case DPM_STILL:
			case DPM_STOPPED:
				// These are modes incapable of being paused.
				return E_FAIL;

			case DPM_PAUSED:
				// Already paused
				return S_OK;
		}

		// Turn pause ON
		ulError = DDP_PauseOn(m_ddpThePlayer);
		hr = ConvertError(ulError);
		if( FAILED(hr) )
		{
			return hr;
		}

		// Set the current play mode, paused and motionless
		return S_OK;
	}
	else
	{
		// Make sure we are in a paused state
		lMode = DDP_GetPlayerMode(m_ddpThePlayer);
		if (lMode != DPM_PAUSED)
		{
			return E_FAIL;
		}

		// Ending current mode and resuming playback from this point
		ulError = (ULONG)DDP_PauseOff( m_ddpThePlayer );
		hr = ConvertError(ulError);
		if (FAILED(hr))
		{
			return hr;
		}

		return S_OK;
	}
}

HRESULT DVDMediaPlayer::Pause()
{
	if (!m_ddpThePlayer)
	{
		return QI_E_NOTINITIALIZED;
	}

	DVDPlayerMode lMode;

	// Get the current mode state
	lMode = DDP_GetPlayerMode(m_ddpThePlayer);

	// If the mode is already paused, return S_OK.  If the mode is
	// an unpausable mode, return E_FAIL
	//
	switch (lMode)
	{
		case DPM_NONE:
		case DPM_STILL:
		case DPM_STOPPED:
			// These are modes incapable of being paused.
			return E_FAIL;

		case DPM_PAUSED:
			return Pause(false);
		default:
			return Pause(true);
	}
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::SelectAudioStream(
    /* [in] */ ULONG ulAudio)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	ULONG ulerr = DDP_AudioStreamChange( m_ddpThePlayer, (WORD)ulAudio );
	HRESULT hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;
	m_ulCurrentAudio = (ULONG)ulAudio;
	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::SelectSubpictureStream(
    /* [in] */ ULONG ulSubPicture)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	m_bSubPicOn = TRUE; // we set this member variable here because we want
	// the subpic data displayed regardless of the member
	// variable's current state. Default is FALSE.
	ULONG ulerr = DDP_SubPictureStreamChange( m_ddpThePlayer,
		(WORD)ulSubPicture, m_bSubPicOn);
	HRESULT hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;
	m_ulCurrentSubpic = ulSubPicture;
	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::SetSubpictureState(
    /* [in] */ BOOL bState)
{
	if ( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	BYTE  btaudioMask;
	DWORD dwsubPictureMask;
	int   i;
	WORD  wsubPicData[32];
	WORD  wnumSubPic;
	WORD  wcurrentSubPic;
	DWORD dwbitChk = 1;

	ULONG ulerr = DDP_GetAvailStreams( m_ddpThePlayer, btaudioMask, dwsubPictureMask );
	wnumSubPic = 0;

	// mark available stream numbers
	for ( i=0; i < C_MAX_STREAMS; i++ )
	{
		if ( dwbitChk & dwsubPictureMask )
		{
			wsubPicData[wnumSubPic] = (WORD)i;
			wnumSubPic++;
		}
		dwbitChk *= 2;
	}//end of for loop

	// get current stream index
	wcurrentSubPic = (WORD)DDP_GetCurrentSubPictureStream( m_ddpThePlayer );
	m_bSubPicOn = bState;
	// notify stream number indicated by current index
	ulerr = DDP_SubPictureStreamChange( m_ddpThePlayer,
		wsubPicData[ wcurrentSubPic ],
		m_bSubPicOn );
	HRESULT hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;
	m_ulCurrentSubpic = (ULONG)wcurrentSubPic;

	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::SelectAngle(
    /* [in] */ ULONG ulAngle)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	ULONG ulerr = DDP_AngleChange( m_ddpThePlayer, (SHORT)ulAngle);
	HRESULT hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;
	m_ulCurrentAngle = ulAngle;
	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::SelectParentalLevel(
    /* [in] */ ULONG ulParentalLevel)
{
	if( (ulParentalLevel < 1 || ulParentalLevel > 9) || (ulParentalLevel == 0xFFFFFFFF) )
		return QI_W_DATAOUTOFRANGE;

	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}
	HRESULT hr;
	ULONG ulErr;
	ulErr = (ULONG)DDP_ParentalLevelSelect( m_ddpThePlayer, (WORD)ulParentalLevel );
	hr = ConvertError( ulErr );
	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::SelectParentalCountry(
    /* [in] */ WORD wCountry)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}
	HRESULT hr;
	ULONG ulErr;
	ulErr = DDP_ParentalCountrySelect( m_ddpThePlayer, wCountry);
	hr = ConvertError( ulErr );
	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::ActivateAtPosition(
    /* [in] */ POINT point)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}
	HRESULT hr;
	ULONG ulErr;
	ulErr = DDP_ButtonSelectAndActivateAt(m_ddpThePlayer, (WORD)point.x, (WORD)point.y);
	hr = ConvertError( ulErr );
	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::SelectAtPosition(
    /* [in] */ POINT point)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}
	HRESULT hr;
	ULONG ulErr;
	ulErr = DDP_ButtonSelectAt(m_ddpThePlayer, (WORD)point.x, (WORD)point.y);
	hr = ConvertError( ulErr );
	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::PlayChaptersAutoStop(
    /* [in] */ ULONG ulTitle,
    /* [in] */ ULONG ulChapter,
    /* [in] */ ULONG ulChaptersToPlay)
{
	// wmp - TBD
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::AcceptParentalLevelChange(
    /* [in] */ BOOL bAccept)
{
	m_bAcceptParentalLevelChange = bAccept;
	return S_OK;
}


HRESULT STDMETHODCALLTYPE DVDMediaPlayer::PlayPeriodInTitleAutoStop(
    /* [in] */ ULONG ulTitle,
    /* [in] */ ULONG ulChapter,
    /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
    /* [in] */ DVD_HMSF_TIMECODE *pEndTime,
    /* [in] */ DWORD flags,
	/* [out]*/ DWORD& breakpointID)
{
	ULONG ulerr;
	HRESULT hr;

	if( !m_ddpThePlayer )
		return E_FAIL;

	if(ulChapter == NULL)
	{
		ulerr = DDP_SetBreakpoint(m_ddpThePlayer,
									(WORD) ulTitle,
									DVDTime(pEndTime->bHours,pEndTime->bMinutes,pEndTime->bSeconds,pEndTime->bFrames,30),
									flags,
									breakpointID);
	}
	else
	{
		ulerr = DDP_SetBreakpointExt(m_ddpThePlayer,
									(WORD) ulTitle,
									(WORD) ulChapter,
									DVDTime(pEndTime->bHours,pEndTime->bMinutes,pEndTime->bSeconds,pEndTime->bFrames,30),
									flags,
									breakpointID);
	}

	hr = ConvertError(ulerr);
	if( FAILED(hr) )
		return hr;

	if(pStartTime != NULL)
	{
		DVDLocation loc;
		ulerr = DDP_GetCurrentLocation( m_ddpThePlayer, loc );
		hr = ConvertError( ulerr );
		if( FAILED(hr) )
			return hr;

		if(loc.title != ulTitle)
		{
			ulerr = DDP_TimePlayForced( m_ddpThePlayer, (WORD) ulTitle, DVDTime() );
			hr = ConvertError( ulerr );
			if( FAILED(hr) )
				return hr;
		}

		ulerr = DDP_TimeSearchForced( m_ddpThePlayer, DVDTime(pStartTime->bHours, pStartTime->bMinutes, pStartTime->bSeconds, pStartTime->bFrames, 25 ));
		hr = ConvertError(ulerr);
		if( FAILED(hr) )
			return hr;
	}

	return hr;


}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::ClearBreakpoint(
    /* [in] */ DWORD& breakpointID)
{
	ULONG ulerr;
	HRESULT hr;

	if( !m_ddpThePlayer )
		return E_FAIL;

	ulerr = DDP_ClearBreakpoint(m_ddpThePlayer, breakpointID);
	hr = ConvertError(ulerr);
	return hr;
}


HRESULT STDMETHODCALLTYPE DVDMediaPlayer::SelectDefaultMenuLanguage(
    /* [in] */ LCID Language)
{
	ULONG ulerr;
	HRESULT hr;

	if( !m_ddpThePlayer )
		return E_FAIL;

	ulerr = DDP_MenuLanguageSelect(m_ddpThePlayer, (SHORT)Language);
	hr = ConvertError(ulerr);
	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::SelectDefaultAudioLanguage(
    /* [in] */ LCID Language,
    /* [in] */ DVD_AUDIO_LANG_EXT audioExtension)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	DVDSubPictureStreamFormat subPicFormat;
	ULONG ulerr;
	HRESULT hr;
	SHORT sSubPicNum;

	if (0 == m_PreferredSubpicLanguage)
	{
//		m_ulCurrentSubpic = DDP_GetCurrentSubPictureStream( m_ddpThePlayer );
//		sSubPicNum = (SHORT)m_ulCurrentSubpic;
//
//		ulerr = DDP_GetSubPictureStreamAttributes( m_ddpThePlayer, (WORD)sSubPicNum,
//			subPicFormat );
//		hr = ConvertError( ulerr );
//		if( FAILED(hr) )
//			return E_FAIL;

		subPicFormat.languageCode = LANG_NEUTRAL;
		subPicFormat.languageExtension = 0;
	}
	else
	{
		subPicFormat.languageCode = m_PreferredSubpicLanguage;
		subPicFormat.languageExtension = m_PreferredSubpicExt;
	}

	ulerr = DDP_InitialLanguageSelect(m_ddpThePlayer, Language,
		audioExtension, subPicFormat.languageCode, subPicFormat.languageExtension);

	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	m_PreferredAudioLanguage = Language;
	m_PreferredAudioExt = audioExtension;

	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::SelectDefaultSubpictureLanguage(
    /* [in] */ LCID Language,
    /* [in] */ DVD_SUBPICTURE_LANG_EXT subpictureExtension)
{
	if( !m_ddpThePlayer )
	{
		return E_FAIL;
	}

	DVDAudioStreamFormat audioFormat;
	ULONG ulerr;
	HRESULT hr;
	SHORT sAudioNum;

	if (0 == m_PreferredAudioLanguage)
	{
//		m_ulCurrentAudio = DDP_GetCurrentAudioStream( m_ddpThePlayer );
//		sAudioNum = (SHORT)m_ulCurrentAudio;
//
//		ulerr = DDP_GetAudioStreamAttributes( m_ddpThePlayer, (WORD)sAudioNum,
//			audioFormat );
//		hr = ConvertError( ulerr );
//		if( FAILED(hr) )
//			return E_FAIL;

		audioFormat.languageCode = LANG_NEUTRAL;
		audioFormat.languageExtension = 0;
	}
	else
	{
		audioFormat.languageCode = m_PreferredAudioLanguage;
		audioFormat.languageExtension = m_PreferredAudioExt;
	}

	ulerr = DDP_InitialLanguageSelect(m_ddpThePlayer, audioFormat.languageCode, audioFormat.languageExtension,
		Language, subpictureExtension);

	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	m_PreferredSubpicLanguage = Language;
	m_PreferredSubpicExt = subpictureExtension;

	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetCurrentDomain(
    /* [out] */ DVD_DOMAIN __RPC_FAR *pDomain)
{
	HRESULT hr;
	ULONG ulerr;
	DVDLocation loc;

	if(!m_ddpThePlayer)
		return E_FAIL;

	ulerr = DDP_GetCurrentLocation(m_ddpThePlayer, loc);
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	*pDomain = (DVD_DOMAIN) (loc.domain + 1);		// the + 1 maps DVDDomain to DVD_DOMAIN enums

	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetCurrentLocation(
    /* [out] */ DVD_PLAYBACK_LOCATION2 __RPC_FAR *pLocation)
{
	HRESULT hr;
	ULONG ulerr;
	DVDLocation loc;

	if(!m_ddpThePlayer)
		return E_FAIL;

	ulerr = DDP_GetCurrentLocation(m_ddpThePlayer, loc);
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	pLocation->TitleNum = loc.title;
	pLocation->ChapterNum = loc.partOfTitle; // wmp - tbd - check this!!!!
	pLocation->TimeCode.bHours = (BYTE)loc.titleTime.Hours();
	pLocation->TimeCode.bMinutes = (BYTE)loc.titleTime.Minutes();
	pLocation->TimeCode.bSeconds = (BYTE)loc.titleTime.Seconds();
	pLocation->TimeCode.bFrames = (BYTE)loc.titleTime.Frames();
	pLocation->TimeCodeFlags = 0;

	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetTotalTitleTime(
    /* [out] */ DVD_HMSF_TIMECODE __RPC_FAR *pTotalTime,
    /* [out] */ ULONG __RPC_FAR *ulTimeCodeFlags,
	/* [in]	 */ ULONG title)
{
	HRESULT hr;
	ULONG ulerr;
	DVDLocation loc;
	DVDTime time;

	if(!m_ddpThePlayer)
		return E_FAIL;
	if(title == NULL)
	{

		ulerr = DDP_GetCurrentDuration(m_ddpThePlayer, loc);
		time = loc.titleTime;
	}
	else
	{
		ulerr = DDP_GetTitleDuration(m_ddpThePlayer, (WORD) title, time);
	}

	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	pTotalTime->bHours = (BYTE)time.Hours();
	pTotalTime->bMinutes = (BYTE)time.Minutes();
	pTotalTime->bSeconds = (BYTE)time.Seconds();
	pTotalTime->bFrames = (BYTE)time.Frames();

	return hr;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetCurrentButton(
    /* [out] */ ULONG __RPC_FAR *pulButtonsAvailable,
    /* [out] */ ULONG __RPC_FAR *pulCurrentButton)
{
	ULONG ulerr;
	HRESULT hr;

	if(!m_ddpThePlayer)
		return E_FAIL;

	ulerr = DDP_GetExtendedPlayerState(m_ddpThePlayer, m_eps);
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	*pulButtonsAvailable = m_eps.numberOfButtons;
	*pulCurrentButton = m_eps.selectedButton;

	return S_OK;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetCurrentAngle(
    /* [out] */ ULONG __RPC_FAR *pulAnglesAvailable,
    /* [out] */ ULONG __RPC_FAR *pulCurrentAngle)
{
	HRESULT hr;
	ULONG ulerr;
	DVDLocation loc;

	if(!m_ddpThePlayer)
		return E_FAIL;

	ulerr = DDP_GetCurrentLocation(m_ddpThePlayer, loc);
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	*pulAnglesAvailable = DDP_GetNumberOfAngles(m_ddpThePlayer, loc.title);

	*pulCurrentAngle = DDP_GetCurrentAngle(m_ddpThePlayer);

	return S_OK;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetCurrentAudio(
    /* [out] */ ULONG __RPC_FAR *pulStreamsAvailable,
    /* [out] */ ULONG __RPC_FAR *pulCurrentStream)
{
	HRESULT hr;
	ULONG ulerr;
	BYTE audio = 0;
	DWORD subPic;

	if(!m_ddpThePlayer)
		return E_FAIL;

	ulerr = DDP_GetAvailStreams(m_ddpThePlayer, audio, subPic);
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	DWORD dwbitChk = 1L;
	unsigned long lnum = 0;
	for (int  i=0; i < 32; i++ )
	{
		if ( dwbitChk & audio )
			lnum++;
		dwbitChk *= 2;
	}
	*pulStreamsAvailable = lnum;

	*pulCurrentStream = DDP_GetCurrentAudioStream(m_ddpThePlayer);

	return S_OK;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetCurrentSubpicture(
    /* [out] */ ULONG __RPC_FAR *pulStreamsAvailable,
    /* [out] */ ULONG __RPC_FAR *pulCurrentStream,
    /* [out] */ BOOL __RPC_FAR *pbIsDisabled)
{
	HRESULT hr;
	ULONG ulerr;
	BYTE audio;
	DWORD subPic;

	if(!m_ddpThePlayer)
		return E_FAIL;

	ulerr = DDP_GetAvailStreams(m_ddpThePlayer, audio, subPic);
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	DWORD dwbitChk = 1L;
	unsigned long lnum = 0;
	for (int i=0; i<32; i++ )
	{
		if ( dwbitChk & subPic )
			lnum++;
		dwbitChk *= 2;
	}

	*pulStreamsAvailable = lnum;

	*pulCurrentStream = DDP_GetCurrentSubPictureStream(m_ddpThePlayer);

	*pbIsDisabled = DDP_IsCurrentSubPictureEnabled(m_ddpThePlayer);

	return S_OK;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetCurrentUOPS(
    /* [out] */ ULONG __RPC_FAR *pulUOPs)
{
	if(!m_ddpThePlayer)
		return E_FAIL;

	*pulUOPs = DDP_GetForbiddenUserOperations(m_ddpThePlayer);

	return S_OK;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetAllSPRMs(
    /* [out] */ SPRMARRAY __RPC_FAR *pRegisterArray)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetAllGPRMs(
    /* [out] */ GPRMARRAY __RPC_FAR *pRegisterArray)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetAudioLanguage(
    /* [in] */ ULONG ulStream,
    /* [out] */ LCID __RPC_FAR *pLanguage)
{
	ULONG ulerr;
	HRESULT hr;
	DVDAudioStreamFormat audioFormat;

	if(!m_ddpThePlayer)
		return E_FAIL;

	ulerr = DDP_GetAudioStreamAttributes(m_ddpThePlayer, (WORD)ulStream, audioFormat);
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	*pLanguage = audioFormat.languageCode;

	return S_OK;
}


HRESULT STDMETHODCALLTYPE  DVDMediaPlayer::GetAudioLanguage(ULONG ulAudioNum, char* pstrCountry, UINT nMaxLength)
{
	if (pstrCountry == NULL)
		return E_POINTER;

	if( m_ddpThePlayer )
	{
		DVDAudioStreamFormat audioFormat;
		ULONG ulerr;
		HRESULT hr;
		char buffer[MAX_PATH];

		ulerr = DDP_GetAudioStreamAttributes( m_ddpThePlayer, (WORD)ulAudioNum,
			audioFormat );
		hr = ConvertError( ulerr );
		if( FAILED(hr) )
			return E_FAIL;

		buffer[0] = '\0'; // safety init.
		int isize = sizeof( LANGUAGE_DATA ) / sizeof( LANGUAGE_DATA[0] );
		for( int i=0; i < isize; i++ )
		{
			if( audioFormat.languageCode == LANGUAGE_DATA[i].code )
				break;
		}
		if( i == isize ) // if we didn't find a match, use lang_neutral
			i = 0;

		GetLanguageStringFromCode(audioFormat.languageCode, buffer, MAX_PATH);

		switch( audioFormat.languageExtension ) // specific code extension
		{
			case DVD_AUD_EXT_VisuallyImpaired:
				strcat(buffer, IDS_AUD_VISUALLY_IMPAIRED);
				break;
			case DVD_AUD_EXT_DirectorComments1:
			case DVD_AUD_EXT_DirectorComments2:
				strcat(buffer, IDS_AUD_DIRECTORS_COMMENTS);
				break;
			default:
				{
					switch( /*(*/audioFormat.channels - 1 /* & 0x07)*/ )
					{
						case 0x00:
							strcat(buffer, " [1]");
							break;

						case 0x01:
							strcat(buffer, " [2]");
							break;

						case 0x02:
							strcat(buffer, " [3]");
							break;

						case 0x03:
							strcat(buffer, " [4]");
							break;
						case 0x04:
							strcat(buffer, " [5]");
							break;
						case 0x05:
							strcat(buffer, " [5.1]");
							break;
						case 0x06:
							strcat(buffer, " [7]");
							break;
						case 0x07:
							strcat(buffer, " [8]");
							break;
					} // end switch
				}
				break;
		} // end switch

		strncpy(pstrCountry, buffer, nMaxLength);
		return S_OK;
	}
	return E_FAIL;
}




HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetSubpictureLanguage(
    /* [in] */ ULONG ulStream,
    /* [out] */ LCID __RPC_FAR *pLanguage)
{
	ULONG ulerr;
	HRESULT hr;
	DVDSubPictureStreamFormat subPicFormat;

	if(!m_ddpThePlayer)
		return E_FAIL;

	ulerr = DDP_GetSubPictureStreamAttributes(m_ddpThePlayer, (WORD)ulStream, subPicFormat);
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	*pLanguage = subPicFormat.languageCode;

	return S_OK;
}

HRESULT STDMETHODCALLTYPE  DVDMediaPlayer::GetSubpictureLanguage(ULONG ulSubpicNum, char* pstrCountry, UINT nMaxLength)
{
	if (pstrCountry == NULL)
		return E_POINTER;

	if( m_ddpThePlayer )
	{
		DVDSubPictureStreamFormat subPicFormat;

		ULONG ulerr = DDP_GetSubPictureStreamAttributes(
			m_ddpThePlayer,
			(WORD)ulSubpicNum,
			subPicFormat );
		HRESULT hr = ConvertError( ulerr );
		if( FAILED(hr) )
			return E_FAIL;

		TCHAR buffer[MAX_PATH];
		buffer[0] = 0; // safety init.
		int isize = sizeof( LANGUAGE_DATA ) / sizeof( LANGUAGE_DATA[0] );
		for( int i=0; i < isize; i++ )
		{
			if( subPicFormat.languageCode == LANGUAGE_DATA[i].code )
				break;
		}
		if( i == isize ) // if we didn't find a match, use lang_neutral
			i = 0;

		GetLanguageStringFromCode(subPicFormat.languageCode, buffer, MAX_PATH);

		switch( subPicFormat.languageExtension ) // specific code extension
		{
			case DVD_SP_EXT_Caption_Normal:
				strcat(buffer, IDS_SUBPIC_NORMAL);
				break;
			case DVD_SP_EXT_Caption_Big:
				strcat(buffer, IDS_SUBPIC_BIG);
				break;
			case DVD_SP_EXT_Caption_Children:
				strcat(buffer, IDS_SUBPIC_CHILDREN);
				break;
			case DVD_SP_EXT_CC_Normal:
				strcat(buffer, IDS_SUBPIC_CC_NORMAL);
				break;
			case DVD_SP_EXT_CC_Big:
				strcat(buffer, IDS_SUBPIC_CC_BIG);
				break;
			case DVD_SP_EXT_CC_Children:
				strcat(buffer, IDS_SUBPIC_CC_CHILDREN);
				break;
			case DVD_SP_EXT_Forced:
				strcat(buffer, IDS_SUBPIC_FORCED);
				break;
			case DVD_SP_EXT_DirectorComments_Normal:
				strcat(buffer, IDS_SUBPIC_DIRECTORS_NORMAL);
				break;
			case DVD_SP_EXT_DirectorComments_Big:
				strcat(buffer, IDS_SUBPIC_DIRECTORS_BIG);
				break;
			case DVD_SP_EXT_DirectorComments_Children:
				strcat(buffer, IDS_SUBPIC_DIRECTORS_CHILDREN);
				break;
			default:
				break;
		} // end switch

		strncpy(pstrCountry, buffer, nMaxLength);

		return S_OK;
	}
	return E_FAIL;
}



HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetTitleAttributes(
    /* [in] */ ULONG ulTitle,
    /* [out] */ DVD_ATR __RPC_FAR *pATR)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetVMGAttributes(
    /* [out] */ DVD_ATR __RPC_FAR *pATR)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetCurrentVideoAttributes(
    /* [out] */ DVD_VideoATR __RPC_FAR *pATR)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetVideoAttributes(
    /* [in] */ ULONG ulTitle,
    /* [in] */ BOOL bForMenus,
    /* [out] */ DVD_VideoATR __RPC_FAR *pATR)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetAudioAttributes(
    /* [in] */ ULONG ulStream,
    /* [out] */ DVD_AudioAttributes __RPC_FAR *pATR)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetKaraokeAttributes(
    /* [in] */ ULONG ulStream,
    /* [out] */ DVD_KaraokeAttributes __RPC_FAR *pAttributes)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetSubpictureAttributes(
    /* [in] */ ULONG ulStream,
    /* [out] */ DVD_SubpictureATR __RPC_FAR *pATR)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetDVDVolumeInfo(
    /* [out] */ ULONG __RPC_FAR *pulNumOfVolumes,
    /* [out] */ ULONG __RPC_FAR *pulVolume,
    /* [out] */ DVD_DISC_SIDE __RPC_FAR *pSide,
    /* [out] */ ULONG __RPC_FAR *pulNumOfTitles)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetDVDTextNumberOfLanguages(
    /* [out] */ ULONG __RPC_FAR *pulNumOfLangs)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetDVDTextLanguageInfo(
    /* [in] */ ULONG ulLangIndex,
    /* [out] */ ULONG __RPC_FAR *pulNumOfStrings,
    /* [out] */ LCID __RPC_FAR *pLangCode,
    /* [out] */ enum DVD_TextCharSet __RPC_FAR *pbCharacterSet)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetDVDTextStringAsNative(
    /* [in] */ ULONG ulLangIndex,
    /* [in] */ ULONG ulStringIndex,
    /* [out] */ BYTE __RPC_FAR *pbBuffer,
    /* [in] */ ULONG ulMaxBufferSize,
    /* [out] */ ULONG __RPC_FAR *pulActualSize,
    /* [out] */ enum DVD_TextStringType __RPC_FAR *pType)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetDVDTextStringAsUnicode(
    /* [in] */ ULONG ulLangIndex,
    /* [in] */ ULONG ulStringIndex,
    /* [out] */ WCHAR __RPC_FAR *pchwBuffer,
    /* [in] */ ULONG ulMaxBufferSize,
    /* [out] */ ULONG __RPC_FAR *pulActualSize,
    /* [out] */ enum DVD_TextStringType __RPC_FAR *pType)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetPlayerParentalLevel(
    /* [out] */ ULONG __RPC_FAR *pulParentalLevel,
    /* [out] */ WORD __RPC_FAR *wCountryCode)
{
	ULONG ulerr;
	HRESULT hr;
	ExtendedPlayerState Eps;

	if(!m_ddpThePlayer)
		return E_FAIL;

	Eps.request = EPS_PARENTAL;

	ulerr = DDP_GetExtendedPlayerState(m_ddpThePlayer, Eps);
	hr = ConvertError( ulerr );
	if( FAILED(hr) )
		return E_FAIL;

	WORD wLevel = Eps.parentalLevel;
	*pulParentalLevel = wLevel;
	*wCountryCode = Eps.parentalCountry;

	return S_OK;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetNumberOfChapters(
    /* [in] */ ULONG ulTitle,
    /* [out] */ ULONG __RPC_FAR *pulNumOfChapters)
{
	if(!m_ddpThePlayer)
		return E_FAIL;

	*pulNumOfChapters = DDP_GetNumberOfPartOfTitle(m_ddpThePlayer, (WORD)ulTitle);

	return S_OK;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetTitleParentalLevels(
    /* [in] */ ULONG ulTitle,
    /* [out] */ ULONG __RPC_FAR *pulParentalLevels)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetDVDDirectory(
    /* [size_is][out] */ LPWSTR pszwPath,
    /* [in] */ ULONG cbMaxSize,
    /* [out] */ ULONG __RPC_FAR *pcbActualSize)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::IsAudioStreamEnabled(
    /* [in] */ ULONG ulStreamNum,
    /* [out] */ BOOL __RPC_FAR *pbEnabled)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetUniqueID(
    /* [in] */ LPCWSTR pszwPath,
    /* [out] */ ULONGLONG __RPC_FAR *pullUniqueID)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetMenuLanguages(
    /* [out] */ LCID __RPC_FAR *pLanguages,
    /* [in] */ ULONG uMaxLanguages,
    /* [out] */ ULONG __RPC_FAR *puActualLanguages)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetButtonAtPosition(
    /* [in] */ POINT point,
    /* [out] */ ULONG __RPC_FAR *puButtonIndex)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetDefaultMenuLanguage(
    /* [out] */ LCID __RPC_FAR *pLanguage)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetDefaultAudioLanguage(
    /* [out] */ LCID __RPC_FAR *pLanguage,
    /* [out] */ DVD_AUDIO_LANG_EXT __RPC_FAR *pAudioExtension)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE DVDMediaPlayer::GetDefaultSubpictureLanguage(
    /* [out] */ LCID __RPC_FAR *pLanguage,
    /* [out] */ DVD_SUBPICTURE_LANG_EXT __RPC_FAR *pSubpictureExtension)
{
	return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: Get_AspectRatios()
// Description:
//   Arguments:     long& xFactor -
//                  long& yFactor -
//      Return:     HRESULT  - S_OK or appropriate error code
// 4:3 or 16:9
///////////////////////////////////////////////////////////////////////////////
HRESULT DVDMediaPlayer::Get_AspectRatios( ULONG& xFactor, ULONG& yFactor )
{

	if (!m_ddpThePlayer)
	{
		// Default to 4X3
		xFactor = 4;
		yFactor = 3;
		return S_OK;
	}

	m_iDisplayMode = DDP_GetCurrentDisplayMode(m_ddpThePlayer);

	if (m_iDisplayMode == DPM_16BY9)
	{
		xFactor = 16;
		yFactor = 9;
	}
	else
	{
		xFactor = 4;
		yFactor = 3;
	}
	return S_OK;
}

DisplayPresentationMode DVDMediaPlayer::GetDisplayMode(void)
{
	if(!m_ddpThePlayer)
	{
		return DPM_NONE;
	}

	return DDP_GetCurrentDisplayMode(m_ddpThePlayer);
}

HRESULT DVDMediaPlayer::SetDisplayMode( DisplayPresentationMode mode )
{
	if(!m_ddpThePlayer)
	{
		return E_FAIL;
	}

	ULONG ulerr;
	HRESULT hr;

	ulerr = DDP_SetDisplayMode(m_ddpThePlayer, mode);
	hr = ConvertError(ulerr);
	if(!FAILED(hr))
	{
		CSize newRatio;
		this->Get_AspectRatios(newRatio.cx,newRatio.cy);
		Set_AspectRatios(newRatio.cx,newRatio.cy); //also updates display
	}
	return hr;
}

HRESULT DVDMediaPlayer::Set_AspectRatios( ULONG& xFactor, ULONG& yFactor )
{
	m_bChangeRatio = true;
	m_newRatio.cx = xFactor;
	m_newRatio.cy = yFactor;
	UpdateDisplay(true);
	return S_OK;
}

HRESULT DVDMediaPlayer::SetSystemRegion(char driveLetter, BYTE regMask)
{
	if(!m_Units)
	{
		return E_FAIL;
	}

	// we are running ... shutdown to set region
	if( m_ddpThePlayer )
	{
		DDP_Stop(m_ddpThePlayer);
		EventHandlerRemove();
		DDP_ClosePlayer( m_ddpThePlayer );
		m_ddpThePlayer = NULL;
//	}

		ULONG err = DDP_SetSystemRegion(m_Units, driveLetter, regMask);

		if(IS_ERROR(err))
		{
			return ConvertError(err);
		}

		if (IS_ERROR(DDP_OpenPlayer(m_Units, driveLetter, m_ddpThePlayer)))
		{
			return E_FAIL;
		}

		if(m_pEventCallback)
		{
			EventHandlerInstall(m_pEventCallback);
		}
	}
	else // ddp is not running
	{
		ULONG err = DDP_SetSystemRegion(m_Units, driveLetter, regMask);

		if(IS_ERROR(err))
		{
			return ConvertError(err);
		}

	}

	return S_OK;

}

HRESULT DVDMediaPlayer::GetSystemRegion(char driveLetter, BYTE& regMask)
{
	BYTE availSets;
	RegionSource regionSource;

	if(!m_Units)
	{
		return E_FAIL;
	}

	HRESULT hr = DDP_GetRegionSettings(m_Units, driveLetter, regMask, availSets, regionSource);

	return hr;
}



HRESULT DVDMediaPlayer::ConvertError( ULONG ulErr )
{
	switch( ulErr )
	{
		case GNR_OK:
			return S_OK;

		case GNR_UNIMPLEMENTED:// the function is not yet implemented, and will never be
			return QI_I_NOTAPPLICABLE;

		case GNR_RANGE_VIOLATION:// a given parameter was out of bounds
			return QI_W_DATAOUTOFRANGE;

		case GNR_FILE_NOT_FOUND:// general file not found error
			return ERROR_FILE_NOT_FOUND;

		case GNR_FILE_IN_USE:// the file is currently in use
			return ERROR_DRIVE_LOCKED;

		case GNR_OBJECT_READ_ONLY:
			return QI_W_READONLY;

		case GNR_OBJECT_WRITE_ONLY:
			return QI_W_SETONLY;

		case GNR_REGIONS_DONT_MATCH:
			return QI_E_INVALID_REGION;

		case GNR_NOT_ENOUGH_MEMORY:// general not enough memory left
			return ERROR_NOT_ENOUGH_MEMORY;

		case GNR_END_OF_FILE:// attempt to read behind the end of a file
			return ERROR_HANDLE_EOF;

		case GNR_INSUFFICIENT_RIGHTS: // parental level too high
		case GNR_PARENTAL_LEVEL_TOO_LOW:
			return QI_E_INSUFFICIENT_RIGHTS;

		case GNR_INVALID_NAV_INFO:	// seeing this also on a parental too high
		case GNR_FILE_WRONG_FORMAT:// the file is in the wrong file format
		case GNR_MEM_NOT_ALLOCATED:// the memory that was requested to be freed was not allocated
			// before.
		case GNR_MEM_ALLOCATED_BEFORE:// the memory was allocated before
		case GNR_OBJECT_NOT_FOUND:// the requested object could not be found
		case GNR_OBJECT_EXISTS:// the object requested to be created does already exist
		case GNR_OBJECT_IN_USE:// an operation that needs exclusive access to an object, found the object
			// already in use
		case GNR_OBJECT_FOUND:// an object that was to be inserted in a data structure with unique objects
			// was already in there
		case GNR_INVALID_CONFIGURE_STATE:// the unit was in an invalid state for configuration
		case GNR_OBJECT_FULL:
		case GNR_OBJECT_EMPTY:
		case GNR_OBJECT_NOT_ALLOCATED:
		case GNR_OPERATION_PROHIBITED:
		case GNR_OBJECT_INVALID:
		default:
			return E_FAIL;
	} // end switch ulerr
}

HRESULT  DVDMediaPlayer::put_Volume(LONG lVal)
{
	WORD wLeft;
	WORD wRight;
	WORD wNewVolume;

	if (lVal < 0  ||  lVal > G_C_MAX_VOLUME)
	{
		return E_INVALIDARG;
	}

	if (m_Units == NULL)
	{
		return E_POINTER;
	}

	// Save the current volume for the purpose of writing it to the registry in ShutDown().  Since
	// the volume passed in is in a different scale from that of VDR, the value is converted and
	// stored in wNewVolume
	m_lCurrentVolume = lVal;
	wNewVolume = (WORD) (lVal * G_C_MAX_VOLUME);

	// Get the current left and right values.  This is needed in case the balance is not equal right now
	VDR_ConfigureUnitsTags(m_Units, GET_MPEG_LEFT_VOLUME(wLeft), GET_MPEG_RIGHT_VOLUME(wRight), TAGDONE);

	// Determine what the value of the left and right channels should be
	if (wLeft == wRight)
	{
		// Balance is equal so both channels should be the same value
		wLeft  = wNewVolume;
		wRight = wNewVolume;
	}
	else if (wRight > wLeft)
	{
		// Balance to the right. The right channel will receive the full volume value but
		// the left channel should be a based upon the proportion of the old values.  So,
		// Old Left / Old Right  ==  New Left / New Right
		wLeft  = (WORD)((float)(wNewVolume * wLeft) / (float)wRight);
		wRight = wNewVolume;
	}
	else
	{
		// Balance to the left. The left channel will receive the full volume value but
		// the right channel should be a based upon the proportion of the old values.  So,
		// Old Left / Old Right  ==  New Left / New Right
		wRight = (WORD)((float)(wNewVolume * wRight) / (float)wLeft);
		wLeft  = wNewVolume;
	}

	// Set the values of the left and right channels
	return VDR_ConfigureUnitsTags(m_Units, SET_MPEG_LEFT_VOLUME(wLeft), SET_MPEG_RIGHT_VOLUME(wRight), TAGDONE);
}

HRESULT  DVDMediaPlayer::get_Volume(LONG* plVal)
{
	WORD wLeft;
	WORD wRight;

	if (m_Units == NULL)
	{
		return E_POINTER;
	}

	// Get the current left and right values.  This is needed in case the balance is not equal right now
	VDR_ConfigureUnitsTags(m_Units, GET_MPEG_LEFT_VOLUME(wLeft), GET_MPEG_RIGHT_VOLUME(wRight), TAGDONE);
	float fVol = (float)MAX_VOLUME(wLeft, wRight) / (float)G_C_MAX_VOLUME;

	m_lCurrentVolume = LONG(fVol + 0.50f);
	*plVal = m_lCurrentVolume;
	return S_OK;
}

HRESULT DVDMediaPlayer::Trick_FrameForward()
{
	if (!m_ddpThePlayer)
	{
		return QI_E_NOTINITIALIZED;
	}

	DVDPlayerMode lMode;
	ULONG         ulError;
	HRESULT       hr;

	// Get the current mode
	lMode = DDP_GetPlayerMode(m_ddpThePlayer);

	// Based on the current status of the playback, function will do different thing.
	// If playing, video is paused.  If paused, video will advance to the next frame.
	//
	switch (lMode)
	{
		case DPM_REVERSEPLAY:
		case DPM_SCANNING:
		case DPM_PLAYING:
			// Currently playing, so pause the video
			ulError = DDP_PauseOn(m_ddpThePlayer);
			hr = ConvertError(ulError);
			return hr;

		case DPM_PAUSED:
/*			if (m_bForwardPlayback == FALSE)
			{
				ulError = (ULONG)DDP_StopScan(m_ddpThePlayer);
				hr = ConvertError(ulError);
				if (FAILED(hr))
				{
					return hr;
				}

				ulError = DDP_PauseOn(m_ddpThePlayer);
				hr = ConvertError(ulError);
				if (FAILED(hr))
				{
					return hr;
				}

				m_bForwardPlayback = TRUE;
			}
*/			// Set for trick play, if not already set
//			ulError = DDP_TrickPlay(m_ddpThePlayer);
//			hr = ConvertError(ulError);
//			if (FAILED(hr))
//			{
//				return hr;
//			}
			// * Fall through to DPM_TRICKPLAY *
		case DPM_TRICKPLAY:
			// Currently paused, so advance the frame
//			ulError = (ULONG)DDP_AdvanceFrameBy(m_ddpThePlayer, 1);
			ulError = (ULONG)DDP_AdvanceFrame(m_ddpThePlayer);
			m_bForwardPlayback = TRUE;
			hr = ConvertError(ulError);
			return hr;
	}

	return E_FAIL;
}

HRESULT DVDMediaPlayer::Trick_FrameBackward()
{
	// Make sure the player is properly initialized
	if (!m_ddpThePlayer)
	{
		return QI_E_NOTINITIALIZED;
	}

	DVDPlayerMode lMode;
	ULONG         ulError;
	HRESULT       hr;

	// Get the current mode
	lMode = DDP_GetPlayerMode(m_ddpThePlayer);

	// Based on the current status of the playback, function will do different thing.
	// If playing, video is paused.  If paused, video will go to the previous frame.
	//
	switch (lMode)
	{
		case DPM_REVERSEPLAY:
		case DPM_SCANNING:
		case DPM_PLAYING:
			// Currently reverse playing, forward playing or seeking, so pause the video
			ulError = DDP_PauseOn(m_ddpThePlayer);
			hr = ConvertError(ulError);
			return hr;

		case DPM_PAUSED:
/*			if (m_bForwardPlayback == TRUE)
			{
				// Cannot go into trick mode when in reverse playback
//				ulError = (ULONG)DDP_StopScan(m_ddpThePlayer);
				ulError = (ULONG)DDP_ReversePlayback(m_ddpThePlayer);
				hr = ConvertError(ulError);
				if (FAILED(hr))
				{
					return hr;
				}

				ulError = DDP_PauseOn(m_ddpThePlayer);
				hr = ConvertError(ulError);
				if (FAILED(hr))
				{
					return hr;
				}

				m_bForwardPlayback = FALSE;
			}
*/			// Set for trick play, if not already set
			ulError = DDP_TrickPlay(m_ddpThePlayer);
			hr = ConvertError(ulError);
			if (FAILED(hr))
			{
				return hr;
			}
			// - Fall through to DPM_TRICKPLAY -
		case DPM_TRICKPLAY:
			// Attempt to move one frame closer to the beginning of the video
			ulError = (ULONG)DDP_AdvanceFrameBy(m_ddpThePlayer, -1);
//			ulError = (ULONG)DDP_AdvanceFrame(m_ddpThePlayer);
			hr = ConvertError(ulError);
			m_bForwardPlayback = FALSE;
			return hr;
	}

	return E_FAIL;
}

//-----------------------------------------------------------------------------
//FUNCTION: Trick_ReversePlay()
//PURPOSE:  Causes the video to be presented in reverse mode and at 1X speed unless
//          the current mode does not allow reverse play to occur.  After checking
//          that the player is initialized, the mode os obtained. Based on the
//          current mode, different actions will be done. Below is a list of the
//          modes and what happens with each:
//          DPM_STOPPED / DPM_STILL:  Function returns E_FAIL because reverse play can
//                                    not begin when the player isn't running any video
//          DPM_REVERSEPLAY: Already in reverse play, but the speed could be incorrect.
//                           EnsureNormalPlaybackSpeed is called to make sure speed is
//                           at 1X.
//          DPM_PAUSED: First, pause is ended restoring previous playback mode.  If the
//                      mode is not restored into reverse play, StopScan ends any seeking
//                      and DDP_ReversePlayback() is called.
//          DPM_SCANNING: DDP_StopScan is called which ends the current scan.  Next,
//                        DDP_ReversePlayback is called to initiate reverse play, after which
//                        the speed is set to normal speed.
//          DPM_TRICKPLAY: First, trick play mode must be stopped.  This is done with DDP_StopScan.
//                         Then reverse play is initiated by calling DDP_ReversePlayback
//          Any other mode: Returns E_FAIL.
//          After the mode specific tasks are finished, the function checks for an error in the
//          last DDP command.  If it was a failure, the function returns a failing HRESULT.  Success
//          results in m_bForwardPlayback becoming FALSE and the function returns TRUE.
//
HRESULT DVDMediaPlayer::Trick_ReversePlay(WORD wSpeed)
{
	// Make sure the player is properly initialized
	if (!m_ddpThePlayer)
	{
		return QI_E_NOTINITIALIZED;
	}

	DVDPlayerMode lMode;
	ULONG         ulError = 0;
	HRESULT       hr;

	// Get the current mode
	lMode = DDP_GetPlayerMode(m_ddpThePlayer);

	// Based on the current mode, determine which function to call
	// to re/start playback.
	//
	switch (lMode)
	{
		case DPM_STOPPED:
		case DPM_STILL:
			// Video stopped. Cannot play backwards because we need a current video
			// point to reverse from!
			return E_FAIL;

		case DPM_REVERSEPLAY:
			// The program is currently playing the video in reverse.  Make sure
			// the video is being played at the proper 1X rate
			ulError = DDP_SetPlaybackSpeed(m_ddpThePlayer, wSpeed);
			break;

		case DPM_PAUSED:
			// Ending current mode and resuming playback from this point
			ulError = GNR_OK;

			// Current mode is paused.  Unpause (i.e. Resume) from this point.
//			hr = Resume();
//			if (FAILED(hr))
//			{
//				return hr;
//			}

			// When pause was taken away, the playback reverted to another play mode.
			lMode = DDP_GetPlayerMode(m_ddpThePlayer);

			// Since you may have resumed playback into "play" mode, switch
			// to reverse playback if you are not playing back in reverse.
			if (lMode != DPM_REVERSEPLAY)
			{
//				ulError = (ULONG)DDP_StopScan(m_ddpThePlayer);
//				hr = ConvertError(ulError);
//				if (FAILED(hr))
//				{
//					return hr;
//				}

				ulError = (ULONG)DDP_ReversePlayback(m_ddpThePlayer);
				hr = ConvertError(ulError);
				if (FAILED(hr))
				{
					return hr;
				}

				ulError = DDP_SetPlaybackSpeed(m_ddpThePlayer, wSpeed);
			}
			break;

		case DPM_SCANNING:

			// Stop the scan (aka seek)
			ulError = (ULONG)DDP_StopScan(m_ddpThePlayer);
			hr = ConvertError(ulError);
			if (FAILED(hr))
			{
				return hr;
			}

			// Tell it to play back reversed
			ulError = (ULONG)DDP_ReversePlayback(m_ddpThePlayer);
			hr = ConvertError(ulError);
			if (FAILED(hr))
			{
				return hr;
			}

			// Set playback speed to 1X
			// Get information about the playback speed
			ulError = DDP_SetPlaybackSpeed(m_ddpThePlayer, wSpeed);
			break;

		case DPM_PLAYING:
			ulError = (ULONG)DDP_ReversePlayback(m_ddpThePlayer);
			hr = ConvertError(ulError);
			if (FAILED(hr))
			{
				return hr;
			}

			// Set playback speed to 1X
			// Get information about the playback speed
			ulError = DDP_SetPlaybackSpeed(m_ddpThePlayer, wSpeed);
			break;

		case DPM_TRICKPLAY:
			// In trick play mode.  Must end trick play and start reverse playback
			ulError = (ULONG)DDP_StopScan(m_ddpThePlayer);
			hr = ConvertError(ulError);
			if (FAILED(hr))
			{
				return hr;
			}

			// Start reverse playback
			ulError = (ULONG)DDP_ReversePlayback(m_ddpThePlayer);
			hr = ConvertError(ulError);
			if (FAILED(hr))
			{
				 return hr;
			}

			ulError = DDP_SetPlaybackSpeed(m_ddpThePlayer, wSpeed);
			break;

		default:
			// Unknown mode encountered
			return E_FAIL;
    }

    // Check for an error
    hr = ConvertError(ulError);
    if (FAILED(hr))
    {
         return hr;
    }

    // Set the member variables which store that current status is
    // forward playback at normal speed.
    m_bForwardPlayback = FALSE;
    return hr;
}

//-----------------------------------------------------------------------------
//FUNCTION: Trick_Zoom(int x0, int y0, int width, int height)
//PURPOSE:  Scales the selected range to the specified zoom factor.
//INPUTS:   (x0, y0) - Upper left-hand point of the zoomed area
//          width    - Width of the rectangle you want zoomed
//          height   - Height of the area you want zoomed.
//
//NOTES:    Function will either restores the original 1X standard zoom or
//          attempts to scale the picture.  This decision is made based on
//          the value of width and height.
//          If width or height are zero, bounding region is empty and this
//          signals that the function should restore the original zoom.
//          If the bounding region has area, the function will attempt to
//          zoom to whatever that bounding region is.
//
//          Point/sizes are measured in pixels of source video NOT the size of
//          the video window!
//
HRESULT DVDMediaPlayer::Trick_Zoom(INT leftX, INT topY, INT width, INT height)
{
	ULONG   ulError;
	HRESULT hr;

	// If the width or height is 0, this is an empty region.  An empty region means
	// the component is supposed to restore the original 1X zoom.
	if (width == 0  ||  height == 0)
	{
		// Setting adapt source size to true restores the original 1X scale
		ulError = VDR_ConfigureUnitsTags(m_Units, SET_PIP_ADAPT_SOURCE_SIZE(TRUE), TAGDONE);

	}
	else
	{
		unsigned short          iSourceHeight;
		unsigned short          iSourceWidth;
		int                     iExpressedHeight;
		float                   fScaleFactor;

		// Get the actual video height
		ulError = VDR_ConfigureUnitsTags(m_Units, GET_MPEG_DISPLAY_HEIGHT(iSourceHeight), TAGDONE);
		hr = ConvertError(ulError);
		if (FAILED(hr))
		{
			return hr;
		}

		// Get the actual video width
		ulError = VDR_ConfigureUnitsTags(m_Units, GET_MPEG_DISPLAY_WIDTH(iSourceWidth), TAGDONE);
		hr = ConvertError(ulError);
		if (FAILED(hr))
		{
			return hr;
		}

		// Calculate the height the app is read
		DisplayPresentationMode iDisplayMode;
		iDisplayMode = DDP_GetCurrentDisplayMode(m_ddpThePlayer);

		// disregard above - it distorts aspect ratio
		iExpressedHeight = iSourceHeight;

		// Convert the topY point to the real source scale
		fScaleFactor = (float)iSourceHeight / (float)iExpressedHeight;
		topY   = (int)(fScaleFactor * topY);
		height = (int)(fScaleFactor * height);

		// Change the zoom
		ulError = VDR_ConfigureUnitsTags(m_Units, SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
			SET_PIP_SOURCE_LEFT(leftX),
			SET_PIP_SOURCE_TOP(topY),
			SET_PIP_SOURCE_WIDTH(width),
			SET_PIP_SOURCE_HEIGHT(height),
			TAGDONE);
	}

	// Check for an error which would have occurred in the ConfigureUnitsTags function
	hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}
	return hr;
}

// DVDMediaPlayer::Trick_Zoom
//	in:	leftX and topY set the position for the upper left corner of the zoom box.
//	in:	scaleFactor - float setting the magnification.
//		scaleFactor == 1.0 resets to normal viewing.
//		scaleFactor == 0.0 leaves the current scaleFactor intact, but moves the window to leftX, topY.
//		scaleFactor >  1.0 zooms (scaleFactor * current magnification) with box at leftX, topY.
HRESULT DVDMediaPlayer::Trick_Zoom(INT leftX, INT topY, float scaleFactor)
{
	ULONG   ulError;
	HRESULT hr;

	// If the width or height is 0, this is an empty region.  An empty region means
	// the component is supposed to restore the original 1X zoom.
	if (scaleFactor == 1.0) // reset to SF of 1.0
	{
		// Setting adapt source size to true restores the original 1X scale
		ulError = VDR_ConfigureUnitsTags(m_Units, SET_PIP_ADAPT_SOURCE_SIZE(TRUE), TAGDONE);

	}
	else if(scaleFactor == 0.0) // just reposition.
	{
		unsigned short          maxHeight, maxWidth;

		int                     iExpressedHeight;
		float                   fScaleFactor;
		float					currentSF;
		unsigned short width, height;



		// Get max video sizes
		ulError = VDR_ConfigureUnitsTags(m_Units,	GET_MPEG_DISPLAY_HEIGHT(maxHeight),
													GET_MPEG_DISPLAY_WIDTH(maxWidth),
													TAGDONE);
		hr = ConvertError(ulError);
		if (FAILED(hr))
		{
			return hr;
		}

		ulError = Get_CurrentScaleFactor(currentSF);

		hr = ConvertError(ulError);
		if (FAILED(hr))
		{
			return hr;
		}

		scaleFactor = currentSF;

		// Calculate the height the app is read
		DisplayPresentationMode iDisplayMode;
		iDisplayMode = DDP_GetCurrentDisplayMode(m_ddpThePlayer);
		iExpressedHeight = maxHeight;

		// Convert the topY point to the real source scale
		fScaleFactor = (float)maxHeight / (float)iExpressedHeight;
		topY   = (int)(fScaleFactor * topY);

		width = (unsigned short) ((float)maxWidth / scaleFactor);
		height = (unsigned short) ((float)iExpressedHeight / scaleFactor);

		// Change the zoom
		ulError = VDR_ConfigureUnitsTags(m_Units, SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
			SET_PIP_SOURCE_LEFT(leftX),
			SET_PIP_SOURCE_TOP(topY),
			SET_PIP_SOURCE_WIDTH(width),
			SET_PIP_SOURCE_HEIGHT(height),
			TAGDONE);

	}
	else // zoom
	{
		unsigned short          maxHeight, maxWidth;

		int                     iExpressedHeight;
		float                   fScaleFactor;
		float					currentSF;
		unsigned short width, height;



		// Get max video sizes
		ulError = VDR_ConfigureUnitsTags(m_Units,	GET_MPEG_DISPLAY_HEIGHT(maxHeight),
													GET_MPEG_DISPLAY_WIDTH(maxWidth),
													TAGDONE);
		hr = ConvertError(ulError);
		if (FAILED(hr))
		{
			return hr;
		}

		ulError = Get_CurrentScaleFactor(currentSF);

		hr = ConvertError(ulError);
		if (FAILED(hr))
		{
			return hr;
		}

		scaleFactor *= currentSF;

		// Calculate the height the app is read
		DisplayPresentationMode iDisplayMode;
		iDisplayMode = DDP_GetCurrentDisplayMode(m_ddpThePlayer);
		iExpressedHeight = maxHeight;

		// Convert the topY point to the real source scale
		fScaleFactor = (float)maxHeight / (float)iExpressedHeight;
		topY   = (int)(fScaleFactor * topY);

		width = (unsigned short) ((float)maxWidth / scaleFactor);
		height = (unsigned short) ((float)iExpressedHeight / scaleFactor);

		// Change the zoom
		ulError = VDR_ConfigureUnitsTags(m_Units, SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
			SET_PIP_SOURCE_LEFT(leftX),
			SET_PIP_SOURCE_TOP(topY),
			SET_PIP_SOURCE_WIDTH(width),
			SET_PIP_SOURCE_HEIGHT(height),
			TAGDONE);
	}


	// Check for an error which would have occurred in the ConfigureUnitsTags function
	hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}
	return hr;
}

HRESULT DVDMediaPlayer::Freeze(BYTE*& ppFreezeBuffer, DWORD& dwBufferSize)
{
    BYTE    *pfreezeBuffer;	        // Buffer to save state in
    DWORD	 freezeBufferSize = 1;	// Size of freeze buffer
    DWORD	 freezeBufferFill;		// Number of bytes used in freezeBuffer
	ULONG    ulError;

    switch (GetPlayerMode())
    {
	    case DPM_INACTIVE:
		case DPM_STOPPED:
			return E_FAIL;
			break;

        default:
            pfreezeBuffer = new BYTE[freezeBufferSize];
	        freezeBufferFill = freezeBufferSize;

		    //
		    // Try freezing and adapt buffer size if necessary

		    ulError = DDP_Freeze(m_ddpThePlayer, pfreezeBuffer, freezeBufferFill);
            if (IS_GNERROR(ulError))
            {
		        if (freezeBufferFill > freezeBufferSize)
                {
			        freezeBufferSize = freezeBufferFill;
                }
                if (pfreezeBuffer)
                {
   			        delete[] pfreezeBuffer;
                }
                pfreezeBuffer = new BYTE[freezeBufferSize];
    		    ulError = DDP_Freeze(m_ddpThePlayer, pfreezeBuffer, freezeBufferFill);
            }

			HRESULT hr = ConvertError(ulError);
			if (FAILED(hr))
			{
                if (pfreezeBuffer)
    			    delete[] pfreezeBuffer;

				return hr;
			}

			ppFreezeBuffer = pfreezeBuffer;
			dwBufferSize = freezeBufferSize;

//            if (pfreezeBuffer)
//            {
//  			    delete[] pfreezeBuffer;
//            }
            break;
    }

	return S_OK;
}

HRESULT DVDMediaPlayer::Defrost(BYTE* pFreezeBuffer, DWORD dwBufferSize)
{
	if (pFreezeBuffer)
	{
        ULONG ulError = DDP_Defrost(m_ddpThePlayer, pFreezeBuffer, dwBufferSize);

		HRESULT hr = ConvertError(ulError);
		if (FAILED(hr))
		{
			return hr;
		}
    }

	return S_OK;
}

// Enables or disables audio playback during a scan of 2x or less
HRESULT DVDMediaPlayer::EnableScanAudio(bool bEnable)
{
	ULONG ulError = VDR_ConfigureUnitsTags(m_Units, SET_MPEG2_AUDIO_VOLUME_DAMP((BOOL) !bEnable), TAGDONE);
	HRESULT hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}

	return S_OK;
}

// Determine if the decoder has enabled colorkey
HRESULT DVDMediaPlayer::GetColorkeyStatus(BOOL &bEnabled)
{
	ULONG ulError = VDR_ConfigureUnitsTags(m_Units, GET_PIP_COLORKEYED(bEnabled), TAGDONE);
	HRESULT hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}

	return S_OK;
}

// Determine if the decoder has enabled colorkey
HRESULT DVDMediaPlayer::SetColorkey(DWORD dwColorkey)
{
	ULONG ulError = VDR_ConfigureUnitsTags(m_Units, SET_PIP_COLORKEY_COLOR(dwColorkey), TAGDONE);
	HRESULT hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}

	return S_OK;
}

HRESULT DVDMediaPlayer::SetDestinationRect(INT leftX, INT topY, INT width, INT height)
{
	ULONG   ulError;
	HRESULT hr;

	// If the width or height is 0, this is an empty region.  An empty region means
	// the component is supposed to restore the original 1X zoom.
	if (width == 0  ||  height == 0)
	{
		// Setting adapt source size to true restores the original 1X scale
		ulError = VDR_ConfigureUnitsTags(m_Units, SET_PIP_ADAPT_SOURCE_SIZE(TRUE), TAGDONE);

	}
	else
	{
		ulError = VDR_ConfigureUnitsTags(m_Units,
			SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
			SET_PIP_DEST_LEFT(leftX),
			SET_PIP_DEST_TOP(topY),
			SET_PIP_DEST_WIDTH(width),
			SET_PIP_DEST_HEIGHT(height),
			TAGDONE);

		hr = ConvertError(ulError);
		if (FAILED(hr))
		{
			return hr;
		}
	}
	return S_OK;
}


HRESULT DVDMediaPlayer::SetOutputRect(INT leftX, INT topY, INT width, INT height)
{
	ULONG   ulError;
	HRESULT hr;

	ulError = VDR_ConfigureUnitsTags(m_Units,
			SET_PIP_DISPLAY_LEFT((short)leftX),
			SET_PIP_DISPLAY_TOP((short)topY),
			SET_PIP_DISPLAY_WIDTH((short)width),
			SET_PIP_DISPLAY_HEIGHT((short)height),
			TAGDONE);

	hr = ConvertError(ulError);
	if (FAILED(hr))
	{
		return hr;
	}
	return S_OK;
}


HRESULT DVDMediaPlayer::Get_CurrentScaleFactor(float& cSF)
{
		unsigned short          currentWidth;
		unsigned short          maxWidth;

//		float					currentSF;
		ULONG ulError;
		HRESULT hr;

		// Get the current video size
		ulError = VDR_ConfigureUnitsTags(m_Units,	GET_PIP_SOURCE_WIDTH((int&)currentWidth),
													TAGDONE);
		hr = ConvertError(ulError);
		if (FAILED(hr))
		{
			return hr;
		}

		// Get max video sizes
		ulError = VDR_ConfigureUnitsTags(m_Units,	GET_MPEG_DISPLAY_WIDTH(maxWidth),
													TAGDONE);
		hr = ConvertError(ulError);
		if (FAILED(hr))
		{
			return hr;
		}

		cSF = (float) maxWidth / (float) currentWidth;
		return S_OK;
}

void DVDMediaPlayer::EventHandlerInstall(HWND EventWnd)
	{
	if(!m_ddpThePlayer)
	{
		return;
	}

	if(EventWnd)
		m_eventWindow = EventWnd;
	else
		MessageBox(NULL, "DVDMediaPlayer::EventHandlerInstall - NO Event Window Handle passed!", "Test Player", MB_OK);


//	eventRead = eventWrite = 0;
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_TITLE_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_PART_OF_TITLE_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_VALID_UOP_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_ANGLE_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_AUDIO_STREAM_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_SUBPICTURE_STREAM_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_DOMAIN_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_PARENTAL_LEVEL_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_BITRATE_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_STILL_ON, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_STILL_OFF, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_PLAYBACK_MODE_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_CDA_PLAYING_GAP, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_READ_ERROR, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_DISPLAY_MODE_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_STREAMS_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_SCAN_SPEED_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_PLAYBACK_SPEED_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_VIDEO_STANDARD_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_BREAKPOINT_REACHED, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_DRIVE_DETACHED, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_ERROR, DDPCaptureEvent, 0);
	}

void DVDMediaPlayer::EventHandlerInstall(PEVENT_CALLBACK pEventCallback)
{
	if(!m_ddpThePlayer)
	{
		return;
	}

	if(pEventCallback)
		m_pEventCallback = pEventCallback;

//	eventRead = eventWrite = 0;
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_TITLE_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_PART_OF_TITLE_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_VALID_UOP_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_ANGLE_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_AUDIO_STREAM_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_SUBPICTURE_STREAM_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_DOMAIN_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_PARENTAL_LEVEL_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_BITRATE_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_STILL_ON, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_STILL_OFF, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_PLAYBACK_MODE_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_CDA_PLAYING_GAP, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_READ_ERROR, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_DISPLAY_MODE_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_STREAMS_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_SCAN_SPEED_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_PLAYBACK_SPEED_CHANGE, DDPCaptureEvent, 0);
//	DDP_InstallEventHandler(m_ddpThePlayer, DNE_VIDEO_STANDARD_CHANGE, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_BREAKPOINT_REACHED, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_DRIVE_DETACHED, DDPCaptureEvent, 0);
	DDP_InstallEventHandler(m_ddpThePlayer, DNE_ERROR, DDPCaptureEvent, 0);
}


void DVDMediaPlayer::EventHandlerRemove(void)
	{
	if (!m_ddpThePlayer)
		return;

	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_TITLE_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_PART_OF_TITLE_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_VALID_UOP_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_ANGLE_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_AUDIO_STREAM_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_SUBPICTURE_STREAM_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_DOMAIN_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_PARENTAL_LEVEL_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_BITRATE_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_STILL_ON);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_STILL_OFF);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_PLAYBACK_MODE_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_CDA_PLAYING_GAP);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_READ_ERROR);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_DISPLAY_MODE_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_STREAMS_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_SCAN_SPEED_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_PLAYBACK_SPEED_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_VIDEO_STANDARD_CHANGE);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_BREAKPOINT_REACHED);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_DRIVE_DETACHED);
	DDP_RemoveEventHandler(m_ddpThePlayer, DNE_ERROR);
	}

//#endif //if 0 for xbox test
///////////////////////////////////////////////////////////////////////////////
// DDPCaptureEvent() -	this is a callback function called by the DDP layer when
//						ever the request event (dwEvent) occurs. For a list of
//						events and the prototype of the callback function, see DVDCPL32.H
// Arguments:    DWORD dwEvent - the event that occurred causing this function to be called.
//               VOID* pvBuffer - any data the was passed to the InstallHandler function.
//               DWORD dwInfo - contains
// Return:       nothing
///////////////////////////////////////////////////////////////////////////////
/*
void  WINAPI DDPCaptureEvent(DWORD dwEvent, VOID* pvBuffer, DWORD dwInfo)
{
	if (DVDMediaPlayer::m_eventWindow == 0)
	{
		return;
	}
	switch(dwEvent)
	{
		case DNE_TITLE_CHANGE:
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_TITLE_CHANGE,
							dwInfo );
			break;
		case DNE_PART_OF_TITLE_CHANGE:
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_CHAPTER_START,
							dwInfo);
			break;
		case DNE_VALID_UOP_CHANGE:
			pMediaPlayer->m_dwCurrentUOPs = dwInfo;
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_VALID_UOPS_CHANGE,
							dwInfo);
			break;
		case DNE_ANGLE_CHANGE:
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_ANGLE_CHANGE,
							dwInfo);
			break;
		case DNE_AUDIO_STREAM_CHANGE:
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_AUDIO_STREAM_CHANGE,
							dwInfo);
			break;
		case DNE_SUBPICTURE_STREAM_CHANGE:
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_SUBPICTURE_STREAM_CHANGE,
							dwInfo);
			break;
		case DNE_DOMAIN_CHANGE:
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_DOMAIN_CHANGE,
							dwInfo+1);
			break;
		case DNE_PARENTAL_LEVEL_CHANGE:
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_PARENTAL_LEVEL_CHANGE,
							dwInfo);
			break;
		case DNE_STILL_ON:
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_STILL_ON,
							dwInfo);
			break;
		case DNE_STILL_OFF:
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_STILL_OFF,
							dwInfo);
			break;
		case DNE_PLAYBACK_MODE_CHANGE:
			switch (dwInfo)
			{
				case DPM_STOPPED:
					::PostMessage(DVDMediaPlayer::m_eventWindow, WM_RAVISENT_EVENT, EC_DVD_PLAYBACK_STOPPED, dwInfo);
					pMediaPlayer->m_lMode = QMODE_STOPPED;
					break;

				case DPM_PLAYING:
					pMediaPlayer->m_bForwardPlayback = TRUE;
					pMediaPlayer->m_lMode = QMODE_PLAYING;
					break;

				case DPM_REVERSEPLAY:
					pMediaPlayer->m_bForwardPlayback = FALSE;
					pMediaPlayer->m_lMode = QMODE_TRICKREVERSE;
					break;

				case DPM_PAUSED:
					pMediaPlayer->m_lMode = QMODE_PAUSED;
					break;
				case DPM_STILL:
					pMediaPlayer->m_lMode = QMODE_STILL;
					break;
				case DPM_BUSY:
					pMediaPlayer->m_lMode = QMODE_BUSY;
					break;
				case DPM_SCANNING:
					pMediaPlayer->m_lMode = QMODE_SEEKING;
					break;
				case DPM_INACTIVE:
					pMediaPlayer->m_lMode = QMODE_STOPPED;
					break;
				case DPM_TRICKPLAY:
					pMediaPlayer->m_lMode = QMODE_TRICKFRAME;
					break;
				default:
					pMediaPlayer->m_lMode = QMODE_NONE;
					break;
			}
			break;

		case DNE_READ_ERROR:
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_ERROR,
							dwInfo);
			break;
		case DNE_STREAMS_CHANGE:
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_SUBPICTURE_STREAM_CHANGE,
							dwInfo );
			break;
		case DNE_PLAYBACK_SPEED_CHANGE:
			pMediaPlayer->m_dPlaySpeed = (double)dwInfo / (double)C_NORMAL_PLAYBACK_SPEED;   // dwInfo will be 500, 1000, 1500, etc
			// Changing playback speed to a fast rate (rate>2.0) causes a switch between standard playback mode
			// and scan playback mode. This situation causes the navigator to set standard playback rate to 1.0
			// and increase the scan rate instead.  Because the navigate sets that standard rate to 1.0, an event
			// is sent to this callback for BOTH this new 1.0 playback speed and the new rapid scan rate.  This "if"
			// will prevent that 1.0 playback event from being sent to the application.
			if (pMediaPlayer->m_dPlaySpeed != 1.0  ||  pMediaPlayer->m_dScanSpeed == 1.0)
			{
				// The application is only notified of this event if one of the following conditions are true:
				// 1) (m_dPlaySpeed != 1.0) - The event signals that the non-scan playback speed just changed
				// 2) (m_dPlaySpeed == 1.0 && pMediaPlayer->m_dScanSpeed == 1.0) - The scan playback speed shows
				//                            that we are not scanning, so this change to a non-playback speed
				//                            of 1.0 means we've returned to 1.0 after traveling at another non
				//                            scan playback rate.  (i.e. From 1.5 to 1.0)
				::PostMessage(	DVDMediaPlayer::m_eventWindow,
								WM_RAVISENT_EVENT,
								EC_DVD_PLAYBACK_RATE_CHANGE,
								dwInfo);
			}
			break;
		case DNE_SCAN_SPEED_CHANGE:
			pMediaPlayer->m_dScanSpeed = (double)dwInfo;     // dwInfo will be 2, 3, 4 etc
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_PLAYBACK_RATE_CHANGE,
							dwInfo);
			break;
		case DNE_DVD_RAVISENTTIMEOUT:
			// Cinemaster DLL has timed out!  Buy the software!!!!
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_ERRORABORT,
							VFW_E_DVD_RAVISENTTIMEOUT);
			break;
		case DNE_DISPLAY_MODE_CHANGE:
			pMediaPlayer->m_lCurrentDisplayMode = dwInfo;
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_DISPLAY_MODE_CHANGE,
							dwInfo);
			break;
		case DNE_BREAKPOINT_REACHED:
			::PostMessage(	DVDMediaPlayer::m_eventWindow,
							WM_RAVISENT_EVENT,
							EC_DVD_PLAYPERIOD_AUTOSTOP,
							dwInfo);
			break;
		case DNE_NONE:
			// no corresponding event in DShow, so we won't send these.
			break;
	}
}
*/

void  WINAPI DDPCaptureEvent(DWORD dwEvent, VOID* pvBuffer, DWORD dwInfo)
{
	if (DVDMediaPlayer::m_pEventCallback == 0)
	{
		return;
	}
	switch(dwEvent)
	{
		case DNE_TITLE_CHANGE:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_TITLE_CHANGE, dwInfo);
							break;

		case DNE_PART_OF_TITLE_CHANGE:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_CHAPTER_START, dwInfo);
							break;

		case DNE_VALID_UOP_CHANGE:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_VALID_UOPS_CHANGE, dwInfo);
							break;

		case DNE_ANGLE_CHANGE:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_ANGLE_CHANGE, dwInfo);
							break;

		case DNE_AUDIO_STREAM_CHANGE:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_AUDIO_STREAM_CHANGE, dwInfo);
							break;

		case DNE_SUBPICTURE_STREAM_CHANGE:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_SUBPICTURE_STREAM_CHANGE, dwInfo);
							break;

		case DNE_DOMAIN_CHANGE:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_DOMAIN_CHANGE, dwInfo+1);
							break;

		case DNE_PARENTAL_LEVEL_CHANGE:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_PARENTAL_LEVEL_CHANGE, dwInfo);
							break;

		case DNE_STILL_ON:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_STILL_ON, dwInfo);
							break;

		case DNE_STILL_OFF:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_STILL_OFF, dwInfo);
							break;

		case DNE_PLAYBACK_MODE_CHANGE:
							switch (dwInfo)
							{
								case DPM_STOPPED:
									DVDMediaPlayer::m_pEventCallback(EC_DVD_PLAYBACK_STOPPED, dwInfo);
									pMediaPlayer->m_lMode = QMODE_STOPPED;
									break;

								case DPM_PLAYING:
									if ((pMediaPlayer->m_dScanSpeed != 1.0) && (pMediaPlayer->m_dPlaySpeed == 1.0))
									{
										DVDMediaPlayer::m_pEventCallback(EC_DVD_PLAYBACK_RATE_CHANGE,
											pMediaPlayer->m_dPlaySpeed * C_NORMAL_PLAYBACK_SPEED);
									}

									pMediaPlayer->m_dScanSpeed = 1.0;

									pMediaPlayer->m_bForwardPlayback = TRUE;
									pMediaPlayer->m_lMode = QMODE_PLAYING;
									break;

								case DPM_REVERSEPLAY:
									pMediaPlayer->m_bForwardPlayback = FALSE;
									pMediaPlayer->m_lMode = QMODE_TRICKREVERSE;
									break;

								case DPM_PAUSED:
									pMediaPlayer->m_lMode = QMODE_PAUSED;
									break;
								case DPM_STILL:
									pMediaPlayer->m_lMode = QMODE_STILL;
									break;
								case DPM_BUSY:
									pMediaPlayer->m_lMode = QMODE_BUSY;
									break;
								case DPM_SCANNING:
									pMediaPlayer->m_lMode = QMODE_SEEKING;
									break;
								case DPM_INACTIVE:
									pMediaPlayer->m_lMode = QMODE_STOPPED;
									break;
								case DPM_TRICKPLAY:
									pMediaPlayer->m_lMode = QMODE_TRICKFRAME;
									break;
								default:
									pMediaPlayer->m_lMode = QMODE_NONE;
									break;
							}
							break;

		case DNE_READ_ERROR:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_ERROR, dwInfo);
							break;

		case DNE_STREAMS_CHANGE:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_SUBPICTURE_STREAM_CHANGE, dwInfo );
							break;

		case DNE_PLAYBACK_SPEED_CHANGE:
							// dwInfo will be 500, 1000, 1500, etc
							pMediaPlayer->m_dPlaySpeed = (double)dwInfo / (double)C_NORMAL_PLAYBACK_SPEED;

							// Changing playback speed to a fast rate (rate>2.0) causes a switch
							// between standard playback mode
							// and scan playback mode. This situation causes the navigator to set
							// standard playback rate to 1.0
							// and increase the scan rate instead.  Because the navigate sets that standard
							// rate to 1.0, an event
							// is sent to this callback for BOTH this new 1.0 playback speed
							// and the new rapid scan rate.  This "if"
							// will prevent that 1.0 playback event from being sent to the application.
							if (pMediaPlayer->m_dPlaySpeed != 1.0  ||  pMediaPlayer->m_dScanSpeed == 1.0)
							{
								// The application is only notified of this event if one of the following
								// conditions are true:
								// 1) (m_dPlaySpeed != 1.0) - The event signals
								// that the non-scan playback speed just changed
								// 2) (m_dPlaySpeed == 1.0 && pMediaPlayer->m_dScanSpeed == 1.0) -
								// The scan playback speed shows
								// that we are not scanning, so this change to a non-playback speed
								// of 1.0 means we've returned to 1.0 after traveling at another non
								// scan playback rate.  (i.e. From 1.5 to 1.0)
								DVDMediaPlayer::m_pEventCallback(EC_DVD_PLAYBACK_RATE_CHANGE, dwInfo);
							}
							break;

		case DNE_SCAN_SPEED_CHANGE:
							pMediaPlayer->m_dScanSpeed = (double)dwInfo;     // dwInfo will be 2, 3, 4 etc
							DVDMediaPlayer::m_pEventCallback(EC_DVD_PLAYBACK_RATE_CHANGE, dwInfo);
							break;

		case DNE_DVD_RAVISENTTIMEOUT:
							// Cinemaster DLL has timed out!  Buy the software!!!!
							DVDMediaPlayer::m_pEventCallback(EC_ERRORABORT, (DWORD) VFW_E_DVD_RAVISENTTIMEOUT);
							break;

		case DNE_DISPLAY_MODE_CHANGE:
							pMediaPlayer->m_lCurrentDisplayMode = dwInfo;
							DVDMediaPlayer::m_pEventCallback(EC_DVD_DISPLAY_MODE_CHANGE, dwInfo);
							break;

		case DNE_BREAKPOINT_REACHED:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_PLAYPERIOD_AUTOSTOP, dwInfo);
							break;

		case DNE_ERROR:
							DVDMediaPlayer::m_pEventCallback(EC_DVD_ERROR, dwInfo);
							break;
		case DNE_NONE:
							// no corresponding event in DShow, so we won't send these.
							break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\DVDMediaPlayer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  $Workfile: DVDMediaPlayer.h $
//
//  Copyright (c) 1999  Quadrant International, Inc.
//  All Rights Reserved.
//
//////////////////////////////////////////////////////////////////////////////
//
// $Archive: /Tproj/Apps/xbDVD/DVDMediaPlayer.h $
// $Author: Thermanson $
// $Modtime: 7/02/01 3:26p $
// $Date: 7/03/01 5:43p $
// $Revision: 26 $
//
////////////////////////////////////$NoKeywords: $////////////////////////////


#ifndef AFX_DVDMEDIAPLAYER_H__DD1FA08A_135D_11D3_810A_00A0CC23CB74__INCLUDED
#define AFX_DVDMEDIAPLAYER_H__DD1FA08A_135D_11D3_810A_00A0CC23CB74__INCLUDED

#pragma warning(disable : 4244)
#pragma warning(disable : 4100)
#pragma warning(disable : 4211)
#pragma warning(disable : 4710)
#pragma warning(disable : 4018)

#include "dvdevcod.h" // dvd event codes
#include "evcode.h" // dvd event codes
#include "QProperties.h"
#include <XBApp.h>
//#include <XBFile.h>
#include <XBFont.h>
#include "dvdpld32.h"

#define DNE_DVD_RAVISENTTIMEOUT			23
#define RAV_STOP_TO_MENU				0
#define VFW_E_DVD_RAVISENTTIMEOUT		((HRESULT)0xe0000001L)
#define REGISTRY_KEY "Software\\Ravisent\\VDRDVD"
#define C_NORMAL_PLAYBACK_SPEED 1000
#define	QIM_VID_WIDTH_DEF			640
#define QIM_VID_HEIGHT_DEF			480
#define C_MAX_STREAMS	8
#define G_C_MAX_VOLUME			100
#define G_C_MAX_VDR_VOLUME		10000
#define G_C_VDR_VOLUME_SCALE	G_C_MAX_VOLUME
#define MAX_VOLUME(a,b) (((a)>(b))?(a):(b))

#ifndef WM_USER
#define WM_USER                         0x0400
#endif //WM_USER

#define WM_RAVISENT_EVENT	WM_USER + 0x010
#define WM_RAVISENT_ERROR	WM_USER + 0x011
#define WM_RAVISENT_GAMEPAD	WM_USER + 0x012
#define EC_DVD_DISPLAY_MODE_CHANGE                     (EC_DVDBASE + 0x20)


typedef void (WINAPI* PEVENT_CALLBACK)(DWORD dwEvent,  DWORD dwInfo);

enum RavisentGamePadEvent {
	RAV_NAVIGATE_UP,
	RAV_NAVIGATE_DOWN,
	RAV_NAVIGATE_LEFT,
	RAV_NAVIGATE_RIGHT,
	RAV_ENTER,
	RAV_NEXT,
	RAV_BACK,
	RAV_PLAY,
	RAV_STOP,
	RAV_PAUSE,
	RAV_MENU,
	RAV_FSCAN,
	RAV_BSCAN,
	RAV_EXIT};


enum PictureControlTyp { E_CTL_Brightness, E_CTL_Contrast,
                         E_CTL_Saturation, E_CTL_Hue,
                         E_CTL_Gamma, E_CTL_Sharpness,
                         E_CTL_RedBrightness, E_CTL_GreenBrightness,
                         E_CTL_BlueBrightness,E_CTL_COUNT};
struct CSize {
	ULONG cx;
	ULONG cy;
};

struct CPoint {
	ULONG x;
	ULONG y;
};

typedef char* BSTR;

typedef LONG CWnd;

#define WM_SETFOCUS                     0x0007
#define WM_KILLFOCUS                    0x0008
#define WM_ENABLE                       0x000A
#define WM_SETREDRAW                    0x000B
#define WM_SETTEXT                      0x000C
#define WM_GETTEXT                      0x000D
#define WM_GETTEXTLENGTH                0x000E
#define WM_PAINT                        0x000F
#define WM_CLOSE                        0x0010
#ifndef _WIN32_WCE
#define WM_QUERYENDSESSION              0x0011
#define WM_QUERYOPEN                    0x0013
#define WM_ENDSESSION                   0x0016
#endif
#define WM_QUIT                         0x0012
#define WM_ERASEBKGND                   0x0014
#define WM_SYSCOLORCHANGE               0x0015
#define WM_SHOWWINDOW                   0x0018
#define WM_WININICHANGE                 0x001A
#if WINVER>=0x0400
#define WM_SETTINGCHANGE                WM_WININICHANGE
#endif /* WINVER >= 0x0400 */

#define MB_OK                       0x00000000L
#if WINVER>=0x0400
#define WM_APP                          0x8000
#endif /* WINVER >= 0x0400 */
#define WM_NCCREATE                     0x0081
#define WM_NCDESTROY                    0x0082
#define WM_NCCALCSIZE                   0x0083
#define WM_NCHITTEST                    0x0084
#define WM_NCPAINT                      0x0085
#define WM_NCACTIVATE                   0x0086
#define WM_GETDLGCODE                   0x0087
#ifndef _WIN32_WCE
#define WM_SYNCPAINT                    0x0088
#endif
#define WM_NCMOUSEMOVE                  0x00A0
#define WM_NCLBUTTONDOWN                0x00A1
#define WM_NCLBUTTONUP                  0x00A2
#define WM_NCLBUTTONDBLCLK              0x00A3
#define WM_NCRBUTTONDOWN                0x00A4
#define WM_NCRBUTTONUP                  0x00A5
#define WM_NCRBUTTONDBLCLK              0x00A6
#define WM_NCMBUTTONDOWN                0x00A7
#define WM_NCMBUTTONUP                  0x00A8
#define WM_NCMBUTTONDBLCLK              0x00A9


#if _WIN32_WINNT>=0x0500
#define WM_NCXBUTTONDOWN                0x00AB
#define WM_NCXBUTTONUP                  0x00AC
#define WM_NCXBUTTONDBLCLK              0x00AD
#endif /* _WIN32_WINNT >= 0x0500 */


#define WM_KEYFIRST                     0x0100
#define WM_KEYDOWN                      0x0100
#define WM_KEYUP                        0x0101
#define WM_CHAR                         0x0102
#define WM_DEADCHAR                     0x0103
#define WM_SYSKEYDOWN                   0x0104
#define WM_SYSKEYUP                     0x0105
#define WM_SYSCHAR                      0x0106
#define WM_SYSDEADCHAR                  0x0107
#define WM_KEYLAST                      0x0108

#if WINVER>=0x0400
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F
#endif /* WINVER >= 0x0400 */

#define WM_INITDIALOG                   0x0110
#define WM_COMMAND                      0x0111
#define WM_SYSCOMMAND                   0x0112
#define WM_TIMER                        0x0113
#define WM_HSCROLL                      0x0114
#define WM_VSCROLL                      0x0115
#define WM_INITMENU                     0x0116
#define WM_INITMENUPOPUP                0x0117
#define WM_MENUSELECT                   0x011F
#define WM_MENUCHAR                     0x0120
#define WM_ENTERIDLE                    0x0121

/*
 * Virtual Keys, Standard Set
 */
#define VK_LBUTTON        0x01
#define VK_RBUTTON        0x02
#define VK_CANCEL         0x03
#define VK_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */

#if _WIN32_WINNT>=0x0500
#define VK_XBUTTON1       0x05    /* NOT contiguous with L & RBUTTON */
#define VK_XBUTTON2       0x06    /* NOT contiguous with L & RBUTTON */
#endif /* _WIN32_WINNT >= 0x0500 */

/*
 * 0x07 : unassigned
 */

#define VK_BACK           0x08
#define VK_TAB            0x09

/*
 * 0x0A - 0x0B : reserved
 */

#define VK_CLEAR          0x0C
#define VK_RETURN         0x0D

#define VK_SHIFT          0x10
#define VK_CONTROL        0x11
#define VK_MENU           0x12
#define VK_PAUSE          0x13
#define VK_CAPITAL        0x14

#define VK_KANA           0x15
#define VK_HANGEUL        0x15  /* old name - should be here for compatibility */
#define VK_HANGUL         0x15
#define VK_JUNJA          0x17
#define VK_FINAL          0x18
#define VK_HANJA          0x19
#define VK_KANJI          0x19

#define VK_ESCAPE         0x1B

#define VK_CONVERT        0x1C
#define VK_NONCONVERT     0x1D
#define VK_ACCEPT         0x1E
#define VK_MODECHANGE     0x1F

#define VK_SPACE          0x20
#define VK_PRIOR          0x21
#define VK_NEXT           0x22
#define VK_END            0x23
#define VK_HOME           0x24
#define VK_LEFT           0x25
#define VK_UP             0x26
#define VK_RIGHT          0x27
#define VK_DOWN           0x28
#define VK_SELECT         0x29
#define VK_PRINT          0x2A
#define VK_EXECUTE        0x2B
#define VK_SNAPSHOT       0x2C
#define VK_INSERT         0x2D
#define VK_DELETE         0x2E
#define VK_HELP           0x2F


typedef struct tagMSG {
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;
#ifdef _MAC
    DWORD       lPrivate;
#endif
} MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;

typedef
enum tagDVD_DOMAIN
    {	DVD_DOMAIN_FirstPlay	= 1,
	DVD_DOMAIN_VideoManagerMenu	= DVD_DOMAIN_FirstPlay + 1,
	DVD_DOMAIN_VideoTitleSetMenu	= DVD_DOMAIN_VideoManagerMenu + 1,
	DVD_DOMAIN_Title	= DVD_DOMAIN_VideoTitleSetMenu + 1,
	DVD_DOMAIN_Stop	= DVD_DOMAIN_Title + 1
    } 	DVD_DOMAIN;

typedef
enum tagDVD_MENU_ID
    {	DVD_MENU_Title	= 2,
	DVD_MENU_Root	= 3,
	DVD_MENU_Subpicture	= 4,
	DVD_MENU_Audio	= 5,
	DVD_MENU_Angle	= 6,
	DVD_MENU_Chapter	= 7
    } 	DVD_MENU_ID;

typedef
enum tagDVD_DISC_SIDE
    {	DVD_SIDE_A	= 1,
	DVD_SIDE_B	= 2
    } 	DVD_DISC_SIDE;

typedef
enum tagDVD_PREFERRED_DISPLAY_MODE
    {	DISPLAY_CONTENT_DEFAULT	= 0,
	DISPLAY_16x9	= 1,
	DISPLAY_4x3_PANSCAN_PREFERRED	= 2,
	DISPLAY_4x3_LETTERBOX_PREFERRED	= 3
    } 	DVD_PREFERRED_DISPLAY_MODE;

typedef WORD DVD_REGISTER;

typedef DVD_REGISTER GPRMARRAY[ 16 ];

typedef DVD_REGISTER SPRMARRAY[ 24 ];

typedef struct tagDVD_ATR
    {
    ULONG ulCAT;
    BYTE pbATRI[ 768 ];
    } 	DVD_ATR;

typedef BYTE DVD_VideoATR[ 2 ];

typedef BYTE DVD_AudioATR[ 8 ];

typedef BYTE DVD_SubpictureATR[ 6 ];

typedef
enum tagDVD_FRAMERATE
    {	DVD_FPS_25	= 1,
	DVD_FPS_30NonDrop	= 3
    } 	DVD_FRAMERATE;

typedef struct tagDVD_TIMECODE
{
   ULONG Hours1    :4; // Hours
   ULONG Hours10  :4; // Tens of Hours

   ULONG Minutes1  :4; // Minutes
   ULONG Minutes10:4; // Tens of Minutes

   ULONG Seconds1  :4; // Seconds
   ULONG Seconds10:4; // Tens of Seconds

   ULONG Frames1   :4; // Frames
   ULONG Frames10 :2; // Tens of Frames

   ULONG FrameRateCode: 2; // use DVD_FRAMERATE to indicate frames/sec and drop/non-drop
} DVD_TIMECODE;
typedef
enum tagDVD_TIMECODE_FLAGS
    {	DVD_TC_FLAG_25fps	= 0x1,
	DVD_TC_FLAG_30fps	= 0x2,
	DVD_TC_FLAG_DropFrame	= 0x4,
	DVD_TC_FLAG_Interpolated	= 0x8
    } 	DVD_TIMECODE_FLAGS;

typedef struct tagDVD_HMSF_TIMECODE
    {
    BYTE bHours;
    BYTE bMinutes;
    BYTE bSeconds;
    BYTE bFrames;
    } 	DVD_HMSF_TIMECODE;

typedef struct tagDVD_PLAYBACK_LOCATION2
    {
    ULONG TitleNum;
    ULONG ChapterNum;
    DVD_HMSF_TIMECODE TimeCode;
    ULONG TimeCodeFlags;
    } 	DVD_PLAYBACK_LOCATION2;

typedef struct tagDVD_PLAYBACK_LOCATION
    {
    ULONG TitleNum;
    ULONG ChapterNum;
    ULONG TimeCode;
    } 	DVD_PLAYBACK_LOCATION;

typedef DWORD VALID_UOP_SOMTHING_OR_OTHER;

typedef /* [public] */
enum __MIDL___MIDL_itf_strmif_0351_0001
    {	UOP_FLAG_Play_Title_Or_AtTime	= 0x1,
	UOP_FLAG_Play_Chapter	= 0x2,
	UOP_FLAG_Play_Title	= 0x4,
	UOP_FLAG_Stop	= 0x8,
	UOP_FLAG_ReturnFromSubMenu	= 0x10,
	UOP_FLAG_Play_Chapter_Or_AtTime	= 0x20,
	UOP_FLAG_PlayPrev_Or_Replay_Chapter	= 0x40,
	UOP_FLAG_PlayNext_Chapter	= 0x80,
	UOP_FLAG_Play_Forwards	= 0x100,
	UOP_FLAG_Play_Backwards	= 0x200,
	UOP_FLAG_ShowMenu_Title	= 0x400,
	UOP_FLAG_ShowMenu_Root	= 0x800,
	UOP_FLAG_ShowMenu_SubPic	= 0x1000,
	UOP_FLAG_ShowMenu_Audio	= 0x2000,
	UOP_FLAG_ShowMenu_Angle	= 0x4000,
	UOP_FLAG_ShowMenu_Chapter	= 0x8000,
	UOP_FLAG_Resume	= 0x10000,
	UOP_FLAG_Select_Or_Activate_Button	= 0x20000,
	UOP_FLAG_Still_Off	= 0x40000,
	UOP_FLAG_Pause_On	= 0x80000,
	UOP_FLAG_Select_Audio_Stream	= 0x100000,
	UOP_FLAG_Select_SubPic_Stream	= 0x200000,
	UOP_FLAG_Select_Angle	= 0x400000,
	UOP_FLAG_Select_Karaoke_Audio_Presentation_Mode	= 0x800000,
	UOP_FLAG_Select_Video_Mode_Preference	= 0x1000000
    } 	VALID_UOP_FLAG;

typedef /* [public] */
enum __MIDL___MIDL_itf_strmif_0351_0002
    {	DVD_CMD_FLAG_None	= 0,
	DVD_CMD_FLAG_Flush	= 0x1,
	DVD_CMD_FLAG_SendEvents	= 0x2,
	DVD_CMD_FLAG_Block	= 0x4,
	DVD_CMD_FLAG_StartWhenRendered	= 0x8,
	DVD_CMD_FLAG_EndAfterRendered	= 0x10
    } 	DVD_CMD_FLAGS;

typedef /* [public][public] */
enum __MIDL___MIDL_itf_strmif_0351_0003
    {	DVD_ResetOnStop	= 1,
	DVD_NotifyParentalLevelChange	= 2,
	DVD_HMSF_TimeCodeEvents	= 3
    } 	DVD_OPTION_FLAG;

typedef /* [public][public] */
enum __MIDL___MIDL_itf_strmif_0351_0004
    {	DVD_Relative_Upper	= 1,
	DVD_Relative_Lower	= 2,
	DVD_Relative_Left	= 3,
	DVD_Relative_Right	= 4
    } 	DVD_RELATIVE_BUTTON;

typedef
enum tagDVD_PARENTAL_LEVEL
    {	DVD_PARENTAL_LEVEL_8	= 0x8000,
	DVD_PARENTAL_LEVEL_7	= 0x4000,
	DVD_PARENTAL_LEVEL_6	= 0x2000,
	DVD_PARENTAL_LEVEL_5	= 0x1000,
	DVD_PARENTAL_LEVEL_4	= 0x800,
	DVD_PARENTAL_LEVEL_3	= 0x400,
	DVD_PARENTAL_LEVEL_2	= 0x200,
	DVD_PARENTAL_LEVEL_1	= 0x100
    } 	DVD_PARENTAL_LEVEL;

typedef
enum tagDVD_AUDIO_LANG_EXT
    {	DVD_AUD_EXT_NotSpecified	= 0,
	DVD_AUD_EXT_Captions	= 1,
	DVD_AUD_EXT_VisuallyImpaired	= 2,
	DVD_AUD_EXT_DirectorComments1	= 3,
	DVD_AUD_EXT_DirectorComments2	= 4
    } 	DVD_AUDIO_LANG_EXT;

typedef
enum tagDVD_SUBPICTURE_LANG_EXT
    {	DVD_SP_EXT_NotSpecified	= 0,
	DVD_SP_EXT_Caption_Normal	= 1,
	DVD_SP_EXT_Caption_Big	= 2,
	DVD_SP_EXT_Caption_Children	= 3,
	DVD_SP_EXT_CC_Normal	= 5,
	DVD_SP_EXT_CC_Big	= 6,
	DVD_SP_EXT_CC_Children	= 7,
	DVD_SP_EXT_Forced	= 9,
	DVD_SP_EXT_DirectorComments_Normal	= 13,
	DVD_SP_EXT_DirectorComments_Big	= 14,
	DVD_SP_EXT_DirectorComments_Children	= 15
    } 	DVD_SUBPICTURE_LANG_EXT;

typedef
enum tagDVD_AUDIO_APPMODE
    {	DVD_AudioMode_None	= 0,
	DVD_AudioMode_Karaoke	= 1,
	DVD_AudioMode_Surround	= 2,
	DVD_AudioMode_Other	= 3
    } 	DVD_AUDIO_APPMODE;

typedef
enum tagDVD_AUDIO_FORMAT
    {	DVD_AudioFormat_AC3	= 0,
	DVD_AudioFormat_MPEG1	= 1,
	DVD_AudioFormat_MPEG1_DRC	= 2,
	DVD_AudioFormat_MPEG2	= 3,
	DVD_AudioFormat_MPEG2_DRC	= 4,
	DVD_AudioFormat_LPCM	= 5,
	DVD_AudioFormat_DTS	= 6,
	DVD_AudioFormat_SDDS	= 7,
	DVD_AudioFormat_Other	= 8
    } 	DVD_AUDIO_FORMAT;

typedef
enum tagDVD_KARAOKE_DOWNMIX
    {	DVD_Mix_0to0	= 0x1,
	DVD_Mix_1to0	= 0x2,
	DVD_Mix_2to0	= 0x4,
	DVD_Mix_3to0	= 0x8,
	DVD_Mix_4to0	= 0x10,
	DVD_Mix_Lto0	= 0x20,
	DVD_Mix_Rto0	= 0x40,
	DVD_Mix_0to1	= 0x100,
	DVD_Mix_1to1	= 0x200,
	DVD_Mix_2to1	= 0x400,
	DVD_Mix_3to1	= 0x800,
	DVD_Mix_4to1	= 0x1000,
	DVD_Mix_Lto1	= 0x2000,
	DVD_Mix_Rto1	= 0x4000
    } 	DVD_KARAOKE_DOWNMIX;

typedef struct tagDVD_AudioAttributes
    {
    DVD_AUDIO_APPMODE AppMode;
    BYTE AppModeData;
    DVD_AUDIO_FORMAT AudioFormat;
    LCID Language;
    DVD_AUDIO_LANG_EXT LanguageExtension;
    BOOL fHasMultichannelInfo;
    DWORD dwFrequency;
    BYTE bQuantization;
    BYTE bNumberOfChannels;
    DWORD dwReserved[ 2 ];
    } 	DVD_AudioAttributes;

typedef struct tagDVD_MUA_MixingInfo
    {
    BOOL fMixTo0;
    BOOL fMixTo1;
    BOOL fMix0InPhase;
    BOOL fMix1InPhase;
    DWORD dwSpeakerPosition;
    } 	DVD_MUA_MixingInfo;

typedef struct tagDVD_MUA_Coeff
    {
    double log2_alpha;
    double log2_beta;
    } 	DVD_MUA_Coeff;

typedef struct tagDVD_MultichannelAudioAttributes
    {
    DVD_MUA_MixingInfo Info[ 8 ];
    DVD_MUA_Coeff Coeff[ 8 ];
    } 	DVD_MultichannelAudioAttributes;

typedef
enum tagDVD_KARAOKE_CONTENTS
    {	DVD_Karaoke_GuideVocal1	= 0x1,
	DVD_Karaoke_GuideVocal2	= 0x2,
	DVD_Karaoke_GuideMelody1	= 0x4,
	DVD_Karaoke_GuideMelody2	= 0x8,
	DVD_Karaoke_GuideMelodyA	= 0x10,
	DVD_Karaoke_GuideMelodyB	= 0x20,
	DVD_Karaoke_SoundEffectA	= 0x40,
	DVD_Karaoke_SoundEffectB	= 0x80
    } 	DVD_KARAOKE_CONTENTS;

typedef
enum tagDVD_KARAOKE_ASSIGNMENT
    {	DVD_Assignment_reserved0	= 0,
	DVD_Assignment_reserved1	= 1,
	DVD_Assignment_LR	= 2,
	DVD_Assignment_LRM	= 3,
	DVD_Assignment_LR1	= 4,
	DVD_Assignment_LRM1	= 5,
	DVD_Assignment_LR12	= 6,
	DVD_Assignment_LRM12	= 7
    } 	DVD_KARAOKE_ASSIGNMENT;

typedef struct tagDVD_KaraokeAttributes
    {
    BYTE bVersion;
    BOOL fMasterOfCeremoniesInGuideVocal1;
    BOOL fDuet;
    DVD_KARAOKE_ASSIGNMENT ChannelAssignment;
    WORD wChannelContents[ 8 ];
    } 	DVD_KaraokeAttributes;

typedef
enum tagDVD_VIDEO_COMPRESSION
    {	DVD_VideoCompression_Other	= 0,
	DVD_VideoCompression_MPEG1	= 1,
	DVD_VideoCompression_MPEG2	= 2
    } 	DVD_VIDEO_COMPRESSION;

typedef struct tagDVD_VideoAttributes
    {
    BOOL fPanscanPermitted;
    BOOL fLetterboxPermitted;
    ULONG ulAspectX;
    ULONG ulAspectY;
    ULONG ulFrameRate;
    ULONG ulFrameHeight;
    DVD_VIDEO_COMPRESSION Compression;
    BOOL fLine21Field1InGOP;
    BOOL fLine21Field2InGOP;
    ULONG ulSourceResolutionX;
    ULONG ulSourceResolutionY;
    BOOL fIsSourceLetterboxed;
    BOOL fIsFilmMode;
    } 	DVD_VideoAttributes;

typedef
enum tagDVD_SUBPICTURE_TYPE
    {	DVD_SPType_NotSpecified	= 0,
	DVD_SPType_Language	= 1,
	DVD_SPType_Other	= 2
    } 	DVD_SUBPICTURE_TYPE;

typedef
enum tagDVD_SUBPICTURE_CODING
    {	DVD_SPCoding_RunLength	= 0,
	DVD_SPCoding_Extended	= 1,
	DVD_SPCoding_Other	= 2
    } 	DVD_SUBPICTURE_CODING;

typedef struct tagDVD_SubpictureAttributes
    {
    DVD_SUBPICTURE_TYPE Type;
    DVD_SUBPICTURE_CODING CodingMode;
    LCID Language;
    DVD_SUBPICTURE_LANG_EXT LanguageExtension;
    } 	DVD_SubpictureAttributes;

typedef
enum tagDVD_TITLE_APPMODE
    {	DVD_AppMode_Not_Specified	= 0,
	DVD_AppMode_Karaoke	= 1,
	DVD_AppMode_Other	= 3
    } 	DVD_TITLE_APPMODE;

typedef struct tagDVD_TitleMainAttributes
    {
    DVD_TITLE_APPMODE AppMode;
    DVD_VideoAttributes VideoAttributes;
    ULONG ulNumberOfAudioStreams;
    DVD_AudioAttributes AudioAttributes[ 8 ];
    DVD_MultichannelAudioAttributes MultichannelAudioAttributes[ 8 ];
    ULONG ulNumberOfSubpictureStreams;
    DVD_SubpictureAttributes SubpictureAttributes[ 32 ];
    } 	DVD_TitleAttributes;

typedef struct tagDVD_MenuAttributes
    {
    BOOL fCompatibleRegion[ 8 ];
    DVD_VideoAttributes VideoAttributes;
    BOOL fAudioPresent;
    DVD_AudioAttributes AudioAttributes;
    BOOL fSubpicturePresent;
    DVD_SubpictureAttributes SubpictureAttributes;
    } 	DVD_MenuAttributes;


enum PictureDisplayPresentationMode
	{
	PDPM_FULLSIZE,
	PDPM_LETTERBOXED,
	PDPM_PANSCAN,
	PDPM_FULLSIZE16by9
	};


/////////////////////////////////////////////////////////////////////////////
// DVDMediaPlayer
class DVDMediaPlayer
	{
private:
	HWND m_hParentWindow;
	DisplayPresentationMode m_iDisplayMode;
	HINSTANCE		m_appInstance;
	CSize			m_currentRatio;
	CSize			m_newRatio;
	bool			m_bChangeRatio;
	ExtendedPlayerState m_eps;

	BSTR			m_bstrWindowCaption;
	int				m_iWindowLeft, m_iWindowTop, m_iWindowWidth, m_iWindowHeight;
	long			m_lWindowStyle, m_lWindowStyleEx;
	BSTR			m_bstrMediaString;
	BSTR			m_bstrFullMediaString;
	BOOL			m_bFSInitMode;
	BOOL			m_bFullScreenMode;
	RECT			m_rVideoRect;
	ULONG			m_ulCurrentSubpic;
	BOOL			m_bSubPicOn;
	ULONG			m_ulCurrentAudio;
	ULONG			m_ulCurrentAngle;
	WORD			m_wCurrentChapter;
	WORD			m_wCurrentTitle;
	ULONG			m_ulPreferredVideo;
	BOOL			m_bTestMode;
	RECT			m_rWndRect;
	WORD			m_wVPEColorControlFlags;
	WORD			m_wDefPicControls[E_CTL_COUNT];
  	long            m_lCurrentVolume;
	long			m_lMode;
	long			m_lCurrentDisplayMode;
	int	            m_iHasSPDIFSupport;
	BOOL            m_bCheckedForPassthrough;
	DWORD           m_dwCurrentUOPs;
	DVDDiskPlayer	m_ddpThePlayer;
	UnitSet			m_Units;
	VDRHandle		m_hVdrDriver;


	LCID					m_PreferredAudioLanguage;
	DVD_AUDIO_LANG_EXT		m_PreferredAudioExt;
	LCID					m_PreferredSubpicLanguage;
	DVD_SUBPICTURE_LANG_EXT	m_PreferredSubpicExt;




	BOOL			m_bAcceptParentalLevelChange;

	double m_dScanSpeed;       // Speed used during scan (2.0X and greater)
	double m_dPlaySpeed;       // Speed used during playback (Less than 2.0X)
	BOOL   m_bForwardPlayback; // Global so callback function can change its value

public:
	static HWND m_eventWindow;
	static PEVENT_CALLBACK  m_pEventCallback;



	DVDMediaPlayer(HINSTANCE hinst);//{} // HWND to parent window to recieve video, and HINSTANCE to the app.
	virtual ~DVDMediaPlayer(void);//{};
	void Shutdown();//{};
	HRESULT put_ParentWindow(HWND win){return S_OK;};
	BOOL CalcVideoSize(CSize sizeMonitor, CSize& sizeVideo);//{return S_OK;};
	BOOL CalcVideoPos(CSize sizeMonitor, CSize sizeVideo, CPoint& pntVideo);//{return S_OK;};
//	void UpdateDisplay(bool forceUpdate = false, HWND parent = NULL){};
	void UpdateDisplay(bool forceUpdate = false);
//	int PreTranslateMessage(MSG* pMsg){};
	void EventHandlerInstall(HWND EventWnd);
	void EventHandlerInstall(PEVENT_CALLBACK pEventCallback);
	void EventHandlerRemove(void);
//	HRESULT Initialize(HWND parentWin, char driveLetter, char* drivePath = NULL);//{return S_OK;};
	HRESULT Initialize(HWND parentWin, char driveLetter, BYTE region = NULL);//{return S_OK;};
	HRESULT CheckDrive(char driveLetter, char __far* id);//{return S_OK;};
	HRESULT CheckDrive(char* drivePath, char __far* id);//{return S_OK;};
	DVDPlayerMode GetPlayerMode(void);//{return (DVDPlayerMode)S_OK;};
	HRESULT StartPresentation(void);//{return S_OK;};
	DVDDiskType GetDiskType(void);//{return (DVDDiskType)S_OK;};
	HRESULT ForwardScan(short speed);//{return S_OK;};
	HRESULT BackwardScan(short speed);//{return S_OK;};
	HRESULT Get_VideoSize(WORD& x, WORD& y);//{return S_OK;};
	ULONG GetNumberOfTitles(void);//{return S_OK;};
	HRESULT GetExtendedPlayerState(ExtendedPlayerState& eps);//{return S_OK;};
	HRESULT GetAvailStreams(BYTE& af, ULONG& spf);//{return S_OK;};
	HRESULT EnableCC(bool enable);//{return S_OK;};

	HRESULT GetAudioDynRngCompMode(AC3DynamicRange& drm);
	HRESULT SetAudioDynRngCompMode(const AC3DynamicRange& drm);

	HRESULT GetAudioDownmixMode(AC3SpeakerConfig & dmm);
	HRESULT SetAudioDownmixMode(const AC3SpeakerConfig & dmm);

	HRESULT GetAudioDualMode(AC3DualModeConfig& plm);
	HRESULT SetAudioDualMode(const AC3DualModeConfig& plm);

	HRESULT GetAudioSpdifOutMode(SPDIFOutputMode& dmm);
	HRESULT SetAudioSpdifOutMode(const SPDIFOutputMode& dmm);

	HRESULT GetAudioLFEMode(BOOL& lfe);
	HRESULT SetAudioLFEMode(const BOOL& lfe);

	HRESULT GetAudioDialogNormMode(AC3DialogNorm& dn);
	HRESULT SetAudioDialogNormMode(const AC3DialogNorm& dn);

	HRESULT GetAudioCompMode(AC3OperationalMode& opm);
	HRESULT SetAudioCompMode(const AC3OperationalMode& opm);

	HRESULT GetAudioCompSFHigh(WORD& sfh);
	HRESULT SetAudioCompSFHigh(const WORD& sfh);

	HRESULT GetAudioCompSFLow(WORD& sfl);
	HRESULT SetAudioCompSFLow(const WORD& sfl);


	// 0x0000 == surround, 0x0001 == stereo, 0x0002 == mono.
	HRESULT GetSpeakerOutputMode(WORD& config);
	HRESULT SetSpeakerOutputMode(const WORD& config);

	// 0x0000 == PCM, 0x0001 == DTS, 0x0002 == AC3
	HRESULT GetDigitalOutputMode(WORD& config);
	HRESULT SetDigitalOutputMode(const WORD& config);

// interface resembling IDVDControl2
    virtual HRESULT STDMETHODCALLTYPE PlayTitle(
        /* [in] */ ULONG ulTitle);

    virtual HRESULT STDMETHODCALLTYPE PlayChapterInTitle(
        /* [in] */ ULONG ulTitle,
        /* [in] */ ULONG ulChapter);

    virtual HRESULT STDMETHODCALLTYPE PlayAtTimeInTitle(
        /* [in] */ ULONG ulTitle,
        /* [in] */ DVD_HMSF_TIMECODE *pStartTime);

    virtual HRESULT STDMETHODCALLTYPE PlayAtTimeInTitleForced(
        /* [in] */ ULONG ulTitle,
        /* [in] */ DVD_HMSF_TIMECODE *pStartTime);

	virtual HRESULT STDMETHODCALLTYPE Stop( void);

    virtual HRESULT STDMETHODCALLTYPE ReturnFromSubmenu(void);

    virtual HRESULT STDMETHODCALLTYPE PlayAtTime(
        /* [in] */ DVD_HMSF_TIMECODE *pTime);

    virtual HRESULT STDMETHODCALLTYPE PlayChapter(
        /* [in] */ ULONG ulChapter);

    virtual HRESULT STDMETHODCALLTYPE PlayPrevChapter(void);

    virtual HRESULT STDMETHODCALLTYPE ReplayChapter(void);

    virtual HRESULT STDMETHODCALLTYPE PlayNextChapter(void);

    virtual HRESULT STDMETHODCALLTYPE PlayForwards(
        /* [in] */ double dSpeed);

    virtual HRESULT STDMETHODCALLTYPE PlayBackwards(
        /* [in] */ double dSpeed);

    virtual HRESULT STDMETHODCALLTYPE ShowMenu(
        /* [in] */ DVD_MENU_ID MenuID);

    virtual HRESULT STDMETHODCALLTYPE Resume(void);

    virtual HRESULT STDMETHODCALLTYPE SelectRelativeButton(
        DVD_RELATIVE_BUTTON buttonDir);

    virtual HRESULT STDMETHODCALLTYPE ActivateButton( void);

//    virtual HRESULT STDMETHODCALLTYPE SelectButton(
//        /* [in] */ ULONG ulButton){return S_OK;};

    virtual HRESULT STDMETHODCALLTYPE SelectAndActivateButton(
        /* [in] */ ULONG ulButton);

    virtual HRESULT STDMETHODCALLTYPE StillOff( void);

    virtual HRESULT STDMETHODCALLTYPE Pause(
        /* [in] */ BOOL bState);

    virtual HRESULT STDMETHODCALLTYPE SelectAudioStream(
        /* [in] */ ULONG ulAudio);

    virtual HRESULT STDMETHODCALLTYPE SelectSubpictureStream(
        /* [in] */ ULONG ulSubPicture);

    virtual HRESULT STDMETHODCALLTYPE SetSubpictureState(
        /* [in] */ BOOL bState);

    virtual HRESULT STDMETHODCALLTYPE SelectAngle(
        /* [in] */ ULONG ulAngle);

    virtual HRESULT STDMETHODCALLTYPE SelectParentalLevel(
        /* [in] */ ULONG ulParentalLevel);

    virtual HRESULT STDMETHODCALLTYPE SelectParentalCountry(
        /* [in] */ WORD wCountry);

    virtual HRESULT STDMETHODCALLTYPE ActivateAtPosition(
        /* [in] */ POINT point);

    virtual HRESULT STDMETHODCALLTYPE SelectAtPosition(
        /* [in] */ POINT point);

    virtual HRESULT STDMETHODCALLTYPE PlayChaptersAutoStop(
        /* [in] */ ULONG ulTitle,
        /* [in] */ ULONG ulChapter,
        /* [in] */ ULONG ulChaptersToPlay);

    virtual HRESULT STDMETHODCALLTYPE AcceptParentalLevelChange(
        /* [in] */ BOOL bAccept);

    virtual HRESULT STDMETHODCALLTYPE PlayPeriodInTitleAutoStop(
		/* [in] */ ULONG ulTitle,
		/* [in] */ ULONG ulChapter,
	    /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
		/* [in] */ DVD_HMSF_TIMECODE *pEndTime,
		/* [in] */ DWORD flags,
		/* [out]*/ DWORD& breakpointID);

    virtual HRESULT STDMETHODCALLTYPE ClearBreakpoint(
        /* [in] */ DWORD& breakpointID);

    virtual HRESULT STDMETHODCALLTYPE SelectDefaultMenuLanguage(
        /* [in] */ LCID Language);

    virtual HRESULT STDMETHODCALLTYPE SelectDefaultAudioLanguage(
        /* [in] */ LCID Language,
        /* [in] */ DVD_AUDIO_LANG_EXT audioExtension);

    virtual HRESULT STDMETHODCALLTYPE SelectDefaultSubpictureLanguage(
        /* [in] */ LCID Language,
        /* [in] */ DVD_SUBPICTURE_LANG_EXT subpictureExtension);



// interface resembling IDVDInfo2
    virtual HRESULT STDMETHODCALLTYPE GetCurrentDomain(
        /* [out] */ DVD_DOMAIN __RPC_FAR *pDomain);

    virtual HRESULT STDMETHODCALLTYPE GetCurrentLocation(
        /* [out] */ DVD_PLAYBACK_LOCATION2 __RPC_FAR *pLocation);

    virtual HRESULT STDMETHODCALLTYPE GetTotalTitleTime(
        /* [out] */ DVD_HMSF_TIMECODE __RPC_FAR *pTotalTime,
        /* [out] */ ULONG __RPC_FAR *ulTimeCodeFlags,
		/* [in]	 */ ULONG title = NULL);

    virtual HRESULT STDMETHODCALLTYPE GetCurrentButton(
        /* [out] */ ULONG __RPC_FAR *pulButtonsAvailable,
        /* [out] */ ULONG __RPC_FAR *pulCurrentButton);

    virtual HRESULT STDMETHODCALLTYPE GetCurrentAngle(
        /* [out] */ ULONG __RPC_FAR *pulAnglesAvailable,
        /* [out] */ ULONG __RPC_FAR *pulCurrentAngle);

    virtual HRESULT STDMETHODCALLTYPE GetCurrentAudio(
        /* [out] */ ULONG __RPC_FAR *pulStreamsAvailable,
        /* [out] */ ULONG __RPC_FAR *pulCurrentStream);

    virtual HRESULT STDMETHODCALLTYPE GetCurrentSubpicture(
        /* [out] */ ULONG __RPC_FAR *pulStreamsAvailable,
        /* [out] */ ULONG __RPC_FAR *pulCurrentStream,
        /* [out] */ BOOL __RPC_FAR *pbIsDisabled);

    virtual HRESULT STDMETHODCALLTYPE GetCurrentUOPS(
        /* [out] */ ULONG __RPC_FAR *pulUOPs);

    virtual HRESULT STDMETHODCALLTYPE GetAllSPRMs(
        /* [out] */ SPRMARRAY __RPC_FAR *pRegisterArray);

    virtual HRESULT STDMETHODCALLTYPE GetAllGPRMs(
        /* [out] */ GPRMARRAY __RPC_FAR *pRegisterArray);

    virtual HRESULT STDMETHODCALLTYPE GetAudioLanguage(
        /* [in] */ ULONG ulStream,
        /* [out] */ LCID __RPC_FAR *pLanguage);

    virtual HRESULT STDMETHODCALLTYPE GetAudioLanguage(
        /* [in] */ ULONG ulStream,
        /* [out] */ char* pLanguage, UINT nMaxLength);

    virtual HRESULT STDMETHODCALLTYPE GetSubpictureLanguage(
        /* [in] */ ULONG ulStream,
        /* [out] */ LCID __RPC_FAR *pLanguage);

    virtual HRESULT STDMETHODCALLTYPE GetSubpictureLanguage(
        /* [in] */ ULONG ulStream,
        /* [out] */ char* pLanguage, UINT nMaxLength);

    virtual HRESULT STDMETHODCALLTYPE GetTitleAttributes(
        /* [in] */ ULONG ulTitle,
        /* [out] */ DVD_ATR __RPC_FAR *pATR);

    virtual HRESULT STDMETHODCALLTYPE GetVMGAttributes(
        /* [out] */ DVD_ATR __RPC_FAR *pATR);

    virtual HRESULT STDMETHODCALLTYPE GetCurrentVideoAttributes(
        /* [out] */ DVD_VideoATR __RPC_FAR *pATR);

    virtual HRESULT STDMETHODCALLTYPE GetVideoAttributes(
        /* [in] */ ULONG ulTitle,
        /* [in] */ BOOL bForMenus,
        /* [out] */ DVD_VideoATR __RPC_FAR *pATR);

    virtual HRESULT STDMETHODCALLTYPE GetAudioAttributes(
        /* [in] */ ULONG ulStream,
        /* [out] */ DVD_AudioAttributes __RPC_FAR *pATR);

    virtual HRESULT STDMETHODCALLTYPE GetKaraokeAttributes(
        /* [in] */ ULONG ulStream,
        /* [out] */ DVD_KaraokeAttributes __RPC_FAR *pAttributes);

    virtual HRESULT STDMETHODCALLTYPE GetSubpictureAttributes(
        /* [in] */ ULONG ulStream,
        /* [out] */ DVD_SubpictureATR __RPC_FAR *pATR);

    virtual HRESULT STDMETHODCALLTYPE GetDVDVolumeInfo(
        /* [out] */ ULONG __RPC_FAR *pulNumOfVolumes,
        /* [out] */ ULONG __RPC_FAR *pulVolume,
        /* [out] */ DVD_DISC_SIDE __RPC_FAR *pSide,
        /* [out] */ ULONG __RPC_FAR *pulNumOfTitles);

    virtual HRESULT STDMETHODCALLTYPE GetDVDTextNumberOfLanguages(
        /* [out] */ ULONG __RPC_FAR *pulNumOfLangs);

    virtual HRESULT STDMETHODCALLTYPE GetDVDTextLanguageInfo(
        /* [in] */ ULONG ulLangIndex,
        /* [out] */ ULONG __RPC_FAR *pulNumOfStrings,
        /* [out] */ LCID __RPC_FAR *pLangCode,
        /* [out] */ enum DVD_TextCharSet __RPC_FAR *pbCharacterSet);

    virtual HRESULT STDMETHODCALLTYPE GetDVDTextStringAsNative(
        /* [in] */ ULONG ulLangIndex,
        /* [in] */ ULONG ulStringIndex,
        /* [out] */ BYTE __RPC_FAR *pbBuffer,
        /* [in] */ ULONG ulMaxBufferSize,
        /* [out] */ ULONG __RPC_FAR *pulActualSize,
        /* [out] */ enum DVD_TextStringType __RPC_FAR *pType);

    virtual HRESULT STDMETHODCALLTYPE GetDVDTextStringAsUnicode(
        /* [in] */ ULONG ulLangIndex,
        /* [in] */ ULONG ulStringIndex,
        /* [out] */ WCHAR __RPC_FAR *pchwBuffer,
        /* [in] */ ULONG ulMaxBufferSize,
        /* [out] */ ULONG __RPC_FAR *pulActualSize,
        /* [out] */ enum DVD_TextStringType __RPC_FAR *pType);

    virtual HRESULT STDMETHODCALLTYPE GetPlayerParentalLevel(
        /* [out] */ ULONG __RPC_FAR *pulParentalLevel,
        /* [out] */ WORD __RPC_FAR *pCountryCode);

    virtual HRESULT STDMETHODCALLTYPE GetNumberOfChapters(
        /* [in] */ ULONG ulTitle,
        /* [out] */ ULONG __RPC_FAR *pulNumOfChapters);

    virtual HRESULT STDMETHODCALLTYPE GetTitleParentalLevels(
        /* [in] */ ULONG ulTitle,
        /* [out] */ ULONG __RPC_FAR *pulParentalLevels);

    virtual HRESULT STDMETHODCALLTYPE GetDVDDirectory(
        /* [size_is][out] */ LPWSTR pszwPath,
        /* [in] */ ULONG cbMaxSize,
        /* [out] */ ULONG __RPC_FAR *pcbActualSize);

    virtual HRESULT STDMETHODCALLTYPE IsAudioStreamEnabled(
        /* [in] */ ULONG ulStreamNum,
        /* [out] */ BOOL __RPC_FAR *pbEnabled);

    virtual HRESULT STDMETHODCALLTYPE GetUniqueID(
        /* [in] */ LPCWSTR pszwPath,
        /* [out] */ ULONGLONG __RPC_FAR *pullUniqueID);

    virtual HRESULT STDMETHODCALLTYPE GetMenuLanguages(
        /* [out] */ LCID __RPC_FAR *pLanguages,
        /* [in] */ ULONG uMaxLanguages,
        /* [out] */ ULONG __RPC_FAR *puActualLanguages);

    virtual HRESULT STDMETHODCALLTYPE GetButtonAtPosition(
        /* [in] */ POINT point,
        /* [out] */ ULONG __RPC_FAR *puButtonIndex);

    virtual HRESULT STDMETHODCALLTYPE GetDefaultMenuLanguage(
        /* [out] */ LCID __RPC_FAR *pLanguage);

    virtual HRESULT STDMETHODCALLTYPE GetDefaultAudioLanguage(
        /* [out] */ LCID __RPC_FAR *pLanguage,
        /* [out] */ DVD_AUDIO_LANG_EXT __RPC_FAR *pAudioExtension);

    virtual HRESULT STDMETHODCALLTYPE GetDefaultSubpictureLanguage(
        /* [out] */ LCID __RPC_FAR *pLanguage,
        /* [out] */ DVD_SUBPICTURE_LANG_EXT __RPC_FAR *pSubpictureExtension);

	HRESULT NextChapter ();
	HRESULT PreviousChapter ();
	HRESULT NextTitle();
	HRESULT PreviousTitle();
	HRESULT put_WindowPosition(INT iLeft, INT iTop, INT iWidth, INT iHeight){return S_OK;};
//	HRESULT get_MessageWindow(LONG* plVal){return S_OK;};
	HRESULT put_MessageWindow(LONG pVal){return S_OK;};
	HRESULT get_FullScreenMode(BOOL* pbVal){return S_OK;};
	HRESULT put_FullScreenMode(BOOL lVal){return S_OK;};


	HRESULT ShowMenu (LONG lMenu);
	bool IsPlaying();
	HRESULT Play();
	HRESULT Pause();
	HRESULT TimeSearch(INT iHour, INT iMin, INT iSec);
	HRESULT ConvertError( ULONG ulErr );
	HRESULT Get_AspectRatios( ULONG& xFactor, ULONG& yFactor );//{return S_OK;};
	DisplayPresentationMode GetDisplayMode(void);
	HRESULT SetDisplayMode( DisplayPresentationMode mode );//{return S_OK;};
	HRESULT Set_AspectRatios( ULONG& xFactor, ULONG& yFactor );//{return S_OK;};
	HRESULT SetSystemRegion(char driveLetter, BYTE regMask);
	HRESULT GetSystemRegion(char driveLetter, BYTE &regMask);

	HRESULT put_Volume(LONG lVal);
	HRESULT get_Volume(LONG* plVal);

	HRESULT EnableScanAudio(bool bEnable);
	HRESULT GetColorkeyStatus(BOOL &bEnabled);
	HRESULT SetColorkey(DWORD dwColorkey);
	HRESULT SetDestinationRect(INT leftX, INT topY, INT width, INT height);
	HRESULT SetOutputRect(INT leftX, INT topY, INT width, INT height);

	HRESULT Trick_FrameForward();
	HRESULT Trick_FrameBackward();
	HRESULT Trick_ReversePlay(WORD wSpeed = C_NORMAL_PLAYBACK_SPEED);
	HRESULT Trick_Zoom(INT leftX, INT topY, INT width, INT height);
	HRESULT Trick_Zoom(INT leftX, INT topY, float scaleFactor);
	HRESULT Freeze(BYTE*& ppFreezeBuffer, DWORD& dwBufferSize);
	HRESULT Defrost(BYTE* pFreezeBuffer, DWORD dwBufferSize);

	HRESULT Get_CurrentScaleFactor(float& cSF);
    friend void WINAPI DDPCaptureEvent(DWORD dwEvent, VOID* pvBuffer, DWORD dwInfo);


};


typedef DVDMediaPlayer			CQVDRDVDMediaPlayer;


enum parental_level
{
	E_PARENTAL_GENERAL=1,
		E_PARENTAL_RESERVED1,
		E_PARENTAL_PG,
		E_PARENTAL_PG13,
		E_PARENTAL_RESERVED2,
		E_PARENTAL_R,
		E_PARENTAL_NC17,
		E_PARENTAL_RESTRICTED,
		E_PARENTAL_DISABLED=0xFFFFFFFF
};

struct LanguageData
	{
	WORD    code;
	BYTE    langID;
	};

const LanguageData LANGUAGE_DATA[] =
	{
	{ 0, LANG_NEUTRAL },
	{ (WORD)'a' << 8 | (BYTE)'f', LANG_AFRIKAANS },
	{ (WORD)'a' << 8 | (BYTE)'r', LANG_ARABIC },
	{ (WORD)'b' << 8 | (BYTE)'g', LANG_BULGARIAN },
	{ (WORD)'c' << 8 | (BYTE)'a', LANG_CATALAN },
	{ (WORD)'c' << 8 | (BYTE)'s', LANG_CZECH },
	{ (WORD)'d' << 8 | (BYTE)'a', LANG_DANISH },
	{ (WORD)'d' << 8 | (BYTE)'e', LANG_GERMAN },
	{ (WORD)'e' << 8 | (BYTE)'l', LANG_GREEK },
	{ (WORD)'e' << 8 | (BYTE)'n', LANG_ENGLISH },
	{ (WORD)'e' << 8 | (BYTE)'s', LANG_SPANISH },
	{ (WORD)'e' << 8 | (BYTE)'t', LANG_ESTONIAN },
	{ (WORD)'e' << 8 | (BYTE)'u', LANG_BASQUE },
	{ (WORD)'f' << 8 | (BYTE)'i', LANG_FINNISH },
	{ (WORD)'f' << 8 | (BYTE)'o', LANG_FAEROESE },
	{ (WORD)'f' << 8 | (BYTE)'r', LANG_FRENCH },
	{ (WORD)'h' << 8 | (BYTE)'r', LANG_CROATIAN },
	{ (WORD)'h' << 8 | (BYTE)'u', LANG_HUNGARIAN },
	{ (WORD)'i' << 8 | (BYTE)'n', LANG_INDONESIAN },
	{ (WORD)'i' << 8 | (BYTE)'s', LANG_ICELANDIC },
	{ (WORD)'i' << 8 | (BYTE)'t', LANG_ITALIAN },
	{ (WORD)'i' << 8 | (BYTE)'w', LANG_HEBREW },
	{ (WORD)'j' << 8 | (BYTE)'a', LANG_JAPANESE },
	{ (WORD)'k' << 8 | (BYTE)'o', LANG_KOREAN },
	{ (WORD)'l' << 8 | (BYTE)'r', LANG_LITHUANIAN },
	{ (WORD)'l' << 8 | (BYTE)'v', LANG_LATVIAN /*_LETTISH*/ },
	{ (WORD)'n' << 8 | (BYTE)'l', LANG_DUTCH },
	{ (WORD)'n' << 8 | (BYTE)'o', LANG_NORWEGIAN },
	{ (WORD)'p' << 8 | (BYTE)'l', LANG_POLISH },
	{ (WORD)'p' << 8 | (BYTE)'t', LANG_PORTUGUESE },
	{ (WORD)'r' << 8 | (BYTE)'m', 0x17 /*IDS_RHAETO_ROMANCE*/ },
	{ (WORD)'r' << 8 | (BYTE)'o', LANG_ROMANIAN },
	{ (WORD)'r' << 8 | (BYTE)'u', LANG_RUSSIAN },
	{ (WORD)'s' << 8 | (BYTE)'h', LANG_SERBIAN },
	{ (WORD)'s' << 8 | (BYTE)'k', LANG_SLOVAK },
	{ (WORD)'s' << 8 | (BYTE)'l', LANG_SLOVENIAN },
	{ (WORD)'s' << 8 | (BYTE)'q', LANG_ALBANIAN },
	{ (WORD)'s' << 8 | (BYTE)'r', LANG_SERBIAN },
	{ (WORD)'s' << 8 | (BYTE)'v', LANG_SWEDISH },
	{ (WORD)'t' << 8 | (BYTE)'h', LANG_THAI },
	{ (WORD)'t' << 8 | (BYTE)'r', LANG_TURKISH },
	{ (WORD)'u' << 8 | (BYTE)'k', LANG_UKRAINIAN },
	{ (WORD)'u' << 8 | (BYTE)'r', 0x20 /*IDS_URDU*/ },
	{ (WORD)'v' << 8 | (BYTE)'i', LANG_VIETNAMESE },
	{ (WORD)'z' << 8 | (BYTE)'h', LANG_CHINESE },
	{ (WORD)'b' << 8 | (BYTE)'e', LANG_BELARUSIAN /*IDS_BYELORUSSIAN*/ },
	{ (WORD)'f' << 8 | (BYTE)'a', LANG_FARSI /*IDS_PERSIAN*/ },
	//{ (WORD)'a' << 8 | (BYTE)'a', IDS_AFAR },
	//{ (WORD)'a' << 8 | (BYTE)'b', IDS_ABKHAZIAN },
	//{ (WORD)'a' << 8 | (BYTE)'m', IDS_AMEHARIC },
	//{ (WORD)'a' << 8 | (BYTE)'s', IDS_ASSAMESE },
	//{ (WORD)'a' << 8 | (BYTE)'y', IDS_AYMARA },
	//{ (WORD)'a' << 8 | (BYTE)'z', IDS_AZERBAIJANI },
	//{ (WORD)'b' << 8 | (BYTE)'a', IDS_BASHKIR },
	//{ (WORD)'b' << 8 | (BYTE)'h', IDS_BIHARI },
	//{ (WORD)'b' << 8 | (BYTE)'i', IDS_BISLAMA },
	//{ (WORD)'b' << 8 | (BYTE)'n', IDS_BENGALI },
	//{ (WORD)'b' << 8 | (BYTE)'o', IDS_TIBETAN },
	//{ (WORD)'b' << 8 | (BYTE)'r', IDS_BRETON },
	//{ (WORD)'c' << 8 | (BYTE)'o', IDS_CORSICAN },
	//{ (WORD)'c' << 8 | (BYTE)'y', IDS_WELSH },
	//{ (WORD)'d' << 8 | (BYTE)'z', IDS_BHUTANI },
	//{ (WORD)'e' << 8 | (BYTE)'o', IDS_ESPERANTO },
	//{ (WORD)'f' << 8 | (BYTE)'j', IDS_FIJI },
	//{ (WORD)'f' << 8 | (BYTE)'y', IDS_FRISIAN },
	//{ (WORD)'g' << 8 | (BYTE)'a', IDS_IRISH },
	//{ (WORD)'g' << 8 | (BYTE)'d', IDS_SCOTS_GAELIC },
	//{ (WORD)'g' << 8 | (BYTE)'l', IDS_GALIZIAN },
	//{ (WORD)'g' << 8 | (BYTE)'n', IDS_GUARANI },
	//{ (WORD)'g' << 8 | (BYTE)'u', IDS_GUJARATI },
	//{ (WORD)'h' << 8 | (BYTE)'a', IDS_HAUSA },
	//{ (WORD)'h' << 8 | (BYTE)'i', IDS_HINDI },
	//{ (WORD)'h' << 8 | (BYTE)'y', IDS_ARMENIAN },
	//{ (WORD)'i' << 8 | (BYTE)'a', IDS_INTERLINGUA },
	//{ (WORD)'i' << 8 | (BYTE)'e', IDS_INTERLINQUE },
	//{ (WORD)'i' << 8 | (BYTE)'k', IDS_INUPIAK },
	//{ (WORD)'j' << 8 | (BYTE)'i', IDS_YIDDISH },
	//{ (WORD)'j' << 8 | (BYTE)'w', IDS_JAVANESE },
	//{ (WORD)'k' << 8 | (BYTE)'a', IDS_GEORGIAN },
	//{ (WORD)'k' << 8 | (BYTE)'k', IDS_KAZAHK },
	//{ (WORD)'k' << 8 | (BYTE)'l', IDS_GREENLANDIC },
	//{ (WORD)'k' << 8 | (BYTE)'m', IDS_CAMBODIAN },
	//{ (WORD)'k' << 8 | (BYTE)'n', IDS_KANNADA },
	//{ (WORD)'k' << 8 | (BYTE)'s', IDS_KASHMIRI },
	//{ (WORD)'k' << 8 | (BYTE)'u', IDS_KURDISH },
	//{ (WORD)'k' << 8 | (BYTE)'y', IDS_KIRGHIZ },
	//{ (WORD)'l' << 8 | (BYTE)'a', IDS_LATIN },
	//{ (WORD)'l' << 8 | (BYTE)'n', IDS_LINGALA },
	//{ (WORD)'l' << 8 | (BYTE)'o', IDS_LAOTHIAN },
	//{ (WORD)'m' << 8 | (BYTE)'g', IDS_MALAGASY },
	//{ (WORD)'m' << 8 | (BYTE)'i', IDS_MAORI },
	//{ (WORD)'m' << 8 | (BYTE)'k', IDS_MACEDONIAN },
	//{ (WORD)'m' << 8 | (BYTE)'l', IDS_MALAYALAM },
	//{ (WORD)'m' << 8 | (BYTE)'n', IDS_MONGOLIAN },
	//{ (WORD)'m' << 8 | (BYTE)'o', IDS_MOLDAVIAN },
	//{ (WORD)'m' << 8 | (BYTE)'r', IDS_MARATHI },
	//{ (WORD)'m' << 8 | (BYTE)'s', IDS_MALAY },
	//{ (WORD)'m' << 8 | (BYTE)'t', IDS_MALTESE },
	//{ (WORD)'m' << 8 | (BYTE)'y', IDS_BURMESE },
	//{ (WORD)'n' << 8 | (BYTE)'a', IDS_NAURU },
	//{ (WORD)'n' << 8 | (BYTE)'e', IDS_NEPALI },
	//{ (WORD)'o' << 8 | (BYTE)'c', IDS_OCCITAN },
	//{ (WORD)'o' << 8 | (BYTE)'m', IDS_AFAN_OROMO },
	//{ (WORD)'o' << 8 | (BYTE)'r', IDS_ORIYA },
	//{ (WORD)'p' << 8 | (BYTE)'a', IDS_PANJABI },
	//{ (WORD)'p' << 8 | (BYTE)'s', IDS_PASHTO_PUSHTO },
	//{ (WORD)'q' << 8 | (BYTE)'u', IDS_QUECHUA },
	//{ (WORD)'r' << 8 | (BYTE)'n', IDS_KIRUNDI },
	//{ (WORD)'r' << 8 | (BYTE)'w', IDS_KINYARWANDA },
	//{ (WORD)'s' << 8 | (BYTE)'a', IDS_SANSKRIT },
	//{ (WORD)'s' << 8 | (BYTE)'d', IDS_SINDHI },
	//{ (WORD)'s' << 8 | (BYTE)'g', IDS_SANGHO },
	//{ (WORD)'s' << 8 | (BYTE)'i', IDS_SINGHALESE },
	//{ (WORD)'s' << 8 | (BYTE)'m', IDS_SAMOAN },
	//{ (WORD)'s' << 8 | (BYTE)'n', IDS_SHONA },
	//{ (WORD)'s' << 8 | (BYTE)'o', IDS_SOMALI },
	//{ (WORD)'s' << 8 | (BYTE)'s', IDS_SISWATI },
	//{ (WORD)'s' << 8 | (BYTE)'t', IDS_SESOTHO },
	//{ (WORD)'s' << 8 | (BYTE)'u', IDS_SUDANESE },
	//{ (WORD)'s' << 8 | (BYTE)'w', IDS_SWAHILI },
	//{ (WORD)'t' << 8 | (BYTE)'a', IDS_TAMIL },
	//{ (WORD)'t' << 8 | (BYTE)'e', IDS_TELUGU },
	//{ (WORD)'t' << 8 | (BYTE)'g', IDS_TAJIK },
	//{ (WORD)'t' << 8 | (BYTE)'i', IDS_TIGRINYA },
	//{ (WORD)'t' << 8 | (BYTE)'k', IDS_TURKMEN },
	//{ (WORD)'t' << 8 | (BYTE)'l', IDS_TAGALOG },
	//{ (WORD)'t' << 8 | (BYTE)'n', IDS_SETSWANA },
	//{ (WORD)'t' << 8 | (BYTE)'o', IDS_TONGA },
	//{ (WORD)'t' << 8 | (BYTE)'s', IDS_TSONGA },
	//{ (WORD)'t' << 8 | (BYTE)'t', IDS_TATAR },
	//{ (WORD)'t' << 8 | (BYTE)'w', IDS_TWI },
	//{ (WORD)'u' << 8 | (BYTE)'z', IDS_UZBEK },
	//{ (WORD)'v' << 8 | (BYTE)'o', IDS_VOLAPUK },
	//{ (WORD)'w' << 8 | (BYTE)'o', IDS_WOLOF },
	//{ (WORD)'x' << 8 | (BYTE)'h', IDS_XHOSA },
	//{ (WORD)'y' << 8 | (BYTE)'o', IDS_YORUBA },
	//{ (WORD)'z' << 8 | (BYTE)'u', IDS_ZULU }
	};


#endif //AFX_DVDMEDIAPLAYER_H__DD1FA08A_135D_11D3_810A_00A0CC23CB74__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\PadInput.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#ifndef __PADMAP_H__
#define __PADMAP_H__

#include <xbInput.h>


// all the different possibilities of gamepad input that we support
enum
{
	XB_NO_INPUT,
	XB_X_BUTTON,
	XB_Y_BUTTON,
	XB_A_BUTTON,
	XB_B_BUTTON,
	XB_BLACK_BUTTON,
	XB_WHITE_BUTTON,
	XB_LEFT_TRIGGER_BUTTON,
	XB_RIGHT_TRIGGER_BUTTON,
	XB_SHIFT_X_BUTTON,
	XB_SHIFT_Y_BUTTON,
	XB_SHIFT_A_BUTTON,
	XB_SHIFT_B_BUTTON,
	XB_SHIFT_BLACK_BUTTON,
	XB_SHIFT_WHITE_BUTTON,
	XB_SHIFT_LEFT_TRIGGER_BUTTON,
	XB_SHIFT_RIGHT_TRIGGER_BUTTON,
	XB_SHIFT_START,
	XB_SHIFT_BACK,
	XB_DPAD_UP,
	XB_DPAD_DOWN,
	XB_DPAD_LEFT,
	XB_DPAD_RIGHT,
	XB_START,
	XB_BACK,
	XB_LTHUMB,
	XB_RTHUMB,
	XB_SHIFT_DPAD_UP,
	XB_SHIFT_DPAD_DOWN,
	XB_SHIFT_DPAD_LEFT,
	XB_SHIFT_DPAD_RIGHT
};


// XBGAMEPAD.wPressedButtons is a newly pressed button. For held buttons we need to check
// XBGAMEPAD.wLastButtons.  THH




// macros to make it easy to see what input has occured
#define HITTEST_XB_DPAD_UP(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wPressedButtons & XINPUT_GAMEPAD_DPAD_UP) > 0 ? TRUE : FALSE )

#define HITTEST_XB_DPAD_DOWN(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN) > 0 ? TRUE : FALSE )

#define HITTEST_XB_DPAD_LEFT(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT) > 0 ? TRUE : FALSE )

#define HITTEST_XB_DPAD_RIGHT(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT) > 0 ? TRUE : FALSE )

#define HITTEST_XB_START(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wPressedButtons & XINPUT_GAMEPAD_START ) > 0 ? TRUE : FALSE )

#define HITTEST_XB_BACK(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wPressedButtons & XINPUT_GAMEPAD_BACK ) > 0 ? TRUE : FALSE )

#define HITTEST_XB_LTHUMB(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wPressedButtons & XINPUT_GAMEPAD_LEFT_THUMB ) > 0 ? TRUE : FALSE )

#define HITTEST_XB_RTHUMB(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wPressedButtons & XINPUT_GAMEPAD_RIGHT_THUMB ) > 0 ? TRUE : FALSE )

// test for held thumb (shift to us)
#define HOLDTEST_XB_LTHUMB(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wLastButtons & XINPUT_GAMEPAD_LEFT_THUMB ) > 0 ? TRUE : FALSE )

#define HOLDTEST_XB_RTHUMB(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wLastButtons & XINPUT_GAMEPAD_RIGHT_THUMB ) > 0 ? TRUE : FALSE )

#define HITTEST_XB_A(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->bPressedAnalogButtons[XINPUT_GAMEPAD_A] ) > 0 ? TRUE : FALSE )

#define HITTEST_XB_B(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->bPressedAnalogButtons[XINPUT_GAMEPAD_B] ) > 0 ? TRUE : FALSE )

#define HITTEST_XB_X(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->bPressedAnalogButtons[XINPUT_GAMEPAD_X] ) > 0 ? TRUE : FALSE )

#define HITTEST_XB_Y(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->bPressedAnalogButtons[XINPUT_GAMEPAD_Y] ) > 0 ? TRUE : FALSE )

#define HITTEST_XB_BLACK(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] ) > 0 ? TRUE : FALSE )

#define HITTEST_XB_WHITE(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] ) > 0 ? TRUE : FALSE )

#define HITTEST_XB_LEFT_TRIGGER(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->bPressedAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] ) > 0 ? TRUE : FALSE )

#define HITTEST_XB_RIGHT_TRIGGER(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->bPressedAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] ) > 0 ? TRUE : FALSE )

#define HITTEST_XB_SHIFT_X(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_X(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_Y(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_Y(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_A(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_A(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_B(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_B(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_BLACK(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_BLACK(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_WHITE(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_WHITE(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_LEFT_TRIGGER(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_LEFT_TRIGGER(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_RIGHT_TRIGGER(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_RIGHT_TRIGGER(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_START(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_START(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_BACK(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_BACK(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_DPAD_LEFT(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_DPAD_LEFT(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_DPAD_RIGHT(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_DPAD_RIGHT(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_DPAD_UP(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_DPAD_UP(pgamepad)) ? TRUE : FALSE)

#define HITTEST_XB_SHIFT_DPAD_DOWN(pgamepad)  \
	((HOLDTEST_XB_LTHUMB(pgamepad) && HITTEST_XB_DPAD_DOWN(pgamepad)) ? TRUE : FALSE)


// test for held dpad
#define HOLDTEST_XB_DPAD_LEFT(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wLastButtons & XINPUT_GAMEPAD_DPAD_LEFT ) > 0 ? TRUE : FALSE )

#define HOLDTEST_XB_DPAD_RIGHT(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wLastButtons & XINPUT_GAMEPAD_DPAD_RIGHT ) > 0 ? TRUE : FALSE )

#define HOLDTEST_XB_DPAD_UP(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wLastButtons & XINPUT_GAMEPAD_DPAD_UP ) > 0 ? TRUE : FALSE )

#define HOLDTEST_XB_DPAD_DOWN(pgamepad)  \
	((((XBGAMEPAD*) pgamepad)->wLastButtons & XINPUT_GAMEPAD_DPAD_DOWN ) > 0 ? TRUE : FALSE )





inline DWORD GET_INPUT_ACTION(XBGAMEPAD* pgamepad)
{
	// check for shift first
	if (HITTEST_XB_SHIFT_X(pgamepad))
		return XB_SHIFT_X_BUTTON;
	if (HITTEST_XB_SHIFT_Y(pgamepad))
		return XB_SHIFT_Y_BUTTON;
	if (HITTEST_XB_SHIFT_A(pgamepad))
		return XB_SHIFT_A_BUTTON;
	if (HITTEST_XB_SHIFT_B(pgamepad))
		return XB_SHIFT_B_BUTTON;
	if (HITTEST_XB_SHIFT_BLACK(pgamepad))
		return XB_SHIFT_BLACK_BUTTON;
	if (HITTEST_XB_SHIFT_WHITE(pgamepad))
		return XB_SHIFT_WHITE_BUTTON;
	if (HITTEST_XB_SHIFT_LEFT_TRIGGER(pgamepad))
		return XB_SHIFT_LEFT_TRIGGER_BUTTON;
	if (HITTEST_XB_SHIFT_RIGHT_TRIGGER(pgamepad))
		return XB_SHIFT_RIGHT_TRIGGER_BUTTON;
	if (HITTEST_XB_SHIFT_START(pgamepad))
		return XB_SHIFT_START;
	if (HITTEST_XB_SHIFT_BACK(pgamepad))
		return XB_SHIFT_BACK;
	if (HITTEST_XB_SHIFT_DPAD_LEFT(pgamepad))
		return XB_SHIFT_DPAD_LEFT;
	if (HITTEST_XB_SHIFT_DPAD_RIGHT(pgamepad))
		return XB_SHIFT_DPAD_RIGHT;
	if (HITTEST_XB_SHIFT_DPAD_UP(pgamepad))
		return XB_SHIFT_DPAD_UP;
	if (HITTEST_XB_SHIFT_DPAD_DOWN(pgamepad))
		return XB_SHIFT_DPAD_DOWN;

	// no shift

//	// check for held pad buttons
//	if (HOLDTEST_XB_DPAD_LEFT(pgamepad))
//		return XB_DPAD_LEFT;
//	if (HOLDTEST_XB_DPAD_RIGHT(pgamepad))
//		return XB_DPAD_RIGHT;
//	if (HOLDTEST_XB_DPAD_UP(pgamepad))
//		return XB_DPAD_UP;
//	if (HOLDTEST_XB_DPAD_DOWN(pgamepad))
//		return XB_DPAD_DOWN;

	if (HITTEST_XB_X(pgamepad))
		return XB_X_BUTTON;
	if (HITTEST_XB_Y(pgamepad))
		return XB_Y_BUTTON;
	if (HITTEST_XB_A(pgamepad))
		return XB_A_BUTTON;
	if (HITTEST_XB_B(pgamepad))
		return XB_B_BUTTON;
	if (HITTEST_XB_BLACK(pgamepad))
		return XB_BLACK_BUTTON;
	if (HITTEST_XB_WHITE(pgamepad))
		return XB_WHITE_BUTTON;
	if (HITTEST_XB_LEFT_TRIGGER(pgamepad))
		return XB_LEFT_TRIGGER_BUTTON;
	if (HITTEST_XB_RIGHT_TRIGGER(pgamepad))
		return XB_RIGHT_TRIGGER_BUTTON;

	// check digital inputs
	if (HITTEST_XB_DPAD_UP(pgamepad))
		return XB_DPAD_UP;
	if (HITTEST_XB_DPAD_DOWN(pgamepad))
		return XB_DPAD_DOWN;
	if (HITTEST_XB_DPAD_LEFT(pgamepad))
		return XB_DPAD_LEFT;
	if (HITTEST_XB_DPAD_RIGHT(pgamepad))
		return XB_DPAD_RIGHT;
	if (HITTEST_XB_START(pgamepad))
		return XB_START;
	if (HITTEST_XB_BACK(pgamepad))
		return XB_BACK;
	if (HITTEST_XB_RTHUMB(pgamepad))
		return XB_RTHUMB;
	if (HITTEST_XB_LTHUMB(pgamepad))
		return XB_LTHUMB;

	return XB_NO_INPUT;
}

#endif	// #ifndef __PADMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\RavDvd.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// RavDvd.cpp : Defines the class behaviors for the application.
//

#include <XBApp.h>
//#include <XBFile.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include <XMenu.h>
#include "XBSplash.h"
#include "RavDvd.h"
#include "DVDMediaPlayer.h"
#include "PadInput.h"
#include "xbDVDStrings.h"
#include "XBRavMenu.h"
#include "QError.h"
#include "XBTga.h"

#define		STRESS_TEST_RANDOM_SEEK		0


void  WINAPI DVDEventHandler(DWORD dwEvent, DWORD dwInfo);


//#define ENABLE_DOLBY_SETTINGS	1
//#define DOLBY_TEST_MODE			1

//#define ENABLE_DMM_SETTINGS		0
//#define ENABLE_DTS_SETTINGS		0

#define AV_FLAGS_WIDESCREEN	0x00010000
#define AV_FLAGS_LETTERBOX	0x00100000

#define AV_ASPECT_RATIO_MASK	(AV_FLAGS_WIDESCREEN | AV_FLAGS_LETTERBOX)


#define VOL_INCREMENT	G_C_MAX_VOLUME/25
//#define RAV_COLORKEY	D3DCOLOR_XRGB(0xFF, 0x80, 0xd0)

CRavDvdApp* g_theApp;

// vertical blank callback
void __cdecl VBlankCallback(D3DVBLANKDATA *pData);
DWORD g_dwVBCount = 0;

bool g_fSettingsMenuActive = false;
bool g_fScaledDestination = false;

DWORD SubpicMenuProc(DWORD cmd, XMenuItem *it);
DWORD AudioMenuProc(DWORD cmd, XMenuItem *it);
DWORD AngleMenuProc(DWORD cmd, XMenuItem *it);
DWORD BookmarkMenuProc(DWORD cmd, XMenuItem *it);

/////////////////////////////////////////////////////////////////////////////
// CRavDvdApp construction


//int WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lpszCmdLine, int showCmd)
//INT WINAPI wWinMain( HINSTANCE, HINSTANCE, LPWSTR, INT )
void __cdecl main()
{
	CRavDvdApp app;
	g_theApp = &app;

//	D3D__SingleStepPusher = 1;

	app.Create();
}

int g_curTitle = 0;

CRavDvdApp::CRavDvdApp() : CXBApplication(),
	m_dScanSpeed(0.0),
	m_nScanIndex(-1),
	m_nScanDir(SCAN_OFF),
	m_fOSDDisplayTime(0.0),
	m_bShowScanSpeed(false),
	m_bShowOSDText(false),
	m_bDrawHelp(false),
	m_bDisplayTime(false),
	m_bZoomed(false),
	m_nZoomX(0),
	m_nZoomY(0),
	m_nZoomH(0),
	m_nZoomW(0),
	m_fLThumbStickX(0.0),
	m_fLThumbStickY(0.0),
	m_fRThumbStickX(0.0),
	m_fRThumbStickY(0.0),
	m_bLThumbStickOn(false),
	m_bRThumbStickOn(false),
	m_bScanCycleUp(true),
	m_pPlayer(0),
	m_DiskID(0),
	m_bEnableScanAudio(false),
	m_fPlayerIsOpen(false),
	m_nHelpScreen(HELP_OFF),
	m_dwNewParentalLevel(PARENTAL_LEVEL_NOCHANGE),
	m_fParentalRightsTooLow(false),
	m_bDeleteMenusOnStop(true)
{
	m_CenterPoint.x = 0;
	m_CenterPoint.y = 0;
	m_LastDvdLoc.pData = NULL;
	m_LastDvdLoc.dwSize = 0;

	ZeroMemory(&m_ABRepeat.FreezeDataA, sizeof(m_ABRepeat.FreezeDataA));
	ZeroMemory(&m_ABRepeat.LocA, sizeof(m_ABRepeat.LocA));
	ZeroMemory(&m_ABRepeat.LocB, sizeof(m_ABRepeat.LocB));
	m_ABRepeat.fABRepeatState = ABREPEAT_OFF;
}

bool CRavDvdApp::InitPlayer()
{
	if(!m_pPlayer)
	{
		m_pPlayer = new DVDMediaPlayer((HINSTANCE)0x01);
	}

	static bool firstRun = true;
	BYTE regionCode = 0x00;

	if(firstRun)
	{
		regionCode = SYSTEM_REGION;
		firstRun = false;
	}

	if (S_OK == m_pPlayer->Initialize((HWND)0x01, 'D', regionCode))
	{
		if (m_LastDvdLoc.dwSize)
			delete[] m_LastDvdLoc.pData;

		ZeroMemory(&m_LastDvdLoc, sizeof(m_LastDvdLoc));
		ClearBookmarks();
		ResetABRepeat();

		// set the system region to SYSTEM_REGION (must be after intialize)
//		m_pPlayer->SetSystemRegion('D', SYSTEM_REGION);

		// FFH
		// set output rectangle as determined from configuration
		m_pPlayer->SetOutputRect(0, 0, m_uMaxWidth, m_uMaxHeight);
		m_pPlayer->SetDestinationRect(0, 0, m_uMaxWidth, m_uMaxHeight);
		MENU_RECT.x2 = (MENU_RECT.x1 + m_uMaxWidth/2) - 20;
		MENU_RECT.y2 = (MENU_RECT.y1 + m_uMaxHeight/2) - 20;


		m_pPlayer->SetColorkey(RAV_COLORKEY);


		m_pPlayer->EventHandlerInstall((PEVENT_CALLBACK) &DVDEventHandler);

		DWORD videoSetting;
		ULONG ulType, res;

		// get user's default setting
		videoSetting = XGetVideoFlags();

		if (videoSetting & XC_VIDEO_FLAGS_WIDESCREEN)
			{
			DP("Widescreen mode");
			m_pPlayer->SetDisplayMode(DPM_16BY9);
			}
		else if (videoSetting & XC_VIDEO_FLAGS_LETTERBOX)
			{
			DP("Letterbox mode");
			m_pPlayer->SetDisplayMode(DPM_LETTERBOXED);
			}

		else
			{
			DP("Normal mode");
			m_pPlayer->SetDisplayMode(DPM_4BY3);
			}


/*
		// ffh - set this based on output
		if (m_uWideScreen)
			m_pPlayer->SetDisplayMode(DPM_16BY9);
		else
			m_pPlayer->SetDisplayMode(DPM_LETTERBOXED);
*/

		// select a country code for audio that the decoder will automatically select if available
		m_pPlayer->SelectDefaultAudioLanguage(SystemDefaults.AudioLanguage, SystemDefaults.AudioExt);

		// select a country code for subpicture that the decoder will automatically select if available
		m_pPlayer->SelectDefaultSubpictureLanguage(SystemDefaults.SubpictureLanguage, SystemDefaults.SubpictureExt);

		// select a country code for dvd menus that the decoder will automatically select if available
		m_pPlayer->SelectDefaultMenuLanguage(SystemDefaults.MenuLanguage);

		// select a country code for parental control that will map the ensuing parental level
		m_pPlayer->SelectParentalCountry((WORD) SystemDefaults.ParentalCountry);

		// select a parental control level
		m_pPlayer->SelectParentalLevel(SystemDefaults.ParentalLevel);

		DWORD config = XGetAudioFlags();

		m_pPlayer->SetSpeakerOutputMode( (WORD) XC_AUDIO_FLAGS_BASIC(config) ); // 0x0000 == stereo, 0x0001 == mono, 0x0002 == surround.
		m_pPlayer->SetDigitalOutputMode( (WORD) (XC_AUDIO_FLAGS_BASIC(config) >> 16) ); // 0x0000 == PCM, 0x0001 == AC3, 0x0002 == DTS

		config = XGetAVPack();

		if (config == XC_AV_PACK_RFU)
		{
			m_pPlayer->SetSpeakerOutputMode( (WORD) XC_AUDIO_FLAGS_MONO ); // mono.
			m_pPlayer->SetAudioDynRngCompMode(AC3DYNRG_TV); // "TV Style"
		}

//		m_fPlayerIsOpen = true;
		return true;
	}
	else
		{
//		m_fPlayerIsOpen = false;
		return false;
		}
}


HRESULT CRavDvdApp::Create()
	{
	UINT wModes;
	int i;
	D3DDISPLAYMODE d3dMode;

	m_uMaxWidth = 0;
	m_uMaxHeight = 0;
	m_uWideScreen = 0;
	m_uProgressive = 0;

	wModes = Direct3D_GetAdapterModeCount(D3DADAPTER_DEFAULT);
	for (i = 0; i < wModes - 1; i++)
		{
		Direct3D_EnumAdapterModes(NULL, i, &d3dMode);
		if (d3dMode.Width > m_uMaxWidth)
			{
			if (d3dMode.Width < 1280)
				{
				m_uMaxWidth = d3dMode.Width;
				m_uMaxHeight = d3dMode.Height;
				m_uWideScreen = (d3dMode.Flags & D3DPRESENTFLAG_WIDESCREEN) >> 4;
				m_uProgressive = (d3dMode.Flags & D3DPRESENTFLAG_PROGRESSIVE) >> 6;
				}
			}
		else if (d3dMode.Height > m_uMaxHeight)
			{
			if (d3dMode.Width < 1280)
				{
				m_uMaxWidth = d3dMode.Width;
				m_uMaxHeight = d3dMode.Height;
				m_uWideScreen = (d3dMode.Flags & D3DPRESENTFLAG_WIDESCREEN) >> 4;
				m_uProgressive = (d3dMode.Flags & D3DPRESENTFLAG_PROGRESSIVE) >> 6;
				}
			}
		// prefer progressive, all else being equal
		else if ((d3dMode.Flags & D3DPRESENTFLAG_PROGRESSIVE) && (d3dMode.Width >= m_uMaxWidth) && (d3dMode.Height >= m_uMaxHeight))
			{
			if (d3dMode.Width < 1280)
				{
				m_uMaxWidth = d3dMode.Width;
				m_uMaxHeight = d3dMode.Height;
				m_uWideScreen = (d3dMode.Flags & D3DPRESENTFLAG_WIDESCREEN) >> 4;
				m_uProgressive = (d3dMode.Flags & D3DPRESENTFLAG_PROGRESSIVE) >> 6;
				}
			}

		// prefer widescreen, all else being equal
		else if ((d3dMode.Flags & D3DPRESENTFLAG_WIDESCREEN) && (d3dMode.Width >= m_uMaxWidth) && (d3dMode.Height >= m_uMaxHeight))
			{
			if (d3dMode.Width < 1280)
				{
				m_uMaxWidth = d3dMode.Width;
				m_uMaxHeight = d3dMode.Height;
				m_uWideScreen = (d3dMode.Flags & D3DPRESENTFLAG_WIDESCREEN) >> 4;
				m_uProgressive = (d3dMode.Flags & D3DPRESENTFLAG_PROGRESSIVE) >> 6;
				}
			}

		}


	// always disable progressive
	m_uProgressive = 0;


	DWORD videoSetting;
	ULONG ulType, res;

	// get user's default setting
	videoSetting = XGetVideoFlags();

	if (videoSetting & XC_VIDEO_FLAGS_WIDESCREEN)
		{
		DP("Widescreen setting selected");
		}
	else if (videoSetting & XC_VIDEO_FLAGS_LETTERBOX)
		{
		DP("Letterbox setting selected");
		}
	else
		{
		DP("Standard video setting selected");
		}


	DP("Width=%d", m_uMaxWidth);
	DP("Height=%d", m_uMaxHeight);
	DP("Progressive=%d", m_uProgressive);
	DP("WideScreen=%d", m_uWideScreen);

	// get the display height and width requirements from the title
    m_d3dpp.BackBufferWidth        = m_uMaxWidth;
    m_d3dpp.BackBufferHeight       = m_uMaxHeight;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;
//    m_d3dpp.Flags		           = (m_uWideScreen << 4) | (m_uProgressive << 6);
    m_d3dpp.Flags		           = (m_uWideScreen << 4) | D3DPRESENTFLAG_INTERLACED;

	return CXBApplication::Create();
	}


/////////////////////////////////////////////////////////////////////////////
// CRavDvdApp initialization

HRESULT CRavDvdApp::Initialize()
{
	printf("InitInstance");


    if( FAILED( m_Font.Create( m_pd3dDevice, "Fonts\\Font16.xpr") ) )
        return XBAPPERR_MEDIANOTFOUND;

//    if( FAILED( m_MenuFont.Create( m_pd3dDevice, "Fonts\\strip.tga",
//                                             "Fonts\\strip.abc" ) ) )
    if( FAILED( m_MenuFont.Create( m_pd3dDevice, "Fonts\\Font12.xpr") ) )
        return XBAPPERR_MEDIANOTFOUND;

	if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr") ) )
		return XBAPPERR_MEDIANOTFOUND;


	if( FAILED( m_Splash.Create( m_pd3dDevice, m_uMaxWidth, m_uMaxHeight) ) )
		return XBAPPERR_MEDIANOTFOUND;

	RECT rect;
	rect.top = OSD_ACTION_TOP;
	rect.bottom = rect.top + 64;
	rect.left = OSD_ACTION_LEFT;
	rect.right = rect.left + 64;

    if( FAILED( m_NotPermitted.Create( m_pd3dDevice, "Textures\\notallowed3.tga", rect) ) )
        return XBAPPERR_MEDIANOTFOUND;

	m_BookmarkOSD.Create( m_pd3dDevice, "Textures\\bookmark.tga", rect);

	XBRavMenu::SetFont(&m_MenuFont);

	m_pd3dDevice->EnableOverlay(true);

	this->m_GamePads = CXBApplication::m_Gamepad;

	LONGLONG diskID = 0;

	if (InitPlayer())
	{
		if(m_pPlayer->CheckDrive('D',(char*)&diskID) == S_OK)
		{

//#if _DEBUG
//		char buf[100];
//		wsprintf(buf,"this id=%d, lastID=%d", diskID,m_DiskID);
//		OutputDebugString(buf);
//#endif _DEBUG

//			if(diskID != m_DiskID)
//				{
//				InitPlayer();
				m_DiskID = diskID;
//				}

	//		m_fPlayerIsOpen = true;
			HRESULT hr = m_pPlayer->Play();
			if (S_OK != hr)
			{
				if (hr == QI_E_INSUFFICIENT_RIGHTS)
				{
					m_fParentalRightsTooLow = true;
				}
			}

			DVDPlayerMode mode = m_pPlayer->GetPlayerMode();
			if(mode == DPM_STOPPED)
			{
				hr = m_pPlayer->PlayTitle(1);

				if (S_OK != hr)
				{
					if (hr == QI_E_INSUFFICIENT_RIGHTS)
					{
						m_fParentalRightsTooLow = true;
					}
				}
			}

		}
	}
	else
		{
		}//m_fPlayerIsOpen = false;

	// register our vblank callback
	g_pd3dDevice->SetVerticalBlankCallback(VBlankCallback);

	return this->Run();
}

CRavDvdApp::~CRavDvdApp()
{
	if (m_pPlayer)
	{
		m_pPlayer->Stop();
		delete m_pPlayer;
		m_pPlayer = NULL;
	}
	m_pPlayer = NULL;
}


void CRavDvdApp::ClearBookmarks()
{
	for(vector<BOOKMARK_DATA>::iterator it = m_Bookmarks.begin(); it != m_Bookmarks.end(); it++)
	{
		if (it->FreezeData.dwSize)
			delete[] it->FreezeData.pData;
		m_Bookmarks.erase(it);
	}
}


void CRavDvdApp::CreateMonitor()
{
}

void CRavDvdApp::ResetOSD(WCHAR* pOSDText,bool bShowOSDText, bool bShowScanSpeed, int nTimerIncrement)
{
	m_bShowOSDText = bShowOSDText;
	m_bShowScanSpeed = bShowScanSpeed;

	if (pOSDText)
		wsprintfW(m_pOSDTextBuf, pOSDText);

	if (m_bShowScanSpeed)
	{
		if(m_dScanSpeed >= 0.0)
		{
			div_t t = div(m_dScanSpeed * 100, 100);

			if (m_nScanDir == SCAN_FWD)
			{
				if (t.rem != 0)
					wsprintfW(m_pScanSpeedTextBuf, L">>\t%.2fx", m_dScanSpeed);
				else
					wsprintfW(m_pScanSpeedTextBuf, L">>\t%dx", (int)m_dScanSpeed);
			}
			else
			{
				if (t.rem != 0)
					wsprintfW(m_pScanSpeedTextBuf, L"<<\t%.2fx", m_dScanSpeed);
				else
					wsprintfW(m_pScanSpeedTextBuf, L"<<\t%dx", (int)m_dScanSpeed);
			}
		}
	}

	m_fOSDDisplayTime = XBUtil_Timer(TIMER_GETAPPTIME) + nTimerIncrement;

	// immediately draw to screen for instant feedback
	if (!m_bDrawHelp )
    {
		m_pd3dDevice->BeginScene();

		DVD_DOMAIN domain;
		if (S_OK == m_pPlayer->GetCurrentDomain(&domain))
		{
			if (domain != DVD_DOMAIN_Stop)
				m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
					 RAV_COLORKEY, 1.0f, 0L );
			else
			{
				m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
									 0xFF000000, 1.0f, 0L );
				m_Splash.Render();
			}
		}
		else
		{
			m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
								 0xFF000000, 1.0f, 0L );
			m_Splash.Render();
		}

		DrawOsd();
		m_pd3dDevice->EndScene();
		m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	}
}

void CRavDvdApp::ResetScanSpeed(bool bClearText, bool bClearData)
{
	if (bClearData)
	{
		m_dScanSpeed = 0.0;
		m_nScanIndex = -1;
		m_nScanDir = SCAN_OFF;
		m_bScanCycleUp = true;
	}

	if (bClearText)
	{
		m_bShowScanSpeed = false;
//		m_bShowOSDText = false;
	}
}

void CRavDvdApp::ResetMenus()
{
	if(m_bDeleteMenusOnStop)
	{
		while(XBRavMenu::IsActive())
		{
			XBRavMenu* curMenu = XBRavMenu::GetActiveMenu();
			curMenu->Activate(false);
			delete curMenu;
		}
	}
}

void CRavDvdApp::ResetABRepeat()
{
	if (m_ABRepeat.fABRepeatState != ABREPEAT_OFF)
	{
		delete[] m_ABRepeat.FreezeDataA.pData;
		m_ABRepeat.FreezeDataA.dwSize = 0;
		ZeroMemory(&m_ABRepeat.LocA, sizeof(m_ABRepeat.LocA));
		ZeroMemory(&m_ABRepeat.LocB, sizeof(m_ABRepeat.LocB));
		m_ABRepeat.fABRepeatState = ABREPEAT_OFF;
	}
}

void CRavDvdApp::ResetZoomVariables()
{
	m_CenterPoint.x = 0;
	m_CenterPoint.y = 0;
	m_nZoomX = 0;
	m_nZoomY = 0;
	m_nZoomH = 0;
	m_nZoomW = 0;
	m_bZoomed = false;
}

void CRavDvdApp::ResetCenterPoint()
{
	WORD wX, wY;
	float fScaleFactor;
	m_pPlayer->Get_VideoSize(wX, wY);

	if (S_OK != m_pPlayer->Get_CurrentScaleFactor(fScaleFactor))
		fScaleFactor = 1.0f;

	if (fScaleFactor != 1.0f)
	{
		m_CenterPoint.x = m_nZoomX + (float) ((float) wX / (fScaleFactor*2.0f));
		m_CenterPoint.y = m_nZoomY + (float) ((float) wY / (fScaleFactor*2.0f));
	}
	else
	{
		m_CenterPoint.x = wX/2;
		m_CenterPoint.y = wY/2;
	}
}

void CRavDvdApp::HandleParentalLevelChange()
{
	unsigned long ulParentalLevel = 8;
	WORD	wCountryCode;

	// get current level
	if (m_pPlayer)
		m_pPlayer->GetPlayerParentalLevel(&ulParentalLevel, &wCountryCode);

	// if new level is higher we need to get a password
	if (ulParentalLevel < g_theApp->m_dwNewParentalLevel)
	{
		// !!!PUT PASSWORD OVERRIDES HERE!!!
		// User should enter a password to override the current Parental Control level

		m_pPlayer->GetPlayerParentalLevel(&ulParentalLevel, &wCountryCode);
		m_pPlayer->SelectParentalLevel(g_theApp->m_dwNewParentalLevel);

		if (m_pPlayer)
			m_pPlayer->Play();
	}
	else
	{
		m_pPlayer->SelectParentalLevel(g_theApp->m_dwNewParentalLevel);

		if (m_pPlayer)
			m_pPlayer->Play();
	}

	// turn this off so we only handle it once
	g_theApp->m_dwNewParentalLevel = PARENTAL_LEVEL_NOCHANGE;
}

int gcd(int nNum1, int nNum2)
{
	int nRemainder = nNum2 % nNum1;

	if (nRemainder != 0)
		return(gcd(nRemainder, nNum1));

	return nNum1;
}

void ReduceRatio(int nNum, int nDen, int& nReducedNum, int& nReducedDen)
{
	int nGcd = gcd(nNum, nDen);

	nReducedNum = nNum/nGcd;
	nReducedDen = nDen/nGcd;
}



void CRavDvdApp::ProcessGamePadInput(DWORD dwInput)
{
	if (dwInput != XB_NO_INPUT)
	{
//		if(!m_fPlayerIsOpen)
//			InitPlayer();
	}


	if((m_pPlayer))// && (m_fPlayerIsOpen))
	{
		switch (dwInput)
		{

			// ROOT MENU ACTION
			case XB_Y_BUTTON:
						{
							ULONG uops;
							DVDPlayerMode lMode = m_pPlayer->GetPlayerMode();
							HRESULT ret = m_pPlayer->GetCurrentUOPS(&uops);

							if((S_OK == ret) && (lMode != DPM_STOPPED))
							{
								if(S_OK == ret && !(uops & UOP_MENU_CALL_ROOT))
								{
									ResetOSD(IDS_ROOTMENU, true, false, OSD_DISPLAY_TIME);
									m_pPlayer->ShowMenu(QMENU_ROOT);
								}
								else
									ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
							}
							else
								ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
							break;
						}
			// PLAY/PAUSE/ENTER ACTION
			case XB_A_BUTTON:
						{
							ULONG uops;
							DVDPlayerMode lMode = m_pPlayer->GetPlayerMode();

							HRESULT ret = m_pPlayer->GetCurrentUOPS(&uops);

							if(S_OK == ret || lMode == DPM_STOPPED)
							{

								if(S_OK == ret && !(uops & UOP_BUTTON))
								{
									m_pPlayer->ActivateButton();
//										ResetOSD(IDS_ACTIVATE, true, false, 1);
								}
								else if( lMode == DPM_STOPPED )
								{

									int seconds = 0;
									bool failed = false;
									LONGLONG diskID = 0;

									while(m_pPlayer->CheckDrive('D',(char*)&diskID) != S_OK && !failed)
									{
										Sleep(1000);
										if(seconds++ > 10)
											failed = true;
									}
								#if _DEBUG
										char buf[100];
										wsprintf(buf,"this id=%d, lastID=%d", diskID,m_DiskID);
										OutputDebugString(buf);
								#endif _DEBUG
									if(!failed)
									{
										if ((diskID != m_DiskID) || (0 == m_LastDvdLoc.dwSize))
										{
											if(InitPlayer())
											{
												ResetOSD(&IDS_PLAY, true, false, OSD_DISPLAY_TIME);

												m_DiskID = diskID;
												HRESULT hr = m_pPlayer->Play();
												if (S_OK != hr)
												{
													if (hr == QI_E_INSUFFICIENT_RIGHTS)
													{
														m_fParentalRightsTooLow = true;
													}
												}

												DVDPlayerMode mode = m_pPlayer->GetPlayerMode();
												if(mode == DPM_STOPPED)
												{
													hr = m_pPlayer->PlayTitle(1);

													if (S_OK != hr)
													{
														if (hr == QI_E_INSUFFICIENT_RIGHTS)
														{
															m_fParentalRightsTooLow = true;
														}
													}
												}
											}
										}
										else
										{
											ResetOSD(&IDS_PLAY, true, false, OSD_DISPLAY_TIME);
											m_pPlayer->Defrost(m_LastDvdLoc.pData, m_LastDvdLoc.dwSize);

											if (m_LastDvdLoc.dwSize)
												delete[] m_LastDvdLoc.pData;
											ZeroMemory(&m_LastDvdLoc, sizeof(m_LastDvdLoc));
										}
									}
								}
								else
								{
									switch (lMode)
									{
										case (DPM_NONE) :
										case (DPM_STILL) :
												// we are incapable of pausing in these modes
												break;

										case (DPM_REVERSEPLAY) :
										case (DPM_TRICKPLAY) :
										case (DPM_PAUSED) :
												ResetOSD(&IDS_PLAY, true, false, OSD_DISPLAY_TIME);
												m_pPlayer->Play();
												break;

										default:
												if (m_dScanSpeed != 0.0)
												{
													ResetOSD(&IDS_PLAY, true, false, OSD_DISPLAY_TIME);
													m_pPlayer->Play();
												}
												else if (!(uops & UOP_PAUSE_ON))
												{
													ResetOSD(&IDS_PAUSE, true, false, OSD_DISPLAY_TIME);
													m_pPlayer->Pause();
												}
												break;
									}
								}
							}

							// reset any scanning that may have been going on
							ResetScanSpeed(false, true);
						}

						break;

			// SHOW HELP ACTION
			case XB_BLACK_BUTTON:
						m_nHelpScreen++;

						if (m_nHelpScreen > HELP_OFF)
							m_nHelpScreen = HELP_NORMAL;

//							m_bDrawHelp = !m_bDrawHelp;
						break;

			// TOGGLE CHAP/TIME DISPLAY
			case XB_WHITE_BUTTON:
						m_bDisplayTime = !m_bDisplayTime;
						break;

			// ZOOM ACTION
			case XB_X_BUTTON:
						{
							DVD_DOMAIN domain;
							if (S_OK == m_pPlayer->GetCurrentDomain(&domain))

							{
								if (domain != DVD_DOMAIN_Stop)
								{
									float fScaleFactor;
									WORD wX, wY;
									WORD xRange, yRange;
									if (S_OK == m_pPlayer->Get_CurrentScaleFactor(fScaleFactor))
									{
										if (fScaleFactor >= 16.0)
										{
											m_pPlayer->Trick_Zoom(0, 0, 1.0);
											ResetZoomVariables();
										}
										else
										{
											m_pPlayer->Get_VideoSize(wX, wY);

											fScaleFactor = max(1, fScaleFactor);

											xRange = (float) wX * (1.0 - (1.0/fScaleFactor));
											yRange = (float) wY * (1.0 - (1.0/fScaleFactor));

											//make sure we are still in the viewable area
											if(m_nZoomX < 0)
												m_nZoomX = 0;
											else if(m_nZoomX > xRange)
												m_nZoomX = xRange;

											if(m_nZoomY < 0)
												m_nZoomY = 0;
											else if(m_nZoomY > yRange)
												m_nZoomY = yRange;

											HRESULT hr = m_pPlayer->Trick_Zoom(m_nZoomX, m_nZoomY, 2.0);
											m_bZoomed = true;

											m_nZoomW = wX - int((float) wX * (1.0 - (1.0/(fScaleFactor*2.0))));
											m_nZoomH = wY - int((float) wY * (1.0 - (1.0/(fScaleFactor*2.0))));
										}
									}
								}
								else
									ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
							}
							else
								ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
						}
						break;

			// STOP
			case XB_B_BUTTON:
						{
							ULONG uops;
							DVDPlayerMode lMode = m_pPlayer->GetPlayerMode();
							HRESULT ret = m_pPlayer->GetCurrentUOPS(&uops);

							if((S_OK == ret) && (lMode != DPM_STOPPED))
							{
								if(S_OK == ret && !(uops & UOP_STOP))
								{
									ResetOSD(&IDS_STOP, true, false, OSD_DISPLAY_TIME);

									if ((m_LastDvdLoc.dwSize != 0) ||
										(S_OK != m_pPlayer->Freeze(m_LastDvdLoc.pData, m_LastDvdLoc.dwSize) ))
									{
										delete[] m_LastDvdLoc.pData;
										ZeroMemory(&m_LastDvdLoc, sizeof(m_LastDvdLoc));
									}

									m_pPlayer->Stop();
								}
								else
									ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
							}
							else if (m_LastDvdLoc.dwSize != 0)
							{
								delete[] m_LastDvdLoc.pData;
								ZeroMemory(&m_LastDvdLoc, sizeof(m_LastDvdLoc));
							}
						}
						break;

			// PREV CHAPTER ACTION
			case XB_LEFT_TRIGGER_BUTTON:
						{
							ULONG uops;
							HRESULT hr = m_pPlayer->GetCurrentUOPS(&uops);

							if ((S_OK == hr) && (!(uops & UOP_PREV_TOP_PG_SEARCH)))
							{
								WCHAR chChapText[64];
								DVD_PLAYBACK_LOCATION2 dvdLoc;

								if (S_OK == m_pPlayer->GetCurrentLocation(&dvdLoc))
								{
									if ((dvdLoc.TitleNum > 0) && (dvdLoc.ChapterNum > 1))
									{
										int nPrevChap = max(1, dvdLoc.ChapterNum - 1);

										wsprintfW(chChapText, L"Title %d\nChapter %d", dvdLoc.TitleNum, nPrevChap);
										ResetOSD(chChapText, true, false, OSD_DISPLAY_TIME);
										hr = m_pPlayer->PreviousChapter();
									}
									else
									{
										hr = m_pPlayer->PlayTitle(dvdLoc.TitleNum-1);
									}
								}

								if (S_OK == m_pPlayer->GetCurrentLocation(&dvdLoc) && dvdLoc.TitleNum != 0 && dvdLoc.ChapterNum)
								{
									wsprintfW(chChapText, L"Title %d\nChapter %d", dvdLoc.TitleNum, dvdLoc.ChapterNum);
									ResetOSD(chChapText, true, false, OSD_DISPLAY_TIME);
								}
							}
							else
								ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
						}
						break;

			// NEXT CHAPTER ACTION
			case XB_RIGHT_TRIGGER_BUTTON:
						{
							ULONG uops;
							HRESULT hr = m_pPlayer->GetCurrentUOPS(&uops);

							if ((S_OK == hr) && (!(uops & UOP_NEXT_PG_SEARCH)))
							{
								WCHAR chChapText[64];
								DVD_PLAYBACK_LOCATION2 dvdLoc;

//								Advance title if last chap

								if (S_OK == m_pPlayer->GetCurrentLocation(&dvdLoc))
								{
									if ((dvdLoc.TitleNum > 0) && (dvdLoc.ChapterNum > 0))
									{
										int nNextChap = dvdLoc.ChapterNum + 1;

										ULONG lChapsInTitle = 0;
										if (m_pPlayer->GetNumberOfChapters(dvdLoc.TitleNum, &lChapsInTitle) != S_OK)
											lChapsInTitle = 0;

										if (nNextChap <= lChapsInTitle)
										{
											wsprintfW(chChapText, L"Title %d\nChapter %d", dvdLoc.TitleNum, nNextChap);
											ResetOSD(chChapText, true, false, OSD_DISPLAY_TIME);
											hr = m_pPlayer->NextChapter();
										}
										else
										{
											hr = m_pPlayer->PlayTitle(dvdLoc.TitleNum+1);
										}
									}
								}

//								hr = m_pPlayer->NextChapter();

								if (S_OK == m_pPlayer->GetCurrentLocation(&dvdLoc) && dvdLoc.TitleNum != 0 && dvdLoc.ChapterNum)
								{
									wsprintfW(chChapText, L"Title %d\nChapter %d", dvdLoc.TitleNum, dvdLoc.ChapterNum);
									ResetOSD(chChapText, true, false, OSD_DISPLAY_TIME);

								}
							}
							else
								ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
						}
						break;


			// SLOW/FAST REV ACTION
			case XB_SHIFT_X_BUTTON:
						{
							ULONG uops;
							HRESULT hr = m_pPlayer->GetCurrentUOPS(&uops);

							if ((S_OK == hr) && (!(uops & UOP_BACKWARD_SCAN)))
							{
								DVDPlayerMode lMode = m_pPlayer->GetPlayerMode();

								if(m_pPlayer->IsPlaying() && !((lMode == DPM_PAUSED) || (lMode == DPM_STILL)))
								{
									if ((m_nScanIndex != -1) && (m_nScanDir == SCAN_REV))
									{
										// increment thru fast reverse speeds
										if (m_bScanCycleUp)
											m_nScanIndex ++;
										else
											m_nScanIndex --;

										if (m_dScanSpeed > 1.0)
										{
											// we are in fast rev mode
											m_nScanIndex = max(0, min(m_nScanIndex, NUM_FAST_MOTION - 1));

											if ((m_nScanIndex == 0) || (m_nScanIndex == NUM_FAST_MOTION - 1))
												m_bScanCycleUp = !m_bScanCycleUp;

											m_dScanSpeed = FAST_SCAN_VALUES[m_nScanIndex];
										}
										else if (m_dScanSpeed < 1.0)
										{
											// we are in slow rev mode
											m_nScanIndex = max(0, min(m_nScanIndex, NUM_SLOW_MOTION - 1));

											if ((m_nScanIndex == 0) || (m_nScanIndex == NUM_SLOW_MOTION - 1))
												m_bScanCycleUp = !m_bScanCycleUp;

											m_dScanSpeed = SLOW_SCAN_VALUES[m_nScanIndex];
										}
									}
									else if (m_nScanIndex != -1)
									{
										// must've been scanning forward; just keep same scan speed in reverse
										m_nScanDir = SCAN_REV;
										m_bScanCycleUp = true;
									}
									else
									{
										m_nScanDir = SCAN_REV;
										m_nScanIndex=0;
										m_bScanCycleUp = true;
										m_dScanSpeed = FAST_SCAN_VALUES[m_nScanIndex];
									}
								}
								else
								{
									m_nScanDir = SCAN_REV;
									m_nScanIndex=0;
									m_bScanCycleUp = true;
									m_dScanSpeed = SLOW_SCAN_VALUES[m_nScanIndex];
								}

								ResetOSD(NULL, false, true, OSD_DISPLAY_TIME-1);
								m_pPlayer->PlayBackwards(m_dScanSpeed);
							}
						}
						break;

			// SLOW/FAST FWD ACTION
			case XB_SHIFT_B_BUTTON:
						// increment thru forward speeds
						{
							ULONG uops;
							HRESULT hr = m_pPlayer->GetCurrentUOPS(&uops);

							if ((S_OK == hr) && (!(uops & UOP_FORWARD_SCAN)))
							{
								DVDPlayerMode lMode = m_pPlayer->GetPlayerMode();

								if(m_pPlayer->IsPlaying() && !((lMode == DPM_PAUSED) || (lMode == DPM_STILL)))

								{
									if ((m_nScanIndex != -1) && (m_nScanDir == SCAN_FWD))
									{
										// increment thru forward speeds
										if (m_bScanCycleUp)
											m_nScanIndex ++;
										else
											m_nScanIndex --;

										if (m_dScanSpeed > 1.0)


										{
											m_nScanIndex = max(0, min(m_nScanIndex, NUM_FAST_MOTION - 1));

											if ((m_nScanIndex == 0) || (m_nScanIndex == NUM_FAST_MOTION - 1))
												m_bScanCycleUp = !m_bScanCycleUp;


											// we are in fast fwd mode
											m_dScanSpeed = FAST_SCAN_VALUES[m_nScanIndex];

										}
										else if (m_dScanSpeed < 1.0)
										{
											// we are in slow fwd mode
											m_nScanIndex = max(0, min(m_nScanIndex, NUM_SLOW_MOTION - 1));

											if ((m_nScanIndex == 0) || (m_nScanIndex == NUM_SLOW_MOTION - 1))
												m_bScanCycleUp = !m_bScanCycleUp;

											m_dScanSpeed = SLOW_SCAN_VALUES[m_nScanIndex];
										}
									}
									else if (m_nScanIndex != -1)
									{
										// must've been scanning backward; just keep same scan speed but forward
										m_nScanDir = SCAN_FWD;
										m_bScanCycleUp = true;
									}
									else
									{
										// we're playing and just starting to scan
										m_nScanDir = SCAN_FWD;
										m_nScanIndex = 0;
										m_bScanCycleUp = true;
										m_dScanSpeed = FAST_SCAN_VALUES[m_nScanIndex];
									}

								}
								else
								{
									m_nScanDir = SCAN_FWD;
									m_nScanIndex = 0;
									m_bScanCycleUp = true;
									m_dScanSpeed = SLOW_SCAN_VALUES[m_nScanIndex];
								}

								ResetOSD(NULL, false, true, OSD_DISPLAY_TIME-1);
								m_pPlayer->PlayForwards(m_dScanSpeed);
							}
						}
						break;

			case XB_SHIFT_Y_BUTTON:
						{
							// show subpicture menu
							ULONG lNumSubpic, lCurSubpic, uops;
							BOOL bEnabled;
							m_pPlayer->GetCurrentSubpicture(&lNumSubpic, &lCurSubpic, &bEnabled);

							if (S_OK == m_pPlayer->GetCurrentUOPS(&uops))
							{
								if (!(uops & UOP_SUB_PICTURE_STREAM_CHANGE))
								{
									if (lNumSubpic > 0)
									{
										XBRavMenu*	pSubpicMenu = new XBRavMenu(NULL, 320.0f, 100.0f,
											lNumSubpic, MENU_WRAP, NULL);
										if (pSubpicMenu)
										{
											for(unsigned long i = 0; i < lNumSubpic; i++)
											{
												// add text description
			    								char strLangName[MAX_PATH];
			    								WCHAR wStrLangName[MAX_PATH];
				    							if (S_OK == m_pPlayer->GetSubpictureLanguage(i, strLangName, MAX_PATH))
												{
													MultiByteToWideChar(CP_ACP,0,strLangName,-1,wStrLangName, MAX_PATH);
													pSubpicMenu->AddItem(MITEM_ROUTINE, wStrLangName, &SubpicMenuProc);
												}
											}

											pSubpicMenu->AddItem(MITEM_ROUTINE, L"None", &SubpicMenuProc);

											if (bEnabled)
												pSubpicMenu->curitem = lCurSubpic;
											else
												pSubpicMenu->curitem = lNumSubpic;

											pSubpicMenu->Activate();
										}
									}
									else
									{
										ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
									}
								}
								else
								{
									ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
								}
							}
						}
						break;

			case XB_SHIFT_A_BUTTON:
						{
							// show audio menu
							ULONG lNumAudio, lCurAudio, uops;
							m_pPlayer->GetCurrentAudio(&lNumAudio, &lCurAudio);

							if(S_OK == m_pPlayer->GetCurrentUOPS(&uops))
							{
								if(!(uops & UOP_AUDIO_STREAM_CHANGE))
								{
									if (lNumAudio > 1)
									{
										XBRavMenu * pAudioMenu = new XBRavMenu(NULL, 320.0f, 100.0f,
											lNumAudio, MENU_WRAP, NULL);
										if (pAudioMenu)
										{
											for(unsigned long i = 0; i < lNumAudio; i++)
											{
												// add text description
			    								char strLangName[MAX_PATH];
			    								WCHAR wStrLangName[MAX_PATH];

				    							if (S_OK == m_pPlayer->GetAudioLanguage(i, strLangName, MAX_PATH))
												{
													MultiByteToWideChar(CP_ACP,0,strLangName,-1,wStrLangName, MAX_PATH);
													pAudioMenu->AddItem(MITEM_ROUTINE, wStrLangName, &AudioMenuProc);

												}


											}
											pAudioMenu->curitem = lCurAudio;
											pAudioMenu->Activate();
										}
									}
									else
									{
										ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
									}
								}
								else
								{
									ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
								}
							}
						}
						break;

			case XB_SHIFT_BLACK_BUTTON:
						// show settings menu

						// temporarily enable/disable audio during scan
//						m_bEnableScanAudio = !m_bEnableScanAudio;
//						m_pPlayer->EnableScanAudio(m_bEnableScanAudio);
						break;

			case XB_SHIFT_BACK:
//						ResetOSD(IDS_TITLEMENU, true, false, OSD_DISPLAY_TIME);
						m_pPlayer->ShowMenu(QMENU_TITLE);
						break;

			case XB_SHIFT_START:
						DisplayTitleMenu();
//						DisplayGlobalSettingsMenu();
						break;

			case XB_SHIFT_WHITE_BUTTON:
						{
							// show angle menu
							ULONG lNumAngles, lCurAngle, uops;
							m_pPlayer->GetCurrentAngle(&lNumAngles, &lCurAngle);

							if(S_OK == m_pPlayer->GetCurrentUOPS(&uops))
							{
								if(!(uops & UOP_ANGLE_CHANGE))
								{
									if (lNumAngles > 1)
									{
										XBRavMenu * pAngleMenu = new XBRavMenu(NULL, 320.0f, 100.0f,
											lNumAngles, MENU_WRAP, NULL);
										if (pAngleMenu)
										{
											for(unsigned long i = 0; i < lNumAngles; i++)
											{
			    								WCHAR strName[MAX_PATH];

												wsprintfW(strName, L"Angle %d", i + 1);
												pAngleMenu->AddItem(MITEM_ROUTINE, strName, &AngleMenuProc);
											}
											pAngleMenu->curitem = lCurAngle-1; // angle is 1-based
											pAngleMenu->Activate();
										}
									}
									else
									{
										ResetOSD(&IDS_NOANGLE, true, false, OSD_DISPLAY_TIME);
									}
								}
								else
								{
									ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
								}
							}
						}
						break;

			case XB_SHIFT_LEFT_TRIGGER_BUTTON:
						// volume down
//						{
//							long lVol;
//							m_pPlayer->get_Volume(&lVol);
//							lVol = max(lVol-VOL_INCREMENT, 0);
//							ResetOSD(&IDS_VOLDOWN, true, false, OSD_DISPLAY_TIME);
//							m_pPlayer->put_Volume(lVol);
//						}
						break;

			case XB_SHIFT_RIGHT_TRIGGER_BUTTON:
						// volume up
//						{
//							long lVol;
//							m_pPlayer->get_Volume(&lVol);
//							lVol = min(lVol+VOL_INCREMENT, G_C_MAX_VOLUME);
//							ResetOSD(&IDS_VOLUP, true, false, OSD_DISPLAY_TIME);
//							m_pPlayer->put_Volume(lVol);
//						}
						break;


			case XB_SHIFT_DPAD_LEFT:
						{
							ULONG uops;
							DVD_DOMAIN domain;

							if(S_OK == m_pPlayer->GetCurrentUOPS(&uops))
							{
								if ((S_OK == m_pPlayer->GetCurrentDomain(&domain)) && (domain != DVD_DOMAIN_Stop)
									&& (!(uops & UOP_TIME_PLAY_SEARCH)))
								{
									BOOKMARK_DATA bookmark;

									// drop bookmark
									ResetOSD(&IDS_BOOKMARK, true, false, OSD_DISPLAY_TIME);

									if (S_OK == m_pPlayer->GetCurrentLocation(&bookmark.Loc))
									{
										if (S_OK == m_pPlayer->Freeze(bookmark.FreezeData.pData,
											bookmark.FreezeData.dwSize))
										{
											m_Bookmarks.push_back(bookmark);
										}
									}
								}
								else
								{
									ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
								}
							}
						}
						break;

			case XB_SHIFT_DPAD_RIGHT:
						{
							ULONG uops;
							DVD_DOMAIN domain;

							if (S_OK == m_pPlayer->GetCurrentUOPS(&uops))
							{
								if ((S_OK == m_pPlayer->GetCurrentDomain(&domain)) && (domain != DVD_DOMAIN_Stop) &&
									(!(uops & UOP_TIME_PLAY_SEARCH)))
								{
									// show bookmark menu if any exist
									int nNumBookmarks = m_Bookmarks.size();
									WCHAR wchBookmarkText[MAX_PATH];

									if (nNumBookmarks)
									{
										for(vector<BOOKMARK_DATA>::iterator it = m_Bookmarks.begin();
											it != m_Bookmarks.end(); it++)
										{
											XBRavMenu * pBookmarkMenu = new XBRavMenu(NULL, 320.0f, 100.0f,
												nNumBookmarks, MENU_WRAP, NULL);
											if (pBookmarkMenu)
											{
												for(unsigned long i = 0; i < nNumBookmarks; i++)
												{
													wsprintfW(wchBookmarkText, L"Title %d %02d:%02d:%02d",
														m_Bookmarks[i].Loc.TitleNum, m_Bookmarks[i].Loc.TimeCode.bHours,
														m_Bookmarks[i].Loc.TimeCode.bMinutes, m_Bookmarks[i].Loc.TimeCode.bSeconds);

													pBookmarkMenu->AddItem(MITEM_ROUTINE, wchBookmarkText, &BookmarkMenuProc);
												}

												pBookmarkMenu->curitem = 0;
												pBookmarkMenu->Activate();
											}
										}
									}
								}
								else
								{
									ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
								}
							}
						}
						break;


			case XB_SHIFT_DPAD_UP:
						{
							switch (m_ABRepeat.fABRepeatState)
							{
								case (ABREPEAT_A_SET) :
										if (S_OK == m_pPlayer->GetCurrentLocation(&m_ABRepeat.LocB))
										{
											DWORD dwBLoc	= (m_ABRepeat.LocB.TimeCode.bHours << 24) +
												(m_ABRepeat.LocB.TimeCode.bMinutes << 16) +
												(m_ABRepeat.LocB.TimeCode.bSeconds << 8) +
												(m_ABRepeat.LocB.TimeCode.bFrames);

											DWORD dwALoc	= (m_ABRepeat.LocA.TimeCode.bHours << 24) +
												(m_ABRepeat.LocA.TimeCode.bMinutes << 16) +
												(m_ABRepeat.LocA.TimeCode.bSeconds << 8) +
												(m_ABRepeat.LocA.TimeCode.bFrames);

											if (dwBLoc > dwALoc)
											{
												m_ABRepeat.fABRepeatState = ABREPEAT_A_AND_B_SET;

												m_pPlayer->Defrost(m_ABRepeat.FreezeDataA.pData,
													m_ABRepeat.FreezeDataA.dwSize);

												ResetOSD(&IDS_B_DOWN, true, false, OSD_DISPLAY_TIME);
												break;
											}
											else
											{
												// points are illegal; let switch pass thru to delete the points below
												ResetOSD(&IDS_ILLEGAL_AB, true, false, OSD_DISPLAY_TIME);
											}
										}

								case (ABREPEAT_A_AND_B_SET) :

										delete[] m_ABRepeat.FreezeDataA.pData;
										m_ABRepeat.FreezeDataA.dwSize = 0;
										ZeroMemory(&m_ABRepeat.LocB, sizeof(m_ABRepeat.LocB));
										m_ABRepeat.fABRepeatState = ABREPEAT_OFF;
										ResetOSD(&IDS_AB_OFF, true, false, OSD_DISPLAY_TIME);
										break;

								case (ABREPEAT_OFF) :

										if (S_OK == m_pPlayer->GetCurrentLocation(&m_ABRepeat.LocA))
										{
											if (S_OK == m_pPlayer->Freeze(m_ABRepeat.FreezeDataA.pData,
												m_ABRepeat.FreezeDataA.dwSize))
											{
												m_ABRepeat.fABRepeatState = ABREPEAT_A_SET;
												ResetOSD(&IDS_A_DOWN, true, false, OSD_DISPLAY_TIME);
											}
										}
										break;
							}
						}
						break;


			// MENU UP ACTION
			case XB_DPAD_UP:
						{
							ULONG uops;
							DVDPlayerMode lMode = m_pPlayer->GetPlayerMode();

							if(S_OK == m_pPlayer->GetCurrentUOPS(&uops))
							{
								if(!(uops & UOP_BUTTON))
								{
									m_pPlayer->SelectRelativeButton(DVD_Relative_Upper);
								}
								else if(m_bZoomed)
								{
									WORD wX, wY;
									float fScaleFactor;

									if (S_OK == m_pPlayer->Get_CurrentScaleFactor(fScaleFactor))
									{
										m_pPlayer->Get_VideoSize(wX, wY);

										fScaleFactor = max(1, fScaleFactor);

										WORD yRange = (float) wY * (1.0 - (1.0/fScaleFactor));
										m_nZoomY -= ZOOM_Y_INCREMENT;
										m_nZoomY = max(0, min(m_nZoomY, yRange));

										HRESULT hr = m_pPlayer->Trick_Zoom(m_nZoomX, m_nZoomY, 0.0);

										ResetCenterPoint();
									}
								}
							}
						}
						break;

			// MENU DOWN ACTION
			case XB_DPAD_DOWN:
						{
							ULONG uops;
							DVDPlayerMode lMode = m_pPlayer->GetPlayerMode();

							if(S_OK == m_pPlayer->GetCurrentUOPS(&uops))
							{
								if(!(uops & UOP_BUTTON))
								{
									m_pPlayer->SelectRelativeButton(DVD_Relative_Lower);
								}
								else if(m_bZoomed)
								{
									WORD wX, wY;
									float fScaleFactor;

									if (S_OK == m_pPlayer->Get_CurrentScaleFactor(fScaleFactor))
									{
										m_pPlayer->Get_VideoSize(wX, wY);

										fScaleFactor = max(1, fScaleFactor);

										WORD yRange = (float) wY * (1.0 - (1.0/fScaleFactor));
										m_nZoomY += ZOOM_Y_INCREMENT;
										m_nZoomY = max(0, min(m_nZoomY, yRange));

										HRESULT hr = m_pPlayer->Trick_Zoom(m_nZoomX, m_nZoomY, 0.0);

										ResetCenterPoint();
									}
								}
							}
						}
						break;


			// MENU LEFT ACTION
			case XB_DPAD_LEFT:
						{
							ULONG uops;
							if(S_OK == m_pPlayer->GetCurrentUOPS(&uops))
							{
								if(!(uops & UOP_BUTTON))

								{
									m_pPlayer->SelectRelativeButton(DVD_Relative_Left);
								}
								else
								{
									DVDPlayerMode lMode = m_pPlayer->GetPlayerMode();

									DVD_DOMAIN dom;
									m_pPlayer->GetCurrentDomain(&dom);

									if (m_bZoomed)
									{
										WORD wX, wY;
										float fScaleFactor;

										if (S_OK == m_pPlayer->Get_CurrentScaleFactor(fScaleFactor))
										{
											m_pPlayer->Get_VideoSize(wX, wY);

											fScaleFactor = max(1, fScaleFactor);

											WORD xRange = (float) wX * (1.0 - (1.0/fScaleFactor));
											m_nZoomX -= ZOOM_X_INCREMENT;
											m_nZoomX = max(0, min(m_nZoomX, xRange));

											HRESULT hr = m_pPlayer->Trick_Zoom(m_nZoomX, m_nZoomY, 0.0);
											ResetCenterPoint();
										}
									}
									else if (((lMode == DPM_PAUSED) || (lMode == DPM_STILL) ||
										(!m_bZoomed && (lMode == DPM_TRICKPLAY))) && (dom != DVD_DOMAIN_FirstPlay))
									{
										ResetOSD(&IDS_FRAMEREV, true, false, OSD_DISPLAY_TIME);
										m_pPlayer->Trick_FrameBackward();
									}
									else if(m_pPlayer->IsPlaying())
									{
										if (!(uops & UOP_PREV_TOP_PG_SEARCH))
										{
											WCHAR chChapText[64];
											DVD_PLAYBACK_LOCATION2 dvdLoc;

											if (S_OK == m_pPlayer->GetCurrentLocation(&dvdLoc))
											{
												if ((dvdLoc.TitleNum > 0) && (dvdLoc.ChapterNum > 1))
												{
													int nChap = max(1, dvdLoc.ChapterNum - 1);

													wsprintfW(chChapText, L"Title %d\nChapter %d", dvdLoc.TitleNum, nChap);
													ResetOSD((WCHAR*) &chChapText, true, false, OSD_DISPLAY_TIME);

												}
											}
											m_pPlayer->PreviousChapter();
										}
									}
								}
							}
						}
						break;

			// MENU RIGHT ACTION
			case XB_DPAD_RIGHT:
						{
							ULONG uops;
							if(S_OK == m_pPlayer->GetCurrentUOPS(&uops))
							{
								if(!(uops & UOP_BUTTON))
								{
									m_pPlayer->SelectRelativeButton(DVD_Relative_Right);
								}
								else
								{
									DVDPlayerMode lMode = m_pPlayer->GetPlayerMode();

									DVD_DOMAIN dom;
									m_pPlayer->GetCurrentDomain(&dom);

									if (m_bZoomed)
									{
										WORD wX, wY;
										float fScaleFactor;

										if (S_OK == m_pPlayer->Get_CurrentScaleFactor(fScaleFactor))
										{
											m_pPlayer->Get_VideoSize(wX, wY);

											fScaleFactor = max(1, fScaleFactor);

											WORD xRange = (float) wX * (1.0 - (1.0/fScaleFactor));
											m_nZoomX += ZOOM_X_INCREMENT;
											m_nZoomX = max(0, min(m_nZoomX, xRange));

											HRESULT hr = m_pPlayer->Trick_Zoom(m_nZoomX, m_nZoomY, 0.0);
											ResetCenterPoint();
										}
									}
									else if (((lMode == DPM_PAUSED) || (lMode == DPM_STILL) ||
										(!m_bZoomed && (lMode == DPM_TRICKPLAY))) && (dom != DVD_DOMAIN_FirstPlay))
									{
										ResetOSD(&IDS_FRAMEFWD, true, false, OSD_DISPLAY_TIME);
										m_pPlayer->Trick_FrameForward();
									}
									else if(m_pPlayer->IsPlaying())
									{
										if (!(uops & UOP_NEXT_PG_SEARCH))
										{
											WCHAR chChapText[64];
											DVD_PLAYBACK_LOCATION2 dvdLoc;

											if (S_OK == m_pPlayer->GetCurrentLocation(&dvdLoc))
											{
												if ((dvdLoc.TitleNum > 0) && (dvdLoc.ChapterNum > 0))
												{
													// NOT DONE - need to compare to num of chapters in title
													int nChap = dvdLoc.ChapterNum + 1;

													ULONG lChapsInTitle = 0;
													if (m_pPlayer->GetNumberOfChapters(dvdLoc.TitleNum,
														&lChapsInTitle) != S_OK)
															lChapsInTitle = 0;

													if (nChap <= lChapsInTitle)
													{
														wsprintfW(chChapText, L"Title %d\nChapter %d",
															dvdLoc.TitleNum, nChap);
														ResetOSD((WCHAR*) &chChapText, true, false, OSD_DISPLAY_TIME);
													}
												}
											}
											m_pPlayer->NextChapter();
										}
									}
								}
							}
						}
						break;

			// RESUME ACTION
			case XB_START:
						{
							ULONG uops;
							if(S_OK == m_pPlayer->GetCurrentUOPS(&uops))
							{
								if(!(uops & UOP_BUTTON))
								{
									m_pPlayer->Resume();

								}
								else if (!(uops & UOP_TITLE_PLAY))
								{
									ResetOSD(&IDS_PLAY, true, false, OSD_DISPLAY_TIME);
									m_pPlayer->Play();
								}
							}
						}
						break;

			// GO UP(RETURN) OR EXIT ACTION
			case XB_BACK:
						{
							ULONG uops;
							if(S_OK == m_pPlayer->GetCurrentUOPS(&uops))
							{
								if(!(uops & UOP_GO_UP))

								{
//										ResetOSD(IDS_RETURN, true, false, 1);
									m_pPlayer->ReturnFromSubmenu();
								}
								else
									ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
							}
							else
							{
								// Exit(0);
							}
						}
						break;

			case XB_LTHUMB:
						break;

			case XB_RTHUMB:
						break;

			default:	break;
		}

		if(m_bLThumbStickOn)
		{
			DVD_DOMAIN domain;
			if (S_OK == m_pPlayer->GetCurrentDomain(&domain) && (domain != DVD_DOMAIN_Stop))
			{
				WORD wX, wY;
				float fScaleFactor;
				if (S_OK == m_pPlayer->Get_CurrentScaleFactor(fScaleFactor))
				{
					m_pPlayer->Get_VideoSize(wX, wY);

					fScaleFactor = max(1, fScaleFactor);

					WORD xRange = (float) wX * (1.0 - (1.0/fScaleFactor));
					WORD yRange = (float) wY * (1.0 - (1.0/fScaleFactor));

					if ((m_fLThumbStickX <= -0.75) || (m_fLThumbStickX >= 0.75))
					{
						m_nZoomX = (m_fLThumbStickX <= -0.75) ? m_nZoomX - ZOOM_X_INCREMENT:
							m_nZoomX + ZOOM_X_INCREMENT;
					}

					if ((m_fLThumbStickY <= -0.75) || (m_fLThumbStickY >= 0.75))
					{
						m_nZoomY = (m_fLThumbStickY <= -0.75) ? m_nZoomY + ZOOM_Y_INCREMENT:
							m_nZoomY - ZOOM_Y_INCREMENT;
					}

					m_nZoomX = max(0, min(m_nZoomX, xRange));
					m_nZoomY = max(0, min(m_nZoomY, yRange));

					ResetCenterPoint();

					HRESULT hr = m_pPlayer->Trick_Zoom(m_nZoomX, m_nZoomY, m_nZoomW, m_nZoomH);
				}
			}
		}

		if(m_bRThumbStickOn)
		{
			DVD_DOMAIN domain;
			if (S_OK == m_pPlayer->GetCurrentDomain(&domain) && (domain != DVD_DOMAIN_Stop))
			{
				if ((m_fRThumbStickY <= -0.75) || (m_fRThumbStickY >= 0.75))
				{
					// calc x and y zoom increment based on w/h ratio
					// this assures we get a smooth zoom with as little bob as possible due to scaling
					WORD wX, wY;
					if (S_OK == m_pPlayer->Get_VideoSize(wX, wY))
					{
						if (!m_nZoomW) // width/height not yet set
							{
								m_nZoomW = wX;
								m_nZoomH = wY;
							}

						// reduce the w/h ratio and use a multiple of those numbers as the base increment
						int wNum, wDen;

						if ((wX) && (wY))
						{
							ReduceRatio(wX, wY, wNum, wDen);

							UINT nZoomYInc = wDen * 4;
							UINT nZoomXInc = wNum * 4;

							// minimum width is 2 x Increment, maximum is full width
							m_nZoomW = (m_fRThumbStickY <= -0.75) ?
								min(m_nZoomW + nZoomXInc, wX) :
								max(m_nZoomW - nZoomXInc, nZoomXInc * 2);

							// minimum Height is 2 x Increment, maximum is full height
							m_nZoomH = (m_fRThumbStickY <= -0.75) ?
								min(m_nZoomH + nZoomYInc, wY) :
								max(m_nZoomH - nZoomYInc, nZoomYInc * 2);

							// x position depends on our new width
							WORD xRange = (float) wX - m_nZoomW;

							// y position depends on our new height
							WORD yRange = (float) wY - m_nZoomH;

							if (0 == xRange)
								ResetZoomVariables();
							else
								m_bZoomed = true;

							// maintain the fixed center point until user pans
							if ((!m_CenterPoint.x) && (!m_CenterPoint.y))
								ResetCenterPoint();

							m_nZoomX = m_CenterPoint.x - (m_nZoomW / 2.0f);
							m_nZoomY = m_CenterPoint.y - (m_nZoomH / 2.0f);

							m_nZoomX = max(0, min(m_nZoomX, xRange));
							m_nZoomY = max(0, min(m_nZoomY, yRange));

							HRESULT hr = m_pPlayer->Trick_Zoom(m_nZoomX, m_nZoomY, m_nZoomW, m_nZoomH);
						}
					}
				}
			}
		}
	}
}

void CRavDvdApp::DrawOsd()
{
	if(m_bShowOSDText)
	{
		if (wcscmp(m_pOSDTextBuf, IDS_NOTPERMITTED) == 0)
		{
			m_NotPermitted.Render();
		}
		else if (wcscmp(m_pOSDTextBuf, IDS_BOOKMARK) == 0)
		{
			m_BookmarkOSD.Render();
		}
		else
			m_Font.DrawText( OSD_ACTION_LEFT, OSD_ACTION_TOP, 0xffffffff, (WCHAR*) m_pOSDTextBuf);
	}

	if(m_bShowScanSpeed)
	{
		m_Font.DrawText( OSD_SCAN_LEFT, OSD_SCAN_TOP, 0xffffffff, (WCHAR*) m_pScanSpeedTextBuf);
	}

	if (m_bDisplayTime)
	{
		WCHAR chTime[256];
		DVD_PLAYBACK_LOCATION2 dvdLoc;

		if (m_pPlayer)
		{
			if (S_OK == m_pPlayer->GetCurrentLocation(&dvdLoc))
			{
				if ((dvdLoc.TitleNum > 0) && (dvdLoc.ChapterNum > 0))
				{
					wsprintfW(chTime, L"%02d:%02d:%02d", dvdLoc.TimeCode.bHours, dvdLoc.TimeCode.bMinutes,
							dvdLoc.TimeCode.bSeconds);
				}
				else
				{
					wsprintfW(chTime, L"--:--:--");
				}

				m_Font.DrawText( OSD_TIME_LEFT, OSD_TIME_TOP, 0xffffffff, (WCHAR*) chTime);
			}
		}
	}
}



//-----------------------------------------------------------------------------
// Name: Run()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CRavDvdApp::Render()
{

#if STRESS_TEST_RANDOM_SEEK
	DVD_PLAYBACK_LOCATION2 dvdLoc;
	static unsigned int count = 0;

	if (m_pPlayer && !(count++%120))
	{
		if (S_OK == m_pPlayer->GetCurrentLocation(&dvdLoc))
		{
			if ((dvdLoc.TitleNum > 0) && (dvdLoc.ChapterNum > 0))
			{
//				wsprintfW(chTime, L"%02d:%02d:%02d", dvdLoc.TimeCode.bHours, dvdLoc.TimeCode.bMinutes,
//						dvdLoc.TimeCode.bSeconds);
				DVD_HMSF_TIMECODE time;
				if(S_OK == m_pPlayer->GetTotalTitleTime(&time, NULL, NULL) && (time.bMinutes || time.bHours))
				{
					static bool initRand = false;
					if(!initRand)
					{
						srand(1);
						initRand = true;
					}else
					{
//						srand(rand());
					}

					unsigned long nTime, tTime = time.bHours * 3600 + time.bMinutes * 60 + time.bSeconds;

					nTime = (tTime * rand()) / RAND_MAX;

					if((tTime - nTime) < 3)
					{
						nTime -= 3;
					}

					time.bHours = nTime / 3600;
					nTime %= 3600;
					time.bMinutes = nTime / 60;
					nTime %= 60;
					time.bSeconds = nTime;

					if(DPM_PLAYING == m_pPlayer->GetPlayerMode())
					{
						m_pPlayer->TimeSearch(time.bHours, time.bMinutes, time.bSeconds);
#if _DEBUG
						char buf[MAX_PATH];
						wsprintf(buf, "Seeking to time %d:%d:%d\n", time.bHours, time.bMinutes, time.bSeconds);
						OutputDebugString(buf);
#endif _DEBUG
					}
				}
			}
		}
	}
#endif

//	Sleep(20);
	m_pd3dDevice->BlockUntilVerticalBlank();

	if(m_bShowOSDText)
	{
		float fCurTime = XBUtil_Timer(TIMER_GETAPPTIME);
		if(fCurTime >= m_fOSDDisplayTime)
		{
			m_bShowOSDText = false;
		}
	}

	if (PARENTAL_LEVEL_NOCHANGE != m_dwNewParentalLevel)
		HandleParentalLevelChange();

	if (m_ABRepeat.fABRepeatState == ABREPEAT_A_AND_B_SET)
	{
		DVD_PLAYBACK_LOCATION2 dvdLoc;

		if (S_OK == m_pPlayer->GetCurrentLocation(&dvdLoc))
		{
			DWORD dwCurrent	= (dvdLoc.TimeCode.bHours << 24) + (dvdLoc.TimeCode.bMinutes << 16) +
				(dvdLoc.TimeCode.bSeconds << 8) + (dvdLoc.TimeCode.bFrames);
			DWORD dwBLoc	= (m_ABRepeat.LocB.TimeCode.bHours << 24) + (m_ABRepeat.LocB.TimeCode.bMinutes << 16) +
				(m_ABRepeat.LocB.TimeCode.bSeconds << 8) + (m_ABRepeat.LocB.TimeCode.bFrames);

			if (dwCurrent >= dwBLoc)
				m_pPlayer->Defrost(m_ABRepeat.FreezeDataA.pData,
					m_ABRepeat.FreezeDataA.dwSize);
		}
	}

	for(int i=0; i<4; i++)
	{
		#ifdef _DEBUG
			if(m_GamePads[i].wPressedButtons)
			{
				char buf[256];
				wsprintf(buf,"wPressedButtons: %d\n", m_GamePads[i].wPressedButtons);
				OutputDebugString(buf);
			}

			if(m_GamePads[i].wButtons)
			{
				char buf[256];
				wsprintf(buf,"wButtons: %d\n", m_GamePads[i].wButtons);
				OutputDebugString(buf);
			}
		#endif


		// first see if we're in an app menu
		bool bReturn = false;
		XBRavMenu* curMenu = XBRavMenu::GetActiveMenu();

		if(XBRavMenu::IsActive())
		{
			DWORD dwMenuCommand = curMenu->ProcessGamePadInput(&m_GamePads[i]);

			if (dwMenuCommand == MENU_ACTIVATE || dwMenuCommand == MENU_BACK)
				{
				curMenu->ProcessCommand(MENU_BACK);
				delete curMenu;
				curMenu = NULL;
				}
			else
				{
//				m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
//                         BACKGROUND_COLOR, 1.0f, 0L );
				curMenu->ProcessCommand(dwMenuCommand);
				}

			bReturn = true;
		}
		else
		{
			// determine if button or control has changed and perform necessary action
			DWORD dwInputAction = GET_INPUT_ACTION(&m_GamePads[i]);

			m_fLThumbStickX = m_GamePads[i].fX1;
			m_fLThumbStickY = m_GamePads[i].fY1;
			m_fRThumbStickX = m_GamePads[i].fX2;
			m_fRThumbStickY = m_GamePads[i].fY2;

			if(m_fLThumbStickX != 0.0 || m_fLThumbStickY != 0.0)
				m_bLThumbStickOn = true;
			else
				m_bLThumbStickOn = false;

			if(m_fRThumbStickX != 0.0 || m_fRThumbStickY != 0.0)
				m_bRThumbStickOn = true;
			else
				m_bRThumbStickOn = false;

			if (m_fParentalRightsTooLow)
			{
				// THH -- discard the button press if parental screen is displayed
				if (dwInputAction != XB_NO_INPUT)
				{
					m_pPlayer->SelectParentalLevel(8);
					m_fParentalRightsTooLow = false;

					if (m_pPlayer)
						m_pPlayer->Play();
				}
			}
			else
				ProcessGamePadInput(dwInputAction);
		}
	}

	m_pd3dDevice->BeginScene();

	if (m_fParentalRightsTooLow)
	{
		m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
							 0xFF000000, 1.0f, 0L );

		m_Font.DrawText( 155, 170, 0xffffffff, (WCHAR*) IDS_PARENTAL_WARNING);
		m_Font.DrawText( 184, 190, 0xffffffff, (WCHAR*) IDS_PARENTAL_WARNING2);
		m_Font.DrawText( 191, 292, 0xffffffff, (WCHAR*) IDS_PARENTAL_OVERRIDE);
	}
	else
	{
		DVD_DOMAIN domain;
		if (S_OK == m_pPlayer->GetCurrentDomain(&domain))
		{
			if (domain != DVD_DOMAIN_Stop)
			{
				BOOL bColorkeyEnabled = FALSE;
				if (S_OK == m_pPlayer->GetColorkeyStatus(bColorkeyEnabled))
				{
					if (bColorkeyEnabled)
					{
						if (g_fSettingsMenuActive)
						{
							m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
									 0xFF000000, 1.0f, 0L );

							m_pd3dDevice->Clear( 1L, &MENU_RECT, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
										 RAV_COLORKEY, 1.0f, 0L );
						}
						else
							m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
								 RAV_COLORKEY, 1.0f, 0L );
					}
					else
						m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
								 0xFF000000, 1.0f, 0L );
				}
				else
					m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
							 0xFF000000, 1.0f, 0L );
			}
			else
			{
				m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
									 0xFF000000, 1.0f, 0L );
				if (!g_fSettingsMenuActive)
					m_Splash.Render();
			}
		}
		else
		{
			m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
								 0xFF000000, 1.0f, 0L );
			m_Splash.Render();
		}
	}

	if (m_nHelpScreen != HELP_OFF)
	{
		if (m_nHelpScreen == HELP_NORMAL)
		{
			m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS);
			m_Font.DrawText( 124, 390, 0xffffffff, (WCHAR*) NORMAL_HELP_TITLE);
		}
		else
		{
			m_Help.Render( &m_Font, g_ShiftHelpCallouts, NUM_SHIFT_HELP_CALLOUTS);
			m_Font.DrawText( 320, 370, 0xffffffff, (WCHAR*) SHIFT_HELP_TITLE1, XBFONT_CENTER_X);
			m_Font.DrawText( 320, 392, 0xffffffff, (WCHAR*) SHIFT_HELP_TITLE2, XBFONT_CENTER_X);
			m_Font.DrawText( 320, 414, 0xffffffff, (WCHAR*) SHIFT_DEFINITION, XBFONT_CENTER_X);
		}
	}
    else
    {
		// we need to draw the OSD even if a menu is up, in case the time display is showing
		DrawOsd();

		// is a menu still active?
		if(XBRavMenu::IsActive())
			XBRavMenu::GetActiveMenu()->Render();
	}

	m_pd3dDevice->EndScene();

	if (g_fSettingsMenuActive && (!g_fScaledDestination) && XBRavMenu::IsActive())
	{
		m_pPlayer->SetDestinationRect(MENU_RECT.x1, MENU_RECT.y1, MENU_RECT.x2-MENU_RECT.x1,
			MENU_RECT.y2-MENU_RECT.y1);
		g_fScaledDestination = true;
	}
	else if(!XBRavMenu::IsActive())
	{
		if (g_fScaledDestination)
		{
			g_theApp->m_pPlayer->SetDestinationRect(MENU_RECT.x1, MENU_RECT.y1, 0, 0);
			g_fScaledDestination = false;
		}
		g_fSettingsMenuActive = false;
	}

	return S_OK;
}


void  WINAPI DVDEventHandler(DWORD dwEvent, DWORD dwInfo)
{
	// put application responses to various events here
	switch (dwEvent)
	{
		case (EC_DVD_TITLE_CHANGE):
							g_theApp->ResetZoomVariables();
							OutputDebugString("DVDEventHandler: EC_DVD_TITLE_CHANGE\n");
							break;

		case (EC_DVD_CHAPTER_START):
							OutputDebugString("DVDEventHandler: EC_DVD_CHAPTER_START\n");
							break;

		case (EC_DVD_VALID_UOPS_CHANGE):
							OutputDebugString("DVDEventHandler: EC_DVD_VALID_UOPS_CHANGE\n");
							break;

		case (EC_DVD_AUDIO_STREAM_CHANGE):
							OutputDebugString("DVDEventHandler: EC_DVD_AUDIO_STREAM_CHANGE\n");
							break;

		case (EC_DVD_SUBPICTURE_STREAM_CHANGE):
							OutputDebugString("DVDEventHandler: EC_DVD_SUBPICTURE_STREAM_CHANGE\n");
							break;

		case (EC_DVD_DOMAIN_CHANGE):
							OutputDebugString("DVDEventHandler: EC_DVD_DOMAIN_CHANGE\n");
							g_theApp->ResetZoomVariables();
							g_theApp->ResetScanSpeed(true, true);
							break;

		case (EC_DVD_PARENTAL_LEVEL_CHANGE):
							OutputDebugString("DVDEventHandler: EC_DVD_PARENTAL_LEVEL_CHANGE\n");
							g_theApp->m_dwNewParentalLevel = dwInfo;
							break;

		case (EC_DVD_STILL_ON):
							OutputDebugString("DVDEventHandler: EC_DVD_STILL_ON\n");
							break;

		case (EC_DVD_STILL_OFF):
							OutputDebugString("DVDEventHandler: EC_DVD_STILL_OFF\n");
							break;

		case (EC_DVD_PLAYBACK_STOPPED):
							OutputDebugString("DVDEventHandler: EC_DVD_PLAYBACK_STOPPED\n");
							g_theApp->ResetZoomVariables();
							g_theApp->ResetScanSpeed(true, true);
							g_theApp->ResetMenus();
							break;

		case (EC_DVD_ERROR):
							switch(dwInfo)
							{
								case GNR_PARENTAL_LEVEL_TOO_LOW:
									g_theApp->m_fParentalRightsTooLow = true;
									break;
							}
							OutputDebugString("DVDEventHandler: EC_DVD_ERROR\n");
							break;

		case (EC_DVD_PLAYBACK_RATE_CHANGE):
							OutputDebugString("DVDEventHandler: EC_DVD_PLAYBACK_RATE_CHANGE\n");
							if (dwInfo == 1000)
							{
								// we're back to normal speed because of domain change so we must
								// reset any scanning that may have been going on
								g_theApp->ResetScanSpeed(true, true);
							}
							break;

		case (EC_ERRORABORT):
							OutputDebugString("DVDEventHandler: EC_ERRORABORT\n");
							break;

		case (EC_DVD_DISPLAY_MODE_CHANGE):
							OutputDebugString("DVDEventHandler: EC_DVD_DISPLAY_MODE_CHANGE\n");
							break;

		case (EC_DVD_PLAYPERIOD_AUTOSTOP):
							OutputDebugString("DVDEventHandler: EC_DVD_PLAYPERIOD_AUTOSTOP\n");
							break;
		default:
							break;
	}
}


//-----------------------------------------------------------------------------
// Name: VBlankCallback
// Desc: This routine is called at the beginning of the vertical blank.
//-----------------------------------------------------------------------------
void __cdecl VBlankCallback(D3DVBLANKDATA *pData)
{
	g_dwVBCount++;
}


DWORD ChapterMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	int nChapter = ((XBRavMenu*)(it->menu))->GetItemIndex(it) + 1;

	if(g_theApp->m_pPlayer)
	{
		g_theApp->m_pPlayer->PlayChapterInTitle(g_curTitle, nChapter);
	}

	if(it->menu->parent)
	{
		delete ((XBRavMenu*)it->menu->parent);
		it->menu->parent = NULL;
	}

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}

DWORD TitleMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	int nTitle = ((XBRavMenu*)(it->menu))->GetItemIndex(it) + 1;

	g_curTitle = nTitle;

	if(g_theApp->m_pPlayer)
	{
		ULONG nChapters = 0;
		g_theApp->m_pPlayer->GetNumberOfChapters(nTitle, &nChapters);
		if(nChapters > 1)
		{
			XBRavMenu * chaptMenu = new XBRavMenu(NULL, 320.0f, 100.0f,
						nChapters, MENU_WRAP, (DWORD*)ChapterMenuProc, (XBRavMenu*)(it->menu) );

			for(int i = 0; i<nChapters; i++)
			{
			    WCHAR strChaptName[MAX_PATH];

				wsprintfW(strChaptName, L"Chapter %d", i+1);

				chaptMenu->AddItem(MITEM_ROUTINE, strChaptName, &ChapterMenuProc);
			}

			DVD_PLAYBACK_LOCATION2 loc;

			if (S_OK == g_theApp->m_pPlayer->GetCurrentLocation(&loc) && nTitle == loc.TitleNum && loc.ChapterNum < nChapters)
			{
				chaptMenu->curitem = loc.ChapterNum - 1;
			}

			((XBRavMenu*)(it->menu))->Activate(false);
			chaptMenu->Activate();
			return MROUTINE_ABORT;
		}
		else
		{
			g_theApp->m_pPlayer->PlayTitle(nTitle);
//			delete ((XBRavMenu*)(it->menu));
			return MROUTINE_DIE;
		}
	}

	return MROUTINE_DIE;
}

DWORD AudioMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	int nAudioStream = ((XBRavMenu*)(it->menu))->GetItemIndex(it);

	// set audio stream
	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SelectAudioStream(nAudioStream);

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}

DWORD SubpicMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	int nSubpicStream = ((XBRavMenu*)(it->menu))->GetItemIndex(it);

	if(g_theApp->m_pPlayer)
	{
		ULONG lNumSubpic, lCurSubpic;
		BOOL bEnabled;

		g_theApp->m_pPlayer->GetCurrentSubpicture(&lNumSubpic, &lCurSubpic, &bEnabled);

		if (nSubpicStream < lNumSubpic)
			g_theApp->m_pPlayer->SelectSubpictureStream(nSubpicStream);
		else
			g_theApp->m_pPlayer->SetSubpictureState(FALSE);
	}

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}

DWORD AngleMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	int nAngleStream = ((XBRavMenu*)(it->menu))->GetItemIndex(it);

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SelectAngle(nAngleStream+1);		// angle is 1-based

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}

DWORD ParentalControlMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	int nAudioStream = ((XBRavMenu*)(it->menu))->GetItemIndex(it);

	// set audio stream
	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SelectAudioStream(nAudioStream);

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}

DWORD BookmarkMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	int nBookmark = ((XBRavMenu*)(it->menu))->GetItemIndex(it);

	if (g_theApp->m_Bookmarks[nBookmark].Loc.TitleNum > 0)
	{
		g_theApp->m_pPlayer->Defrost(g_theApp->m_Bookmarks[nBookmark].FreezeData.pData,
			g_theApp->m_Bookmarks[nBookmark].FreezeData.dwSize);
	}

	return MROUTINE_DIE;
}



#include "library\hardware\audio\generic\ac3setup.h"

DWORD AudioDynRngMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	AC3DynamicRange drm = (AC3DynamicRange) ((XBRavMenu*)(it->menu))->GetItemIndex(it);

	if(g_theApp->m_pPlayer && drm <= AC3DYNRG_TV)
		g_theApp->m_pPlayer->SetAudioDynRngCompMode(drm);
	else
		g_theApp->m_pPlayer->SetAudioDynRngCompMode((AC3DynamicRange) -1);

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}

DWORD AudioDownmixModeMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	WORD value = (WORD) ((XBRavMenu*)(it->menu))->GetItemIndex(it);

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SetSpeakerOutputMode(value);


	return MROUTINE_DIE;
}

#if ENABLE_DMM_SETTINGS
DWORD AudioDualModeMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	AC3DualModeConfig dm = (AC3DualModeConfig) ((XBRavMenu*)(it->menu))->GetItemIndex(it);

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SetAudioDualMode(dm);

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}
#endif ENABLE_DMM_SETTINGS

//DWORD AudioSPDIFOutMenuProc(DWORD cmd, XMenuItem *it)
//{
//	if(it == NULL)
//		return -1;
//
//	SPDIFOutputMode som = (SPDIFOutputMode) ((XBRavMenu*)(it->menu))->GetItemIndex(it);
//
//	if(g_theApp->m_pPlayer)
//		g_theApp->m_pPlayer->SetAudioSpdifOutMode(som);
//
////	delete ((XBRavMenu*)(it->menu));
////	g_theApp->m_bDeleteMenusOnStop = true;
//	return MROUTINE_DIE;
//}

DWORD AudioLFEMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	BOOL lfe = (BOOL) ((XBRavMenu*)(it->menu))->GetItemIndex(it);

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SetAudioLFEMode(lfe);

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}

DWORD AudioDiagNormMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	AC3DialogNorm dnm = (AC3DialogNorm) ((XBRavMenu*)(it->menu))->GetItemIndex(it);

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SetAudioDialogNormMode(dnm);

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}

DWORD AudioCompModeMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	AC3OperationalMode opm = (AC3OperationalMode) ((XBRavMenu*)(it->menu))->GetItemIndex(it);

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SetAudioCompMode(opm);

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}

DWORD AudioCompSFHighMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	WORD sfh = 5000 * (((XBRavMenu*)(it->menu))->GetItemIndex(it)); // scale goes from 0 to 0x100

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SetAudioCompSFHigh(sfh);

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}

DWORD AudioCompSFLowMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	WORD sfl = 5000 * (((XBRavMenu*)(it->menu))->GetItemIndex(it)); // scale goes from 0 to 0x100

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SetAudioCompSFLow(sfl);

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}


#define NUM_SETTINGS_MENU_ITEMS 15
#define MENU_BACK_COLOR			0xff7e9f71
//#define MENU_BACK_COLOR			0xff005500
#define MENU_HIGHLIGHT_COLOR	0xffcedfad
//#define MENU_HIGHLIGHT_COLOR	0xff333333
#define MENU_TEXT_COLOR			0xffffffff
//#define MENU_TEXT_COLOR			RAV_COLORKEY


DWORD DolbySettingsMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	XBRavMenu * pSubMenu, * pCallingMenu = (XBRavMenu*)it->menu;
	XBMenuProfile profile;

	profile.title[0]			= NULL;
	profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
	profile.flags				= MENU_WRAP | MENU_RIGHT;
	profile.hideparent			= false;
	profile.showbackground		= true;
	profile.showhighlight		= true;
	profile.showtextedge		= false;
	profile.topcolor			= MENU_BACK_COLOR;
	profile.bottomcolor			= MENU_BACK_COLOR;
	profile.itemcolor			= MENU_TEXT_COLOR;
	profile.seltopcolor			= MENU_HIGHLIGHT_COLOR;
	profile.selbotcolor			= MENU_HIGHLIGHT_COLOR;


	WORD posX, posY;

	posX = pCallingMenu->GetX() + pCallingMenu->GetW() + 2;
	posY = pCallingMenu->GetY(); // temp fix while font size is miss reported...

	switch(pCallingMenu->GetItemIndex(it))
	{
		case 0://Dynamic Range Control
		{
			pSubMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)AudioDynRngMenuProc, pCallingMenu);

			pSubMenu->AddItem(MITEM_ROUTINE, L"Standard - Def", (DWORD*)AudioDynRngMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Maximum", (DWORD*)AudioDynRngMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Minimum", (DWORD*)AudioDynRngMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"\"TV Style\"", (DWORD*)AudioDynRngMenuProc);
			pSubMenu->AddItem(MITEM_DISABLED, L"Unknown", (DWORD*)AudioDynRngMenuProc);

			AC3DynamicRange drm;

			if(g_theApp->m_pPlayer->GetAudioDynRngCompMode(drm) == S_OK)
			{
				if((int) drm == -1)
					pSubMenu->curitem = pSubMenu->nitems - 1;
				else if((DWORD) drm < pSubMenu->nitems)
					pSubMenu->curitem = (DWORD) drm;
			}
			else
			{
				OutputDebugString("VDR call to get audio setting failed.");
			}
			break;
		}
		case 1://downmix
		{
			pSubMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)AudioDownmixModeMenuProc, pCallingMenu);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Surround (LtRt) - Def", (DWORD*)AudioDownmixModeMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Stereo (LoRo)", (DWORD*)AudioDownmixModeMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Mono", (DWORD*)AudioDownmixModeMenuProc);

			AC3SpeakerConfig dmm;

			if(g_theApp->m_pPlayer->GetAudioDownmixMode(dmm) == S_OK)
			{
				if(dmm == AC3SC_20_NORMAL)
					pSubMenu->curitem = (DWORD) 1;
				else if(dmm == AC3SC_10)
					pSubMenu->curitem = (DWORD) 2;
				else
					pSubMenu->curitem = (DWORD) 0;
			}
			else
			{
				OutputDebugString("VDR call to get audio setting failed.");
			}
			break;
		}
#if ENABLE_DMM_SETTINGS
		case 2://output mode
		{
			pSubMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)AudioDualModeMenuProc, pCallingMenu);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Stereo - Def", (DWORD*)AudioDualModeMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Left", (DWORD*)AudioDualModeMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Right", (DWORD*)AudioDualModeMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Mix", (DWORD*)AudioDualModeMenuProc);

			AC3DualModeConfig dm;

			if(g_theApp->m_pPlayer->GetAudioDualMode(dm) == S_OK && (DWORD) dm < pSubMenu->nitems)
			{
				pSubMenu->curitem = (DWORD) dm;
			}
			else
			{
				OutputDebugString("VDR call to get audio setting failed.");
			}
			break;
		}
#endif ENABLE_DMM_SETTINGS
/*		case 3://SPDIF out Mode
		{
			pSubMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)AudioSPDIFOutMenuProc, pCallingMenu);
			pSubMenu->AddItem(MITEM_ROUTINE, L"AC3", (DWORD*)AudioSPDIFOutMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"PCM - Def", (DWORD*)AudioSPDIFOutMenuProc);

			SPDIFOutputMode som;

//			g_theApp->m_bDeleteMenusOnStop = false; // set back to true in AudioSPDIFOutMenuProc callback

			if(g_theApp->m_pPlayer->GetAudioSpdifOutMode(som) == S_OK && (DWORD) som < pSubMenu->nitems)
			{
				pSubMenu->curitem = (DWORD) som;
			}
			else
			{
				OutputDebugString("VDR call to get audio setting failed.");
			}
			break;
		}
*/
#if ENABLE_DMM_SETTINGS
		case 4://LFE Mode
#else
		case 3://LFE Mode
#endif ENABLE_DMM_SETTINGS
		{
			pSubMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)AudioLFEMenuProc, pCallingMenu);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Off - Def", (DWORD*)AudioLFEMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"On", (DWORD*)AudioLFEMenuProc);

			BOOL lfe;

			if(g_theApp->m_pPlayer->GetAudioLFEMode(lfe) == S_OK && (DWORD) lfe < pSubMenu->nitems)
			{
				pSubMenu->curitem = (DWORD) lfe;
			}
			else
			{
				OutputDebugString("VDR call to get audio setting failed.");
			}
			break;
		}
#if ENABLE_DMM_SETTINGS
		case 5://dialog normalization
#else
		case 4://dialog normalization
#endif ENABLE_DMM_SETTINGS
		{
			pSubMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)AudioDiagNormMenuProc, pCallingMenu);
			pSubMenu->AddItem(MITEM_ROUTINE, L"On - Def", (DWORD*)AudioDiagNormMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Off", (DWORD*)AudioDiagNormMenuProc);

			AC3DialogNorm dn;
			if(g_theApp->m_pPlayer->GetAudioDialogNormMode(dn) == S_OK && (DWORD) dn < pSubMenu->nitems)
			{
				pSubMenu->curitem = (DWORD) dn;
			}
			else
			{
				OutputDebugString("VDR call to get audio setting failed.");
			}
			break;
		}
#if ENABLE_DMM_SETTINGS
		case 6://compression
#else
		case 5://compression
#endif ENABLE_DMM_SETTINGS
		{
			pSubMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)AudioCompModeMenuProc, pCallingMenu);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Line - Def", (DWORD*)AudioCompModeMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"RF", (DWORD*)AudioCompModeMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Custom Mode 0", (DWORD*)AudioCompModeMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"Custom Mode 1", (DWORD*)AudioCompModeMenuProc);

			AC3OperationalMode opm;

			if(g_theApp->m_pPlayer->GetAudioCompMode(opm) == S_OK && (DWORD) opm < pSubMenu->nitems)
			{
				pSubMenu->curitem = (DWORD) opm;
			}
			else
			{
				OutputDebugString("VDR call to get audio setting failed.");
			}
			break;
		}
#if ENABLE_DMM_SETTINGS
		case 7://comp SF High
#else
		case 6://comp SF High
#endif ENABLE_DMM_SETTINGS
		{
			pSubMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)AudioCompSFHighMenuProc, pCallingMenu);
			pSubMenu->AddItem(MITEM_ROUTINE, L"0.0", (DWORD*)AudioCompSFHighMenuProc);
//			pSubMenu->AddItem(MITEM_ROUTINE, L"0.25", (DWORD*)AudioCompSFHighMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"0.5", (DWORD*)AudioCompSFHighMenuProc);
//			pSubMenu->AddItem(MITEM_ROUTINE, L"0.75", (DWORD*)AudioCompSFHighMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"1.0", (DWORD*)AudioCompSFHighMenuProc);

			WORD sfh;

			if(g_theApp->m_pPlayer->GetAudioCompSFHigh(sfh) == S_OK && (DWORD) (sfh / 5000) < pSubMenu->nitems)
			{
				pSubMenu->curitem = (DWORD) (sfh / 5000);
			}
			else
			{
				OutputDebugString("VDR call to get audio setting failed.");
			}
			break;
		}
#if ENABLE_DMM_SETTINGS
		case 8://comp SF Low
#else
		case 7://comp SF Low
#endif ENABLE_DMM_SETTINGS
		{
			pSubMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)AudioCompSFLowMenuProc, pCallingMenu);
			pSubMenu->AddItem(MITEM_ROUTINE, L"0.0", (DWORD*)AudioCompSFLowMenuProc);
//			pSubMenu->AddItem(MITEM_ROUTINE, L"0.25", (DWORD*)AudioCompSFLowMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"0.5", (DWORD*)AudioCompSFLowMenuProc);
//			pSubMenu->AddItem(MITEM_ROUTINE, L"0.75", (DWORD*)AudioCompSFLowMenuProc);
			pSubMenu->AddItem(MITEM_ROUTINE, L"1.0", (DWORD*)AudioCompSFLowMenuProc);

			WORD sfl;

			if(g_theApp->m_pPlayer->GetAudioCompSFLow(sfl) == S_OK && (DWORD) (sfl / 5000) < pSubMenu->nitems)
			{
				pSubMenu->curitem = (DWORD) (sfl / 5000);
			}
			else
			{
				OutputDebugString("VDR call to get audio setting failed.");
			}
			break;
		}
#if ENABLE_DMM_SETTINGS
		case 9:// Exit Menu
#else
		case 8:// Exit Menu
#endif ENABLE_DMM_SETTINGS
		default:
		{
//			if (g_fScaledDestination)
//			{
//				g_theApp->m_pPlayer->SetDestinationRect(MENU_RECT.x1, MENU_RECT.y1, 0, 0);
//				g_fScaledDestination = false;
//			}
//			g_fSettingsMenuActive = false;
			return MROUTINE_DIE;
		}

	}

	((XBRavMenu*)((_xmenu*)pSubMenu)->parent)->Activate(false);
	pSubMenu->Activate();

//	if (g_fScaledDestination)
//	{
//		g_theApp->m_pPlayer->SetDestinationRect(MENU_RECT.x1, MENU_RECT.y1, 0, 0);
//		g_fScaledDestination = false;
//	}
//	g_fSettingsMenuActive = false;

	return MROUTINE_RETURN;
}

DWORD PresentationModeMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	DisplayPresentationMode mode = (DisplayPresentationMode) (((XBRavMenu*)(it->menu))->GetItemIndex(it)); // scale goes from 0 to 0x100

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SetDisplayMode(mode);

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}

void CRavDvdApp::DisplayPresentationModeMenu(XBRavMenu* parent)
{
	ULONG uops;
	if(m_pPlayer == NULL)
	{
		return;
	}

//	if(S_OK == m_pPlayer->GetCurrentUOPS(&uops))
//	{
//		if(!(uops & UOP_AUDIO_STREAM_CHANGE))
//		{
//			if (lNumAudio > 1)
//			{

				XBRavMenu*	pPModeMenu;
				XBMenuProfile profile;

				float posX, posY;

				if(parent != NULL)
				{
					wsprintfW(profile.title, L"Presentation Mode");
//					profile.title[0]			= NULL;
					profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
					profile.flags				= MENU_WRAP | MENU_RIGHT;
					profile.hideparent			= false;
					profile.showbackground		= true;
					profile.showhighlight		= true;
					profile.showtextedge		= false;
					profile.topcolor			= MENU_BACK_COLOR;
					profile.bottomcolor			= MENU_BACK_COLOR;
					profile.itemcolor			= MENU_TEXT_COLOR;
					profile.seltopcolor			= MENU_HIGHLIGHT_COLOR;
					profile.selbotcolor			= MENU_HIGHLIGHT_COLOR;

					posX = parent->GetX() + parent->GetW() + 2;
					posY = parent->GetY();

					parent->Activate(false);
				}
				else // Transparent Menu over video
				{
					profile.title[0]			= NULL;
					profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
					profile.flags				= MENU_WRAP;
					profile.hideparent			= true;
					profile.showbackground		= false;
					profile.showhighlight		= false;
					profile.showtextedge		= true;
					profile.topcolor			= RAV_COLORKEY;
					profile.bottomcolor			= RAV_COLORKEY;
					profile.itemcolor			= 0xff333333;
					profile.seltopcolor			= 0xffffffff;
					profile.selbotcolor			= 0xffffffff;

					posX = 320.0f;
					posY = 100.0f;
				}

				pPModeMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)NULL, parent);
//					XBRavMenu*	pSubpicMenu = new XBRavMenu(NULL, 320.0f, 100.0f,
//						lNumSubpic, MENU_WRAP, NULL);

				if (pPModeMenu)
				{
					pPModeMenu->AddItem(MITEM_ROUTINE, L"4 by 3", &PresentationModeMenuProc);
					pPModeMenu->AddItem(MITEM_ROUTINE, L"16 by 9", &PresentationModeMenuProc);
					pPModeMenu->AddItem(MITEM_ROUTINE, L"LetterBox", &PresentationModeMenuProc);
					pPModeMenu->AddItem(MITEM_ROUTINE, L"Pan and Scan", &PresentationModeMenuProc);
					pPModeMenu->AddItem(MITEM_ROUTINE, L"none", &PresentationModeMenuProc);

					pPModeMenu->curitem = (ULONG) m_pPlayer->GetDisplayMode();
					pPModeMenu->Activate();
				}
//			}
//			else
//			{
//				ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
//			}
//		}
//		else
//		{
//			ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
//		}
//	}
}

DWORD RegionMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	BYTE region = (BYTE) (((XBRavMenu*)(it->menu))->GetItemIndex(it));

	if(g_theApp->m_pPlayer)
	{
		g_theApp->m_bDeleteMenusOnStop = false;

		if(region == 0x00)
			g_theApp->m_pPlayer->SetSystemRegion('D', (BYTE)0x3f); // region free, set all 6 region bits
		else
			g_theApp->m_pPlayer->SetSystemRegion('D', (BYTE)~(1 << (region-1)));

		g_theApp->m_bDeleteMenusOnStop = true;
	}

//	delete ((XBRavMenu*)(it->menu));
	return MROUTINE_DIE;
}

void CRavDvdApp::DisplayRegionMenu(XBRavMenu* parent)
{
	ULONG uops;
	if(m_pPlayer == NULL)
	{
		return;
	}
//	if(S_OK == m_pPlayer->GetCurrentUOPS(&uops))
//	{
//		if(!(uops & UOP_AUDIO_STREAM_CHANGE))
//		{
//			if (lNumAudio > 1)
//			{

				XBRavMenu*	pRegionMenu;
				XBMenuProfile profile;

				float posX, posY;

				if(parent != NULL)
				{
					wsprintfW(profile.title, L"Region");
//					profile.title[0]			= NULL;
					profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
					profile.flags				= MENU_WRAP | MENU_RIGHT;
					profile.hideparent			= false;
					profile.showbackground		= true;
					profile.showhighlight		= true;
					profile.showtextedge		= false;
					profile.topcolor			= MENU_BACK_COLOR;
					profile.bottomcolor			= MENU_BACK_COLOR;
					profile.itemcolor			= MENU_TEXT_COLOR;
					profile.seltopcolor			= MENU_HIGHLIGHT_COLOR;
					profile.selbotcolor			= MENU_HIGHLIGHT_COLOR;

					posX = parent->GetX() + parent->GetW() + 2;
					posY = parent->GetY();

					parent->Activate(false);
				}
				else // Transparent Menu over video
				{
					profile.title[0]			= NULL;
					profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
					profile.flags				= MENU_WRAP;
					profile.hideparent			= true;
					profile.showbackground		= false;
					profile.showhighlight		= false;
					profile.showtextedge		= true;
					profile.topcolor			= RAV_COLORKEY;
					profile.bottomcolor			= RAV_COLORKEY;
					profile.itemcolor			= 0xff333333;
					profile.seltopcolor			= 0xffffffff;
					profile.selbotcolor			= 0xffffffff;

					posX = 320.0f;
					posY = 100.0f;
				}

				pRegionMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)NULL, parent);
//					XBRavMenu*	pSubpicMenu = new XBRavMenu(NULL, 320.0f, 100.0f,
//						lNumSubpic, MENU_WRAP, NULL);

				if (pRegionMenu)
				{
					pRegionMenu->AddItem(MITEM_ROUTINE, L"Region Free", &RegionMenuProc);
					pRegionMenu->AddItem(MITEM_ROUTINE, L"Region 1", &RegionMenuProc);
					pRegionMenu->AddItem(MITEM_ROUTINE, L"Region 2", &RegionMenuProc);
					pRegionMenu->AddItem(MITEM_ROUTINE, L"Region 3", &RegionMenuProc);
					pRegionMenu->AddItem(MITEM_ROUTINE, L"Region 4", &RegionMenuProc);
					pRegionMenu->AddItem(MITEM_ROUTINE, L"Region 5", &RegionMenuProc);
					pRegionMenu->AddItem(MITEM_ROUTINE, L"Region 6", &RegionMenuProc);

					BYTE region, mask = 0x00;
					if(m_pPlayer->GetSystemRegion('D', mask) == S_OK)
					{

						if(mask == 0x00)
						{
							region = 0x00;
						}
						else
						{
							region = ~mask;
//							BYTE temp = ~mask;
//							BYTE count = 0x01;
//							region = 0x00;
//							while(temp > 0x00 && region == 0x00)
//							{
//								if(temp & 0x01)
//								{
//									region = count;
//								}
//								else
//								{
//									count++;
//									temp = temp>>1;
//								}
//							}

						}

						char buf[MAX_PATH];
						wsprintf(buf, "GetSystemRegion return mask = %x, region = %x", mask, region);
						OutputDebugString(buf);

						if(region <= 6)
						{
							pRegionMenu->curitem = (ULONG) region;
						}
					}

					pRegionMenu->Activate();
				}
//			}
//			else
//			{
//				ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
//			}
//		}
//		else
//		{
//			ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
//		}
//	}
}


void CRavDvdApp::DisplayDolbySettingsMenu(XBRavMenu* parent)
{
}

DWORD SpeakerOutputModeMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	WORD config = (WORD) ((XBRavMenu*)(it->menu))->GetItemIndex(it);

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SetSpeakerOutputMode( config ); // 0x0000 == stereo, 0x0001 == stereo, 0x0002 == surround.

	return MROUTINE_DIE;
}

void CRavDvdApp::DisplaySpeakerOutputModeMenu(XBRavMenu* parent)
{
	ULONG uops;
	if(m_pPlayer == NULL)
	{
		return;
	}

	XBRavMenu*	pPModeMenu;
	XBMenuProfile profile;

	float posX, posY;

	if(parent != NULL)
	{
		wsprintfW(profile.title, L"Speaker Output Mode");
		profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
		profile.flags				= MENU_WRAP | MENU_RIGHT;
		profile.hideparent			= false;
		profile.showbackground		= true;
		profile.showhighlight		= true;
		profile.showtextedge		= false;
		profile.topcolor			= MENU_BACK_COLOR;
		profile.bottomcolor			= MENU_BACK_COLOR;
		profile.itemcolor			= MENU_TEXT_COLOR;
		profile.seltopcolor			= MENU_HIGHLIGHT_COLOR;
		profile.selbotcolor			= MENU_HIGHLIGHT_COLOR;

		posX = parent->GetX() + parent->GetW() + 2;
		posY = parent->GetY();

		parent->Activate(false);
	}
	else // Transparent Menu over video
	{
		profile.title[0]			= NULL;
		profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
		profile.flags				= MENU_WRAP;
		profile.hideparent			= true;
		profile.showbackground		= false;
		profile.showhighlight		= false;
		profile.showtextedge		= true;
		profile.topcolor			= RAV_COLORKEY;
		profile.bottomcolor			= RAV_COLORKEY;
		profile.itemcolor			= 0xff333333;
		profile.seltopcolor			= 0xffffffff;
		profile.selbotcolor			= 0xffffffff;

		posX = 320.0f;
		posY = 100.0f;
	}

	pPModeMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)NULL, parent);

	if (pPModeMenu)
	{
//		pPModeMenu->AddItem(MITEM_ROUTINE, L"5.1 Surround - AC3", &SpeakerOutputModeMenuProc);
//		pPModeMenu->AddItem(MITEM_ROUTINE, L"5.1 Surround - DTS", &SpeakerOutputModeMenuProc);
		pPModeMenu->AddItem(MITEM_ROUTINE, L"Stereo", &SpeakerOutputModeMenuProc);
		pPModeMenu->AddItem(MITEM_ROUTINE, L"Mono", &SpeakerOutputModeMenuProc);
		pPModeMenu->AddItem(MITEM_ROUTINE, L"Surround", &SpeakerOutputModeMenuProc);

		WORD config;
		if( !FAILED(m_pPlayer->GetSpeakerOutputMode( config )) )
		{
			pPModeMenu->curitem = (ULONG) config;
		}
		pPModeMenu->Activate();
	}
}

DWORD DigitalDTSMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	WORD curConfig = 0x0000;

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->GetDigitalOutputMode( curConfig );

	curConfig &= ~(XC_AUDIO_FLAGS_ENABLE_DTS >> 16);

	WORD config = (WORD) (((XBRavMenu*)(it->menu))->GetItemIndex(it)) << 1; // 0 -> 0, 0x0001 -> 0x0002

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SetDigitalOutputMode( config | curConfig ); // 0x0000 == PCM, 0x0001 == DTS, 0x0002 == AC3


	return MROUTINE_DIE;
}

void CRavDvdApp::DisplayDigitalDTSMenu(XBRavMenu* parent)
{
	ULONG uops;
	if(m_pPlayer == NULL)
	{
		return;
	}

	XBRavMenu*	pPModeMenu;
	XBMenuProfile profile;

	float posX, posY;

	if(parent != NULL)
	{
		wsprintfW(profile.title, L"Digital DTS Mode");
		profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
		profile.flags				= MENU_WRAP | MENU_RIGHT;
		profile.hideparent			= false;
		profile.showbackground		= true;
		profile.showhighlight		= true;
		profile.showtextedge		= false;
		profile.topcolor			= MENU_BACK_COLOR;
		profile.bottomcolor			= MENU_BACK_COLOR;
		profile.itemcolor			= MENU_TEXT_COLOR;
		profile.seltopcolor			= MENU_HIGHLIGHT_COLOR;
		profile.selbotcolor			= MENU_HIGHLIGHT_COLOR;

		posX = parent->GetX() + parent->GetW() + 2;
		posY = parent->GetY();

		parent->Activate(false);
	}
	else // Transparent Menu over video
	{
		profile.title[0]			= NULL;
		profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
		profile.flags				= MENU_WRAP;
		profile.hideparent			= true;
		profile.showbackground		= false;
		profile.showhighlight		= false;
		profile.showtextedge		= true;
		profile.topcolor			= RAV_COLORKEY;
		profile.bottomcolor			= RAV_COLORKEY;
		profile.itemcolor			= 0xff333333;
		profile.seltopcolor			= 0xffffffff;
		profile.selbotcolor			= 0xffffffff;

		posX = 320.0f;
		posY = 100.0f;
	}

	pPModeMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)NULL, parent);

	if (pPModeMenu)
	{
//		pPModeMenu->AddItem(MITEM_ROUTINE, L"5.1 Surround - AC3", &PresentationModeMenuProc);
//		pPModeMenu->AddItem(MITEM_ROUTINE, L"5.1 Surround - DTS", &PresentationModeMenuProc);
		pPModeMenu->AddItem(MITEM_ROUTINE, L"Disabled", &DigitalDTSMenuProc);
		pPModeMenu->AddItem(MITEM_ROUTINE, L"Enabled (Content Dependent)", &DigitalDTSMenuProc);

		WORD config;
		if( !FAILED(m_pPlayer->GetDigitalOutputMode( config )) )
		{
			pPModeMenu->curitem = ((ULONG) config & (XC_AUDIO_FLAGS_ENABLE_DTS >> 16) >> 1);
		}
		pPModeMenu->Activate();
	}
}

DWORD DigitalAC3MenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	WORD curConfig = 0x0000;

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->GetDigitalOutputMode( curConfig );

	curConfig &= ~(XC_AUDIO_FLAGS_ENABLE_AC3 >> 16);

	WORD config = (WORD) (((XBRavMenu*)(it->menu))->GetItemIndex(it));

	if(g_theApp->m_pPlayer)
		g_theApp->m_pPlayer->SetDigitalOutputMode( config | curConfig ); // 0x0000 == PCM, 0x0001 == AC3, 0x0002 == DTS

	return MROUTINE_DIE;
}

void CRavDvdApp::DisplayDigitalAC3Menu(XBRavMenu* parent)
{
	ULONG uops;
	if(m_pPlayer == NULL)
	{
		return;
	}

	XBRavMenu*	pPModeMenu;
	XBMenuProfile profile;

	float posX, posY;

	if(parent != NULL)
	{
		wsprintfW(profile.title, L"Digital Output On/Off");
		profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
		profile.flags				= MENU_WRAP | MENU_RIGHT;
		profile.hideparent			= false;
		profile.showbackground		= true;
		profile.showhighlight		= true;
		profile.showtextedge		= false;
		profile.topcolor			= MENU_BACK_COLOR;
		profile.bottomcolor			= MENU_BACK_COLOR;
		profile.itemcolor			= MENU_TEXT_COLOR;
		profile.seltopcolor			= MENU_HIGHLIGHT_COLOR;
		profile.selbotcolor			= MENU_HIGHLIGHT_COLOR;

		posX = parent->GetX() + parent->GetW() + 2;
		posY = parent->GetY();

		parent->Activate(false);
	}
	else // Transparent Menu over video
	{
		profile.title[0]			= NULL;
		profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
		profile.flags				= MENU_WRAP;
		profile.hideparent			= true;
		profile.showbackground		= false;
		profile.showhighlight		= false;
		profile.showtextedge		= true;
		profile.topcolor			= RAV_COLORKEY;
		profile.bottomcolor			= RAV_COLORKEY;
		profile.itemcolor			= 0xff333333;
		profile.seltopcolor			= 0xffffffff;
		profile.selbotcolor			= 0xffffffff;

		posX = 320.0f;
		posY = 100.0f;
	}

	pPModeMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)NULL, parent);

	if (pPModeMenu)
	{
		pPModeMenu->AddItem(MITEM_ROUTINE, L"Disabled", &DigitalAC3MenuProc);
		pPModeMenu->AddItem(MITEM_ROUTINE, L"Enabled (Content Dependent)", &DigitalAC3MenuProc);

		WORD config;
		if( !FAILED(m_pPlayer->GetDigitalOutputMode( config )) )
		{
			pPModeMenu->curitem = ((ULONG) (config & (XC_AUDIO_FLAGS_ENABLE_AC3 >> 16)));
		}
		pPModeMenu->Activate();
	}
}

DWORD GlobalSettingsMenuProc(DWORD cmd, XMenuItem *it)
{
	if(it == NULL)
		return -1;

	XBRavMenu * pCallingMenu = (XBRavMenu*)it->menu;

	switch(pCallingMenu->GetItemIndex(it))
	{
		case 0:// Audio Stream
		{
			g_theApp->DisplayAudioStreamMenu(pCallingMenu);
			break;
		}
		case 1:// Subpicture Stream
		{
			g_theApp->DisplaySubpictureStreamMenu(pCallingMenu);
			break;
		}
		case 2:// Dolby Settings
		{
			g_theApp->DisplayDolbySettingsMenu(pCallingMenu);
			break;
		}
		case 3:// Presentation Mode
		{
			g_theApp->DisplayPresentationModeMenu(pCallingMenu);
			break;
		}
		case 4:// Region
		{
			g_theApp->DisplayRegionMenu(pCallingMenu);
			break;
		}
		case 5:// Speaker Out Mode
		{
			g_theApp->DisplaySpeakerOutputModeMenu(pCallingMenu);
			break;
		}
		case 6:// Digital DTS
		{
			g_theApp->DisplayDigitalDTSMenu(pCallingMenu);
			break;
		}
		case 7:// Digital AC3
		{
			g_theApp->DisplayDigitalAC3Menu(pCallingMenu);
			break;
		}
		default: // Kill Menu
		{
			if (g_fScaledDestination)
			{
				g_theApp->m_pPlayer->SetDestinationRect(MENU_RECT.x1, MENU_RECT.y1, 0, 0);
				g_fScaledDestination = false;
			}
			g_fSettingsMenuActive = false;
			return MROUTINE_DIE;
		}
	}

	return MROUTINE_RETURN;
}

void CRavDvdApp::DisplayGlobalSettingsMenu(XBRavMenu* parent)
{
	ULONG uops;

//	if (S_OK == m_pPlayer->GetCurrentUOPS(&uops))
//	{
//		if (!(uops & UOP_TITLE_PLAY))
//		{
			XBRavMenu*	pSettingsMenu = NULL;
			XBMenuProfile profile;


			MultiByteToWideChar(CP_ACP,0,"ST DVD Settings",-1,profile.title, MAX_PATH);
//			profile.title				= L"Dolby Audio Settings";
			profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
			profile.flags				= MENU_WRAP | MENU_RIGHT;
			profile.hideparent			= false;
			profile.showbackground		= true;
			profile.showhighlight		= true;
			profile.showtextedge		= false;
			profile.topcolor			= MENU_BACK_COLOR;
			profile.bottomcolor			= MENU_BACK_COLOR;
			profile.itemcolor			= MENU_TEXT_COLOR;
			profile.seltopcolor			= MENU_HIGHLIGHT_COLOR;
			profile.selbotcolor			= MENU_HIGHLIGHT_COLOR;

			pSettingsMenu = new XBRavMenu(&profile, 30.0f, 30.0f, (DWORD*)GlobalSettingsMenuProc);
//				pSettingsMenu = new XBRavMenu(L"Dolby Audio Settings", 30.0f, 30.0f, NUM_SETTINGS_MENU_ITEMS, MENU_WRAP | MENU_RIGHT, (DWORD*)SettingsMenuProc,
//					MENU_BACK_COLOR, MENU_BACK_COLOR, MENU_TEXT_COLOR, MENU_HIGHLIGHT_COLOR, MENU_HIGHLIGHT_COLOR);
			if (pSettingsMenu)
			{

				pSettingsMenu->AddItem(MITEM_ROUTINE, L"Audio Stream", &GlobalSettingsMenuProc);
				pSettingsMenu->AddItem(MITEM_ROUTINE, L"Subpicture Stream", &GlobalSettingsMenuProc);
				pSettingsMenu->AddItem(MITEM_ROUTINE, L"Dolby Settings", &GlobalSettingsMenuProc);
				pSettingsMenu->AddItem(MITEM_ROUTINE, L"Presentation Mode", &GlobalSettingsMenuProc);
				pSettingsMenu->AddItem(MITEM_ROUTINE, L"Region", &GlobalSettingsMenuProc);
				pSettingsMenu->AddItem(MITEM_ROUTINE, L"Speaker Output Config", &GlobalSettingsMenuProc);
				pSettingsMenu->AddItem(MITEM_ROUTINE, L"Digital DTS Mode", &GlobalSettingsMenuProc);
				pSettingsMenu->AddItem(MITEM_ROUTINE, L"Digital AC3 Mode", &GlobalSettingsMenuProc);
				pSettingsMenu->AddItem(MITEM_ROUTINE, L"Exit", &GlobalSettingsMenuProc);
				pSettingsMenu->Activate();

				g_fSettingsMenuActive = true;
				g_fScaledDestination = false;
			}
//		}
//	}
}

void CRavDvdApp::DisplayTitleMenu(XBRavMenu* parent)
{
	ULONG uops, lNumTitles = m_pPlayer->GetNumberOfTitles();

	if (S_OK == m_pPlayer->GetCurrentUOPS(&uops))
	{
		if (!(uops & UOP_TITLE_PLAY))
		{
			if (lNumTitles > 0)
			{
				XBRavMenu*	pTitleMenu = NULL;

				pTitleMenu = new XBRavMenu(NULL, 320.0f, 100.0f,
					lNumTitles, MENU_WRAP, (DWORD*)TitleMenuProc);
				if (pTitleMenu)
				{
					for(unsigned long i = 0; i < lNumTitles; i++)
					{
						// add text description
			    		WCHAR strTitleName[MAX_PATH];

						wsprintfW(strTitleName, L"Title %d", i+1);

						pTitleMenu->AddItem(MITEM_ROUTINE, strTitleName, &TitleMenuProc);
					}

					DVD_PLAYBACK_LOCATION2 loc;
					loc.TitleNum = 0;

					if (S_OK == m_pPlayer->GetCurrentLocation(&loc) && loc.TitleNum < lNumTitles)
					{
						if(loc.TitleNum == 0)
							pTitleMenu->curitem = 0;
						else
							pTitleMenu->curitem = loc.TitleNum - 1;
					}

					pTitleMenu->Activate();
				}
			}
			else
				ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
		}
		else
			ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
	}
	else
		ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
}

// show subpicture menu
void CRavDvdApp::DisplaySubpictureStreamMenu(XBRavMenu* parent)
{
	ULONG lNumSubpic, lCurSubpic, uops;
	BOOL bEnabled;

	if(m_pPlayer == NULL)
	{
		return;
	}

	m_pPlayer->GetCurrentSubpicture(&lNumSubpic, &lCurSubpic, &bEnabled);

	if (S_OK == m_pPlayer->GetCurrentUOPS(&uops))
	{
		if (!(uops & UOP_SUB_PICTURE_STREAM_CHANGE))
		{
			if (lNumSubpic > 0)
			{

				XBRavMenu*	pSubpicMenu;
				XBMenuProfile profile;

				float posX, posY;

				if(parent != NULL)
				{
					wsprintfW(profile.title, L"SubPicture Selection");
					profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
					profile.flags				= MENU_WRAP | MENU_RIGHT;
					profile.hideparent			= false;
					profile.showbackground		= true;
					profile.showhighlight		= true;
					profile.showtextedge		= false;
					profile.topcolor			= MENU_BACK_COLOR;
					profile.bottomcolor			= MENU_BACK_COLOR;
					profile.itemcolor			= MENU_TEXT_COLOR;
					profile.seltopcolor			= MENU_HIGHLIGHT_COLOR;
					profile.selbotcolor			= MENU_HIGHLIGHT_COLOR;

					posX = parent->GetX() + parent->GetW() + 2;
					posY = parent->GetY();

					parent->Activate(false);
				}
				else // Transparent Menu over video
				{
					profile.title[0]			= NULL;
					profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
					profile.flags				= MENU_WRAP;
					profile.hideparent			= true;
					profile.showbackground		= false;
					profile.showhighlight		= false;
					profile.showtextedge		= true;
					profile.topcolor			= RAV_COLORKEY;
					profile.bottomcolor			= RAV_COLORKEY;
					profile.itemcolor			= 0xff333333;
					profile.seltopcolor			= 0xffffffff;
					profile.selbotcolor			= 0xffffffff;

					posX = 320.0f;
					posY = 100.0f;

				}

				pSubpicMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)NULL, parent);

//					XBRavMenu*	pSubpicMenu = new XBRavMenu(NULL, 320.0f, 100.0f,
//						lNumSubpic, MENU_WRAP, NULL);

				if (pSubpicMenu)
				{
					for(unsigned long i = 0; i < lNumSubpic; i++)
					{
						// add text description
			    		char strLangName[MAX_PATH];
			    		WCHAR wStrLangName[MAX_PATH];
				    	if (S_OK == m_pPlayer->GetSubpictureLanguage(i, strLangName, MAX_PATH))
						{
							MultiByteToWideChar(CP_ACP,0,strLangName,-1,wStrLangName, MAX_PATH);
							pSubpicMenu->AddItem(MITEM_ROUTINE, wStrLangName, &SubpicMenuProc);
						}
					}

					pSubpicMenu->AddItem(MITEM_ROUTINE, L"None", &SubpicMenuProc);

					if (bEnabled)
						pSubpicMenu->curitem = lCurSubpic;
					else
						pSubpicMenu->curitem = lNumSubpic;

					pSubpicMenu->Activate();
				}


			}
			else
			{
				ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
			}
		}
		else
		{
			ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
		}
	}
}

// show audio menu
void CRavDvdApp::DisplayAudioStreamMenu(XBRavMenu* parent)
{
	ULONG lNumAudio, lCurAudio, uops;
	if(m_pPlayer == NULL)
	{
		return;
	}
	m_pPlayer->GetCurrentAudio(&lNumAudio, &lCurAudio);

	if(S_OK == m_pPlayer->GetCurrentUOPS(&uops))
	{
		if(!(uops & UOP_AUDIO_STREAM_CHANGE))
		{
			if (lNumAudio > 1)
			{

				XBRavMenu*	pAudioMenu;
				XBMenuProfile profile;

				float posX, posY;

				if(parent != NULL)
				{
					wsprintfW(profile.title, L"Audio Selection");
					profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
					profile.flags				= MENU_WRAP | MENU_RIGHT;
					profile.hideparent			= false;
					profile.showbackground		= true;
					profile.showhighlight		= true;
					profile.showtextedge		= false;
					profile.topcolor			= MENU_BACK_COLOR;
					profile.bottomcolor			= MENU_BACK_COLOR;
					profile.itemcolor			= MENU_TEXT_COLOR;
					profile.seltopcolor			= MENU_HIGHLIGHT_COLOR;
					profile.selbotcolor			= MENU_HIGHLIGHT_COLOR;

					posX = parent->GetX() + parent->GetW() + 2;
					posY = parent->GetY();

					parent->Activate(false);
				}
				else // Transparent Menu over video
				{
					profile.title[0]			= NULL;
					profile.maxitems			= NUM_SETTINGS_MENU_ITEMS;
					profile.flags				= MENU_WRAP;
					profile.hideparent			= true;
					profile.showbackground		= false;
					profile.showhighlight		= false;
					profile.showtextedge		= true;
					profile.topcolor			= RAV_COLORKEY;
					profile.bottomcolor			= RAV_COLORKEY;
					profile.itemcolor			= 0xff333333;
					profile.seltopcolor			= 0xffffffff;
					profile.selbotcolor			= 0xffffffff;

					posX = 320.0f;
					posY = 100.0f;

				}

				pAudioMenu = new XBRavMenu(&profile, posX, posY, (DWORD*)NULL, parent);

//					XBRavMenu*	pSubpicMenu = new XBRavMenu(NULL, 320.0f, 100.0f,
//						lNumSubpic, MENU_WRAP, NULL);

				if (pAudioMenu)
				{
					for(unsigned long i = 0; i < lNumAudio; i++)
					{
						// add text description
			    		char strLangName[MAX_PATH];
			    		WCHAR wStrLangName[MAX_PATH];

				    	if (S_OK == m_pPlayer->GetAudioLanguage(i, strLangName, MAX_PATH))
						{
							MultiByteToWideChar(CP_ACP,0,strLangName,-1,wStrLangName, MAX_PATH);
							pAudioMenu->AddItem(MITEM_ROUTINE, wStrLangName, &AudioMenuProc);

						}


					}
					pAudioMenu->curitem = lCurAudio;
					pAudioMenu->Activate();
				}
			}
			else
			{
				ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
			}
		}
		else
		{
			ResetOSD(&IDS_NOTPERMITTED, true, false, OSD_NOTPERMITTED_DISPLAY_TIME);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\RavDvd.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// RavDvd.h : main header file for the RAVDVD application
//

#if !defined
#define AFX_RAVDVD_H__7D3E038B_A4E1_11D4_B8BE_0001031A0E82__INCLUDED_

#if _MSC_VER>1000
#pragma once
#endif // _MSC_VER > 1000

//#ifndef __AFXWIN_H__
//	#error include 'stdafx.h' before including this file for PCH
//#endif

#include "DVDMediaPlayer.h"
//#include "XBUtil.h"
#include <XBApp.h>
#include "XBUtil.h"
#include "XBRavMenu.h"
#include "XBTga.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] =
{
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, (WCHAR*) (L"Menu Navigation\nFrame Fwd/Rev") },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_1, (WCHAR*) (L"Stepped Zoom") },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_1, (WCHAR*) (L"Root Menu") },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, (WCHAR*) (L"Play/Pause/Enter") },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, (WCHAR*) (L"Stop") },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_1, (WCHAR*) (L"Display Time") },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_1, (WCHAR*) (L"Display Help") },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, (WCHAR*) (L"Resume/Play") },
    { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, (WCHAR*) (L"[Return] from \nSubmenu") },
	{ XBHELP_LEFTSTICK, XBHELP_PLACEMENT_1, (WCHAR*) (L"Pan") },
	{ XBHELP_RIGHTSTICK, XBHELP_PLACEMENT_1, (WCHAR*) (L"Continuous Zoom") }
//	{ XBHELP_LEFT_TRIGGER, XBHELP_PLACEMENT_1, _T("Previous \nChapter") },
//	{ XBHELP_RIGHT_TRIGGER, XBHELP_PLACEMENT_1, _T("Next Chapter") }
};

#define NUM_HELP_CALLOUTS 11

#define NORMAL_HELP_TITLE	L"GAME PAD FUNCTIONS FOR DVD PLAYER"
#define SHIFT_HELP_TITLE1	L"GAME PAD FUNCTIONS FOR DVD PLAYER"
#define SHIFT_HELP_TITLE2	L"WITH SHIFT BUTTON HELD"
#define SHIFT_DEFINITION	L"(SHIFT = LEFT TRIGGER UNDERNEATH PAD)"


XBHELP_CALLOUT g_ShiftHelpCallouts[] =
{
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_1, (WCHAR*) (L"Rev Scan") },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_1, (WCHAR*) (L"Subpic Menu") },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, (WCHAR*) (L"Audio Menu") },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, (WCHAR*) (L"Fwd Scan") },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_1, (WCHAR*) (L"Angle Menu") },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_1, (WCHAR*) (L"Dolby Settings") },
    { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, (WCHAR*) (L"Title Menu") },
};

#define NUM_SHIFT_HELP_CALLOUTS 7



#define BACKGROUND_COLOR		0x00000000
#define	PARENTAL_LEVEL_NOCHANGE	0xffffffff

#define OSD_DISPLAY_TIME	3
#define OSD_NOTPERMITTED_DISPLAY_TIME	2
#define ZOOM_Y_INCREMENT	3
#define ZOOM_X_INCREMENT	4

#define OSD_ACTION_TOP	50
#define OSD_ACTION_LEFT	64
#define OSD_SCAN_TOP	50
#define OSD_SCAN_LEFT	500
#define OSD_TIME_TOP	25
#define OSD_TIME_LEFT	500


// Normal Slowmotion and Fast motion speed tables
const double SLOW_SCAN_VALUES[] =
{
	0.75,
	0.5,
	0.25
};

const double FAST_SCAN_VALUES[] =
{
	1.25,
	1.5,
	2.0,
	10.0,
	20.0
};

#define NUM_FAST_MOTION  (sizeof(FAST_SCAN_VALUES)/sizeof(double))
#define NUM_SLOW_MOTION  (sizeof(SLOW_SCAN_VALUES)/sizeof(double))

enum
{
	SCAN_FWD,
	SCAN_REV,
	SCAN_OFF
};

enum
{
	HELP_NORMAL,
	HELP_SHIFT,
	HELP_OFF
};

#define SYSTEM_REGION	0xfe		// byte mask for region 1



#define    US_PARENTAL_NONE    8
#define    US_PARENTAL_NC17    7
#define    US_PARENTAL_R       6
#define    US_PARENTAL_PG13    4
#define    US_PARENTAL_PG      3
#define    US_PARENTAL_G       1

#define    UNSPEC_PARENTAL_NONE         9
#define    UNSPEC_PARENTAL_ADULT        8
#define    UNSPEC_PARENTAL_THEATRICAL   6
#define    UNSPEC_PARENTAL_KIDSSAFE     1

#define MKLANG(a, b)  ((WORD) a << 8 | (BYTE) b)

#define LCID_FRENCH			MKLANG('f', 'r')
#define LCID_SPANISH		MKLANG('e', 's')
#define LCID_ENGLISH		MKLANG('e', 'n')
#define ISO3166_US			0x5553

typedef struct tagSYSTEM_DEFAULTS
{
	LCID					AudioLanguage;
	DVD_AUDIO_LANG_EXT		AudioExt;
	LCID					SubpictureLanguage;
	DVD_SUBPICTURE_LANG_EXT	SubpictureExt;
	LCID					MenuLanguage;
	LCID					ParentalCountry;
	DWORD					ParentalLevel;
	DWORD					SubpictureState;
}	SYSTEM_DEFAULTS;

typedef struct tagFREEZE_DATA
{
	BYTE*					pData;
	DWORD					dwSize;
} FREEZE_DATA;


enum ABREPEAT_ENUM
{
	ABREPEAT_OFF,
	ABREPEAT_A_SET,
	ABREPEAT_A_AND_B_SET
};

typedef struct tagAB_REPEAT_DATA
{
	ABREPEAT_ENUM			fABRepeatState;
	FREEZE_DATA				FreezeDataA;
	DVD_PLAYBACK_LOCATION2	LocA;
	DVD_PLAYBACK_LOCATION2	LocB;
} AB_REPEAT_DATA;

typedef struct tagBOOKMARK_DATA
{
	FREEZE_DATA				FreezeData;
	DVD_PLAYBACK_LOCATION2	Loc;
} BOOKMARK_DATA;

const SYSTEM_DEFAULTS SystemDefaults =
{
	LCID_ENGLISH,				// Audio
//	LCID_FRENCH,				// Audio
	(DVD_AUDIO_LANG_EXT) 0xffff,	// Audio extension
	LANG_NEUTRAL,				// Subpic
//	LCID_SPANISH,				// Subpic
	DVD_SP_EXT_Caption_Big,		// Subpic extension
	LCID_ENGLISH,				// Menu
//	LCID_FRENCH,				// Menu
	ISO3166_US,					// Parental Country
	US_PARENTAL_G,				// Parental Level
	TRUE						// Subpicture state (TRUE = On)
};

//const D3DRECT MENU_RECT = { 320, 220, 620, 460 };
D3DRECT MENU_RECT = { 320, 220, 620, 460 };

/////////////////////////////////////////////////////////////////////////////
// CRavDvdApp:
// See RavDvd.cpp for the implementation of this class
//

//class CRavDvdApp : public CWinApp//, CXBApplication
class CRavDvdApp : public CXBApplication
{
public:
	CRavDvdApp();
	virtual ~CRavDvdApp();
    virtual HRESULT Initialize();
    virtual HRESULT Render();
    HRESULT Create();

	vector <BOOKMARK_DATA> m_Bookmarks;

	DVDMediaPlayer*			m_pPlayer;
	DWORD		m_dwNewParentalLevel;  // parental level change event must be handled asyncronously on a different thread
	bool		m_fParentalRightsTooLow;
    void ResetScanSpeed(bool bClearText, bool bClearData);
    void ResetZoomVariables();
	void ResetMenus();
	void ResetABRepeat();

	bool m_bDeleteMenusOnStop;

	void DisplayGlobalSettingsMenu(XBRavMenu* parent = NULL);
	void DisplayTitleMenu(XBRavMenu* parent = NULL);
	void DisplayAudioStreamMenu(XBRavMenu* parent = NULL);
	void DisplaySubpictureStreamMenu(XBRavMenu* parent = NULL);
	void DisplayDolbySettingsMenu(XBRavMenu* parent = NULL);
	void DisplayPresentationModeMenu(XBRavMenu* parent = NULL);
	void DisplayRegionMenu(XBRavMenu* parent = NULL);
	void DisplayDigitalDTSMenu(XBRavMenu* parent = NULL);
	void DisplayDigitalAC3Menu(XBRavMenu* parent = NULL);
	void DisplaySpeakerOutputModeMenu(XBRavMenu* parent = NULL);

private:
	void CreateMonitor();
	void ClearBookmarks();
	bool InitPlayer();
	void ProcessGamePadInput(DWORD dwInput);
	void HandleParentalLevelChange();
	void ResetCenterPoint();

	void ResetOSD(WCHAR* pOSDText, bool bShowOSDText, bool bShowScanSpeed, int nTimerIncrement);
	void DrawOsd();

    // The game controller
	LONGLONG	m_DiskID;
    XBGAMEPAD*  m_GamePads;
    CXBFont     m_Font;
	CXBFont		m_MenuFont;
	DWORD		m_dwMenuCommand;
    CXBHelp     m_Help;
    CXBSplash   m_Splash;
	CXBTga		m_NotPermitted;
	CXBTga		m_BookmarkOSD;

	char m_chLastVolName[MAX_PATH];
//	DVD_PLAYBACK_LOCATION2 m_LastDvdLoc;
	FREEZE_DATA m_LastDvdLoc;
	AB_REPEAT_DATA	m_ABRepeat;

    BOOL        m_bDrawHelp;
	BOOL		m_bShowOSDText;
	BOOL		m_bShowScanSpeed;
	double		m_dScanSpeed;
	int			m_nScanIndex;
	int			m_nScanDir;
	bool		m_bScanCycleUp;			// are we cycling up or down thru scan speeds
	WCHAR 		m_pOSDTextBuf[256];
	WCHAR		m_pScanSpeedTextBuf[256];
	BOOL		m_bDisplayTime;			// show DVD elapsed time/chapter info overtop video
	float		m_fOSDDisplayTime;
	bool		m_bZoomed;
	int			m_nZoomX, m_nZoomY, m_nZoomW, m_nZoomH;
	POINT		m_CenterPoint;
	float		m_fLThumbStickX, m_fLThumbStickY, m_fRThumbStickX, m_fRThumbStickY;
	bool		m_bLThumbStickOn, m_bRThumbStickOn;
	bool		m_bEnableScanAudio;
	bool		m_fPlayerIsOpen;
	int			m_nHelpScreen;

	UINT		m_uMaxWidth, m_uMaxHeight;
	UINT		m_uWideScreen;
	UINT		m_uProgressive;
};

#endif // !defined(AFX_RAVDVD_H__7D3E038B_A4E1_11D4_B8BE_0001031A0E82__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbfont.h ===
//-----------------------------------------------------------------------------
// File: XBFont.h
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFONT_H
#define XBFONT_H
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Number of vertex buffers for rendering text. Having this number be greater
// than 1 can reduce potential stalling of the GPU.
//-----------------------------------------------------------------------------
#define NUM_FONT_BUFFERS 2



//-----------------------------------------------------------------------------
// Flags for the CXBFont::DrawText() function
//-----------------------------------------------------------------------------
#define XBFONT_LEFT     0x00000000
#define XBFONT_RIGHT    0x00000001
#define XBFONT_CENTER_X 0x00000002
#define XBFONT_CENTER_Y 0x00000004




//-----------------------------------------------------------------------------
// Custom vertex type for rendering text
//-----------------------------------------------------------------------------
struct XBFONTVERTEX 
{ 
    D3DXVECTOR4 p;
    DWORD       color;
    FLOAT       tu, tv; 
};

#define D3DFVF_XBFONTVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom; // Texture coordinates for the image
    SHORT wOffset;                  // Pixel offset for glyph start
    SHORT wWidth;                   // Pixel width of the glyph
    SHORT wAdvance;                 // Pixels to advance after the glyph
};




//-----------------------------------------------------------------------------
// Name: class CXBFont
// Desc: Class to implement texture-based font rendering. A .tga image file of 
//       the pre-rendered font is used to create the texture. A .abc file
//       contains information for spacing the font characters (aka glyphs).
//-----------------------------------------------------------------------------
class CXBFont
{
public:
    // Font and texture dimensions
    DWORD         m_dwFontHeight;
    DWORD         m_dwTexWidth;
    DWORD         m_dwTexHeight;

    // Unicode ranges
    WCHAR         m_cLowChar;
    WCHAR         m_cHighChar;

    // Glyph data for the font
    DWORD         m_dwNumGlyphs;
    GLYPH_ATTR*   m_Glyphs;

    // D3D rendering objects
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVBs[NUM_FONT_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwCurrentBuffer;
    XBFONTVERTEX*           m_pVertices;
    DWORD                   m_dwNumQuads;
    DWORD                   m_dwNestedBeginCount;
    BOOL                    m_bTextureFromFile;

    // Internal call to trigger rendering of the vertex buffer
    HRESULT Render();

    // Access functions for debugging purposes
    LPDIRECT3DTEXTURE8 GetTexture() const    { return m_pTexture; }
    DWORD              GetFontHeight() const { return m_dwFontHeight; }

public:
    // Constructor/destructor
    CXBFont();
    ~CXBFont();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                    const CHAR* strFontResourceFileName );
    HRESULT Destroy();

    // Replaces invalid (outside the valid glyph range) characters in a string
    VOID    ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const;

    // Returns the dimensions of a text string
    HRESULT GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;

    // Function to create a texture containing rendered text
    LPDIRECT3DTEXTURE8 CreateTexture( const WCHAR* strText, 
                                      D3DCOLOR dwBackgroundColor = 0x00000000,
                                      D3DCOLOR dwTextColor = 0xffffffff,
                                      D3DFORMAT d3dFormat = D3DFMT_LIN_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multople calls together, bracketed by 
    // calls to Begin() and End().
    HRESULT Begin();
    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L );
    HRESULT End();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbapp.cpp ===
//-----------------------------------------------------------------------------
// File: XBApp.cpp
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       12.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBApp.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
CXBApplication*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;




//-----------------------------------------------------------------------------
// Name: CXBApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBApplication::CXBApplication()
{
    // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_bPaused         = FALSE;
    m_fTime           = 0.0f;
    m_fElapsedTime    = 0.0f;
    m_fAppTime        = 0.0f;
    m_fElapsedAppTime = 0.0f;
    m_fFPS            = 0.0f;
    m_strFrameRate[0] = L'\0';

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    m_dwNumInputDeviceTypes = 0;
    m_InputDeviceTypes      = NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT CXBApplication::Create()
{
    HRESULT hr;

    // Create the Direct3D object
    OutputDebugString( _T("XBApp: Creating Direct3D...\n") );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        OutputDebugString( _T("XBApp: Unable to create Direct3D!\n") );
        return E_FAIL;
    }

    // Create the device
    OutputDebugString( _T("XBApp: Creating the D3D device...\n") );
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        OutputDebugString( _T("XBApp: Could not create D3D device!\n") );
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Clear the backbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );

    // Create the gamepad devices
    OutputDebugString( _T("XBApp: Creating gamepad devices...\n") );
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        OutputDebugString( _T("XBApp: Call to CreateGamepads() failed!\n") );
        return hr;
    }

    // Initialize the app's device-dependent objects
    OutputDebugString( _T("XBApp: Initializing the app...\n") );
    if( FAILED( hr = Initialize() ) )
    {
        OutputDebugString( _T("XBApp: Call to Initialize() failed!\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID CXBApplication::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    SAFE_RELEASE( m_pd3dDevice );
    SAFE_RELEASE( m_pD3D );
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
INT CXBApplication::Run()
{
    OutputDebugString( _T("XBApp: Running the application...\n") );

    // Get the frequency of the timer
    LARGE_INTEGER qwTicksPerSec;
    QueryPerformanceFrequency( &qwTicksPerSec );
    FLOAT fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

    // Save the start time
    LARGE_INTEGER qwTime, qwLastTime, qwElapsedTime;
    QueryPerformanceCounter( &qwTime );
    qwLastTime.QuadPart = qwTime.QuadPart;

    LARGE_INTEGER qwAppTime, qwElapsedAppTime;
    qwAppTime.QuadPart        = 0;
    qwElapsedTime.QuadPart    = 0;
    qwElapsedAppTime.QuadPart = 0;

    // Run the game loop, animating and rendering frames
    while( TRUE )
    {
        //-----------------------------------------
        // Handle input
        //-----------------------------------------

        // Read the input for all connected gampads
        XBInput_GetInput( m_Gamepad );

        // Lump inputs of all connected gamepads into one common structure.
        // This is done so apps that need only one gamepad can function with
        // any gamepad.
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        for( DWORD i=0; i<4; i++ )
        {
            if( m_Gamepad[i].hDevice )
            {
                m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
                m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
                m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
                m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;
                m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
                m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
                m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
                m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
                m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
                m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
                m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

                for( DWORD b=0; b<8; b++ )
                {
                    m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                    m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                    m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
                }

                // Check if we need to alter the current rumble value
                if( ( m_Gamepad[i].Rumble.wLeftMotorSpeed   != m_Gamepad[i].Feedback.Rumble.wLeftMotorSpeed  ) || 
                    ( m_Gamepad[i].Rumble.wRightMotorSpeed  != m_Gamepad[i].Feedback.Rumble.wRightMotorSpeed ) )
                {
                    // Check to see if we are still transferring current motor
                    // value. If so, we can't update. so just ignore it
                    if( m_Gamepad[i].Feedback.Header.dwStatus != ERROR_IO_PENDING )
                    {
                        // We can alter the motor values
                        m_Gamepad[i].Feedback.Rumble.wLeftMotorSpeed  = m_Gamepad[i].Rumble.wLeftMotorSpeed;
                        m_Gamepad[i].Feedback.Rumble.wRightMotorSpeed = m_Gamepad[i].Rumble.wRightMotorSpeed;
                        XInputSetState( m_Gamepad[i].hDevice, &m_Gamepad[i].Feedback );
                    }
                }
            }
        }

        // Handle special input functions:
        // -  Both triggers and white button triggers a screen dump
        // -  Both triggers and black button triggers a reboot
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
            {
                // With white button, dump the backbuffer contents
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
                    XGWriteSurfaceToFile( m_pBackBuffer, "D:\\BackBuffer.bmp" );

                // With black button, reboot to the Xbox Dashboard
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                    XLaunchNewImage( NULL, NULL );
            }
        }

        //-----------------------------------------
        // Perform app timing
        //-----------------------------------------

        // Check Start button
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
            m_bPaused = !m_bPaused;

        // Get the current time (keep in LARGE_INTEGER format for precision)
        QueryPerformanceCounter( &qwTime );
        qwElapsedTime.QuadPart = qwTime.QuadPart - qwLastTime.QuadPart;
        qwLastTime.QuadPart    = qwTime.QuadPart;
        if( m_bPaused )
            qwElapsedAppTime.QuadPart = 0;
        else
            qwElapsedAppTime.QuadPart = qwElapsedTime.QuadPart;
        qwAppTime.QuadPart    += qwElapsedAppTime.QuadPart;

        // Store the current time values as floating point
        m_fTime           = fSecsPerTick * ((FLOAT)(qwTime.QuadPart));
        m_fElapsedTime    = fSecsPerTick * ((FLOAT)(qwElapsedTime.QuadPart));
        m_fAppTime        = fSecsPerTick * ((FLOAT)(qwAppTime.QuadPart));
        m_fElapsedAppTime = fSecsPerTick * ((FLOAT)(qwElapsedAppTime.QuadPart));

        // Compute the FPS (frames per second) once per second
        static FLOAT fLastTime = 0.0f;
        static DWORD dwFrames  = 0L;
        dwFrames++;

        if( m_fTime - fLastTime > 1.0f )
        {
            m_fFPS    = dwFrames / ( m_fTime - fLastTime );
            fLastTime = m_fTime;
            dwFrames  = 0L;
            swprintf( m_strFrameRate, L"%0.02f fps", m_fFPS );
        }

        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------

        // Frame move the scene
        FrameMove();

        // Render the scene
        Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return 0;
}




//-----------------------------------------------------------------------------
// Name: RenderGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT CXBApplication::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    m_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbhelp.h ===
//-----------------------------------------------------------------------------
// File: XBHelp.h
//
// Desc: Support class for rendering a help image, which is an image of an Xbox
//       gamepad, with labelled callouts to each of the gamepad's controls.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.06.01 - Changes for April XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBHELP_H
#define XBHELP_H
#include "XBFont.h"
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Name: struct XBHELP_CALLOUT
// Desc: Structure for callout information, used to label controls when
//       rendering an image of an Xbox gamepad. An app will define an array of
//       of these, one for each gamepad control used.
//-----------------------------------------------------------------------------
struct XBHELP_CALLOUT
{
    WORD     wControl;    // An index to identify a control, as enum'ed below
    WORD     wPlacement;  // An offset to pick from one of the possible placements
    WCHAR*   strText;     // Text to draw when rendering this callout
};




//-----------------------------------------------------------------------------
// Name: class CXBHelp
// Desc: Class for rendering a help image of a gamepad with labelled callouts.
//-----------------------------------------------------------------------------
class CXBHelp
{
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pGamepadTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVB;

public:
    // Constructor/destructor
    CXBHelp();
    ~CXBHelp();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* pResource );
    HRESULT Destroy();

    // Renders the help screen
    HRESULT Render( CXBFont* pFont, XBHELP_CALLOUT* tags, DWORD dwNumCallouts );
};




//-----------------------------------------------------------------------------
// A bunch of constants used to identify callout positions
//-----------------------------------------------------------------------------
enum
{   
    XBHELP_LEFTSTICK,
    XBHELP_LEFTSTICK_LINEEND_1, XBHELP_LEFTSTICK_TEXTPOS_1,
    XBHELP_LEFTSTICK_LINEEND_2, XBHELP_LEFTSTICK_TEXTPOS_2,

    XBHELP_RIGHTSTICK,
    XBHELP_RIGHTSTICK_LINEEND_1, XBHELP_RIGHTSTICK_TEXTPOS_1,
    XBHELP_RIGHTSTICK_LINEEND_2, XBHELP_RIGHTSTICK_TEXTPOS_2,

    XBHELP_DPAD,
    XBHELP_DPAD_LINEEND_1, XBHELP_DPAD_TEXTPOS_1,
    XBHELP_DPAD_LINEEND_2, XBHELP_DPAD_TEXTPOS_2,

    XBHELP_BACK_BUTTON,
    XBHELP_BACK_BUTTON_LINEEND_1, XBHELP_BACK_BUTTON_TEXTPOS_1,
    XBHELP_BACK_BUTTON_LINEEND_2, XBHELP_BACK_BUTTON_TEXTPOS_2,

    XBHELP_START_BUTTON,
    XBHELP_START_BUTTON_LINEEND_1, XBHELP_START_BUTTON_TEXTPOS_1,
    XBHELP_START_BUTTON_LINEEND_2, XBHELP_START_BUTTON_TEXTPOS_2,

    XBHELP_X_BUTTON,
    XBHELP_X_BUTTON_LINEEND_1, XBHELP_X_BUTTON_TEXTPOS_1,
    XBHELP_X_BUTTON_LINEEND_2, XBHELP_X_BUTTON_TEXTPOS_2,

    XBHELP_Y_BUTTON,
    XBHELP_Y_BUTTON_LINEEND_1, XBHELP_Y_BUTTON_TEXTPOS_1,
    XBHELP_Y_BUTTON_LINEEND_2, XBHELP_Y_BUTTON_TEXTPOS_2,

    XBHELP_A_BUTTON,
    XBHELP_A_BUTTON_LINEEND_1, XBHELP_A_BUTTON_TEXTPOS_1,
    XBHELP_A_BUTTON_LINEEND_2, XBHELP_A_BUTTON_TEXTPOS_2,

    XBHELP_B_BUTTON,
    XBHELP_B_BUTTON_LINEEND_1, XBHELP_B_BUTTON_TEXTPOS_1,
    XBHELP_B_BUTTON_LINEEND_2, XBHELP_B_BUTTON_TEXTPOS_2,

    XBHELP_WHITE_BUTTON,
    XBHELP_WHITE_BUTTON_LINEEND_1, XBHELP_WHITE_BUTTON_TEXTPOS_1,
    XBHELP_WHITE_BUTTON_LINEEND_2, XBHELP_WHITE_BUTTON_TEXTPOS_2,

    XBHELP_BLACK_BUTTON,
    XBHELP_BLACK_BUTTON_LINEEND_1, XBHELP_BLACK_BUTTON_TEXTPOS_1,
    XBHELP_BLACK_BUTTON_LINEEND_2, XBHELP_BLACK_BUTTON_TEXTPOS_2,

    XBHELP_LEFT_BUTTON,
    XBHELP_LEFT_BUTTON_LINEEND_1, XBHELP_LEFT_BUTTON_TEXTPOS_1,
    XBHELP_LEFT_BUTTON_LINEEND_2, XBHELP_LEFT_BUTTON_TEXTPOS_2,

    XBHELP_RIGHT_BUTTON,
    XBHELP_RIGHT_BUTTON_LINEEND_1, XBHELP_RIGHT_BUTTON_TEXTPOS_1,
    XBHELP_RIGHT_BUTTON_LINEEND_2, XBHELP_RIGHT_BUTTON_TEXTPOS_2,

    XBHELP_MISC_CALLOUT,
    XBHELP_MISC_CALLOUT_LINEEND_1, XBHELP_MISC_CALLOUT_TEXTPOS_1,
    XBHELP_MISC_CALLOUT_LINEEND_2, XBHELP_MISC_CALLOUT_TEXTPOS_2,
};




//-----------------------------------------------------------------------------
// Placement options for each callout, used as an offset into the enumerated
// list above.
//-----------------------------------------------------------------------------
#define XBHELP_PLACEMENT_CUSTOM 0   // For future implementation
#define XBHELP_PLACEMENT_1      1   // Callout has one line of text
#define XBHELP_PLACEMENT_2      2   // Callout has two lines of text




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbDVDStrings.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////



#define IDS_ROOTMENU	L"MENU"
#define IDS_ACTIVATE	L"ENTER"
#define IDS_PLAY		L"PLAY"
#define IDS_PAUSE		L"PAUSE"
#define IDS_STOP		L"STOP"
#define IDS_NEXT		L"NEXT"
#define IDS_PREV		L"PREV"
#define IDS_UP			L"UP"
#define IDS_DOWN		L"DOWN"
#define IDS_LEFT		L"LEFT"
#define IDS_RIGHT		L"RIGHT"
#define IDS_TITLEMENU	L"TITLEMENU"
#define IDS_RETURN		L"RETURN"
#define IDS_REVSCAN		L"SCANNING REV"
#define IDS_FWDSCAN		L"SCANNING FWD"
#define IDS_FRAMEREV	L"FRAME REV"
#define IDS_FRAMEFWD	L"FRAME FWD"
#define IDS_VOLUP		L"VOLUME UP"
#define IDS_VOLDOWN		L"VOLUME DOWN"
#define IDS_NOANGLE		L"NO ADDITIONAL ANGLES"
#define IDS_NOAUDIO		L"NO ADDITIONAL AUDIO STREAMS"
#define IDS_NOSUBPIC	L"NO ADDITIONAL SUBPICTURE STREAMS"
#define IDS_NOTPERMITTED L"NOT PERMITTED"
#define IDS_BOOKMARK	L"BOOKMARK"
#define IDS_SPACES		L"  "
#define IDS_A_DOWN		L"A/B REPEAT: A SET"
#define IDS_B_DOWN		L"A/B REPEAT: B SET"
#define IDS_AB_OFF		L"A/B REPEAT OFF"
#define IDS_ILLEGAL_AB	L"ILLEGAL A/B POINTS"

#define IDS_PARENTAL_WARNING L"The current parental level setting does"
#define IDS_PARENTAL_WARNING2 L"not allow this disc to be viewed"
#define IDS_PARENTAL_OVERRIDE L"[Press any button to override]"


#define IDS_AUD_VISUALLY_IMPAIRED	" (Visually Impaired Audio)"
#define IDS_AUD_DIRECTORS_COMMENTS	" Director's Comments"
#define IDS_SUBPIC_NORMAL			" (Normal)"
#define IDS_SUBPIC_BIG   			" (Big)"
#define IDS_SUBPIC_CHILDREN			" (Children)"
#define IDS_SUBPIC_CC_NORMAL		" (CC Normal)"
#define IDS_SUBPIC_CC_BIG   		" (CC Big)"
#define IDS_SUBPIC_CC_CHILDREN		" (CC Children)"
#define IDS_SUBPIC_FORCED     		" (Forced)"
#define IDS_SUBPIC_DIRECTORS_NORMAL	" (Director's Comments - Normal)"
#define IDS_SUBPIC_DIRECTORS_BIG	" (Director's Comments - Big)"
#define IDS_SUBPIC_DIRECTORS_CHILDREN	" (Director's Comments - Children)"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbfile.cpp ===
//-----------------------------------------------------------------------------
// File: XBFile.cpp
//
// Desc: Support code for loading DirectX .X files. During the file loading, 
//       a hierarchy of frames and meshes is built. The frame nodes can have
//       child nodes, thereby providing for a hierarchial structure, and
//       typically have a transformation matrix that is applied before it's
//       child nodes are rendered. The mesh nodes contain geometry that is
//       stored in a D3DXMesh object, which wraps a vertex buffer and
//       maintains a material list.
//
//       Note: the mesh code also supports loading .xbg files. These files are
//       more-or-less pure dumps of a vertex buffer and an index buffer for a
//       mesh, so they are trivial and fast to load. They are created with the
//       MakeXBG tool, found on the XDK.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include <rmxfguid.h>
#include <rmxftmpl.h>
#include <dxfile.h>
#include "XBFile.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Name: CXBGMesh()
// Desc: Mesh class constructor.
//-----------------------------------------------------------------------------
CXBGMesh::CXBGMesh()
{
    m_dwNumVertices = 0;
    m_dwNumIndices  = 0;
    m_dwNumSubsets  = 0;

    m_pSubsets      = NULL;
	m_dwRefCount    = 1;
}




//-----------------------------------------------------------------------------
// Name: ~CXBGMesh()
// Desc: Mesh class destructor.
//-----------------------------------------------------------------------------
CXBGMesh::~CXBGMesh()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys mesh objects
//-----------------------------------------------------------------------------
VOID CXBGMesh::Destroy()
{
    m_dwNumVertices = 0;
    m_dwNumIndices  = 0;
    m_dwNumSubsets  = 0;

    // Free subsets
    for( DWORD i=0; i < m_dwNumSubsets; i++ )
        SAFE_RELEASE( m_pSubsets[i].pTexture )
    if( m_pSubsets )
        delete[] m_pSubsets;

    // Free resources
    if( m_IB.Data )
        delete[] (WORD*)m_IB.Data;
    if( m_VB.Data )
        D3D_FreeContiguousMemory( (VOID*)(0x80000000|m_VB.Data) );
}




//-----------------------------------------------------------------------------
// Name: CreateFromXBG()
// Desc: Creates a mesh from a .XBG geometry. Note: .XBG files are made with
//       the MakeXBG tool.
//-----------------------------------------------------------------------------
HRESULT CXBGMesh::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename )
{
    // Find the media file
    CHAR strMeshPath[512];
    if( FAILED( XBUtil_FindMediaFile( strMeshPath, strFilename ) ) )
        return E_FAIL;

    // Open the file
    FILE* file = fopen( strMeshPath, "rb" );
    if( file == NULL )
        return E_FAIL;

    // Read the magic number
    DWORD dwFileID;
    fread( &dwFileID, 1, sizeof(DWORD), file ); 
    if( dwFileID != XBG_FILE_ID )
    {
        fclose( file );
        return E_FAIL;
    }

    // Read the mesh info
    fread( &m_VB, 1, sizeof(XBGMESH_INFO), file );

    // Read subsets
    m_pSubsets  = new XBGMESH_SUBSET[m_dwNumSubsets];
    fread( m_pSubsets, m_dwNumSubsets, sizeof(XBGMESH_SUBSET), file ); 

    // Read indices
    m_IB.Data  = (DWORD)new WORD[m_dwNumIndices];
    fread( (VOID*)m_IB.Data, m_dwNumIndices, sizeof(WORD), file ); 

    // Create the textures
    for( DWORD i=0; i < m_dwNumSubsets; i++ )
    {
        m_pSubsets[i].pTexture = NULL;

        CHAR strTextureName[512];
        fread( strTextureName, 1, sizeof(strTextureName), file ); 
        if( strTextureName[0] )
        {
            // Expand the path and create the texture
            CHAR strTexture[MAX_PATH];
            sprintf( strTexture, "Textures\\%s", strTextureName );
            XBUtil_CreateTexture( pd3dDevice, strTexture, &m_pSubsets[i].pTexture );
        }
    }

    // Read vertex buffer data from the file
    VOID* pVertexData = D3D_AllocContiguousMemory( m_dwNumVertices*m_dwVertexSize, D3DVERTEXBUFFER_ALIGNMENT );
    fread( pVertexData, m_dwNumVertices, m_dwVertexSize, file ); 
    m_VB.Register( pVertexData );

    // Close the file and return okay
    fclose( file );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the mesh geometry.
//-----------------------------------------------------------------------------
HRESULT CXBGMesh::Render( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFlags )
{
    // Set the object transform
    D3DXMATRIX matWorld, matWorldSaved;
    pd3dDevice->GetTransform( D3DTS_WORLD, &matWorldSaved );

    // Set the vertex stream
    pd3dDevice->SetStreamSource( 0, &m_VB, m_dwVertexSize );
    pd3dDevice->SetIndices( &m_IB, 0 );
    if( dwFlags & XBGMESH_USEMESHFVF )
        pd3dDevice->SetVertexShader( m_dwFVF );

    // Render the opqaue subsets
    if( dwFlags & XBGMESH_RENDEROPAQUESUBSETS )
    {
        for( DWORD i = 0; i < m_dwNumSubsets; i++ )
        {
            // Skip non-opaque meshes
            if( dwFlags & XBGMESH_USEMESHMATERIALS)
                if( m_pSubsets[i].mtrl.Diffuse.a < 1.0f )
                    continue;

            // Set world transform
            D3DXMATRIX matWorld;
            D3DXMatrixMultiply( &matWorld, &m_pSubsets[i].mat, &matWorldSaved );
            pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

            // Set the material
            if( dwFlags & XBGMESH_USEMESHMATERIALS )
                pd3dDevice->SetMaterial( &m_pSubsets[i].mtrl );

            // Set the texture
            if( dwFlags & XBGMESH_USEMESHTEXTURES )
                pd3dDevice->SetTexture( 0, m_pSubsets[i].pTexture );

            // Call the callback, so the app can tweak state before rendering
            // each subset
            BOOL bRenderSubset = RenderCallback( pd3dDevice, i, &m_pSubsets[i] );

            // Draw the mesh subset
            if( bRenderSubset )
            {
                DWORD dwNumPrimitives = ( D3DPT_TRIANGLESTRIP == m_dwPrimType ) ? m_pSubsets[i].dwIndexCount-2 : m_pSubsets[i].dwIndexCount/3;
                pd3dDevice->DrawIndexedPrimitive( m_dwPrimType, 0, m_pSubsets[i].dwIndexCount,
                                                  m_pSubsets[i].dwIndexStart, dwNumPrimitives );
            }
        }
    }

    // Render the transparent subsets
    if( dwFlags & XBGMESH_RENDERALPHASUBSETS )
    {
        if( dwFlags & XBGMESH_USEMESHMATERIALS)
        {
            for( DWORD i = 0; i < m_dwNumSubsets; i++ )
            {
                // Skip non-transparent meshes
                if( m_pSubsets[i].mtrl.Diffuse.a >= 1.0f )
                    continue;

                // Set world transform
                D3DXMATRIX matWorld;
                D3DXMatrixMultiply( &matWorld, &m_pSubsets[i].mat, &matWorldSaved );
                pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

                // Set the material
                if( dwFlags & XBGMESH_USEMESHMATERIALS )
                    pd3dDevice->SetMaterial( &m_pSubsets[i].mtrl );

                // Set the texture
                if( dwFlags & XBGMESH_USEMESHTEXTURES )
                    pd3dDevice->SetTexture( 0, m_pSubsets[i].pTexture );

                // Call the callback, so the app can tweak state before rendering
                // each subset
                BOOL bRenderSubset = RenderCallback( pd3dDevice, i, &m_pSubsets[i] );

                // Draw the mesh subset
                if( bRenderSubset )
                {
                    DWORD dwNumPrimitives = ( D3DPT_TRIANGLESTRIP == m_dwPrimType ) ? m_pSubsets[i].dwIndexCount-2 : m_pSubsets[i].dwIndexCount/3;
                    pd3dDevice->DrawIndexedPrimitive( m_dwPrimType, 0, m_pSubsets[i].dwIndexCount,
                                                      m_pSubsets[i].dwIndexStart, dwNumPrimitives );
                }
            }
        }
    }

    // Restore the world transform
    pd3dDevice->SetTransform( D3DTS_WORLD, &matWorldSaved );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CXBMesh()
// Desc: Mesh class constructor.
//-----------------------------------------------------------------------------
CXBMesh::CXBMesh( CHAR* strName )
{
    strcpy( m_strName, strName );
    m_pVB           = NULL;
    m_dwNumVertices = 0L;
    m_pIB           = NULL;
    m_dwNumIndices  = 0L;
    m_dwFVF         = 0L;
    m_dwPrimType    = D3DPT_TRIANGLELIST;
    m_dwVertexSize  = 0L;
    m_dwNumSubsets  = 0L;
    m_pSubsets      = NULL;
    m_bUseMaterials = TRUE;
    m_bUseFVF       = TRUE;
    m_dwRefCount    = 1;
}




//-----------------------------------------------------------------------------
// Name: ~CXBMesh()
// Desc: Mesh class destructor.
//-----------------------------------------------------------------------------
CXBMesh::~CXBMesh()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: CreateFromXBG()
// Desc: Creates a mesh from a .XBG geometry. Note: .XBG files are made with
//       the MakeXBG tool.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::CreateFromXBG( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename )
{
    BYTE* pData;

    // Find the media file
    CHAR strMeshPath[512];
    if( FAILED( XBUtil_FindMediaFile( strMeshPath, strFilename ) ) )
        return E_FAIL;

    // Open the file
    FILE* file = fopen( strMeshPath, "rb" );
    if( file == NULL )
        return E_FAIL;

    // Read the magic number
    DWORD dwFileID;
    fread( &dwFileID, 1, sizeof(DWORD), file ); 
    if( dwFileID != XBG_FILE_ID )
    {
        fclose( file );
        return E_FAIL;
    }

    // Read the mesh info
    fread( &m_dwNumVertices, 1, sizeof(DWORD), file ); 
    fread( &m_dwNumIndices,  1, sizeof(DWORD), file ); 
    fread( &m_dwFVF,         1, sizeof(DWORD), file ); 
    fread( &m_dwVertexSize,  1, sizeof(DWORD), file ); 
    fread( &m_dwPrimType,    1, sizeof(DWORD), file ); 
    fread( &m_dwNumSubsets,  1, sizeof(DWORD), file ); 

    // Read the subset array
    m_pSubsets = new XBMESH_SUBSET[m_dwNumSubsets];
    fread( m_pSubsets, m_dwNumSubsets, sizeof(XBMESH_SUBSET), file ); 

    // Create the textures
    for( DWORD i=0; i < m_dwNumSubsets; i++ )
    {
        m_pSubsets[i].pTexture = NULL;

        CHAR strTextureName[512];
        fread( strTextureName, 1, sizeof(strTextureName), file ); 
        if( strTextureName[0] )
        {
            // Expand the path and create the texture
            CHAR strTexture[MAX_PATH];
            sprintf( strTexture, "Textures\\%s", strTextureName );
            XBUtil_CreateTexture( pd3dDevice, strTexture, &m_pSubsets[i].pTexture );
        }
    }

    // Read vertex buffer
    pd3dDevice->CreateVertexBuffer( m_dwNumVertices*m_dwVertexSize, D3DUSAGE_WRITEONLY, 
                                    m_dwFVF, D3DPOOL_DEFAULT, &m_pVB );
    m_pVB->Lock( 0, 0, &pData, 0 );
    fread( pData, m_dwNumVertices, m_dwVertexSize, file ); 
    m_pVB->Unlock();

    // Read vertex buffer
    pd3dDevice->CreateIndexBuffer( m_dwNumIndices*sizeof(WORD), D3DUSAGE_WRITEONLY, 
                                   D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pIB );
    m_pIB->Lock( 0, 0, &pData, 0 );
    fread( pData, m_dwNumIndices, sizeof(WORD), file ); 
    m_pIB->Unlock();

    // Close the file and return okay
    fclose( file );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateFromD3DXMesh()
// Desc: Creates mesh, loading geometry from a file.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::CreateFromD3DXMesh( LPDIRECT3DDEVICE8 pd3dDevice, LPD3DXMESH pSrcMesh,
                                     LPD3DXBUFFER pAdjacencyBuffer, LPD3DXBUFFER pMtrlBuffer, 
                                     DWORD dwFVF )
{
    // Attribute sort the mesh
    DWORD* rgdwAdjacencyTemp = new DWORD[ pSrcMesh->GetNumFaces() * 3 ];
    pSrcMesh->OptimizeInplace( D3DXMESHOPT_COMPACT|D3DXMESHOPT_ATTRSORT,
                                  (DWORD*)pAdjacencyBuffer->GetBufferPointer(),
                                  rgdwAdjacencyTemp, NULL, NULL );
    SAFE_DELETE_ARRAY( rgdwAdjacencyTemp );

    // Clone the mesh into local memory, overriding the FVF if specified.
    DWORD dwOldFVF = pSrcMesh->GetFVF();
    DWORD dwNewFVF = dwFVF ? dwFVF : pSrcMesh->GetFVF();
    LPD3DXMESH pNewMesh;
    pSrcMesh->CloneMeshFVF( 0L, dwNewFVF, pd3dDevice, &pNewMesh );

    // Compute normals, if necessery
    if( 0==(dwOldFVF&D3DFVF_NORMAL) && 0!=(dwNewFVF&D3DFVF_NORMAL) )
        D3DXComputeNormals( pNewMesh );

    // Store mesh properties
    pNewMesh->GetVertexBuffer( &m_pVB );
    pNewMesh->GetIndexBuffer( &m_pIB );
    m_dwNumVertices = pNewMesh->GetNumVertices();
    m_dwNumIndices  = pNewMesh->GetNumFaces() * 3;
    m_dwFVF         = pNewMesh->GetFVF();
    m_dwVertexSize  = D3DXGetFVFVertexSize( m_dwFVF );

    // Build the array of subsets, used to render the mesh
    pNewMesh->GetAttributeTable( NULL, &m_dwNumSubsets );
    m_pSubsets  = new XBMESH_SUBSET[ max(1,m_dwNumSubsets) ];
    
    if( m_dwNumSubsets > 0 )
    {
        // Get subset info from mesh's attribute table
        D3DXATTRIBUTERANGE* pAttributes;
        pAttributes = new D3DXATTRIBUTERANGE[ max(1,m_dwNumSubsets) ];
        pNewMesh->GetAttributeTable( pAttributes, NULL );
        for( DWORD i = 0; i < m_dwNumSubsets; i++ )
        {
            m_pSubsets[i].dwVertexStart = pAttributes[i].VertexStart;
            m_pSubsets[i].dwVertexCount = pAttributes[i].VertexCount;
            m_pSubsets[i].dwIndexStart  = pAttributes[i].FaceStart * 3;
            m_pSubsets[i].dwIndexCount  = pAttributes[i].FaceCount * 3;
        }

        SAFE_DELETE( pAttributes );
    }
    else
    {
        // Set default subset
        m_dwNumSubsets = 1; 
        m_pSubsets[0].dwVertexStart = 0;
        m_pSubsets[0].dwVertexCount = m_dwNumVertices;
        m_pSubsets[0].dwIndexStart   = 0;
        m_pSubsets[0].dwIndexCount   = m_dwNumIndices / 3;
    }

    // Create materials and textures for the mesh
    if( pMtrlBuffer && m_dwNumSubsets > 0 )
    {
        // Allocate memory for the materials and textures
        D3DXMATERIAL* d3dxMtrls = (D3DXMATERIAL*)pMtrlBuffer->GetBufferPointer();

        // Copy each material and create it's texture
        for( DWORD i=0; i<m_dwNumSubsets; i++ )
        {
            // Copy the material
            m_pSubsets[i].mtrl         = d3dxMtrls[i].MatD3D;
            m_pSubsets[i].mtrl.Ambient = m_pSubsets[i].mtrl.Diffuse;
            m_pSubsets[i].pTexture     = NULL;

            // Create a texture
            if( d3dxMtrls[i].pTextureFilename )
            {
                // Find the full path to the texture file
                CHAR strTexture[MAX_PATH];
                sprintf( strTexture, "Textures\\%s", d3dxMtrls[i].pTextureFilename );
    
                // Create the texture
                XBUtil_CreateTexture( pd3dDevice, strTexture, &m_pSubsets[i].pTexture );
            }
        }
    }

    // Delete the new mesh, which was created above.
    SAFE_RELEASE( pNewMesh );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates mesh, loading geometry from a file.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::CreateFromX( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename,
                              DWORD dwFVF )
{
    LPD3DXMESH   pD3DXMesh         = NULL;
    LPD3DXBUFFER pAdjacencyBuffer  = NULL;
    LPD3DXBUFFER pMtrlBuffer       = NULL;
    DWORD        dwNumMaterials    = 0L;
    HRESULT      hr;

    // Find the media file
    CHAR strMeshPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strMeshPath, strFilename ) ) )
        return hr;

    // Use D3DX to load the mesh from a .x file
    if( FAILED( hr = D3DXLoadMeshFromX( strMeshPath, D3DXMESH_SYSTEMMEM, 
                                        pd3dDevice, &pAdjacencyBuffer, &pMtrlBuffer, 
                                        &dwNumMaterials, &pD3DXMesh ) ) )
        return hr;

    // Now create our mesh internals from the D3DX mesh
    hr = CreateFromD3DXMesh( pd3dDevice, pD3DXMesh, pAdjacencyBuffer, 
                             pMtrlBuffer, dwFVF );

    // Release objects and return
    SAFE_RELEASE( pMtrlBuffer );
    SAFE_RELEASE( pAdjacencyBuffer );
    SAFE_RELEASE( pD3DXMesh );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates a mesh, loading geometry from a previously-opened DXFILE.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::CreateFromXFileData( LPDIRECT3DDEVICE8 pd3dDevice,
                                      LPDIRECTXFILEDATA pFileData, DWORD dwFVF )
{
    LPD3DXMESH   pD3DXMesh         = NULL;
    LPD3DXBUFFER pAdjacencyBuffer  = NULL;
    LPD3DXBUFFER pMtrlBuffer       = NULL;
    DWORD        dwNumMaterials    = 0L;
    HRESULT      hr;

    // Use D3DX to load the mesh from the DXFILEDATA object
    if( FAILED( hr = D3DXLoadMeshFromXof( pFileData, D3DXMESH_SYSTEMMEM, pd3dDevice,
                                          &pAdjacencyBuffer, &pMtrlBuffer, 
                                          &dwNumMaterials, &pD3DXMesh ) ) )
        return hr;

    // Now create our mesh internals from the D3DX mesh
    hr = CreateFromD3DXMesh( pd3dDevice, pD3DXMesh, pAdjacencyBuffer, 
                             pMtrlBuffer, dwFVF );

    // Release objects and return
    SAFE_RELEASE( pMtrlBuffer );
    SAFE_RELEASE( pAdjacencyBuffer );
    SAFE_RELEASE( pD3DXMesh );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates mesh, loading geometry from a file.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename,
                         DWORD dwOptionalFVF )
{
    HRESULT hr = E_FAIL;

    // First try loading the mesh as .xbg (Xbox geometry file)
    if( FAILED(hr) )
        hr = CreateFromXBG( pd3dDevice, strFilename );

    // Next, try loading the mesh as .x (DirectX geometry file)
    if( FAILED(hr) )
        hr = CreateFromX( pd3dDevice, strFilename, dwOptionalFVF );

    // Add other file types here...

    return hr;
}




//-----------------------------------------------------------------------------
// Name: ComputeNormals()
// Desc: Compute the normals for the mesh
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeNormals()
{
    // Make sure the vertices have normals
    if( 0 == ( m_dwFVF & D3DFVF_NORMAL ) )
        return E_FAIL;

    // Compute the vertices' byte offset to their normals
    DWORD dwNormalOffset = 12;
    DWORD dwPositionFVF  = m_dwFVF & D3DFVF_POSITION_MASK;
    if( dwPositionFVF >= D3DFVF_XYZB1 )
        dwNormalOffset += 4*((dwPositionFVF-4)/2);

    // Gain access to vertices and faces
    BYTE* pVertices;
    WORD* pIndices;
    m_pIB->Lock( 0, 0, (BYTE**)&pIndices,  0 );
    m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

    // Zero out the existing normals
    for( DWORD vtx = 0; vtx < m_dwNumVertices; vtx++ )
    {
        BYTE*        pVertex = ( (BYTE*)pVertices + (vtx * m_dwVertexSize) );
        D3DXVECTOR3* pNormal = (D3DXVECTOR3*)( pVertex + dwNormalOffset );
        (*pNormal) = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    }

    // Add in face normals
    for( DWORD face = 0; face < m_dwNumIndices/3; face++ )
    {
        WORD wFaceVtx[3];
        wFaceVtx[0] = pIndices[ face*3 + 0 ];
        wFaceVtx[1] = pIndices[ face*3 + 1 ];
        wFaceVtx[2] = pIndices[ face*3 + 2 ];

        D3DXVECTOR3* pPos0 = (D3DXVECTOR3*)( pVertices + (wFaceVtx[0] * m_dwVertexSize) );
        D3DXVECTOR3* pPos1 = (D3DXVECTOR3*)( pVertices + (wFaceVtx[1] * m_dwVertexSize) );
        D3DXVECTOR3* pPos2 = (D3DXVECTOR3*)( pVertices + (wFaceVtx[2] * m_dwVertexSize) );

        // Calculate the normal of the face from the two edge vectors
        D3DXVECTOR3  vNormal;
        D3DXVECTOR3  vEdge1 = *pPos0 - *pPos1;
        D3DXVECTOR3  vEdge2 = *pPos0 - *pPos2;
        D3DXVec3Cross( &vNormal, &vEdge1, &vEdge2 );

        for( DWORD point = 0; point < 3; point++ )
        {
            BYTE*        pVertex = ( pVertices + (wFaceVtx[point] * m_dwVertexSize) );
            D3DXVECTOR3* pNormal = (D3DXVECTOR3*)( pVertex + dwNormalOffset );
            (*pNormal) += vNormal;
        }
    }

    // Renormalize all normals
    for( vtx = 0; vtx < m_dwNumVertices; vtx++ )
    {
        BYTE*        pVertex = ( pVertices + (vtx * m_dwVertexSize) );
        D3DXVECTOR3* pNormal = (D3DXVECTOR3*)( pVertex + dwNormalOffset );
        D3DXVec3Normalize( pNormal, pNormal );
    }

    m_pIB->Unlock();
    m_pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the mesh geometry.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::Destroy()
{
    // Release subsets
    for( UINT i=0; i<m_dwNumSubsets; i++ )
        SAFE_RELEASE( m_pSubsets[i].pTexture );
    SAFE_DELETE_ARRAY( m_pSubsets );
    m_dwNumSubsets = 0L;

    SAFE_RELEASE( m_pVB );
    SAFE_RELEASE( m_pIB );
    m_dwNumVertices = 0L;
    m_dwNumIndices  = 0L;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the mesh geometry.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::Render( LPDIRECT3DDEVICE8 pd3dDevice, BOOL bDrawOpaqueSubsets,
                         BOOL bDrawAlphaSubsets )
{
    // Set the vertex stream
    pd3dDevice->SetStreamSource( 0, m_pVB, m_dwVertexSize );
    pd3dDevice->SetIndices( m_pIB, 0 );
    if( m_bUseFVF )
        pd3dDevice->SetVertexShader( m_dwFVF );

    // First, draw the subsets without alpha
    if( bDrawOpaqueSubsets )
    {
        for( DWORD i = 0; i < m_dwNumSubsets; i++ )
        {
            // Draw i'th subset
            if( m_bUseMaterials )
            {
                if( m_pSubsets[i].mtrl.Diffuse.a < 1.0f )
                    continue;
                pd3dDevice->SetMaterial( &m_pSubsets[i].mtrl );
                pd3dDevice->SetTexture( 0, m_pSubsets[i].pTexture );
            }

            DWORD dwNumPrimitives = ( D3DPT_TRIANGLESTRIP == m_dwPrimType ) ? m_pSubsets[i].dwIndexCount-2 : m_pSubsets[i].dwIndexCount/3;
            pd3dDevice->DrawIndexedPrimitive( m_dwPrimType, 0, m_pSubsets[i].dwIndexCount,
                                              m_pSubsets[i].dwIndexStart, dwNumPrimitives );
        }
    }

    // Then, draw the subsets with alpha
    if( bDrawAlphaSubsets && m_bUseMaterials )
    {
        for( DWORD i = 0; i < m_dwNumSubsets; i++ )
        {
            // Draw i'th subset
            if( m_pSubsets[i].mtrl.Diffuse.a == 1.0f )
                continue;
            pd3dDevice->SetMaterial( &m_pSubsets[i].mtrl );
            pd3dDevice->SetTexture( 0, m_pSubsets[i].pTexture );

            DWORD dwNumPrimitives = ( D3DPT_TRIANGLESTRIP == m_dwPrimType ) ? m_pSubsets[i].dwIndexCount-2 : m_pSubsets[i].dwIndexCount/3;
            pd3dDevice->DrawIndexedPrimitive( m_dwPrimType, 0, m_pSubsets[i].dwIndexCount,
                                              m_pSubsets[i].dwIndexStart, dwNumPrimitives );
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CXBFrame()
// Desc: Frame class constructor.
//-----------------------------------------------------------------------------
CXBFrame::CXBFrame( CHAR* strName )
{
    strcpy( m_strName, strName );
    D3DXMatrixIdentity( &m_mat );
    m_pMesh  = NULL;

    m_pChild = NULL;
    m_pNext  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFrame()
// Desc: Frame class destructor.
//-----------------------------------------------------------------------------
CXBFrame::~CXBFrame()
{
    SAFE_DELETE( m_pChild );
    SAFE_DELETE( m_pNext );
}




//-----------------------------------------------------------------------------
// Name: EnumMeshes()
// Desc: Recursively enumerates through the hierarchy of frames and meshes and
//       calls a callback function for each mesh. This is useful for creating
//       shadowvolumes, calculating bounding volumes, etc..
//-----------------------------------------------------------------------------
BOOL CXBFrame::EnumMeshes( BOOL (*EnumMeshCB)(CXBMesh*,VOID*), VOID* pContext )
{
    if( m_pMesh )
        EnumMeshCB( m_pMesh, pContext );
    if( m_pChild )
        m_pChild->EnumMeshes( EnumMeshCB, pContext );
    if( m_pNext )
        m_pNext->EnumMeshes( EnumMeshCB, pContext );

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: FindMesh()
// Desc: Tranverses the hierarchy, and returns a named mesh.
//-----------------------------------------------------------------------------
CXBMesh* CXBFrame::FindMesh( CHAR* strMeshName )
{
    CXBMesh* pMesh;

    if( m_pMesh )
        if( !_stricmp( m_pMesh->m_strName, strMeshName ) )
            return m_pMesh;

    if( m_pChild )
        if( NULL != ( pMesh = m_pChild->FindMesh( strMeshName ) ) )
            return pMesh;

    if( m_pNext )
        if( NULL != ( pMesh = m_pNext->FindMesh( strMeshName ) ) )
            return pMesh;

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: FindFrame()
// Desc: Tranverses the hierarchy, and returns a named frame.
//-----------------------------------------------------------------------------
CXBFrame* CXBFrame::FindFrame( CHAR* strFrameName )
{
    CXBFrame* pFrame;

    if( !_stricmp( m_strName, strFrameName ) )
        return this;

    if( m_pChild )
        if( NULL != ( pFrame = m_pChild->FindFrame( strFrameName ) ) )
            return pFrame;

    if( m_pNext )
        if( NULL != ( pFrame = m_pNext->FindFrame( strFrameName ) ) )
            return pFrame;

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys a frame.
//-----------------------------------------------------------------------------
HRESULT CXBFrame::Destroy()
{
    if( m_pMesh )  m_pMesh->Destroy();
    if( m_pChild ) m_pChild->Destroy();
    if( m_pNext )  m_pNext->Destroy();

    SAFE_DELETE( m_pMesh );
    SAFE_DELETE( m_pNext );
    SAFE_DELETE( m_pChild );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders a frame (save state, apply matrix, render children, restore).
//-----------------------------------------------------------------------------
HRESULT CXBFrame::Render( LPDIRECT3DDEVICE8 pd3dDevice, BOOL bDrawOpaqueSubsets,
                          BOOL bDrawAlphaSubsets )
{
    D3DXMATRIX matSavedWorld, matWorld;
    pd3dDevice->GetTransform( D3DTS_WORLD, &matSavedWorld );
    D3DXMatrixMultiply( &matWorld, &m_mat, &matSavedWorld );
    pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    if( m_pMesh )
        m_pMesh->Render( pd3dDevice, bDrawOpaqueSubsets, bDrawAlphaSubsets );

    if( m_pChild )
        m_pChild->Render( pd3dDevice, bDrawOpaqueSubsets, bDrawAlphaSubsets );

    pd3dDevice->SetTransform( D3DTS_WORLD, &matSavedWorld );

    if( m_pNext )
        m_pNext->Render( pd3dDevice, bDrawOpaqueSubsets, bDrawAlphaSubsets );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadFrame()
// Desc: Creates a child frame, as specified in the DXFILE being loaded.
//-----------------------------------------------------------------------------
HRESULT CXBFile::LoadFrame( LPDIRECT3DDEVICE8 pd3dDevice, LPDIRECTXFILEDATA pFileData,
                            CXBFrame* pParentFrame, DWORD dwFVF )
{
    LPDIRECTXFILEDATA   pChildData = NULL;
    LPDIRECTXFILEOBJECT pChildObj = NULL;
    const GUID* pGUID;
    DWORD       cbSize;
    CXBFrame*   pCurrentFrame;
    HRESULT     hr;

    // Get the type of the object
    if( FAILED( hr = pFileData->GetType( &pGUID ) ) )
        return hr;

    if( *pGUID == TID_D3DRMMesh )
    {
        hr = LoadMesh( pd3dDevice, pFileData, pParentFrame, dwFVF );
        if( FAILED(hr) )
            return hr;
    }
    if( *pGUID == TID_D3DRMFrameTransformMatrix )
    {
        D3DXMATRIX* pmatMatrix;
        hr = pFileData->GetData( NULL, &cbSize, (VOID**)&pmatMatrix );
        if( FAILED(hr) )
            return hr;

        // Update the parents matrix with the new one
        pParentFrame->SetMatrix( pmatMatrix );
    }
    if( *pGUID == TID_D3DRMFrame )
    {
        // Get the frame name
        CHAR strName[MAX_PATH] = "";
        DWORD dwNameLength;
        pFileData->GetName( NULL, &dwNameLength );
        if( dwNameLength > 0 )
            pFileData->GetName( strName, &dwNameLength );

        // Create the frame
        pCurrentFrame = new CXBFrame( strName );

        pCurrentFrame->m_pNext = pParentFrame->m_pChild;
        pParentFrame->m_pChild = pCurrentFrame;

        // Enumerate child objects
        while( SUCCEEDED( pFileData->GetNextObject( &pChildObj ) ) )
        {
            // Query the child for it's FileData
            hr = pChildObj->QueryInterface( IID_IDirectXFileData,
                                            (VOID**)&pChildData );
            if( SUCCEEDED(hr) )
            {
                hr = LoadFrame( pd3dDevice, pChildData, pCurrentFrame, dwFVF );
                pChildData->Release();
            }

            pChildObj->Release();

            if( FAILED(hr) )
                return hr;
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadMesh()
// Desc: Creates a mesh, as specified in the DXFILE being loaded.
//-----------------------------------------------------------------------------
HRESULT CXBFile::LoadMesh( LPDIRECT3DDEVICE8 pd3dDevice, LPDIRECTXFILEDATA pFileData,
                           CXBFrame* pParentFrame, DWORD dwFVF )
{
    // Currently only allowing one mesh per frame
    if( pParentFrame->m_pMesh )
    {
        OutputDebugStringA( "CXBFile::LoadMesh(): Only one mesh per frame allowed!\n" );
        return E_FAIL;
    }

    // Get the mesh name
    CHAR strName[MAX_PATH] = "";
    DWORD dwNameLength;
    pFileData->GetName( NULL, &dwNameLength );
    if( dwNameLength > 0 )
        pFileData->GetName( strName, &dwNameLength );

    // Create the mesh
    pParentFrame->m_pMesh = new CXBMesh( strName );
    pParentFrame->m_pMesh->CreateFromXFileData( pd3dDevice, pFileData, dwFVF );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads the specified .x file, creating a hierarchy of frames and
//       meshes.
//-----------------------------------------------------------------------------
HRESULT CXBFile::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename,
                         DWORD dwFVF )
{
    LPDIRECTXFILE           pDXFile   = NULL;
    LPDIRECTXFILEENUMOBJECT pEnumObj  = NULL;
    LPDIRECTXFILEDATA       pFileData = NULL;
    HRESULT hr;

    // Create a x file object
    if( FAILED( hr = DirectXFileCreate( &pDXFile ) ) )
        return E_FAIL;

    // Register templates for d3drm and patch extensions.
    if( FAILED( hr = pDXFile->RegisterTemplates( (VOID*)D3DRM_XTEMPLATES,
                                                 D3DRM_XTEMPLATE_BYTES ) ) )
    {
        pDXFile->Release();
        return E_FAIL;
    }

    // Find the path to the file
    CHAR strPath[MAX_PATH];
    XBUtil_FindMediaFile( strPath, strFilename );

    // Create the file
    hr = pDXFile->CreateEnumObject( strPath, DXFILELOAD_FROMFILE, &pEnumObj );
    if( FAILED(hr) )
    {
        pDXFile->Release();
        return hr;
    }

    // Enumerate top level objects (which are always frames)
    while( SUCCEEDED( pEnumObj->GetNextDataObject( &pFileData ) ) )
    {
        hr = LoadFrame( pd3dDevice, pFileData, this, dwFVF );
        pFileData->Release();
        if( FAILED(hr) )
        {
            pEnumObj->Release();
            pDXFile->Release();
            return E_FAIL;
        }
    }

    SAFE_RELEASE( pFileData );
    SAFE_RELEASE( pEnumObj );
    SAFE_RELEASE( pDXFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the hierarchy of frames and meshes previousy loaded.
//-----------------------------------------------------------------------------
HRESULT CXBFile::Render( LPDIRECT3DDEVICE8 pd3dDevice )
{
    // Setup the world transformation
    D3DXMATRIX matSavedWorld, matWorld;
    pd3dDevice->GetTransform( D3DTS_WORLD, &matSavedWorld );
    D3DXMatrixMultiply( &matWorld, &matSavedWorld, &m_mat );
    pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Render opaque subsets in the meshes
    if( m_pChild )
        m_pChild->Render( pd3dDevice, TRUE, FALSE );

    // Enable alpha blending
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

    // Render alpha subsets in the meshes
    if( m_pChild )
        m_pChild->Render( pd3dDevice, FALSE, TRUE );

    // Restore state
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTransform( D3DTS_WORLD, &matSavedWorld );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\XBResource.cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName ) const
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourcePath, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugString( _T("Invalid Xbox Packed Resource (.xpr) file") );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( m_pSysMemData, dwSysMemDataSize, 1, file );
    fread( m_pVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Under UMA emulation, we copy the data from AGP memory to video memory.
    // This will not be necessary with final hardware
    D3D_CopyContiguousMemoryToVideo( m_pVidMemData );

    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += 8;

			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\XBResource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset ) const
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset ) const
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName ) const;

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName ) const
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName ) const
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbhelp.cpp ===
//-----------------------------------------------------------------------------
// File: XBHelp.cpp
//
// Desc: Support class for rendering a help image, which is an image of an Xbox
//       gamepad, with labelled callouts to each of the gamepad's controls.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.06.01 - Changes for April XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include "XBHelp.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Constants for rendering callouts on the help screen. The order of these
// callouts is in agreement with the enum structure in XBHelp.h
//-----------------------------------------------------------------------------
static D3DXVECTOR2 g_vHelpCallouts[] = 
{
    // Order:
    // Button position (start of line),
    // End of line for placement one, Start of text for placement one
    // End of line for placement two, Start of text for placement two

    // Left thumbstick
    D3DXVECTOR2( 255.0f, 149.0f ),
    D3DXVECTOR2( 141.0f,  99.0f ), D3DXVECTOR2( 108.0f,  77.0f ),
    D3DXVECTOR2( 145.0f, 124.0f ), D3DXVECTOR2( 108.0f,  77.0f ),
    
    // Right thumbstick 
    D3DXVECTOR2( 370.0f, 191.0f ),
    D3DXVECTOR2( 370.0f, 363.0f ), D3DXVECTOR2( 352.0f, 364.0f ),
    D3DXVECTOR2( 370.0f, 363.0f ), D3DXVECTOR2( 352.0f, 364.0f ),

    // D-pad
    D3DXVECTOR2( 254.0f, 194.0f ),
    D3DXVECTOR2( 117.0f, 223.0f ), D3DXVECTOR2(  78.0f, 222.0f ),
    D3DXVECTOR2( 117.0f, 223.0f ), D3DXVECTOR2(  78.0f, 222.0f ),
    
    // Back button
    D3DXVECTOR2( 288.0f, 221.0f ),
    D3DXVECTOR2( 185.0f, 284.0f ), D3DXVECTOR2( 145.0f, 282.0f ),
    D3DXVECTOR2( 185.0f, 284.0f ), D3DXVECTOR2( 145.0f, 282.0f ),

    // Start button
    D3DXVECTOR2( 322.0f, 223.0f ),
    D3DXVECTOR2( 262.0f, 343.0f ), D3DXVECTOR2( 217.0f, 340.0f ),
    D3DXVECTOR2( 262.0f, 343.0f ), D3DXVECTOR2( 217.0f, 340.0f ),

    // X button
    D3DXVECTOR2( 394.0f, 176.0f ),
    D3DXVECTOR2( 295.0f, 124.0f ), D3DXVECTOR2( 268.0f, 101.0f ),
    D3DXVECTOR2( 300.0f, 149.0f ), D3DXVECTOR2( 268.0f, 101.0f ),

    // Y button
    D3DXVECTOR2( 405.0f, 164.0f ),
    D3DXVECTOR2( 416.0f,  99.0f ), D3DXVECTOR2( 404.0f, 76.0f ),
    D3DXVECTOR2( 416.0f,  99.0f ), D3DXVECTOR2( 404.0f, 51.0f ),

    // A button
    D3DXVECTOR2( 411.0f, 189.0f ),
    D3DXVECTOR2( 431.0f, 298.0f ), D3DXVECTOR2( 424.0f, 298.0f ),
    D3DXVECTOR2( 431.0f, 298.0f ), D3DXVECTOR2( 424.0f, 298.0f ),

    // B button
    D3DXVECTOR2( 422.0f, 175.0f ),
    D3DXVECTOR2( 443.0f, 244.0f ), D3DXVECTOR2( 435.0f, 243.0f ),
    D3DXVECTOR2( 443.0f, 244.0f ), D3DXVECTOR2( 435.0f, 243.0f ),

    // White button
    D3DXVECTOR2( 424.0f, 158.0f ),
    D3DXVECTOR2( 458.0f, 124.0f ), D3DXVECTOR2( 444.0f, 102.0f ),
    D3DXVECTOR2( 448.0f, 148.0f ), D3DXVECTOR2( 444.0f, 102.0f ),
    
    // Black button
    D3DXVECTOR2( 443.0f, 170.0f ),
    D3DXVECTOR2( 456.0f, 183.0f ), D3DXVECTOR2( 442.0f, 182.0f ),
    D3DXVECTOR2( 456.0f, 183.0f ), D3DXVECTOR2( 442.0f, 182.0f ),

    // Left trigger button
    D3DXVECTOR2( 230.0f, 173.0f ),
    D3DXVECTOR2( 164.0f, 160.0f ), D3DXVECTOR2( 66.0f, 150.0f ),
    D3DXVECTOR2( 164.0f, 160.0f ), D3DXVECTOR2( 66.0f, 150.0f ),

    // Right trigger button
    D3DXVECTOR2( 462.0f, 172.0f ),
    D3DXVECTOR2( 480.0f, 170.0f ), D3DXVECTOR2( 482.0f, 158.0f ),
    D3DXVECTOR2( 480.0f, 170.0f ), D3DXVECTOR2( 482.0f, 158.0f ),

    // Misc callout
    D3DXVECTOR2(  64.0f, 380.0f ),
    D3DXVECTOR2(  64.0f, 380.0f ), D3DXVECTOR2( 64.0f, 405.0f ),
    D3DXVECTOR2(  64.0f, 380.0f ), D3DXVECTOR2( 64.0f, 380.0f ),
};




//-----------------------------------------------------------------------------
// Name: CXBHelp()
// Desc: Help class constructor
//-----------------------------------------------------------------------------
CXBHelp::CXBHelp()
{
    m_pd3dDevice      = NULL;
    m_pGamepadTexture = NULL;
    m_pVB             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBHelp()
// Desc: Help class destructor
//-----------------------------------------------------------------------------
CXBHelp::~CXBHelp()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the help class' internal objects
//-----------------------------------------------------------------------------
HRESULT CXBHelp::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strResource )
{
    // Keep track of the device
    m_pd3dDevice = pd3dDevice;

    // Create the gamepad resource
    if( FAILED( m_xprResource.Create( pd3dDevice, strResource, 1 ) ) )
        return E_FAIL;

    // Store access to the 640x480, linear gamepad texture
    m_pGamepadTexture = m_xprResource.GetTexture( 0UL );

    // Create a vertex buffer for rendering the help screen
    m_pd3dDevice->CreateVertexBuffer( 4*6*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                      0L, D3DPOOL_DEFAULT, &m_pVB );
    struct VERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
    VERTEX* v;
    m_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
    v[0].p = D3DXVECTOR4(   0,   0, 0, 0 ); v[0].tu =   0; v[0].tv =   0;
    v[1].p = D3DXVECTOR4( 640,   0, 0, 0 ); v[1].tu = 639; v[1].tv =   0;
    v[2].p = D3DXVECTOR4( 640, 480, 0, 0 ); v[2].tu = 639; v[2].tv = 479;
    v[3].p = D3DXVECTOR4(   0, 480, 0, 0 ); v[3].tu =   0; v[3].tv = 479;
    m_pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the help class' internal objects/
//-----------------------------------------------------------------------------
HRESULT CXBHelp::Destroy()
{
    SAFE_RELEASE( m_pVB );
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the gamepad help image, and it's labelled callouts.
//-----------------------------------------------------------------------------
HRESULT CXBHelp::Render( CXBFont* pFont, XBHELP_CALLOUT* tags, 
                         DWORD dwNumCallouts )
{
    // Set state to render the gamepad image
    m_pd3dDevice->SetTexture( 0, m_pGamepadTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,   FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,  D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,  D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );

    // Render the gamepad image
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 6*sizeof(FLOAT) );
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, 1 );

    // Set state to draw the lines
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );

    for( DWORD i=0; i<dwNumCallouts; i++ )
    {
        // Determine the line start and end positions
        WORD wLineStartIndex = tags[i].wControl;
        WORD wLineEndIndex   = tags[i].wControl + 2*(tags[i].wPlacement-1)+1;
        FLOAT line1x = g_vHelpCallouts[wLineStartIndex].x;
        FLOAT line1y = g_vHelpCallouts[wLineStartIndex].y;
        FLOAT line2x = g_vHelpCallouts[wLineEndIndex].x;
        FLOAT line2y = g_vHelpCallouts[wLineEndIndex].y;

        // Draw the callout line
        D3DXVECTOR4 v[2];
        v[0] = D3DXVECTOR4( line1x, line1y, 0.0f, 0.0f );
        v[1] = D3DXVECTOR4( line2x, line2y, 0.0f, 0.0f );
        
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, v, sizeof(D3DXVECTOR4) );
    }

    // Prepare font for rendering
    pFont->Begin();

    // Render the callouts
    for( i=0; i<dwNumCallouts; i++ )
    {
        // Determine the text position
        WORD wTextPosIndex = tags[i].wControl + 2*(tags[i].wPlacement-1)+2;
        FLOAT textx = g_vHelpCallouts[wTextPosIndex].x;
        FLOAT texty = g_vHelpCallouts[wTextPosIndex].y;

        // Draw the callout text
        pFont->DrawText( textx, texty, 0xffffffff, tags[i].strText );
    }

    // Flush the text drawing
    pFont->End();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbinput.h ===
//-----------------------------------------------------------------------------
// File: XBInput.h
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.h for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBINPUT_H
#define XBINPUT_H




//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // Inherited members from XINPUT_GAMEPAD
	//
    // WORD    wButtons;
    // BYTE    bAnalogButtons[8];
    // SHORT   sThumbLX;
    // SHORT   sThumbLY;
    // SHORT   sThumbRX;
    // SHORT   sThumbRY;

    // Thumb stick values in range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // Buttons pressed since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

	// Rumble properties
	XINPUT_RUMBLE	Rumble;
	XINPUT_FEEDBACK	Feedback;

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;

    // Flags for whether gamepad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;
};




//-----------------------------------------------------------------------------
// Global access to gamepad devices
//-----------------------------------------------------------------------------
extern XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetPrimaryController()
// Desc: The first controller used by the player or the controller on the
//       lowest numbered slot. NULL if no controllers inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* XBInput_GetPrimaryController();




//-----------------------------------------------------------------------------
// Name: XBInput_IsAnyButtonActive()
// Desc: TRUE if any button or thumbstick depressed on the given controller
//-----------------------------------------------------------------------------
BOOL XBInput_IsAnyButtonActive( const XBGAMEPAD* );




#endif // XBINPUT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbinput.cpp ===
//-----------------------------------------------------------------------------
// File: XBInput.cpp
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.cpp for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "XBInput.h"




//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------

// Deadzone for thumbsticks
#define XBINPUT_DEADZONE 0.25

// Threshold for analog buttons
#define XBINPUT_BUTTONTHRESHOLD 1

// Global instance of gamepad devices
XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads )
{
    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        ZeroMemory( &g_Gamepads[i], sizeof(XBGAMEPAD) );
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                                XDEVICE_NO_SLOT, NULL );

            // Store capabilites of the device
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }
    }

    // Created devices are kept global, but for those who prefer member
    // variables, they can get a pointer to the gamepads returned.
    if( ppGamepads )
        (*ppGamepads) = g_Gamepads;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads )
{
    if( NULL == pGamepads )
        pGamepads = g_Gamepads;

    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        pGamepads[i].bRemoved = ( dwRemovals & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bRemoved )
        {
            XInputClose( pGamepads[i].hDevice );
            pGamepads[i].hDevice = NULL;
        }

        // Handle inserted devices
        pGamepads[i].bInserted = ( dwInsertions & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bInserted ) 
        {
            // TCR 1-14 Device Types
            pGamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                               XDEVICE_NO_SLOT, NULL );
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }

        // If we have a valid device, poll it's state and track button changes
        if( pGamepads[i].hDevice )
        {
            // Read the input state
            XINPUT_STATE xiState;
            XInputGetState( pGamepads[i].hDevice, &xiState );

            // Copy gamepad to local structure
            pGamepads[i].wButtons          = xiState.Gamepad.wButtons;
            pGamepads[i].bAnalogButtons[0] = xiState.Gamepad.bAnalogButtons[0];
            pGamepads[i].bAnalogButtons[1] = xiState.Gamepad.bAnalogButtons[1];
            pGamepads[i].bAnalogButtons[2] = xiState.Gamepad.bAnalogButtons[2];
            pGamepads[i].bAnalogButtons[3] = xiState.Gamepad.bAnalogButtons[3];
            pGamepads[i].bAnalogButtons[4] = xiState.Gamepad.bAnalogButtons[4];
            pGamepads[i].bAnalogButtons[5] = xiState.Gamepad.bAnalogButtons[5];
            pGamepads[i].bAnalogButtons[6] = xiState.Gamepad.bAnalogButtons[6];
            pGamepads[i].bAnalogButtons[7] = xiState.Gamepad.bAnalogButtons[7];
            pGamepads[i].sThumbLX          = xiState.Gamepad.sThumbLX;
            pGamepads[i].sThumbLY          = xiState.Gamepad.sThumbLY;
            pGamepads[i].sThumbRX          = xiState.Gamepad.sThumbRX;
            pGamepads[i].sThumbRY          = xiState.Gamepad.sThumbRY;

            // Put Xbox device input for the gamepad into our custom format
            pGamepads[i].fX1 = (pGamepads[i].sThumbLX+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fX1) < XBINPUT_DEADZONE )
                pGamepads[i].fX1 = 0.0f;

            pGamepads[i].fY1 = (pGamepads[i].sThumbLY+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fY1) < XBINPUT_DEADZONE )
                pGamepads[i].fY1 = 0.0f;

            pGamepads[i].fX2 = (pGamepads[i].sThumbRX+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fX2) < XBINPUT_DEADZONE )
                pGamepads[i].fX2 = 0.0f;

            pGamepads[i].fY2 = (pGamepads[i].sThumbRY+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fY2) < XBINPUT_DEADZONE ) 
                pGamepads[i].fY2 = 0.0f;

            // Get the boolean buttons that have been pressed since the last
            // call. Each button is represented by one bit.
            pGamepads[i].wPressedButtons = ( pGamepads[i].wLastButtons ^ pGamepads[i].wButtons ) & pGamepads[i].wButtons;
            pGamepads[i].wLastButtons    = pGamepads[i].wButtons;

            // Get the analog buttons that have been pressed since the last
            // call. Here, we considered an analog button pressed (a boolean 
            // condition) if that value is >= the threshold.
            for( DWORD b=0; b<8; b++ )
            {
                // Turn the 8-bit polled value into a boolean value
                BOOL bPressed = ( pGamepads[i].bAnalogButtons[b] >= XBINPUT_BUTTONTHRESHOLD );

                if( bPressed )
                    pGamepads[i].bPressedAnalogButtons[b] = !pGamepads[i].bLastAnalogButtons[b];
                else
                    pGamepads[i].bPressedAnalogButtons[b] = FALSE;
                
                // Store the current state for the next time
                pGamepads[i].bLastAnalogButtons[b] = bPressed;
            }
        }
    }
}



//-----------------------------------------------------------------------------
// Name: XBInput_GetPrimaryController()
// Desc: The primary controller is the first controller used by a player.
//       If no controller has been used or the controller has been removed,
//       the primary controller is the controller inserted at the lowest 
//       port number. Function returns NULL if no controller is inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* XBInput_GetPrimaryController()
{
    static INT nPrimaryController = -1;

    // If primary controller has been set and hasn't been removed, use it
    const XBGAMEPAD* pGamePad = NULL;
    if( nPrimaryController != -1 )
    {
        pGamePad = &g_Gamepads[ nPrimaryController ];
        if( pGamePad->hDevice != NULL )
            return pGamePad;
    }

    // Primary controller hasn't been set or has been removed...

    // Examine each inserted controller to see if any is being used
    INT nFirst = -1;
    for( DWORD i=0; i < XGetPortCount(); ++i )
    {
        pGamePad = &g_Gamepads[i];
        if( pGamePad->hDevice != NULL )
        {
            // Remember the lowest inserted controller ID
            if( nFirst == -1 )
                nFirst = i;

            // If any button is active, we found the primary controller
            if( XBInput_IsAnyButtonActive( pGamePad ) )
            {
                nPrimaryController = i;
                return pGamePad;
            }
        }
    }

    // No controllers are inserted
    if( nFirst == -1 )
        return NULL;

    // The primary controller hasn't been set and no controller has been
    // used yet, so return the controller on the lowest port number
    pGamePad = &g_Gamepads[ nFirst ];
    return pGamePad;
}




//-----------------------------------------------------------------------------
// Name: XBInput_IsAnyButtonActive()
// Desc: TRUE if any button depressed or any thumbstick offset on the given
//       controller.
//-----------------------------------------------------------------------------
BOOL XBInput_IsAnyButtonActive( const XBGAMEPAD* pGamePad )
{
    // Check digital buttons
    if( pGamePad->wButtons )
        return TRUE;

    // Check analog buttons
    for( DWORD i = 0; i < 8; ++i )
    {
        if( pGamePad->bAnalogButtons[ i ] )
            return TRUE;
    }

    // Check thumbsticks
    if( pGamePad->fX1 >  XBINPUT_DEADZONE ||
        pGamePad->fX1 < -XBINPUT_DEADZONE ||
        pGamePad->fY1 >  XBINPUT_DEADZONE ||
        pGamePad->fY1 < -XBINPUT_DEADZONE )
    {
        return TRUE;
    }

    if( pGamePad->fX2 >  XBINPUT_DEADZONE ||
        pGamePad->fX2 < -XBINPUT_DEADZONE ||
        pGamePad->fY2 >  XBINPUT_DEADZONE ||
        pGamePad->fY2 < -XBINPUT_DEADZONE )
    {
        return TRUE;
    }

    // Nothing active
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbfile.h ===
//-----------------------------------------------------------------------------
// File: XBFile.h
//
// Desc: Support code for loading DirectX .X files.
//
//       Note: the mesh code also supports loading .xbg files. These files are
//       more-or-less pure dumps of a vertex buffer and an index buffer for a
//       mesh, so they are trivial and fast to load. They are created with the
//       MakeXBG tool, found on the XDK.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFILE_H
#define XBFILE_H
#include "XBUtil.h"



// Rendering flags. Most common usage is:
//    XBGMESH_RENDERALLSUBSETS|XBGMESH_USEALLMESHPROPERTIES

#define XBGMESH_RENDEROPAQUESUBSETS  0x00000001
#define XBGMESH_RENDERALPHASUBSETS   0x00000002
#define XBGMESH_RENDERALLSUBSETS     0x0000000f

#define XBGMESH_USEMESHMATERIALS     0x00000010
#define XBGMESH_USEMESHTEXTURES      0x00000020
#define XBGMESH_USEMESHFVF           0x00000040
#define XBGMESH_USEALLMESHPROPERTIES 0x000000f0


// The magic number to identify .xbg files
#define XBG_FILE_ID  (((DWORD)'X'<<0)|(((DWORD)'B'<<8))|(((DWORD)'G'<<16)))




//-----------------------------------------------------------------------------
// Name: struct XBGMESH_SUBSET
// Desc: Struct to hold data for rendering a mesh
//-----------------------------------------------------------------------------
struct XBGMESH_SUBSET
{
    D3DXMATRIX         mat;
    D3DMATERIAL8       mtrl;
    LPDIRECT3DTEXTURE8 pTexture;
    DWORD              dwVertexStart;
    DWORD              dwVertexCount;
    DWORD              dwIndexStart;
    DWORD              dwIndexCount;
};




//-----------------------------------------------------------------------------
// Name: struct XBGMESH_INFO
// Desc: Struct to hold data for rendering a mesh
//-----------------------------------------------------------------------------
struct XBGMESH_INFO
{
    D3DVertexBuffer         m_VB;           // Mesh geometry
    DWORD                   m_dwNumVertices;
    D3DIndexBuffer          m_IB;
    DWORD                   m_dwNumIndices;
    
    DWORD                   m_dwFVF;         // Mesh vertex info
    DWORD                   m_dwVertexSize;
    D3DPRIMITIVETYPE        m_dwPrimType;

    DWORD                   m_dwNumSubsets;  // Subset info, for rendering
};




//-----------------------------------------------------------------------------
// Name: class CXBGMesh
// Desc: Class for loading and rendering file-based meshes
//-----------------------------------------------------------------------------
class CXBGMesh : public XBGMESH_INFO
{
public:
    XBGMESH_SUBSET*         m_pSubsets;

public:
    // Mesh access
    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer() { return &m_VB; }
    DWORD                   GetNumVertices()  { return  m_dwNumVertices; }
    LPDIRECT3DINDEXBUFFER8  GetIndexBuffer()  { return &m_IB; }
    DWORD                   GetNumIndices()   { return  m_dwNumIndices; }
    DWORD                   GetFVF()          { return  m_dwFVF; }
    DWORD                   GetVertexSize()   { return  m_dwVertexSize; }
    D3DPRIMITIVETYPE        GetPrimType()     { return  m_dwPrimType; }

    // A callback so that a derived class can tweak state before rendering 
    // each subset. It returns a boolean for whether to still render the mesh.
    virtual BOOL    RenderCallback( LPDIRECT3DDEVICE8, DWORD, 
                                    XBGMESH_SUBSET* ) { return TRUE; }
    
    // Tha main render function, with lots of override functionality
    virtual HRESULT Render( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFlags );

    // Creation/destruction
    virtual HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFileName );
    virtual VOID    Destroy();

	// Reference counting
	DWORD   m_dwRefCount;
	DWORD	AddRef()  { return ++m_dwRefCount; }
	DWORD   Release() { if( --m_dwRefCount ) 
		                    return m_dwRefCount;
	                    delete this; 
						return 0L; }

	CXBGMesh();
   ~CXBGMesh();
};




//-----------------------------------------------------------------------------
// Name: struct XBMESH_SUBSET
// Desc: Struct to hold data for rendering a mesh
//-----------------------------------------------------------------------------
struct XBMESH_SUBSET
{
    D3DMATERIAL8       mtrl;
    LPDIRECT3DTEXTURE8 pTexture;
    DWORD              dwVertexStart;
    DWORD              dwVertexCount;
    DWORD              dwIndexStart;
    DWORD              dwIndexCount;
};




//-----------------------------------------------------------------------------
// Name: class CXBMesh
// Desc: Class for loading and rendering file-based meshes
//-----------------------------------------------------------------------------
class CXBMesh
{
public:
    CHAR                    m_strName[512];  // Name of the mesh
	
    LPDIRECT3DVERTEXBUFFER8 m_pVB;           // Mesh geometry
    DWORD                   m_dwNumVertices;
    LPDIRECT3DINDEXBUFFER8  m_pIB;
    DWORD                   m_dwNumIndices;
    
    DWORD                   m_dwFVF;         // Mesh vertex info
    DWORD                   m_dwVertexSize;
	D3DPRIMITIVETYPE        m_dwPrimType;

    DWORD                   m_dwNumSubsets;  // Subset info, for rendering
    XBMESH_SUBSET*          m_pSubsets;

    BOOL                    m_bUseMaterials; // Whether to override materials
    BOOL                    m_bUseFVF;       // Whether to override FVF

	DWORD					m_dwRefCount;	 // Reference count

public:
    // Rendering
    HRESULT Render( LPDIRECT3DDEVICE8 pd3dDevice, 
                    BOOL bDrawOpaqueSubsets = TRUE,
                    BOOL bDrawAlphaSubsets = TRUE );

    // Mesh access
    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer() { return m_pVB; }
    DWORD                   GetNumVertices()  { return m_dwNumVertices; }
    LPDIRECT3DINDEXBUFFER8  GetIndexBuffer()  { return m_pIB; }
    DWORD                   GetNumIndices()   { return m_dwNumIndices; }
	DWORD                   GetFVF()          { return m_dwFVF; }
	DWORD                   GetVertexSize()   { return m_dwVertexSize; }
	D3DPRIMITIVETYPE        GetPrimType()     { return m_dwPrimType; }

	// Reference counting
	DWORD	AddRef()  { return ++m_dwRefCount; }
	DWORD   Release() { if( --m_dwRefCount ) 
		                    return m_dwRefCount;
	                    delete this; 
						return 0L; }

    // Rendering options
    HRESULT ComputeNormals();
    VOID    UseMeshMaterials( BOOL bFlag ) { m_bUseMaterials = bFlag; }
    VOID    UseMeshFVF( BOOL bFlag )       { m_bUseFVF       = bFlag; }

    // Creation/destruction
	HRESULT CreateFromXBG( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFileName );
	HRESULT CreateFromD3DXMesh( LPDIRECT3DDEVICE8 pd3dDevice, LPD3DXMESH pD3DXMesh,
                                LPD3DXBUFFER pAdjacencyBuffer, LPD3DXBUFFER pMtrlBuffer, 
                                DWORD dwFVF=0L );
    HRESULT CreateFromX( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename,
                         DWORD dwFVF=0L );
    HRESULT CreateFromXFileData( LPDIRECT3DDEVICE8 pd3dDevice, LPDIRECTXFILEDATA pFileData, 
                                 DWORD dwFVF=0L );
	HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename, DWORD dwFVF = 0L );
    HRESULT Destroy();

    CXBMesh( CHAR* strName = "XBFile_Mesh" );
    virtual ~CXBMesh();
};




//-----------------------------------------------------------------------------
// Name: class CXBFrame
// Desc: Class for loading and rendering file-based meshes
//-----------------------------------------------------------------------------
class CXBFrame
{
public:
    CHAR       m_strName[512];
    D3DXMATRIX m_mat;
    CXBMesh*   m_pMesh;
    CHAR       m_strMeshName[512];

    CXBFrame*  m_pNext;
    CXBFrame*  m_pChild;

public:
    // Matrix access
    VOID        SetMatrix( D3DXMATRIX* pmat ) { m_mat = *pmat; }
    D3DXMATRIX* GetMatrix()                   { return &m_mat; }

    CXBMesh*    FindMesh( CHAR* strMeshName );
    CXBFrame*   FindFrame( CHAR* strFrameName );
    BOOL        EnumMeshes( BOOL (*EnumMeshCB)(CXBMesh*,VOID*), 
                            VOID* pContext );

    HRESULT Destroy();
    HRESULT Render( LPDIRECT3DDEVICE8 pd3dDevice, 
                    BOOL bDrawOpaqueSubsets = TRUE,
                    BOOL bDrawAlphaSubsets = TRUE );
    
    CXBFrame( CHAR* strName = "XBFile_Frame" );
    virtual ~CXBFrame();
};




//-----------------------------------------------------------------------------
// Name: class CXBFile
// Desc: Class for loading and rendering file-based meshes
//-----------------------------------------------------------------------------
class CXBFile : public CXBFrame
{
    HRESULT LoadMesh( LPDIRECT3DDEVICE8 pd3dDevice, LPDIRECTXFILEDATA pFileData, 
                      CXBFrame* pParentFrame, DWORD dwFVF=0L );
    HRESULT LoadFrame( LPDIRECT3DDEVICE8 pd3dDevice, LPDIRECTXFILEDATA pFileData, 
                       CXBFrame* pParentFrame, DWORD dwFVF=0L );
public:
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename, 
                    DWORD dwFVF=0L );
    HRESULT Render( LPDIRECT3DDEVICE8 pd3dDevice );

    CXBFile() : CXBFrame( "XBFile_Root" ) {}
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\XbRavMenu.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "library/common/prelude.h"
#include "XBRavMenu.h"

#define DEFAULT_MENU_FLAGS	0

CXBFont * XBRavMenu::m_pFont = NULL;
bool XBRavMenu::m_pFontLoaded = false;
XBRavMenu * XBRavMenu::m_pCurMenu = NULL;
int (*XBRavMenu::m_pCurRoutine)(DWORD cmd, XMenuItem *mi) = NULL;

typedef 	vector<XMenuItem*>::iterator itemIt;

void XBRavMenu::Initialize(WCHAR* title, float x, float y, DWORD maxitems, DWORD flags, DWORD *abortroutine,
						DWORD topcolor, DWORD bottomcolor, DWORD itemcolor, DWORD seltopcolor, DWORD selbotcolor, XBRavMenu * parent)
{
	this->maxitems = 0;
	this->maxshow = 0;
	this->nitems = 0;
	this->curitem = 0;
//	this->parent = 0;
	this->parent = parent;
	this->flags = flags;
	this->abortroutine = (DWORD(*)(DWORD, XMenuItem *)) abortroutine;
	this->x = x;
	this->y = y;
	this->w = 100.0f;
	this->topcolor = topcolor;
	this->bottomcolor = bottomcolor;
	this->itemcolor = itemcolor;
	this->seltopcolor = seltopcolor;
	this->selbotcolor = selbotcolor;

	if(title != NULL)
	{
		XMenu_SetTitle(this, title, seltopcolor);
		this->m_bHasTitle = true;
	}
	else
		this->m_bHasTitle = false;

	XMenu_SetMaxShow(this, this->maxitems);		// sets height
}

XBRavMenu::XBRavMenu(XBMenuProfile* profile, float x, float y, DWORD *abortroutine, XBRavMenu * parent) :
	m_bShowBackground(profile->showbackground),
	m_bShowHighlight(profile->showhighlight),
	m_bHideParent(profile->hideparent),
	m_bShowTextEdge(profile->showtextedge)
{
	Initialize(profile->title,x,y,profile->maxitems,profile->flags,abortroutine,profile->topcolor,profile->bottomcolor,profile->itemcolor,profile->seltopcolor,profile->selbotcolor,parent);
}

XBRavMenu::XBRavMenu(WCHAR * title, float x, float y, DWORD maxitems, DWORD flags, DWORD *abortroutine, XBRavMenu * parent) :
	m_bShowBackground(false),
	m_bShowHighlight(false)
{
//	Initialize(title,x,y,maxitems,flags,abortroutine,0xffffffff,0xffffffff,0xff000000,0xffcedfad,0xff84b642);
	m_bHideParent = true;

	Initialize(title,x,y,maxitems,flags,abortroutine,RAV_COLORKEY,RAV_COLORKEY,0xff333333,0xffffffff,0xffffffff,parent);
//	Initialize(title,x,y,maxitems,flags,abortroutine,0x50cedfad,0x5084b642,0xa0111111,0xffffffff,0xffffffff);
}

XBRavMenu::XBRavMenu(WCHAR * title, float x, float y, DWORD maxitems, DWORD flags, DWORD *abortroutine,
					 DWORD topcolor, DWORD bottomcolor, DWORD itemcolor, DWORD seltopcolor, DWORD selbotcolor, XBRavMenu * parent) :
	m_bShowBackground(true),
//	m_bShowBackground(false),
	m_bShowHighlight(true)
{
	if(parent != NULL)
		m_bHideParent = false;
	else
		m_bHideParent = true;

	Initialize(title,x,y,maxitems,flags,abortroutine,topcolor,bottomcolor,itemcolor,seltopcolor,selbotcolor,parent);
}

XBRavMenu::~XBRavMenu(void)
{
	for(itemIt it = m_pItems.begin(); it != m_pItems.end(); )
	{
//		this->DeleteItem(*it);
		XMenuItem * item = *it;
		m_pItems.erase(it);
		delete item;
		this->nitems--;
	}
}

XBRavMenu * XBRavMenu::GetActiveMenu()
{
	return	 XBRavMenu::m_pCurMenu;
}

void XBRavMenu::UpdateSize()
{
	if(m_pItems.size() <= 14)
	{
//		XMenu_SetMaxShow(this,m_pItems.size() + 2*m_bHasTitle);
		XMenu_SetMaxShow(this,m_pItems.size() + m_bHasTitle);
	}
	else
	{
//		XMenu_SetMaxShow(this, 14 + 2*m_bHasTitle );
		XMenu_SetMaxShow(this, 14 + m_bHasTitle );
	}
}

void XBRavMenu::AddItem(DWORD flags, WCHAR *string, void *action)
{
	XMenuItem *mi = new XMenuItem;

	mi->flags = flags;
	mi->action = action;
	mi->val1 = 0;
	mi->val2 = 0;
	mi->menu = this;
	mi->color = this->itemcolor;
	XMenu_SetItemText(mi, (WCHAR*) string);

	this->nitems++;

	m_pItems.push_back(mi);
	this->UpdateSize();
}

void XBRavMenu::AddItem(WCHAR *string, void *action)
{
	DWORD flags = DEFAULT_MENU_FLAGS;
	AddItem(flags, string, action);
}

bool XBRavMenu::DeleteItem(XMenuItem* item)
{
	bool found = false;
	int index = 0;

	for(itemIt it = m_pItems.begin(); it != m_pItems.end(); it++)
	{
		if(*it == item)
		{
			DeleteItem(index);
			found = true;
		}

		index++;
	}

	this->UpdateSize();

	return found;
}

bool XBRavMenu::DeleteItem(int item)
{
	if(item >= m_pItems.size())
		return false;

	delete *(m_pItems.begin() + item);
	m_pItems.erase(m_pItems.begin() + item);
	this->nitems--;
	return true;
}

int XBRavMenu::GetItemIndex(XMenuItem* item)
{
	int count = 0;
	for(itemIt it = m_pItems.begin(); it != m_pItems.end(); it++)
	{
		if(*it == item)
			return count;
		count++;
	}
	return -1;
}

XMenuItem* XBRavMenu::GetItem(int item)
{
	if(item < m_pItems.size())
	{
		return m_pItems[item];
	}
	else
	{
		return NULL;
	}
}


void XBRavMenu::Activate(bool activate)
{
	if(activate)
	{
		m_pCurMenu = this;
	}
	else // deActivate
	{
		if(m_pCurMenu && m_pCurMenu->parent && !(flags&MENU_NOBACK))
		{
			m_pCurMenu = (XBRavMenu*) m_pCurMenu->parent;
		}
		else
			m_pCurMenu = NULL;
	}
}

bool XBRavMenu::IsActive()
{
	return (XBRavMenu::m_pCurMenu != NULL);
}

DWORD XBRavMenu::ProcessGamePadInput(XBGAMEPAD *gamepad)
{
	DWORD command;
	static int count = 0;

	// get menu command
//	if(XMenu_CurMenu || XMenu_CurRoutine)
//	{
		if(gamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_A] && !(gamepad->wPressedButtons & XINPUT_GAMEPAD_LEFT_THUMB))
			command = MENU_SELECTITEM;
		else if(gamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE])
			command = MENU_ACTIVATE;
		else if(gamepad->wPressedButtons & XINPUT_GAMEPAD_BACK)
			command = MENU_BACK;
		else if(gamepad->fY1>0.25f ||
			gamepad->wPressedButtons & XINPUT_GAMEPAD_DPAD_UP ||
			gamepad->wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT ||
			((gamepad->wLastButtons & XINPUT_GAMEPAD_DPAD_UP) && ((count % 10) == 0)) ||
			((gamepad->wLastButtons & XINPUT_GAMEPAD_DPAD_LEFT) && ((count % 10) == 0)))
			command = MENU_PREVITEM;
		else if(gamepad->fY1<-0.25f ||
			gamepad->wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
			gamepad->wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT ||
			((gamepad->wLastButtons & XINPUT_GAMEPAD_DPAD_DOWN) && ((count % 10) == 0)) ||
			((gamepad->wLastButtons & XINPUT_GAMEPAD_DPAD_RIGHT) && ((count % 10) == 0)))
			command = MENU_NEXTITEM;
//	}
//	else if(gamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_X])
//		command = MENU_ACTIVATE;
	else
		command = 0;

//	ZeroMemory(gamepad, sizeof(XBGAMEPAD));

//	for(int i = 0; i<8; i++)
//		{
//		gamepad->bPressedAnalogButtons[i] = 0;
//		}
//
//	gamepad->wPressedButtons = 0;

	return command;
}

DWORD XBRavMenu::ProcessCommand(DWORD command)
{
	return this->Routine(command);
}

void XBRavMenu::SetFont(CXBFont* m_pFont)
{
	XBRavMenu::m_pFont = m_pFont;
	XBRavMenu::m_pFontLoaded = true;
}

DWORD XBRavMenu::Routine(DWORD command)
{
	static float menutime = 0.0f;
	float time;
	XBRavMenu *m;
	XMenuItem *mi;
	DWORD status;

	// check for menu routine first
	if(XBRavMenu::m_pCurRoutine)
	{
		status = XBRavMenu::m_pCurRoutine(command, NULL);
		if(status==MROUTINE_DIE)
		{
			XBRavMenu::m_pCurRoutine = NULL;
		}
//		return 0;
	}

	m = XBRavMenu::m_pCurMenu;
	if(!m)
		return 0;
//	else
//		m->Render();

	time = XBUtil_Timer(TIMER_GETABSOLUTETIME);

	if(m->curitem >= m->nitems)
	{
		m->curitem = m->nitems - 1;
	}
	else if(m->curitem < 0)
	{
		m->curitem = 0;
	}

	int looped = 0;

	switch(command)
	{
		case MENU_NEXTITEM:
			if((time-menutime)<0.2f)
				return 0;
			menutime = time;

			if(m->m_pItems.size() == 0)
				break;

			do
			{
				m->curitem++;
				if(m->curitem==m->nitems)
					if(m->flags&MENU_WRAP)
					{
						looped++;
						m->curitem = 0;
					}
					else
					{
						looped++;
						m->curitem = m->nitems-1;
					}

				if( looped >= 2 )
				{
					break;
				}

			} while(m->m_pItems[m->curitem]->flags&(MITEM_SEPARATOR|MITEM_DISABLED));
			break;

		case MENU_PREVITEM:
			if((time-menutime)<0.2f)
				return 0;
			menutime = time;

			if(m->m_pItems.size() == 0)
				break;

			do
			{
				m->curitem--;
				if(m->curitem==-1)
					if(m->flags&MENU_WRAP)
					{
						looped++;
						m->curitem = m->nitems-1;
					}
					else
					{
						looped++;
						m->curitem = 0;
					}

				if( looped >= 2 )
				{
					break;
				}

			} while(m->m_pItems[m->curitem]->flags&(MITEM_SEPARATOR|MITEM_DISABLED));

			menutime = time;
			break;

		case MENU_SELECTITEM:
			if(m->m_pItems.size() == 0 || m->m_pItems[m->curitem]->flags&(MITEM_SEPARATOR|MITEM_DISABLED))
			{
				break;
			}

			mi = m->m_pItems[m->curitem];

			if(mi->flags&MITEM_ROUTINE)
			{
				// do routine
				XBRavMenu::m_pCurRoutine = (int (*)(DWORD, XMenuItem *))mi->action;
				status = XBRavMenu::m_pCurRoutine(MROUTINE_INIT, mi);

				// check return value...
				if(status==MROUTINE_DIE)
				{
					m->Activate(false);			// kill the current menu
					XBRavMenu::m_pCurRoutine = NULL;		// and the routine
					if(m->parent)							// activate parent menu if it exists
						((XBRavMenu*)m->parent)->Activate();
					delete m;
				}
				else if(status==MROUTINE_RETURN)	// just kill the routine
					XBRavMenu::m_pCurRoutine = NULL;
				else if(status==MROUTINE_SLEEP)
					m->Activate(false);			// just kill the current menu
			}
			else
			{
				// activate next menu if it exists
				if(mi->action)
				{
					((XBRavMenu*)mi->action)->Activate();
					XBRavMenu::m_pCurMenu->parent = m;		// the menu that called me
				}
				else
				{
					if(m->abortroutine)
						m->abortroutine(MROUTINE_ABORT, NULL);

					m->Activate(false);			// kill the current menu
				}
			}
			break;

		case MENU_BACK:
			if(!(m->flags&MENU_NOBACK))
			{
				if(m->abortroutine)						// call abort routine if it exists
					m->abortroutine(MROUTINE_ABORT, NULL);

				if(m->parent)							// activate parent menu if it exists
					((XBRavMenu*)m->parent)->Activate();
				else
					m->Activate(false);			// kill the current menu
			}
			break;

		default:
			break;
	}

	return 1;
}

//-----------------------------------------------------------------------------
// Name: DrawRect
// Desc: Draws a gradient filled rectangle
//-----------------------------------------------------------------------------
void XBRavMenu::DrawRect(float x, float y, float w, float h, DWORD dwTopColor, DWORD dwBottomColor)
{
    static LPDIRECT3DVERTEXBUFFER8 XMenu_VB = NULL;
    struct BACKGROUNDVERTEX
	{
		D3DXVECTOR4 p;
		D3DCOLOR color;
	} *v;

    if(XMenu_VB == NULL)
        g_pd3dDevice->CreateVertexBuffer(4*sizeof(BACKGROUNDVERTEX), D3DUSAGE_WRITEONLY,
                                          0L, D3DPOOL_DEFAULT, &XMenu_VB);

    // Setup vertices for a background-covering quad
	XMenu_VB->Lock(0, 0, (BYTE **)&v, NULL);
    v[0].p = D3DXVECTOR4(x, y, 1.0f, 1.0f);
	v[0].color = dwTopColor;
    v[1].p = D3DXVECTOR4(x+w, y, 1.0f, 1.0f);
	v[1].color = dwTopColor;
    v[2].p = D3DXVECTOR4(x, y+h, 1.0f, 1.0f);
	v[2].color = dwBottomColor;
    v[3].p = D3DXVECTOR4(x+w, y+h, 1.0f, 1.0f);
	v[3].color = dwBottomColor;
	XMenu_VB->Unlock();

	// set render states
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);

    // Set states
    g_pd3dDevice->SetTexture(0, NULL);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
    g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_DIFFUSE);
    g_pd3dDevice->SetStreamSource(0, XMenu_VB, sizeof(BACKGROUNDVERTEX));

    // Render the quad
    g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

	// restore render state
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
}

void XBRavMenu::Render()
{
	float menux, menuy;
	float rectx, recty, rectw, recth;
	float itemx, itemy, itemh;
	float w, h;
	DWORD i, color;
	DWORD firstitem, nitems;
	WCHAR* str;
	XMenuItem *mi;
	WCHAR ddd[11] = L"--MORE--";


	if(!XBRavMenu::m_pFontLoaded || this->m_pItems.size() == 0)
		return;

	if(!m_bHideParent && ((_xmenu*)this)->parent != NULL)
	{
		((XBRavMenu*)((_xmenu*)this)->parent)->Render();
	}

	// get height of font
	itemh = (float)XBRavMenu::m_pFont->GetFontHeight();

	// draw menu background
	rectx = this->x;
	rectw = this->w;
//	recty = this->y - itemh/2.0f;
	if(m_bHasTitle)
	{
		recty = this->y + itemh;
		recth = this->h - itemh;
	}
	else
	{
		recty = this->y;
		recth = this->h;
	}
	// Outer Rectangle Background of Menu.
	if(m_bShowBackground)
	{
		if(this->flags&(MENU_LEFT|MENU_RIGHT))
		{
//			DrawRect(rectx-8.0f, recty, rectw, recth, this->topcolor, this->bottomcolor);
			OutputDebugString("");
			DrawRect(rectx, recty, rectw, recth, this->topcolor, this->bottomcolor);
		}
		else if(m_bHideParent)
		{
			DrawRect(rectx-(rectw/2.0f), recty, rectw, recth, this->topcolor, this->bottomcolor);
		}
		else //draw to the right of parent menu
		{
			DrawRect(rectx, recty, rectw, recth, this->topcolor, this->bottomcolor);
		}
	}

	menux = this->x;
	menuy = this->y;

	if(this->nitems == this->m_pItems.size())
		this->nitems = this->m_pItems.size();

	// determine which menu items to show (firstitem, nitems)
	if(this->nitems>this->maxshow)
	{
		if(this->curitem<(this->maxshow/2))
			firstitem = 0;
		else if(this->curitem<(this->nitems-(this->maxshow/2)))
			firstitem = this->curitem-(this->maxshow/2)+(!(this->maxshow%2));
		else
			firstitem = this->nitems-this->maxshow;
	}
	else
		firstitem = 0;

	if(this->nitems>this->maxshow)
		nitems = this->maxshow;
	else
		nitems = this->nitems;

	itemy = menuy;

	// draw the menu title
	if(this->m_bHasTitle)
	{
//		itemy += itemh/2.0f;
		float h,w;

		XBRavMenu::m_pFont->GetTextExtent(this->title, &w, &h);

		if(this->flags&MENU_LEFT)
			XBRavMenu::m_pFont->DrawText(menux + 10.f, itemy, this->titlecolor, this->title);
		else if(this->flags&MENU_RIGHT)
			XBRavMenu::m_pFont->DrawText(menux + (this->GetW() - w) - 10.0f, itemy, this->titlecolor, this->title);
		else if(m_bHideParent)
			XBRavMenu::m_pFont->DrawText(menux, itemy, this->titlecolor, this->title, XBFONT_CENTER_X);
		else
			XBRavMenu::m_pFont->DrawText(menux, itemy, this->titlecolor, this->title);

//		itemy += 1.5f*itemh;
//		itemy += 2.0f*itemh * 1.1f;
		itemy += itemh * 1.1f;
	}

	// draw the menu items
	for(i=firstitem; i<nitems+firstitem; i++)
	{
		mi = this->m_pItems[i];

		if(!(mi->flags&MITEM_SEPARATOR))
		{
			str = mi->string;
			if(this->nitems>this->maxshow)
			{
				if((i==firstitem) && (firstitem!=0))
					str = ddd;
				if((i==(firstitem+nitems-1)) && (firstitem!=(this->nitems-this->maxshow)))
					str = ddd;
			}

			//Rectangle around highlighted item
			if(m_bShowHighlight)
			{

//				rectx = this->x;

				if(i==this->curitem)
				{
					if(this->flags&(MENU_LEFT|MENU_RIGHT))
					{
						DrawRect(rectx, itemy, rectw, XBRavMenu::m_pFont->GetFontHeight()+2.0f, this->seltopcolor, this->selbotcolor);
					}
					else if(m_bHideParent)
					{
						OutputDebugString("");
						DrawRect(rectx-(rectw/2.0f), itemy, rectw, XBRavMenu::m_pFont->GetFontHeight()+2.0f, this->seltopcolor, this->selbotcolor);
					}
					else
					{
						DrawRect(rectx, itemy, rectw, XBRavMenu::m_pFont->GetFontHeight()+2.0f, this->seltopcolor, this->selbotcolor);
//						OutputDebugString("showing parent, not centering curitem highlight.\n");
					}
				}
			}

			DWORD negColor;
			float edgeSize;
			if(mi->flags&MITEM_DISABLED)
				{
//				color = (mi->color&0xffffff) | 0x40000000;	// lower alpha
				color = 0xff111111;// & 0xffffff);// | 0x8000000;	// lower alpha
//				negColor = 0xffeeeeee;
				negColor = color;
//				edgeSize = 1.0f;
				edgeSize = 0.5f;
//				edgeSize = 0.0f;
				}
			else if(i==this->curitem)
				{
				color = (0xffffffff - this->seltopcolor) | 0xff000000;
//				color = (0xffffffff - this->seltopcolor) | 0xff000000;
				negColor = 0xff646464;
//				negColor = (0xffffffff - color) | 0xff000000;
				edgeSize = 1.0f;
//				edgeSize = 0.5f;
//				edgeSize = 0.0f;
				}
			else
				{
				color = mi->color;
//				color = RAV_COLORKEY;
//				negColor = ( (this->seltopcolor / 2) + (mi->color / 2) ) | 0xff000000;
				negColor = 0xff646464;
//				edgeSize = 1.0f;
				edgeSize = 0.5f;
//				edgeSize = 0.0f;
				}

			if(this->flags&MENU_LEFT)
			{
				itemx = menux + 10.0f;
				if(m_bShowTextEdge)
				{
					XBRavMenu::m_pFont->DrawText(itemx - edgeSize, itemy - edgeSize, negColor, str);
					XBRavMenu::m_pFont->DrawText(itemx + edgeSize, itemy + edgeSize, negColor, str);
					XBRavMenu::m_pFont->DrawText(itemx - edgeSize, itemy + edgeSize, negColor, str);
					XBRavMenu::m_pFont->DrawText(itemx + edgeSize, itemy - edgeSize, negColor, str);
				}
				XBRavMenu::m_pFont->DrawText(itemx, itemy, color, str);
			}
			else if(this->flags&MENU_RIGHT)
			{
				XBRavMenu::m_pFont->GetTextExtent(str, &w, &h);
				itemx = menux + (this->GetW() - w) - 10.0f;
				if(m_bShowTextEdge)
				{
					XBRavMenu::m_pFont->DrawText(itemx - edgeSize, itemy - edgeSize, negColor, str);
					XBRavMenu::m_pFont->DrawText(itemx + edgeSize, itemy + edgeSize, negColor, str);
					XBRavMenu::m_pFont->DrawText(itemx - edgeSize, itemy + edgeSize, negColor, str);
					XBRavMenu::m_pFont->DrawText(itemx + edgeSize, itemy - edgeSize, negColor, str);
				}
				XBRavMenu::m_pFont->DrawText(itemx, itemy, color, str);
			}
			else if(m_bHideParent)
			{
				XBRavMenu::m_pFont->GetTextExtent(str, &w, &h);
				itemx = menux;
//				itemx = menux-(w/2.0f);
				if(m_bShowTextEdge)
				{
					XBRavMenu::m_pFont->DrawText(itemx - edgeSize, itemy - edgeSize, negColor, str, XBFONT_CENTER_X);
					XBRavMenu::m_pFont->DrawText(itemx + edgeSize, itemy + edgeSize, negColor, str, XBFONT_CENTER_X);
					XBRavMenu::m_pFont->DrawText(itemx - edgeSize, itemy + edgeSize, negColor, str, XBFONT_CENTER_X);
					XBRavMenu::m_pFont->DrawText(itemx + edgeSize, itemy - edgeSize, negColor, str, XBFONT_CENTER_X);
				}
				XBRavMenu::m_pFont->DrawText(itemx, itemy, color, str, XBFONT_CENTER_X);
			}
			else
			{
				XBRavMenu::m_pFont->GetTextExtent(str, &w, &h);
				itemx = menux+(this->GetW()/2.0f);
//				itemx = menux;
				if(m_bShowTextEdge)
				{
					XBRavMenu::m_pFont->DrawText(itemx - edgeSize, itemy - edgeSize, negColor, str, XBFONT_CENTER_X);
					XBRavMenu::m_pFont->DrawText(itemx + edgeSize, itemy + edgeSize, negColor, str, XBFONT_CENTER_X);
					XBRavMenu::m_pFont->DrawText(itemx - edgeSize, itemy + edgeSize, negColor, str, XBFONT_CENTER_X);
					XBRavMenu::m_pFont->DrawText(itemx + edgeSize, itemy - edgeSize, negColor, str, XBFONT_CENTER_X);
				}
				XBRavMenu::m_pFont->DrawText(itemx, itemy, color, str, XBFONT_CENTER_X);
			}
		}

		itemy += XBRavMenu::m_pFont->GetFontHeight() * 1.1f;
	}

}

void XMenu_SetMaxShow(XMenu *m, DWORD maxshow)
{
	m->maxshow = maxshow;
	if(m->nitems > maxshow)
		m->h = (float)(m->maxshow+1) * XBRavMenu::m_pFont->GetFontHeight() * 1.1f;
	else
		m->h = (float)(m->maxshow) * XBRavMenu::m_pFont->GetFontHeight() * 1.1f;
}

void XMenu_SetTitle(XMenu *m, WCHAR *string, DWORD color)
{
	float w, h;

	m->titlecolor = color;

	if(string)
	{
		// set string
//		_tcsncpy(m->title, string, MITEM_STRINGLEN-1);
		wcsncpy(m->title, string, MITEM_STRINGLEN-1);

		// calculate new menu width based on this item
		XBRavMenu::m_pFont->GetTextExtent(string, &w, &h);
		if(m->w<(w+16.0f))
		{
			if(w < 200)
			{
				m->w = w+16.0f;
			}
			else
			{
				m->w = 216;
			}
		}

		m->h = (float)(m->maxshow+3) * XBRavMenu::m_pFont->GetFontHeight();
	}
	else
		m->h = (float)(m->maxshow+1) * XBRavMenu::m_pFont->GetFontHeight();
}

void XMenu_SetItemText(XMenuItem *mi, WCHAR *string)
{
	float w, h;

	if(!string || (mi->flags&MITEM_SEPARATOR))
		return;

	// set string
//	_tcsncpy(mi->string, string, MITEM_STRINGLEN-1);
	wcsncpy(mi->string, string, MITEM_STRINGLEN-1);

	// calculate new menu width based on this item
	XBRavMenu::m_pFont->GetTextExtent(string, &w, &h);
	if(mi->menu->w<(w+16.0f))
		mi->menu->w = w+16.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\XbRavMenu.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef _XBRAVMENU_
#define _XBRAVMENU_

#pragma warning(disable : 4786)
#pragma warning(disable : 4018)
#pragma warning(disable : 4245)

#include <XBApp.h>
#include <XMenu.h>
#include <vector>
#include <map>

#define RAV_COLORKEY	D3DCOLOR_XRGB(0xFF, 0x80, 0xd0)

typedef struct _XBMenuProfile
{
	WCHAR	title[MAX_PATH];
	DWORD	maxitems;
	DWORD	flags;
	bool	hideparent;
	bool	showbackground;
	bool	showhighlight;
	bool	showtextedge;
	DWORD	topcolor;
	DWORD	bottomcolor;
	DWORD	itemcolor;
	DWORD	seltopcolor;
	DWORD	selbotcolor;
} XBMenuProfile;

using namespace std;

class XBRavMenu : public XMenu
{
private:
	vector <XMenuItem*> m_pItems;

	void UpdateSize(void);
	bool m_bHasTitle;
	bool m_bShowBackground;
	bool m_bShowHighlight;
	bool m_bHideParent;
	bool m_bShowTextEdge;
	void Initialize(WCHAR* title, float x, float y, DWORD maxitems, DWORD flags, DWORD *abortroutine,
						DWORD topcolor, DWORD bottomcolor, DWORD itemcolor, DWORD seltopcolor, DWORD selbotcolor, XBRavMenu * parent = NULL);
	void DrawRect(float x, float y, float w, float h, DWORD dwTopColor, DWORD dwBottomColor);

public:

	XBRavMenu(XBMenuProfile* profile, float x, float y, DWORD *abortroutine, XBRavMenu * parent = NULL);
	XBRavMenu(WCHAR * title, float x, float y, DWORD maxitems, DWORD flags, DWORD *abortroutine, XBRavMenu * parent = NULL);
	XBRavMenu(WCHAR * title, float x, float y, DWORD maxitems, DWORD flags, DWORD *abortroutine,
			  DWORD topcolor, DWORD bottomcolor, DWORD itemcolor, DWORD seltopcolor, DWORD selbotcolor, XBRavMenu * parent = NULL);
	~XBRavMenu(void);
	void AddItem(DWORD flags, WCHAR *string, void *action);
	void AddItem(WCHAR *string, void *action);
	bool DeleteItem(XMenuItem*);
	bool DeleteItem(int);
	int GetItemIndex(XMenuItem* item);
	XMenuItem* GetItem(int item);

	float GetX()
	{
		return this->x;
	}

	float GetY()
	{
		return this->y;
	}

	float GetW()
	{
		return this->w;
	}

	float GetH()
	{
		return this->h;
	}

	float GetBodyY()
	{
		if(m_bHasTitle)
			return this->y + (1.0f * (this->h / (nitems + 1.0f)));
		else
			return GetY();
	}

	float GetBodyH()
	{
		return this->h - (GetBodyY() - GetY());
	}

	void Activate(bool act = true);
	void Render(void);
	static bool IsActive(void);
	DWORD ProcessGamePadInput(XBGAMEPAD *gamepad);
	DWORD ProcessCommand(DWORD command);

	static void SetFont(CXBFont*);

	DWORD Routine(DWORD command);

	// static information for all menus
	static CXBFont* m_pFont;
	static bool m_pFontLoaded;

	// static information for the current active menu.
	static XBRavMenu * m_pCurMenu;
	static int (*m_pCurRoutine)(DWORD cmd, XMenuItem *mi);

	static XBRavMenu * GetActiveMenu(void);
};

#endif //_XBRAVMENU_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbfont.cpp ===
//-----------------------------------------------------------------------------
// File: XBFont.cpp
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBFont.h"




// Max size for the font class' vertex buffer
const DWORD XBFONT_MAX_VERTICES = 1024 * 4;

// Helper function to init a vertex
inline XBFONTVERTEX InitFontVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                    FLOAT tu, FLOAT tv )
{
    XBFONTVERTEX v;   
    v.p     = p;   
    v.color = color;   
    v.tu    = tu;   
    v.tv    = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CXBFont()
// Desc: Font class constructor.
//-----------------------------------------------------------------------------
CXBFont::CXBFont()
{
    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;

    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        m_pVBs[i] = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFont()
// Desc: Font class destructor.
//-----------------------------------------------------------------------------
CXBFont::~CXBFont()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the image and information from two files.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                         const CHAR* strFontResourceFileName )
{
    HRESULT hr;

    // Store the device for use in member functions
    m_pd3dDevice = pd3dDevice;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, strFontResourceFileName, 
                                      2 ) ) )
        return E_FAIL;

    m_pTexture = m_xprResource.GetTexture( 0UL );

    BYTE* pData = (BYTE*)m_xprResource.GetData( XBResource_SizeOf(m_pTexture) );
    DWORD dwResourceType = ((DWORD*)pData)[0];
    DWORD dwResourceSize = ((DWORD*)pData)[1];
    pData += 2*sizeof(DWORD);

    DWORD dwVersion = ((DWORD*)pData)[0];
    m_dwFontHeight  = ((DWORD*)pData)[1];
    m_dwTexWidth    = ((DWORD*)pData)[2];
    m_dwTexHeight   = ((DWORD*)pData)[3];
    DWORD dwBPP     = ((DWORD*)pData)[4];
    pData += 5*sizeof(DWORD);

    // Check version of file (to make sure it matches up with the FontMaker tool)
    if( dwVersion != 0x00000004 )
    {
        OutputDebugStringA( "XBFont: Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Read the low and high char
    m_cLowChar  = ((WCHAR*)pData)[0];
    m_cHighChar = ((WCHAR*)pData)[1];
    pData += 2*sizeof(WCHAR);

    // Read the glyph attributes from the file
    m_Glyphs = (GLYPH_ATTR*)(pData+4);

    // Create vertex buffer for rendering text strings
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
    {
        hr = pd3dDevice->CreateVertexBuffer( XBFONT_MAX_VERTICES*sizeof(XBFONTVERTEX),
                                             D3DUSAGE_WRITEONLY, 0L,
                                             D3DPOOL_DEFAULT, &m_pVBs[i] );
        if( FAILED(hr) )
            return hr;
    }

    // Assign a current vertex buffer
    m_dwCurrentBuffer = 0L;
    m_pVB = m_pVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the font object
//-----------------------------------------------------------------------------
HRESULT CXBFont::Destroy()
{
    m_xprResource.Destroy();

    // Delete vertex buffers
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        SAFE_RELEASE( m_pVBs[i] );

    if( m_bTextureFromFile )
    {
        SAFE_RELEASE( m_pTexture );
        delete [] m_Glyphs;
    }

    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CXBFont::GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                                FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    // Check parameters
    if( NULL==strText || NULL==pWidth || NULL==pHeight )
        return E_INVALIDARG;

    // Set default text extent in output parameters
    (*pWidth)   = 0.0f;
    (*pHeight)  = 0.0f;

    // Initialize counters that keep track of text extent
    FLOAT sx = 0.0f;
    FLOAT sy = (FLOAT)(m_dwFontHeight + 1);

    // Loop through each character and update text extent
    while( *strText )
    {
        WCHAR letter = *strText++;
        
        // Handle newline character
        if( letter == L'\n' )
        {
            if( bFirstLineOnly )
                return S_OK;
            sx  = 0.0f;
            sy += (FLOAT)(m_dwFontHeight + 1);
        }

        // Ignore unprintable characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get text extent for this character's glyph
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter - m_cLowChar];
        sx += pGlyph->wOffset;
        sx += pGlyph->wAdvance;

        // Store text extent of string in output parameters
        if( sx > (*pWidth) )   (*pWidth)  = sx;
        if( sy > (*pHeight) )  (*pHeight) = sy;
     }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Begin()
{
    // Lock vertex buffer on the first call (allow nesting of begin/end calls)
    if( 0 == m_dwNestedBeginCount )
    {
        // Assign a current vertex buffer
        if( m_pVB->IsBusy() )
        {
            if( ++m_dwCurrentBuffer >= NUM_FONT_BUFFERS )
                m_dwCurrentBuffer = 0L;
            m_pVB = m_pVBs[m_dwCurrentBuffer];
        }

        // Lock the vertex buffer
        m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
        m_dwNumQuads = 0;
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//-----------------------------------------------------------------------------
HRESULT CXBFont::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                           const WCHAR* strText, DWORD dwFlags )
{
    // Set up stuff (i.e. lock the vertex buffer) to prepare for drawing text
    Begin();

    // Set the starting screen position
    FLOAT sx = fOriginX;
    FLOAT sy = fOriginY;

    // If vertically centered, offset the starting sy value
    if( dwFlags & XBFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        sy = floorf( sy - h/2 );
    }

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    while( *strText )
    {
        // If starting text on a new line, determine justification effects
        if( bStartingNewLine )
        {
            if( dwFlags & (XBFONT_RIGHT|XBFONT_CENTER_X) )
            {
                // Get the extent of this line
                FLOAT w, h;
                GetTextExtent( strText, &w, &h, TRUE );

                // Offset this line's starting sx value
                if( dwFlags & XBFONT_RIGHT )
                    sx = floorf( fOriginX - w );
                if( dwFlags & XBFONT_CENTER_X )
                    sx = floorf( fOriginX - w/2 );
            }
            bStartingNewLine = FALSE;
        }

        // Get the current letter in the string
        WCHAR letter = *strText++;

        // Handle the newline character
        if( letter == L'\n' )
        {
            sx  = fOriginX;
            sy += m_dwFontHeight;
            bStartingNewLine = TRUE;
        }

        // Skip invalid characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get the glyph for this character
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter-m_cLowChar];

        // Setup the screen coordinates (note the 0.5f shift value which is to
        // align texel centers with pixel centers)
        sx += pGlyph->wOffset;
        FLOAT sx1 = sx - 0.5f;
        FLOAT sx2 = sx - 0.5f + ((FLOAT)pGlyph->wWidth + 1);
        FLOAT sy1 = sy - 0.5f;
        FLOAT sy2 = sy - 0.5f + ((FLOAT)m_dwFontHeight + 1);
        sx += pGlyph->wAdvance;

        // Setup the texture coordinates (note the fudge factor for converting
        // from integer texel values to floating point texture coords).
        FLOAT tx1 = ( pGlyph->left   * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty1 = ( pGlyph->top    * (m_dwTexHeight-1) ) / m_dwTexHeight;
        FLOAT tx2 = ( pGlyph->right  * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty2 = ( pGlyph->bottom * (m_dwTexHeight-1) ) / m_dwTexHeight;

        // Set up the vertices (1 quad = 2 triangles = 6 vertices)
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy2,0.0f,0.0f), dwColor, tx1, ty2 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy1,0.0f,0.0f), dwColor, tx1, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy1,0.0f,0.0f), dwColor, tx2, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy2,0.0f,0.0f), dwColor, tx2, ty2 );
        m_dwNumQuads++;

        // If the vertex buffer is full, render it. This will stall the GPU, so
        // we should sure that XBFONT_MAX_VERTICES is big enough.
        if( (m_dwNumQuads+1)*4 > XBFONT_MAX_VERTICES )
        {
            // Unlock, render, and relock the vertex buffer
            m_pVB->Unlock();
            Render();
            m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
            m_dwNumQuads = 0L;
        }
    }

    // Call End() to complete the begin/end pair for drawing text
    End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called after Begin(), this function triggers the rendering of the
//       vertex buffer contents filled during calls to DrawText().
//-----------------------------------------------------------------------------
HRESULT CXBFont::End()
{
    // Keep track of nested calls to begin/end.
    if( 0L == m_dwNestedBeginCount )
        return E_FAIL;
    if( --m_dwNestedBeginCount > 0 )
        return S_OK;
    
    // Unlock the vertex buffer
    m_pVB->Unlock();

    // Render the contents of the vertex buffer
    if( m_dwNumQuads > 0 )
        Render();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: The internal call to actually render the vertices.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Render()
{
    // Set the necessary renderstates
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(XBFONTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_XBFONTVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the vertex buffer
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumQuads );

    // We can restore state here, if we like. Unfortunately, for generic use,
    // it's hard to guess what state the app will want everything restored to.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToTexture()
// Desc: Creates a texture and renders a text string into it. The texture
//       format defaults to a 32-bit linear texture
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBFont::CreateTexture( const WCHAR* strText, 
                                           D3DCOLOR dwBackgroundColor, 
                                           D3DCOLOR dwTextColor, 
                                           D3DFORMAT d3dFormat )
{
    // Calculate texture dimensions
    FLOAT fTexWidth;
    FLOAT fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth  = (DWORD)fTexWidth;
    DWORD dwHeight = (DWORD)fTexHeight;

    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
            // For swizzled textures, make sure the dimensions are a power of two
            for( DWORD wmask=1; dwWidth&(dwWidth-1); wmask = (wmask<<1)+1 )
                dwWidth  = ( dwWidth + wmask ) & ~wmask;
            for( DWORD hmask=1; dwHeight&(dwHeight-1); hmask = (hmask<<1)+1 )
                dwHeight = ( dwHeight + hmask ) & ~hmask;
            break;

        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_X1R5G5B5:
            // For linear textures, make sure the stride is a multiple of 64 bytes
            dwWidth  = ( dwWidth + 0x1f ) & ~0x1f;
            break;

        default:
            // All other formats are unsupported as render targets
            return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE8 pTexture;
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat, 
                                             D3DPOOL_DEFAULT, &pTexture ) ) )
        return NULL;
    
    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Set the new texture as the render target
    LPDIRECT3DSURFACE8 pTextureSurface;
    pTexture->GetSurfaceLevel( 0, &pTextureSurface );
    D3DVIEWPORT8 vp = { 0, 0, dwWidth, dwHeight, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pTextureSurface, NULL );
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    DrawText( 0, 0, dwTextColor, strText, 0L );

    // Restore the rendertarget
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    m_pd3dDevice->SetViewport( &vpBackBuffer );
    SAFE_RELEASE( pBackBuffer );
    SAFE_RELEASE( pZBuffer );
    SAFE_RELEASE( pTextureSurface );

    // Return the new texture
    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: ReplaceInvalidChars()
// Desc: Replaces any character that does not have a glyph in the font with
//       the specified character value. Function is useful for replacing
//       invalid characters with the null "box" character.
//-----------------------------------------------------------------------------
VOID CXBFont::ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const
{
    // TCR 3-26 Unsupported Characters
    for( ; *strUpdate; ++strUpdate )
    {
        WCHAR cLetter = *strUpdate;
        if( cLetter == L'\n' )
            continue;
        if( cLetter < m_cLowChar || cLetter > m_cHighChar )
            *strUpdate = cReplacement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xmenu.h ===
#ifndef __XMENU_H
#define __XMENU_H

#include "XBFont.h"
#include "XBInput.h"

// menu item flags
#define MITEM_SEPARATOR		0x0001			// this item is a separator
#define MITEM_ROUTINE		0x0002			// this item calls a routine
#define MITEM_DISABLED		0x0004			// this item is greyed out

// menu routine commands
#define MROUTINE_INIT		0xffff			// first call to routine
#define MROUTINE_ABORT		0xfffe			// abort routine triggered

// menu routine return values
#define MROUTINE_RETURN		0x0001			// return to menu
#define MROUTINE_DIE		0x0002			// kill routine
#define MROUTINE_SLEEP		0x0003			// routine sleeps

// menu item definition
#define MITEM_STRINGLEN 48
typedef struct _xmenuitem
{
	DWORD flags;
	WCHAR string[MITEM_STRINGLEN];			// text to display
	DWORD val1;								// user defined values
	DWORD val2;
	void *action;							// link to menu or routine
	struct _xmenu *menu;					// menu that owns this item
	DWORD color;							// item color
} XMenuItem;

// menu commands
#define MENU_NEXTITEM		0x0001			// next menu item
#define MENU_PREVITEM		0x0002			// previous menu item
#define MENU_SELECTITEM		0x0003			// select this menu item
#define MENU_BACK			0x0004			// go back one level
#define MENU_ACTIVATE		0x0005			// activate menu

// menu flags
#define MENU_LEFT			0x0001			// left justify menu text
#define MENU_RIGHT			0x0002			// right justify menu text
#define MENU_WRAP			0x0004			// wrap menu selection
#define MENU_NOBACK			0x0008			// cannot use back button

typedef struct _xmenu
{
	float x, y;								// screen position
	float w, h;								// menu size
	DWORD flags;							// menu flags
	DWORD topcolor, bottomcolor;			// menu background gradient color
	DWORD seltopcolor, selbotcolor;			// menu selection bar gradient color
	DWORD itemcolor;						// menu item default color
	struct _xmenu *parent;					// parent menu

	WCHAR title[MITEM_STRINGLEN];			// menu title
	DWORD titlecolor;						// memu title color
	DWORD maxshow;							// max # of items to show at one time
	DWORD maxitems;							// max # of items
	DWORD nitems;							// # of items
	DWORD curitem;							// current selected item
	XMenuItem *items;						// items

	DWORD (*abortroutine)(DWORD, XMenuItem *);	// called when menu aborted
} XMenu;

#ifdef __cplusplus
extern "C" {
#endif

extern XMenu *XMenu_CurMenu;
extern int (*XMenu_CurRoutine)(DWORD cmd, XMenuItem *mi);

void XMenu_SetFont(CXBFont *font);
XMenu *XMenu_Init(float x, float y, DWORD maxitems, DWORD flags, DWORD (*abortroutine)(DWORD, XMenuItem *));
void XMenu_Shutdown();
void XMenu_Delete(XMenu *m);
XMenuItem *XMenu_AddItem(XMenu *m, DWORD flags, WCHAR *string, void *action);
void XMenu_DeleteItem(XMenuItem *mi);
void XMenu_SetMaxShow(XMenu *m, DWORD maxshow);
void XMenu_SetTitle(XMenu *m, WCHAR *string, DWORD color);
void XMenu_SetItemText(XMenuItem *mi, WCHAR *string);
#define XMenu_IsActive() (XMenu_CurMenu||XMenu_CurRoutine)

DWORD XMenu_GetCommand(XBGAMEPAD *gamepad);	// gets command based on joypad
DWORD XMenu_Activate(XMenu *m);				// activates a menu
DWORD XMenu_Routine(DWORD command);			// called each frame to update menu

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\XbSplash.Cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// File: XBSplash.cpp
//
// Desc: Support class for rendering a help image, which is an image of an Xbox
//       gamepad, with labelled callouts to each of the gamepad's controls.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <tchar.h>
#include <stdio.h>
#include "XBSplash.h"



//-----------------------------------------------------------------------------
// Name: CXBSplash()
// Desc: Help class constructor
//-----------------------------------------------------------------------------
CXBSplash::CXBSplash()
{
    m_pd3dDevice      = NULL;
    m_pSplashTexture = NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the help class' internal objects
//-----------------------------------------------------------------------------
HRESULT CXBSplash::Create( LPDIRECT3DDEVICE8 pd3dDevice, UINT nWidth, UINT nHeight )
{
    // Keep track of the device
    m_pd3dDevice = pd3dDevice;
	m_nWidth = nWidth;
	m_nHeight = nHeight;

	// Create the gamepad texture
    if( FAILED( XBUtil_CreateTexture( m_pd3dDevice, "Textures\\Cinemx32.tga",
                                      &m_pSplashTexture, D3DFMT_A8R8G8B8 ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the class' internal objects/
//-----------------------------------------------------------------------------
HRESULT CXBSplash::Destroy()
{
    SAFE_RELEASE(m_pSplashTexture);
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the splash image
//-----------------------------------------------------------------------------
HRESULT CXBSplash::Render()
{
    // First time around, create a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*6*sizeof(FLOAT), D3DUSAGE_WRITEONLY,
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct VERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
        VERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, NULL );
        v[0].p = D3DXVECTOR4(   0,   0, 0.0f, 0.5f ); v[0].tu = 0.0f; v[0].tv = 0.0f;
        v[1].p = D3DXVECTOR4( (FLOAT) m_nWidth,   0, 0.0f, 0.5f ); v[1].tu = 1.0f; v[1].tv = 0.0f;
        v[2].p = D3DXVECTOR4(   0, (FLOAT) m_nHeight, 0.0f, 0.5f ); v[2].tu = 0.0f; v[2].tv = 1.0f;
        v[3].p = D3DXVECTOR4( (FLOAT) m_nWidth, (FLOAT) m_nHeight, 0.0f, 0.5f ); v[3].tu = 1.0f; v[3].tv = 1.0f;
        g_pVB->Unlock();
    }

    // Set state to render the splash image
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCCOLOR);
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_DESTCOLOR);
    m_pd3dDevice->SetTexture( 0, m_pSplashTexture );
//    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
//    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
//    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
//    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
//    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
//    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
//    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
//    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );

    m_pd3dDevice->SetStreamSource( 0, g_pVB, 6*sizeof(FLOAT) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbutil.cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Allocate memory for storing the surface bits
    VOID* pBits = (VOID*)new DWORD[desc.Width*desc.Height];

    // Unswizzle the bits, if necessary
    if( XGIsSwizzledFormat( desc.Format ) )
        XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL,
                         pBits, lock.Pitch, NULL, sizeof(DWORD) );
    else
        memcpy( pBits, lock.pBits, desc.Size );
    
    // Unlock the surface
    pSurface->UnlockRect();

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    delete[] pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0     = Vertex position
//          v1     = Vertex blend weights
//          v2     = Vertex normal
//          v3     = Vertex diffuse color
//          v4     = Vertex specular color
//       // v5     = Vertex fog (no FVF code)
//       // v6     = Vertex pointsize (no FVF code)
//       // v7     = Vertex back diffuse color (no FVF code)
//       // v8     = Vertex back specular color (no FVF code)
//          v9-v12 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 3, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwNumTexCoords = 0;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
            dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 9 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\XbSplash.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// File: XBSplash.h
//
// Desc: Support class for rendering a splash image
//
//-----------------------------------------------------------------------------
#ifndef XBSPLASH_H
#define XBSPLASH_H
#include "XBFont.h"
#include "XBUtil.h"


//-----------------------------------------------------------------------------
// Name: class CXBSplash
// Desc: Class for rendering a splash image
//-----------------------------------------------------------------------------
class CXBSplash
{
    LPDIRECT3DDEVICE8  m_pd3dDevice;
    LPDIRECT3DTEXTURE8 m_pSplashTexture;

	UINT m_nWidth, m_nHeight;

public:
    // Constructor
    CXBSplash();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, UINT nWidth, UINT nHeight );
    HRESULT Destroy();

    // Renders the splash screen
    HRESULT Render();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\xbutil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\XbTga.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// File: XBTga.h
//
// Desc: Support class for rendering a splash image
//
//-----------------------------------------------------------------------------
#ifndef XBTGA_H
#define XBTGA_H
#include "XBFont.h"
#include "XBUtil.h"


//-----------------------------------------------------------------------------
// Name: class CXBTga
// Desc: Class for rendering a targa image
//-----------------------------------------------------------------------------
class CXBTga
{
    LPDIRECT3DDEVICE8  m_pd3dDevice;
    LPDIRECT3DTEXTURE8 m_pTgaTexture;
	RECT m_pos;

public:
    // Constructor
    CXBTga();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, char* pFilename, RECT pos );
    HRESULT Destroy();

    // Renders the tga
    HRESULT Render();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\XbTga.Cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// File: XBTga.cpp
//
// Desc: Support class for rendering a help image, which is an image of an Xbox
//       gamepad, with labelled callouts to each of the gamepad's controls.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <tchar.h>
#include <stdio.h>
#include "XBTga.h"



//-----------------------------------------------------------------------------
// Name: CXBTga()
// Desc: Help class constructor
//-----------------------------------------------------------------------------
CXBTga::CXBTga()
{
    m_pd3dDevice      = NULL;
    m_pTgaTexture = NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the help class' internal objects
//-----------------------------------------------------------------------------
HRESULT CXBTga::Create( LPDIRECT3DDEVICE8 pd3dDevice, char* pFilename, RECT rect)
{
    // Keep track of the device
    m_pd3dDevice = pd3dDevice;
	m_pos = rect;

    // Create the gamepad texture
    if( FAILED( XBUtil_CreateTexture( m_pd3dDevice, pFilename,
                                      &m_pTgaTexture, D3DFMT_A8R8G8B8 ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the class' internal objects/
//-----------------------------------------------------------------------------
HRESULT CXBTga::Destroy()
{
    SAFE_RELEASE(m_pTgaTexture);
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the tga image
//-----------------------------------------------------------------------------
HRESULT CXBTga::Render()
{
    // First time around, create a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*6*sizeof(FLOAT), D3DUSAGE_WRITEONLY,
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct VERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
        VERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, NULL );
        v[0].p = D3DXVECTOR4( (float)  m_pos.left, (float) m_pos.top, 0.0f, 0.5f );
		v[0].tu = 0.0f;
		v[0].tv = 0.0f;
        v[1].p = D3DXVECTOR4( (float) m_pos.right, (float) m_pos.top, 0.0f, 0.5f );
		v[1].tu = 1.0f;
		v[1].tv = 0.0f;
        v[2].p = D3DXVECTOR4( (float) m_pos.left, (float) m_pos.bottom, 0.0f, 0.5f );
		v[2].tu = 0.0f;
		v[2].tv = 1.0f;
        v[3].p = D3DXVECTOR4( (float) m_pos.right, (float) m_pos.bottom, 0.0f, 0.5f );
		v[3].tu = 1.0f;
		v[3].tv = 1.0f;
        g_pVB->Unlock();
    }

    // Set state to render the tga image
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );

	m_pd3dDevice->SetTexture( 0, m_pTgaTexture );
//    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
//    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
//    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
//    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
//    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
//    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
//    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
//    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );

    m_pd3dDevice->SetStreamSource( 0, g_pVB, 6*sizeof(FLOAT) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Dvdpld32.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DDP Interface Declaration
//
////////////////////////////////////////////////////////////////////

#ifndef DVDPLD32_H
#define DVDPLD32_H

////////////////////////////////////////////////////////////////////
//
//  General Includes
//
////////////////////////////////////////////////////////////////////

#include "Library/Files/VFI.h"
#include "DVDTime.h"
#include "NavErrors.h"

typedef class CDDiskPlayerClass * DVDDiskPlayer;

////////////////////////////////////////////////////////////////////
//
//  Internal Stuff
//
////////////////////////////////////////////////////////////////////

#ifndef ONLY_EXTERNAL_VISIBLE

#include "Library/Common/WinPorts.h"
#include "Config/DiskPlayerFactory.h"
#include "Config/DVDDiskPlayerFactory.h"
#include "Config/FileSystemFactory.h"
#include "Library/Common/Profiles.h"
#include "Library/Hardware/Drives/Generic/DriveTable.h"

//
//  DDP_Init() and DDP_Cleanup() are internal functions only
//  They should not be called from outside the configuration/platform dependent files
//

DLLCALL Error WINAPI DDP_Init(WinPortServer					* driverInstance,
										GenericProfile					* profile,
										DriveTable						* driveTable,
										DVDDiskPlayerFactory			* dvdVideoDiskPlayerFactory,
										DVDDiskPlayerFactory			* dvdAudioDiskPlayerFactory,
										VCDDiskPlayerFactory			* vcdDiskPlayerFactory,
										CDDADiskPlayerFactory		* cddaDiskPlayerFactory,
										AVFDiskPlayerFactory			* avfDiskPlayerFactory,
										FileSystemFactory				* dvdFileSystemFactory,
										FileSystemFactory				* vcdFileSystemFactory,
										FileSystemFactory				* cddaFileSystemFactory,
										FileSystemFactory				* avfFileSystemFactory,
										FileSystemFactory				* osFileSystemFactory);

DLLCALL Error WINAPI  DDP_Cleanup(void);

//
//  Special declarations for ST20LITE
//

DLLCALL Error WINAPI DDP_Initialize(void);

#endif	// ONLY_EXTERNAL_VISIBLE

#include "boards/generic/vdgendrv.h"

////////////////////////////////////////////////////////////////////
//
//  Interface declaration
//
////////////////////////////////////////////////////////////////////

extern "C" {

DLLCALL Error WINAPI  DDP_CheckDrive(char driveLetter, char __far * id);

DLLCALL Error WINAPI  DDP_CheckDriveWithPath(char * drivePath, char __far * id);

DLLCALL Error WINAPI  DDP_GetVolumeName(char driveLetter, char * name);

DLLCALL Error WINAPI  DDP_GetDiskRegionSettings(UnitSet units, char driveLetter, BYTE __far &region, BYTE __far &availSets, RegionSource __far & regionSource, BYTE & diskRegion);

DLLCALL Error WINAPI  DDP_GetRegionSettings(UnitSet units, char driveLetter, BYTE __far &region, BYTE __far &availSets, RegionSource __far &regionSource);

DLLCALL Error WINAPI  DDP_SetSystemRegion(UnitSet units, char driveLetter, BYTE region);

DLLCALL Error WINAPI  DDP_EjectDiskInDrive(char driveLetter);

#if MSNDISC
DLLCALL Error WINAPI  DDP_LoadMedia(char driveLetter, BOOL wait);
DLLCALL Error WINAPI  DDP_UnloadMedia(char driveLetter, BOOL wait);
DLLCALL Error WINAPI  DDP_GetDriveCaps(char driveLetter, DWORD &caps, DWORD &slots, DWORD& positions, DWORD& changerOpenOffset);
DLLCALL Error WINAPI  DDP_MoveChanger(char driveLetter, DWORD operation, DWORD flags, DWORD param);
DLLCALL Error WINAPI  DDP_GetChangerStatus(char driveLetter, DWORD& status, DWORD& position );
DLLCALL Error WINAPI  DDP_GetSlotStatus(char driveLetter, DWORD slot, DWORD& status );
#endif

DLLCALL Error WINAPI  DDP_GetDriveStatus(char driveLetter, BOOL & opened, BOOL & closed);

DLLCALL Error WINAPI  DDP_LoadDiskInDrive(char driveLetter, BOOL wait);

DLLCALL Error WINAPI  DDP_OpenPlayer(UnitSet units, char diskLetter, DVDDiskPlayer __far & player);

DLLCALL Error WINAPI  DDP_OpenPlayerWithPath(UnitSet units, char * drivePath, DVDDiskPlayer __far & player);

DLLCALL Error WINAPI  DDP_OpenPlayerExtended(UnitSet units, char driveLetter, char * drivePath,
															DVDDiskPlayer __far & player, DDPDiskInfo __far & diskInfo);

DLLCALL Error WINAPI  DDP_ClosePlayer(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_StartPresentation(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_StartPresentationExt(DVDDiskPlayer player, DWORD flags);

DLLCALL DVDDiskType	 WINAPI DDP_GetDiskType(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_GetDiskInfoAsync(char * drivePath, ARQAsyncRequestDoneCB ARQCallback, DDPDiskOnlyInfo* diskOnlyInfo, DWORD & dwRqHandle);

DLLCALL Error WINAPI  DDP_OpenPlayerAsync(char * drivePath, ARQAsyncRequestDoneCB ARQCallback, DDPOpenPlayerInfo* openPlayerInfo, DWORD & rqHandle);

DLLCALL Error WINAPI  DDP_AbortAsyncRequest(DWORD dwRqHandle);

DLLCALL Error WINAPI  DDP_GetCurrentLocation(DVDDiskPlayer player, DVDLocation __far & location);

DLLCALL Error WINAPI  DDP_GetCurrentDuration(DVDDiskPlayer player, DVDLocation __far & location);

DLLCALL Error WINAPI  DDP_GetTitleDuration(DVDDiskPlayer player, WORD title, DVDTime & duration);

DLLCALL DVDPlayerMode WINAPI DDP_GetPlayerMode(DVDDiskPlayer player);

DLLCALL Error WINAPI	 DDP_GetExtendedPlayerState(DVDDiskPlayer player, ExtendedPlayerState & eps);

DLLCALL DWORD WINAPI  DDP_GetForbiddenUserOperations(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetNumberOfTitles(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetNumberOfPartOfTitle(DVDDiskPlayer player, WORD title);

DLLCALL Error WINAPI  DDP_GetAvailStreams(DVDDiskPlayer player, BYTE __far & audioMask, DWORD __far & subPictureMask);

DLLCALL Error WINAPI  DDP_GetAudioStreamAttributes(DVDDiskPlayer player, WORD stream, DVDAudioStreamFormat __far & format);

DLLCALL Error WINAPI  DDP_GetSubPictureStreamAttributes(DVDDiskPlayer player, WORD stream, DVDSubPictureStreamFormat __far & format);

DLLCALL WORD  WINAPI  DDP_GetCurrentAudioStream(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetCurrentSubPictureStream(DVDDiskPlayer player);

DLLCALL BOOL  WINAPI  DDP_IsCurrentSubPictureEnabled(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetNumberOfAngles(DVDDiskPlayer player, WORD title);

DLLCALL WORD  WINAPI  DDP_GetCurrentAngle(DVDDiskPlayer player);

DLLCALL BOOL  WINAPI  DDP_CheckMenuAvail(DVDDiskPlayer player, VTSMenuType menu);

DLLCALL DisplayPresentationMode WINAPI  DDP_GetCurrentDisplayMode(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_SetDisplayMode(DVDDiskPlayer player, DisplayPresentationMode mode);

DLLCALL Error WINAPI  DDP_TitlePlay(DVDDiskPlayer player, WORD title);

DLLCALL Error WINAPI  DDP_TitlePlayForced(DVDDiskPlayer player, WORD title);

DLLCALL Error WINAPI  DDP_PTTPlay(DVDDiskPlayer player, WORD title, WORD part);

DLLCALL Error WINAPI  DDP_PTTPlayForced(DVDDiskPlayer player, WORD title, WORD part);

DLLCALL Error WINAPI  DDP_TimePlay(DVDDiskPlayer player, WORD title, DVDTime time);

DLLCALL Error WINAPI  DDP_TimePlayForced(DVDDiskPlayer player, WORD title, DVDTime time);

DLLCALL Error WINAPI  DDP_ExtendedPlay(DVDDiskPlayer player, DWORD flags, WORD title, WORD ptt, DVDTime time);

DLLCALL Error WINAPI  DDP_Stop(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_GoUp(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_TimeSearch(DVDDiskPlayer player, DVDTime time);

DLLCALL Error WINAPI  DDP_TimeSearchForced(DVDDiskPlayer player, DVDTime time);

DLLCALL Error WINAPI  DDP_PTTSearch(DVDDiskPlayer player, WORD part);

DLLCALL Error WINAPI  DDP_PTTSearchForced(DVDDiskPlayer player, WORD part);

DLLCALL Error WINAPI  DDP_PrevPGSearch(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_TopPGSearch(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_NextPGSearch(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_ForwardScan(DVDDiskPlayer player, WORD speed);

DLLCALL Error WINAPI  DDP_BackwardScan(DVDDiskPlayer player, WORD speed);

DLLCALL Error WINAPI  DDP_TrickPlay(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_StopScan(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_ReversePlayback(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_MenuCall(DVDDiskPlayer player, VTSMenuType menu);

DLLCALL Error WINAPI  DDP_Resume(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_UpperButtonSelect(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_LowerButtonSelect(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_LeftButtonSelect(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_RightButtonSelect(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_ButtonSelectAt(DVDDiskPlayer player, WORD x, WORD y);

DLLCALL Error WINAPI  DDP_ButtonActivate(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_ButtonSelectAndActivate(DVDDiskPlayer player, WORD num);

DLLCALL Error WINAPI  DDP_ButtonSelectAndActivateAt(DVDDiskPlayer player, WORD x, WORD y);

DLLCALL BOOL  WINAPI  DDP_IsButtonAt(DVDDiskPlayer player, WORD x, WORD y);

DLLCALL Error WINAPI  DDP_StillOff(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_PauseOn(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_PauseOff(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_PbcOn(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_PbcOff(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_AdvanceFrame(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_AdvanceFrameBy(DVDDiskPlayer player, int by);

DLLCALL Error WINAPI  DDP_SetPlaybackSpeed(DVDDiskPlayer player, WORD speed);

DLLCALL Error WINAPI  DDP_MenuLanguageSelect(DVDDiskPlayer player, WORD language);

DLLCALL Error WINAPI  DDP_AudioStreamChange(DVDDiskPlayer player, WORD streamID);

DLLCALL Error WINAPI  DDP_SubPictureStreamChange(DVDDiskPlayer player, WORD streamID, BOOL display);

DLLCALL Error WINAPI  DDP_AngleChange(DVDDiskPlayer player, WORD angle);

DLLCALL Error WINAPI  DDP_ParentalLevelSelect(DVDDiskPlayer player, WORD parentalLevel);

DLLCALL Error WINAPI  DDP_ParentalCountrySelect(DVDDiskPlayer player, WORD country);

DLLCALL Error WINAPI  DDP_InitialLanguageSelect(DVDDiskPlayer player,
														      WORD audioLanguage,
														      WORD audioExtension,
														      WORD subPictureLanguage,
														      WORD subPictureExtension);

DLLCALL Error WINAPI  DDP_InquireCurrentBitRate(DVDDiskPlayer player, DWORD & bitsPerSecond);

DLLCALL Error WINAPI  DDP_GetCurrentButtonState(DVDDiskPlayer player, WORD & minButton, WORD & numButtons, WORD & currentButton);

DLLCALL Error WINAPI  DDP_Freeze(DVDDiskPlayer player, BYTE * buffer, DWORD & length);

DLLCALL Error WINAPI  DDP_Defrost(DVDDiskPlayer player, BYTE * buffer, DWORD & length);

DLLCALL Error WINAPI  DDP_DefrostExt(DVDDiskPlayer player, BYTE * buffer, DWORD & length, DWORD flags);

DLLCALL Error WINAPI  DDP_GetFrozenInfo(BYTE * buffer, DWORD length, DDPFreezeState & state);

DLLCALL Error WINAPI  DDP_InstallEventHandler(DVDDiskPlayer player, DWORD event, DNEEventHandler handler, void * userData);

DLLCALL Error WINAPI  DDP_RemoveEventHandler(DVDDiskPlayer player, DWORD event);

DLLCALL Error WINAPI  DDP_SetBreakpoint(DVDDiskPlayer player, WORD title, DVDTime time, DWORD flags, DWORD & id);

DLLCALL Error WINAPI  DDP_SetBreakpointExt(DVDDiskPlayer player, WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id);

DLLCALL Error WINAPI  DDP_ClearBreakpoint(DVDDiskPlayer player, DWORD id);

DLLCALL Error WINAPI  DDP_DetachDrive(DVDDiskPlayer player, DWORD flags, DVDTime time, DWORD bufferSize);

DLLCALL Error WINAPI  DDP_GetAVFileInfo(DVDDiskPlayer player, HIter * it, AVFInfo * pInfo);

DLLCALL Error WINAPI  DDP_PlayFile(DVDDiskPlayer player, HIter * it, DWORD flags);

DLLCALL Error WINAPI  DDP_SetAudioStreamSelectionPreferences(DVDDiskPlayer player, DWORD flags);

}	// extern "C"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\dvdevcod.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------
// File: DVDevCod.h
//
// Desc: List of standard DVD-Video event codes and the expected params.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#define EC_DVDBASE                          0x0100

#ifndef EXCLUDE_DVDEVCODE_ENUMS

typedef enum _tagDVD_ERROR {
    DVD_ERROR_Unexpected=1,         // Something unexpected happened, perhaps content
                                    //   is incorrectly authored.  Playback is stopped.
    DVD_ERROR_CopyProtectFail=2,    // Key exchange for DVD copy protection failed.
                                    //   Playback is stopped.
    DVD_ERROR_InvalidDVD1_0Disc=3,  // DVD-Video disc is incorrectly authored for v1.0
                                    //   of spec. Playback is stopped.
    DVD_ERROR_InvalidDiscRegion=4,  // The Disc cannot be played because the disc is not
                                    // authored to play in system region.
                                    // The region mismatch may be fixable by
                                    // changing the system region with dvdrgn.exe
    DVD_ERROR_LowParentalLevel=5,   // Player parental level is lower than the lowest parental
                                    //   level available in the DVD content. Playback is stopped.
    DVD_ERROR_MacrovisionFail=6,    // Macrovision Distribution Failed.
                                    // Playback is stopped.
    DVD_ERROR_IncompatibleSystemAndDecoderRegions=7,
                                    // No discs can be played because the system region
                                    // does not match the decoder region.
    DVD_ERROR_IncompatibleDiscAndDecoderRegions=8
                                    // The disc cannot be played because the disc is
                                    // not authored to be played in the decoder's region
} DVD_ERROR;

typedef enum _tagDVD_WARNING {
    DVD_WARNING_InvalidDVD1_0Disc=1,// DVD-Video disc is incorrectly authored. Playback
                                    //   can continue, but unexpected behavior may occur.
    DVD_WARNING_FormatNotSupported=2,// A decoder would not support the current format.  Playback
                                    //   of a stream (audio, video of SP) may not function.
    DVD_WARNING_IllegalNavCommand=3,// The internal DVD navigation command processor attempted to
                                    //   process an illegal command.
    DVD_WARNING_Open = 4,           // File Open Failed
    DVD_WARNING_Seek = 5,           // File Seek Failed
    DVD_WARNING_Read = 6            // File Read Failed
} DVD_WARNING;

#endif

// DVD-Video event codes
// ======================
//
// All DVD-Video event are always passed on to the application, and are
// never processed by the filter graph


#define EC_DVD_DOMAIN_CHANGE                    (EC_DVDBASE + 0x01)
// Parameters: ( DWORD, void )
// lParam1 is enum DVD_DOMAIN, and indicates the player's new domain
//
// Raised from following domains: all
//
// Signaled when ever the DVD player changes domains.


#define EC_DVD_TITLE_CHANGE                     (EC_DVDBASE + 0x02)
// Parameters: ( DWORD, void )
// lParam1 is the new title number.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Indicates when the current title number changes.  Title numbers
// range 1 to 99.  This indicates the TTN, which is the title number
// with respect to the whole disc, not the VTS_TTN which is the title
// number with respect to just a current VTS.


#define EC_DVD_CHAPTER_START                   (EC_DVDBASE + 0x03)
// Parameters: ( DWORD, void )
// lParam1 is the new chapter number (which is the program number for
// One_Sequential_PGC_Titles).
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signales that DVD player started playback of a new program in the Title
// domain.  This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_AUDIO_STREAM_CHANGE              (EC_DVDBASE + 0x04)
// Parameters: ( DWORD, void )
// lParam1 is the new user audio stream number.
//
// Raised from following domains: all
//
// Signaled when ever the current user audio stream number changes for the main
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.
// Audio stream numbers range from 0 to 7.  Stream 0xffffffff
// indicates that no stream is selected.

#define EC_DVD_SUBPICTURE_STREAM_CHANGE         (EC_DVDBASE + 0x05)
// Parameters: ( DWORD, void )
// lParam1 is the new user subpicture stream number.
//
// Raised from following domains: all
//
// Signaled when ever the current user subpicture stream number changes for the main
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.
// Subpicture stream numbers range from 0 to 31.  Stream 0xffffffff
// indicates that no stream is selected.

#define EC_DVD_ANGLE_CHANGE                     (EC_DVDBASE + 0x06)
// Parameters: ( DWORD, DWORD )
// lParam1 is the number of available angles.
// lParam2 is the current user angle number.
//
// Raised from following domains: all
//
// Signaled when ever either
//   a) the number of available angles changes, or
//   b) the current user angle number changes.
// Current angle number can be changed automatically with navigation command
// on disc as well as through IDVDAnnexJ.
// When the number of available angles is 1, the current video is not multiangle.
// Angle numbers range from 1 to 9.


#define EC_DVD_BUTTON_CHANGE                    (EC_DVDBASE + 0x07)
// Parameters: ( DWORD, DWORD )
// lParam1 is the number of available buttons.
// lParam2 is the current selected button number.
//
// Raised from following domains: all
//
// Signaled when ever either
//   a) the number of available buttons changes, or
//   b) the current selected button number changes.
// The current selected button can be changed automatically with navigation
// commands on disc as well as through IDVDAnnexJ.
// Button numbers range from 1 to 36.  Selected button number 0 implies that
// no button is selected.  Note that these button numbers enumerate all
// available button numbers, and do not always correspond to button numbers
// used for IDVDAnnexJ::ButtonSelectAndActivate since only a subset of buttons
// may be activated with ButtonSelectAndActivate.


#define EC_DVD_VALID_UOPS_CHANGE                (EC_DVDBASE + 0x08)
// Parameters: ( DWORD, void )
// lParam1 is a VALID_UOP_SOMTHING_OR_OTHER bit-field stuct which indicates
//   which IDVDAnnexJ commands are explicitly disable by the DVD disc.
//
// Raised from following domains: all
//
// Signaled when ever the available set of IDVDAnnexJ methods changes.  This
// only indicates which operations are explicited disabled by the content on
// the DVD disc, and does not guarentee that it is valid to call methods
// which are not disabled.  For example, if no buttons are currently present,
// IDVDAnnexJ::ButtonActivate() won't work, even though the buttons are not
// explicitly disabled.


#define EC_DVD_STILL_ON                         (EC_DVDBASE + 0x09)
// Parameters: ( BOOL, DWORD )
// lParam1 == 0  -->  buttons are available, so StillOff won't work
// lParam1 == 1  -->  no buttons available, so StillOff will work
// lParam2 indicates the number of seconds the still will last, with 0xffffffff
//   indicating an infinite still (wait till button or StillOff selected).
//
// Raised from following domains: all
//
// Signaled at the beginning of any still: PGC still, Cell Still, or VOBU Still.
// Note that all combinations of buttons and still are possible (buttons on with
// still on, buttons on with still off, button off with still on, button off
// with still off).

#define EC_DVD_STILL_OFF                         (EC_DVDBASE + 0x0a)
// Parameters: ( void, void )
//
//   Indicating that any still that is currently active
//   has been released.
//
// Raised from following domains: all
//
// Signaled at the end of any still: PGC still, Cell Still, or VOBU Still.
//

#define EC_DVD_CURRENT_TIME                     (EC_DVDBASE + 0x0b)
// Parameters: ( DWORD, BOOL )
// lParam1 is a DVD_TIMECODE which indicates the current
//   playback time code in a BCD HH:MM:SS:FF format.
// lParam2 == 0  -->  time code is 25 frames/sec
// lParam2 == 1  -->  time code is 30 frames/sec (non-drop).
// lParam2 == 2  -->  time code is invalid (current playback time
//                    cannot be determined for current title)
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.
// This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_ERROR                            (EC_DVDBASE + 0x0c)
// Parameters: ( DWORD, void)
// lParam1 is an enum DVD_ERROR which notifies the app of some error condition.
//
// Raised from following domains: all
//

#define EC_DVD_WARNING                           (EC_DVDBASE + 0x0d)
// Parameters: ( DWORD, void)
// lParam1 is an enum DVD_WARNING which notifies the app of some warning condition.
//
// Raised from following domains: all
//

#define EC_DVD_CHAPTER_AUTOSTOP                  (EC_DVDBASE + 0x0e)
// Parameters: (BOOL, void)
// lParam1 is a BOOL which indicates the reason for the cancellation of ChapterPlayAutoStop
// lParam1 == 0 indicates successful completion of ChapterPlayAutoStop
// lParam1 == 1 indicates that ChapterPlayAutoStop is being cancelled as a result of another
//            IDVDControl call or the end of content has been reached & no more chapters
//            can be played.
//  Indicating that playback is stopped as a result of a call
//  to IDVDControl::ChapterPlayAutoStop()
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_NO_FP_PGC                         (EC_DVDBASE + 0x0f)
//  Parameters : (void, void)
//
//  Raised from the following domains : FP_DOM
//
//  Indicates that the DVD disc does not have a FP_PGC (First Play Program Chain)
//  and the DVD Navigator will not automatically load any PGC and start playback.
//

#define EC_DVD_PLAYBACK_RATE_CHANGE              (EC_DVDBASE + 0x10)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new playback rate.
//  lParam1 < 0 indicates reverse playback mode.
//  lParam1 > 0 indicates forward playback mode
//  Value of lParam1 is the actual playback rate multiplied by 10000.
//  i.e. lParam1 = rate * 10000
//
//  Raised from the following domains : TT_DOM
//
//  Indicates that a rate change in playback has been initiated and the parameter
//  lParam1 indicates the new playback rate that is being used.
//

#define EC_DVD_PARENTAL_LEVEL_CHANGE            (EC_DVDBASE + 0x11)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new parental level.
//
//  Raised from the following domains : VMGM_DOM
//
//  Indicates that an authored Nav command has changed the parental level
//  setting in the player.
//

#define EC_DVD_PLAYBACK_STOPPED                 (EC_DVDBASE + 0x12)
//  Parameters : (void, void)
//
//  Raised from the following domains : All Domains
//
// Indicates that playback has been stopped as the Navigator has completed
// playback of the pgc and did not find any other branching instruction for
// subsequent playback.
//

#define EC_DVD_ANGLES_AVAILABLE                 (EC_DVDBASE + 0x13)
//  Parameters : (BOOL, void)
//  lParam1 == 0 indicates that playback is not in an angle block and angles are
//             not available
//  lParam1 == 1 indicates that an angle block is being played back and angle changes
//             can be performed.
//
//  Indicates whether an angle block is being played and if angle changes can be
//  performed. However, angle changes are not restricted to angle blocks and the
//  manifestation of the angle change can be seen only in an angle block.

#define EC_DVD_PLAYPERIOD_AUTOSTOP              (EC_DVDBASE + 0x14)
// Parameters: (void, void)
// Sent when the PlayPeriodInTitle completes or is cancelled
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_BUTTON_AUTO_ACTIVATED                 (EC_DVDBASE + 0x15)
// Parameters: (DWORD button, void)
// Sent when a button is automatically activated
//
// Raised from following domains : DVD_DOMAIN_MENU
//

#define EC_DVD_CMD_START                 (EC_DVDBASE + 0x16)
// Parameters: (CmdID, HRESULT)
// Sent when a command begins
//

#define EC_DVD_CMD_END                 (EC_DVDBASE + 0x17)
// Parameters: (CmdID, HRESULT)
// Sent when a command completes
//

#define EC_DVD_DISC_EJECTED                (EC_DVDBASE + 0x18)
// Parameters: none
// Sent when the nav detects that a disc was ejected and stops the playback
// The app does not need to take any action to stop the playback.
//

#define EC_DVD_DISC_INSERTED                (EC_DVDBASE + 0x19)
// Parameters: none
// Sent when the nav detects that a disc was inserted and the nav begins playback
// The app does not need to take any action to start the playback.
//

#define EC_DVD_CURRENT_HMSF_TIME                     (EC_DVDBASE + 0x1a)
// Parameters: ( ULONG, ULONG )
// lParam2 contains a union of the DVD_TIMECODE_FLAGS
// lParam1 contains a DVD_HMSF_TIMECODE.  Assign lParam1 to a ULONG then cast the
// ULONG as a DVD_HMSF_TIMECODE to use its values.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.

#define EC_DVD_KARAOKE_MODE                     (EC_DVDBASE + 0x1b)
// Parameters: ( BOOL, reserved )
// lParam1 is either TRUE (a karaoke track is being played) or FALSE (no karaoke data is being played).
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\DVDTIME.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef DVDTIME_H
#define DVDTIME_H

#include "Library/Common/Prelude.h"
#include "Library/Common/GNErrors.h"
#include "Library/hardware/video/generic/vidtypes.h"
#include "Library/hardware/audio/generic/ac3setup.h"
#include "Driver/Dvdpldrv/Common/AVF/MPEGAudioTypes.h"
#include "NavErrors.h"


enum DVDPlayerMode
	{
	DPM_STOPPED,
	DPM_PAUSED,
	DPM_STILL,
	DPM_PLAYING,
	DPM_BUSY,
	DPM_SCANNING,
	DPM_INACTIVE,
	DPM_REVERSEPLAY,
	DPM_TRICKPLAY,
	DPM_REVERSESCAN
	};

enum DVDDomain
	{
	FP_DOM,
	VMGM_DOM,
	VTSM_DOM,
	TT_DOM,
	STOP_DOM,
	AMGM_DOM,
	TT_GR_DOM
	};

enum VTSMenuType
	{
	VMT_TITLE_MENU,
	VMT_ROOT_MENU,
	VMT_SUBPICTURE_MENU,
	VMT_AUDIO_MENU,
	VMT_ANGLE_MENU,
	VMT_PTT_MENU,
	VMT_NO_MENU		// Note that this is used in ExtendedPlayerState as array size
	};

enum DVDManagerMenuType
	{
	DMT_VMGM,
	DMT_AMGM,
	DMT_UNDEFINED
	};

enum DisplayPresentationMode
	{
	DPM_4BY3,
	DPM_16BY9,
	DPM_LETTERBOXED,
	DPM_PANSCAN,
	DPM_NONE
	};

enum DVDAudioCodingMode
	{
	DAM_AC3,
	DAM_MPEG1,
	DAM_MPEG2,
	DAM_LPCM,
	DAM_DTS,
	DAM_SDDS,
	DAM_NONE = 0xFF
	};

enum DVDAudioApplicationMode
	{
	DAAM_UNDEFINED		= 0,
	DAAM_KARAOKE		= 1,
	DAAM_SURROUND		= 2
	};

enum DVDKaraokeSoloDuetMode
	{
	DKM_SOLO				= 0,
	DKM_DUET				= 1,
	DKM_UNDEFINED		= 2
	};

enum MPEG2PrologicStatus		// Status of the decoder (actually played!)
	{
	MP2PS_OFF,
	MP2PS_ON,
	MP2PS_UNKNOWN
	};

enum MPEG2LFEStatus				// Content, not playing
	{
	MP2LFE_OFF,
	MP2LFE_ON,
	MP2LFE_UNKNOWN
	};

enum DVDDiskType
	{
	DDT_NONE,
	DDT_VIDEO_DVD,
	DDT_AUDIO_DVD,
	DDT_VIDEO_CD,
	DDT_AUDIO_CD,
	DDT_SUPER_AUDIO_CD,
	DDT_DTS_AUDIO_CD,
	DDT_SUPER_VIDEO_CD,
	DDT_MULTI_DISK			// Describes a CD-R or similar with files of different types on it
	};

enum RegionSource
	{
	RGSRC_UNDEFINED	= 0,
	RGSRC_DRIVE			= 1,
	RGSRC_BOARD			= 2
	};

enum VideoCompressionMode
	{
	VCM_UNKNOWN,
	VCM_MPEG1,
	VCM_MPEG2
	};

enum Line21Mode
	{
	L21M_NO_DATA,
	L21M_FIRST_FIELD,
	L21M_SECOND_FIELD,
	L21M_BOTH_FIELDS
	};

//
//  User Operation Bitmasks
//

#define UOP_TIME_PLAY_SEARCH				MKFLAG(0)
#define UOP_PTT_PLAY_SEARCH				MKFLAG(1)
#define UOP_TITLE_PLAY						MKFLAG(2)
#define UOP_STOP								MKFLAG(3)
#define UOP_GO_UP								MKFLAG(4)
#define UOP_TIME_PTT_SEARCH				MKFLAG(5)
#define UOP_PREV_TOP_PG_SEARCH			MKFLAG(6)
#define UOP_NEXT_PG_SEARCH					MKFLAG(7)
#define UOP_FORWARD_SCAN					MKFLAG(8)
#define UOP_BACKWARD_SCAN					MKFLAG(9)
#define UOP_SCAN_OFF							MKFLAG(25)	// additional
#define UOP_MENU_CALL_TITLE				MKFLAG(10)
#define UOP_MENU_CALL_ROOT					MKFLAG(11)
#define UOP_MENU_CALL_SUB_PICTURE		MKFLAG(12)
#define UOP_MENU_CALL_AUDIO				MKFLAG(13)
#define UOP_MENU_CALL_ANGLE				MKFLAG(14)
#define UOP_MENU_CALL_PTT					MKFLAG(15)
#define UOP_RESUME							MKFLAG(16)
#define UOP_BUTTON							MKFLAG(17)
#define UOP_STILL_OFF						MKFLAG(18)
#define UOP_PAUSE_ON							MKFLAG(19)
#define UOP_PAUSE_OFF						MKFLAG(26)	// additional
#define UOP_AUDIO_STREAM_CHANGE			MKFLAG(20)
#define UOP_SUB_PICTURE_STREAM_CHANGE	MKFLAG(21)
#define UOP_ANGLE_CHANGE					MKFLAG(22)
#define UOP_KARAOKE_MODE_CHANGE			MKFLAG(23)
#define UOP_VIDEO_MODE_CHANGE				MKFLAG(24)

//
//  Disc Information Structure
//

class __far DDPDiskInfo
	{
	public:
		DDPDiskInfo(void)			{size = sizeof(DDPDiskInfo);}

		DWORD				size;				// Size of the structure passed, DO NOT CHANGE!!!
		DVDDiskType		type;				// Type of media inserted
		char				uniqueKey[8];	// Unique identifier of disk
		BYTE				systemRegion;	// System region (decoder or drive, only for type == DDT_VIDEO_DVD)
		BYTE				diskRegion;		// Disk region (only for type == DDT_VIDEO_DVD)
		RegionSource	regionSource;	// Region source (decoder or drive, only for type == DDT_VIDEO_DVD)
		BYTE				availSets;		// Number of region sets left (only for type == DDT_VIDEO_DVD)
	};

//
//  Disc-Only Information Structure (no system region related info)
//

class DDPDiskOnlyInfo
	{
	public:
		DDPDiskOnlyInfo(void)			{size = sizeof(DDPDiskOnlyInfo);}

		DWORD				size;				// Size of the structure passed, DO NOT CHANGE!!!
		DWORD				dwUserData;		// User data, not touched by DDP layer
		DVDDiskType		type;				// Type of media inserted
		char				uniqueKey[8];	// Unique identifier of disk
		BYTE				diskRegion;		// Disk region (only for type == DDT_VIDEO_DVD)
		char				volumeName[256];
	};


class DDPOpenPlayerInfo
	{
	public:
		DDPOpenPlayerInfo(){size = sizeof(DDPOpenPlayerInfo);}

		DWORD				size;				// Size of the structure passed, DO NOT CHANGE!!!
		DWORD				dwUserData;		// User data, not touched by DDP layer
		void*				units;			// UnitSet currently open, cast to void*
		void**			pplayer;			// Pointer to DVDDiskPlayer (cast to void**)
		DDPDiskInfo		diskInfo;		// structure filled out with relevant disk data upon successful player opening
	};


//
//  DVD Time Class
//

class __far DVDTime
	{
	private:
		DWORD	stamp;  // Format HHHH HHHH MMMM MMMM SSSS SSSS RR FF FFFF
	public:
		DVDTime(DWORD stamp) {this->stamp = stamp;}
		DVDTime(void) {this->stamp = 0;}
		DVDTime(int hours, int minutes, int seconds, int frames, int frameRate);
		DVDTime(int millisecs, int divider, int frameRate);

		int FrameRate(void)	const {return XTBF(7, stamp) ? 30 : 25;}
		int Frames(void)		const {return (int)(XTBF(0, 4, stamp) + 10 * XTBF(4, 2, stamp));}
		int Seconds(void)		const {return (int)(XTBF(8, 4, stamp) + 10 * XTBF(12, 4, stamp));}
		int Minutes(void)		const {return (int)(XTBF(16, 4, stamp) + 10 * XTBF(20, 4, stamp));}
		int Hours(void)		const {return (int)(XTBF(24, 4, stamp) + 10 * XTBF(28, 4, stamp));}

		DWORD FrameTotal(void)	const	{return (Seconds() + Minutes() * 60 + Hours() * 3600) * FrameRate() + Frames();}

		DWORD Millisecs(void) const {return 1000 * Frames() / FrameRate() +
		                              1000 * Seconds() +
		                              60000 * Minutes() +
		                              3600000 * Hours();}

		friend DVDTime operator+ (const DVDTime u, const DVDTime v);
		friend DVDTime operator- (const DVDTime u, const DVDTime v);

		DVDTime & operator+= (const DVDTime u);
		DVDTime & operator-= (const DVDTime u);

		int Compare(const DVDTime u) const;

		friend BOOL operator==(const DVDTime u, const DVDTime v) {return u.Compare(v) == 0;}
		friend BOOL operator!=(const DVDTime u, const DVDTime v) {return u.Compare(v) != 0;}
		friend BOOL operator<(const DVDTime u, const DVDTime v)  {return u.Compare(v) < 0;}
		friend BOOL operator>(const DVDTime u, const DVDTime v)  {return u.Compare(v) > 0;}
		friend BOOL operator<=(const DVDTime u, const DVDTime v) {return u.Compare(v) <= 0;}
		friend BOOL operator>=(const DVDTime u, const DVDTime v) {return u.Compare(v) >= 0;}

		BOOL IsZero(void)		const {return (stamp & 0xffffff3f) == 0;}
		BOOL IsNotZero(void)	const {return (stamp & 0xffffff3f) != 0;}
	};

//
//  DVD Location
//

class __far DVDLocation
	{
	public:
		DVDDomain	domain;
		WORD			videoTitleSet;
		WORD			title;
		WORD			vtsTitle;
		DVDTime		titleTime;
		WORD			partOfTitle;
		WORD			programChain;
		DVDTime		pgcTime;
		WORD			program;
		WORD			cell;
		DVDTime		cellTime;

		DVDLocation(void) {};
		friend BOOL	NotEqual(const DVDLocation u, const DVDLocation v);
		friend BOOL operator !=(const DVDLocation u, const DVDLocation v) { return (BOOL)memcmp(&u, &v, sizeof(DVDLocation)); }
	};

//
//  Audio Stream Format
//

class __far DVDAudioStreamFormat
	{
	public:
		WORD							languageCode;
		WORD							languageExtension;
		DVDAudioCodingMode		codingMode;
		WORD							bitsPerSample;
		DWORD							samplesPerSecond;
		WORD							channels;
		DVDAudioApplicationMode	applicationMode;
		BYTE							channelAssignment;
		BYTE							mcIntro;
		DVDKaraokeSoloDuetMode	soloDuetMode;

		friend BOOL operator==(const DVDAudioStreamFormat u, const DVDAudioStreamFormat v);
		friend BOOL operator!=(const DVDAudioStreamFormat u, const DVDAudioStreamFormat v);
	};

//
//  Video Stream Format
//

class VideoStreamFormat
	{
	public:
		VideoCompressionMode			compressionMode;			// Compression technique used
		VideoStandard					videoStandard;				// Source video standard
		DisplayPresentationMode		sourceAspectRatio;		// Aspect ratio of source picture
		BOOL								panScanOn4By3;				// TRUE if Pan & Scan is allowed on 4 by 3 display
		BOOL								letterboxedOn4By3;		// TRUE if letterboxed is allowed on 4 by 3 display
		Line21Mode						line21Mode;					// Encoded line 21 data
		WORD								sourceWidth;				// Width of source picture
		WORD								sourceHeight;				// Height of source picture
		BOOL								sourceLetterboxed;		// TRUE is source material is letterboxed

		friend BOOL operator==(const VideoStreamFormat & u, const VideoStreamFormat & v);
		friend BOOL operator!=(const VideoStreamFormat & u, const VideoStreamFormat & v);
	};

//
//  Subpicture Stream Format
//

class __far DVDSubPictureStreamFormat
	{
	public:
		WORD						languageCode;
		WORD						languageExtension;

		friend BOOL operator==(const DVDSubPictureStreamFormat u, const DVDSubPictureStreamFormat v);
		friend BOOL operator!=(const DVDSubPictureStreamFormat u, const DVDSubPictureStreamFormat v);
	};

//
//  Button Information
//

#define DBI_MAX_BUTTON_NUMBER 103

class __far DVDButtonInformation
	{
	public:
		WORD	x;
		WORD	y;
		WORD	w;
		WORD	h;
		BOOL	autoAction;
		BYTE	upperButton;
		BYTE	lowerButton;
		BYTE	leftButton;
		BYTE	rightButton;

		friend BOOL operator==(const DVDButtonInformation u, const DVDButtonInformation v);
		friend BOOL operator!=(const DVDButtonInformation u, const DVDButtonInformation v);
	};

//
//  Extended player state
//

class __far ExtendedPlayerState
	{
	public:
		DWORD								size;								// Size of the structure passed

		// Request bitmasks

		DWORD								request;							// Bitmask for requested data
		DWORD								valid;							// Bitmask for delivered data
		DWORD								monitor;							// Bitmask indicating the elements to check for changes
		DWORD								changed;							// Bitmask indicating the elements that have changed

		// Player Information (EPS_PLAYERINFO, additions below)

		DVDPlayerMode					playerMode;						// Current player mode
		WORD								playbackSpeed;					// Current playback speed
		WORD								scanSpeed;						// Current scan speed
		DWORD								forbiddenUOPs;					// Forbidden UOPs

		// Hardware Information (EPS_MISC)

		DVDDiskType						diskType;						// Current disk type
		DisplayPresentationMode		displayMode;					// Current display mode
		VideoStandard					videoStandard;					// Current video standard
		DWORD								currentBitRate;				// Current bitrate

		// Audio Stream Information (EPS_AUDIOSTREAMS)

		int								currentAudioStream;			// Current Audio Stream ID
		BYTE								availableAudioStreams;		// Bitmask of audio streams available
		DVDAudioStreamFormat			audioStream[8];				// Audio stream data

		// Sub Picture Stream Information (EPS_SUBPICTURESTREAMS)

		int								currentSubPictureStream;	// Current sub picture Stream ID
		DWORD								availableSubPictureStreams;// Bitmask of sub picture streams available
		DVDSubPictureStreamFormat	subPictureStream[32];		// Subpicture stream data
		BOOL								subPictureEnable;				// Subpicture enabled

		// Title Information (EPS_TITLE)

		DVDLocation						location;						// Current location
		DVDLocation						duration;						// Current duration

		// Menu Information (EPS_MENU)

		WORD								menuLanguage;
		BOOL								menuAvailable[VMT_NO_MENU+1];  // Use a VTSMenuType as index

		// Parental Information (EPS_PARENTAL)

		WORD								parentalCountry;
		WORD								parentalLevel;

		// Angle Information (EPS_ANGLE, addition below)

		WORD								numberOfAngles;
		WORD								currentAngle;

		// Button Information (EPS_BUTTON)

		WORD								numberOfButtons;
		WORD								selectedButton;
		WORD								forcedlyActivatedButton;
		WORD								userButtonOffset;
		WORD								numberOfUserButtons;
		DVDButtonInformation			buttonInfo[DBI_MAX_BUTTON_NUMBER];

		// CDDA Information (EPS_PLAYINGGAP)

		BOOL								playingGap;						// CDDA only: TRUE is gap between titles is played

		// Additional Player Information (EPS_PLAYERINFO)

		BOOL								playingForward;

		// Additional Angle Information (EPS_ANGLE)

		BOOL								isMultiAngleScene;
		WORD								playingAngle;

		// Video stream information (EPS_VIDEOSTREAM, additional to info in EPS_MISC)

		VideoStreamFormat				videoStream;

		// Hardware Information (EPS_MISC, additional)

		BOOL								diskIsEncrypted;				// TRUE if disk is encrypted

		// Additional Audio Information (EPS_AUDIOSTREAMS, additional)

		MPEG2PrologicStatus			mpeg2PrologicStatus;			// Indicating if Prologic decoding is currently done
		MPEG2LFEStatus					mpeg2LFEStatus;				// Indicates if LFE info is in content
		AC3AudioCodingMode			ac3AudioCodingMode;			// Encoding, not actual output

		// (S-)Video-CD specific information (EPS_VCDPLAYERINFO)

		BOOL								isPlaybackControlOn;
	};

//
//  Request bitmask defines (00001000 in use)
//

#define EPS_PLAYERINFO				0x00000001
#define EPS_MISC						0x00000002
#define EPS_TITLE						0x00000004
#define EPS_AUDIOSTREAMS			0x00000008
#define EPS_SUBPICTURESTREAMS		0x00000010
#define EPS_ANGLE						0x00000020
#define EPS_MENU						0x00000040
#define EPS_PARENTAL					0x00000080
#define EPS_BUTTON					0x00000100
#define EPS_PLAYINGGAP				0x00000200
#define EPS_VIDEOSTREAM				0x00000400
#define EPS_KARAOKE					0x00000800
#define EPS_VCDPLAYERINFO			0x00001000


//
//  Shortcuts
//

#define EPS_COMMON					EPS_PLAYERINFO | EPS_MISC | EPS_TITLE
#define EPS_DVD						EPS_MENU | EPS_PARENTAL | EPS_BUTTON | EPS_ANGLE | EPS_AUDIOSTREAMS | \
											EPS_SUBPICTURESTREAMS | EPS_VIDEOSTREAM
#define EPS_VCD						EPS_BUTTON | EPS_AUDIOSTREAMS
#define EPS_CDA						EPS_PLAYINGGAP | EPS_AUDIOSTREAMS
#define EPS_ALL						EPS_COMMON | EPS_DVD | EPS_VCD | EPS_CDA

//
//  Async request processing
//

typedef enum ARQReqestID
	{
	ARQ_NONE = 0,
	ARQ_GET_DISK_INFO,
	ARQ_OPEN_PLAYER
	};

//
//  AsyncRequestDoneCallback - called e.g. when DDP_GetDiskInfoAsync is actually completed
//

typedef void (WINAPI * ARQAsyncRequestDoneCB)(ARQReqestID doneRqID, DWORD dwRqHandle, void * userData, Error err);

typedef void (WINAPI * DNEEventHandler)(DWORD event, void * userData, DWORD info);

//
//  Disk Navigation Event handling
//

typedef void (WINAPI * DNEEventHandler)(DWORD event, void * userData, DWORD info);

#define DNE_NONE								0
#define DNE_TITLE_CHANGE					1
#define DNE_PART_OF_TITLE_CHANGE			2
#define DNE_VALID_UOP_CHANGE				3
#define DNE_ANGLE_CHANGE					4
#define DNE_AUDIO_STREAM_CHANGE			5
#define DNE_SUBPICTURE_STREAM_CHANGE	6
#define DNE_DOMAIN_CHANGE					7
#define DNE_PARENTAL_LEVEL_CHANGE		8
#define DNE_BITRATE_CHANGE					9
#define DNE_STILL_ON							10
#define DNE_STILL_OFF						11
#define DNE_PLAYBACK_MODE_CHANGE			12
#define DNE_CDA_PLAYING_GAP				13
#define DNE_READ_ERROR						14
#define DNE_DISPLAY_MODE_CHANGE			15
#define DNE_STREAMS_CHANGE					16
#define DNE_SCAN_SPEED_CHANGE				17
#define DNE_PLAYBACK_SPEED_CHANGE		18
#define DNE_VIDEO_STANDARD_CHANGE		19
#define DNE_BREAKPOINT_REACHED			20
#define DNE_DRIVE_DETACHED					21		// OBSOLETE
#define DNE_ERROR								22

#define DNE_EVENT_NUMBER					23

//
//  ERS Breakpoints
//

#define ERS_BREAKPOINT_NONE				0xffffffff	// Defines an invalid breakpoint id

//
//  Flags for DDP_SetBreakpoint()
//

enum ERSBreakpointFlags
	{
	ERS_NONE					=	0x0000,	// No flags, normal breakpoint
	ERS_PAUSE				=	0x0001,	// Go to still mode when reaching breakpoint
	ERS_AUTOCLEAR			=	0x0002,	// Delete breakpoint when it has been reached
	ERS_PAUSEATEND			=	0x0004	// Trigger at end of title
	};

//
//  Flags for DDP_SetBreakpointExt()
//

enum ERSBreakpointExtFlags
	{
	ERS_ATTIME			=	0x0001,	// Trigger when reaching time in title
	ERS_ENDOFTITLE		=	0x0002,	// Trigger at end of title
	ERS_ENDOFPTT		=	0x0004,	// Trigger at and of part of title
	ERS_FORWARD			=	0x0008,	// Trigger when playing forward
	ERS_BACKWARD		=	0x0010,	// Trigger when playing backward
	ERS_TOSTILL			=	0x0020,	// Go to still when reaching breakpoint
	ERS_CLEAR			=	0x0040,	// Automatically delete breakpoint after triggering
	ERS_BEGINOFPTT		=	0x0080	// Trigger at begin of PTT
	};

//
//  Flags for ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time);
//

#define DDPEPF_NONE					0
#define DDPEPF_PAUSE_AT_START		1
#define DDPEPF_USE_TIME				2
#define DDPEPF_USE_PTT				4
#define DDPEPF_USE_TITLE			8

//
//  Flags for DetachDrive(DWORD flags, DVDTime time);
//

#define DDPDDF_DETACH_IMMEDIATE				1
#define DDPDDF_DETACH_AT_TIME					2
#define DDPDDF_DETACH_AT_END_OF_CELL		4
#define DDPDDF_DETACH_AT_END_OF_PROGRAM	8
#define DDPDDF_DETACH_AT_END_OF_PGC			16

#define DDPDDF_DETACH_ANY						31

#define DDPDDF_STREAM_PREFETCH				32
#define DDPDDF_PREFETCH_BUFFER_SIZE			64

//
//  Flags for DDP_StartPresentationExt and DDP_DefrostExt
//

#define DDPSPF_NONE		0
#define DDPSPF_TOPAUSE	1
#define DDPSPF_ID_MATCH	2

//
//  Flags for DDP_PlayFile
//

#define DDPPFF_NONE				0
#define DDPPFF_PAUSE_AT_START	1

//
// Flags for DDP_SetAudioStreamSelectionPreferences
//
#define DDPASSP_NONE				0
#define DDPASSP_MAXCHANNELS	1
#define DDPASSP_NO_DTS			2
#define DDPASSP_DTS				4

//
//  AVF definitions
//

// Structure for AVFStreamServer::GetFileInfo()

class AVFInfo
	{
	public:
		DWORD								size;								// Size of the structure passed

		// Request bitmasks

		DWORD								request;							// Bitmask for requested data
		DWORD								valid;							// Bitmask for delivered data
		DWORD								monitor;							// Bitmask indicating the elements to check for changes
		DWORD								changed;							// Bitmask indicating the elements that have changed

		DVDLocation						duration;						// obviates need for ExtendedPlayerState call

		// MPEG Audio Characteristics (the following items will always be available for MPEG Audio)
		MPEGAudioFrameInfo			mpegAudio;

		// MPEG Audio ID3v1 information (optional)
		MPEGAudioID3V1Tag				id3;
	};

//
//  Request bitmask defines
//

#define AVFINFO_MPEG_AUDIO_FRAME			0x00000001
#define AVFINFO_MPEG_AUDIO_ID3			0x00000002
#define AVFINFO_VERIFY_FILENAME_ONLY	0x00000004

//
//  Freeze state info
//

class DDPFreezeState
	{
	public:
		DVDDiskType diskType;
		BYTE			uniqueKey[8];
		WORD			parentalLevel;
		WORD			parentalCountry;
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\naverrors.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Error Declaration for DVDPLD32
//
////////////////////////////////////////////////////////////////////


#ifndef NAVERRORS_H
#define NAVERRORS_H

#include "Library/Common/GNErrors.h"
#include "Library/hardware/drives/generic/DriveErrors.h"
#include "Library/Files/FileErrors.h"

//  Navigation in general

#define GNR_UNEXPECTED_NAVIGATION_ERROR				MKERR(ERROR,	NAVIGATION,	INTERNALSTATE,		0x00)
// Some internal error happened

#define GNR_INVALID_PLAYER									MKERR(ERROR,	NAVIGATION,	OBJECT,				0x00)
// The player handle is invalid

#define GNR_INVALID_NAV_INFO								MKERR(ERROR,	NAVIGATION,	OBJECT,				0x02)
// The navigation information is invalid (possible causes: wrong authoring, read error from drive, internal error)

#define GNR_LOST_DECODER									MKERR(ERROR,	NAVIGATION,	OBJECT,				0x03)
// The decoder has been preempted

#define GNR_DISK_TYPE_NOT_SUPPORTED						MKERR(ERROR,	NAVIGATION, OBJECT,				0x04)
// The disk type is not supported by the current version

#define GNR_OPERATION_NOT_SUPPORTED						MKERR(ERROR,	NAVIGATION, OPERATION,			0x00)
// This operation is (currently) not supported by the player

#define GNR_TITLE_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x01)
// The title specified does not exist

#define GNR_CHAPTER_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x02)
// The chapter specified does not exist

#define GNR_TIME_OUT_OF_RANGE								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x03)
// The time specified (e.g. for a search operation) is out of range

#define GNR_PROGRAM_LINK_NOT_FOUND						MKERR(ERROR,	NAVIGATION,	OPERATION,			0x04)
// The current program does not have a next/prev/upper/etc. program

#define GNR_MENU_DOES_NOT_EXIST							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x05)
// The requested menu does not exist

#define GNR_STREAM_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x06)
// The stream (audio/subpicture) does not exist

#define GNR_FLAGS_NOT_SUPPORTED							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x07)
// The flags specified for this operation are not supported

#define GNR_BUTTON_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x08)
// The specified button does not exist

#define GNR_UNKNOWN_EVENT_TYPE							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x09)
// The event type specified does not exist

#define GNR_BREAKPOINT_NOT_FOUND							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x0a)
// The breakpoint to be deleted does not exist

#define GNR_INVALID_UNIQUE_KEY							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x0b)
// The unique key could not be created/was invalid

#define GNR_ERROR_RECOVERY									MKERR(ERROR,	NAVIGATION, INTERNALSTATE,		0x0c)
// The navigation is currently in an error recovery mode for some reason and therefore it could be
// that some queries can't be satisfied (e.g. the GetExtendedPlayerState())

//
//  DVD specific errors
//

#define GNR_UOP_PROHIBITED									MKERR(ERROR,	DVD,			UOP,					0x01)
// The current UOPs do not allow this action

#define GNR_REGIONS_DONT_MATCH							MKERR(ERROR,	DVD,			REGION,				0x00)
// The system and disk regions don't match

#define GNR_REGION_CODE_INVALID							MKERR(ERROR,	DVD,			REGION,				0x01)
// The region code specified was invalid (e.g. multiregion when trying to set region)

#define GNR_NO_MORE_REGION_SETS							MKERR(ERROR,	DVD,			REGION,				0x02)
// The number of region changes is exhausted

#define GNR_REGION_WRITE_ERROR							MKERR(ERROR,	DVD,			REGION,				0x03)
// Unable to write region

#define GNR_REGION_READ_ERROR								MKERR(ERROR,	DVD,			REGION,				0x04)
// Unable to read region

#define GNR_PARENTAL_LEVEL_TOO_LOW						MKERR(ERROR,	DVD,			PARENTAL,			0x03)
// The parental level currently set is too low to play the disc

#define GNR_ILLEGAL_NAVIGATION_COMMAND					MKERR(ERROR,	DVD,			OPERATION,			0x00)
// The DVD contains an illegal navigation command

#define GNR_ILLEGAL_DOMAIN									MKERR(ERROR,	DVD,			OPERATION,			0x01)
// The domain is illegal for this operation

#define GNR_NO_RESUME_INFORMATION						MKERR(ERROR,	DVD,			OPERATION,			0x02)
// No resume information currently available

#define GNR_COULD_NOT_CHANGE_ANGLE						MKERR(ERROR,	DVD,			OPERATION,			0x03)
// Angle change was not possible

//
//  VCD specific errors
//

//
//  CDDA specific errors
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\qerror.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  $Workfile: qerror.h $
//
//  Copyright (c) 1999  Quadrant International, Inc.
//  All Rights Reserved.
//
//////////////////////////////////////////////////////////////////////////////
//
// $Archive: /Tproj/Apps/xbDVD/INC/qerror.h $
// $Author: Mpeteritas $
// $Modtime: 3/21/01 6:24p $
// $Date: 3/21/01 6:24p $
// $Archive: /Tproj/Apps/xbDVD/INC/qerror.h $
// $Revision: 2 $
//
////////////////////////////////////$NoKeywords: $////////////////////////////


#ifndef QI_Errors_H
#define QI_Errors_H

#include "winerror.h"

#define FACILITY_QI		FACILITY_ITF

#define QI_ERROR    3
#define QI_WARNING  2
#define QI_INFO     1
#define QI_OK		0

#define MAKE_HR( a, b, c ) MAKE_HRESULT(a, b, c+0x0200)

// ERRORs
#define QI_E_NOTINITIALIZED			MAKE_HR( QI_ERROR, FACILITY_QI, 1 )
#define QI_E_INVALIDPROPERTY		MAKE_HR( QI_ERROR, FACILITY_QI, 2 )
#define QI_E_MEDIA_NOT_RECOGNIZED	MAKE_HR( QI_ERROR, FACILITY_QI, 3 )
#define QI_E_DSHOW_NODVD			MAKE_HR( QI_ERROR, FACILITY_QI, 4 )
#define QI_E_DSHOW_RENDERFAIL		MAKE_HR( QI_ERROR, FACILITY_QI, 5 )
#define QI_E_CREATIONFAILED			MAKE_HR( QI_ERROR, FACILITY_QI, 6 )
#define QI_E_MEMORYERROR			MAKE_HR( QI_ERROR, FACILITY_QI, 7 )
#define QI_E_INVALID_TYPE_SPECIFIED	MAKE_HR( QI_ERROR, FACILITY_QI, 8 )
#define QI_E_NO_OBJECTS_LOADED		MAKE_HR( QI_ERROR, FACILITY_QI, 9 )
#define QI_E_DRIVE_EMPTY			MAKE_HR( QI_ERROR, FACILITY_QI, 10 )
#define QI_E_RESOURCE				MAKE_HR( QI_ERROR, FACILITY_QI, 11 )
#define QI_E_LARGERBUFFERSIZE		MAKE_HR( QI_ERROR, FACILITY_QI, 12 )
#define QI_E_AUTOSCAN_ABORT			MAKE_HR( QI_ERROR, FACILITY_QI, 13 )
#define QI_E_INVALID_REGION			MAKE_HR( QI_ERROR, FACILITY_QI, 14 )
#define QI_E_INSUFFICIENT_RIGHTS	MAKE_HR( QI_ERROR, FACILITY_QI, 15 )

// INFOs
#define QI_I_NOTAPPLICABLE			MAKE_HR( QI_INFO, FACILITY_QI, 1 )
#define QI_I_CHANGEPENDING			MAKE_HR( QI_INFO, FACILITY_QI, 2 )
#define QI_I_NOTVALIDNOW			MAKE_HR( QI_INFO, FACILITY_QI, 3 )

// OKs

// WARNINGs
#define QI_W_BOOL_EXPECTED			MAKE_HR( QI_WARNING, FACILITY_QI, 1 )
#define QI_W_DATAOUTOFRANGE			MAKE_HR( QI_WARNING, FACILITY_QI, 2 )
#define QI_W_READONLY				MAKE_HR( QI_WARNING, FACILITY_QI, 3 )
#define QI_W_SETONLY				MAKE_HR( QI_WARNING, FACILITY_QI, 4 )
#define QI_W_INPROCESS				MAKE_HR( QI_WARNING, FACILITY_QI, 5 )

// Message Based Errors
enum {
	QERROR_UNKNOWN = 100,	// don't tread on DShow errors
	QERROR_VIDEOSTREAM,		// the video stream couldn't be rendered
	QERROR_AUDIOSTREAM,		// the audio stream couldn't be rendered
	QERROR_SUBPICSTREAM,	// the subpicture stream couldn't be rendered
	QERROR_VPE,				// there was a problem creating the vpe surface
	QERROR_VOL_INVALID,		// the DVD volume was deemed invalid
	QERROR_VOL_UNKNOWN,		// the DVD volume is of an unknown type
	QERROR_CAPTIONS,		// closed captions don't appear to be properly encoded
	QERROR_REGION,			// the DVD is not of a playable region code
	QERROR_COPYPROTECTION,	// the DVD's copy protection could not be authenticated
	QERROR_FORMAT,			// does not meet DVD 1.0 specs
	QERROR_MACROVISION,		// the DVD's macrovision protection could not be authenticated
	QERROR_SYS_DECODER,		// system region and decoder region don't match
	QERROR_DISC_DECODER,	// disc not authored for decoder region
	QERROR_COUNT
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\evcode.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------
// File: EvCode.h
//
// Desc: List of standard Quartz event codes and the expected params.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


// Event codes are broken into two groups
//   -- system event codes
//   -- extension event codes
// All system event codes are below EC_USER

#define EC_SYSTEMBASE                       0x00
#define EC_USER                             0x8000

// System-defined event codes
// ==========================
//
// There are three types of system-defined event codes:
//
// 1.  Those which are always passed through to the application
//     (To be collected by calls to GetEvent or within WaitForCompletion.)
//     (e.g. EC_ERRORABORT, EC_USERABORT.)
//
// 2.  Those which are pure internal and will never be passed to
//     the application.  (e.g. EC_SHUTDOWN)
//
// 3.  Those which have default handling.  Default handing implies that
//     the event is not passed to the application.  However, default
//     handling may be canceled by calling
//     IMediaEvent::CancelDefaultHandling.  If the default handling is
//     cancelled in this way, then the message will be delivered to the
//     application and the application must action it appropriately.
//     Default handling can be restored by calling RestoreDefaultHandling.
//
// We will refer to these events as application, internal and defaulted
// events respectively.
//
// System-defined events may have interface pointers, BSTR's, etc passed
// as parameters.  It is therefore essential that, for any message
// retrieved using GetEvent, a matching call to FreeEventParams is made
// to ensure that relevant interfaces are released and storage freed.
// Failure to call FreeEventParams will result in memory leaks, if not
// worse.
//
// Filters sending these messages to the filter graph should not AddRef()
// any interfaces that they may pass as parameters.  The filter graph
// manager will AddRef them if required.  E.g. if the event is to be queued
// for the application or queued to a worker thread.

// Each event listed below is immediately followed by a parameter list
// detailing the types of the parameters associated with the message,
// and an indication of whether the message is an application, internal
// or defaulted message.  This is then followed by a short description.
// The use of "void" in the parameter list implies that the parameter is not
// used.  Such parameters should be zero.

// Other defined EC_ regions:
// DVD event codes           0x0100 - 0x0150 (dvdevcod.h)
// audio device event codes  0x0200 - 0x0250 (audevcod.h)
// WindowsMedia SDK-originated events 0x0251 - 0x0300 (see below)

#define EC_COMPLETE                         0x01
// ( HRESULT, void ) : defaulted (special)
// Signals the completed playback of a stream within the graph.  This message
// is sent by renderers when they receive end-of-stream.  The default handling
// of this message results in a _SINGLE_ EC_COMPLETE being sent to the
// application when ALL of the individual renderers have signaled EC_COMPLETE
// to the filter graph.  If the default handing is canceled, the application
// will see all of the individual EC_COMPLETEs.


#define EC_USERABORT                        0x02
// ( void, void ) : application
// In some sense, the user has requested that playback be terminated.
// This message is typically sent by renderers that render into a
// window if the user closes the window into which it was rendering.
// It is up to the application to decide if playback should actually
// be stopped.


#define EC_ERRORABORT                       0x03
// ( HRESULT, void ) : application
// Operation aborted because of error


#define EC_TIME                             0x04
// ( DWORD, DWORD ) : application
// The requested reference time occurred.  (This event is currently not used).
// lParam1 is low dword of ref time, lParam2 is high dword of reftime.


#define EC_REPAINT                          0x05
// ( IPin * (could be NULL), void ) : defaulted
// A repaint is required - lParam1 contains the (IPin *) that needs the data
// to be sent again. Default handling is: if the output pin which the IPin is
// attached  to supports the IMediaEventSink interface then it will be called
// with the EC_REPAINT first.  If that fails then normal repaint processing is
// done by the filter graph.


// Stream error notifications
#define EC_STREAM_ERROR_STOPPED             0x06
#define EC_STREAM_ERROR_STILLPLAYING        0x07
// ( HRESULT, DWORD ) : application
// lParam 1 is major code, lParam2 is minor code, either may be zero.


#define EC_ERROR_STILLPLAYING               0x08
// ( HRESULT, void ) : application
// The filter graph manager may issue Run's to the graph asynchronously.
// If such a Run fails, EC_ERROR_STILLPLAYING is issued to notify the
// application of the failure.  The state of the underlying filters
// at such a time will be indeterminate - they will all have been asked
// to run, but some are almost certainly not.


#define EC_PALETTE_CHANGED                  0x09
// ( void, void ) : application
// notify application that the video palette has changed


#define EC_VIDEO_SIZE_CHANGED               0x0A
// ( DWORD, void ) : application
// Sent by video renderers.
// Notifies the application that the native video size has changed.
// LOWORD of the DWORD is the new width, HIWORD is the new height.


#define EC_QUALITY_CHANGE                   0x0B
// ( void, void ) : application
// Notify application that playback degradation has occurred


#define EC_SHUTTING_DOWN                    0x0C
// ( void, void ) : internal
// This message is sent by the filter graph manager to any plug-in
// distributors which support IMediaEventSink to notify them that
// the filter graph is starting to shutdown.


#define EC_CLOCK_CHANGED                    0x0D
// ( void, void ) : application
// Notify application that the clock has changed.
// (i.e. SetSyncSource has been called on the filter graph and has been
// distributed successfully to the filters in the graph.)


#define EC_PAUSED                           0x0E
// ( HRESULT, void ) : application
// Notify application the previous pause request has completed


#define EC_OPENING_FILE	                    0x10
#define EC_BUFFERING_DATA                   0x11
// ( BOOL, void ) : application
// lParam1 == 1   --> starting to open file or buffer data
// lParam1 == 0   --> not opening or buffering any more
// (This event does not appear to be used by ActiveMovie.)


#define EC_FULLSCREEN_LOST                  0x12
// ( void, IBaseFilter * ) : application
// Sent by full screen renderers when switched away from full screen.
// IBaseFilter may be NULL.


#define EC_ACTIVATE                         0x13
// ( BOOL, IBaseFilter * ) : internal
// Sent by video renderers when they lose or gain activation.
// lParam1 is set to 1 if gained or 0 if lost
// lParam2 is the IBaseFilter* for the filter that is sending the message
// Used for sound follows focus and full-screen switching


#define EC_NEED_RESTART                     0x14
// ( void, void ) : defaulted
// Sent by renderers when they regain a resource (e.g. audio renderer).
// Causes a restart by Pause/put_Current/Run (if running).


#define EC_WINDOW_DESTROYED                 0x15
// ( IBaseFilter *, void ) : internal
// Sent by video renderers when the window has been destroyed. Handled
// by the filter graph / distributor telling the resource manager.
// lParam1 is the IBaseFilter* of the filter whose window is being destroyed


#define EC_DISPLAY_CHANGED                  0x16
// ( IPin *, void ) : internal
// Sent by renderers when they detect a display change. the filter graph
// will arrange for the graph to be stopped and the pin send in lParam1
// to be reconnected. by being reconnected it allows a renderer to reset
// and connect with a more appropriate format for the new display mode
// lParam1 contains an (IPin *) that should be reconnected by the graph


#define EC_STARVATION                       0x17
// ( void, void ) : defaulted
// Sent by a filter when it detects starvation. Default handling (only when
// running) is for the graph to be paused until all filters enter the
// paused state and then run. Normally this would be sent by a parser or source
// filter when too little data is arriving.


#define EC_OLE_EVENT			    0x18
// ( BSTR, BSTR ) : application
// Sent by a filter to pass a text string to the application.
// Conventionally, the first string is a type, and the second a parameter.


#define EC_NOTIFY_WINDOW                    0x19
// ( HWND, void ) : internal
// Pass the window handle around during pin connection.

#define EC_STREAM_CONTROL_STOPPED	    0x1A
// ( IPin * pSender, DWORD dwCookie )
// Notification that an earlier call to IAMStreamControl::StopAt
// has now take effect.  Calls to the method can be marked
// with a cookie which is passed back in the second parameter,
// allowing applications to easily tie together request
// and completion notifications.
//
// NB: IPin will point to the pin that actioned the Stop.  This
// may not be the pin that the StopAt was sent to.

#define EC_STREAM_CONTROL_STARTED	    0x1B
// ( IPin * pSender, DWORD dwCookie )
// Notification that an earlier call to IAMStreamControl::StartAt
// has now take effect.  Calls to the method can be marked
// with a cookie which is passed back in the second parameter,
// allowing applications to easily tie together request
// and completion notifications.
//
// NB: IPin will point to the pin that actioned the Start.  This
// may not be the pin that the StartAt was sent to.

#define EC_END_OF_SEGMENT                   0x1C
//
// ( const REFERENCE_TIME *pStreamTimeAtEndOfSegment, DWORD dwSegmentNumber )
//
// pStreamTimeAtEndOfSegment
//     pointer to the accumulated stream clock
//     time since the start of the segment - this is directly computable
//     as the sum of the previous and current segment durations (Stop - Start)
//     and the rate applied to each segment
//     The source add this time to the time within each segment to get
//     a total elapsed time
//
// dwSegmentNumber
//     Segment number - starts at 0
//
// Notifies that a segment end has been reached when the
// AM_SEEKING_Segment flags was set for IMediaSeeking::SetPositions
// Passes in an IMediaSeeking interface to allow the next segment
// to be defined by the application

#define EC_SEGMENT_STARTED                  0x1D
//
// ( const REFERENCE_TIME *pStreamTimeAtStartOfSegment, DWORD dwSegmentNumber)
//
// pStreamTimeAtStartOfSegment
//     pointer to the accumulated stream clock
//     time since the start of the segment - this is directly computable
//     as the sum of the previous segment durations (Stop - Start)
//     and the rate applied to each segment
//
// dwSegmentNumber
//     Segment number - starts at 0
//
// Notifies that a new segment has been started.
// This is sent synchronously by any entity that will issue
// EC_END_OF_SEGMENT when a new segment is started
// (See IMediaSeeking::SetPositions - AM_SEEKING_Segment flag)
// It is used to compute how many EC_END_OF_SEGMENT notifications
// to expect at the end of a segment and as a consitency check

#define EC_LENGTH_CHANGED                  0x1E
// (void, void)
// sent to indicate that the length of the "file" has changed

#define EC_DEVICE_LOST                     0x1f
// (IUnknown, 0)
//
// request window notification when the device is available again
// (through WM_DEVICECHANGED messages registered with
// RegisterDeviceNotification; see IAMDeviceRemoval interface)

#define EC_STEP_COMPLETE                      0x24
// (BOOL bCacelled, void)
// Step request complete
// if bCancelled is TRUE the step was cancelled.  This can happen
// if the application issued some control request or because there
// was a mode change etc etc


#define EC_SKIP_FRAMES                      0x25
// ( nFramesToSkip, void ) : internal
// Get the filter graph to seek accuratley.

#define EC_TIMECODE_AVAILABLE			0x30
// Sent by filter supporting timecode
// Param1 has a pointer to the sending object
// Param2 has the device ID of the sending object

#define EC_EXTDEVICE_MODE_CHANGE		0x31
// Sent by filter supporting IAMExtDevice
// Param1 has the new mode
// Param2 has the device ID of the sending object

#define EC_GRAPH_CHANGED                        0x50
// Sent by filter to notify interesting graph changes

#define EC_CLOCK_UNSET                      0x51
// ( void, void ) : application
// Used to notify the filter graph to unset the current graph clock.
// Has the affect of forcing the filter graph to reestablish the graph clock
// on the next Pause/Run (note that this is only used by ksproxy, when the pin
// of a clock providing filter is disconnected)


//------------------------------------------
//
// WindowsMedia SDK filter-specific events:
//
#define EC_WMT_EVENT_BASE                   0x0251
//
#define EC_WMT_INDEX_EVENT                  EC_WMT_EVENT_BASE
// WindowsMedia SDK-originated file indexing status, sent by WMSDK-based filters
//
// lParam1 is one of the enum WMT_STATUS messages listed below, sent by the WindowsMedia SDK
// lParam2 is specific to the lParam event
//
//     the following WMT_STATUS messages are sent for this event:
//         WMT_STARTED        - lParam2 is 0
//         WMT_CLOSED         - lParam2 is 0
//         WMT_INDEX_PROGRESS - lParam2 is a DWORD containing the progress percent complete
//
// end WMSDK-originated events
//-----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\qevent.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  $Workfile: qevent.h $
//
//  Copyright (c) 1999  Quadrant International, Inc.
//  All Rights Reserved.
//
//////////////////////////////////////////////////////////////////////////////
//
// $Archive: /Tproj/Apps/xbDVD/INC/qevent.h $
// $Author: Thermanson $
// $Modtime: 9/12/00 8:29a $
// $Date: 1/22/01 3:56p $
// $Archive: /Tproj/Apps/xbDVD/INC/qevent.h $
// $Revision: 1 $
//
////////////////////////////////////$NoKeywords: $////////////////////////////


#ifndef QEvent_h
#define QEvent_h

#include "evcode.h"

// UOP definitions
#define MKFLAG(x)					(1UL << x)

#define UOP_TIME_PLAY_SEARCH			MKFLAG(0)
#define UOP_PTT_PLAY_SEARCH			MKFLAG(1)
#define UOP_TITLE_PLAY				MKFLAG(2)
#define UOP_STOP					MKFLAG(3)
#define UOP_GO_UP					MKFLAG(4)
#define UOP_TIME_PTT_SEARCH			MKFLAG(5)
#define UOP_PREV_TOP_PG_SEARCH		MKFLAG(6)
#define UOP_NEXT_PG_SEARCH			MKFLAG(7)
#define UOP_FORWARD_SCAN				MKFLAG(8)
#define UOP_BACKWARD_SCAN			MKFLAG(9)
#define UOP_MENU_CALL_TITLE			MKFLAG(10)
#define UOP_MENU_CALL_ROOT			MKFLAG(11)
#define UOP_MENU_CALL_SUB_PICTURE		MKFLAG(12)
#define UOP_MENU_CALL_AUDIO			MKFLAG(13)
#define UOP_MENU_CALL_ANGLE			MKFLAG(14)
#define UOP_MENU_CALL_PTT			MKFLAG(15)
#define UOP_RESUME					MKFLAG(16)
#define UOP_BUTTON					MKFLAG(17)
#define UOP_STILL_OFF				MKFLAG(18)
#define UOP_PAUSE_ON				MKFLAG(19)
#define UOP_AUDIO_STREAM_CHANGE		MKFLAG(20)
#define UOP_SUB_PICTURE_STREAM_CHANGE	MKFLAG(21)
#define UOP_ANGLE_CHANGE				MKFLAG(22)
#define UOP_KARAOKE_MODE_CHANGE		MKFLAG(23)
#define UOP_VIDEO_MODE_CHANGE			MKFLAG(24)

//
// Event Codes
//

// EC_QI_AUTOSCAN_PERCENTAGE
//
// data is the percentage complete of the automatic channel scan.
//
// Periodically updates the application as to the percentage complete of the
// automatic channel scan.
#define EC_QI_AUTOSCAN_PERCENTAGE		(EC_USER|1)

// EC_QI_AUTOSCAN_DONE
//
// no data
//
// Indicates the automatic channel scan is complete.
#define EC_QI_AUTOSCAN_DONE			(EC_USER|2)

// EC_QI_AUTOSCAN_ABORTED
//
// no data
//
// Indicates that the automatic channel scan has been aborted.  If requested,
// this indicates the request has successfully completed.
#define EC_QI_AUTOSCAN_ABORTED		(EC_USER|3)



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\qmessages.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  $Workfile: qmessages.h $
//
//  Copyright (c) 1999  Quadrant International, Inc.
//  All Rights Reserved.
//
//////////////////////////////////////////////////////////////////////////////
//
// $Archive: /Tproj/Apps/xbDVD/INC/qmessages.h $
// $Author: Thermanson $
// $Modtime: 9/12/00 8:29a $
// $Date: 1/22/01 3:56p $
// $Archive: /Tproj/Apps/xbDVD/INC/qmessages.h $
// $Revision: 1 $
//
////////////////////////////////////$NoKeywords: $////////////////////////////


#ifndef QIMessages_h
#define QIMessages_h

#include "winuser.h"

#define BASE	WM_APP + 100

// WM_QI_DSHOW		is sent to a window by DirectShow's IMediaEventEx interface.
//				The DirectShow IMediaEventEx::GetEvent method should then be
//				called to retrieve the event that took place and respond
//				to it.
//
// wParam			not used
//
// lParam			pointer to the IMediaEventEx interface
//
#define WM_QI_DSHOW						BASE + 5

// QMediaComponentEvent and QMediaComponentEvent2
//				sent to a window to indicate some sort of event took place,
//                  perhaps without user interaction.  The "2" is sent after the
//				regular to indicate	the same event with more data.
//
// wParam			QI event code or DShow event code (EC_*)
//
// lParam			data for the event, if any
//
#define QMediaComponentEvent	"QMediaComponentEvent"
#define QMediaComponentEvent2	"QMediaComponentEvent2"



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\WinEFS.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       winefs.h
//
//  Contents:   EFS Data and prototypes.
//
//----------------------------------------------------------------------------

#ifndef __WINEFS_H__
#define __WINEFS_H__

#if _MSC_VER>1000
#pragma once
#endif


#ifdef __cplusplus
extern "C" {
#endif

//+---------------------------------------------------------------------------------/
//                                                                                  /
//                                                                                  /
//                          Data Structures                                         /
//                                                                                  /
//                                                                                  /
//----------------------------------------------------------------------------------/


//
//  Encoded Certificate
//


typedef struct _CERTIFICATE_BLOB {

    DWORD   dwCertEncodingType;

    DWORD   cbData;

#ifdef MIDL_PASS
    [size_is(cbData)]
#endif // MIDL_PASS
    PBYTE    pbData;

} EFS_CERTIFICATE_BLOB, *PEFS_CERTIFICATE_BLOB;


//
//  Certificate Hash
//

typedef struct _EFS_HASH_BLOB {

    DWORD   cbData;

#ifdef MIDL_PASS
    [size_is(cbData)]
#endif // MIDL_PASS
    PBYTE    pbData;

} EFS_HASH_BLOB, *PEFS_HASH_BLOB;



//
// Input to add a user to an encrypted file
//


typedef struct _ENCRYPTION_CERTIFICATE {
    DWORD cbTotalLength;
    SID * pUserSid;
    PEFS_CERTIFICATE_BLOB pCertBlob;
} ENCRYPTION_CERTIFICATE, *PENCRYPTION_CERTIFICATE;

#define MAX_SID_SIZE 256


typedef struct _ENCRYPTION_CERTIFICATE_HASH {
    DWORD cbTotalLength;
    SID * pUserSid;
    PEFS_HASH_BLOB  pHash;

#ifdef MIDL_PASS
    [string]
#endif // MIDL_PASS
    LPWSTR lpDisplayInformation;

} ENCRYPTION_CERTIFICATE_HASH, *PENCRYPTION_CERTIFICATE_HASH;







typedef struct _ENCRYPTION_CERTIFICATE_HASH_LIST {
    DWORD nCert_Hash;
#ifdef MIDL_PASS
    [size_is(nCert_Hash)]
#endif // MIDL_PASS
     PENCRYPTION_CERTIFICATE_HASH * pUsers;
} ENCRYPTION_CERTIFICATE_HASH_LIST, *PENCRYPTION_CERTIFICATE_HASH_LIST;



typedef struct _ENCRYPTION_CERTIFICATE_LIST {
    DWORD nUsers;
#ifdef MIDL_PASS
    [size_is(nUsers)]
#endif // MIDL_PASS
     PENCRYPTION_CERTIFICATE * pUsers;
} ENCRYPTION_CERTIFICATE_LIST, *PENCRYPTION_CERTIFICATE_LIST;




//+---------------------------------------------------------------------------------/
//                                                                                  /
//                                                                                  /
//                               Prototypes                                         /
//                                                                                  /
//                                                                                  /
//----------------------------------------------------------------------------------/


WINADVAPI
DWORD
WINAPI
QueryUsersOnEncryptedFile(
     IN LPCWSTR lpFileName,
     OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pUsers
    );


WINADVAPI
DWORD
WINAPI
QueryRecoveryAgentsOnEncryptedFile(
     IN LPCWSTR lpFileName,
     OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    );


WINADVAPI
DWORD
WINAPI
RemoveUsersFromEncryptedFile(
     IN LPCWSTR lpFileName,
     IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    );

WINADVAPI
DWORD
WINAPI
AddUsersToEncryptedFile(
     IN LPCWSTR lpFileName,
     IN PENCRYPTION_CERTIFICATE_LIST pUsers
    );

WINADVAPI
DWORD
WINAPI
SetUserFileEncryptionKey(
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    );


WINADVAPI
VOID
WINAPI
FreeEncryptionCertificateHashList(
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    );

WINADVAPI
BOOL
WINAPI
EncryptionDisable(
    IN LPCWSTR DirPath,
    IN BOOL Disable
    );


#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __WINEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\DDPCyber.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DDP Layer Configuration File For Cyberdrive
//
////////////////////////////////////////////////////////////////////

//#include "DDPST20.h"
#include "driver/dvdpldrv/Common/dvdpld32.h"
#include "VCDDiskPlayerFactory.h"
#include "AVFDiskPlayerFactory.h"
#include "CDDADiskPlayerFactory.h"
#include "AVFFileSystemFactory.h"
#include "CDDAFileSystemFactory.h"

////////////////////////////////////////////////////////////////////
//
//  Initialization function
//
////////////////////////////////////////////////////////////////////

Error DDP_Initialize(GenericProfile * profile)
	{
	WinPortServer * server;
	DriveTable * driveTable;

	//
	//  Create WinPortServer
	//

	server = new WinPortServer();
	if (!server)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	//
	//  Create ST20LITE drive table
	//

	driveTable = new ST20DriveTable();
	if (!driveTable)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	GNREASSERT(driveTable->Init(profile));

	//
	//  Perform general initialization
	//

	GNRAISE(DDP_Init(server, profile, driveTable,
						  new DVDVideoDiskPlayerFactory(),
						  new DVDAudioDiskPlayerFactory(),
						  new FullVCDDiskPlayerFactory(),
						  new FullCDDADiskPlayerFactory(),
						  new FullAVFDiskPlayerFactory(),
						  new DVDFileSystemFactory(),
						  new VCDFileSystemFactory(),
						  new CDDAFileSystemFactory(),
						  new AVFFileSystemFactory(),
						  new FileSystemFactory()));
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\boards\generic\vdgendrv.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "win32\vdgendrv.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\qproperties.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  $Workfile: qproperties.h $
//
//  Copyright (c) 1999  Quadrant International, Inc.
//  All Rights Reserved.
//
//////////////////////////////////////////////////////////////////////////////
//
// $Archive: /Tproj/Apps/xbDVD/INC/qproperties.h $
// $Author: Thermanson $
// $Modtime: 1/22/01 10:46a $
// $Date: 1/22/01 3:56p $
// $Archive: /Tproj/Apps/xbDVD/INC/qproperties.h $
// $Revision: 1 $
//
////////////////////////////////////$NoKeywords: $////////////////////////////


#ifndef QIProperties_H
#define QIProperties_H

enum {
	QI_MEDIACONTROL,
	QI_MEDIACONTROL_CDA,
	QI_MEDIACONTROL_DVD,
	QI_MEDIACONTROL_VIDEOCD,
	QI_MEDIACONTROL_FILE,
	QI_MEDIACONTROL_ANALOG_TV,
	QI_MEDIACONTROL_DIGITAL_TV,
	QI_MEDIACONTROL_CAMVCR,
	// add new type objects above this comment...
	QI_MEDIACONTROL_COUNT
	};


// Available Properties for use with IQMedia, IQMediaManager, and all
// derived classes.
//
// All definitions are comprised as follows:
//
//		QPROP_TYPE_NAME
//
// where QPROP indicates it's a property, TYPE is replaced by the data type of
// the property (such as BOOL, INT, etc.), and NAME is simply the name of the
// property.
//
// The appropriate type item in the QIPROP structure will be construed from
// the LONG type passed to set or get by typecasting.  For example, if a BOOL
// type is expected, the LONG should simply be 0 or 1, or an error is produced.
//
enum {
	QPROP_START,
//	QPROP_BOOL_TEST,			// set classes to test mode only
	QPROP_INT_MODE,			// current mode, read only by app
	QPROP_BOOL_CLOSEDCAPTIONS,	// turn on/off closed captioning

	QPROP_SHORT_VIDEOMODE,		// preferred video mode

	QPROP_SHORT_PARENTLVL,		// parental level of player --
							//		it is up to the app to save and
							//		maintain this setting -- this simply
							//		passes it along to any devices that
							//		care
	QPROP_WORD_PARENTCOUNTRY,	// parental level country, see description for
							//		parental level...

	QPROP_BOOL_STOPTOMENU,		// when playing, hit stop, go to menu or stop
							// completely?  TRUE to menu, FALSE to stop

	QPROP_HWND_EVENTWINDOW,		// window to send messages and events to

	QPROP_BOOL_USEDIVICORE,		// force use of divicore DShow filter(s)

	QPROP_BOOL_PREFERHW,		// prefer use of hardware decoding (DirectShow)

	QPROP_DWORD_SOURCESIZE,		// read only, retrieve the size of the video source as
							// HIGHWORD x LOWORD of the DWORD.


	QPROP_BOOL_ASPECTFIXED,		// should the video aspect ratio be fixed (TRUE), or should the
							// video fill the given window (FALSE)?

	QPROP_POINTER_DDCOLORCONTROL,	// get/set color controls (brightness, contrast, etc.) using a
							// pointer to the DirectDraw defined DDCOLORCONTROL structure
							// declared in ddraw.h

	QPROP_LONG_SRCLETTERBOXING,	// is the source of the video letterboxed already? see enum
							// SrcLetterBoxing

	QPROP_BOOL_PAUSEHACK,		// uses IMediaControl->Pause instead of IDvdControl->PauseOn

	QPROP_LCID_AUDIOCOUNTRY,		// place the number of the audio stream in the parameter; what is
							// returned will be the code.  READ ONLY

	QPROP_LCID_SUBPICCOUNTRY,	// see QPROP_WORD_AUDIOCOUNTRY

	QPROP_BOOL_CABLEORANTENNA,	// indication of whether cable is being used, or an antenna
							// is being used for coaxial input of a TV stream (TRUE = CABLE)

	QPROP_BOOL_TIMESHIFTABLE,	// recording device can be time-shifted.  READ ONLY

	QPROP_POINTER_ZOOMRECT,		// pass a pointer to a RECT, get back the dimensions of the video
								// section that you have zoomed using IQMediaTricks.  READ ONLY
	QPROP_BOOL_AC3_DIGITALAUDIO_PASSTHROUGH_ENABLED,		// Used for setting or obtaining the ACS digital audio passthrough
															// setting as seen in Software Cinemaster property sheet.  TRUE means
															// enabled, FALSE means disabled.
	QPROP_BOOL_AC3_DIGITALAUDIO_PASSTHROUGH_AVAILABLE,		// Determines whether or not AC-3 digital audio passthrough is available
															// on this soundcard. READ ONLY
	QPROP_END
	};

enum {
	SRCLTX_NONE,
	SRCLTX_4x3_LETTERBOX,
	SRCLTX_COUNT
	};

enum {						// Modes for QPROP_INT_MODE above
	QMODE_NONE,				// no applicable state (no usable media)
	QMODE_STILL,				// media is in still frame
	QMODE_PLAYING,				// media is playing
	QMODE_STOPPED,				// media is stopped
	QMODE_PAUSED,				// media is paused
	QMODE_RECORDING,			// media is recording
	QMODE_SEEKING,				// seeking the current media
	QMODE_BUSY,
	QMODE_TRICKREVERSE,			// trick mode reverse play
	QMODE_TRICKFRAME,			// trick mode frame advance
	QMODE_COUNT
	};

enum {
	QMENU_NONE,				// menu choices for DVD
	QMENU_TITLE,
	QMENU_ROOT,
	QMENU_SUBPIC,
	QMENU_AUDIO,
	QMENU_ANGLE,
	QMENU_CHAPTER,				// chapter menu, or part of title (PTT)
	QMENU_COUNT
	};

enum {
	QDOMAIN_NONE,				// DVD Domains
	QDOMAIN_FIRSTPLAY,
	QDOMAIN_TITLE,
	QDOMAIN_VIDEOTITLESET,
	QDOMAIN_VIDEOMANAGER,
	QDOMAIN_STOP,
	QDOMAIN_COUNT
	};

enum {
	QVIDEO_NONE,				// preferred video playback modes
	QVIDEO_DEFAULT,			// default content type
	QVIDEO_16x9,				// enhanced for 16x9 TVs
	QVIDEO_PANSCAN,			// pan and scan (TV) format
	QVIDEO_LETTERBOX,			// widescreen for normal TVs
	QVIDEO_COUNT
	};

enum {								// AnalogTV constants
	QPROP_BOOL_TIMESHIFT= 100,
	QPROP_BOOL_BLINDRECORD,
	QPROP_LONG_BITRATE,
	QPROP_INT_PICTUREQUALITY,
	QPROP_BOOL_AUTOSCANNED,
	QPROP_LONG_BUFFERLEFTMB,
	QPROP_LONG_RECORDTIMESEC,
	QPROP_LONG_DELAYTIMESEC
	};

enum {								// AnalogTV Recording states
	RECORDSTATE_STOPPED,
	RECORDSTATE_VIEWING,
	RECORDSTATE_PLAYING,
	RECORDSTATE_RECORDING,
	RECORDSTATE_TIMESHIFTING,
	RECORDSTATE_PAUSED
	};

// define a GUID for QI DVD filter
// {595E37C1-A479-11d1-BC3C-006097B18ABC}
//wmpx DEFINE_GUID(CLSID_QIDVDFilter, 0x595e37c1, 0xa479, 0x11d1, 0xbc, 0x3c, 0x00, 0x60, 0x97, 0xb1, 0x8a, 0xbc);

#define FLAG(x)	(1UL << x)

#define QFLAG_DIRECTSHOW		FLAG(0)
#define QFLAG_FILEBASED		FLAG(1)
#define QFLAG_DISCBASED		FLAG(2)
#define QFLAG_HARDWAREDECODE	FLAG(3)
#define QFLAG_SOFTWAREDECODE	FLAG(4)
#define QFLAG_CONTAINSVIDEO	FLAG(5)
#define QFLAG_STREAMING		FLAG(6)
#define QFLAG_DIGITALSTR		FLAG(7)		// digital streaming data, or analog
#define QFLAG_RECORDABLE		FLAG(8)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\vddebug.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\vddebug.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#ifndef _VDDEBUG_
#define _VDDEBUG_

#include "library/common/gnerrors.h"


#if LINUX
#include <stdio.h>
#include "library/common/prelude.h"
#define _export    /* FN: should be corrected in prelude.h.. */
#endif

void __cdecl MDebugPrint(const TCHAR * szFormat, ...);
#define RDP MDebugPrint

#if _DEBUG
	#ifdef _PROPTEST
		extern Error Print(const TCHAR __far * szFormat, ...);
		#define DP Print
	#elif NT_KERNEL
		#define DP DbgPrint("\n"), DbgPrint
	#elif VXD_VERSION
		void _cdecl DebugPrint(char * szFormat, ...);
		#define DP DebugPrint
	#elif LINUX
		void DebugPrint (const TCHAR * szFormat, ...);	// standard prototype for debug output
		#define DP DebugPrint
		#define DPF printf
		void DebugPrintRecord (const TCHAR * szFormat, ...);	// standard prototype for debug output
		#define DPR DebugPrintRecord
		void InitializeDebugRecording (void);
		void GetDebugRecordingParameters (BYTE * & array, int & size);
	#elif _DOS
		#define DP printf   // note: output should really go to stderr instead of stdout
#else
		void FAR __cdecl DebugPrint(const TCHAR __far * szFormat, ...);	// standard prototype for debug output
		#define DP DebugPrint
	#endif
#else
	#ifdef _PROPTEST
		extern Error Print(const TCHAR __far * szFormat, ...);
		#define DP Print
	#elif NT_KERNEL
		inline void __cdecl DebugPrintEmpty(const char __far * szFormat, ...) {}		// empty function (optimized to nothing)
		#define DP while(0) DebugPrintEmpty
	#elif LINUX
		inline void DebugPrintEmpty(const TCHAR * szFormat, ...) {}		// empty function (optimized to nothing)
		#define DP while(0) DebugPrintEmpty
		#define DPF while(0) DebugPrintEmpty
		#define DPR while(0) DebugPrintEmpty
		inline void InitializeDebugRecording (void) {}
		inline void GetDebugRecordingParameters (BYTE * & array, int & size) {array=NULL; size=0;}
#else
		inline void __cdecl DebugPrintEmpty(const TCHAR __far * szFormat, ...) {}		// empty function (optimized to nothing)
		#define DP while(0) DebugPrintEmpty
	#endif
#endif

#ifdef _DEBUG

#if NT_KERNEL
#define BREAKPOINT		DbgBreakPoint();
#else
#define BREAKPOINT		__asm int 3
#endif

#else

#define BREAKPOINT

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\boards\generic\win32\Vdgendrv.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef VDGENDRV_H
#define VDGENDRV_H

#define ONLY_EXTERNAL_VISIBLE

#include "library\common\prelude.h"

class GenericHook;


extern "C" {
DLLCALL	void	WINAPI VDR_RegisterCallback(GenericHook * hook);
DLLCALL	void	WINAPI VDR_UnregisterCallback(GenericHook * hook);
#define H20_RegisterCallback	VDR_RegisterCallback
}


#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"
#include "library\common\winports.h"

#include "library\hardware\videodma\generic\pip.h"

#include "library\hardware\video\generic\vidchip.h"


#include "library\hardware\video\generic\videnc.h"

#include "library\hardware\mpeg2dec\generic\mpeg2dec.h"
#ifndef NO_INTERNAL_INCLUDE
#include "library\hardware\mpeg2dec\generic\mp2dcryp.h"
#endif

#if BOARD_HAS_MPEG2_ENCODER
#include "library\hardware\mpeg2enc\generic\mpeg2enc.h"
#endif



typedef class __far UnitSetClass __far *UnitSet;
typedef class __far VDRHandleClass __far *VDRHandle;

extern "C" {

DLLCALL void VDR_ServiceProcess(void);

DLLCALL Error WINAPI VDR_OpenDriver(TCHAR * name, DWORD boardID, VDRHandle __far & handle);
DLLCALL Error WINAPI VDR_CloseDriver(VDRHandle handle);

DLLCALL DWORD WINAPI VDR_AvailUnits(VDRHandle handle);

DLLCALL Error WINAPI VDR_ReconfigureDriver(VDRHandle handle);

DLLCALL Error WINAPI VDR_OpenUnits(VDRHandle handle, DWORD requnits, UnitSet &units);
DLLCALL Error WINAPI VDR_OpenSubUnits(UnitSet parent, DWORD requnits, UnitSet &units);
DLLCALL Error WINAPI VDR_CloseUnits(UnitSet units);


DLLCALL Error WINAPI VDR_ConfigureUnits(UnitSet units, TAG * tags);
inline Error __cdecl VDR_ConfigureUnitsTags(UnitSet units, TAG tags, ...) {return VDR_ConfigureUnits(units, &tags);}

DLLCALL Error WINAPI VDR_LockUnits(UnitSet units);
DLLCALL Error WINAPI VDR_UnlockUnits(UnitSet units);
DLLCALL Error WINAPI VDR_ActivateUnits(UnitSet units);
DLLCALL Error WINAPI VDR_PassivateUnits(UnitSet units);


DLLCALL Error WINAPI VDR_EnablePIP(UnitSet units, BOOL enable);
DLLCALL Error WINAPI VDR_UpdatePIP(UnitSet units);
DLLCALL Error WINAPI VDR_GrabFrame(UnitSet units, FPTR base,
                                   WORD width, WORD height,
                                   WORD stride,
                                   GrabFormat fmt);

DLLCALL Error WINAPI VDR_OptimizeBuffer(UnitSet units, WORD __far & minPixVal);


//
// MPEG Functions
//
DLLCALL DWORD	WINAPI VDR_SendMPEGData(UnitSet units, HPTR data, DWORD size);
DLLCALL void	WINAPI VDR_CompleteMPEGData(UnitSet units);
DLLCALL DWORD	WINAPI VDR_SendMPEGDataMultiple(UnitSet units, MPEGDataSizePair * data, DWORD size);

DLLCALL DWORD	WINAPI VDR_SendMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType, HPTR data, DWORD size, LONG timeStamp);
DLLCALL void	WINAPI VDR_CompleteMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType);
DLLCALL DWORD  WINAPI VDR_SendMPEGDataSplitMultiple(UnitSet units, MPEGElementaryStreamType streamType, MPEGDataSizePair * data, DWORD size, int timeStamp);
DLLCALL void	WINAPI VDR_RestartMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType);

DLLCALL Error	WINAPI VDR_SendMPEGCommand(UnitSet units, MPEGCommand com, long param, DWORD __far &tag);
DLLCALL Error	WINAPI VDR_DoMPEGCommand(UnitSet units, MPEGCommand com, long param);
DLLCALL Error	WINAPI VDR_CompleteMPEGCommand(UnitSet units, DWORD tag);
DLLCALL BOOL	WINAPI VDR_MPEGCommandPending(UnitSet units, DWORD tag);

DLLCALL DWORD	WINAPI VDR_CurrentMPEGLocation(UnitSet units);
DLLCALL DWORD	WINAPI VDR_CurrentMPEGTransferLocation(UnitSet units);
DLLCALL MPEGState WINAPI VDR_CurrentMPEGState(UnitSet units);

DLLCALL Error	WINAPI VDR_InstallMPEGWinHooks(UnitSet units, HWND hwnd, WORD refillMsg, WORD signalMsg, WORD doneMsg);
DLLCALL Error	WINAPI VDR_RemoveMPEGWinHooks(UnitSet units);
DLLCALL Error	WINAPI VDR_CompleteMPEGRefillMessage(UnitSet units);

DLLCALL Error  WINAPI VDR_InstallMessagePort(UnitSet units, GenericMsgPort * port);
DLLCALL Error  WINAPI VDR_RemoveMessagePort(UnitSet units);

#ifndef NO_INTERNAL_INCLUDE
DLLCALL Error	WINAPI VDR_DoAuthenticationCommand(UnitSet units, MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);
DLLCALL BOOL	WINAPI VDR_CheckRegionCodeValid(UnitSet units, BYTE regionSet);
#endif


#if BOARD_HAS_MPEG2_ENCODER

DLLCALL Error  WINAPI VDR_DoCommand(UnitSet units, MPEGCommand com, long param);
DLLCALL Error	WINAPI VDR_PutBuffer(UnitSet units, HPTR data, DWORD size);
DLLCALL Error  WINAPI VDR_InstallMPEGTransferDoneHook(UnitSet units, HWND hwnd, WORD transferDoneMsg);
DLLCALL Error  WINAPI VDR_RemoveMPEGTransferDoneHook(UnitSet units);
DLLCALL Error  WINAPI VDR_InstallMPEGEncoderBufferStarvingHook(UnitSet units, HWND hwnd, WORD bufferStarvingMsg);
DLLCALL Error  WINAPI VDR_RemoveMPEGEncoderBufferStarvingHook(UnitSet units);

#endif



	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\DDPWin.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DDP Layer Include File For Win32
//
////////////////////////////////////////////////////////////////////

#ifndef DDPWIN_H
#define DDPWIN_H

#include "driver/dvdpldrv/Common/dvdpld32.h"
#include "boards/generic/vdgendrv.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\DDPST20.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DDP Layer Include File For ST20LITE
//
////////////////////////////////////////////////////////////////////

#ifndef DDPST20_H
#define DDPST20_H

////////////////////////////////////////////////////////////////////
//
//  Includes
//
////////////////////////////////////////////////////////////////////

#include "driver/dvdpldrv/Common/dvdpld32.h"
#include "boards/generic/vdgendrv.h"

////////////////////////////////////////////////////////////////////
//
//  Function Declarations
//
////////////////////////////////////////////////////////////////////

Error DDP_Initialize(GenericProfile * profile);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\DiskPlayerFactory.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Disk Player Factory Classes
//
////////////////////////////////////////////////////////////////////

#include "DiskPlayerFactory.h"

////////////////////////////////////////////////////////////////////
//
//  DVDDiskPlayer Factory Classes
//
////////////////////////////////////////////////////////////////////

//
//  Base Class
//

Error DVDDiskPlayerFactory::CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile,
															DVDDiskType diskType, DVDFileSystem * dvdfs, BYTE region,
															CDDiskPlayerClass * & player)
	{
	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}

Error DVDDiskPlayerFactory::CreateDVDDisk(DVDDisk * & dvdDisk)
	{
	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}

////////////////////////////////////////////////////////////////////
//
//  VCDDiskPlayer Factory
//
////////////////////////////////////////////////////////////////////

//
//  Base Class
//

Error VCDDiskPlayerFactory::CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile,
															DVDDiskType diskType, VCDFileSystem * vcdfs, CDDiskPlayerClass * & player)
	{
	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}

////////////////////////////////////////////////////////////////////
//
//  CDDADiskPlayer Factory
//
////////////////////////////////////////////////////////////////////

//
//  Base Class
//

Error CDDADiskPlayerFactory::CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile,
															 DVDDiskType diskType, CDDAFileSystem * cddafs, CDDiskPlayerClass * & player)
	{
	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}

////////////////////////////////////////////////////////////////////
//
//  AVFDiskPlayer Factory
//
////////////////////////////////////////////////////////////////////

//
//  Base Class
//

Error AVFDiskPlayerFactory::CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile,
															DVDDiskType diskType, GenericFileSystem * gfs, CDDiskPlayerClass * & player)
	{
	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}

Error AVFDiskPlayerFactory::CreateMP3Player(WinPortServer * server, GenericProfile * profile, DVDDiskType diskType,
														  GenericFileSystem * gfs)
	{
	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\DDPXBox.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVDPLD32: Entry Point For XBox
//
////////////////////////////////////////////////////////////////////

#include "driver/dvdpldrv/common/dvdpld32.h"
#include "library/common/profiles.h"
#include "library/hardware/drives/generic/drivetable.h"

////////////////////////////////////////////////////////////////////
//
//  Helper Functions
//
////////////////////////////////////////////////////////////////////
//
// Tells us what kind of entry it is
//

enum SetupEntryType
	{
	SET_VALUE,
	SET_SECTION,
	SET_END
	};

//
// One entry of the setup array
//

struct SetupEntry
	{
	char				* name;
	SetupEntryType	type;
	DWORD				value;
	};


static SetupEntry config[] =
	{
		{"$", SET_SECTION, 0},

			{"DRIVE", SET_SECTION, 0},
			{"", SET_END, 0},

		{"", SET_END, 0},
	};

static DWORD CalculateID(BOOL section, KernelString name)
	{
	DWORD temp = 0;

	if (name.Length() > 0)
		{
		for (int i = 0; i < name.Length(); i++)
			{
			temp ^= name[i];
			temp = (temp << 3) | (temp >> 29);	// The first 10 characters count
			}

		return (section ? (temp |= 1) : (temp &= ~1));
		}
	else
		return 0;
	}

//
//  Parse Setup
//

static void ParseSetup(SetupEntry * & sentry, ProfileEntry * pentry, int & num)
	{
	int snum;

	num = 0;
	pentry->id = CalculateID(TRUE, sentry->name);
	num++;
	sentry++;
	while (sentry->type != SET_END)
		{
		if (sentry->type == SET_VALUE)
			{
			pentry[num].id = CalculateID(FALSE, sentry->name);
			pentry[num].value = sentry->value;
			num++;
			sentry++;
			}
		else
			{
			ParseSetup(sentry, pentry + num, snum);
			num += snum;
			}
		}
	pentry->value = num;

	sentry++;
	}

////////////////////////////////////////////////////////////////////
//
//  DDP_Initialize
//
////////////////////////////////////////////////////////////////////

DLLCALL Error WINAPI DDP_Initialize(void)
	{
	GenericProfile * profile;
	DriveTable * driveTable;
	int num;
	Error err;

	static ProfileEntry	pentry[200];

	SetupEntry	*	se = config;

	ParseSetup(se, pentry, num);

	profile = new StaticProfile(pentry);

	if (!profile)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	driveTable = new W2KDriveTable();
	if (IS_ERROR(err = driveTable->Init(profile)))
		{
		delete driveTable;
		driveTable = NULL;
		GNRAISE(err);
		}

	//
	//  Perform general initializations
	//

	GNREASSERT(DDP_Init(new WinPortServer(), profile, driveTable,
							  new DVDVideoDiskPlayerFactory(),
							  new DVDAudioDiskPlayerFactory(),
							  new VCDDiskPlayerFactory(),
							  new CDDADiskPlayerFactory(),
							  new AVFDiskPlayerFactory(),
							  new DVDFileSystemFactory(),
							  new FileSystemFactory(),
							  new FileSystemFactory(),
							  new FileSystemFactory(),
							  new FileSystemFactory()));

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\DDPWin.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVDPLD32: Entry Point For Win32
//
////////////////////////////////////////////////////////////////////

//#include "DDPWin.h"
#include "driver/dvdpldrv/Common/dvdpld32.h"
#include "VCDDiskPlayerFactory.h"
#include "AVFDiskPlayerFactory.h"
#include "CDDADiskPlayerFactory.h"
#include "AVFFileSystemFactory.h"
#include "CDDAFileSystemFactory.h"

////////////////////////////////////////////////////////////////////
//
//  DllMain Function
//
////////////////////////////////////////////////////////////////////

extern "C" {

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
	{
	switch (fdwReason)
		{
		case DLL_PROCESS_ATTACH:
			{
			WinPortServer * server;
			GenericProfile * profile;
			DriveTable * driveTable;
			Error err;

//			_CrtSetBreakAlloc(116);

			profile = new Profile("RAVISENT", "DVD Navigation Driver", "3.0");
			server = new WinPortServer(hDLLInst);
			if (!profile || !server)
				{
				DP("Could not create Profile or WinPortServer!");
				return FALSE;
				}

			//
			//  Create drive table
			//

			driveTable = new Win9xDriveTable();
			if (!driveTable)
				{
				DP("Not enough memory for Win9x drive table");
				return FALSE;
				}

			if (IS_ERROR(err = driveTable->Init(profile)))
				{
				delete driveTable;

				driveTable = new W2KDriveTable();
				if (!driveTable)
					{
					DP("Not enough memory for W2K drive table");
					return FALSE;
					}

				if (IS_ERROR(err = driveTable->Init(profile)))
					{
					delete driveTable;
					return FALSE;
					}
				}

			//
			//  Perform general initializations
			//

			if (IS_ERROR(DDP_Init(server, profile, driveTable,
										 new DVDVideoDiskPlayerFactory(),
										 new DVDAudioDiskPlayerFactory(),
										 new FullVCDDiskPlayerFactory(),
										 new FullCDDADiskPlayerFactory(),
										 new FullAVFDiskPlayerFactory(),
										 new DVDFileSystemFactory(),
										 new VCDFileSystemFactory(),
										 new CDDAFileSystemFactory(),
										 new AVFFileSystemFactory(),
										 new FileSystemFactory())))
				return FALSE;

			break;
			}
		case DLL_PROCESS_DETACH:

			DDP_Cleanup();

#if DUMPOBJECTS
			_CrtDumpMemoryLeaks();
//			_CrtMemDumpAllObjectsSince(&memstate );
#endif
			break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_THREAD_DETACH:
			break;
		}

	return TRUE;
	}

}	// extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\DDPXBox.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DDP Layer Include File For XBox
//
////////////////////////////////////////////////////////////////////

#ifndef DDPXBOX_H
#define DDPXBOX_H

#include "boards/generic/vdgendrv.h"
#include "driver/dvdpldrv/Common/dvdpld32.h"

////////////////////////////////////////////////////////////////////
//
//  Function Declarations
//
////////////////////////////////////////////////////////////////////

Error WINAPI DDP_Initialize(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\DiskPlayerFactory.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Disk Player Factory Classes
//
////////////////////////////////////////////////////////////////////

#ifndef DISKPLAYERFACTORY_H
#define DISKPLAYERFACTORY_H

class DVDDiskPlayerFactory;
class VCDDiskPlayerFactory;
class CDDADiskPlayerFactory;
class AVFDiskPlayerFactory;

class DVDFileSystem;
class VCDFileSystem;
class CDDAFileSystem;

class DVDDisk;
class DVDGenericCPBI;
#include "driver/dvdpldrv/Common/CDDiskPlayer.h"

#include "boards/generic/vdgendrv.h"

////////////////////////////////////////////////////////////////////
//
//  DVDDiskPlayer Factory Classes
//
////////////////////////////////////////////////////////////////////

//
//  Base class that only returns errors
//

class DVDDiskPlayerFactory
	{
	public:
		virtual Error CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile, DVDDiskType type,
												 DVDFileSystem * dvdfs, BYTE region, CDDiskPlayerClass * & player);
		virtual Error CreateDVDDisk(DVDDisk * & dvdDisk);
	};

////////////////////////////////////////////////////////////////////
//
//  VCDDiskPlayer Factory
//
////////////////////////////////////////////////////////////////////

//
//  Base class that only returns errors
//

class VCDDiskPlayerFactory
	{
	public:
		virtual Error CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile, DVDDiskType type,
												 VCDFileSystem * vcdfs, CDDiskPlayerClass * & player);
	};

////////////////////////////////////////////////////////////////////
//
//  CDDADiskPlayer Factory
//
////////////////////////////////////////////////////////////////////

//
//  Base class that only returns errors
//

class CDDADiskPlayerFactory
	{
	public:
		virtual Error CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile, DVDDiskType type,
												 CDDAFileSystem * cddafs, CDDiskPlayerClass * & player);
	};

////////////////////////////////////////////////////////////////////
//
//  AVFDiskPlayer Factory
//
////////////////////////////////////////////////////////////////////

//
//  Base class that only returns errors
//

class AVFDiskPlayerFactory
	{
	public:
		virtual Error CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile, DVDDiskType type,
												 GenericFileSystem * gfs, CDDiskPlayerClass * & player);
		virtual Error CreateMP3Player(WinPortServer * server, GenericProfile * profile, DVDDiskType type, GenericFileSystem * gfs);
	};

//
//  Further AVF factories that only create subsets of all supported file types should be created here!!!
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\DVDDiskPlayerFactory.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "DVDDiskPlayerFactory.h"
#include "driver/dvdpldrv/Common/DVDDiskPlayer.h"

//
//  Common DVD Disk Player Factory
//

Error DVDDiskPlayerFactoryCommon::CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile,
																	DVDDiskType diskType, DVDFileSystem * dvdfs, BYTE region,
																	CDDiskPlayerClass * & player)
	{
	Error err;

	//
	//  Create Disk Player
	//

	player = new DVDDiskPlayerClass(server, units, this);
	if (!player)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	//
	//  Initialize player
	//

	if (IS_ERROR(err = ((DVDDiskPlayerClass*)player)->Init(server, profile, diskType, dvdfs, region)))
		delete player;

	GNRAISE(err);
	}

//
//  DVD Video Player Factory
//

Error DVDVideoDiskPlayerFactory::CreateDVDDisk(DVDDisk * & dvdDisk)
	{
	dvdDisk = new DVDVideoDisk(this);
	if (dvdDisk)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  DVD Audio Player Factory
//

Error DVDAudioDiskPlayerFactory::CreateDVDDisk(DVDDisk * & dvdDisk)
	{
	dvdDisk = new DVDAudioDisk(this);
	if (dvdDisk)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\DVDDiskPlayerFactory.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef DVDDISKPLAYERFACTORY_H
#define DVDDISKPLAYERFACTORY_H

#include "DiskPlayerFactory.h"

//
//  This one collects common things of Video/Audio DVD. It should not be instantiated, only its derived classes.
//

class DVDDiskPlayerFactoryCommon : public DVDDiskPlayerFactory
	{
	public:
		virtual Error CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile, DVDDiskType type,
												 DVDFileSystem * dvdfs, BYTE region, CDDiskPlayerClass * & player);
	};

//
//  DVD Video Disk Player Factory
//

class DVDVideoDiskPlayerFactory : public DVDDiskPlayerFactoryCommon
	{
	public:
		virtual Error CreateDVDDisk(DVDDisk * & dvdDisk);
	};

//
//  DVD Audio Disk Player Factory
//

class DVDAudioDiskPlayerFactory : public DVDDiskPlayerFactoryCommon
	{
	public:
		virtual Error CreateDVDDisk(DVDDisk * & dvdDisk);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\VCDDiskPlayerFactory.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "VCDDiskPlayerFactory.h"
#include "driver/dvdpldrv/Common/VCDDiskPlayer.h"

//
//  Real Factory
//

Error FullVCDDiskPlayerFactory::CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile,
																 DVDDiskType diskType, VCDFileSystem * vcdfs, CDDiskPlayerClass * & player)
	{
	Error err;

	//
	//  Create Disk Player
	//

	player = new VCDDiskPlayerClass(server, units);
	if (!player)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	//
	//  Initialize player
	//

	if (IS_ERROR(err = ((VCDDiskPlayerClass*)player)->Init(server, profile, diskType, vcdfs)))
		delete player;

	GNRAISE(err);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\FileSystemFactory.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  File System Factories
//
////////////////////////////////////////////////////////////////////

#ifndef FILESYSTEMFACTORY_H
#define FILESYSTEMFACTORY_H

#include "driver/dvdpldrv/Common/DVDFile.h"

class FileSystemFactory
	{
	public:
		virtual Error CreateFileSystem(RootIterator * rit, GenericProfile * profile, GenericFileSystem * & gfs);
	};

class DVDFileSystemFactory : public FileSystemFactory
	{
	public:
		virtual Error CreateFileSystem(RootIterator * rit, GenericProfile * profile, GenericFileSystem * & gfs);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\FileSystemFactory.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Operating System Specific File System Factories
//
////////////////////////////////////////////////////////////////////

#include "FileSystemFactory.h"

////////////////////////////////////////////////////////////////////
//
//  Base Class For File System Factories
//
////////////////////////////////////////////////////////////////////

//
//  Default implementation
//

Error FileSystemFactory::CreateFileSystem(RootIterator * rit, GenericProfile * profile, GenericFileSystem * & gfs)
	{

	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}

//
//  DVD File System Factory
//

Error DVDFileSystemFactory::CreateFileSystem(RootIterator * rit, GenericProfile * profile, GenericFileSystem * & gfs)
	{
	Error err;

	gfs = new DVDFileSystem(NULL); //Remember to set EventDispatcher for this file system (here we have to pass NULL)
	if (!gfs)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	if (IS_ERROR(err = gfs->Init(rit, NULL, profile)))
		delete gfs;

	GNRAISE(err);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\WinNavi.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVDPLD32: Entry Point For Win32
//
////////////////////////////////////////////////////////////////////

#include "driver/dvdpldrv/Common/dvdpld32.h"
#include "library/hardware/drives/generic/DriveTable.h"
#include "DiskPlayerFactory.h"

extern "C" {

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
	{
	WinPortServer * winPortServer;
	GenericProfile * profile;
	DWORD dd;
	Error err;

	switch (fdwReason)
		{
		case DLL_PROCESS_ATTACH:
//			_CrtSetBreakAlloc(116);

			profile = new Profile("RAVISENT", "DVD Navigation Driver", "3.0");
			winPortServer = new WinPortServer(hDLLInst);
			if (!profile || !winPortServer)
				{
				DP("Could not create Profile or WinPortServer!");
				return FALSE;
				}

			//
			//  Create drive table
			//

			driveTable = new Win9xDriveTable();
			if (!driveTable)
				{
				DP("Not enough memory for Win9x drive table");
				return FALSE;
				}

			if (IS_ERROR(err = driveTable->Init(profile)))
				{
				delete driveTable;

				driveTable = new W2KDriveTable();
				if (!driveTable)
					{
					DP("Not enough memory for W2K drive table");
					return FALSE;
					}

				if (IS_ERROR(err = driveTable->Init(profile)))
					{
					delete driveTable;
					return FALSE;
					}
				}

			//
			//  Perform general initializations
			//

			if (IS_ERROR(DDP_Init(winPortServer, profile, driveTable,
										 new DVDVideoDiskPlayerFactory(),
										 new DVDAudioDiskPlayerFactory(),
										 new VCDDiskPlayerFactory(),
										 new CDDADiskPlayerFactory(),
										 new AVFDiskPlayerFactory(),
										 new OSFileSystemFactory())))
				return FALSE;

			//
			//  Set up threads
			//

			DDPScheduleThread = CreateThread(NULL, 10000, DDPScheduleRoutine, NULL, CREATE_SUSPENDED, &dd);
			SetThreadPriority(DDPScheduleThread, THREAD_PRIORITY_HIGHEST);
			ResumeThread(DDPScheduleThread);

			break;

		case DLL_PROCESS_DETACH:

			DDP_Cleanup();

#if DUMPOBJECTS
			_CrtDumpMemoryLeaks();
//			_CrtMemDumpAllObjectsSince(&memstate );
#endif
			break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_THREAD_DETACH:
			break;
		}

	return TRUE;
	}

}	// extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\XBoxNavi.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVDPLD32: Entry Point For XBox
//
////////////////////////////////////////////////////////////////////

extern "C" {

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
	{
	WinPortServer * winPortServer;
	GenericProfile profile;
	DWORD dd;
	Error err;

	switch (fdwReason)
		{
		case DLL_PROCESS_ATTACH:
//			_CrtSetBreakAlloc(116);

			profile = new Profile("RAVISENT", "DVD Navigation Driver", "3.0");
			winPortServer = new WinPortServer(hDLLInst);
			if (!profile || !winPortServer)
				{
				DP("Could not create Profile or WinPortServer!");
				return FALSE;
				}

			//
			//  Create drive table
			//

			driveTable = new W2KDriveTable();
			if (!driveTable)
				{
				DP("Not enough memory for W2K drive table");
				return FALSE;
				}

			if (IS_ERROR(err = driveTable->Init(profile)))
				{
				delete driveTable;
				return FALSE;
				}

			//
			//  Perform general initializations
			//

			if (IS_ERROR(Initialize(winPortServer, profile, driveTable,
											new DVDVideoDiskPlayerFactory(),
											new DVDAudioDiskPlayerFactory(),
											new VCDDiskPlayerFactory(),
											new CDDADiskPlayerFactory(),
											new AVFDiskPlayerFactory(),
											new WinFileSystemFactory())))
				return FALSE;

			//
			//  Set up threads
			//

			DDPScheduleThread = CreateThread(NULL, 10000, DDPScheduleRoutine, NULL, CREATE_SUSPENDED, &dd);
			SetThreadPriority(DDPScheduleThread, THREAD_PRIORITY_HIGHEST);
			ResumeThread(DDPScheduleThread);

			break;

		case DLL_PROCESS_DETACH:

			delete DriverInstance;

#if DUMPOBJECTS
			_CrtDumpMemoryLeaks();
//			_CrtMemDumpAllObjectsSince(&memstate );
#endif
			break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_THREAD_DETACH:
			break;
		}

	return TRUE;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\VCDDiskPlayerFactory.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef VCDDISKPLAYERFACTORY_H
#define VCDDISKPLAYERFACTORY_H

#include "DiskPlayerFactory.h"

class FullVCDDiskPlayerFactory : public VCDDiskPlayerFactory
	{
	public:
		virtual Error CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile, DVDDiskType type,
												 VCDFileSystem * vcdfs, CDDiskPlayerClass * & player);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\Config\WinNavi.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\ATHLONMacros.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// ************************************************************************************
// *
// *	AMD ATHLON 3dNow! INSTRUCTION EXTENSION MACROS
// *
// *	FILE:			ATHLONMacros.h
// *	CONTEXT:		header file containing preprocessor macros for ATHLON (K7)
// *	PURPOSE:		preprocessor macros for generation of ISSE instructions
// *	START:		Friday, 23. July 1999
// *
// *	AUTHOR:		Roland Schaufler
// *	COPYRIGHT:	VIONA Development GmbH
// *
// ************************************************************************************
//
// THIS FILE IS COPYRIGHT OF VIONA DEVELOPMENT GMBH AND IS NOT LICENSED TO THE PUBLIC
// use amd 3d-now! macro file instead.
//
// This file depends on the file "MMXExtensionMacros.h" and will not compile without it.
// All register definitions are missing here...
//
// As it is not possible to overload a macro and to use it with different parameters
// every single addressing mode which is needed has to be "hard-coded". The convention used
// herefore is the following:
//
// instruction			meaning
// Suffix
// -------------------------------------------------------
// --						reg, reg
// MEM					reg, [base]
// IMM8					reg, [base + immediate8]  (this one is not used)
//	IMM32					reg, [base + immediate32] (this one is used rather!)
// SIB					reg, [base + scale*index]
//	STR					[base], reg  (memory store)
//
// explicite store or load instructions contain no extra suffixes
//

#include "MMXExtensionMacros.h"

#ifndef ATHLON_MACROS_H
#define ATHLON_MACROS_H

//////////////////////////////////////////////////////////////////////////////////////////////
// Macros only for use within other Macros
//////////////////////////////////////////////////////////////////////////////////////////////


// AMD 3D-NOW instructions all start with 0x0F 0x0F code!!
#define TDNSTART	_asm _emit 0x0F _asm _emit 0x0F _asm _emit


// define bodies for macros
#define TDNBLOCK(opcode, mod, rm, dest)									\
	}																					\
   TDNSTART																			\
	MODRMBYTE(mod, rm, dest)													\
	_asm _emit opcode																\
	_asm																				\
		{

#define TDNBLOCKIMM8(opcode, mod, rm, dest, imm8)						\
	}																					\
   TDNSTART																			\
	MODRMBYTE(mod, rm, dest)													\
	_asm _emit imm8																\
	_asm _emit opcode																\
	_asm																				\
		{

#define TDNBLOCKIMM32(opcode, mod, rm, dest, imm32)					\
	}																					\
   TDNSTART																			\
	MODRMBYTE(mod, rm, dest)													\
	_asm _emit BYTE0(imm32)														\
	_asm _emit BYTE1(imm32)														\
	_asm _emit BYTE2(imm32)														\
	_asm _emit BYTE3(imm32)														\
	_asm _emit opcode																\
	_asm																				\
		{

//////////////////////////////////////////////////////////////////////////////////////////////

#define TDNBLOCKSIB(opcode, mod, rm, dest, scale, index, base)		\
	}																					\
   TDNSTART																			\
	MODRMBYTE(mod, rm, dest)													\
	_asm _emit SIBBYTE(scale, index, base)									\
	_asm _emit opcode																\
	_asm																				\
		{

#define TDNBLOCKSIBIMM8(opc, mod, rm, dest, scal, ind, bas, imm8)	\
	}																					\
   TDNSTART																			\
	MODRMBYTE(mod, rm, dest)													\
	_asm _emit SIBBYTE(scal, ind, bas)										\
	_asm _emit imm8																\
	_asm _emit opc																	\
	_asm																				\
		{

#define TDNBLOCKSIBIMM32(opc, mod, rm, dest, scale, ind, base)		\
	}																					\
   TDNSTART																			\
	MODRMBYTE(mod, rm, dest)													\
	_asm _emit SIBBYTE(scale, ind, base)									\
	_asm _emit BYTE0(imm32)														\
	_asm _emit BYTE1(imm32)														\
	_asm _emit BYTE2(imm32)														\
	_asm _emit BYTE3(imm32)														\
	_asm _emit opc																	\
	_asm																				\
		{


//////////////////////////////////////////////////////////////////////////////////////////////
// ATHLON NEW INSTRUCTIONS
//////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////
// **** REGISTER to REGISTER
//////////////////////////////////////////////////////////////////////////////////////////////

// standard 3D-now
#define pavgusb(dest,src)					TDNBLOCK(0xBF, reg, src, dest)
#define pf2id(dest,src)						TDNBLOCK(0x1D, reg, src, dest)
#define pfacc(dest,src)						TDNBLOCK(0xAE, reg, src, dest)
#define pfadd(dest,src)						TDNBLOCK(0x9E, reg, src, dest)
#define pfcmpeq(dest,src)					TDNBLOCK(0xB0, reg, src, dest)
#define pfcmpge(dest,src)					TDNBLOCK(0x90, reg, src, dest)
#define pfcmpgt(dest,src)					TDNBLOCK(0xA0, reg, src, dest)
#define pfmax(dest,src)						TDNBLOCK(0xA4, reg, src, dest)
#define pfmin(dest,src)						TDNBLOCK(0x94, reg, src, dest)
#define pfmul(dest,src)						TDNBLOCK(0xB4, reg, src, dest)
#define pfrcp(dest,src)						TDNBLOCK(0x96, reg, src, dest)
#define pfrcpit1(dest,src)					TDNBLOCK(0xA6, reg, src, dest)
#define pfrcpit2(dest,src)					TDNBLOCK(0xB6, reg, src, dest)
#define pfrsqit1(dest,src)					TDNBLOCK(0xA7, reg, src, dest)
#define pfrsqrt(dest,src)					TDNBLOCK(0x97, reg, src, dest)
#define pfsub(dest,src)						TDNBLOCK(0x9A, reg, src, dest)
#define pfsubr(dest,src)					TDNBLOCK(0xAA, reg, src, dest)
#define pi2fd(dest,src)						TDNBLOCK(0x0D, reg, src, dest)
#define pmulhrw(dest,src)					TDNBLOCK(0xB7, reg, src, dest)

#define femms									} _asm _emit 0x0F _asm _emit 0x0E _asm {

// NEW ATHLON 3D-now
#define pf2iw(dest,src)						TDNBLOCK(0x1C, reg, src, dest)
#define pfnacc(dest, src)					TDNBLOCK(0x8A, reg, src, dest)
#define pfpnacc(dest, src)					TDNBLOCK(0x8E, reg, src, dest)
#define pi2fw(dest,src)						TDNBLOCK(0x0C, reg, src, dest)
#define pswapd(dest, src)					TDNBLOCK(0xBB, reg, src, dest)

//////////////////////////////////////////////////////////////////////////////////////////////
// **** MEMORY to REGISTER
//////////////////////////////////////////////////////////////////////////////////////////////

// standard 3D-now
#define pavgusbMEM(dest,src)					TDNBLOCK(0xBF, none, src, dest)
#define pf2idMEM(dest,src)						TDNBLOCK(0x1D, none, src, dest)
#define pfaccMEM(dest,src)						TDNBLOCK(0xAE, none, src, dest)
#define pfaddMEM(dest,src)						TDNBLOCK(0x9E, none, src, dest)
#define pfcmpeqMEM(dest,src)					TDNBLOCK(0xB0, none, src, dest)
#define pfcmpgeMEM(dest,src)					TDNBLOCK(0x90, none, src, dest)
#define pfcmpgtMEM(dest,src)					TDNBLOCK(0xA0, none, src, dest)
#define pfmaxMEM(dest,src)						TDNBLOCK(0xA4, none, src, dest)
#define pfminMEM(dest,src)						TDNBLOCK(0x94, none, src, dest)
#define pfmulMEM(dest,src)						TDNBLOCK(0xB4, none, src, dest)
#define pfrcpMEM(dest,src)						TDNBLOCK(0x96, none, src, dest)
#define pfrcpit1MEM(dest,src)					TDNBLOCK(0xA6, none, src, dest)
#define pfrcpit2MEM(dest,src)					TDNBLOCK(0xB6, none, src, dest)
#define pfrsqit1MEM(dest,src)					TDNBLOCK(0xA7, none, src, dest)
#define pfrsqrtMEM(dest,src)					TDNBLOCK(0x97, none, src, dest)
#define pfsubMEM(dest,src)						TDNBLOCK(0x9A, none, src, dest)
#define pfsubrMEM(dest,src)					TDNBLOCK(0xAA, none, src, dest)
#define pi2fdMEM(dest,src)						TDNBLOCK(0x0D, none, src, dest)
#define pmulhrwMEM(dest,src)					TDNBLOCK(0xB7, none, src, dest)

// NEW ATHLON 3D-now
#define pf2iwMEM(dest,src)						TDNBLOCK(0x1C, none, src, dest)
#define pfnaccMEM(dest, src)					TDNBLOCK(0x8A, none, src, dest)
#define pfpnaccMEM(dest, src)					TDNBLOCK(0x8E, none, src, dest)
#define pi2fwMEM(dest,src)						TDNBLOCK(0x0C, none, src, dest)
#define pswapdMEM(dest, src)					TDNBLOCK(0x0B, none, src, dest)



//////////////////////////////////////////////////////////////////////////////////////////////
// **** MEMORY to REGISTER plus IMMEDIATE8
//////////////////////////////////////////////////////////////////////////////////////////////

// standard 3D-now
#define pavgusbIMM08(dest,src, imm8)	TDNBLOCKIMM8(0xBF, disp8, src, dest, imm8)
#define pf2idIMM08(dest,src, imm8)		TDNBLOCKIMM8(0x1D, disp8, src, dest, imm8)
#define pfaccIMM08(dest,src, imm8)		TDNBLOCKIMM8(0xAE, disp8, src, dest, imm8)
#define pfaddIMM08(dest,src, imm8)		TDNBLOCKIMM8(0x9E, disp8, src, dest, imm8)
#define pfcmpeqIMM08(dest,src, imm8)	TDNBLOCKIMM8(0xB0, disp8, src, dest, imm8)
#define pfcmpgeIMM08(dest,src, imm8)	TDNBLOCKIMM8(0x90, disp8, src, dest, imm8)
#define pfcmpgtIMM08(dest,src, imm8)	TDNBLOCKIMM8(0xA0, disp8, src, dest, imm8)
#define pfmaxIMM08(dest,src, imm8)		TDNBLOCKIMM8(0xA4, disp8, src, dest, imm8)
#define pfminIMM08(dest,src, imm8)		TDNBLOCKIMM8(0x94, disp8, src, dest, imm8)
#define pfmulIMM08(dest,src, imm8)		TDNBLOCKIMM8(0xB4, disp8, src, dest, imm8)
#define pfrcpIMM08(dest,src, imm8)		TDNBLOCKIMM8(0x96, disp8, src, dest, imm8)
#define pfrcpit1IMM08(dest,src, imm8)	TDNBLOCKIMM8(0xA6, disp8, src, dest, imm8)
#define pfrcpit2IMM08(dest,src, imm8)	TDNBLOCKIMM8(0xB6, disp8, src, dest, imm8)
#define pfrsqit1IMM08(dest,src, imm8)	TDNBLOCKIMM8(0xA7, disp8, src, dest, imm8)
#define pfrsqrtIMM08(dest,src, imm8)	TDNBLOCKIMM8(0x97, disp8, src, dest, imm8)
#define pfsubIMM08(dest,src, imm8)		TDNBLOCKIMM8(0x9A, disp8, src, dest, imm8)
#define pfsubrIMM08(dest,src, imm8)		TDNBLOCKIMM8(0xAA, disp8, src, dest, imm8)
#define pi2fdIMM08(dest,src, imm8)		TDNBLOCKIMM8(0x0D, disp8, src, dest, imm8)
#define pmulhrwIMM08(dest,src, imm8)	TDNBLOCKIMM8(0xB7, disp8, src, dest, imm8)

// NEW ATHLON 3D-now
#define pf2iwIMM08(dest,src, imm8)		TDNBLOCKIMM8(0x1C, disp8, src, dest, imm8)
#define pfnaccIMM08(dest, src, imm8)	TDNBLOCKIMM8(0x8A, disp8, src, dest, imm8)
#define pfpnaccIMM08(dest, src, imm8)	TDNBLOCKIMM8(0x8E, disp8, src, dest, imm8)
#define pi2fwIMM08(dest,src, imm8)		TDNBLOCKIMM8(0x0C, disp8, src, dest, imm8)
#define pswapdIMM08(dest, src, imm8)	TDNBLOCKIMM8(0x0B, disp8, src, dest, imm8)


//////////////////////////////////////////////////////////////////////////////////////////////
// **** MEMORY to REGISTER plus IMMEDIATE32
//////////////////////////////////////////////////////////////////////////////////////////////

// standard 3D-now
#define pavgusbIMM32(dest,src, imm32)		TDNBLOCKIMM32(0xBF, disp32, src, dest, imm32)
#define pf2idIMM32(dest,src, imm32)			TDNBLOCKIMM32(0x1D, disp32, src, dest, imm32)
#define pfaccIMM32(dest,src, imm32)			TDNBLOCKIMM32(0xAE, disp32, src, dest, imm32)
#define pfaddIMM32(dest,src, imm32)			TDNBLOCKIMM32(0x9E, disp32, src, dest, imm32)
#define pfcmpeqIMM32(dest,src, imm32)		TDNBLOCKIMM32(0xB0, disp32, src, dest, imm32)
#define pfcmpgeIMM32(dest,src, imm32)		TDNBLOCKIMM32(0x90, disp32, src, dest, imm32)
#define pfcmpgtIMM32(dest,src, imm32)		TDNBLOCKIMM32(0xA0, disp32, src, dest, imm32)
#define pfmaxIMM32(dest,src, imm32)			TDNBLOCKIMM32(0xA4, disp32, src, dest, imm32)
#define pfminIMM32(dest,src, imm32)			TDNBLOCKIMM32(0x94, disp32, src, dest, imm32)
#define pfmulIMM32(dest,src, imm32)			TDNBLOCKIMM32(0xB4, disp32, src, dest, imm32)
#define pfrcpIMM32(dest,src, imm32)			TDNBLOCKIMM32(0x96, disp32, src, dest, imm32)
#define pfrcpit1IMM32(dest,src, imm32)		TDNBLOCKIMM32(0xA6, disp32, src, dest, imm32)
#define pfrcpit2IMM32(dest,src, imm32)		TDNBLOCKIMM32(0xB6, disp32, src, dest, imm32)
#define pfrsqit1IMM32(dest,src, imm32)		TDNBLOCKIMM32(0xA7, disp32, src, dest, imm32)
#define pfrsqrtIMM32(dest,src, imm32)		TDNBLOCKIMM32(0x97, disp32, src, dest, imm32)
#define pfsubIMM32(dest,src, imm32)			TDNBLOCKIMM32(0x9A, disp32, src, dest, imm32)
#define pfsubrIMM32(dest,src, imm32)		TDNBLOCKIMM32(0xAA, disp32, src, dest, imm32)
#define pi2fdIMM32(dest,src, imm32)			TDNBLOCKIMM32(0x0D, disp32, src, dest, imm32)
#define pmulhrwIMM32(dest,src, imm32)		TDNBLOCKIMM32(0xB7, disp32, src, dest, imm32)

// NEW ATHLON 3D-now
#define pf2iwIMM32(dest,src, imm32)			TDNBLOCKIMM32(0x1C, disp32, src, dest, imm32)
#define pfnaccIMM32(dest, src, imm32)		TDNBLOCKIMM32(0x8A, disp32, src, dest, imm32)
#define pfpnaccIMM32(dest, src, imm32)		TDNBLOCKIMM32(0x8E, disp32, src, dest, imm32)
#define pi2fwIMM32(dest,src, imm32)			TDNBLOCKIMM32(0x0C, disp32, src, dest, imm32)
#define pswapdIMM32(dest, src, imm32)		TDNBLOCKIMM32(0x0B, disp32, src, dest, imm32)


//////////////////////////////////////////////////////////////////////////////////////////////
// **** COMPLEX INDEX VERSIONS ****
//////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////
// **** MEMORY+SCALED*MEMORY to REGISTER
//////////////////////////////////////////////////////////////////////////////////////////////
#define pfmulSIB(dest, scale, index, base)		TDNBLOCKSIB(0xB4, none, SIB, dest, scale, index, base)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\DIALOG.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\common\dialog.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   09.05.95
//
// PURPOSE: The base class for requesters.
//
// HISTORY:

#ifndef DIALOG_H
#define DIALOG_H

#include <windows.h>
#include <commdlg.h>
#include "library\common\prelude.h"
#include "library\common\gnerrors.h"



class Slider
	{
	friend class Dialog;

	private:
		WORD value;
		WORD min, max;
		WORD lineStep, pageStep;
		HWND slider;
		int resourceID;

	public:
		Slider (HWND hDlg, int resourceID);
		Slider (void) {}

		void Init (HWND hDlg, int resourceID, WORD value,   // with implicit drawing!
		           WORD min, WORD max, WORD lineStep, WORD pageStep);

		void SetRange (WORD min, WORD max, WORD lineStep, WORD pageStep);

		void SetValue (WORD value);   // with implicit drawing!
		WORD GetValue (void) {return value;}

		int GetID (void) {return resourceID;}

		WORD Move (WPARAM wParam, LPARAM lParam);

		void Show (BOOL showIt);
	};



class Dialog
	{
	private:
		friend BOOL FAR PASCAL __loadds DialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
		HBRUSH		hbrGrey;

	protected:
		HINSTANCE	hinst;

		HWND			hDlg;	   	// dialog handle
		int			resourceID;
   	BOOL			modal;

		virtual BOOL DialogProc (UINT msg, WPARAM wParam, LPARAM lParam);
			// Implemented by derived classes. Return if message was processed.
		virtual Error InitDialog(void) {GNRAISE_OK;}
		virtual Error DoneDialog(void) {GNRAISE_OK;}
		virtual Error CancelDialog(void) {GNRAISE_OK;}
		virtual Error InitMove(int xu, int yu);

      virtual Error Paint(HDC hdc) {GNRAISE_OK;}

      Error InitSlider(Slider & slider, WORD value, WORD min, WORD max,
		                                  WORD lineStep, WORD pageStep,
		                                  int resourceID);

		WORD MoveSlider(Slider & slider, WPARAM wParam, LPARAM lParam);
	public:
		Dialog(HINSTANCE	hinst, int resourceID)
			{this->hinst = hinst; this->resourceID = resourceID; hDlg = NULL; hbrGrey = NULL;}

		Error OpenDialog(void);
		Error CloseDialog(void);

		Error DoDialog(void);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\drvdiagnostics.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:      software\library\common\drvdiagnostics.h
// AUTHOR:    Martin Stephan
// COPYRIGHT: (c) 1999 Viona Development GmbH. All Rights Reserved.
// CREATED:   11.05.1999
//
// PURPOSE:   useful routines for debugging kernel mode drivers
//
// HISTORY:
#ifndef _DRVDIAGNOSTICS_H
#define _DRVDIAGNOSTICS_H

#if DBG!=0
#ifndef _DEBUG
#define _DEBUG
#endif
#endif

#ifdef _DEBUG

// A VERIFY macro.
#define VERIFY(x) ASSERT(x)

// The C/C++ ASSERTIRQL define.  This checks that the IRQL is equal to
//  that specified.  If it is not, then the assert fires.
#define ASSERTIRQL(x)                                       \
            ASSERTMSG ( "KeGetCurrentIrql ( ) == "#x ,      \
                         KeGetCurrentIrql ( ) == x    ) ;

// For consistency....
#define ASSERTIRQL_EQ(x)    ASSERTIRQL ( x )

// Is the IRQL less than x?
#define ASSERTIRQL_LT(x)                                    \
            ASSERTMSG ( "KeGetCurrentIrql ( ) < "#x ,       \
                         KeGetCurrentIrql ( )< x     ) ;

// Is the IRQL less than or equal to x?
#define ASSERTIRQL_LE(x)                                    \
            ASSERTMSG ( "KeGetCurrentIrql ( ) <= "#x ,      \
                         KeGetCurrentIrql ( ) <= x    ) ;

// Is the IRQL greater than or equal to x?
#define ASSERTIRQL_GE(x)                                    \
            ASSERTMSG ( "KeGetCurrentIrql ( ) >= "#x ,      \
                         KeGetCurrentIrql ( ) >= x    ) ;

// Is the IRQL greater than x?
#define ASSERTIRQL_GT(x)                                    \
            ASSERTMSG ( "KeGetCurrentIrql ( ) > "#x ,       \
                         KeGetCurrentIrql ( ) > x    ) ;

// Is the IRQL not equal to x?
#define ASSERTIRQL_NE(x)                                    \
            ASSERTMSG ( "KeGetCurrentIrql ( ) != "#x ,      \
                         KeGetCurrentIrql ( ) != x    ) ;

#define guidPrint(guid) DP("GUID: %x %x %x %x%x%x%x%x%x%x%x", guid.Data1, guid.Data2, guid.Data3, (int)guid.Data4[0], \
																													(int)guid.Data4[1], \
																													(int)guid.Data4[2], \
																													(int)guid.Data4[3], \
																													(int)guid.Data4[4], \
																													(int)guid.Data4[5], \
																													(int)guid.Data4[6], \
																													(int)guid.Data4[7]);

#else

#define ASSERTIRQL(x)
#define ASSERTIRQL_EQ(x)
#define ASSERTIRQL_LT(x)
#define ASSERTIRQL_LE(x)
#define ASSERTIRQL_GE(x)
#define ASSERTIRQL_GT(x)
#define ASSERTIRQL_NE(x)

#define guidPrint(guid)

#define VERIFY(x) x


#endif      // _DEBUG


#endif      // _DRVDIAGNOSTICS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\fuzzylgk.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef FUZZYLGK_H
#define FUZZYLGK_H

#include "prelude.h"

#define FUZZY_TRUE	10000
#define FUZZY_FALSE	0

inline WORD FZNOT(WORD a) {return FUZZY_TRUE - a;}

inline WORD FZAND(WORD a1, WORD a2) {return ScaleWord(a1, FUZZY_TRUE, a2);}
inline WORD FZAND(WORD a1, WORD a2, WORD a3) {return FZAND(FZAND(a1, a2), a3);}
inline WORD FZAND(WORD a1, WORD a2, WORD a3, WORD a4) {return FZAND(FZAND(a1, a2), FZAND(a3, a4));}

inline WORD FZOR(WORD a1, WORD a2) {return FZNOT(FZAND(FZNOT(a1), FZNOT(a2)));}
inline WORD FZOR(WORD a1, WORD a2, WORD a3) {return FZOR(FZOR(a1, a2), a3);}
inline WORD FZOR(WORD a1, WORD a2, WORD a3, WORD a4) {return FZOR(FZOR(a1, a2), FZOR(a3, a4));}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\KATMAIMacros.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// ************************************************************************************
// *
// *	INTEL KATMAI ISSE EXTENSION MACROS
// *
// *	FILE:			KatmaiMacros
// *	CONTEXT:		header file containing preprocessor macros
// *	PURPOSE:		preprocessor macros for generation of ISSE instructions
// *	START:		Friday, 23. July 1999
// *
// *	AUTHOR:		Roland Schaufler
// *	COPYRIGHT:	VIONA Development GmbH
// *
// ************************************************************************************
//
// THIS FILE IS COPYRIGHT OF VIONA DEVELOPMENT GMBH AND IS NOT LICENSED TO THE PUBLIC
//
// This file depends on the file "MMXExtensionMacros.h" and will not compile without it.
// All register definitions are missing here...
//
// As it is not possible to overload a macro and to use it with different parameters
// every single addressing mode which is needed has to be "hard-coded". The convention used
// herefore is the following:
//
// instruction			meaning
// Suffix
// -------------------------------------------------------
// --						reg, reg
// MEM					reg, [base]
// IMM8					reg, [base + immediate8]  (this one is not used)
//	IMM32					reg, [base + immediate32] (this one is used rather!)
// SIB					reg, [base + scale*index]
//	STR					[base], reg  (memory store)
//
// explicite store or load instructions contain no extra suffixes
//

#include "MMXExtensionMacros.h"


#ifndef KATMAI_MACROS_H
#define KATMAI_MACROS_H

// streaming SIMD MMX registers
#define Register_xmm0 0
#define Register_xmm1 1
#define Register_xmm2 2
#define Register_xmm3 3
#define Register_xmm4 4
#define Register_xmm5 5
#define Register_xmm6 6
#define Register_xmm7 7

// specials for ModR/M bytes: Mod
#define Mod_none   0
#define Mod_disp8	 1
#define Mod_disp32 2
#define Mod_reg    3

// specials for ModR/M bytes: R/M
#define Register_SIB    4
#define Register_disp32	5

// specials for SIB bytes
#define Register_noindx 4
#define Register_nobase 5

//////////////////////////////////////////////////////////////////////////////////////////////
// Macros only for use within other Macros
//////////////////////////////////////////////////////////////////////////////////////////////

#define START2	_asm _emit 0x0F _asm _emit
#define START3	_asm _emit 0xF3 _asm _emit 0x0F _asm _emit

//////////////////////////////////////////////////////////////////////////////////////////////

#define BLOCK2(opcode, mod, rm, dest)									\
	}																				\
   START2 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm																			\
		{

#define BLOCK2IMM8(opcode, mod, rm, dest, imm8)						\
	}																				\
   START2 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit imm8															\
	_asm																			\
		{

#define BLOCK2IMM32(opcode, mod, rm, dest, imm32)					\
	}																				\
   START2 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit BYTE0(imm32)													\
	_asm _emit BYTE1(imm32)													\
	_asm _emit BYTE2(imm32)													\
	_asm _emit BYTE3(imm32)													\
	_asm																			\
		{

//////////////////////////////////////////////////////////////////////////////////////////////

#define BLOCK2SIB(opcode, mod, rm, dest, scale, index, base)	\
	}																				\
   START2 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit SIBBYTE(scale, index, base)								\
	_asm																			\
		{

#define BLOCK2SIBIMM8(opc, mod, rm, dst, scal, ind, bas, imm8)	\
	}																				\
   START2 opc																	\
	_asm _emit MODRMBYTE(mod, rm, dst)									\
	_asm _emit SIBBYTE(scal, ind, bas)									\
	_asm _emit imm8															\
	_asm																			\
		{

#define BLOCK2SIBIMM32(opc, mod, rm, dest, scale, ind, base)	\
	}																				\
   START2 opc																	\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit SIBBYTE(scale, ind, base)								\
	_asm _emit BYTE0(imm32)													\
	_asm _emit BYTE1(imm32)													\
	_asm _emit BYTE2(imm32)													\
	_asm _emit BYTE3(imm32)													\
	_asm																			\
		{

//////////////////////////////////////////////////////////////////////////////////////////////

#define BLOCK3(opcode, mod, rm, dest)									\
	}																				\
   START3 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm																			\
		{

#define BLOCK3IMM8(opcode, mod, rm, dest, imm8)						\
	}																				\
   START3 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit imm8															\
	_asm																			\
		{

#define BLOCK3IMM32(opcode, mod, rm, dest, imm32)					\
	}																				\
   START3 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit BYTE0(imm32)													\
	_asm _emit BYTE1(imm32)													\
	_asm _emit BYTE2(imm32)													\
	_asm _emit BYTE3(imm32)													\
	_asm																			\
		{

//////////////////////////////////////////////////////////////////////////////////////////////

#define BLOCK3SIB(opcode, mod, rm, dest, scale, index, base)	\
	}																				\
   START3 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit SIBBYTE(scale, index, base)								\
	_asm																			\
		{

#define BLOCK3SIBIMM8(opc, mod, rm, dst, scal, ind, bas, imm8)	\
	}																				\
   START3 opc																	\
	_asm _emit MODRMBYTE(mod, rm, dst)									\
	_asm _emit SIBBYTE(scal, ind, bas)									\
	_asm _emit imm8															\
	_asm																			\
		{

#define BLOCK3SIBIMM32(opc, mod, rm, dest, scale, ind, base)	\
	}																				\
   START3 opc																	\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit SIBBYTE(scale, ind, base)								\
	_asm _emit BYTE0(imm32)													\
	_asm _emit BYTE1(imm32)													\
	_asm _emit BYTE2(imm32)													\
	_asm _emit BYTE3(imm32)													\
	_asm																			\
		{


//////////////////////////////////////////////////////////////////////////////////////////////
// KATMAI STREAMING SIMD INSTRUCTIONS
//////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////
// **** 2 BYTE OPCODES
// **** REGISTER to REGISTER
//////////////////////////////////////////////////////////////////////////////////////////////
#define addps(dest, src)					BLOCK2(0x58, reg, src, dest)
#define andnps(dest, src)					BLOCK2(0x55, reg, src, dest)
#define andps(dest, src)					BLOCK2(0x54, reg, src, dest)
#define comiss(dest, src)					BLOCK2(0x2F, reg, src, dest)
#define cvtpi2ps(dest, src)				BLOCK2(0x2A, reg, src, dest)
#define cvtps2pi(dest, src)				BLOCK2(0x2D, reg, src, dest)
#define cvttps2pi(dest, src)				BLOCK2(0x2C, reg, src, dest)
#define divps(dest, src)					BLOCK2(0x5E, reg, src, dest)
#define maxps(dest, src)					BLOCK2(0x5F, reg, src, dest)
#define minps(dest, src)					BLOCK2(0x5D, reg, src, dest)
#define movaps(dest, src)					BLOCK2(0x28, reg, src, dest)
#define movmskps(dest, src)				BLOCK2(0x50, reg, src, dest)
#define movups(dest, src)					BLOCK2(0x10, reg, src, dest)
#define mulps(dest, src)					BLOCK2(0x59, reg, src, dest)
#define orps(dest, src)						BLOCK2(0x56, reg, src, dest)
#define rcpps(dest, src)					BLOCK2(0x53, reg, src, dest)
#define rsqrtps(dest, src)					BLOCK2(0x52, reg, src, dest)
#define sqrtps(dest, src)					BLOCK2(0x51, reg, src, dest)
#define subps(dest, src)					BLOCK2(0x5C, reg, src, dest)
#define ucomiss(dest, src)					BLOCK2(0x2E, reg, src, dest)
#define unpckhps(dest, src)				BLOCK2(0x15, reg, src, dest)
#define unpcklps(dest, src)				BLOCK2(0x14, reg, src, dest)
#define xorps(dest, src)					BLOCK2(0x57, reg, src, dest)

//////////////////////////////////////////////////////////////////////////////////////////////
// **** 3 Byte opcodes
// **** REGISTER to REGISTER
//////////////////////////////////////////////////////////////////////////////////////////////
#define rcpss(dest, src)					BLOCK3(0x53, reg, src, dest)
#define rsqrtss(dest, src)					BLOCK3(0x52, reg, src, dest)
#define addss(dest, src)					BLOCK3(0x58, reg, src, dest)
#define cvtsi2ss(dest, src)				BLOCK3(0x2A, reg, src, dest)
#define cvtss2si(dest, src)				BLOCK3(0x2D, reg, src, dest)
#define cvttss2si(dest, src)				BLOCK3(0x2C, reg, src, dest)
#define divss(dest, src)					BLOCK3(0x5E, reg, src, dest)
#define maxss(dest, src)					BLOCK3(0x5F, reg, src, dest)
#define minss(dest, src)					BLOCK3(0x5D, reg, src, dest)
#define movss(dest, src)					BLOCK3(0x10, reg, src, dest)
#define mulss(dest, src)					BLOCK3(0x59, reg, src, dest)
#define rcpss(dest, src)					BLOCK3(0x53, reg, src, dest)
#define rsqrtss(dest, src)					BLOCK3(0x52, reg, src, dest)
#define sqrtss(dest, src)					BLOCK3(0x51, reg, src, dest)
#define subss(dest, src)					BLOCK3(0x5C, reg, src, dest)

//////////////////////////////////////////////////////////////////////////////////////////////
// **** 2 BYTE OPCODES
// **** REGISTER to REGISTER plus IMMEDIATE8
//////////////////////////////////////////////////////////////////////////////////////////////
#define cmpps(dest, src, imm8)         BLOCK2IMM8(0xC2, reg, src, dest, imm8)
#define shufps(dest, src, imm8)        BLOCK2IMM8(0xC6, reg, src, dest, imm8)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// **** 2 Byte opcodes
// **** MEMORY	to REGISTER
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// **** MEMORY to REGISTER
#define cvtpi2psMEM(dest, src)										BLOCK2(0x2A, none, src, dest)
#define cvtps2piMEM(dest, src)										BLOCK2(0x2D, none, src, dest)
#define movapsMEM(dest, src)											BLOCK2(0x28, none, src, dest)           // src = single INTEGER Register
#define movhpsMEM(dest, src)											BLOCK2(0x16, none, src, dest)           // src = single INTEGER Register
#define movlpsMEM(dest, src)											BLOCK2(0x12, none, src, dest)           // src = single INTEGER Register
#define movupsMEM(dest, src)											BLOCK2(0x10, none, src, dest)
#define xorpsMEM(dest, src)											BLOCK2(0x57, none, src, dest)
// **** MEMORY to REGISTER	+ offset8
#define cvtpi2psIMM8(dest, src, imm8)								BLOCK2IMM8(0x2A, disp8, src, dest, imm8)
#define cvtps2piIMM8(dest, src, imm8)								BLOCK2IMM8(0x2D, disp8, src, dest, imm8)
#define movupsIMM8(dest, src, imm8)									BLOCK2IMM8(0x10, disp8, src, dest, imm8)  // src = single INTEGER Register
#define movhpsIMM8(dest, src, imm8)									BLOCK2IMM8(0x16, disp8, src, dest, imm8)  // src = single INTEGER Register
#define movlpsIMM8(dest, src, imm8)									BLOCK2IMM8(0x12, disp8, src, dest, imm8)  // src = single INTEGER Register
// **** MEMORY to REGISTER	+ offset32
#define cvtpi2psIMM32(dest, src, imm32)							BLOCK2IMM32(0x2A, disp32, src, dest, imm32)
#define cvtps2piIMM32(dest, src, imm32)							BLOCK2IMM32(0x2D, disp32, src, dest, imm32)
#define movhpsIMM32(dest, src, imm32)								BLOCK2IMM32(0x16, disp32, src, dest, imm32) // src = single INTEGER Register
#define movlpsIMM32(dest, src, imm32)								BLOCK2IMM32(0x12, disp32, src, dest, imm32) // src = single INTEGER Register
// **** MEMORY to REGISTER	complex adress (base + index)
#define cvtpi2psSIB(dest, scale, index, base)					BLOCK2SIB(0x2A, none, SIB, dest, scale, index, base)
#define cvtps2piSIB(dest, scale, index, base)					BLOCK2SIB(0x2D, none, SIB, dest, scale, index, base)
#define movhpsSIB(dest, scale, index, base)						BLOCK2SIB(0x16, none, SIB, dest, scale, index, base)
#define movlpsSIB(dest, scale, index, base)						BLOCK2SIB(0x12, none, SIB, dest, scale, index, base)
#define movupsSIB(dest, scale, index, base)						BLOCK2SIB(0x10, none, SIB, dest, scale, index, base)
// **** MEMORY to REGISTER	complex adress (base + index), offset8
#define cvtpi2psSIBIMM8(dest, scale, index, base, imm8)		BLOCK2SIBIMM8(0x2A, disp8, SIB, dest, scale, index, base, imm8)
#define cvtps2piSIBIMM8(dest, scale, index, base, imm8)		BLOCK2SIBIMM8(0x2D, disp8, SIB, dest, scale, index, base, imm8)
#define movhpsSIBIMM8(dest, scale, index, base, imm8)			BLOCK2SIBIMM8(0x16, disp8, SIB, dest, scale, index, base, imm8)
#define movlpsSIBIMM8(dest, scale, index, base, imm8)			BLOCK2SIBIMM8(0x12, disp8, SIB, dest, scale, index, base, imm8)
#define movupsSIBIMM8(dest, scale, index, base, imm8)			BLOCK2SIBIMM8(0x10, disp8, SIB, dest, scale, index, base, imm8)
// **** MEMORY to REGISTER	complex adress (base + index), offset32
#define cvtpi2psSIBIMM32(dest, scale, index, base, imm32)	BLOCK2SIBIMM32(0x2A, disp32, SIB, dest, scale, index, base, imm32)
#define cvtps2piSIBIMM32(dest, scale, index, base, imm32)	BLOCK2SIBIMM32(0x2D, disp32, SIB, dest, scale, index, base, imm32)
#define movhpsSIBIMM32(dest, scale, index, base, imm32)		BLOCK2SIBIMM32(0x16, disp32, SIB, dest, scale, index, base, imm32)
#define movlpsSIBIMM32(dest, scale, index, base, imm32)		BLOCK2SIBIMM32(0x12, disp32, SIB, dest, scale, index, base, imm32)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// **** 2 Byte opcodes
// **** REGISTER to MEMORY
//////////////////////////////////////////////////////////////////////////////////////////////
// **** REGISTER to MEMORY
#define movapsSTR(dest, src)              BLOCK2(0x29, none, src, dest)           // src = single INTEGER Register
#define movhpsSTR(dest, src)              BLOCK2(0x17, none, src, dest)           // src = single INTEGER Register
#define movlpsSTR(dest, src)              BLOCK2(0x13, none, src, dest)           // src = single INTEGER Register
#define movupsSTR(dest, src)              BLOCK2(0x11, none, src, dest)           // src = single INTEGER Register
// **** REGISTER to MEMORY	+ offset8
#define movhpsIMM8STR(dest, src, imm8)		BLOCK2IMM8(0x17, disp8, src, dest, imm8)  // src = single INTEGER Register
#define movlpsIMM8STR(dest, src, imm8)		BLOCK2IMM8(0x13, disp8, src, dest, imm8)  // src = single INTEGER Register
#define movupsIMM8STR(dest, src, imm8)		BLOCK2IMM8(0x11, disp8, src, dest, imm8)  // src = single INTEGER Register
// **** REGISTER to MEMORY	+ offset32
#define movhpsIMM32STR(dest, src, imm32)  BLOCK2IMM32(0x17, disp32, src, dest, imm32) // src = single INTEGER Register
#define movlpsIMM32STR(dest, src, imm32)  BLOCK2IMM32(0x13, disp32, src, dest, imm32) // src = single INTEGER Register
#define movupsIMM32STR(dest, src, imm32)  BLOCK2IMM32(0x11, disp32, src, dest, imm32) // src = single INTEGER Register
// **** REGISTER to MEMORY	complex adress (base + index)
#define movhpsSIBSTR(dest, scale, index, base)  BLOCK2SIB(0x17, none, SIB, dest, scale, index, base)
#define movlpsSIBSTR(dest, scale, index, base)  BLOCK2SIB(0x13, none, SIB, dest, scale, index, base)
#define movupsSIBSTR(dest, scale, index, base)  BLOCK2SIB(0x11, none, SIB, dest, scale, index, base)
// **** REGISTER to MEMORY	complex adress (base + index), offset8
#define movhpsSIBIMM8STR(dest, scale, index, base, imm8) BLOCK2SIBIMM8(0x17, disp8, SIB, dest, scale, index, base, imm8)
#define movlpsSIBIMM8STR(dest, scale, index, base, imm8) BLOCK2SIBIMM8(0x13, disp8, SIB, dest, scale, index, base, imm8)
#define movupsSIBIMM8STR(dest, scale, index, base, imm8) BLOCK2SIBIMM8(0x11, disp8, SIB, dest, scale, index, base, imm8)
// **** REGISTER to MEMORY	complex adress (base + index), offset32
#define movhpsSIBIMM32STR(dest, scale, index, base, imm32) BLOCK2SIBIMM32(0x17, disp32, SIB, dest, scale, index, base, imm32)
#define movlpsSIBIMM32STR(dest, scale, index, base, imm32) BLOCK2SIBIMM32(0x13, disp32, SIB, dest, scale, index, base, imm32)
#define movupsSIBIMM32STR(dest, scale, index, base, imm32) BLOCK2SIBIMM32(0x11, disp32, SIB, dest, scale, index, base, imm32)

//////////////////////////////////////////////////////////////////////////////////////////////
// **** 3 Byte opcodes
// **** REGISTER to MEMORY (Stores)
//////////////////////////////////////////////////////////////////////////////////////////////
#define movssSIBSTR(dest, scale, index, base)   BLOCK3SIB(0x11, none, SIB, dest, scale, index, base)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\krnlfile.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlfile.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#ifndef KRNLFILE_H
#define KRNLFILE_H

#include "prelude.h"
#include "gnerrors.h"
#include "krnlint.h"
#include "..\general\lists.h"
#include "..\general\refcnt.h"

class KernelFileHandle;
class GenericKernelInputFile;
class GenericKernelOutputFile;

class GenericKernelFileHandle : public Node, public ReferenceCounter
	{
	friend class GenericKernelFile;
	friend class GenericKernelInputFile;
	friend class GenericKernelOutputFile;

	public:
		KernelInt64	pos;
		KernelInt64 size;

		virtual Error RawWrite(HPTR buffer, DWORD size, DWORD __far & done) = 0;
		virtual Error RawRead(HPTR buffer, DWORD size, DWORD __far & done) = 0;

		virtual ~GenericKernelFileHandle(void) {}

		virtual Error Seek(KernelInt64 at) = 0;
	};

class GenericKernelFile
	{
	protected:
		GenericKernelFileHandle	*	handle;
	public:
		GenericKernelFile(void);
		virtual ~GenericKernelFile(void);

		GenericKernelInputFile * CastToInputFile(void) {return NULL;}
		GenericKernelOutputFile * CastToOutputFile(void) {return NULL;}

		Error Open(GenericKernelFileHandle * handle);
		Error Close(void);
		Error Seek(KernelInt64 at);

		KernelInt64 FilePos(void) {return handle ? handle->pos : 0;}
		KernelInt64 FileSize(void) {return handle ? handle->size : 0;}
	};

class GenericKernelInputFile : virtual public GenericKernelFile
	{
	public:
		GenericKernelInputFile * CastToInputFile(void) {return this;}

		Error Read(HPTR buffer, DWORD size, DWORD __far & done);
		Error Read(BYTE __far & data);
		Error Read(WORD __far & data);
		Error Read(DWORD __far & data);
	};

class GenericKernelOutputFile : virtual public GenericKernelFile
	{
	public:
		GenericKernelOutputFile * CastToOutputFile(void) {return this;}

		Error Write(HPTR buffer, DWORD size, DWORD __far & done);
		Error Write(BYTE data);
		Error Write(WORD data);
		Error Write(DWORD data);
	};

class GenericKernelInOutFile : public GenericKernelInputFile, public GenericKernelOutputFile
	{
	};

class KernelInputFile : public GenericKernelInputFile
	{
	friend class KernelInputSubFile;
	friend class KernelInputChainFile;
	public:
		virtual Error Open(KernelString fname);
	};

class KernelOutputFile : public GenericKernelOutputFile
	{
	public:
		virtual Error Open(KernelString fname);
		virtual Error Create(KernelString fname);

	};

class KernelInOutFile : public KernelInputFile,
                        public KernelOutputFile,
                        public GenericKernelInOutFile
	{
	public:
		virtual Error Open(KernelString fname);
		virtual Error Create(KernelString fname);
	};


class KernelInputSubFile : public GenericKernelInputFile
	{
	public:
		virtual Error Open(KernelInputFile * file, KernelInt64 start, KernelInt64 size);
	};

class KernelInputChainFile : public KernelInputFile
	{
	protected:
		class KernelChainFileHandle * handle;
	public:
		KernelInputChainFile(void) {handle = NULL;}
		virtual Error Open(void);

		virtual Error AppendFile(KernelInputFile * file);
		virtual Error PrependFile(KernelInputFile * file);
		virtual Error RemoveFile(KernelInputFile * file);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\Hooks.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\hooks.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   15.05.95
//
// PURPOSE:   Generalized callback
//
// HISTORY:
//
//

#ifndef HOOKS_H
#define HOOKS_H

#include "prelude.h"
#include "gnerrors.h"

//
// A hook is a generalized callback.  The receiver of the callback
// gets two parameters, first the hook itself (this may be used for
// caller specific data), and a hook specific data element.
//
// The callback function is _NOT_ a virtual function, but a function
// pointer.  This has been done, to avoid incompatibilities with
// traditional 'C'.
//
// A typical use for a hook would be a refill request for a buffer
// in a buffer based stream:
//
// typedef struct RefillMsgStruct
//    {void __far * data, long num, long actual} RefillMsg;
//
// MKHOOK(Refill, RefillMsg);
//
// The implementor of the hook may then add some additional data,
// to customize the hook:
//
// class FileRefillHook : public RefillHook {
//		private:
//			Error Refill(void __far * data, long num, long &actual);
//			friend Error Refill(RefillHook * me, RefillMsg data);
//			FILE 	*	file;
//    public:
//       FileRefillHook(FILE * file) : RefillHook(Refill);
//		};
//
//	Error Refill(RefillHook * me, RefillMsg data)
//		{
//		return (FileRefillHook *)me->Refill(data.data, data.num, data.actual);
//		};
//
//
// Note that you have to do a MakeProcInstance if your callback function is not
// inside a DLL.
//


class KWorkerQueue;

class GenericHook
	{
	protected:
		KWorkerQueue	*	queue;
	public:
		void Register(KWorkerQueue * queue) {this->queue = queue;}
	};


#if NT_KERNEL

//#ifndef ONLY_EXTERNAL_VISIBLE

#include "krnlsync.h"

#define WORKER_QUEUE_SIZE	4096

#if WDM_VERSION
#define WORKER_HEADER_SIZE ((sizeof(void *) + sizeof(DWORD)) / sizeof(DWORD))
#endif

class KWorkerQueue
	{
	private:
		DWORD		buffer[WORKER_QUEUE_SIZE];
		int		bstart, bend, used;
		KEVENT	event, done;
		HANDLE	workerThread;
		IRQMutex	mutex;

		void PutDW(DWORD val);
		DWORD GetDW(void);

#if WDM_VERSION
		void PutDWP(DWORD_PTR);
		DWORD_PTR GetDWP(void);
#endif

	public:
		KWorkerQueue(void);
		~KWorkerQueue(void);
		void EnterWork(GenericHook * me, void * mem, int size);
		void GetWork(GenericHook * & me, void * mem, int & size);
		void RemoveHook(GenericHook * hook);
	};

#define MKHOOK(name, type) \
	class name##Hook : public GenericHook { \
		friend class name##HookHandle;	\
		public: \
			typedef Error (__far * CallType)(name##Hook * me, type & data); \
		private: \
			CallType	call; \
		public:	\
			name##Hook(CallType call) {this->call = call; queue = NULL;} \
	};	\
	class name##HookHandle {	\
		private:	\
			KWorkerQueue	*	queue;	\
			name##Hook	*	hook;		\
		public: \
			name##HookHandle(name##Hook * hook) {this->queue = hook->queue; this->hook = hook;}	\
			name##HookHandle(void) {hook = NULL; queue = NULL;}	\
			Error Call(type data) {if (!queue && hook) hook->call(hook, data); else queue->EnterWork(hook, &data, sizeof(type));GNRAISE_OK;} \
			operator name##Hook * (void) {return hook;}	\
			BOOL operator!= (name##Hook * hook) {return this->hook != hook;} \
			name##HookHandle & operator= (name##Hook * hook) \
				{	\
				if (hook)	\
					this->queue = hook->queue;	\
				else	\
					this->queue = NULL;	\
				this->hook = hook; return *this;	\
				} \
			name##HookHandle & operator= (int i) {this->queue = NULL; this->hook = NULL; return *this;}	\
	};


//#endif // of ONLY_EXTERNAL_VISIBLE

#elif VXD_VERSION

#ifndef ONLY_EXTERNAL_VISIBLE

#define KEVENT HANDLE

#define WORKER_QUEUE_SIZE	4096

class KWorkerQueue
	{
	private:
		DWORD		eventVxdHandle, doneVxdHandle;
		DWORD		buffer[WORKER_QUEUE_SIZE];
		volatile int bstart, bend, used;
//		KEVENT	event, done;
		HANDLE	workerThread;
		void PutDW(DWORD val);
		DWORD GetDW(void);
	public:
		KWorkerQueue(DWORD eventVxdHandle, DWORD doneVxdHandle);
		~KWorkerQueue(void);
		void EnterWork(GenericHook * me, void * mem, int size);
		void GetWork(GenericHook * & me, void * mem, int & size);
	};

#define MKHOOK(name, type) \
	class name##Hook : public GenericHook { \
		friend class name##HookHandle;	\
		public: \
			typedef Error (__far * CallType)(name##Hook * me, type & data); \
		private: \
			CallType	call; \
	};	\
	class name##HookHandle {	\
		private:	\
			KWorkerQueue	*	queue;	\
			name##Hook	*	hook;		\
		public: \
			name##HookHandle(name##Hook * hook) {this->queue = hook->queue; this->hook = hook;}	\
			name##HookHandle(void) {hook = NULL; queue = NULL;}	\
			Error Call(type data) {queue->EnterWork(hook, &data, sizeof(type));GNRAISE_OK;} \
			operator name##Hook * (void) {return hook;}	\
			name##HookHandle & operator= (name##Hook * hook) \
				{	\
				if (hook)	\
					this->queue = hook->queue;	\
				else	\
					this->queue = NULL;	\
				this->hook = hook; return *this;	\
				} \
			name##HookHandle & operator= (int i) {this->queue = NULL; this->hook = NULL; return *this;}	\
	};

#endif	// of ONLY_EXTERNAL_VISIBLE

#elif DRVDLL

#define MKHOOK(name, type) \
	class __far name##Hook : public GenericHook { \
		public: \
			typedef Error (WINAPI * CallType)(name##Hook __far * me, type & data); \
		private: \
			CallType	call; \
			class KWorkerQueue	*	queue;	\
		public: \
			name##Hook(CallType call) {this->call = call;} \
			Error Call(type &data) {return call(this, data);} \
	};

typedef DWORD DWBLK[8];

MKHOOK(Dummy, DWBLK);

#else

extern "C" {
DLLCALL void  WINAPI VDR_RegisterCallback(GenericHook * hook);
}

#define MKHOOK(name, type) \
	class __far name##Hook : public GenericHook { \
		public: \
			typedef Error (WINAPI * CallType)(name##Hook __far * me, type & data); \
		private: \
			CallType	call; \
			class KWorkerQueue	*	queue;	\
		public: \
			name##Hook(CallType call) {this->call = call;VDR_RegisterCallback(this);} \
	};

#endif // NTKERNEL




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\gnerrors.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\gnerrors.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:   Centralized error handling
//
// HISTORY:
//
//

#ifndef GNERRORS_H
#define GNERRORS_H

#if !VIDEO_MINIPORT_DRIVER
#include	"prelude.h"
#endif

typedef unsigned long Error;

//
// The last error, that was raised, is not only returned, but preserved in
// this variable.
//
//extern Error LastError;

//
// Error numbers are composed of four parts, an severity level, that
// tells how hard the error hit; a unit id, describing the unit that
// failed; an error type giving some general reasons and an unique
// id (unique for the module, not all error messages).
//
//                  SS-UUUUUUUU-TTTTTTTT-IIIIIIIIIIIIII
//


#define GNR_SEVERITY_BITS	(2)
#define GNR_SEVERITY_SHIFT	(30)
#define GNR_SEVERITY_MASK	(0xC0000000)

#define GNR_UNIT_BITS		(8)
#define GNR_UNIT_SHIFT		(22)
#define GNR_UNIT_MASK		(0x3FC00000)

#define GNR_TYPE_BITS		(8)
#define GNR_TYPE_SHIFT		(14)
#define GNR_TYPE_MASK	   (0x003FC000)

#define GNR_UNIQUE_BITS		(14)
#define GNR_UNIQUE_SHIFT	(0)
#define GNR_UNIQUE_MASK		(0x00003FFF)


//
// The severity level describes how hard this error affected the operation.
//
// As the severity level is the most significant part of an error message,
// it can be tested with a simple compare (not the Error is defined as
// unsigned, so no special sign effects can occur).
//
#define GNR_OK					(0x0L << GNR_SEVERITY_SHIFT)
	// everything did well; The neat side effect of defining the OK level as
	// 0, is that the check for an error can be done with a simple not
	// 0 compare like "if (error) { ... }".

#define GNR_WARNING			(0x1L << GNR_SEVERITY_SHIFT)
	// something not quite perfect happened, but the action was performed

#define GNR_ERROR				(0x2L << GNR_SEVERITY_SHIFT)
	// an error accured, that kept the routine from doing its job

#define GNR_DEADLY			(0x3L << GNR_SEVERITY_SHIFT)
	// something happened, that will keep the program from working correct,
	// it would be better to exit gracefully

//
// The error unit specifies the module where this error was defined
//
#define GNR_UNIT_COMMON		(0x0L << GNR_UNIT_SHIFT)
	// defined in gnerrors.H

#define GNR_UNIT_GENERAL	(0x1L << GNR_UNIT_SHIFT)
	// define in ..\general\*.h

#define GNR_UNIT_MEMMPDIO	(0x2L << GNR_UNIT_SHIFT)
	// define in memmpdio.h

#define GNR_UNIT_I2C			(0x3L << GNR_UNIT_SHIFT)
	// defined in viperi2c.h

#define GNR_UNIT_INTERRUPT	(0x4L << GNR_UNIT_SHIFT)
   // defined in intrctrl.h

#define GNR_UNIT_PARSER		(0x5L << GNR_UNIT_SHIFT)
	// defined in mpgparse.h

#define GNR_UNIT_PCI					(0x6L << GNR_UNIT_SHIFT)
	// define in pci.h

#define GNR_UNIT_DMA					(0x7L << GNR_UNIT_SHIFT)
	// define in dma*.h

#define GNR_UNIT_VDECODER			(0x8L << GNR_UNIT_SHIFT)
	// defined in viddec.h

#define GNR_UNIT_VENCODER			(0x9L << GNR_UNIT_SHIFT)
	// defined in videnc.h

#define GNR_UNIT_JPEG				(0xCL << GNR_UNIT_SHIFT)
	// defined in core.h

#define GNR_UNIT_MPEG				(0xDL << GNR_UNIT_SHIFT)
	// defined in library\hardware\mpeg2dec\mp2eldec.h

#define GNR_UNIT_TVTUNER			(0xEL << GNR_UNIT_SHIFT)
	// defined in tvtuner.h

#define GNR_UNIT_VESA20				(0xFL << GNR_UNIT_SHIFT)
	// defined in vesa20.h

#define GNR_UNIT_GFC					(0x10L << GNR_UNIT_SHIFT)
	// defined in gfxconfig.h

#define GNR_UNIT_PIP					(0x11L << GNR_UNIT_SHIFT)
	// defined in *pip*.h

#define GNR_UNIT_DMAMEM				(0x12L << GNR_UNIT_SHIFT)
	//	defined in ctdmamem.h

#define GNR_UNIT_CD					(0x13L << GNR_UNIT_SHIFT)
	// defined in cdifs.h

#define GNR_UNIT_PROFILES			(0x14L << GNR_UNIT_SHIFT)
	// defined in profiles.h

#define GNR_UNIT_AUDIO				(0x15L << GNR_UNIT_SHIFT)
	// defined in audio

#define GNR_UNIT_PCICONTROLLER	(0x16L << GNR_UNIT_SHIFT)

#define GNR_UNIT_AC3					(0x17L << GNR_UNIT_SHIFT)

#define GNR_UNIT_VTX					(0x18L << GNR_UNIT_SHIFT)
	// defined in vtxdll.h

#define GNR_UNIT_MPEG2				(0x19L << GNR_UNIT_SHIFT)

#define GNR_UNIT_MP2PARSER			(0x1AL << GNR_UNIT_SHIFT)

#define GNR_UNIT_VXD					(0x1BL << GNR_UNIT_SHIFT)
	// Error messages from PnP VxD interfaces

#define GNR_UNIT_DISK				(0x1CL << GNR_UNIT_SHIFT)
	// General disk errors (library\hardware\drives\generic\diskerrors.h)

#define GNR_UNIT_NAVIGATION		(0x1DL << GNR_UNIT_SHIFT)
	// Navigation errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_DVD					(0x1EL << GNR_UNIT_SHIFT)
	// DVD specific errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_VCD					(0x1FL << GNR_UNIT_SHIFT)
	// VCD specific errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_CDA					(0x20L << GNR_UNIT_SHIFT)
	// CDA specific errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_DECRYPTION		(0x21L << GNR_UNIT_SHIFT)
	// Decryption errors (library\hardware\mpeg2dec\generic\mp2dcryp.h)

#define GNR_UNIT_FILE				(0x22L << GNR_UNIT_SHIFT)
	// File errors (library\files\fileerrors.h)

#define GNR_UNIT_UNITS				(0x21L << GNR_UNIT_SHIFT)
	// in virtunit.h

#define GNR_UNIT_SUBPICTURE		(0x22L << GNR_UNIT_SHIFT)

#define GNR_UNIT_FRONTPANEL             (0x23L << GNR_UNIT_SHIFT)

//
// The error type gives a general hint, what caused the malfunction
//
#define GNR_TYPE_GENERAL			(0x00L << GNR_TYPE_SHIFT)
	// no special info

#define GNR_TYPE_FILEIO				(0x01L << GNR_TYPE_SHIFT)
	// some file specific error occured

#define GNR_TYPE_HARDWARE			(0x02L << GNR_TYPE_SHIFT)
	// it was a general hardware problem

#define GNR_TYPE_PARAMS				(0x03L << GNR_TYPE_SHIFT)
	// illegal parameters were used

#define GNR_TYPE_TIMEOUT			(0x04L << GNR_TYPE_SHIFT)
	// a timeout happened

#define GNR_TYPE_BUSY				(0x05L << GNR_TYPE_SHIFT)
	// the requested unit is currently busy

#define GNR_TYPE_NOACK				(0x06L << GNR_TYPE_SHIFT)
	// the requested unit did not respond

#define GNR_TYPE_INACTIVE			(0x07L << GNR_TYPE_SHIFT)
	// the requested unit is currently not active, or in an illegal
	// state for the type of the requested operation

#define GNR_TYPE_MEMORY				(0x08L << GNR_TYPE_SHIFT)
	// there was no sufficient free store left

#define GNR_TYPE_UNIMPLEMENTED 	(0x09L << GNR_TYPE_SHIFT)
	// the called function is not yet completely implemented

#define GNR_TYPE_FORMAT				(0x0aL << GNR_TYPE_SHIFT)
	// the examined object was in the wrong format

#define GNR_TYPE_OBJECT				(0x0bL << GNR_TYPE_SHIFT)

#define GNR_TYPE_BOUNDS				(0x0cL << GNR_TYPE_SHIFT)

#define GNR_TYPE_ILLEGALACCESS	(0x0dL << GNR_TYPE_SHIFT)

#define GNR_TYPE_REGION				(0x0eL << GNR_TYPE_SHIFT)

#define GNR_TYPE_PARENTAL			(0x0fL << GNR_TYPE_SHIFT)

#define GNR_TYPE_UOP					(0x10L << GNR_TYPE_SHIFT)

#define GNR_TYPE_OPERATION			(0x11L << GNR_TYPE_SHIFT)

#define GNR_TYPE_INTERNALSTATE	(0x12L << GNR_TYPE_SHIFT)

#define GNR_TYPE_COPYPROTECTION	(0x13L << GNR_TYPE_SHIFT)

//
// Macros to build and decompose error numbers
//
#define MKERR(level, unit, type, unique) ((Error)(GNR_##level | GNR_UNIT_##unit | GNR_TYPE_##type | unique))
	// build an error number from its parts

#define GNR_SEVERITY(err) (err & GNR_SEVERITY_MASK)
	// extracts the severity of the error number

#define GNR_UNIT(err) (err & GNR_UNIT_MASK)
	// extracts the unit of the error number

#define GNR_TYPE(err) (err & GNR_TYPE_MASK)
	// extracts the type of the error number

#define GNR_UNIQUE(err) (err & GNR_UNIQUE_MASK)
	// extracts the unique id of the error number

#ifndef IS_ERROR
	//
	// sidenote, the original definition of IS_ERROR in <winerror.h> is
	// #define IS_ERROR(Status) ((unsigned long)(Status) >> 31 == SEVERITY_ERROR)
	// this is functional identical to our definition, so no need to redefine it
	// here.  In any case a new define is added, which is to be used in all future
	// tests.
	//
#define IS_ERROR(err) ((err) >= GNR_ERROR)
#endif
#define IS_GNERROR(err) ((err) >= GNR_ERROR)

#define IS_WARNING(err) (GNR_SEVERITY(err) == GNR_WARNING)

//
// Some default error messages
//
#define GNR_FILE_NOT_FOUND			MKERR(ERROR, COMMON, FILEIO, 0x00)
	// general file not found error

#define GNR_FILE_IN_USE 			MKERR(ERROR, COMMON, FILEIO, 0x01)
	// the file is currently in use

#define GNR_FILE_WRONG_FORMAT 	MKERR(ERROR, COMMON, FILEIO, 0x02)
	// the file is in the wrong file format

#define GNR_END_OF_FILE 			MKERR(ERROR, COMMON, FILEIO, 0x03)
	// attempt to read behind the end of a file

#define GNR_NOT_ENOUGH_MEMORY 	MKERR(ERROR, COMMON, MEMORY, 0x04)
	// general not enough memory left

#define GNR_MEM_NOT_ALLOCATED 	MKERR(WARNING, COMMON, MEMORY, 0x05)
	// the memory that was requested to be freed was not allocated
	// before.

#define GNR_MEM_ALLOCATED_BEFORE MKERR(WARNING, COMMON, MEMORY, 0x06)
	// the memory was allocated before


#define GNR_UNIMPLEMENTED 			MKERR(ERROR, COMMON, UNIMPLEMENTED, 0x07)
	// the function is not yet implemented, and will never be


#define GNR_OBJECT_NOT_FOUND		MKERR(ERROR, COMMON, OBJECT, 0x08)
	// the requested object could not be found

#define GNR_OBJECT_EXISTS			MKERR(ERROR, COMMON, OBJECT, 0x09)
	// the object requested to be created does already exist

#define GNR_OBJECT_IN_USE			MKERR(ERROR, COMMON, OBJECT, 0x0a)
	// an operation that needs exclusive access to an object, found the object
	// already in use

#define GNR_OBJECT_FOUND			MKERR(ERROR, COMMON, OBJECT, 0x0b)
	// an object that was to be inserted in a data structure with unique objects
	// was already in there

#define GNR_RANGE_VIOLATION		MKERR(ERROR, COMMON, BOUNDS, 0x0c)
	// a given parameter was out of bounds


#define GNR_INVALID_CONFIGURE_STATE		MKERR(ERROR, COMMON, INACTIVE, 0x0d)
	// the unit was in an invalid state for configuration

#define GNR_OBJECT_FULL				MKERR(ERROR, COMMON, BOUNDS, 0x0e)

#define GNR_OBJECT_EMPTY			MKERR(ERROR, COMMON, BOUNDS, 0x0f)

#define GNR_OBJECT_NOT_ALLOCATED	MKERR(ERROR, COMMON, INACTIVE, 0x10)

#define GNR_OBJECT_READ_ONLY		MKERR(ERROR, COMMON, OBJECT, 0x11)

#define GNR_OBJECT_WRITE_ONLY		MKERR(ERROR, COMMON, OBJECT, 0x12)

#define GNR_OPERATION_PROHIBITED	MKERR(ERROR, COMMON, ILLEGALACCESS, 0x13)

#define GNR_OBJECT_INVALID			MKERR(ERROR, COMMON, OBJECT, 0x14)

#define GNR_INSUFFICIENT_RIGHTS	MKERR(ERROR, COMMON, ILLEGALACCESS, 0x15)

#define GNR_TIMEOUT					MKERR(ERROR, COMMON, NOACK, 0x16)

#define GNR_FILE_READ_ERROR		MKERR(ERROR, COMMON, FILEIO, 0x17)

#define GNR_FILE_WRITE_ERROR		MKERR(ERROR, COMMON, FILEIO, 0x18)

#define GNR_INVALID_PARAMETERS	MKERR(ERROR, COMMON, PARAMS, 0x19)

#define GNR_CONNECTION_LOST		MKERR(ERROR, COMMON, INACTIVE, 0x1a)

#define GNR_OPERATION_ABORTED		MKERR(ERROR, COMMON, TIMEOUT, 0x1b)

#define GNR_OPERATION_FAILED		MKERR(ERROR, COMMON, OPERATION, 0x1c )

//
// Error invocation macros, to be used to standardize erroneous returns
//
#define GNRAISE(e) return (e)
	// raise an error, store it into the global error variable, and
	// return with the error number.

#define GNRAISE_OK return GNR_OK
	// raise the OK error, all did well

//#define GNRAISE_AGAIN return LastError
	// raise the last error again

#define GNASSERT(cond, except) if (cond) GNRAISE(except); else	0
	// if the condition evaluates to true, the exception is raised

#define GNREASSERT(cond) if (1) {Error e; if (e = (cond)) GNRAISE(e);} else 0
	// if the condition evaluates to not OK, the error is raised again

#define GNREASSERTMAP(cond, ne) if (1) {Error e; if (e = (cond)) GNRAISE(ne);} else 0
	// if the condition evaluates to not OK, the error ne is returned

#ifndef ONLY_EXTERNAL_VISIBLE


#ifdef _WINDOWS

class NamedError {
	private:
		Error				error;
		NamedError	*	link;
		WORD				id;
		static	NamedError	*	root;
	friend void GetErrorText(HINSTANCE hinst, Error error, TCHAR __far * buffer, int bufferSize);
	public:
		NamedError(Error error, WORD id) {this->error = error; this->id = id; this->link = root; root = this;}
	};

#define NAME_ERROR(err, text)	static const NamedError GNRI_##err(GNR_##err, IDS_GNR_##err)

void GetErrorText(HINSTANCE hinst, Error error, TCHAR __far * buffer, int bufferSize);

#elif LINUX

class NamedError {
	private:
		Error				error;
		NamedError	*	link;
		const char 	*	name;
		static	NamedError	*	root;
	friend void GetErrorText(Error error, TCHAR __far * buffer, int bufferSize);
	public:
		NamedError(Error error, const char * name) {this->error = error; this->name = name; this->link = root; root = this;}
	};

#define NAME_ERROR(err, text)	static const NamedError GNRI_##err(GNR_##err, text)

void GetErrorText(Error error, TCHAR __far * buffer, int bufferSize);

#else

#if VXD_VERSION || WDM_VERSION

#define NAME_ERROR(err, text)
const char * GetErrorText(Error error);

#else
class NamedError {
	private:
		Error				error;
		NamedError	*	link;
		const char 	*	name;
		static	NamedError	*	root;
	friend const char * GetErrorText(Error error);
	public:
		NamedError(Error error, const char * name) {this->error = error; this->name = name; this->link = root; root = this;}
	};

#define NAME_ERROR(err, text)	static const NamedError GNRI_##err(GNR_##err, text)

const char * GetErrorText(Error error);
#endif	// of VXD_VERSION

#endif	// of _WINDOWS

#endif	// of ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\KRNLFLT.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlflt.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
//

#ifndef KRNLFLT_H
#define KRNLFLT_H

#include "prelude.h"
#include "krnlstr.h"

class KernelFloat
	{
	private:
		unsigned long	mantisse;
		short	exponent;
		short sign;

		void Normalize(void);
		KernelFloat(unsigned long mantisse, short exponent, short sign);
	public:
		KernelFloat(void);
		KernelFloat(long val, unsigned long frac = 0, short exp = 0);
		KernelFloat(const KernelString u);

		KernelString ToString(int digits = 0, BOOL exp = FALSE);

		long Trunc(void);

		friend KernelFloat operator+ (const KernelFloat u, const KernelFloat v);
		friend KernelFloat operator* (const KernelFloat u, const KernelFloat v);
		friend KernelFloat operator- (const KernelFloat u, const KernelFloat v);
		friend KernelFloat operator/ (const KernelFloat u, const KernelFloat v);

		KernelFloat & operator+= (const KernelFloat u);
		KernelFloat & operator*= (const KernelFloat u);
		KernelFloat & operator/= (const KernelFloat u);
		KernelFloat & operator-= (const KernelFloat u);

		KernelFloat operator- (void) const;

		int Compare(const KernelFloat u) const;

		friend BOOL operator==(const KernelFloat u, const KernelFloat v);
		friend BOOL operator!=(const KernelFloat u, const KernelFloat v);
		friend BOOL operator<(const KernelFloat u, const KernelFloat v);
		friend BOOL operator>(const KernelFloat u, const KernelFloat v);
		friend BOOL operator<=(const KernelFloat u, const KernelFloat v);
		friend BOOL operator>=(const KernelFloat u, const KernelFloat v);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\krnlhash.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:			library\common\krnlhash.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1999 Viona Development.  All Rights Reserved.
// CREATED:		1999-11-09
//
// PURPOSE:		Hashing table for Kernelstring key hashing
//
// HISTORY:		Created 1999-11-09 Ulrich Mohr
//

#ifndef _KRNLHASH_H_
#define _KRNLHASH_H_

#include "library/common/krnlstr.h"
#include "library/general/iterator.h"

#define defaultHashTableSize 32


// Entry in Kernel Hash list....

class KernelHash;

class HashNode
	{
	friend class KernelHash;
	friend class HashIterator;

	protected:
		KernelString key;
		HashNode * next;
		HashNode(KernelString key);
		HashNode(HashNode &);
	};

typedef HashNode * HashNodePtr;


// Kernel Hash class...

class KernelHash : public IteratorHost
	{
	friend class HashIterator;
	private:
		HashNode ** hashTable;
	protected:
		DWORD hashTableSize;
		// hash fuction....
		DWORD Hash(KernelString key);
	public:
		// Constructor ....
		KernelHash(DWORD hashTableSize = defaultHashTableSize);
		// Copy constructor ...
		KernelHash(KernelHash &);

		// Destructor ....
		~KernelHash();

		bool Enter(HashNode * pHash, KernelString key);
		HashNode* Remove(KernelString key);
		HashNode* LookUp(KernelString key);

		Iterator * CreateIterator(void);
	};


// Kernel Hash Iterator class...

class HashIterator : public Iterator
	{
	private:
		HashNode * nextNode;
		KernelHash * hashTable;
		DWORD searchIndex;
	public:
		HashIterator(KernelHash * pHash);
		APTR Proceed(void);
		~HashIterator(void) {}
	};

#endif // _KRNLHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\krnlint.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlint.cpp
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#include "KrnlInt.h"



KernelInt64 operator* (const KernelInt64 u, const KernelInt64 v)
	{
	BOOL sign;
	DWORD ll0, ll1, lh, hl, dummy;
	KernelInt64 u1, v1;

	if (u < 0)
		{
		u1 = -u;
		sign = TRUE;
		}
	else
		{
		u1 = u;
		sign = FALSE;
		}

	if (v < 0)
		{
		v1 = -v;
		sign = !sign;
		}
	else
		{
		v1 = v;
		}

	MUL32x32(v1.lower, u1.lower, ll1, ll0);
	MUL32x32(v1.lower, u1.upper, dummy, lh);
	MUL32x32(v1.upper, u1.lower, dummy, hl);

	if (sign)
		return -KernelInt64(ll0, lh+hl+ll1);
	else
		return KernelInt64(ll0, lh+hl+ll1);
	}

KernelInt64 operator/ (const KernelInt64 u, const KernelInt64 v)
	{
	BOOL sign;
	KernelInt64 u1, v1, acc;
	DWORD a0, a1, a2;

	if (u < 0)
		{
		u1 = -u;
		sign = TRUE;
		}
	else
		{
		u1 = u;
		sign = FALSE;
		}

	if (v < 0)
		{
		v1 = -v;
		sign = !sign;
		}
	else
		{
		v1 = v;
		}

	if (v1 != 0)
		{
		if (v1.upper)
			{
			if (u1.upper <= v1.upper)
				{
				a0 = u1.upper / v1.upper;
				MUL32x32(a0, v1.lower, a1, a2);
				a2 += a0 * v1.upper;
				acc = KernelInt64(a1, a2);
				if (acc > u1) a0--;

				acc = KernelInt64(a0, 0L);
				}
			else
				acc = 0;
			}
		else
			{
			if ((unsigned long)u1.upper < v1.lower)
				{
				a0 = DIV64x32(u1.upper, u1.lower, v1.lower);
				acc = KernelInt64(a0, 0L);
				}
			else
				{
				a0 = u1.upper / v1.lower;
				a1 = DIV64x32(u1.upper % v1.lower, u1.lower, v1.lower);
				acc = KernelInt64(a1, a0);
				}
			}
		if (sign)
			return -acc;
		else
			return acc;
		}
	else
		{
		if (sign)
			return KernelInt64(0x00000000, 0x80000000);
		else
			return KernelInt64(0xffffffff, 0x7fffffff);
		}
	}

KernelInt64::KernelInt64(KernelString str, int base)
	{
	int i = 0;
	BOOL sign = FALSE;
	TCHAR c;

	*this = 0;

	if (str[0] == '-')
		{
		sign = TRUE;
		i++;
		}

	while (c = str[i++])
		{
		*this *= base;

		if (c >= __TEXT('a') && c <= __TEXT('f'))
			*this += c - __TEXT('a') + 10;
		else if (c >= __TEXT('A') && c <= __TEXT('F'))
			*this += c - __TEXT('A') + 10;
		else if (c >= __TEXT('0') && c <= __TEXT('9'))
			*this += c - __TEXT('0');
		}

	if (sign)
		*this = -*this;
	}

KernelString KernelInt64::ToString(int digits, int base, TCHAR fill)
	{
	KernelString s;
	KernelInt64 a;
	BOOL sign;

	if (*this < 0)
		{
		a = -*this;
		sign = TRUE;
		}
	else
		{
		a = *this;
		sign = FALSE;
		}

	if (a == 0)
		{
		s = __TEXT("0");
		}
	else
		{
		while (a > 0)
			{
			int val = (a % base).ToLong();

			if (val < 10)
				s = KernelString((TCHAR)(__TEXT('0') + val)) + s;
			else
				s = KernelString((TCHAR)(__TEXT('A') + val - 10)) + s;

			a = a / base;
			}
		}

	if (sign)
		s = KernelString(__TEXT('-')) + s;

	if (digits)
		{
		while (s.Length() < digits) s = KernelString(fill) + s;
		}

	return s;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\KrnlInt.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlint.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#ifndef KRNLINT_H
#define KRNLINT_H

#include "prelude.h"
#include "KrnlStr.h"


//
// REMARK:
// This class is passed through DLLs.
// So please:
//        - insert member variables only at the end of the class declaration
//			 - do not append virutal methods
//
// occures in krnlint.h


// this defines a new data type as a class, the KernelInt64 type,
// a 64-Bit-Integer data type for all integer arithmetics
class __far KernelInt64
	{
	private:
      // upper 32 bit
		unsigned long lower;
      // lower 32 bit
		signed long upper;
	public:

      // empty constructor sets value to ZERO
		KernelInt64(void) {lower = 0; upper = 0;}

      // DWORD constructor, generates a 64-bit value from an 32 DWORD
      KernelInt64(DWORD val) {lower = val; upper = 0;}

      // long constructor (32 bit with sign)
		// upper 32 bit part carries sign
      KernelInt64(long val) {lower = val; upper = val < 0 ? -1 : 0;}

      // int constructor, same effect as for long value
      // i.e. upper 32 bit carry also sign
		KernelInt64(int val) {lower = val; upper = val < 0 ? -1 : 0;}
      // same for positive values, upper 32 bit are ZERO
		KernelInt64(unsigned int val) {lower = val; upper =  0;}
      // copy constructor
      // dublicates value
      KernelInt64(const KernelInt64 & val) {lower = val.lower; upper = val.upper;}

      // assignment operator
      KernelInt64 & operator= (const KernelInt64 val) {lower = val.lower; upper = val.upper; return *this;}

      // constructor:  a 64 bit value out of 2 32 bit int parts
		KernelInt64(unsigned long lower, int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned int lower, int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(int lower, unsigned int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(int lower, int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(int lower, long upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned int lower, unsigned int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned long lower, unsigned int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned long lower, unsigned long upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned long lower, signed long upper) {this->lower = lower; this->upper = upper;}

		KernelInt64(KernelString str, int base = 10);
		KernelString ToString(int digits = 0, int base = 10, TCHAR fill = __TEXT('0'));

      // convert 64bit value to 32 bit long/DWORD/Int value with saturation
      // i.e in case of an overflow a predefined value is retruned

		long ToLong(void)
			{
			if      (upper == 0x00000000 && !(lower & 0x80000000)) return lower;
			else if (upper == 0xffffffff &&  (lower & 0x80000000)) return lower;
			else if (upper < 0) return 0x8000000;
			else return 0x7fffffff;
			}

		DWORD ToDWORD(void)
			{
			if (upper < 0) return 0;
			else if (upper > 0) return 0xffffffff;
			else return lower;
			}

		int ToInt(void)
			{
			if (*this < -32768) return -32768;
			else if (*this > 32767) return 32767;
			else return (int)lower;
			}

#if NT_KERNEL
		LONGLONG ToLongLong(void)
			{
			LARGE_INTEGER li;

			li.LowPart = lower;
			li.HighPart = upper;

			return li.QuadPart;
			}
#endif

      // return upper or lower part of 64 bit values
		DWORD Lower(void) {return lower;}
		long Upper(void) {return upper;}

      // The logical-negation (logical-NOT) operator produces the value 0 if its operand
      // is true (nonzero) and the value 1 if its operand is false (0). The result has int type.
      // The operand must be an integral, floating, or pointer value.
		inline int operator! (void) const {return !lower && !upper;}

      // minus operator
		inline KernelInt64 operator- (void) const;

      // The one's complement operator, sometimes called the "bitwise complement" or "bitwise NOT"
      // operator, produces the bitwise one's complement of its operand. The operand must be of
      // integral type. This operator performs usual arithmetic conversions; the result has the
      // type of the operand after conversion.
		inline KernelInt64 operator~ (void) const {return KernelInt64(~lower, ~upper);}

      // FRIEND
      // The friend keyword allows a function or class to gain access to the private
      // and protected members of a class. In some circumstances, it is more convenient to grant
      // member-level access to functions that are not members of a class or to all functions in
      // a separate class. With the friend keyword, programmers can designate either the specific
      // functions or the classes whose functions can access not only public members but also protected
      // and private members


      // integer arithmetic operators for different input types/vaiations
		inline friend KernelInt64 operator+ (const KernelInt64 u, const KernelInt64 v);
		inline friend KernelInt64 operator- (const KernelInt64 u, const KernelInt64 v);
		inline friend KernelInt64 operator+ (const long u, const KernelInt64 v);
		inline friend KernelInt64 operator- (const long u, const KernelInt64 v);
		inline friend KernelInt64 operator+ (const KernelInt64 u, const long v);
		inline friend KernelInt64 operator- (const KernelInt64 u, const long v);
		friend KernelInt64 operator* (const KernelInt64 u, const KernelInt64 v);
		friend KernelInt64 operator/ (const KernelInt64 u, const KernelInt64 v);
		inline friend KernelInt64 operator% (const KernelInt64 u, const KernelInt64 v);

		inline KernelInt64 & operator+= (const KernelInt64 u);
		inline KernelInt64 & operator-= (const KernelInt64 u);
		inline KernelInt64 & operator+= (const long u);
		inline KernelInt64 & operator-= (const long u);
		inline KernelInt64 & operator*= (const KernelInt64 u);
		inline KernelInt64 & operator/= (const KernelInt64 u);
		inline KernelInt64 & operator%= (const KernelInt64 u);

		inline KernelInt64 & operator++ (void);
		inline KernelInt64 & operator-- (void);

      // shift operators
		inline friend KernelInt64 operator << (const KernelInt64 u, const int shl);
		inline friend KernelInt64 operator >> (const KernelInt64 u, const int shl);

		inline KernelInt64 & operator <<= (const int shl);
		inline KernelInt64 & operator >>= (const int shl);

		inline int Compare(const KernelInt64 u) const;

		friend BOOL operator==(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) == 0;}
		friend BOOL operator!=(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) != 0;}
		friend BOOL operator<(const KernelInt64 u, const KernelInt64 v)  {return u.Compare(v) < 0;}
		friend BOOL operator>(const KernelInt64 u, const KernelInt64 v)  {return u.Compare(v) > 0;}
		friend BOOL operator<=(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) <= 0;}
		friend BOOL operator>=(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) >= 0;}

		friend KernelInt64 operator& (const KernelInt64 u, const KernelInt64 v) {return KernelInt64(u.lower & v.lower, u.upper & v.upper);}
		friend KernelInt64 operator| (const KernelInt64 u, const KernelInt64 v) {return KernelInt64(u.lower | v.lower, u.upper | v.upper);}

		KernelInt64 & operator&= (const KernelInt64 u) {lower &= u.lower; upper &= u.upper; return *this;}
		KernelInt64 & operator|= (const KernelInt64 u) {lower |= u.lower; upper |= u.upper; return *this;}
	};

inline KernelInt64 & KernelInt64::operator+= (const KernelInt64 u)
	{
	lower += u.lower;
   // check and propagare overflow from lower part up to upper part
	if (lower < u.lower)
      // overflow
		upper += u.upper+1;
	else
      // no overflow
		upper += u.upper;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator-= (const KernelInt64 u)
	{
	unsigned long sum = lower - u.lower;

   // check and propagare overflow from lower part up to upper part
	if (sum > lower)
      // overflow...
		upper -= u.upper+1;
	else
      // none...
		upper -= u.upper;
	lower = sum;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator+= (const long u)
	{
   // check sign of u
	if (u < 0)
      // already use new defined -= operator (see above) and negation operator
      // to invert and subtract u from this (type KernelInt64)
		*this -= -u;
	else
		{
		lower += u;
      // check overflow and eventually propagate it to upper part
		if (lower < (DWORD)u)
         // yes, overflow
			upper += 1;
		}
	return *this;
	}

inline KernelInt64 & KernelInt64::operator++ (void)
	{
	lower ++;
	if (!lower)
      // pass on overflow upwards...
		upper ++;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator-- (void)
	{
   // check overflow
	if (!lower)
      // .. and paas on
		upper --;
	lower --;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator-= (const long u)
	{
	if (u < 0)
		*this += -u;
	else
		{
      // check and handle overflow
		unsigned long sum = lower - u;
		if (sum > lower)
         // propagate overflow
			upper -= 1;
		lower = sum;
		}
	return *this;
	}


// the following additions and subtractions is rearranged from the add/sub of two KernelInto64 objects
// with each having an upper and lower part to a separate addition of the lower part
// then passing the result to another add/sub  of the two added/subtracted lower parts with the
// added/subtracted upper parts


// add two KernelInt64 objects
inline KernelInt64 operator+ (const KernelInt64 u, const KernelInt64 v)
	{
   // add into temporary var
	unsigned long sum = u.lower + v.lower;
   // check overflow from lower to upper
	if (sum < u.lower)
      // overflow, so add one to pass this on
		return KernelInt64(sum, u.upper + v.upper + 1);
	else
      // no overflow
		return KernelInt64(sum, u.upper + v.upper);
	}

inline KernelInt64 operator- (const KernelInt64 u, const KernelInt64 v)
	{
	unsigned long sum = u.lower - v.lower;
	if (sum > u.lower)
      // overflow
		return KernelInt64(sum, u.upper - v.upper - 1);
	else
      // no overflow
		return KernelInt64(sum, u.upper - v.upper);
	}

inline KernelInt64 operator+ (const KernelInt64 u, const long v)
	{
	if (v < 0)
		return u - -v;
	else
		{
		unsigned long sum = u.lower + v;
		if (sum < u.lower)
			return KernelInt64(sum, u.upper + 1);
		else
			return KernelInt64(sum, u.upper);
		}
	}

inline KernelInt64 operator- (const KernelInt64 u, const long v)
	{
	if (v < 0)
		return u + -v;
	else
		{
		unsigned long sum = u.lower - v;
		if (sum > u.lower)
			return KernelInt64(sum, u.upper - 1);
		else
			return KernelInt64(sum, u.upper);
		}
	}


inline KernelInt64 operator+ (const long u, const KernelInt64 v)
	{
	if (u < 0)
		return v - -u;
	else
		{
		unsigned long sum = u + v.lower;
		if (sum < v.lower)
			return KernelInt64(sum, v.upper + 1);
		else
			return KernelInt64(sum, v.upper);
		}
	}

inline KernelInt64 operator- (const long u, const KernelInt64 v)
	{
   // use negation operation and addition opeartor to define minus operator
	return u + -v;
	}

inline KernelInt64 KernelInt64::operator- (void) const
	{
	if (lower == 0)
		return KernelInt64(0, -upper);
	else
		return KernelInt64((DWORD)-(long)lower, ~upper);
	}

inline int KernelInt64::Compare(const KernelInt64 u) const
	{
	if (upper < u.upper) return -1;
	else if (upper > u.upper) return 1;
	else if (lower < u.lower) return -1;
	else if (lower > u.lower) return 1;
	else return 0;
	}


// define shift operators

// left shift of KernelInt64 object for shl bits
inline KernelInt64 operator<< (const KernelInt64 u, const int shl)
	{
   // use definition of <<= operator to do this

   // first make a copy of u to do the shift with
	KernelInt64 v = u;
	v <<= shl;
	return v;
	}

// right shift of KernelInt64 object for shr bits
inline KernelInt64 operator>> (const KernelInt64 u, const int shr)
	{
   // use definition of >>= operator to do this

   // do shift with copy
	KernelInt64 v = u;
	v >>= shr;
	return v;
	}

inline KernelInt64 & KernelInt64::operator*= (const KernelInt64 u)
	{
   // use "normal" mult to do *=
	*this = *this * u;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator/= (const KernelInt64 u)
	{
   // use normal division to do /=
	*this = *this / u;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator%= (const KernelInt64 u)
	{
   // use normal modulo op to do %=
	*this = *this % u;
	return *this;
	}

inline KernelInt64 operator % (const KernelInt64 u, const KernelInt64 v)
	{
   // normal modulo op is done with / and *
	return u - (u / v) * v;
	}

inline KernelInt64 & KernelInt64::operator<<= (const int shl)
	{
	int s = shl;

   // shift data shl times left by 1
	while (s > 0)
		{
      // upper part left 1 bit, lowest bit becomes always 0
		upper <<= 1;
      // check lower part before shift: if highest bit is set, carry this to upper part
      // i.e. set lowest bit of upper part
		if (lower & 0x80000000) upper |= 1;
		lower <<= 1;
		s--;
		}

	return *this;
	}

inline KernelInt64 & KernelInt64::operator>>= (const int shl)
	{
	int s = shl;

   // lower part right by 1, highest bit becomes always 0
	while (s > 0)
		{
		lower >>= 1;
      // check lowest bit of upper part, and take carry to highest bit of lower part
		if (upper & 0x00000001) lower |= 0x80000000;
		upper >>= 1;
		s--;
		}

	return *this;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\krnllog.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnllog.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#ifndef KRNLLOG_H
#define KRNLLOG_H

#include "prelude.h"
#include "krnlstr.h"

class KernelLogger
	{
	protected:
#if NT_KERNEL
		PDRIVER_OBJECT	driver;
#endif
	public:
#if NT_KERNEL
		KernelLogger(PDRIVER_OBJECT driver);
#else
#endif
		Error LogEvent(DWORD msgID);
		Error LogEvent(DWORD msgID, KernelString ext1);
		Error LogEvent(DWORD msgID, KernelString ext1, KernelString ext2);
		Error LogEvent(DWORD msgID, KernelString ext1, KernelString ext2, KernelString ext3);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\krnlstrm.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlstrm.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#ifndef KRNLSTRM
#define KRNLSTRM

#include "prelude.h"
#include "gnerrors.h"
#include "krnlstr.h"

#if !NT_KERNEL
#include <mmsystem.h>
#endif

class KernelInputStream
	{
	private:
#if NT_KERNEL
		HANDLE		file;
#else
		HMMIO			file;
#endif
		DWORD			pos;		// position of _next_ buffer in file
		DWORD			size;		// size of file
		BYTE		*	buffer;
		WORD			bsize;	// size of buffer
		WORD			bpos;		// current byte in buffer
		WORD			bend;		// end of buffer

		Error DirectRead(FPTR buffer, DWORD size, DWORD __far & done);

	public:
		Error Open(KernelString name, WORD bufferSize = 512);
		Error Close(void);

		Error Read(FPTR buffer, DWORD size, DWORD __far & done);
		Error Read(char __far & c);
		Error Peek(char __far & c);

		Error ReadDec(BYTE __far & b);
		Error ReadDec(WORD __far & w);
		Error ReadDec(DWORD __far & d);

		Error ReadHex(BYTE __far & b);
		Error ReadHex(WORD __far & w);
		Error ReadHex(DWORD __far & d);

		BOOL EOF(void);
	};

class KernelOutputStream
	{
	private:
#if NT_KERNEL
		HANDLE		file;
#else
		HMMIO			file;
#endif
		DWORD			pos;
		BYTE		*	buffer;
		WORD			bsize, bend;

		Error DirectWrite(FPTR buffer, DWORD size, DWORD __far & done);

	public:
		Error Open(KernelString name, WORD bufferSize = 512);
		Error Close(void);

		Error Write(FPTR buffer, DWORD size, DWORD __far & done);
		Error Write(char c);

		Error WriteHex(BYTE  b);
		Error WriteHex(WORD  w);
		Error WriteHex(DWORD  d);

		Error WriteDec(DWORD d, int num);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\KrnlStr.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlstr.cpp
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#include "KrnlStr.h"

////////////////////////////////////////////////////////////////////
//
//  Kernel String Buffer Class
//
////////////////////////////////////////////////////////////////////

class KernelStringBuffer
	{
	public:
		int		useCnt;
		int		length;
		TCHAR	*	buffer;
#if NT_KERNEL
		UNICODE_STRING	us;
#endif

		KernelStringBuffer(const TCHAR __far * str);
		KernelStringBuffer(const TCHAR ch);
		KernelStringBuffer(KernelStringBuffer * u, KernelStringBuffer * v);
		KernelStringBuffer(KernelStringBuffer * u, int start, int num);
		KernelStringBuffer(KernelStringBuffer * u, int num);
		KernelStringBuffer(BOOL sign, DWORD value, int digits, int base, TCHAR fill);

		~KernelStringBuffer(void);

		int Compare(KernelStringBuffer * u);

		void Obtain(void) {useCnt++;}
		void Release(void) {if (!--useCnt) delete this;}
	};

#define WS	sizeof(TCHAR)

KernelStringBuffer::KernelStringBuffer(const TCHAR __far * str)
	{
	useCnt = 1;

	const TCHAR __far * p;
	TCHAR * q;

	length = 0;
	p = str;
	while (*p++) length++;

#if   LINUX
	buffer = new TCHAR[length+2];
#else
	buffer = new (PagedPool) TCHAR[length+2];
#endif

	p = str;
	q = buffer;

	while (*q++ = *p++) ;

#if NT_KERNEL
	RtlInitUnicodeString(&us, buffer);
#endif
	}

KernelStringBuffer::KernelStringBuffer(const TCHAR ch)
	{
	useCnt = 1;

   length = 1;

#if   LINUX
	buffer = new TCHAR[2];
#else
	buffer = new (PagedPool) TCHAR[2];
#endif

	buffer[0] = ch;
	buffer[1] = 0;

#if NT_KERNEL
	RtlInitUnicodeString(&us, buffer);
#endif
	}

KernelStringBuffer::~KernelStringBuffer(void)
	{
	if (buffer) delete[] buffer;
	}

KernelStringBuffer::KernelStringBuffer(KernelStringBuffer * u, KernelStringBuffer * v)
	{
	useCnt = 1;

	length = u->length + v->length;
	TCHAR * p, * q;

#if   LINUX
	buffer = new TCHAR[length + 1];
#else
	buffer = new (PagedPool) TCHAR[length + 1];
#endif

	p = buffer;
	q = u->buffer;
	while (*p++ = *q++);
	p--;
	q = v->buffer;
	while (*p++ = *q++);

#if NT_KERNEL
	RtlInitUnicodeString(&us, buffer);
#endif
	}

KernelStringBuffer::KernelStringBuffer(KernelStringBuffer * u, int start, int num)
	{
	int i;

	useCnt = 1;

	length = u->length - start;
	if (length > num) length = num;
	TCHAR * p, * q;

#if   LINUX
	buffer = new TCHAR[length + 1];
#else
	buffer = new (PagedPool) TCHAR[length + 1];
#endif

	p = buffer;
	q = u->buffer + start;

	for(i=0; i<length; i++) *p++ = *q++;

	*p = 0;

#if NT_KERNEL
	RtlInitUnicodeString(&us, buffer);
#endif
	}

KernelStringBuffer::KernelStringBuffer(KernelStringBuffer * u, int num)
	{
	int i;

	useCnt = 1;

	length = u->length * num;
	TCHAR * p, * q;

#if   LINUX
	buffer = new TCHAR[length + 1];
#else
	buffer = new (PagedPool) TCHAR[length + 1];
#endif

	p = buffer;
	for(i=0; i<num; i++)
		{
		q = u->buffer;
		while (*p++ = *q++);
		p--;
		}
	p++;

#if NT_KERNEL
	RtlInitUnicodeString(&us, buffer);
#endif
	}

KernelStringBuffer::KernelStringBuffer(BOOL sign, DWORD value, int digits, int base, TCHAR fill)
	{
	TCHAR lbuffer[12];
	int pos = digits;
	int i;

	useCnt = 1;

	if (!pos) pos = 10;

	do {
		i = (int)(value % base);

		if (i < 10)
			lbuffer[--pos] = __TEXT('0') + i;
		else
			lbuffer[--pos] = __TEXT('A') + i - 10;

		value /= base;
		} while (value && pos);

	if (digits)
		{
#if   LINUX
		buffer = new TCHAR[digits + 1];
#else
		buffer = new (PagedPool) TCHAR[digits + 1];
#endif

		for(i=0; i<pos; i++) buffer[i] = fill;
		if (sign) buffer[0] = __TEXT('-');
		for(i=pos; i<digits; i++) buffer[i] = lbuffer[i];
		buffer[digits] = 0;
		length = digits;
		}
	else
		{
		if (sign)
			{
#if   LINUX
			buffer = new TCHAR[10 - pos + 2];
#else
			buffer = new (PagedPool) TCHAR[10 - pos + 2];
#endif
			buffer[0] = __TEXT('-');
			i = 1;
			length = 10 - pos + 1;
			}
		else
			{
#if   LINUX
			buffer = new TCHAR[10 - pos + 1];
#else
			buffer = new (PagedPool) TCHAR[10 - pos + 1];
#endif
			i = 0;
			length = 10 - pos;
			}

		while (pos < 10)
			{
			buffer[i++] = lbuffer[pos++];
			}
		buffer[i] = 0;
		}
	}


int KernelStringBuffer::Compare(KernelStringBuffer * u)
	{
#if NT_KERNEL
	return RtlCompareUnicodeString(&us, &(u->us), FALSE);
#else
	TCHAR * p, * q;
	TCHAR cp, cq;

	p = buffer;
	q = u->buffer;

	do {
		cp = *p++;
		cq = *q++;
		if (cp < cq)
			return -1;
		else if (cp > cq)
			return 1;
		} while (cp);

	return 0;
#endif
	}

////////////////////////////////////////////////////////////////////
//
//  Kernel String Class
//
////////////////////////////////////////////////////////////////////

KernelString::KernelString(void)
	{
	buffer = NULL;
	}

KernelString::KernelString(const TCHAR __far * str)
	{
	buffer = new (PagedPool) KernelStringBuffer(str);
	}

KernelString::KernelString(const TCHAR ch)
	{
	buffer = new (PagedPool) KernelStringBuffer(ch);
	}

#if NT_KERNEL

KernelString::KernelString(const UNICODE_STRING & str)
	{
	buffer = new (PagedPool) KernelStringBuffer(str.Buffer);
	}

#endif

KernelString::KernelString(int value, int digits, int base, TCHAR fill)
	{
	if (value < 0)
		buffer = new (PagedPool) KernelStringBuffer(TRUE, (DWORD)(-value), digits, base, fill);
	else
		buffer = new (PagedPool) KernelStringBuffer(FALSE, (DWORD)(value), digits, base, fill);
	}



KernelString::KernelString(DWORD value, int digits, int base, TCHAR fill)
	{
	buffer = new (PagedPool) KernelStringBuffer(FALSE, value, digits, base, fill);
	}

KernelString::KernelString(const KernelString & str)
	{
	buffer = str.buffer;
	if (buffer) buffer->Obtain();
	}

KernelString::~KernelString(void)
	{
	if (buffer) buffer->Release();
	}


int KernelString::Length(void) const
	{
	if (buffer)
		return buffer->length;
	else
		return 0;
	}


long KernelString::ToInt(int base)
	{
	long val = 0;
	BOOL sign;
	TCHAR c, * p;

	if (buffer && buffer->length)
		{
		p = buffer->buffer;
		if (*p == __TEXT('-'))
			{
			sign = TRUE;
			p++;
			}
		else
			sign = FALSE;

		while (c = *p++)
			{
			if      (c >= __TEXT('0') && c <= __TEXT('9')) val = val * base + c - __TEXT('0');
			else if (c >= __TEXT('a') && c <= __TEXT('f')) val = val * base + c - __TEXT('a') + 10;
			else if (c >= __TEXT('A') && c <= __TEXT('F')) val = val * base + c - __TEXT('A') + 10;
			else return 0;
			}

		if (sign)
			return -val;
		else
			return val;
		}
	else
		return 0;
	}

DWORD KernelString::ToUnsigned(int base)
	{
	DWORD val = 0;
	TCHAR c, * p;

	if (buffer && buffer->length)
		{
		p = buffer->buffer;

		while (c = *p++)
			{
			if (c>=__TEXT('0') && c<= __TEXT('9')) val = val * base + c - __TEXT('0');
			else if (c>=__TEXT('a') && c<=__TEXT('f')) val = val * base + c - __TEXT('a') + 10;
			else if (c>=__TEXT('A') && c<=__TEXT('F')) val = val * base + c - __TEXT('A') + 10;
			else return 0;
			}

		return val;
		}
	else
		return 0;
	}

BOOL KernelString::Get(TCHAR __far * str, int len)
	{
	TCHAR __far * p, * q;
	if (buffer)
		{
		if (len > buffer->length)
			{
			p = str;
			q = buffer->buffer;

			while (*p++ = * q++);

			return TRUE;
			}
		else
			return FALSE;
		}
	else if (len > 0)
		{
		str[0] = 0;

		return TRUE;
		}
	else
		return FALSE;
	}

#if NT_KERNEL

BOOL KernelString::Get(UNICODE_STRING & us)
	{
	RtlCopyUnicodeString(&us, &(buffer->us));

	return TRUE;
	}

#endif

KernelString & KernelString::operator= (const TCHAR __far * str)
	{
	if (buffer) buffer->Release();
	buffer = new (PagedPool) KernelStringBuffer(str);
	return * this;
	}

#if NT_KERNEL

KernelString & KernelString::operator= (const UNICODE_STRING & str)
	{
	if (buffer) buffer->Release();
	buffer = new (PagedPool) KernelStringBuffer(str.Buffer);
	return * this;
	}

#endif

KernelString & KernelString::operator= (const KernelString str)
	{
	if (buffer) buffer->Release();
	buffer = str.buffer;
	if (buffer) buffer->Obtain();

	return * this;
	}

KernelString operator+ (const KernelString u, const KernelString v)
	{
	KernelString str = u;
	str += v;
	return str;
	}

KernelString & KernelString::operator += (const KernelString u)
	{
	KernelStringBuffer * bp;

	if (buffer)
		{
		if (u.buffer)
			{
			bp = new (PagedPool) KernelStringBuffer(buffer, u.buffer);
			buffer->Release();
			buffer = bp;
			}
		}
	else
		{
		buffer = u.buffer;
		if (buffer) buffer->Obtain();
		}
	return *this;
	}

KernelString operator* (const KernelString u, const int num)
	{
	KernelString str = u;
	str *= num;
	return str;
	}

KernelString & KernelString::operator *= (const int num)
	{
	KernelStringBuffer * bp;

	if (buffer)
		{
		if (num)
			{
			bp = new (PagedPool) KernelStringBuffer(buffer, num);
			buffer->Release();
			buffer = bp;
			}
		else
			{
			buffer->Release();
			buffer = NULL;
			}
		}

	return *this;
	}

int KernelString::Compare(const KernelString str)
	{
	if (buffer == str.buffer)
		return 0;
	else if (!buffer)
		return -1;
	else if (!str.buffer)
		return 1;
	else
		return buffer->Compare(str.buffer);
	}

BOOL operator==(const KernelString u, const KernelString v)
	{
	return ((KernelString)u).Compare(v) == 0;
	}

BOOL operator!=(const KernelString u, const KernelString v)
	{
	return ((KernelString)u).Compare(v) != 0;
	}

BOOL operator<=(const KernelString u, const KernelString v)
	{
	return ((KernelString)u).Compare(v) <= 0;
	}

BOOL operator>=(const KernelString u, const KernelString v)
	{
	return ((KernelString)u).Compare(v) >= 0;
	}

BOOL operator<(const KernelString u, const KernelString v)
	{
	return ((KernelString)u).Compare(v) < 0;
	}

BOOL operator>(const KernelString u, const KernelString v)
	{
	return ((KernelString)u).Compare(v) > 0;
	}

TCHAR & KernelString::operator[] (const int index)
	{
	static TCHAR dummy;

	if (buffer)
		return buffer->buffer[index];
	else
		return dummy;
	}

const TCHAR & KernelString::operator[] (const int index) const
	{
	static TCHAR dummy;

	if (buffer)
		return buffer->buffer[index];
	else
		return dummy;
	}

KernelString operator >> (const KernelString u, int num)
	{
	KernelString str = u;
	str >>= num;

	return str;
	}

KernelString operator << (const KernelString u, int num)
	{
	KernelString str = u;
	str <<= num;

	return str;
	}

KernelString & KernelString::operator <<= (int index)
	{
	KernelStringBuffer * pb;

	if (buffer)
		{
		if (index < buffer->length)
			pb = new (PagedPool) KernelStringBuffer(buffer, index, buffer->length-index);
		else
			pb = NULL;

		buffer->Release();
		buffer = pb;
		}

	return * this;
	}

KernelString & KernelString::operator >>= (int index)
	{
	KernelStringBuffer * pb;

	if (buffer)
		{
		if (index < buffer->length)
			pb = new (PagedPool) KernelStringBuffer(buffer, 0, buffer->length-index);
		else
			pb = NULL;

		buffer->Release();
		buffer = pb;
		}

	return * this;
	}

KernelString KernelString::Seg(int start, int num) const
	{
	KernelString str;

	if (buffer)
		{
		if (start+num > buffer->length) num = buffer->length-start;
		if (num > 0)
			str.buffer = new (PagedPool) KernelStringBuffer(buffer, start, num);
		}

	return str;
	}

//
//  Return first num characters
//

KernelString KernelString::Head(int num) const
	{
	KernelString str;

	if (buffer && num > 0)
		{
		if (num > buffer->length)
			num = buffer->length;

		str.buffer = new (PagedPool) KernelStringBuffer(buffer, 0, num);
		}

	return str;
	}

//
//  Return last num characters
//

KernelString KernelString::Tail(int num) const
	{
	KernelString str;

	if (buffer && num > 0)
		{
		if (num <= buffer->length)
			str.buffer = new (PagedPool) KernelStringBuffer(buffer, buffer->length - num, num);
		else
			str.buffer = new (PagedPool) KernelStringBuffer(buffer, 0, num);
		}

	return str;
	}

//
//  Delete whitespaces at beginning or end of string
//

KernelString KernelString::Trim()
	{
	int i = 0;
	KernelString str = *this;

	// delete leading tabs and spaces...
	i = 0;
	while ((str[i] == ' ') || (str[i] == '\t'))
		i++;
	str <<= i;


	// delete preceding tabs and spaces ...
	i = str.Length()-1;
	while ((str[i] == ' ') || (str[i] == '\t'))
		i--;
	str = str.Seg(0, i+1);

	return str;
	}

//
//  Return upper case version of string
//

KernelString KernelString::Caps(void)
	{
	KernelString str;
	int i;
	TCHAR c;

	str = *this;

	for(i=0; i<str.Length(); i++)
		{
		c = str[i];
		if (c >= __TEXT('a') && c <= __TEXT('z'))
			str[i] = c + __TEXT('A') - __TEXT('a');
		}

	return str;
	}

//
//  Find first occurrence of str
//

int KernelString::First(KernelString str) const
	{
	int i;
	i = 0;

	while (i<= Length()-str.Length() && Seg(i, str.Length()) != str)
		i++;

	return i;
	}

//
//  Find next occurrence of str
//

int KernelString::Next(KernelString str, int pos) const
	{
	int i;
	i = pos+1;

	while (i<= Length()-str.Length() && Seg(i, str.Length()) != str)
		i++;

	return i;
	}

//
//  Find last occurrence of str
//

int KernelString::Last(KernelString str) const
	{
	int i;
	i = Length()-str.Length();

	while (i>=0 && Seg(i, str.Length()) != str)
		i--;

	return i;
	}

//
//  Find previous occurrence of str
//

int KernelString::Prev(KernelString str, int pos) const
	{
	int i;
	i = pos-1;

	while (i>=0 && Seg(i, str.Length()) != str)
		i--;

	return i;
	}

//
//  Find first occurrence of c (-1 if not found)
//

int KernelString::First(TCHAR c) const
	{
	int i = 0;

	if (buffer)
		{
		while (i < Length())
			{
			if (buffer->buffer[i] == c)
				return i;

			i++;
			}
		}

	return -1;
	}

//
//  Find next occurrence of c (length if not found)
//

int KernelString::Next(TCHAR c, int pos) const
	{
	int i = 0;

	if (buffer)
		{
		i = pos + 1;
		while (i < Length())
			{
			if (buffer->buffer[i] == c)
				return i;

			i++;
			}
		}

	return i;
	}

//
//  Find last occurrence of c (length if not found)
//

int KernelString::Last(TCHAR c) const
	{
	int i = 0;

	if (buffer)
		{
		i = Length() - 1;
		while (i >= 0)
			{
			if (buffer->buffer[i] == c)
				return i;

			i--;
			}
		}

	return i;
	}

//
//  Find previous occurrence of c (-1 if not found)
//

int KernelString::Prev(TCHAR c, int pos) const
	{
	int i = 0;

	if (buffer)
		{
		i = pos - 1;
		while (i >= 0)
			{
			if (buffer->buffer[i] == c)
				return i;

			i--;
			}
		}

	return -1;
	}

//
//  Test if string contains c
//

BOOL KernelString::Contains(TCHAR c) const
	{
	int i;

	if (buffer)
		{
		for (i=0; i<Length(); i++)
			{
			if (buffer->buffer[i] == c)
				return TRUE;
			}
		}

	return FALSE;
	}

#if NT_KERNEL

KernelString::operator UNICODE_STRING * (void)
	{
	return &(buffer->us);
	}

KernelString::operator UNICODE_STRING & (void)
	{
	return buffer->us;
	}

#else

KernelString::operator TCHAR * (void)
	{
	if (buffer)
		return buffer->buffer;
	else
		return NULL;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\krnlsync.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlsync.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#ifndef KRNLSYNC_H
#define KRNLSYNC_H

#include "prelude.h"





class IRQMutex
	{
	private:
#if NT_KERNEL
		KSPIN_LOCK	lock;
		KEVENT		event;
		BOOL			block;
		KIRQL			irql;
		BOOL			atIRQLevel;
#else
		volatile	BOOL	lock;
		BOOL				irq;
#endif
	public:
		IRQMutex(void);

		void Enter(void);
		void Leave(void);

		void EnterAtIRQLevel(void);
		void LeaveAtIRQLevel(void);
	};



class VDMutex
	{
	private:
#if   !NT_KERNEL && !VXD_VERSION
		int		count;
		int		requested;
		HANDLE	mutex;
#endif
	public:
		VDMutex(void);
		VDMutex(LPCTSTR name);
		~VDMutex(void);

		void Enter(void);
		void Leave(void);
	};

#if !NT_KERNEL && !VXD_VERSION
class VDLocalMutex
	{
	private:
		CRITICAL_SECTION	lock;
	public:
		VDLocalMutex(void) {InitializeCriticalSection(&lock);}
		~VDLocalMutex(void) {DeleteCriticalSection(&lock);}

		void Enter(void) {EnterCriticalSection(&lock);}
		void Leave(void) {LeaveCriticalSection(&lock);}
	};
#else
typedef VDMutex	VDLocalMutex;
#endif

class VDAutoMutex
	{
	protected:
		VDLocalMutex	*	mutex;
	public:
		VDAutoMutex(VDLocalMutex	*	mutex)
			{
			this->mutex = mutex;
			mutex->Enter();
			}

		~VDAutoMutex(void)
			{
			mutex->Leave();
			}
	};



class VDSemaphore
	{
	protected:
#if !NT_KERNEL && !VXD_VERSION
		HANDLE	sema;
#endif
	public:
		VDSemaphore (void);
		virtual ~VDSemaphore (void);

		virtual void Reset (void);
		virtual void Signal (void);
		virtual void Wait (void);
	};

class VDTimedSemaphore : public VDSemaphore
	{
	public:
		VDTimedSemaphore (void);
		virtual ~VDTimedSemaphore (void);

		virtual void Reset (void);
		virtual void Wait (void);

		void WaitTimeout (DWORD time, BOOL & timeout); // time in microsecs
	};



class VDCriticalSection
	{
	private:
		BOOL		scheduled;
		WORD		cnt;
#if NT_KERNEL
		KMUTEX	mutex;
#endif
	protected:
		virtual void CriticalSection(void) = 0;
	public:
		VDCriticalSection(void);

		void EnterSection(void);
		void LeaveSection(void);

		void ScheduleSection(void);
	};



#if !NT_KERNEL && !VXD_VERSION

extern VDMutex	VDWin16Mutex;

#endif



// This class provides multitasking- and multiprocessing-safe variables.

class InterlockedLong
	{
	private:
		LONG value;


	public:
		InterlockedLong (void)
			{
			value = 0;
			}

		InterlockedLong (LONG value)
			{
			this->value = value;
			}

		~InterlockedLong (void)
			{
			}

		void Increment (void)
			{
#if NT_KERNEL
			InterlockedIncrement (&value);
#else
			InterlockedIncrement (&value);
#endif
			}

		void Decrement (void)
			{
#if NT_KERNEL
			InterlockedDecrement (&value);
#else
			InterlockedDecrement (&value);
#endif
			}

		void SetValue (LONG newValue) {value = newValue;}

		LONG GetValue (void)
			{
			return value;
			}
	};



class VDIRQSafeSpinLock
	{
	private:
#if NT_KERNEL
		KIRQL			oldIRQLevel;
		LONG			lockVar;
#elif !VXD_VERSION
		int			count;
		BOOL			irqDisabled;
#endif
		BOOL			inIRQ;
	protected:
#if !NT_KERNEL && !VXD_VERSION
		void EnableLock(void);
		BOOL DisableLock(void);
#endif
	public:
		VDIRQSafeSpinLock(void);

		void EnterLock(void);
		void LeaveLock(void);

		void SetInIRQ(BOOL inIRQ) {this->inIRQ = inIRQ;}
		BOOL InIRQ(void) {return inIRQ;}
	};



inline VDIRQSafeSpinLock::VDIRQSafeSpinLock(void)
	{
#if NT_KERNEL
	lockVar = 0;
#elif !VXD_VERSION
	count = 0;
#endif
	}

inline void VDIRQSafeSpinLock::EnterLock()
	{
#if NT_KERNEL
	KIRQL oldIRQLLocal;

	// Multi-processor safe lock that can be executed at > DISPATCH_LEVEL

	KeRaiseIrql(HIGH_LEVEL, &oldIRQLLocal);				// prevents us from being interrupted by any IRQ
	do {;} while (InterlockedExchange(&lockVar, 1));

	oldIRQLevel = oldIRQLLocal;

#elif !VXD_VERSION
	if (!inIRQ)
		{
		count++;

		if (count == 1)
			irqDisabled = DisableLock();
		}
#endif
	}

inline void VDIRQSafeSpinLock::LeaveLock()
	{
#if NT_KERNEL
	KIRQL	oldIRQLLocal;

	oldIRQLLocal = oldIRQLevel;
	InterlockedExchange(&lockVar, 0);
	KeLowerIrql(oldIRQLLocal);
#elif !VXD_VERSION
	if (!inIRQ)
		{
		count--;

		if (count == 0)
			{
			if (irqDisabled)
				EnableLock();
			}
		}
#endif
	}




#if NT_KERNEL || VXD_VERSION || DRVDLL

class VDSpinLock
	{
	private:
#if NT_KERNEL
		KSPIN_LOCK	spinLock;
		KIRQL			oldIRQLevel;
#elif !VXD_VERSION
		int			count;
		BOOL			irqDisabled;
#endif
		BOOL			inIRQ;
	protected:
#if !NT_KERNEL && !VXD_VERSION
		void EnableLock(void);
		BOOL DisableLock(void);
#endif
	public:
		VDSpinLock(void);

		void EnterLock(void);
		void LeaveLock(void);

		void SetInIRQ(BOOL inIRQ) {this->inIRQ = inIRQ;}
		BOOL InIRQ(void) {return inIRQ;}
	};


inline VDSpinLock::VDSpinLock(void)
	{
#if NT_KERNEL
	KeInitializeSpinLock(&spinLock);
#elif !VXD_VERSION
	count = 0;
#endif
	}

inline void VDSpinLock::EnterLock()
	{
#if NT_KERNEL
	KeAcquireSpinLock(&spinLock, &oldIRQLevel);
#elif !VXD_VERSION
	if (!inIRQ)
		{
		count++;

		if (count == 1)
			irqDisabled = DisableLock();
		}
#endif
	}

inline void VDSpinLock::LeaveLock()
	{
#if NT_KERNEL
	KeReleaseSpinLock(&spinLock, oldIRQLevel);
#elif !VXD_VERSION
	if (!inIRQ)
		{
		count--;

		if (count == 0)
			{
			if (irqDisabled)
				EnableLock();
			}
		}
#endif
	}

#if !NT_KERNEL && !VXD_VERSION

inline BOOL VDSpinLock::DisableLock(void)
	{
	if (inIRQ)
		return FALSE;
	else
		{
		BOOL	result;
		_asm {pushf
			   pop   ax
			   and   ax, 0x0200
			   jz   	notSet
				mov	ax, TRUE
				cli
		notSet:
				mov	[result], ax
				}
		return result;
		}
	}

inline void VDSpinLock::EnableLock(void)
	{
	_asm sti;
	}

#endif

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\Krnlsync.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlsync.cpp
// AUTHOR:    Viona
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:

#include "krnlsync.h"

#include "vddebug.h"





#if NT_KERNEL


IRQMutex::IRQMutex(void)
	{
	KeInitializeSpinLock(&lock);
	KeInitializeEvent(&event, SynchronizationEvent, TRUE);
	block = TRUE;
	}


void IRQMutex::Enter(void)
	{
	LARGE_INTEGER	li;

	if (KeGetCurrentIrql() < DISPATCH_LEVEL)
		{
		li.QuadPart = 0x7fffffffffffffff;

		for(;;)
			{
			KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, &li);

			KeAcquireSpinLock(&lock, &irql);

			if (block) break;

			KeReleaseSpinLock(&lock, irql);
			}

		atIRQLevel = FALSE;
		}
	else
		{
		KeAcquireSpinLockAtDpcLevel(&lock);
		atIRQLevel = TRUE;
		}
	}


void IRQMutex::Leave(void)
	{
	if (!atIRQLevel)
		{
		KeReleaseSpinLock(&lock, irql);
		KeSetEvent(&event, 0, FALSE);
		}
	else
		KeReleaseSpinLockFromDpcLevel(&lock);
	}


void IRQMutex::EnterAtIRQLevel(void)
	{
	KeAcquireSpinLockAtDpcLevel(&lock);
	KeResetEvent(&event);
	block = FALSE;
	KeReleaseSpinLockFromDpcLevel(&lock);
	}


void IRQMutex::LeaveAtIRQLevel(void)
	{
	KeAcquireSpinLockAtDpcLevel(&lock);
	block = TRUE;
	KeSetEvent(&event, 0, FALSE);
	KeReleaseSpinLockFromDpcLevel(&lock);
	}


#else


VDMutex::VDMutex(LPCTSTR name)
	{
//	DP(__TEXT("*** Create: %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	mutex = ::CreateMutex(NULL, FALSE, name);
//	DP(__TEXT("*** C-    : %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	}

VDMutex::VDMutex(void)
	{
	VDMutex(NULL);
	}

VDMutex::~VDMutex(void)
	{
//	DP(__TEXT("*** Destroy: %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	if (mutex)
		CloseHandle(mutex);
//	DP(__TEXT("*** D-     : %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	}

void VDMutex::Enter(void)
	{
//	DP(__TEXT("*** Enter : %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	::WaitForSingleObject(mutex, INFINITE);
//	DP(__TEXT("*** E-,   : %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	}

void VDMutex::Leave(void)
	{
//	DP(__TEXT("*** Leave : %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	::ReleaseMutex(mutex);
//	DP(__TEXT("*** L-    : %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	}

VDSemaphore::VDSemaphore (void)
	{
	sema = ::CreateSemaphore(NULL, NULL, 1000000, NULL);
	}

VDSemaphore::~VDSemaphore (void)
	{
	if (sema)
		CloseHandle(sema);
	}

void VDSemaphore::Reset (void)
	{
	do {} while (::WaitForSingleObject(sema, 0) != WAIT_TIMEOUT);
	}

void VDSemaphore::Signal (void)
	{
	::ReleaseSemaphore(sema, 1, NULL);
	}

void VDSemaphore::Wait (void)
	{
	::WaitForSingleObject(sema, INFINITE);
	}

VDTimedSemaphore::VDTimedSemaphore(void)
	: VDSemaphore()
	{
	}

VDTimedSemaphore::~VDTimedSemaphore(void)
	{
	}

void VDTimedSemaphore::Reset (void)
	{
	do {} while (::WaitForSingleObject(sema, 0) != WAIT_TIMEOUT);
	}

void VDTimedSemaphore::Wait (void)
	{
	::WaitForSingleObject(sema, INFINITE);
	}

void VDTimedSemaphore::WaitTimeout (DWORD time, BOOL & timeout)
	{
	timeout = ::WaitForSingleObject(sema, time / 1000) == WAIT_TIMEOUT;
	}

#endif	// of NT_KERNEL





VDCriticalSection::VDCriticalSection(void)
	{
	scheduled = FALSE;
	cnt = 0;
#if NT_KERNEL
	KeInitializeMutex (&mutex, 0);
#endif
	}


void VDCriticalSection::EnterSection(void)
	{
#if NT_KERNEL
	KeWaitForSingleObject (&mutex, Executive, KernelMode, FALSE, NULL);
	cnt++;
//	DP("ES %x %d", KeGetCurrentThread(), cnt);
#else
	cnt++;
#endif
	}

void VDCriticalSection::LeaveSection(void)
	{
#if NT_KERNEL
	cnt--;
	if (!cnt)
		{
//		DP("LS1 %x %d", KeGetCurrentThread(), cnt);
		KeReleaseMutex (&mutex, FALSE);
		while (scheduled)
			{
//			DP("SCHED1");
			KeWaitForSingleObject (&mutex, Executive, KernelMode, FALSE, NULL);
			cnt++;
			if (scheduled)
				{
				scheduled = FALSE;
				CriticalSection ();
				}
			cnt--;
			KeReleaseMutex (&mutex, FALSE);
			}
		}
	else
		{
//		DP("LS2 %x %d", KeGetCurrentThread(), cnt);
		KeReleaseMutex (&mutex, FALSE);
		}
#else
	cnt--;
	if (!cnt)
		{
		while (scheduled)
			{
			cnt++;
			if (scheduled)
				{
				scheduled = FALSE;
				CriticalSection();
				}
			cnt--;
			}
		}
#endif
	}

void VDCriticalSection::ScheduleSection(void)
	{
#if NT_KERNEL
	LARGE_INTEGER timeout;
	timeout.QuadPart = 0;
	BOOL success;
	success = (STATUS_SUCCESS == KeWaitForSingleObject (&mutex, Executive, KernelMode, FALSE, &timeout));
	if (! success)
		{
//		DP("SS1 %x %d", KeGetCurrentThread(), cnt);
		scheduled = TRUE;
		}
	else
		{
//		DP("SS2 %x %d", KeGetCurrentThread(), cnt);
		if (!cnt)
			{
			scheduled = FALSE;
			CriticalSection ();
			}
		else
			scheduled = TRUE;

		KeReleaseMutex (&mutex, FALSE);
		}
#else
	if (cnt)
		scheduled = TRUE;
	else
		{
		scheduled = FALSE;
		CriticalSection();
		}
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\LockedQueue.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\lockedQueue.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 2000 Viona Development.  All Rights Reserved.
// CREATED:
//
// PURPOSE:   template for single locked queue that can be accessed from multiple threads
//				  uses a windows critical section
//
// HISTORY:
//
//


#ifndef LOCKEDQUEUE_H
#define LOCKEDQUEUE_H

#include <windows.h>

template < class T>
class LockedQueue
	{
	protected:
		CRITICAL_SECTION	lock;
		HANDLE				henter, hremove;
		int					in, out, num, max;
		bool					terminate;
		T					*	queue;

	public:
		// constructor - create locked queue with a maximum of max entries
		LockedQueue(int max)
			{
			::InitializeCriticalSection(&lock);
			this->max = max;
			in = out = num = 0;
			queue = new T[max];
			henter = ::CreateEvent(NULL, FALSE, FALSE, NULL);
			hremove = ::CreateEvent(NULL, FALSE, FALSE, NULL);

			this->terminate = false;
			}

		// desctructor
		// deletes a locked queue. The entries in the queue are NOT deleted
		~LockedQueue(void)
			{
			delete[] queue;
			::CloseHandle(henter);
			::CloseHandle(hremove);
			::DeleteCriticalSection(&lock);
			}


		// Add new element to locked queue.
		bool Enqueue(T t, bool block = true)
			{
			bool success = false;

			::EnterCriticalSection(&lock);
			while (block && !terminate && num == max)
				{
				::LeaveCriticalSection(&lock);
				::WaitForSingleObject(henter, INFINITE);
				::EnterCriticalSection(&lock);
				}

			if (!terminate && num < max)
				{
				queue[in] = t;
				in++;
				num++;
				if (in == max) in = 0;
				::SetEvent(hremove);
				success = true;
				}

			::LeaveCriticalSection(&lock);

			return success;
			}

		// remove element from locked queue. Do not use during flush. Use DequeueFlush instead.
		bool Dequeue(T & t, bool block = true)
			{
			bool success = false;

			::EnterCriticalSection(&lock);
			while (block && !terminate && num == 0)
				{
				::LeaveCriticalSection(&lock);
				::WaitForSingleObject(hremove, INFINITE);
				::EnterCriticalSection(&lock);
				}

			if (!terminate && num != 0)
				{
				t = queue[out];
				out++;
				num--;
				if (out == max) out = 0;
				::SetEvent(henter);
				success = true;
				}

			::LeaveCriticalSection(&lock);

			return success;
			}


		// signal begin flush operation. After BeginFlush(), remove all elements with DequeueFlush.
		// at the end, call EndFlush();
		// during Flush, no other operations than DequeueFlush() can be performed, all other would block.
		// begin flush holds critical section till next EndFlush().
		bool BeginFlush(void)
			{
			::EnterCriticalSection(&lock);

			return true;
			}

		// signal end flush. Critical section hold since BeginFlush() will be released.
		bool EndFlush(void)
			{
			::SetEvent(henter);
			::LeaveCriticalSection(&lock);

			return true;
			}

		// remove element form queue, without critical section. Only call during flush.
		bool DequeueFlush(T & t)
			{
			if (num != 0)
				{
				t = queue[out];
				out++;
				num--;
				if (out == max) out = 0;

				return true;
				}
			else
				return false;
			}

		// terminate queue operations. All blocked operations will be unblocked when calling
		// Terminate()
		bool Terminate(void)
			{
			this->terminate = true;
			::SetEvent(henter);
			::SetEvent(hremove);

			return true;
			}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\MMXExtensionMacros.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// ************************************************************************************
// *
// *	MMX INSTRUCTION EXTENSION MACROS
// *
// *	FILE:			MMXExtensionMacros.h
// *	CONTEXT:		header file containing preprocessor macros for ATHLON (K7)
// *	PURPOSE:		preprocessor macros for generation of ISSE instructions
// *	START:		Wednesday, Aug. 25th, 1999
// *
// *	AUTHOR:		Roland Schaufler
// *	COPYRIGHT:	VIONA Development GmbH
// *
// ************************************************************************************
//
// THIS FILE IS COPYRIGHT OF VIONA DEVELOPMENT GMBH AND IS NOT LICENSED TO THE PUBLIC
//
// As it is not possible to overload a macro and to use it with different parameters
// every single addressing mode which is needed has to be "hard-coded". The convention used
// herefore is the following:
//
// instruction			meaning
// Suffix
// -------------------------------------------------------
// --						reg, reg
// MEM					reg, [base]
// IMM8					reg, [base + immediate8]  (this one is not used)
//	IMM32					reg, [base + immediate32] (this one is used rather!)
// SIB					reg, [base + scale*index]
//
//
// explicite store or load instructions contain no extra suffixes
//

#ifndef MMX_EXTENSION_MACROS_H
#define MMX_EXTENSION_MACROS_H

//////////////////////////////////////////////////////////////////////////////////////////////
// Definitions of CPU registers INTEGER and MMX
//////////////////////////////////////////////////////////////////////////////////////////////

// integer registers
#define Register_eax 0
#define Register_ecx 1
#define Register_edx 2
#define Register_ebx 3
#define Register_esp 4
#define Register_ebp 5
#define Register_esi 6
#define Register_edi 7

// integer MMX registers
#define Register_mm0 0
#define Register_mm1 1
#define Register_mm2 2
#define Register_mm3 3
#define Register_mm4 4
#define Register_mm5 5
#define Register_mm6 6
#define Register_mm7 7

// specials for ModR/M bytes: Mod
#define Mod_none   0
#define Mod_disp8	 1
#define Mod_disp32 2
#define Mod_reg    3

// specials for ModR/M bytes: R/M
#define Register_SIB    4
#define Register_disp32	5

// specials for SIB bytes
#define Register_noindx 4
#define Register_nobase 5


//////////////////////////////////////////////////////////////////////////////////////////////
// Macros only for use within other Macros
//////////////////////////////////////////////////////////////////////////////////////////////

// immediate values following opcode bytes
#define BYTE0(off)					(off & 0xff)
#define BYTE1(off)					((off & 0xff00) >> 8)
#define BYTE2(off)					((off & 0xff0000) >> 16)
#define BYTE3(off)					((off & 0xff000000) >> 24)

#define MODRMBYTE(mod, rm, dest)     ((Mod_##mod << 6) + (Register_##dest << 3)  + Register_##rm)

#define SIBBYTE(scale, index, base)  ((scale << 6)	    + (Register_##index << 3) + Register_##base)

// define register byte
#define REG(dest, src)	(0xC0 + (Register_##dest << 3) + Register_##src)

// Additional ATHLON MMX ops
#define MMXSTART	   _asm _emit 0x0F  _asm _emit

// define bodies for macros
#define MMXBLOCK(opcode, mod, rm, dest)									\
	}																					\
   MMXSTART opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm																				\
		{

#define MMXBLOCKIMM8(opcode, mod, rm, dest, imm8)						\
	}																					\
   MMXSTART opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm _emit imm8																\
	_asm																				\
		{

#define MMXBLOCKIMM32(opcode, mod, rm, dest, imm32)					\
	}																					\
   MMXSTART opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm _emit BYTE0(imm32)														\
	_asm _emit BYTE1(imm32)														\
	_asm _emit BYTE2(imm32)														\
	_asm _emit BYTE3(imm32)														\
	_asm																				\
		{

#define MMXBLOCKIMM32IMM8(opcode, mod, rm, dest, imm32, imm8)		\
	}																					\
   MMXSTART opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm _emit BYTE0(imm32)														\
	_asm _emit BYTE1(imm32)														\
	_asm _emit BYTE2(imm32)														\
	_asm _emit BYTE3(imm32)														\
	_asm _emit imm8																\
	_asm																				\
		{

//////////////////////////////////////////////////////////////////////////////////////////////

#define MMXBLOCKSIB(opcode, mod, rm, dest, scale, index, base)		\
	}																					\
   MMXSTART opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm _emit SIBBYTE(scale, index, base)									\
	_asm																				\
		{

#define MMXBLOCKSIBIMM8(opc, mod, rm, dest, scal, ind, bas, imm8)	\
	}																					\
   MMXSTART opc																	\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm _emit SIBBYTE(scal, ind, bas)										\
	_asm _emit imm8																\
	_asm																				\
		{

#define MMXBLOCKSIBIMM32(opc, mod, rm, dest, scale, ind, base)		\
	}																					\
   MMXSTART opc																	\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm _emit SIBBYTE(scale, ind, base)									\
	_asm _emit BYTE0(imm32)														\
	_asm _emit BYTE1(imm32)														\
	_asm _emit BYTE2(imm32)														\
	_asm _emit BYTE3(imm32)														\
	_asm																				\
		{


//////////////////////////////////////////////////////////////////////////////////////////////
// **** REGISTER to REGISTER
//////////////////////////////////////////////////////////////////////////////////////////////

#define maskmovq(dest, src)				MMXBLOCK(0xF7, reg, src, dest)
#define pavgb(dest, src)					MMXBLOCK(0xE0, reg, src, dest)
#define pavgw(dest, src)					MMXBLOCK(0xE3, reg, src, dest)
#define pinsrw(dest, src)					MMXBLOCK(0xC4, reg, src, dest)
#define pmaxsw(dest, src)					MMXBLOCK(0xEE, reg, src, dest)
#define pmaxub(dest, src)					MMXBLOCK(0xDE, reg, src, dest)
#define pminsw(dest, src)					MMXBLOCK(0xEA, reg, src, dest)
#define pminub(dest, src)					MMXBLOCK(0xDA, reg, src, dest)
#define pmovmskb(dest, src)				MMXBLOCK(0xD7, reg, src, dest)
#define pmulhw(dest, src)					MMXBLOCK(0xE4, reg, src, dest)
#define psadbw(dest, src)					MMXBLOCK(0xF6, reg, src, dest)


//////////////////////////////////////////////////////////////////////////////////////////////
// **** MEMORY to REGISTER
//////////////////////////////////////////////////////////////////////////////////////////////

#define maskmovqMEM(dest, src)				MMXBLOCK(0xF7, none, src, dest)
#define pavgbMEM(dest, src)					MMXBLOCK(0xE0, none, src, dest)
#define pavgwMEM(dest, src)					MMXBLOCK(0xE3, none, src, dest)
#define pinsrwMEM(dest, src)					MMXBLOCK(0xC4, none, src, dest)
#define pmaxswMEM(dest, src)					MMXBLOCK(0xEE, none, src, dest)
#define pmaxubMEM(dest, src)					MMXBLOCK(0xDE, none, src, dest)
#define pminswMEM(dest, src)					MMXBLOCK(0xEA, none, src, dest)
#define pminubMEM(dest, src)					MMXBLOCK(0xDA, none, src, dest)
#define pmovmskbMEM(dest, src)				MMXBLOCK(0xD7, none, src, dest)
#define pmulhwMEM(dest, src)					MMXBLOCK(0xE4, none, src, dest)
#define psaddbwMEM(dest, src)					MMXBLOCK(0xF6, none, src, dest)


//////////////////////////////////////////////////////////////////////////////////////////////
// **** MEMORY to REGISTER plus IMMEDIATE8
//////////////////////////////////////////////////////////////////////////////////////////////

#define maskmovqIMM08(dest, src)			MMXBLOCKIMM8(0xF7, disp8, src, dest, imm8)
#define pavgbIMM08(dest, src, imm8)		MMXBLOCKIMM8(0xE0, disp8, src, dest, imm8)
#define pavgwIMM08(dest, src, imm8)		MMXBLOCKIMM8(0xE3, disp8, src, dest, imm8)
#define pinsrwIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xC4, disp8, src, dest, imm8)
#define pmaxswIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xEE, disp8, src, dest, imm8)
#define pmaxubIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xDE, disp8, src, dest, imm8)
#define pminswIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xEA, disp8, src, dest, imm8)
#define pminubIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xDA, disp8, src, dest, imm8)
#define pmovmskbIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xD7, disp8, src, dest, imm8)
#define pmulhwIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xE4, disp8, src, dest, imm8)
#define psaddbwIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xF6, disp8, src, dest, imm8)


//////////////////////////////////////////////////////////////////////////////////////////////
// **** MEMORY to REGISTER plus IMMEDIATE32
//////////////////////////////////////////////////////////////////////////////////////////////
// NEW ATHLON MMX
#define maskmovqIMM32(dest, src, imm32)	MMXBLOCKIMM32(0xF7, disp32, src, dest, imm23)
#define pavgbIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xE0, disp32, src, dest, imm32)
#define pavgwIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xE3, disp32, src, dest, imm32)
#define pinsrwIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xC4, disp32, src, dest, imm32)
#define pmaxswIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xEE, disp32, src, dest, imm32)
#define pmaxubIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xDE, disp32, src, dest, imm32)
#define pminswIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xEA, disp32, src, dest, imm32)
#define pminubIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xDA, disp32, src, dest, imm32)
#define pmovmskbIMM32(dest, src, imm32)	MMXBLOCKIMM32(0xD7, disp32, src, dest, imm32)
#define pmulhwIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xE4, disp32, src, dest, imm32)
#define psaddbwIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xF6, disp32, src, dest, imm32)

//////////////////////////////////////////////////////////////////////////////////////////////
// **** REGISTER to MEMORY
//////////////////////////////////////////////////////////////////////////////////////////////

#define movntq(src, dest)							MMXBLOCK(0xE7, none, dest, src)
#define movntqIMM8(src, dest, imm8)				MMXBLOCKIMM8(0xE7, disp8, dest, src, imm8)
#define movntqIMM32(src, dest, imm32)			MMXBLOCKIMM32(0xE7, disp32, dest, src, imm32)
#define movntqSIB(src, scale, index, base)	MMXBLOCKSIB(0xE7, none, SIB, src, scale, index, base)



//////////////////////////////////////////////////////////////////////////////////////////////
// special instruciotns
//////////////////////////////////////////////////////////////////////////////////////////////

// pextr
#define pextrw(dest, src, imm8)				MMXBLOCKIMM8(0xC5, reg, src, dest, imm8)


// pshufw
#define pshufw(dest, src, imm8)				MMXBLOCKIMM8(0x70, reg, src, dest, imm8)

#define pshufwMEM(dest, src, imm8)								\
				}															\
				MMXSTART 0x70											\
				_asm _emit MODRMBYTE(none, src, dest)			\
				_asm _emit imm8										\
				_asm														\
				{

#define pshufwIMM8(dest, src, mem8, imm8)						\
				}															\
				MMXSTART 0x70											\
				_asm _emit MODRMBYTE(disp8, src, dest)			\
				_asm _emit mem8										\
				_asm _emit imm8										\
				_asm														\
				{


#define pshufwIMM32(dest, src, imm32, imm8)					\
				}															\
				MMXSTART 0x70											\
				_asm _emit MODRMBYTE(disp32, src, dest)		\
				_asm _emit BYTE0(imm32)								\
				_asm _emit BYTE1(imm32)								\
				_asm _emit BYTE2(imm32)								\
				_asm _emit BYTE3(imm32)								\
				_asm _emit imm8										\
				_asm														\
				{



// prefetch

// MOD/RM Bytes
#define MOD_OPC_RM(mod, opc, rm)		((mod << 6) + (opc << 3) + rm)
#define MOD_OPC_REG(mod, opc, reg)	((mod << 6) + (opc << 3) + Register_##reg)

// SIB (Scale/index/base) Bytes
#define SIB(scale, index, base)		((scale << 6) + (Register_##index << 3) + Register_##base)
#define SIN(scale, index, base)		((scale << 6) + (Register_##index << 3) + base)

// **** prefetch [reg]
// mode = opcode extension bit 5..8: prefetch-op,  = { 1, 2, 3, 0 }
// reg  = base register
#define prefetch_REG(mode, reg)											\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_REG(0x00, mode, reg)							\
	_asm																			\
		{

// **** prefetch [reg + reg]
// mode = opcode extension bit 5..8: prefetch-op
// reg1 = unscaled register
// reg2 = scaled register
// scale = reg*1=0, reg*2=1, reg*4=2, reg*8=3
#define prefetch_REGpsREG(mode, reg1, scale, reg2)					\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_RM(0x00, mode, 0x04)							\
   _asm _emit SIB(scale, reg2, reg1)									\
	_asm																			\
		{

// **** prefetch [reg + off8]
// mode = opcode extension bit 5..8: prefetch-op  = { 1, 2, 3, 0 }
// reg  = base register
// off8 = 8-bit offset, is sign extended and added for address	generation
#define prefetch_REGpOFF8(mode, reg, off8)							\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_REG(0x01, mode, reg)							\
	_asm _emit off8															\
	_asm																			\
		{

// **** prefetch [reg1 + s*reg2 + off8]
// mode = opcode extension bit 5..8: prefetch-op  = { 1, 2, 3, 0 }
// reg1 = unscaled register
// reg2 = scaled register
// off8 = 8-bit offset, is sign extended and added for address	generation
// scale = reg*1=0, reg*2=1, reg*4=2, reg*8=3
#define prefetch_REGpsREGpOFF8(mode, reg1, scale, reg2, off8)	\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_RM(0x01, mode, 0x04)							\
	_asm _emit SIB(scale, reg2, reg1)									\
	_asm _emit off8															\
	_asm																			\
		{

// **** prefetch [reg + off32]
// mode  = opcode extension bit 5..8: prefetch-op  = { 1, 2, 3, 0 }
// reg   = base register
// off32 = 32-bit offset
#define prefetch_REGpOFF32(mode, reg, off32)							\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_REG(0x02, mode, reg)							\
	_asm _emit BYTE0(off32)													\
	_asm _emit BYTE1(off32)													\
	_asm _emit BYTE2(off32)													\
	_asm _emit BYTE3(off32)													\
	_asm																			\
		{

// **** prefetch [s*reg + off32]
// mode  = opcode extension bit 5..8: prefetch-op  = { 1, 2, 3, 0 }
// reg   = base register
// off32 = 32-bit offset
// scale = reg*1=0, reg*2=1, reg*4=2, reg*8=3
#define prefetch_sREGpOFF32(mode, scale, reg1, off32)				\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_RM(0x00, mode, 0x04)							\
	_asm _emit SIN(scale, reg1, 0x05)									\
	_asm _emit BYTE0(off32)													\
	_asm _emit BYTE1(off32)													\
	_asm _emit BYTE2(off32)													\
	_asm _emit BYTE3(off32)													\
	_asm																			\
		{

// **** prefetch [reg1 + s*reg2 + off32]
// mode = opcode extension bit 5..8: prefetch-op  = { 1, 2, 3, 0 }
// reg1 = unscaled register
// reg2 = scaled register
// off32 = 32-bit offset
// scale = reg*1=0, reg*2=1, reg*4=2, reg*8=3
#define prefetch_REGpsREGpOFF32(mode, reg1, scale, reg2, off32)\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_RM(0x02, mode, 0x04)							\
	_asm _emit SIB(scale, reg2, reg1)									\
	_asm _emit BYTE0(off32)													\
	_asm _emit BYTE1(off32)													\
	_asm _emit BYTE2(off32)													\
	_asm _emit BYTE3(off32)													\
	_asm																			\
		{



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\prelude2.c ===
/*
// FILE:      library\common\prelude2.c
// AUTHOR:    D. Heidrich, S. Herr
// COPYRIGHT: (c) 1998 Viona Development.  All Rights Reserved.
// CREATED:   19.05.98
//
// PURPOSE:   This file contains all code that's supposed to be in prelude.cpp
//            but must be implemented in plain C code.
//
// HISTORY:
*/


#if ST20LITE

#include <debug.h>
#include <restart.h>

#include <interrup.h>

typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned char BYTE;
typedef void * HPTR;


#if EXPLICIT_DEVICE_ACCESSES

#if __ICC_VERSION_NUMBER__ >= 60000
#pragma ST_inline (ST20PutDWord)
#endif
void ST20PutDWord(DWORD * p, DWORD data)
	{
#pragma ST_device (dptr)
	DWORD * dptr = p;
	*dptr = data;
	}
/* BUGBUG: Will be expanded only if optimisation and minimal debug info are selected
	as compile switches. */
#if !__EDG__ || __EDG_VERSION__ < 240
#pragma ST_inline (ST20PutDWord)
#endif

#if __ICC_VERSION_NUMBER__ >= 60000
#pragma ST_inline (ST20PutWord)
#endif
void ST20PutWord(WORD * p, WORD data)
	{
#pragma ST_device (wptr)
	WORD * wptr = p;
	*wptr = data;
	}
#if __ICC_VERSION_NUMBER__ < 60000
#pragma ST_inline (ST20PutWord)
#endif

#if __ICC_VERSION_NUMBER__ >= 60000
#pragma ST_inline (ST20PutByte)
#endif
void ST20PutByte(BYTE * p, BYTE data)
	{
#pragma ST_device (bptr)
	BYTE * bptr = p;
	*bptr = data;
	}
#if __ICC_VERSION_NUMBER__ < 60000
#pragma ST_inline (ST20PutByte)
#endif

#if __ICC_VERSION_NUMBER__ >= 60000
#pragma ST_inline (ST20GetDWord)
#endif
DWORD ST20GetDWord(DWORD * p)
	{
#pragma ST_device (rdptr)
	DWORD * rdptr = p;
	return *rdptr;	
	}
#if __ICC_VERSION_NUMBER__ < 60000
#pragma ST_inline (ST20GetDWord)
#endif

#if __ICC_VERSION_NUMBER__ >= 60000
#pragma ST_inline (ST20GetWord)
#endif
WORD ST20GetWord(WORD * p)
	{
#pragma ST_device (rwptr)
	WORD * rwptr = p;
	return *rwptr;	
	}
#if __ICC_VERSION_NUMBER__ < 60000
#pragma ST_inline (ST20GetWord)
#endif

#if __ICC_VERSION_NUMBER__ >= 60000
#pragma ST_inline (ST20GetByte)
#endif
BYTE ST20GetByte(BYTE * p)
	{
#pragma ST_device (rbptr)
	BYTE * rbptr = p;
	return *rbptr;	
	}
#if __ICC_VERSION_NUMBER__ < 60000
#pragma ST_inline (ST20GetByte)
#endif

#endif /* EXPLICIT_DEVICE_ACCESSES */

#if 0
static int MyInternalBlock[25];
#pragma ST_section (MyInternalBlock, "internal_part")
#endif

void DisableScheduler(void)
	{
  unsigned int Previous;

/* Disable scheduler trap handlers (OS!)  */

	__asm {
	   ldab       0xffffffff, 1;
		trapdis;
	   ldab       0xffffffff, 0;
		trapdis;
		st         Previous;
		}
	}

void ResetProcessor (void)
	{
	__asm {
		reboot;
		}
	}

#define LOCK    interrupt_lock();
#define UNLOCK  interrupt_unlock();

#define WRITE32_DEVICE( base, reg, value )              \
LOCK                                                    \
__asm                                                   \
{                                                       \
  ld    (value);                                        \
  ld    (base)+(reg);                                   \
  devsw;                                                \
}                                                       \
UNLOCK                                                


void RunProgram(unsigned char * vector)
	{
#if 0
	WRITE32_DEVICE (0x4000, 0x500, 0)	/* Enable change of config registers */
	WRITE32_DEVICE (0x4000, 0x400, 1)	/* Flush data cache */
	WRITE32_DEVICE (0x4000, 0x100, 0)	/* Disable data and instruction cache */
#endif

	interrupt_lock();

	__asm
		{
		ld vector;
		gcall;
		}
	}

void RestoreInitialState()
	{
	#define MINT 0x80000000
	int regs[4] ;
	int pr ;

#if EXPLICIT_DEVICE_ACCESSES || __ICC_VERSION_NUMBER__ >= 60000
#pragma ST_device (irqcont)
	int* irqcont = (int *) 0x200000c0;
#endif

	/* check priority */
	__asm { ldpri ; st pr ; } ;

	if (pr==1)
		{
		/* change from low to high pri */
		__asm {
			ldlabeldiff there-here ;
			ldpi ;
			here: ;
			stl -1 ;
			ldlp 0 ;
			runp ;
			there: ;
			} ;
		}
	/* clear all channels */

	__asm {
		ldc MINT ; /* OS Link channel */
		resetch ;
		ldc MINT+0x10 ; /* OS Link channel */
		resetch ;
		} ;

	/* clear interrupt controller */
#if EXPLICIT_DEVICE_ACCESSES || __ICC_VERSION_NUMBER__ >= 60000
	*irqcont = 0 ;
#else
	*( (volatile int*) 0x200000c0 ) = 0 ;
#endif

	/* remove timers from queue */
	__asm { ldab 0, MINT ; swaptimer ; } ;
	__asm { ldab 1, MINT ; swaptimer ; } ;

	/* remove processes from queue */
	__asm { ldabc 0, MINT, MINT ; swapqueue ; } ;
	__asm { ldabc 1, MINT, MINT ; swapqueue ; } ;

	/* clear shadow regs */
	regs[1] = 0 ;
	__asm { ldabc 2, 1, regs ; ldshadow ; } ;

	/* disable all traps except BP handler */
	__asm { ldab 0xfffe, 0 ; trapdis ; } ;
	__asm { ldab 0xfffe, 1 ; trapdis ; } ;
	}

void RestartSystem()
	{
	RestoreInitialState();
	romrestart();
	}

int WarmLastStart()
	{
	return (romlaststart() == warm_t);
	}

DWORD GetLowClock (void)
	{
	DWORD clock;
	__asm {
		ldc	1;
		ldclock;
		stl	clock;
		}
	return clock;
	}

DWORD GetHighClock (void)
	{
	DWORD clock;
	__asm {
		ldc	0;
		ldclock;
		stl	clock;
		}
	return clock;
	}

void _hmemcpy (HPTR dst, HPTR src, DWORD size)
	{
#if 0
	/* Use the block move DMA. */
	DWORD channel = 0x80000034;

#if EXPLICIT_DEVICE_ACCESSES || __ICC_VERSION_NUMBER__ >= 60000
#pragma ST_device(ctrl)
	DWORD *ctrl = (DWORD *)0x20026000;
#else
	volatile DWORD *ctrl = (DWORD *)0x20026000;
#endif

	*ctrl = (DWORD)dst;
	;
	__asm {
		ldl	src;
		ldl	channel;
		ldl	size;
		out;
		}
#elif 0
	/* Copy via the data cache SRAM. */
	DWORD d = (DWORD)dst;
	DWORD s = (DWORD)src;
/*	DWORD sram = (DWORD)MyInternalBlock; 0x80000800;*/
	DWORD sram = 0x80000800;
	DWORD chunk = 2048;
	DWORD channel = 0x80000034;

#if EXPLICIT_DEVICE_ACCESSES || __ICC_VERSION_NUMBER__ >= 60000
#pragma ST_device(ctrl)
	DWORD *ctrl = (DWORD *)0x20026000;
#else
	volatile DWORD *ctrl = (DWORD *)0x20026000;
#endif

	while (size > 0)
		{
		if (size < chunk)
			chunk = size;
		*ctrl = sram;
		__asm {
			ldl	s;
			ldl	channel;
			ldl	chunk;
			out;
			}
		*ctrl = d;
		__asm {
			ldl	sram;
			ldl	channel;
			ldl	chunk;
			out;
			}
		d += chunk;
		s += chunk;
		size -= chunk;
		}
#else
	__asm {
		ldl	src;
		ldl	dst;
		ldl	size;
		move;
		}
#endif
	}

void memDMAcpy (HPTR dst, HPTR src, DWORD size)
	{
	/* Use the block move DMA. */
	DWORD channel = 0x80000034;

#if EXPLICIT_DEVICE_ACCESSES || __ICC_VERSION_NUMBER__ >= 60000
#pragma ST_device(ctrl)
	DWORD *ctrl = (DWORD *)0x20026000;
#else
	volatile DWORD *ctrl = (DWORD *)0x20026000;
#endif

	*ctrl = (DWORD)dst;
	;
	__asm {
		ldl	src;
		ldl	channel;
		ldl	size;
		out;
		}
	}

void FastRectCopy (int nRows, void *src, int bytesPerRow, int srcStride, void *dst, int dstStride)
	{
	__asm {
		ldl	srcStride;
		ldl	dstStride;
		ldl	nRows;
		move2dinit;
		ldl	src;
		ldl	dst;
		ldl	bytesPerRow;
		move2dall;
		}
	}

void C_MUL32x32 (DWORD op1, DWORD op2, DWORD *upper, DWORD *lower)
	{
	DWORD a, b;

	__asm {
		ldc	0;
		ldl	op2;
		ldl	op1;
		lmul;
		stl	a;
		stl	b;
		}
	*lower = a;
	*upper = b;
	}

DWORD DIV64x32 (DWORD upper, DWORD lower, DWORD op)
	{
	DWORD result;
	__asm {
		ldl	upper;
		ldl	lower;
		ldl	op;
		ldiv;
		stl	result;
		stl	op;
		}
	return result;
	}

DWORD ScaleDWord (DWORD op, DWORD from, DWORD to)
	{
	DWORD result;
	__asm {
		ldc	0;
		ldl	op;
		ldl	to;
		lmul;
		ldl	from;
		ldiv;
		stl	result;
		stl	op;
		}
	return result;
	}

long ScaleLong (long op, long from, long to)
	{
	DWORD result;
	int signCount = 0;
	if (op < 0)
		{
		op = -op;
		signCount++;
		}
	if (from < 0)
		{
		from = -from;
		signCount++;
		}
	if (to < 0)
		{
		to = -to;
		signCount++;
		}
	__asm {
		ldc	0;
		ldl	op;
		ldl	to;
		lmul;
		ldl	from;
		ldiv;
		stl	result;
		stl	op;
		}
	return (signCount & 1) ? -result : result;
	}

void RunBitBufferDMA (DWORD channel, void *data, DWORD size)
	{
	/* Note that the DMA is run synchronously. The OUT instruction will
	   deschedule the process until the data has been transferred.
	*/
	__asm {
		ldl	data;
		ldl	channel;
		ldl	size;
		out;
		}
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\prelude.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\prelude.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:   Central prelude for all modules, defining types and
//				  often used macros.
//
// HISTORY:
//
//


// ATTENTION: THE INCLUDE OF "RESOURCE.H" EXPERIMENTALY REMOVED : Uli (II)

#ifndef PRELUDE_H
#define PRELUDE_H



#if   LINUX
////////////////////////////////////////////////////////////////////
//
//	LINUX
//
////////////////////////////////////////////////////////////////////

// #define NULL	0

#define __far
#define __huge
#define __cdecl
#define __pascal
#define __export
#define __loadds
#define FAR
#define cdecl
#define WINAPI
#define DLLCALL

typedef unsigned int HANDLE;
typedef signed long LONG;

typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned char BYTE;


#include <stdlib.h>
#include <malloc.h>
#include <string.h>

enum POOL_TYPE
	{
	NonPagedPool, PagedPool
	};

void * operator new (unsigned int nSize, POOL_TYPE iType);
void * operator new (unsigned int nSize);
void operator delete (void *p);

#define _fstrcpy	strcpy
#define _fstrcat	strcat
#define _fstrlen	strlen
#define _fstrcmp	strcmp
#define _fmemcpy  memcpy
#define _fmalloc	malloc
#define _ffree		free

/* just like below in the #ifdef MMXMEMORY section */
inline void * __cdecl operator new(unsigned int nSize)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

inline void * __cdecl operator new(unsigned int nSize, POOL_TYPE iType)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

inline void __cdecl operator delete(void* p, POOL_TYPE iType)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}

inline void __cdecl operator delete(void* p)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}

inline void __cdecl operator delete[](void* p)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}


#elif MACINTOSH
////////////////////////////////////////////////////////////////////
//
//	Apple Macintosh
//
////////////////////////////////////////////////////////////////////

//	You should manually define MACINTOSH and also one of:
//	TARGET_API_MAC_OS8 ||TARGET_API_MAC_OSX ||TARGET_API_MAC_CARBON
//	TARGET_CPU_PPC is default


//	undefine Windows-isms
#define __far
#define __huge
#define __cdecl
#define __pascal
#define __export
#define __loadds
#define WINAPI
#define DLLCALL


//	Memory management

typedef unsigned long	size_t;

enum POOL_TYPE
	{
	NonPagedPool, PagedPool
	};

void *  operator new(size_t nSize);
void *  operator new(size_t nSize, POOL_TYPE iType);
void	operator delete(void* p);

void *  operator new[](size_t nSize);
void *  operator new[](size_t nSize, POOL_TYPE iType);
void	operator delete[](void* p);

//	core MacOS includes
#include <ConditionalMacros.h>


#else
////////////////////////////////////////////////////////////////////
//
//	 Windows and XBox
//
////////////////////////////////////////////////////////////////////

//
// Disable warnings for "inline assembler", "lost debugging information"
// and "inline functions".
//
#pragma warning(disable : 4505)
#pragma warning(disable : 4704)
#pragma warning(disable : 4791)

#define DLLCALL

#if VXD_VERSION

// Take these as C includes as we are a .cpp file!
#define WANTVXDWRAPS
#define IS_32

#define NULL	0

extern "C"
	{
	#include <basedef.h>
	#include <vmm.h>
	#include <vmmreg.h>
	#include <vxdwraps.h>
	#include <debug.h>
	#include <vwin32.h>
	#include "library/support/w95vxds/vwinwrap.h"
	#include <winerror.h>
	}

extern int __cdecl _purecall(void);

#ifdef _DEBUG
#define HARDBREAK __asm int 1;
#else
#define HARDBREAK
#endif

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

#endif // VXD_VERSION



#if NT_KERNEL


#if WDM_VERSION

extern "C"
{
#include <wdm.h>
#include <windef.h>
}


#else


#ifndef CALLBACK
#define CALLBACK    __stdcall
#endif


extern "C"
{
#include <ntddk.h>
}

#endif // not WDM_VERSION branch

void * __cdecl operator new(size_t nSize, POOL_TYPE iType);
void * __cdecl operator new(size_t nSize);
void __cdecl operator delete(void *p);


#elif VXD_VERSION

enum POOL_TYPE
	{
	NonPagedPool = 0,
	PagedPool = HEAPSWAP
	};

void * __cdecl operator new(unsigned int nSize, POOL_TYPE iType);
void * __cdecl operator new(unsigned int nSize);
void __cdecl operator delete(void *p);


#else


#include <stdlib.h>
#include <malloc.h>

enum POOL_TYPE
	{
	PagedPool = 0,
	NonPagedPool = 1
	};


//void * __cdecl operator new(unsigned int nSize);
//void __cdecl operator delete(void *p);

#include <stdlib.h>
#include <malloc.h>

static inline void * __cdecl operator new(unsigned int nSize)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

static inline void * __cdecl operator new[](unsigned int nSize)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

static inline void * __cdecl operator new(unsigned int nSize, POOL_TYPE iType)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

static inline void * __cdecl operator new[](unsigned int nSize, POOL_TYPE iType)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

static inline void __cdecl operator delete(void* p, POOL_TYPE iType)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}

static inline void __cdecl operator delete(void* p)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}

static inline void __cdecl operator delete[](void* p)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}


#endif // not NT_KERNEL and not VXD_VERSION branch



#endif // not ST20LITE branch


////////////////////////////////////////////////////////////////////
//
//	SECOND PART: Common definitions
//
////////////////////////////////////////////////////////////////////



#include <xtl.h>
#include <winnt.h>
#define ASSERT(x)

#define __far
#define __huge
#define __loadds

#define _fmemcpy	memcpy
#if UNICODE
#define _fstrcpy	wcscpy
#define _fstrcat	wcscat
#define _fstrlen  wcslen
#define _fstrcmp	wcscmp
#else
#define _fstrcpy	strcpy
#define _fstrcat	strcat
#define _fstrlen	strlen
#define _fstrcmp	strcmp
#endif
#define _fmalloc	malloc
#define _ffree		free
#define _halloc(x,y)	new BYTE[x*y]
#define _hfree(x) delete[] x

typedef int			BOOL;
typedef char	 * LPSTR;

typedef unsigned char		BYTE;
typedef unsigned short		WORD;
typedef unsigned long		DWORD;

#ifndef VXD_VERSION
typedef unsigned __int64	QWORD;
#endif

typedef unsigned int		UINT;
typedef signed long		LONG;


#ifndef LOBYTE
#define LOBYTE(w)	    	((BYTE)(w))
#endif

#ifndef HIBYTE
#define HIBYTE(w)     	((BYTE)(((UINT)(w) >> 8) & 0xFF))
#endif

#ifndef LOWORD
#define LOWORD(l)     	((WORD)(DWORD)(l))
#endif

#ifndef HIWORD
#define HIWORD(l)     	((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))
#endif

#ifndef MAKELONG
#define MAKELONG(low, high) ((DWORD)(WORD)(low) | ((DWORD)(WORD)(high) << 16))
#endif

#ifndef max
#define max(a,b)        (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)        (((a) < (b)) ? (a) : (b))
#endif

#if (NT_KERNEL || VXD_VERSION) && !WDM_VERSION
struct RECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
};
#endif





#if VXD_VERSION

#define TCHAR	char
#define __TEXT(x)	x

#endif



//
// Some extended definitions for word/dword arithmetic
//
#ifndef MAKEWORD
#define MAKEWORD(low, high) ((WORD)(BYTE)(low) | ((WORD)(BYTE)(high) << 8))
#endif

#define MAKELONG4(low, lmid, hmid, high) ((DWORD)(BYTE)(low) | ((DWORD)(BYTE)(lmid) << 8) | ((DWORD)(BYTE)(hmid) << 16) | ((DWORD)(BYTE)(high) << 24))
#define LBYTE0(w) ((BYTE)((w) & 0xff))
#define LBYTE1(w) ((BYTE)(((DWORD)(w) >> 8) & 0xff))
#define LBYTE2(w) ((BYTE)(((DWORD)(w) >> 16) & 0xff))
#define LBYTE3(w) ((BYTE)(((DWORD)(w) >> 24) & 0xff))

inline DWORD FLIPENDIAN(DWORD x)
	{
	return MAKELONG4(LBYTE3(x), LBYTE2(x), LBYTE1(x), LBYTE0(x));
	}

//
// Some standard pointer types
//

typedef void 		 	*	APTR;			// local pointer
typedef void __far	*	FPTR;			// far pointer
typedef void __huge	*	HPTR;			//	huge pointer
typedef BYTE __huge 	*	HBPTR;		// huge byte pointer



//
// We need a memory copy for huge memory; will use the windows version
// when available.
//

#if NT_KERNEL

#define _hmemcpy RtlMoveMemory

#else

#if _WINDOWS

#define _hmemcpy memcpy

#else


inline void _hmemcpy(HPTR dst, HPTR src, DWORD size)
	{
	DWORD i, quad, rest;
	quad = size / 4;
	rest = size % 4;

	for(i=0;i<quad;i++) *((DWORD __huge * &)dst)++ = *((DWORD __huge * &)src)++;
	for(i=0;i<rest;i++) *((BYTE __huge * &)dst)++ = *((BYTE __huge * &)src)++;
	}


#endif // not _WINDOWS branch

#endif // not NT_KERNEL branch



//
// Some more stuff
//
typedef BOOL				BIT;

#define HIGH				TRUE
#define LOW					FALSE

#if !NT_KERNEL && !VXD_VERSION
#ifndef FP_OFF
#define FP_OFF(x)			LOWORD(x)
#define FP_SEG(x)			HIWORD(x)
#endif
#endif



//
// Flag construction macro
//
#define MKFLAG(x)		(1UL << (x))

//
// DWORD Bitfield construction and extraction functions
//
inline DWORD MKBF(int bit, int num, DWORD val) {return (((DWORD)val & ((1UL << num) -1)) << bit);}
inline DWORD MKBF(int bit, BOOL val) {return (val ? (1UL << bit) : 0);}
inline DWORD XTBF(int bit, int num, DWORD bf) {return ((bf >> bit) & ((1UL << num) -1));}
inline BOOL XTBF(int bit, DWORD bf) {return ((bf & (1UL << bit)) != 0);}
inline DWORD WRBF(DWORD bf, int bit, int num, DWORD val)
	{
	DWORD mask = ((1UL << num)-1) << bit;
	return (bf & ~mask) | ((val << bit) & mask);
	}
inline DWORD WRBF(DWORD bf, int bit, BOOL val) {return (val ? (bf | (1UL << bit)) : (bf & ~(1UL << bit)));}

//
// WORD Bitfield construction and extraction functions
//
inline WORD MKBFW(int bit, int num, WORD val) {return (((WORD)val & ((1 << num) -1)) << bit);}
inline WORD MKBFW(int bit, BOOL val) {return (val ? (1 << bit) : 0);}
inline WORD XTBFW(int bit, int num, WORD bf) {return ((bf >> bit) & ((1 << num) -1));}
inline BOOL XTBFW(int bit, WORD bf) {return ((bf & (1 << bit)) != 0);}
inline WORD WRBFW(WORD bf, int bit, int num, WORD val)
	{
	WORD mask = ((1 << num)-1) << bit;
	return (bf & ~mask) | ((val << bit) & mask);
	}
inline WORD WRBFW(WORD bf, int bit, BOOL val) {return (val ? (bf | (1 << bit)) : (bf & ~(1 << bit)));}

//
// BYTE Bitfield construction and extraction functions
//
inline BYTE MKBFB(int bit, int num, BYTE val) {return (((BYTE)val & ((1 << num) -1)) << bit);}
inline BYTE MKBFB(int bit, BOOL val) {return (val ? (1 << bit) : 0);}
inline BYTE XTBFB(int bit, int num, BYTE bf) {return ((bf >> bit) & ((1 << num) -1));}
inline BOOL XTBFB(int bit, BYTE bf) {return ((bf & (1 << bit)) != 0);}
inline BYTE WRBFB(BYTE bf, int bit, int num, BYTE val)
	{
	BYTE mask = ((1 << num)-1) << bit;
	return (bf & ~mask) | ((val << bit) & mask);
	}
inline BYTE WRBFB(BYTE bf, int bit, BOOL val) {return (val ? (bf | (1 << bit)) : (bf & ~(1 << bit)));}

//
// Find the most significate one bit or the least significant one bit in a double word
//
inline int FindMSB(DWORD bf) {int i; for(i=31; i>=0; i--) {if (XTBF(31, bf)) return i; bf <<= 1;} return -1;}
inline int FindLSB(DWORD bf) {int i; for(i=0; i<=31; i++) {if (XTBF( 0, bf)) return i; bf >>= 1;} return 32;}



//
// Scaling of values of WORD range to values of WORD range
//
inline WORD ScaleWord(WORD op, WORD from, WORD to) {return (WORD)((DWORD)op * (DWORD) to / (DWORD) from);}
	DWORD ScaleDWord(DWORD op, DWORD from, DWORD to);
	long ScaleLong(long op, long from, long to);
	void MUL32x32(DWORD op1, DWORD op2, DWORD __far & upper, DWORD __far & lower);
	DWORD DIV64x32(DWORD upper, DWORD lower, DWORD op);
//
// Most values in drivers etc. are scaled in a range from 0 to 10000, this functions transfer from and
// to this range
//
inline WORD ScaleFrom10k(WORD op, WORD to) {return ScaleWord(op, 10000, to);}
inline BYTE ScaleByteFrom10k(WORD op, BYTE to) {return (BYTE)ScaleWord(op, 10000, to);}
inline WORD ScaleTo10k(WORD op, WORD from) {return ScaleWord(op, from, 10000);}



#ifndef ONLY_EXTERNAL_VISIBLE

#define FAND(x, y) ScaleWord(x, 10000, y)
#define FAND3(x, y, z) FAND(FAND(x, y), z)

//
// Fix a value inside a boundary
//
inline DWORD BoundTo(DWORD op, DWORD lower, DWORD upper) {if (op<lower) return lower; else if (op>upper) return upper; else return op;}

#if !NT_KERNEL && !VXD_VERSION
//
// Alloc Dos (real) and Windows (protected) memory
//
void AllocDouble(FPTR __far &rmode, FPTR __far &pmode, DWORD size);

//
// Free this memory
//
void FreeDouble(FPTR rmode, FPTR pmode);
#endif

#endif // ONLY_EXTERNAL_VISIBLE



#endif // PRELUDE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\Profiles.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\profiles.cpp
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   28.11.95
//
// PURPOSE:   Classes for configuration (INI) files.
//
// HISTORY:
//
// Date			Author	Comment
// --------		------	-------

#include "library/common/profiles.h"
#include "library/lowlevel/timer.h"
#include "library/common/vddebug.h"

///////////////////////////////////////////////////////////////////////////////
// Generic Profile Implementation
///////////////////////////////////////////////////////////////////////////////

Error GenericProfile::Write(KernelString section, KernelString entry, int value)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->WriteDirect(entry, value);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}

Error GenericProfile::Read(KernelString section, KernelString entry, int __far & value, int deflt)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->ReadDirect(entry, value, deflt);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}

Error GenericProfile::Write(KernelString section, KernelString entry, bool value)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->WriteDirect(entry, value);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}

Error GenericProfile::Read(KernelString section, KernelString entry, bool __far & value, bool deflt)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->ReadDirect(entry, value, deflt);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}


Error GenericProfile::Read(KernelString section, KernelString entry, long __far & value, long deflt)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->ReadDirect(entry, value, deflt);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}

Error GenericProfile::Write(KernelString section, KernelString entry, DWORD value, int base)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->WriteDirect(entry, value, base);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}


Error GenericProfile::Read(KernelString section, KernelString entry, DWORD __far & value, int base, DWORD deflt)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->ReadDirect(entry, value, base, deflt);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}

Error GenericProfile::Write(KernelString section, KernelString entry, WORD value, int base)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->WriteDirect(entry, value, base);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}


Error GenericProfile::Read(KernelString section, KernelString entry, WORD __far & value, int base, WORD deflt)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->ReadDirect(entry, value, base, deflt);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}

Error GenericProfile::Write(KernelString section, KernelString entry, KernelString value)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->WriteDirect(entry, value);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}


Error GenericProfile::Read(KernelString section, KernelString entry, KernelString & value, KernelString deflt)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->ReadDirect(entry, value, deflt);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}



///////////////////////////////////////////////////////////////////////////////
// Static Profile Implementation
///////////////////////////////////////////////////////////////////////////////


static DWORD CalculateID(BOOL section, KernelString name, int start, int range)
	{
	DWORD temp = 0;

	if (name.Length() > 0)
		{
		for (int i = start; i < start + range; i++)
			{
			temp ^= name[i];
			temp = (temp << 3) | (temp >> 29);	// The first 10 characters count
			}

		return (section ? (temp |= 1) : (temp &= ~1));
		}
	else
		return 0;
	}

static ProfileEntry * WalkSetupInfo(ProfileEntry * entries, int start, DWORD id)
	{
	DWORD i = start + 1;
	DWORD range = entries->value;

	while (i < range)
		{
		if (entries[i].id == id)
			return entries + i;
		else if (entries[i].id & 1)
			i += entries[i].value;
		else
			i++;
		}

	return NULL;
	}

Error StaticProfile::FindValue(KernelString entryName, ProfileEntry * __far & entry)
	{
	DWORD id;

	if (entries && (id = CalculateID(FALSE, entryName, 0, entryName.Length())))
		{
		entry = WalkSetupInfo(entries, 0, id);

		if (entry)
			GNRAISE_OK;
		}

	entry = NULL;
	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

Error StaticProfile::FindSection(KernelString section, ProfileEntry * __far & entry)
	{
	int start, range;
	DWORD	id;

	ProfileEntry * entryPtr = this->entries;	// Initialize with root

	start = 0;

	while (entryPtr && start < section.Length())
		{
		range = section.Next(__TEXT("\\"), start - 1) - start;	// Next increments its argument!

		id = CalculateID(TRUE, section, start, range);
		entryPtr = WalkSetupInfo(entryPtr, 0, id);	// entryPtr->value - 1: section header is counted for

		start = start + range + 1;	// Skip "\"
		}

	if (entryPtr)
		{
		entry = entryPtr;
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);

	GNRAISE_OK;
	}

StaticProfile::StaticProfile(ProfileEntry * entries)
	{
	this->protect = FALSE;
	this->entries = entries;
	}

StaticProfile::StaticProfile(const ProfileEntry * entries)
	{
	this->protect = TRUE;
	this->entries = (ProfileEntry *) entries;
	}


StaticProfile::StaticProfile(ProfileEntry * entries, KernelString section)
	{
	ProfileEntry * sectionEntry;

	this->protect = TRUE;

	this->entries = entries;

	// Find section
	if (!IS_ERROR(FindSection(section, sectionEntry)))
		{
		// Now the search will become faster by adapting the offset into the array
		this->entries = sectionEntry;
		}
	}

StaticProfile::StaticProfile(StaticProfile * parent, KernelString section)
	{
	ProfileEntry * sectionEntry;

	this->protect = TRUE;

	if (!IS_ERROR(parent->FindSection(section, sectionEntry)))
		this->entries = sectionEntry;
	else
		this->entries = NULL;
	}

GenericProfile * StaticProfile::CreateSection(KernelString section)
	{
	StaticProfile *profile = new StaticProfile(this, section);
	profile->protect = this->protect;   // clone protection setting
	return profile;
	}

BOOL StaticProfile::IsValid(void)
	{
	return TRUE;
	}

Error StaticProfile::CalculateByteSize (int & size)
	{
	// The top section has the number of ProfileEntry entries.
	size = entries->value * sizeof(ProfileEntry);
	GNRAISE_OK;
	}

Error StaticProfile::WriteDW(KernelString entry, DWORD value)
	{
	ProfileEntry * valEntry;

	if (protect)
		GNRAISE(GNR_OBJECT_READ_ONLY);
	else
		{
		if (!IS_ERROR(FindValue(entry, valEntry)))
			valEntry->value = value;
		else
			GNRAISE(GNR_OBJECT_NOT_FOUND);
		}

	GNRAISE_OK;
	}

Error StaticProfile::ReadDW(KernelString entry, DWORD __far & value)
	{
	ProfileEntry * valEntry;

	if (!IS_ERROR(FindValue(entry, valEntry)))
		value = valEntry->value;
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);

	GNRAISE_OK;
	}

Error StaticProfile::WriteDirect(KernelString entry, int value)
	{
	GNRAISE(WriteDW(entry, (DWORD) value));	// Type size platform specific...
	}

Error StaticProfile::WriteDirect(KernelString entry, long value)
	{
	GNRAISE(WriteDW(entry, (DWORD) value));
	}

Error StaticProfile::WriteDirect(KernelString entry, WORD value, int base)
	{
	GNRAISE(WriteDW(entry, ((DWORD) value) & 0xffff0000));
	}

Error StaticProfile::WriteDirect(KernelString entry, DWORD value, int base)
	{
	GNRAISE(WriteDW(entry, value));
	}

Error StaticProfile::ReadDirect(KernelString entry, int __far & value, int deflt)
	{
	DWORD dw;
	Error error;

	if (!IS_ERROR(error = ReadDW(entry, dw)))
		value = (int) dw;
	else
		value = deflt;

	GNRAISE(error);
	}

Error StaticProfile::ReadDirect(KernelString entry, long __far & value, long deflt)
	{
	DWORD dw;
	Error error;

	if (!IS_ERROR(error = ReadDW(entry, dw)))
		value = (long) dw;
	else
		value = deflt;

	GNRAISE(error);
	}

Error StaticProfile::ReadDirect(KernelString entry, WORD __far & value, int base, WORD deflt)
	{
	DWORD dw;
	Error error;

	if (!IS_ERROR(error = ReadDW(entry, dw)))
		value = (WORD) dw;
	else
		value = deflt;

	GNRAISE(error);
	}

Error StaticProfile::ReadDirect(KernelString entry, DWORD __far & value, int base, DWORD deflt)
	{
	DWORD dw;
	Error error;

	if (!IS_ERROR(error = ReadDW(entry, dw)))
		value = (int) dw;
	else
		value = deflt;

	GNRAISE(error);
	}

Error StaticProfile::WriteDirect(KernelString entry, KernelString value)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error StaticProfile::ReadDirect(KernelString entry, KernelString & value, KernelString deflt)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}


Error StaticProfile::WriteDirect(KernelString entry, bool value)
	{
	GNRAISE(WriteDW(entry, value ? 1 : 0));
	}

Error StaticProfile::ReadDirect(KernelString entry, bool __far & value, bool deflt)
	{
	DWORD dw;
	Error error;

	if (!IS_ERROR(error = ReadDW(entry, dw)))
		value = (bool) (dw != 0);
	else
		value = deflt;

	GNRAISE(error);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\KrnlStr.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlstr.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//

#ifndef KRNLSTR
#define KRNLSTR

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"

class KernelStringBuffer;

class __far KernelString
	{
	private:
		KernelStringBuffer	*	buffer;
	public:
		KernelString(void);
		KernelString(const TCHAR __far * str);
		KernelString(const TCHAR ch);
#if NT_KERNEL
		KernelString(const UNICODE_STRING & org);
#endif
		KernelString(const KernelString & str);
		KernelString(DWORD value, int digits = 0, int base = 10, TCHAR fill = __TEXT('0'));
		KernelString(int value, int digits = 0, int base = 10, TCHAR fill = __TEXT('0'));
		~KernelString();

		// returns the length of the string EXCLUDING the succeeding zero...
		int Length() const;

		long ToInt(int base = 10);
		DWORD ToUnsigned(int base = 10);


		BOOL Get(TCHAR __far * str, int len);
#if NT_KERNEL
		BOOL Get(UNICODE_STRING & us);
#endif

		KernelString & operator = (const TCHAR __far * str);
#if NT_KERNEL
		KernelString & operator = (const UNICODE_STRING & str);
#endif
		KernelString & operator = (const KernelString str);

		friend KernelString operator+ (const KernelString u, const KernelString v);
		KernelString & operator+= (const KernelString u);
		friend KernelString operator* (const KernelString u, const int num);
		KernelString & operator*= (const int num);

		int Compare(const KernelString str);

		friend BOOL operator==(const KernelString u, const KernelString v);
		friend BOOL operator!=(const KernelString u, const KernelString v);
		friend BOOL operator<(const KernelString u, const KernelString v);
		friend BOOL operator>(const KernelString u, const KernelString v);
		friend BOOL operator<=(const KernelString u, const KernelString v);
		friend BOOL operator>=(const KernelString u, const KernelString v);

		friend KernelString operator << (const KernelString u, int index);
		friend KernelString operator >> (const KernelString u, int index);
		KernelString & operator <<= (int index);
		KernelString & operator >>= (int index);

		KernelString Seg(int start, int num) const;	// Extract seqment of string
		KernelString Caps(void);
		KernelString Head(int num) const;				// Return the first num characters
		KernelString Tail(int num) const;				// Return the last num characters

		int First(KernelString str) const;				// Find first occurrence of str
		int Next(KernelString str, int pos) const;	// Find next occurrence of str
		int Last(KernelString str) const;				// Find last occurrence of str
		int Prev(KernelString str, int pos) const;	// Find previous occurrence of str

		int First(TCHAR c) const;							// Find first occurrence of c (-1 if not found)
		int Next(TCHAR c, int pos) const;				// Find next occurrence of c (-1 if not found)
		int Last(TCHAR c) const;							// Find last occurrence of c (-1 if not found)
		int Prev(TCHAR c, int pos) const;				// Find prevoius occurrence of c (-1 if not found)
		BOOL Contains(TCHAR c) const;						// Test if character occurs in string

		// deletes spaces (and tabs) at beginning or end of string...
		KernelString Trim();

		TCHAR& operator[] (const int index);
		const TCHAR& operator[] (const int index) const;

//
// Unsafe functions
//
#if NT_KERNEL
		operator UNICODE_STRING * (void);
		operator UNICODE_STRING & (void);
#else
		operator TCHAR * (void);
#endif
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\prelude.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\prelude.cpp
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:
//
// HISTORY:
//
//



#if   LINUX
////////////////////////////////////////////////////////////////////
//
//	LINUX
//
////////////////////////////////////////////////////////////////////


#define MUNGWALL	0

#include <stdlib.h>
#include <malloc.h>
#include "prelude.h"

#if MUNGWALL
#include "vddebug.h"
#include <debug.h>
DWORD	memAllocated = 0;
DWORD maxAllocated = 0;
DWORD numAllocated[1024];
DWORD newAllocated[1024];
#endif

void PrintFreeMemory (void);


void MUL32x32(DWORD op1, DWORD op2, DWORD & upper, DWORD & lower)
	{
	DWORD u, l;

	__asm__ (
		".intel_syntax \n"
		"movl		%%eax, %0 \n"
		"movl		%%edx, %1 \n"
		"mul		%%edx \n"
		".att_syntax \n"
		:"=r"(l), "=r"(u)
		:"0"(l), "1"(u)
// 	:"eax", "edx"
		);

	upper = u;
	lower = l;
	}

DWORD DIV64x32(DWORD upper, DWORD lower, DWORD op)
	{
	DWORD res;

	if(op)
		{
		__asm__ (
			".intel_syntax \n"
			"movl		%%edx, %0 \n"
			"movl		%%eax, %1 \n"
			"movl		%%ecx, %2 \n"
			"divl		%%ecx \n"
			".att_syntax \n"
			:"=r"(res)
			:"r"(lower), "r"(upper)
			);
		return res;
		}
	else
		return 0;
	}

#elif MACINTOSH
////////////////////////////////////////////////////////////////////
//
//	Apple Macintosh
//
////////////////////////////////////////////////////////////////////

#include "prelude.h"


#include <stdlib.h>


void *  operator new(size_t nSize)
	{
	return malloc(nSize);
	}

void *  operator new(size_t nSize, POOL_TYPE iType)
	{
	return malloc(nSize);
	}

void	operator delete(void* p)
	{
	free(p);
	}


void *  operator new[](size_t nSize)
	{
	return malloc(nSize);
	}

void *  operator new[](size_t nSize, POOL_TYPE iType)
	{
	return malloc(nSize);
	}

void	operator delete[](void* p)
	{
	free(p);
	}


#else
////////////////////////////////////////////////////////////////////
//
//	WIN32 || NT_KERNEL || VXD_VERSION
//
////////////////////////////////////////////////////////////////////

#include "prelude.h"

#if NT_KERNEL


#ifndef POOL_ALLOCATION_TAG
// Default tag: "VddV"
#define POOL_ALLOCATION_TAG 0x56646456
#endif

void * __cdecl operator new(size_t nSize, POOL_TYPE iType)
	{
	return ExAllocatePoolWithTag(iType, nSize, (DWORD) POOL_ALLOCATION_TAG);
	}

void * __cdecl operator new(size_t nSize)
	{
	return ExAllocatePoolWithTag(NonPagedPool, nSize, (DWORD) POOL_ALLOCATION_TAG);
	}

void __cdecl operator delete(void* p)
	{
	if (p) ExFreePool(p);
	}

#endif



#if VXD_VERSION

void * __cdecl operator new(unsigned int nSize, POOL_TYPE iType)
	{
	return _HeapAllocate(nSize, iType);
	}

void * __cdecl operator new(unsigned int nSize)
	{
	return _HeapAllocate(nSize, NonPagedPool);
	}

void __cdecl operator delete(void* p)
	{
	if (p) _HeapFree(p, 0);
	}


#endif

#if VXD_VERSION || WDM_VERSION

//
// This is normally in the run time libraries, so we define it here.
// It is there to detect calls of pure virtual functions.
//

int __cdecl _purecall(void)
	{
	// Insert your own error reporting code here
	return 0;
	}

#endif // VXD_VERSION



#if WDM_VERSION

void MUL32x32(DWORD op1, DWORD op2, DWORD __far & upper, DWORD __far & lower)
	{
	unsigned __int64 ui;

	ui = (unsigned __int64) op1 * (unsigned __int64) op2;

	lower = (DWORD) ui;
	upper = (DWORD) (ui >> 32);
	}

DWORD DIV64x32(DWORD upper, DWORD lower, DWORD op)
	{
	unsigned __int64 ui;

	ui = ((unsigned __int64) upper << 32) | lower;

	return (DWORD) (ui / op);
	}

DWORD ScaleDWord(DWORD op, DWORD from, DWORD to)
	{
	unsigned __int64 ui;

	if (to && op)
		{
		ui = (unsigned __int64) op * (unsigned __int64) to;

		return (DWORD) (ui / (unsigned __int64) from);
		}
	else
		return 0;
	}

long ScaleLong(long op, long from, long to)
	{
	__int64 i;

	if (to && op)
		{
		i = (__int64) op * (__int64) to;

		return (long) (i / (__int64) from);
		}
	else
		return 0;
	}

#else

void MUL32x32(DWORD op1, DWORD op2, DWORD __far & upper, DWORD __far & lower)
	{
	DWORD u, l;

	__asm {
			mov	eax, op1
			mov	edx, op2
			mul	edx
			mov	u, edx
			mov	l, eax
			}

	upper = u;
	lower = l;
	}

DWORD DIV64x32(DWORD upper, DWORD lower, DWORD op)
	{
	DWORD res;

	if (op)
		{
		__asm {
				mov	edx, upper
				mov	eax, lower
				mov	ecx, op
				div	ecx
				mov	res, eax
				};
		return res;
		}
	else
		return 0;
	}

DWORD ScaleDWord(DWORD op, DWORD from, DWORD to)
	{
	DWORD	res;

	if (to && op)
		{
		__asm {
				mov	eax, op
				mov	edx, to
				mul	edx
				mov	ecx, from
				cmp	edx, ecx
				jge	done
				div	ecx
				mov	res, eax
			done:
				};

		return res;
		}
	else
		return 0;
	}

long ScaleLong(long op, long from, long to)
	{
	long	res;

	if (to && op)
		{
		__asm {
				mov	eax, op
				mov	edx, to
				imul	edx
				mov	ecx, from
				cmp	edx, ecx
				jge	done
				idiv	ecx
				mov	res, eax
			done:
				};

		return res;
		}
	else
		return 0;
	}

#endif	// WDM_VERSION

#endif	// of !WIN32 && !NT_KERNEL && !VXD_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\resourceDll.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef RESOURCEDLL_INCLUDED
#define RESOURCEDLL_INCLUDED



#include "library\common\profiles.h"
#include "library\common\krnlstr.h"

class ResourceDLL
	{
	private:
		BOOL libLoaded;
		HINSTANCE resInst;
		LANGID langId;
		KernelString resourceName;
	public:
		ResourceDLL(KernelString vendor, KernelString product, KernelString version, KernelString resDefName);
		~ResourceDLL();
		void Load(HINSTANCE defInst);
		void SetLanguage(LANGID langId);
		BOOL LoadStringResource(UINT resourceID, WCHAR * invalidMsg, int & invalidMsgSize);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\Profiles.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\profiles.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   28.11.95
//
// PURPOSE:   Classes for configuration (INI) files.
//
// HISTORY:
//
// Date			Author	Comment
// --------		------	-------
// 16.11.1999  Franky   Added some documentation
// 20.04.2000	Martin	Added some more documentation after searching several hours for a bug
//								(I didn't know to call InitProfiles() first before creating a new profile object in NT kernel)


// The Profile classes are used to store configuration data in a tree-like
// structure. The location where profile information is stored depends on
// the operating system; for Win16, it's in .ini files, for W95/W98/NT it's
// in the registry.
// Where the data is stored is hidden from the programmer; he just uses
// the public methods to store or retrieve key/value pairs.
//
// There are 3 types of profile classes:
// GenericProfile - this is the base class
// StaticProfile - it stores its data in a linear array instead of a tree
//                 and is mostly used for storage in ROM areas
// Profile - derived from GenericProfile, mostly used class
//
// All classes are able to create new entries (actual key/value pairs)
// or sections (folders) through their constructors.
//
// The entries that can be read or written are:
// int, long, DWORD, WORD, string, (bool - only under Win32)
// For ReadXXX functions, if the desired key cannot be opened
// you can pass a default value that will be returned instead.
//
// When creating a new profile object, the corresponding
// object is either opened for read/write access (if it exists)
// or is created newly if it didn't yet exist.
//
// All methods of the ReadDirect() and WriteDirect() format
// (only found in the derived classes) are directly reading
// from / writing to the specified location, using absolute
// path names.
// Methods without "Direct" in their name allow a parent entry
// to be named first under which the child entry will be located
// (which means the path is a relative path, starting at the
// location of the current Profile object).
//
// The constructors can be called in one of the following ways:
//
// bla = new Profile(KernelString name)
//   creates a Profile object with <name> as its complete
//   "path", as seen from the root of the profile tree.
//
// bla = new Profile(Profile * parent, KernelString name)
//   creates a Profile object under the given "parent"
//   object in the tree.
//
// bla = new Profile(KernelString main, KernelString section)
//   creates a Profile object under the location
//   "software\viona\<main>\<section>" in the tree.
//   (e.g. "software\viona\Ravisent\2.0")
//
// bla = new Profile(KernelString vendor, KernelString product, KernelString version)
//   creates a Profile object under the location
//   "software\<vendor>\<product>\<version>" in the tree
//   (e.g. "software\SomeoneProducts, Unlimited\Kickstart\40.72")
//
// IMPORTANT when using the Profiles class in kernel mode drivers:
// Before creating a new Profile object (see above) you have to call the static function
//	Profiles::InitProfiles(). And after deleting the Profile object you have to call
// the static function Profiles::CleanupProfiles()!!!

// Parameter: Was bei Aufruf ohne Default?

#ifndef _PROFILES_H_
#define _PROFILES_H_

#include "gnerrors.h"
#include "krnlstr.h"

#define MAX_PROFILE_NAME_LENGTH 40

// error: unable to write to the specified profile
#define GNR_PROFILE_WRITE			MKERR(ERROR, PROFILES, GENERAL, 0x01)

// error: unable to read from the specified profile
#define GNR_PROFILE_READ			MKERR(ERROR, PROFILES, GENERAL, 0x02)

// error: No child profile could be created
#define GNR_PROFILE_NO_LEVEL		MKERR(ERROR, PROFILES, GENERAL, 0x03)

// Entry for the generic profile
class GenericProfile
	{
	public:
		virtual ~GenericProfile(void) {}
		virtual GenericProfile * CreateSection(KernelString section) = 0;

		virtual BOOL IsValid(void) = 0;

		// XXXDirect methods write directly to the absolute location given in "entry"
		// entry is the absolute path name, value is the value to be written.
		// "deflt", where used, is the value to return from a ReadXXX function when
		// the desired entry does not exist. If in such a case no parameter for
		// "deflt" is passed, the value of "value" is not changed.

		virtual Error WriteDirect(KernelString entry, int value) = 0;
		virtual Error ReadDirect(KernelString entry, int __far & value, int deflt) = 0;
		Error ReadDirect(KernelString entry, int __far & value) {return ReadDirect(entry, value, value);}

		virtual Error WriteDirect(KernelString entry, bool value) = 0;
		virtual Error ReadDirect(KernelString entry, bool __far & value, bool deflt) = 0;
		Error ReadDirect(