 {-0.706033f, -0.682031f, -0.190659f}, {0.408724f, 0.280925f} },
    { {0.298078f, -0.999833f, 0.210707f}, {0.910628f, -0.198922f, 0.362197f}, {0.416138f, 0.307172f} },
    { {0.274803f, -0.960770f, -0.025866f}, {0.973935f, 0.111958f, -0.197270f}, {0.332567f, 0.276662f} },
    { {0.262285f, -0.929234f, -0.000302f}, {0.935444f, -0.284423f, -0.209877f}, {0.335166f, 0.272794f} },
    { {-0.271725f, -1.160446f, 0.113197f}, {-0.612366f, -0.563728f, 0.554273f}, {0.311695f, 0.320208f} },
    { {-0.268700f, -1.192359f, 0.076164f}, {-0.867269f, -0.497212f, 0.024987f}, {0.312249f, 0.322798f} },
    { {-0.166192f, -1.172176f, 0.082440f}, {0.115864f, -0.728371f, 0.675316f}, {0.331038f, 0.321160f} },
    { {-0.282515f, -1.098839f, 0.145114f}, {-0.657681f, -0.246759f, 0.711734f}, {0.398967f, 0.250791f} },
    { {-0.293585f, -1.029920f, 0.144211f}, {-0.645995f, 0.105074f, 0.756075f}, {0.393288f, 0.250928f} },
    { {-0.289097f, -0.917639f, 0.055867f}, {-0.999161f, 0.032236f, 0.025264f}, {0.384035f, 0.264295f} },
    { {-0.287043f, -0.909182f, -0.020157f}, {-0.991421f, 0.051540f, -0.120114f}, {0.383338f, 0.275799f} },
    { {-0.286240f, -0.959791f, 0.119350f}, {-0.989940f, -0.053648f, 0.130925f}, {0.387508f, 0.254690f} },
    { {-0.288200f, -0.526269f, -0.166868f}, {-0.551510f, 0.143175f, 0.821789f}, {0.308675f, 0.268738f} },
    { {-0.232035f, -0.481650f, -0.136949f}, {-0.551510f, 0.143175f, 0.821789f}, {0.318970f, 0.265117f} },
    { {-0.275292f, -0.472512f, -0.167572f}, {-0.551510f, 0.143175f, 0.821789f}, {0.311041f, 0.264375f} },
    { {-0.214979f, -0.496644f, -0.248814f}, {-0.764794f, 0.175511f, -0.619909f}, {0.349341f, 0.310397f} },
    { {-0.288200f, -0.526269f, -0.166868f}, {-0.764794f, 0.175511f, -0.619909f}, {0.351782f, 0.297998f} },
    { {-0.275292f, -0.472512f, -0.167572f}, {-0.764794f, 0.175511f, -0.619909f}, {0.347352f, 0.298104f} },
    { {0.199262f, -1.222086f, -0.119777f}, {0.381606f, -0.814833f, -0.436376f}, {0.311033f, 0.290872f} },
    { {0.236907f, -1.180343f, -0.091713f}, {0.803735f, -0.457828f, -0.380005f}, {0.314473f, 0.286626f} },
    { {0.221320f, -1.150861f, -0.118681f}, {0.832293f, -0.406163f, -0.377253f}, {0.316902f, 0.290707f} },
    { {0.205958f, -0.623267f, 0.283670f}, {0.645420f, -0.118923f, 0.754513f}, {0.399253f, 0.276610f} },
    { {0.213969f, -0.899592f, -0.052535f}, {-0.997492f, 0.039523f, -0.058722f}, {0.382547f, 0.280698f} },
    { {0.215080f, -0.890057f, 0.017273f}, {-0.989345f, 0.078604f, -0.122551f}, {0.381762f, 0.270135f} },
    { {0.232195f, -0.969125f, -0.129921f}, {0.039987f, 0.429793f, -0.902041f}, {0.316095f, 0.304680f} },
    { {-0.193131f, -1.003442f, 0.314212f}, {-0.440292f, -0.156803f, 0.884056f}, {0.326100f, 0.307465f} },
    { {0.260820f, -0.368920f, -0.125452f}, {0.887339f, 0.431791f, -0.161821f}, {0.381341f, 0.291731f} },
    { {0.260820f, -0.368920f, -0.125452f}, {0.887339f, 0.431791f, -0.161821f}, {0.409309f, 0.255967f} },
    { {0.314734f, -1.159232f, 0.075731f}, {0.978772f, -0.179465f, -0.098979f}, {0.419191f, 0.320109f} },
    { {0.321173f, -0.995015f, 0.143754f}, {0.545388f, 0.264951f, 0.795206f}, {0.329745f, 0.250997f} },
    { {0.317977f, -1.064743f, 0.144667f}, {0.234072f, -0.180878f, 0.955245f}, {0.323999f, 0.250859f} },
    { {-0.215866f, -0.246713f, -0.100200f}, {-0.683685f, 0.283169f, -0.672600f}, {0.398223f, 0.246049f} },
    { {-0.162093f, -0.324994f, -0.142361f}, {-0.605324f, 0.475173f, -0.638587f}, {0.388367f, 0.252402f} },
    { {-0.211087f, -0.407967f, -0.176466f}, {-0.840443f, 0.242432f, -0.484647f}, {0.397347f, 0.259137f} },
    { {0.305901f, -0.926170f, 0.118910f}, {0.987756f, 0.062261f, 0.143043f}, {0.335419f, 0.254756f} },
    { {-0.232937f, -0.849266f, -0.128994f}, {-0.936472f, -0.119528f, -0.329748f}, {0.401352f, 0.294952f} },
    { {-0.249435f, -0.520515f, 0.262561f}, {0.968298f, -0.248138f, -0.028762f}, {0.368848f, 0.233020f} },
    { {-0.308751f, -0.583534f, 0.192201f}, {-0.862991f, 0.074966f, 0.499627f}, {0.356502f, 0.243666f} },
    { {-0.296485f, -0.725490f, 0.042436f}, {-0.914296f, -0.315358f, 0.254189f}, {0.368200f, 0.266328f} },
    { {-0.302610f, -0.717268f, -0.000221f}, {-0.877452f, -0.380330f, -0.292278f}, {0.367522f, 0.272782f} },
    { {-0.228981f, -0.181087f, -0.088140f}, {0.984360f, -0.004725f, -0.176106f}, {0.396820f, 0.286085f} },
    { {-0.226577f, -0.122977f, -0.047134f}, {0.955647f, -0.070248f, -0.286013f}, {0.401609f, 0.279881f} },
    { {-0.302564f, -0.919919f, -0.017806f}, {-0.814826f, 0.537926f, -0.216087f}, {0.384223f, 0.275443f} },
    { {-0.302564f, -0.919919f, -0.017806f}, {-0.814826f, 0.537926f, -0.216087f}, {0.414115f, 0.300687f} },
    { {-0.200854f, -0.914135f, -0.017881f}, {-0.105957f, 0.926058f, -0.362202f}, {0.395472f, 0.300217f} },
    { {-0.238920f, -0.655763f, 0.221391f}, {-0.920361f, -0.006023f, 0.391024f}, {0.317708f, 0.279248f} },
    { {-0.158450f, -0.568113f, 0.302483f}, {-0.708413f, 0.001495f, 0.705797f}, {0.332458f, 0.272134f} },
    { {-0.220589f, -0.524437f, 0.259586f}, {-0.846076f, 0.112341f, 0.521090f}, {0.321068f, 0.268589f} },
    { {-0.123835f, -0.451583f, 0.289042f}, {-0.603420f, 0.391178f, 0.694884f}, {0.338802f, 0.262676f} },
    { {-0.171112f, -0.992025f, -0.129621f}, {0.874912f, 0.423741f, 0.234463f}, {0.329992f, 0.292362f} },
    { {-0.212426f, -0.964817f, -0.109750f}, {0.814797f, 0.550122f, 0.182954f}, {0.332234f, 0.289355f} },
    { {-0.212426f, -0.964817f, -0.109750f}, {-0.047919f, 0.646869f, -0.761094f}, {0.397593f, 0.304330f} },
    { {-0.116378f, -0.479162f, 0.348913f}, {-0.428316f, 0.263937f, 0.864224f}, {0.340169f, 0.264915f} },
    { {-0.095602f, -0.381657f, 0.317300f}, {-0.699954f, 0.364334f, 0.614267f}, {0.343978f, 0.257001f} },
    { {-0.177122f, -1.173484f, -0.118385f}, {-0.781063f, -0.505718f, -0.366318f}, {0.405119f, 0.290662f} },
    { {0.199262f, -1.222086f, -0.119777f}, {0.381606f, -0.814833f, -0.436376f}, {0.322131f, 0.325210f} },
    { {0.135768f, -1.242706f, -0.072460f}, {-0.115201f, -0.956853f, -0.266762f}, {0.333770f, 0.326884f} },
    { {-0.216691f, -0.660921f, 0.231745f}, {-0.811464f, -0.097665f, 0.576184f}, {0.362879f, 0.237683f} },
    { {0.323642f, -1.029202f, 0.100049f}, {0.933107f, 0.108640f, 0.342796f}, {0.326928f, 0.257610f} },
    { {0.325058f, -0.972813f, 0.080778f}, {0.943684f, 0.145869f, 0.296957f}, {0.331575f, 0.260526f} },
    { {0.032002f, -0.251750f, 0.315597f}, {0.891632f, 0.041780f, 0.450829f}, {0.390997f, 0.224995f} },
    { {0.017795f, -0.464706f, 0.363432f}, {0.891632f, 0.041780f, 0.450829f}, {0.373447f, 0.217757f} },
    { {0.015018f, -0.597857f, 0.371079f}, {0.964367f, -0.004922f, 0.264521f}, {0.362475f, 0.216600f} },
    { {-0.068882f, -0.277541f, 0.259799f}, {-0.201238f, 0.955928f, -0.213789f}, {0.371281f, 0.233438f} },
    { {-0.123835f, -0.451583f, 0.289042f}, {-0.603420f, 0.391178f, 0.694884f}, {0.345628f, 0.229013f} },
    { {-0.068882f, -0.277541f, 0.259799f}, {-0.670733f, 0.335903f, 0.661276f}, {0.331285f, 0.233438f} },
    { {-0.097613f, -0.293084f, 0.217344f}, {-0.357756f, 0.386344f, 0.850147f}, {0.332566f, 0.239862f} },
    { {0.017886f, -0.314175f, 0.353252f}, {-0.847112f, 0.106596f, 0.520614f}, {0.334304f, 0.219297f} },
    { {-0.009208f, -0.367256f, 0.320035f}, {-0.847112f, 0.106596f, 0.520614f}, {0.338678f, 0.224323f} },
    { {0.015830f, -0.362231f, 0.359745f}, {-0.847112f, 0.106596f, 0.520614f}, {0.338264f, 0.218315f} },
    { {0.090080f, -0.365177f, 0.306672f}, {0.581643f, 0.084417f, 0.809052f}, {0.378013f, 0.255664f} },
    { {0.017886f, -0.314175f, 0.353252f}, {0.581643f, 0.084417f, 0.809052f}, {0.364780f, 0.251524f} },
    { {0.015830f, -0.362231f, 0.359745f}, {0.581643f, 0.084417f, 0.809052f}, {0.364403f, 0.255425f} },
    { {0.007536f, -0.556010f, 0.385927f}, {-0.847112f, 0.106596f, 0.520614f}, {0.354233f, 0.214353f} },
    { {-0.019558f, -0.609090f, 0.352709f}, {-0.847112f, 0.106596f, 0.520614f}, {0.358608f, 0.219379f} },
    { {0.005479f, -0.604066f, 0.392419f}, {-0.847112f, 0.106596f, 0.520614f}, {0.358194f, 0.213371f} },
    { {0.079730f, -0.607012f, 0.339347f}, {0.581643f, 0.084417f, 0.809052f}, {0.376115f, 0.275291f} },
    { {0.007536f, -0.556010f, 0.385927f}, {0.581643f, 0.084417f, 0.809052f}, {0.362882f, 0.271152f} },
    { {0.005479f, -0.604066f, 0.392419f}, {0.581643f, 0.084417f, 0.809052f}, {0.362505f, 0.275052f} },
    { {-0.322370f, -0.709769f, -0.057088f}, {-0.750085f, 0.488051f, 0.446295f}, {0.366904f, 0.281387f} },
    { {-0.288289f, -0.654833f, -0.059883f}, {-0.750085f, 0.488051f, 0.446295f}, {0.362377f, 0.281810f} },
    { {-0.318381f, -0.674884f, -0.090598f}, {-0.760239f, 0.493159f, 0.422883f}, {0.364030f, 0.286457f} },
    { {-0.247604f, -0.726455f, -0.121434f}, {-0.625826f, -0.501928f, -0.597001f}, {0.368279f, 0.291123f} },
    { {-0.322370f, -0.709769f, -0.057088f}, {-0.625826f, -0.501928f, -0.597001f}, {0.366904f, 0.281387f} },
    { {-0.318381f, -0.674884f, -0.090598f}, {-0.625826f, -0.501928f, -0.597001f}, {0.364030f, 0.286457f} },
    { {0.333940f, -0.739006f, 0.050902f}, {0.936938f, -0.237022f, 0.256841f}, {0.350843f, 0.265047f} },
    { {0.302915f, -0.784960f, 0.084378f}, {0.968829f, -0.019487f, 0.246963f}, {0.347056f, 0.259981f} },
    { {-0.289317f, -1.042562f, -0.114192f}, {-0.968540f, 0.014574f, -0.248431f}, {0.394329f, 0.290027f} },
    { {-0.314857f, -1.039015f, 0.039891f}, {-0.977920f, 0.128309f, -0.164950f}, {0.394037f, 0.266713f} },
    { {-0.319712f, -1.090746f, 0.028526f}, {-0.169513f, -0.196269f, 0.965787f}, {0.302899f, 0.314551f} },
    { {-0.255971f, -1.086796f, 0.040517f}, {-0.092809f, -0.101414f, 0.990506f}, {0.314582f, 0.314230f} },
    { {-0.314857f, -1.039015f, 0.039891f}, {-0.092809f, -0.101414f, 0.990506f}, {0.303789f, 0.310352f} },
    { {-0.326696f, -0.745139f, -0.001002f}, {-0.800335f, -0.569657f, -0.186962f}, {0.369819f, 0.272900f} },
    { {-0.312584f, -0.711296f, -0.058727f}, {-0.522910f, -0.503191f, -0.688014f}, {0.415951f, 0.283755f} },
    { {0.159539f, -0.112797f, 0.006867f}, {0.999924f, -0.012230f, -0.001254f}, {0.402448f, 0.271710f} },
    { {0.158529f, -0.207091f, 0.121621f}, {0.999896f, -0.014404f, -0.000962f}, {0.394677f, 0.254346f} },
    { {0.317594f, -0.480569f, 0.092160f}, {0.984676f, 0.090544f, 0.149050f}, {0.372140f, 0.258804f} },
    { {0.324051f, -0.504400f, 0.050432f}, {0.953962f, 0.299834f, 0.007485f}, {0.370176f, 0.265118f} },
    { {0.153667f, -0.350668f, 0.036247f}, {0.652996f, 0.684870f, -0.323341f}, {0.382845f, 0.267264f} },
    { {0.317594f, -0.480569f, 0.092160f}, {0.643975f, 0.658568f, -0.389339f}, {0.372140f, 0.258804f} },
    { {0.324051f, -0.504400f, 0.050432f}, {0.653218f, 0.696592f, -0.296758f}, {0.370176f, 0.265118f} },
    { {-0.036071f, -1.000924f, 0.340965f}, {-0.119822f, -0.373630f, 0.919806f}, {0.354889f, 0.307261f} },
    { {0.234356f, -1.096259f, 0.083289f}, {0.381467f, -0.868116f, 0.317582f}, {0.404458f, 0.260146f} },
    { {0.234593f, -1.114849f, 0.017183f}, {0.509017f, -0.856254f, 0.087921f}, {0.404501f, 0.270149f} },
    { {0.228641f, -1.101025f, -0.059494f}, {0.589855f, -0.711693f, -0.381529f}, {0.321009f, 0.281751f} },
    { {0.234593f, -1.114849f, 0.017183f}, {0.509017f, -0.856254f, 0.087921f}, {0.319870f, 0.270149f} },
    { {0.214271f, -1.128507f, -0.000573f}, {0.338723f, -0.937652f, -0.077944f}, {0.318744f, 0.272835f} },
    { {-0.100229f, -0.634711f, 0.369926f}, {-0.218639f, -0.050835f, 0.974481f}, {0.343129f, 0.277539f} },
    { {-0.060630f, -0.681714f, 0.372035f}, {-0.057018f, -0.050335f, 0.997103f}, {0.350388f, 0.281354f} },
    { {0.126898f, -1.146976f, 0.231600f}, {0.349098f, -0.846877f, 0.401161f}, {0.384761f, 0.237705f} },
    { {-0.209938f, -0.960969f, -0.182611f}, {-0.250673f, 0.332289f, -0.909256f}, {0.397137f, 0.304018f} },
    { {-0.206689f, -1.018105f, -0.192016f}, {-0.126103f, -0.084345f, -0.988425f}, {0.396541f, 0.308655f} },
    { {-0.193753f, -1.019618f, -0.193537f}, {-0.126103f, -0.084345f, -0.988425f}, {0.394170f, 0.308778f} },
    { {-0.192200f, -1.104313f, -0.172642f}, {-0.140985f, -0.239574f, -0.960587f}, {0.393885f, 0.315652f} },
    { {-0.237168f, -1.026719f, -0.155175f}, {-0.862268f, -0.327828f, -0.386035f}, {0.393024f, 0.296229f} },
    { {-0.250052f, -1.036398f, -0.115736f}, {-0.912037f, -0.302122f, -0.277328f}, {0.393821f, 0.290261f} },
    { {-0.163451f, -0.664948f, 0.342474f}, {-0.503697f, -0.046640f, 0.862621f}, {0.331541f, 0.279993f} },
    { {-0.151565f, -0.769398f, 0.345867f}, {-0.475933f, 0.011929f, 0.879401f}, {0.371818f, 0.220415f} },
    { {-0.163451f, -0.664948f, 0.342474f}, {-0.503697f, -0.046640f, 0.862621f}, {0.363211f, 0.220928f} },
    { {-0.123154f, -1.268707f, -0.021974f}, {0.099020f, -0.981459f, -0.164115f}, {0.338927f, 0.276074f} },
    { {-0.092792f, -1.389129f, -0.008142f}, {0.049333f, -0.389465f, -0.919719f}, {0.375664f, 0.338768f} },
    { {-0.122128f, -1.406020f, 0.027715f}, {-0.780647f, -0.622527f, -0.055233f}, {0.339115f, 0.268555f} },
    { {-0.090352f, -1.409800f, 0.027271f}, {-0.051209f, -0.971439f, -0.231698f}, {0.344940f, 0.268622f} },
    { {-0.095798f, -1.402583f, 0.064460f}, {-0.124923f, -0.948004f, 0.292717f}, {0.343941f, 0.262995f} },
    { {0.125765f, -1.376759f, -0.011337f}, {-0.006487f, -0.382062f, -0.924114f}, {0.335603f, 0.337764f} },
    { {0.157105f, -1.390191f, 0.025553f}, {0.755840f, -0.650954f, -0.070468f}, {0.390298f, 0.268882f} },
    { {0.130829f, -1.389727f, 0.063438f}, {0.232681f, -0.930085f, 0.284255f}, {0.385482f, 0.263150f} },
    { {0.126018f, -1.397541f, 0.025140f}, {0.160997f, -0.960843f, -0.225521f}, {0.384600f, 0.268945f} },
    { {-0.232931f, -1.099791f, -0.142042f}, {-0.632517f, -0.366215f, -0.682502f}, {0.399046f, 0.294241f} },
    { {-0.228691f, -1.184295f, -0.081538f}, {-0.532695f, -0.469316f, -0.704257f}, {0.406009f, 0.285086f} },
    { {-0.159364f, -1.159279f, 0.066433f}, {0.887729f, -0.432614f, -0.157423f}, {0.316209f, 0.262697f} },
    { {-0.185992f, -1.172784f, -0.046613f}, {0.887729f, -0.432614f, -0.157423f}, {0.315096f, 0.279802f} },
    { {-0.186958f, -1.151442f, -0.110709f}, {0.887729f, -0.432614f, -0.157423f}, {0.316855f, 0.289500f} },
    { {-0.283352f, -1.025524f, -0.081190f}, {-0.933917f, -0.054791f, -0.353265f}, {0.392925f, 0.285034f} },
    { {-0.247819f, -0.935326f, 0.283034f}, {0.685139f, -0.118337f, -0.718735f}, {0.334664f, 0.229922f} },
    { {-0.216885f, -0.719787f, 0.260260f}, {0.860934f, -0.166607f, -0.480660f}, {0.352426f, 0.233368f} },
    { {-0.215457f, -0.794104f, 0.288576f}, {0.785472f, -0.147511f, -0.601061f}, {0.346302f, 0.229084f} },
    { {-0.203125f, -0.921933f, 0.052125f}, {0.070603f, -0.822940f, -0.563724f}, {0.395888f, 0.300850f} },
    { {-0.180187f, -0.992979f, 0.124349f}, {-0.157730f, -0.728554f, -0.666581f}, {0.391683f, 0.306616f} },
    { {-0.215797f, -0.967494f, 0.104921f}, {0.031214f, -0.760398f, -0.648707f}, {0.398211f, 0.304548f} },
    { {-0.201861f, -0.913731f, 0.017583f}, {0.507809f, 0.003885f, 0.861461f}, {0.324500f, 0.300184f} },
    { {-0.255926f, -0.932265f, 0.049536f}, {0.507809f, 0.003885f, 0.861461f}, {0.314590f, 0.301688f} },
    { {-0.173893f, -1.058972f, 0.001751f}, {0.507809f, 0.003885f, 0.861461f}, {0.329627f, 0.311972f} },
    { {-0.219339f, -0.174854f, -0.031498f}, {-0.918664f, 0.224772f, -0.324861f}, {0.322823f, 0.277515f} },
    { {-0.187146f, -0.072930f, -0.052016f}, {-0.879940f, 0.268215f, -0.392132f}, {0.314423f, 0.280619f} },
    { {0.157814f, -0.239995f, 0.118837f}, {0.999678f, -0.025386f, -0.000008f}, {0.391966f, 0.254767f} },
    { {0.156688f, -0.279592f, 0.107255f}, {0.999503f, -0.031529f, -0.000628f}, {0.388702f, 0.256520f} },
    { {0.280571f, -0.322080f, 0.163889f}, {0.463181f, 0.222778f, -0.857807f}, {0.307228f, 0.252166f} },
    { {0.156688f, -0.279592f, 0.107255f}, {0.497031f, 0.289605f, -0.817979f}, {0.329935f, 0.248718f} },
    { {-0.297113f, -0.686801f, -0.037317f}, {-0.937556f, 0.017730f, -0.347383f}, {0.365012f, 0.278395f} },
    { {0.310175f, -0.991824f, -0.081631f}, {0.895802f, 0.035601f, -0.443025f}, {0.330008f, 0.285101f} },
    { {0.176161f, -0.683017f, 0.306509f}, {0.409623f, -0.091548f, 0.907650f}, {0.393791f, 0.281460f} },
    { {0.011862f, -0.623795f, 0.328603f}, {0.083079f, 0.032532f, 0.996012f}, {0.363675f, 0.276653f} },
    { {0.032127f, -0.417447f, 0.309849f}, {0.106754f, 0.111923f, 0.987966f}, {0.367390f, 0.259906f} },
    { {-0.182678f, -0.970851f, 0.309196f}, {0.161478f, -0.067316f, -0.984578f}, {0.392140f, 0.304820f} },
    { {-0.006994f, -1.041614f, 0.342547f}, {0.084467f, -0.060041f, -0.994616f}, {0.359937f, 0.310563f} },
    { {0.279307f, -0.939542f, 0.021566f}, {0.957805f, 0.273020f, -0.089834f}, {0.334317f, 0.269486f} },
    { {0.219415f, -0.827723f, -0.163522f}, {0.715749f, -0.190396f, -0.671903f}, {0.343532f, 0.297492f} },
    { {-0.151958f, -0.505046f, -0.361585f}, {0.563708f, -0.700080f, -0.438316f}, {0.370123f, 0.327461f} },
    { {-0.129241f, -0.508163f, -0.326932f}, {0.548452f, -0.724921f, -0.416761f}, {0.369866f, 0.322218f} },
    { {0.188577f, -0.549484f, -0.254471f}, {0.771150f, 0.438915f, 0.461174f}, {0.366461f, 0.311253f} },
    { {0.201539f, -0.727526f, -0.144457f}, {0.733567f, 0.291851f, 0.613761f}, {0.351789f, 0.294607f} },
    { {0.215152f, -0.558031f, -0.290774f}, {0.768923f, 0.440638f, 0.463244f}, {0.365757f, 0.316746f} },
    { {0.128194f, -0.457749f, -0.310489f}, {0.397022f, 0.878542f, 0.265590f}, {0.374021f, 0.319730f} },
    { {0.166997f, -0.499857f, -0.303378f}, {0.677580f, 0.648991f, 0.345970f}, {0.370551f, 0.318654f} },
    { {0.190114f, -0.500472f, -0.347507f}, {0.670677f, 0.658775f, 0.340892f}, {0.370500f, 0.325331f} },
    { {-0.247819f, -0.935326f, 0.283034f}, {-0.846936f, 0.112751f, 0.519602f}, {0.385492f, 0.229922f} },
    { {-0.218441f, -0.914433f, 0.314177f}, {-0.535315f, 0.006311f, 0.844629f}, {0.383770f, 0.225210f} },
    { {-0.220816f, -0.969240f, 0.304839f}, {-0.592385f, -0.110306f, 0.798068f}, {0.388287f, 0.226623f} },
    { {0.185872f, -1.075471f, -0.141454f}, {-0.990633f, 0.072924f, 0.115448f}, {0.397041f, 0.294152f} },
    { {0.131658f, -0.713783f, 0.349737f}, {0.402449f, 0.025996f, 0.915073f}, {0.385634f, 0.283957f} },
    { {0.135901f, -0.666576f, 0.343375f}, {0.324362f, 0.120968f, 0.938166f}, {0.386411f, 0.280125f} },
    { {0.052436f, -0.683727f, 0.371555f}, {0.166332f, 0.004516f, 0.986059f}, {0.371112f, 0.281517f} },
    { {0.175099f, -0.682619f, 0.324091f}, {0.626073f, 0.059174f, 0.777516f}, {0.355490f, 0.223710f} },
    { {-0.214979f, -0.496644f, -0.248814f}, {0.504071f, -0.132200f, -0.853484f}, {0.398061f, 0.266334f} },
    { {-0.185339f, -0.545276f, -0.223775f}, {0.504071f, -0.132200f, -0.853484f}, {0.392628f, 0.270280f} },
    { {-0.223988f, -0.534166f, -0.248322f}, {0.504071f, -0.132200f, -0.853485f}, {0.399712f, 0.269379f} },
    { {-0.223988f, -0.534166f, -0.248322f}, {-0.764794f, 0.175511f, -0.619909f}, {0.352433f, 0.310323f} },
    { {-0.288357f, -0.714357f, -0.060982f}, {-0.812973f, -0.205100f, -0.544986f}, {0.367283f, 0.281976f} },
    { {0.265516f, -0.483372f, 0.245638f}, {0.787718f, 0.069047f, 0.612154f}, {0.410170f, 0.265256f} },
    { {0.273517f, -0.294558f, 0.165364f}, {0.621088f, 0.268414f, 0.736344f}, {0.411636f, 0.249932f} },
    { {0.217042f, -0.445835f, 0.267533f}, {0.447328f, 0.301904f, 0.841874f}, {0.401284f, 0.262210f} },
    { {0.249511f, -1.215930f, 0.124539f}, {0.403241f, -0.877073f, 0.261035f}, {0.407236f, 0.324711f} },
    { {-0.213270f, -1.209222f, 0.163020f}, {-0.711596f, -0.554513f, 0.431446f}, {0.322409f, 0.324166f} },
    { {-0.147145f, -1.241755f, -0.119520f}, {-0.323648f, -0.851630f, -0.412284f}, {0.334530f, 0.290834f} },
    { {-0.147145f, -1.241755f, -0.119520f}, {-0.323648f, -0.851630f, -0.412284f}, {0.410745f, 0.290834f} },
    { {0.135768f, -1.242706f, -0.072460f}, {-0.115201f, -0.956853f, -0.266762f}, {0.386387f, 0.283713f} },
    { {0.199262f, -1.222086f, -0.119777f}, {0.381606f, -0.814833f, -0.436376f}, {0.398025f, 0.290872f} },
    { {0.026414f, -0.620213f, 0.369462f}, {0.296928f, 0.147756f, 0.943399f}, {0.366343f, 0.276362f} },
    { {0.230717f, -0.764515f, -0.163158f}, {0.750220f, 0.291807f, 0.593311f}, {0.348741f, 0.297436f} },
    { {0.219415f, -0.827723f, -0.163522f}, {0.251035f, -0.137531f, 0.958158f}, {0.401719f, 0.293204f} },
    { {0.230717f, -0.764515f, -0.163158f}, {0.750220f, 0.291807f, 0.593311f}, {0.403791f, 0.288074f} },
    { {0.201539f, -0.727526f, -0.144457f}, {0.733567f, 0.291851f, 0.613761f}, {0.398443f, 0.285072f} },
    { {0.091953f, -0.794021f, -0.259907f}, {0.165330f, 0.400430f, -0.901289f}, {0.341801f, 0.290469f} },
    { {-0.000691f, -0.787993f, -0.274224f}, {-0.026407f, 0.417048f, -0.908501f}, {0.358782f, 0.289979f} },
    { {0.003683f, -0.725038f, -0.245451f}, {-0.026407f, 0.417048f, -0.908501f}, {0.357980f, 0.284870f} },
    { {-0.000691f, -0.787993f, -0.274224f}, {-0.063858f, -0.834875f, -0.546723f}, {0.361374f, 0.314242f} },
    { {-0.098351f, -0.785614f, -0.250517f}, {0.328927f, -0.702253f, 0.631386f}, {0.343473f, 0.289786f} },
    { {0.000338f, -0.780909f, -0.292811f}, {0.025480f, -0.679769f, 0.732983f}, {0.361563f, 0.289404f} },
    { {0.003683f, -0.725038f, -0.245451f}, {0.009049f, -0.646906f, 0.762516f}, {0.362176f, 0.284870f} },
    { {-0.182678f, -0.970851f, 0.309196f}, {-0.459004f, -0.255465f, 0.850913f}, {0.328017f, 0.304820f} },
    { {-0.223243f, -1.179958f, 0.044927f}, {-0.908394f, -0.418013f, -0.009286f}, {0.405652f, 0.265951f} },
    { {-0.221439f, -0.773414f, -0.166654f}, {-0.034268f, -0.171670f, 0.984558f}, {0.320912f, 0.288796f} },
    { {-0.210159f, -0.822763f, -0.163325f}, {0.042592f, 0.076936f, 0.996126f}, {0.322979f, 0.292801f} },
    { {-0.180031f, -0.786180f, -0.167439f}, {-0.034268f, -0.171670f, 0.984558f}, {0.328502f, 0.289832f} },
    { {-0.210159f, -0.822763f, -0.163325f}, {-0.793317f, -0.137451f, -0.593090f}, {0.376216f, 0.297462f} },
    { {0.154361f, -1.101528f, -0.173107f}, {-0.600689f, -0.289462f, -0.745241f}, {0.330361f, 0.315426f} },
    { {0.129525f, -1.137688f, -0.140009f}, {-0.589409f, -0.069615f, -0.804830f}, {0.334914f, 0.318361f} },
    { {0.080789f, -1.176341f, -0.062171f}, {0.195835f, -0.974954f, -0.105419f}, {0.314803f, 0.282156f} },
    { {0.090555f, -1.152624f, -0.121960f}, {0.185008f, -0.923480f, -0.336091f}, {0.316757f, 0.291203f} },
    { {-0.226577f, -0.122977f, -0.047134f}, {-0.881054f, 0.273820f, -0.385702f}, {0.318548f, 0.279881f} },
    { {0.251930f, -1.154095f, -0.040301f}, {0.902974f, -0.330865f, -0.274164f}, {0.316636f, 0.278847f} },
    { {0.154364f, -0.337462f, -0.052851f}, {0.999534f, -0.026218f, 0.015616f}, {0.383933f, 0.280746f} },
    { {0.155434f, -0.314211f, -0.077574f}, {0.999489f, -0.022052f, 0.023160f}, {0.385849f, 0.284487f} },
    { {0.154364f, -0.337462f, -0.052851f}, {0.645390f, 0.657992f, 0.387967f}, {0.383933f, 0.280746f} },
    { {0.208718f, -0.935174f, -0.165600f}, {0.125732f, 0.342471f, -0.931077f}, {0.334677f, 0.297806f} },
    { {0.180878f, -1.013744f, -0.193611f}, {0.102270f, 0.079676f, -0.991561f}, {0.328202f, 0.302044f} },
    { {0.274803f, -0.960770f, -0.025866f}, {0.507897f, -0.821782f, -0.258294f}, {0.308285f, 0.304002f} },
    { {0.284058f, -1.017703f, 0.082546f}, {0.510237f, -0.474331f, -0.717404f}, {0.306588f, 0.308623f} },
    { {0.262007f, -1.001667f, 0.046902f}, {0.696755f, -0.582668f, -0.418366f}, {0.310630f, 0.307321f} },
    { {0.257004f, -1.092814f, 0.058656f}, {0.753578f, 0.116059f, -0.647033f}, {0.311547f, 0.314719f} },
    { {0.252157f, -1.049300f, 0.059717f}, {0.887339f, -0.199514f, -0.415722f}, {0.312436f, 0.311187f} },
    { {0.239849f, -1.039936f, -0.093853f}, {0.945280f, -0.197654f, 0.259574f}, {0.326043f, 0.286950f} },
    { {0.239849f, -1.039936f, -0.093853f}, {0.618538f, -0.251182f, -0.744526f}, {0.326043f, 0.286950f} },
    { {0.213013f, -1.094716f, -0.084843f}, {0.320460f, -0.699971f, -0.638237f}, {0.321529f, 0.285586f} },
    { {0.205958f, -0.623267f, 0.283670f}, {0.645420f, -0.118923f, 0.754513f}, {0.360381f, 0.229826f} },
    { {0.317403f, -0.884717f, -0.018267f}, {0.881313f, 0.455163f, -0.126939f}, {0.338835f, 0.275513f} },
    { {0.310754f, -0.912012f, -0.083890f}, {0.889964f, 0.213810f, -0.402802f}, {0.301695f, 0.285442f} },
    { {0.090080f, -0.365177f, 0.306672f}, {0.876445f, -0.101116f, -0.470764f}, {0.381649f, 0.226345f} },
    { {0.071776f, -0.333836f, 0.265862f}, {0.876445f, -0.101116f, -0.470764f}, {0.384232f, 0.232520f} },
    { {0.091516f, -0.331635f, 0.302140f}, {0.876445f, -0.101117f, -0.470764f}, {0.384414f, 0.227031f} },
    { {0.091516f, -0.331635f, 0.302140f}, {0.581643f, 0.084418f, 0.809052f}, {0.378276f, 0.252941f} },
    { {0.079730f, -0.607012f, 0.339347f}, {0.876445f, -0.101117f, -0.470764f}, {0.361720f, 0.221401f} },
    { {0.061425f, -0.575671f, 0.298536f}, {0.876445f, -0.101117f, -0.470764f}, {0.364303f, 0.227576f} },
    { {0.081165f, -0.573469f, 0.334815f}, {0.876445f, -0.101117f, -0.470764f}, {0.364484f, 0.222087f} },
    { {0.081165f, -0.573469f, 0.334815f}, {0.581643f, 0.084418f, 0.809052f}, {0.376378f, 0.272569f} },
    { {0.099001f, -0.263711f, 0.262282f}, {0.497127f, 0.315992f, 0.808093f}, {0.379648f, 0.247429f} },
    { {0.099001f, -0.263711f, 0.262282f}, {-0.074234f, 0.779586f, -0.621880f}, {0.340509f, 0.247429f} },
    { {-0.166192f, -1.172176f, 0.082440f}, {0.970541f, 0.224691f, 0.086966f}, {0.315146f, 0.260274f} },
    { {-0.078636f, -1.174550f, 0.005505f}, {-0.273689f, -0.955746f, 0.107903f}, {0.347087f, 0.271916f} },
    { {0.180878f, -1.013744f, -0.193611f}, {0.102270f, 0.079676f, -0.991561f}, {0.325501f, 0.308301f} },
    { {0.159207f, -1.074088f, -0.188636f}, {-0.171219f, -0.019715f, -0.985036f}, {0.329473f, 0.313199f} },
    { {0.220589f, -0.940231f, -0.110072f}, {-0.981768f, -0.054742f, -0.182031f}, {0.385896f, 0.289404f} },
    { {0.213969f, -0.899592f, -0.052535f}, {-0.063750f, 0.928193f, -0.366596f}, {0.319435f, 0.299037f} },
    { {-0.163008f, -0.556958f, -0.281101f}, {-0.991851f, 0.110105f, -0.064104f}, {0.354311f, 0.315283f} },
    { {-0.163008f, -0.556958f, -0.281101f}, {-0.646482f, 0.709896f, 0.279479f}, {0.354311f, 0.315283f} },
    { {-0.129241f, -0.508163f, -0.326932f}, {-0.633800f, 0.722069f, 0.277334f}, {0.350290f, 0.322218f} },
    { {-0.151712f, -0.509769f, -0.374833f}, {-0.638707f, 0.718421f, 0.275546f}, {0.350423f, 0.329466f} },
    { {-0.227084f, -0.916552f, 0.293208f}, {0.387192f, -0.093994f, -0.917195f}, {0.400279f, 0.300413f} },
    { {-0.193131f, -1.003442f, 0.314212f}, {0.200254f, -0.151566f, -0.967949f}, {0.394056f, 0.307465f} },
    { {-0.038812f, -0.277028f, 0.317547f}, {-0.612332f, 0.467985f, 0.637212f}, {0.331243f, 0.224700f} },
    { {-0.003333f, -0.255153f, 0.313058f}, {-0.224548f, 0.543474f, 0.808835f}, {0.329440f, 0.225379f} },
    { {-0.069826f, -0.277135f, 0.277381f}, {-0.721365f, 0.475029f, 0.503964f}, {0.331252f, 0.230778f} },
    { {-0.095602f, -0.381657f, 0.317300f}, {-0.699954f, 0.364334f, 0.614267f}, {0.339865f, 0.224737f} },
    { {-0.094630f, -0.455463f, -0.360780f}, {0.216535f, -0.908622f, -0.357098f}, {0.344156f, 0.327339f} },
    { {0.028383f, -0.443978f, -0.364737f}, {0.050425f, -0.951213f, -0.304386f}, {0.366704f, 0.327938f} },
    { {0.028472f, -0.455208f, -0.329653f}, {0.065489f, -0.950223f, -0.304609f}, {0.366720f, 0.322629f} },
    { {0.144131f, -0.446951f, -0.342507f}, {0.313694f, 0.647898f, -0.694135f}, {0.332237f, 0.262300f} },
    { {-0.193947f, -1.042042f, -0.178074f}, {-0.119525f, 0.978083f, -0.170490f}, {0.394206f, 0.299693f} },
    { {0.201539f, -0.727526f, -0.144457f}, {-0.629912f, -0.441417f, -0.639032f}, {0.368368f, 0.294607f} },
    { {0.188577f, -0.549484f, -0.254471f}, {-0.596009f, -0.559774f, -0.575696f}, {0.353696f, 0.311253f} },
    { {0.214474f, -0.553342f, -0.277525f}, {-0.618311f, -0.485884f, -0.617745f}, {0.354014f, 0.314742f} },
    { {0.144131f, -0.446951f, -0.342507f}, {-0.312634f, -0.841394f, -0.440812f}, {0.345246f, 0.324574f} },
    { {0.189429f, -0.495783f, -0.334258f}, {-0.548215f, -0.679228f, -0.487965f}, {0.349270f, 0.323326f} },
    { {0.166997f, -0.499857f, -0.303378f}, {-0.568341f, -0.655289f, -0.497579f}, {0.349606f, 0.318654f} },
    { {-0.211037f, -0.902522f, -0.139781f}, {-0.670509f, 0.208244f, -0.712076f}, {0.397338f, 0.299275f} },
    { {-0.214899f, -0.871100f, -0.137062f}, {-0.279030f, -0.098833f, -0.955183f}, {0.398046f, 0.296724f} },
    { {-0.308266f, -0.983843f, 0.045815f}, {-0.148025f, 0.943885f, 0.295246f}, {0.415160f, 0.265816f} },
    { {-0.301982f, -0.987138f, 0.059498f}, {-0.148025f, 0.943885f, 0.295246f}, {0.414008f, 0.263746f} },
    { {-0.300688f, -0.969020f, 0.002224f}, {-0.148025f, 0.943885f, 0.295246f}, {0.413771f, 0.272412f} },
    { {-0.300051f, -1.008307f, 0.081243f}, {-0.876060f, 0.232793f, 0.422286f}, {0.391506f, 0.260456f} },
    { {-0.245802f, -0.538991f, -0.136199f}, {-0.551510f, 0.143175f, 0.821789f}, {0.316446f, 0.269770f} },
    { {-0.226378f, -1.138849f, 0.214609f}, {-0.376562f, -0.819318f, 0.432342f}, {0.402264f, 0.240276f} },
    { {-0.213728f, -0.886884f, -0.122662f}, {-0.000133f, 0.899071f, -0.437803f}, {0.397831f, 0.291309f} },
    { {-0.296877f, -0.867383f, -0.077237f}, {-0.458607f, 0.826589f, -0.326237f}, {0.413072f, 0.284436f} },
    { {-0.216610f, -0.873321f, 0.069480f}, {0.917247f, 0.392371f, 0.068573f}, {0.339774f, 0.262236f} },
    { {-0.220585f, -0.863188f, -0.025581f}, {0.740771f, 0.670779f, -0.036238f}, {0.340609f, 0.276619f} },
    { {-0.230854f, -0.849165f, 0.024082f}, {0.073990f, 0.996111f, 0.047829f}, {0.341765f, 0.269105f} },
    { {-0.186958f, -1.151442f, -0.110709f}, {-0.400281f, -0.909624f, -0.111169f}, {0.403302f, 0.289500f} },
    { {-0.165826f, -1.152849f, -0.125997f}, {-0.372286f, -0.840316f, -0.394047f}, {0.403418f, 0.291814f} },
    { {-0.200083f, -1.027626f, -0.203298f}, {0.388966f, 0.325039f, -0.862006f}, {0.395330f, 0.309428f} },
    { {0.211740f, -0.324816f, -0.147631f}, {0.008367f, 0.995228f, 0.097215f}, {0.319844f, 0.295087f} },
    { {0.118597f, -0.316379f, -0.225992f}, {0.006020f, 0.989689f, 0.143105f}, {0.336917f, 0.306944f} },
    { {-0.049494f, -0.314152f, -0.234319f}, {0.006020f, 0.989689f, 0.143105f}, {0.367728f, 0.308204f} },
    { {-0.247604f, -0.726455f, -0.121434f}, {0.685377f, -0.543700f, -0.484406f}, {0.351877f, 0.291123f} },
    { {-0.220161f, -0.729693f, -0.078971f}, {0.685377f, -0.543700f, -0.484406f}, {0.351610f, 0.284698f} },
    { {-0.249956f, -0.747024f, -0.101675f}, {0.685377f, -0.543700f, -0.484406f}, {0.350182f, 0.288133f} },
    { {-0.249956f, -0.747024f, -0.101675f}, {-0.625826f, -0.501929f, -0.597000f}, {0.369975f, 0.288133f} },
    { {0.032002f, -0.251750f, 0.315597f}, {-0.106395f, 0.439090f, 0.892121f}, {0.367367f, 0.246458f} },
    { {-0.003333f, -0.255153f, 0.313058f}, {-0.093827f, 0.995196f, -0.027941f}, {0.359266f, 0.225379f} },
    { {0.032002f, -0.251750f, 0.315597f}, {-0.093833f, 0.995196f, -0.027948f}, {0.352790f, 0.224995f} },
    { {-0.250125f, -1.088850f, -0.170559f}, {-0.007345f, -0.998803f, -0.048351f}, {0.315654f, 0.298556f} },
    { {-0.196621f, -1.085638f, -0.173034f}, {0.056612f, -0.996023f, -0.068798f}, {0.325461f, 0.298931f} },
    { {-0.240111f, -1.072827f, -0.087240f}, {-0.937585f, -0.270564f, -0.218470f}, {0.396824f, 0.285949f} },
    { {0.221163f, -0.859057f, 0.119867f}, {-0.174980f, 0.812391f, 0.556239f}, {0.318117f, 0.254611f} },
    { {0.310921f, -0.855241f, 0.119817f}, {0.513392f, 0.722810f, 0.462574f}, {0.301664f, 0.254619f} },
    { {-0.297422f, -0.852944f, 0.024132f}, {-0.695124f, 0.715400f, 0.070744f}, {0.413172f, 0.269097f} },
    { {0.030294f, -0.416737f, 0.341282f}, {-0.276080f, -0.098026f, -0.956123f}, {0.353103f, 0.259848f} },
    { {0.009951f, -0.623090f, 0.360036f}, {-0.396441f, 0.012935f, -0.917969f}, {0.356832f, 0.276596f} },
    { {0.009951f, -0.623090f, 0.360036f}, {0.511007f, -0.153057f, -0.845840f}, {0.356832f, 0.276596f} },
    { {0.026414f, -0.620213f, 0.369462f}, {0.511007f, -0.153057f, -0.845840f}, {0.353814f, 0.276362f} },
    { {-0.023197f, -0.668812f, 0.360831f}, {0.508537f, -0.382095f, -0.771617f}, {0.362907f, 0.280307f} },
    { {-0.236605f, -0.262261f, 0.095698f}, {0.135964f, 0.440681f, 0.887307f}, {0.318132f, 0.247311f} },
    { {-0.234776f, -0.452276f, 0.169097f}, {0.094640f, 0.121236f, 0.988102f}, {0.318467f, 0.262733f} },
    { {-0.218613f, -0.264882f, 0.094243f}, {0.133597f, 0.440561f, 0.887727f}, {0.321430f, 0.247524f} },
    { {-0.078557f, -0.465218f, -0.326241f}, {-0.216360f, 0.960996f, 0.172264f}, {0.373055f, 0.322113f} },
    { {0.028472f, -0.455208f, -0.329653f}, {-0.029518f, 0.990603f, 0.133544f}, {0.353437f, 0.322629f} },
    { {0.028998f, -0.448669f, -0.377985f}, {-0.058708f, 0.989324f, 0.133384f}, {0.353340f, 0.329942f} },
    { {-0.094232f, -0.460171f, -0.374029f}, {-0.397959f, 0.890403f, 0.220933f}, {0.346335f, 0.329344f} },
    { {0.229906f, -0.759834f, -0.149909f}, {-0.627409f, -0.442768f, -0.640558f}, {0.371030f, 0.295432f} },
    { {0.192314f, -0.786076f, -0.156191f}, {0.029905f, 0.191987f, -0.980942f}, {0.323405f, 0.289824f} },
    { {0.201539f, -0.727526f, -0.144457f}, {0.029980f, 0.191885f, -0.980959f}, {0.321714f, 0.285072f} },
    { {0.229906f, -0.759834f, -0.149909f}, {0.029905f, 0.191987f, -0.980942f}, {0.316514f, 0.287694f} },
    { {-0.006589f, -1.178168f, -0.094256f}, {0.076174f, -0.196096f, -0.977621f}, {0.359863f, 0.321646f} },
    { {-0.017364f, -0.557830f, 0.345783f}, {-0.847112f, 0.106596f, 0.520614f}, {0.354383f, 0.220427f} },
    { {-0.290801f, -0.689346f, -0.028432f}, {-0.738998f, 0.482395f, 0.470295f}, {0.365221f, 0.277051f} },
    { {-0.007014f, -0.315996f, 0.313109f}, {-0.847112f, 0.106596f, 0.520614f}, {0.334454f, 0.225371f} },
    { {-0.084038f, -0.393919f, 0.308830f}, {0.326266f, -0.282616f, -0.902041f}, {0.374059f, 0.257996f} },
    { {-0.029473f, -0.376766f, 0.323191f}, {-0.518557f, 0.299232f, 0.800974f}, {0.356099f, 0.256604f} },
    { {-0.256128f, -1.094155f, -0.089437f}, {-0.918575f, -0.266156f, -0.292200f}, {0.398581f, 0.286282f} },
    { {0.237291f, -0.993521f, -0.098860f}, {0.579933f, 0.194636f, -0.791072f}, {0.315161f, 0.306660f} },
    { {-0.275173f, -0.569612f, -0.168535f}, {-0.652776f, -0.207315f, -0.728632f}, {0.355354f, 0.298250f} },
    { {-0.248607f, -0.485188f, -0.187763f}, {0.952856f, -0.243199f, 0.181436f}, {0.371760f, 0.301159f} },
    { {0.191570f, -1.004799f, -0.142123f}, {-0.909713f, 0.377495f, 0.172972f}, {0.391217f, 0.294254f} },
    { {0.232195f, -0.969125f, -0.129921f}, {-0.915813f, 0.401043f, 0.021253f}, {0.388278f, 0.292407f} },
    { {-0.127657f, -1.391714f, 0.081068f}, {-0.748267f, -0.653203f, 0.115857f}, {0.338102f, 0.260482f} },
    { {-0.127657f, -1.391714f, 0.081068f}, {-0.001313f, 0.023662f, 0.999719f}, {0.338102f, 0.338977f} },
    { {0.335353f, -0.737899f, 0.014813f}, {0.937703f, -0.205465f, -0.280173f}, {0.350934f, 0.270507f} },
    { {-0.225506f, -1.126627f, -0.029572f}, {-0.803037f, -0.582941f, -0.123741f}, {0.401257f, 0.277223f} },
    { {0.015018f, -0.597857f, 0.371079f}, {0.438237f, 0.285057f, -0.852462f}, {0.355903f, 0.274548f} },
    { {0.208303f, -0.938115f, 0.110286f}, {-0.975902f, 0.054001f, 0.211424f}, {0.385722f, 0.256061f} },
    { {-0.184623f, -1.057023f, 0.200826f}, {0.289762f, -0.312930f, -0.904496f}, {0.392497f, 0.311814f} },
    { {-0.151114f, -1.007334f, 0.194370f}, {0.289762f, -0.312930f, -0.904496f}, {0.386354f, 0.307781f} },
    { {-0.138141f, -1.054214f, 0.214745f}, {0.289762f, -0.312930f, -0.904496f}, {0.383976f, 0.311586f} },
    { {-0.227084f, -0.916552f, 0.293208f}, {-0.786533f, -0.074351f, 0.613056f}, {0.383945f, 0.228383f} },
    { {-0.182678f, -0.970851f, 0.309196f}, {-0.459004f, -0.255465f, 0.850913f}, {0.388420f, 0.225964f} },
    { {0.161310f, -1.375312f, 0.080501f}, {0.800354f, -0.596990f, 0.055103f}, {0.391069f, 0.260568f} },
    { {0.161310f, -1.375312f, 0.080501f}, {0.000088f, 0.022011f, 0.999758f}, {0.391069f, 0.337646f} },
    { {0.174993f, -0.808260f, -0.204613f}, {0.381577f, -0.604826f, -0.698988f}, {0.326580f, 0.291624f} },
    { {0.219415f, -0.827723f, -0.163522f}, {0.715749f, -0.190396f, -0.671903f}, {0.318437f, 0.293204f} },
    { {0.220731f, -0.848489f, -0.144835f}, {0.464992f, -0.386137f, -0.796669f}, {0.318196f, 0.294889f} },
    { {0.175827f, -0.812939f, -0.217862f}, {0.639071f, -0.225171f, -0.735450f}, {0.344750f, 0.305714f} },
    { {0.230717f, -0.764515f, -0.163158f}, {0.748793f, -0.263426f, -0.608207f}, {0.348741f, 0.297436f} },
    { {-0.210159f, -0.822763f, -0.163325f}, {-0.225718f, 0.220879f, -0.948822f}, {0.397177f, 0.292801f} },
    { {-0.221923f, -0.768709f, -0.153406f}, {-0.003832f, 0.179681f, -0.983718f}, {0.399333f, 0.288414f} },
    { {-0.191470f, -0.735541f, -0.147466f}, {-0.225718f, 0.220879f, -0.948822f}, {0.393751f, 0.285722f} },
    { {0.153667f, -0.350668f, 0.036247f}, {0.999103f, -0.042165f, -0.003805f}, {0.382845f, 0.267264f} },
    { {-0.258865f, -1.035836f, 0.039850f}, {0.000001f, 0.013090f, 0.999914f}, {0.314052f, 0.310094f} },
    { {-0.319712f, -1.090746f, 0.028526f}, {0.059890f, -0.998150f, 0.010446f}, {0.302899f, 0.268432f} },
    { {-0.319712f, -1.090746f, 0.028526f}, {-0.977991f, 0.127992f, -0.164775f}, {0.398300f, 0.268432f} },
    { {0.273517f, -0.294558f, 0.165364f}, {0.415497f, 0.111269f, -0.902763f}, {0.308520f, 0.249932f} },
    { {0.321126f, -0.933713f, 0.001762f}, {0.900420f, 0.424804f, -0.093724f}, {0.334797f, 0.272482f} },
    { {0.313678f, -0.953723f, -0.055186f}, {0.855959f, 0.364679f, -0.366529f}, {0.333148f, 0.281099f} },
    { {-0.232962f, -1.114357f, -0.055679f}, {-0.959834f, -0.273385f, -0.063081f}, {0.400246f, 0.281174f} },
    { {0.091953f, -0.794021f, -0.259907f}, {-0.345795f, -0.594593f, 0.725868f}, {0.378356f, 0.290469f} },
    { {-0.220585f, -0.863188f, -0.025581f}, {0.898170f, 0.437506f, -0.043346f}, {0.340609f, 0.276619f} },
    { {-0.194348f, -0.929407f, -0.150290f}, {0.878318f, 0.456894f, -0.140733f}, {0.335152f, 0.295489f} },
    { {-0.213728f, -0.886884f, -0.122662f}, {0.882737f, 0.461079f, -0.090454f}, {0.338656f, 0.291309f} },
    { {-0.220585f, -0.863188f, -0.025581f}, {0.740771f, 0.670779f, -0.036238f}, {0.399088f, 0.276619f} },
    { {0.144824f, -0.451641f, -0.355755f}, {0.165182f, 0.967506f, 0.191434f}, {0.332110f, 0.326579f} },
    { {0.144824f, -0.451641f, -0.355755f}, {0.165182f, 0.967506f, 0.191434f}, {0.374524f, 0.326579f} },
    { {0.242983f, -0.171202f, 0.154071f}, {0.380935f, -0.024143f, -0.924286f}, {0.314117f, 0.239921f} },
    { {0.219447f, -0.208958f, 0.179984f}, {-0.785339f, 0.617912f, 0.037766f}, {0.325633f, 0.245515f} },
    { {0.242983f, -0.171202f, 0.154071f}, {-0.821591f, 0.564879f, 0.076807f}, {0.322522f, 0.249436f} },
    { {0.202708f, -0.227724f, 0.138948f}, {-0.785339f, 0.617912f, 0.037766f}, {0.327180f, 0.251724f} },
    { {0.225727f, -0.901127f, -0.137092f}, {0.872143f, -0.224889f, -0.434501f}, {0.337483f, 0.293492f} },
    { {0.033814f, -0.252462f, 0.284164f}, {0.964471f, -0.256951f, 0.061414f}, {0.390938f, 0.229751f} },
    { {0.032002f, -0.251750f, 0.315597f}, {0.964471f, -0.256951f, 0.061414f}, {0.390997f, 0.224995f} },
    { {-0.001191f, -0.374046f, 0.325206f}, {0.964471f, -0.256951f, 0.061414f}, {0.380919f, 0.223541f} },
    { {0.033814f, -0.252462f, 0.284164f}, {0.565352f, 0.146800f, 0.811682f}, {0.367699f, 0.246516f} },
    { {-0.116378f, -0.479162f, 0.348913f}, {-0.428316f, 0.263937f, 0.864224f}, {0.347900f, 0.219954f} },
    { {-0.036777f, -0.308322f, 0.332043f}, {-0.335355f, 0.282366f, 0.898781f}, {0.333822f, 0.222506f} },
    { {0.109050f, -0.715693f, 0.345900f}, {0.552884f, -0.437374f, 0.709242f}, {0.381490f, 0.284112f} },
    { {-0.271510f, -0.933681f, 0.030897f}, {-0.920552f, 0.329806f, -0.209314f}, {0.385357f, 0.268074f} },
    { {-0.247334f, -0.958297f, -0.090426f}, {-0.834569f, 0.358956f, -0.417905f}, {0.387385f, 0.286431f} },
    { {-0.160024f, -0.567365f, 0.333915f}, {0.145967f, -0.156022f, -0.976909f}, {0.387988f, 0.272073f} },
    { {-0.160024f, -0.567365f, 0.333915f}, {-0.930116f, 0.344771f, 0.126562f}, {0.355169f, 0.222223f} },
    { {-0.163008f, -0.556958f, -0.281101f}, {0.632830f, -0.578977f, -0.514113f}, {0.365845f, 0.315283f} },
    { {0.186586f, -0.843918f, 0.321441f}, {0.598386f, 0.033608f, 0.800503f}, {0.395702f, 0.294518f} },
    { {0.175099f, -0.682619f, 0.324091f}, {0.626073f, 0.059174f, 0.777516f}, {0.393596f, 0.281427f} },
    { {-0.256314f, -0.466915f, 0.240568f}, {-0.833688f, 0.257440f, 0.488558f}, {0.314519f, 0.263921f} },
    { {-0.249435f, -0.520515f, 0.262561f}, {-0.757160f, 0.119392f, 0.642226f}, {0.315780f, 0.268271f} },
    { {-0.218877f, -0.443576f, 0.258289f}, {-0.564483f, 0.331544f, 0.755935f}, {0.321382f, 0.262027f} },
    { {-0.230624f, -0.224731f, 0.146881f}, {-0.730648f, 0.312364f, 0.607109f}, {0.319228f, 0.244265f} },
    { {-0.344792f, -0.703594f, -0.039882f}, {-0.778237f, -0.374524f, -0.504063f}, {0.366396f, 0.278783f} },
    { {-0.341508f, -0.604726f, -0.095462f}, {-0.837154f, -0.144950f, -0.527411f}, {0.358248f, 0.287193f} },
    { {-0.217862f, -0.883984f, 0.120194f}, {0.164831f, 0.757964f, 0.631127f}, {0.338895f, 0.254562f} },
    { {-0.206198f, -0.965606f, 0.176745f}, {0.351586f, 0.549832f, 0.757675f}, {0.332169f, 0.246005f} },
    { {0.233209f, -0.849617f, -0.072541f}, {-0.884632f, 0.461110f, -0.069306f}, {0.378429f, 0.283725f} },
    { {0.217926f, -0.897240f, -0.161146f}, {-0.295647f, 0.662643f, -0.688111f}, {0.382354f, 0.297132f} },
    { {0.197287f, -0.947260f, -0.177425f}, {-0.916558f, 0.356349f, -0.181484f}, {0.386476f, 0.299595f} },
    { {0.237843f, -0.836530f, 0.022234f}, {-0.843303f, 0.536780f, -0.026597f}, {0.377351f, 0.269384f} },
    { {0.242323f, -0.836171f, -0.077657f}, {-0.181409f, 0.913435f, -0.364318f}, {0.377321f, 0.284499f} },
    { {-0.175829f, -0.505667f, -0.224294f}, {0.504071f, -0.132200f, -0.853484f}, {0.390884f, 0.267066f} },
    { {-0.185992f, -1.172784f, -0.046613f}, {0.832632f, -0.551879f, 0.046404f}, {0.315096f, 0.279802f} },
    { {-0.184940f, -1.160797f, 0.077065f}, {0.832632f, -0.551879f, 0.046404f}, {0.316084f, 0.261088f} },
    { {-0.190886f, -1.174778f, 0.017485f}, {0.832632f, -0.551879f, 0.046404f}, {0.314931f, 0.270103f} },
    { {-0.204574f, -1.158585f, 0.082731f}, {-0.564320f, -0.819604f, 0.098954f}, {0.324003f, 0.260230f} },
    { {-0.184940f, -1.160797f, 0.077065f}, {-0.005446f, -0.999752f, 0.021600f}, {0.327602f, 0.261088f} },
    { {-0.213278f, -1.160303f, 0.133314f}, {-0.618454f, -0.785621f, -0.017740f}, {0.322408f, 0.252577f} },
    { {-0.264254f, -0.950713f, 0.092009f}, {0.314720f, 0.923343f, 0.219976f}, {0.407093f, 0.258827f} },
    { {-0.247225f, -0.926014f, -0.036030f}, {0.314720f, 0.923343f, 0.219976f}, {0.403971f, 0.278200f} },
    { {-0.271510f, -0.933681f, 0.030897f}, {0.314720f, 0.923343f, 0.219976f}, {0.408423f, 0.268074f} },
    { {-0.005761f, -1.165726f, -0.087672f}, {0.208735f, -0.745688f, -0.632755f}, {0.359711f, 0.320636f} },
    { {-0.098351f, -0.785614f, -0.250517f}, {-0.204592f, 0.418606f, -0.884823f}, {0.376683f, 0.289786f} },
    { {-0.098351f, -0.785614f, -0.250517f}, {-0.239044f, -0.407051f, -0.881571f}, {0.376683f, 0.289786f} },
    { {-0.000691f, -0.787993f, -0.274224f}, {-0.063858f, -0.834875f, -0.546723f}, {0.358782f, 0.289979f} },
    { {-0.094630f, -0.455463f, -0.360780f}, {0.216535f, -0.908622f, -0.357098f}, {0.374209f, 0.327339f} },
    { {-0.078557f, -0.465218f, -0.326241f}, {0.389772f, -0.825223f, -0.408761f}, {0.373405f, 0.322113f} },
    { {-0.078557f, -0.465218f, -0.326241f}, {0.389772f, -0.825223f, -0.408761f}, {0.347102f, 0.322113f} },
    { {-0.230624f, -0.224731f, 0.146881f}, {-0.730648f, 0.312364f, 0.607109f}, {0.326933f, 0.250524f} },
    { {0.319397f, -0.878381f, 0.056794f}, {0.328242f, -0.851404f, -0.409106f}, {0.420046f, 0.264155f} },
    { {0.303873f, -0.883971f, 0.055426f}, {0.349265f, -0.900687f, -0.258413f}, {0.417200f, 0.264362f} },
    { {0.315819f, -0.870047f, -0.021158f}, {0.356224f, -0.933789f, 0.033795f}, {0.419390f, 0.275950f} },
    { {0.311317f, -0.899347f, -0.094209f}, {0.439410f, -0.784165f, 0.438183f}, {0.337629f, 0.287004f} },
    { {0.300763f, -0.875807f, -0.020594f}, {0.501991f, -0.834764f, 0.226217f}, {0.339569f, 0.275865f} },
    { {0.288327f, -0.930388f, -0.120492f}, {0.471286f, -0.689521f, 0.549955f}, {0.335071f, 0.290981f} },
    { {-0.204574f, -1.158585f, 0.082731f}, {-0.564320f, -0.819604f, 0.098954f}, {0.324003f, 0.320057f} },
    { {-0.238141f, -1.107306f, 0.135602f}, {-0.909591f, -0.415127f, 0.017705f}, {0.317850f, 0.315895f} },
    { {-0.238893f, -1.130744f, 0.112088f}, {-0.728252f, -0.682928f, 0.057087f}, {0.317713f, 0.317797f} },
    { {-0.216885f, -0.719787f, 0.260260f}, {-0.957411f, 0.199586f, 0.208637f}, {0.367730f, 0.233368f} },
    { {-0.305152f, -0.913842f, 0.057258f}, {-0.230373f, -0.883120f, -0.408690f}, {0.414589f, 0.300193f} },
    { {-0.289097f, -0.917639f, 0.055867f}, {-0.245458f, -0.934452f, -0.257970f}, {0.411646f, 0.300501f} },
    { {-0.286240f, -0.959791f, 0.119350f}, {-0.220374f, -0.727502f, -0.649751f}, {0.411123f, 0.303923f} },
    { {-0.304195f, -0.957341f, 0.122359f}, {0.017552f, -0.550985f, -0.834331f}, {0.414414f, 0.303724f} },
    { {-0.273453f, -1.024674f, 0.155736f}, {0.113148f, -0.399322f, -0.909802f}, {0.408779f, 0.309188f} },
    { {0.319397f, -0.878381f, 0.056794f}, {0.328242f, -0.851404f, -0.409106f}, {0.300111f, 0.297315f} },
    { {0.305901f, -0.926170f, 0.118910f}, {0.300338f, -0.697937f, -0.650140f}, {0.302585f, 0.301194f} },
    { {0.303873f, -0.883971f, 0.055426f}, {0.349265f, -0.900687f, -0.258413f}, {0.302956f, 0.297769f} },
    { {0.323467f, -0.921703f, 0.121892f}, {0.043694f, -0.549501f, -0.834350f}, {0.299365f, 0.300831f} },
    { {0.300594f, -0.992080f, 0.155309f}, {-0.068565f, -0.409640f, -0.909667f}, {0.303557f, 0.306543f} },
    { {-0.271600f, -0.991121f, -0.145424f}, {-0.135543f, -0.513499f, 0.847317f}, {0.311717f, 0.306465f} },
    { {-0.237168f, -1.026719f, -0.155175f}, {-0.306906f, -0.372735f, 0.875715f}, {0.318029f, 0.309354f} },
    { {-0.268657f, -0.962013f, -0.120078f}, {-0.389388f, -0.738390f, 0.550597f}, {0.312257f, 0.304103f} },
    { {-0.294974f, -0.933772f, -0.093759f}, {-0.347170f, -0.828828f, 0.438769f}, {0.385364f, 0.286936f} },
    { {-0.268657f, -0.962013f, -0.120078f}, {-0.389388f, -0.738390f, 0.550597f}, {0.387691f, 0.290918f} },
    { {-0.287043f, -0.909182f, -0.020157f}, {-0.403938f, -0.886202f, 0.226891f}, {0.383338f, 0.275799f} },
    { {0.160894f, -0.584857f, 0.314900f}, {0.226132f, 0.078542f, 0.970925f}, {0.363546f, 0.225100f} },
    { {0.176161f, -0.683017f, 0.306509f}, {0.409623f, -0.091548f, 0.907650f}, {0.355457f, 0.226370f} },
    { {0.266565f, -1.194868f, 0.060937f}, {-0.317278f, 0.732603f, -0.602185f}, {0.309795f, 0.323001f} },
    { {0.256057f, -1.172808f, 0.093310f}, {-0.131388f, 0.698089f, -0.703853f}, {0.311721f, 0.321211f} },
    { {0.296754f, -1.111209f, 0.146808f}, {-0.038983f, 0.565057f, -0.824130f}, {0.304261f, 0.316212f} },
    { {0.266565f, -1.194868f, 0.060937f}, {0.690036f, 0.680696f, -0.245974f}, {0.313276f, 0.263528f} },
    { {0.225089f, -1.194477f, -0.054335f}, {0.690036f, 0.680696f, -0.245974f}, {0.313308f, 0.280970f} },
    { {0.256057f, -1.172808f, 0.093310f}, {0.685861f, 0.685446f, -0.244455f}, {0.315094f, 0.258630f} },
    { {-0.216828f, -1.222314f, 0.061296f}, {0.231425f, 0.763758f, -0.602591f}, {0.398400f, 0.325229f} },
    { {-0.256166f, -1.142603f, 0.147219f}, {-0.026446f, 0.565770f, -0.824139f}, {0.405610f, 0.318760f} },
    { {-0.208837f, -1.199205f, 0.093656f}, {0.050485f, 0.708416f, -0.703988f}, {0.396935f, 0.323353f} },
    { {-0.216828f, -1.222314f, 0.061296f}, {-0.763015f, 0.598194f, -0.244893f}, {0.409143f, 0.263474f} },
    { {-0.208837f, -1.199205f, 0.093656f}, {-0.759401f, 0.603388f, -0.243380f}, {0.407238f, 0.258577f} },
    { {-0.175834f, -1.217241f, -0.054037f}, {-0.763015f, 0.598194f, -0.244893f}, {0.408724f, 0.280925f} },
    { {-0.139317f, -1.107505f, -0.192407f}, {0.269403f, -0.286461f, -0.919436f}, {0.384192f, 0.315911f} },
    { {-0.188579f, -0.969169f, -0.177138f}, {0.919760f, 0.356860f, -0.163378f}, {0.331875f, 0.299552f} },
    { {-0.139317f, -1.107505f, -0.192407f}, {0.932069f, 0.344339f, -0.112600f}, {0.320475f, 0.301862f} },
    { {-0.158947f, -1.060990f, -0.212651f}, {0.933053f, 0.343025f, -0.108381f}, {0.324308f, 0.304925f} },
    { {-0.143113f, -1.188016f, 0.152296f}, {0.005440f, 0.525469f, -0.850795f}, {0.384888f, 0.322445f} },
    { {-0.093087f, -1.145144f, 0.179095f}, {0.005440f, 0.525469f, -0.850795f}, {0.375718f, 0.318966f} },
    { {-0.145320f, -1.232582f, 0.124757f}, {0.005440f, 0.525469f, -0.850795f}, {0.385292f, 0.326062f} },
    { {-0.209938f, -0.960969f, -0.182611f}, {-0.097313f, 0.156263f, -0.982910f}, {0.397137f, 0.304018f} },
    { {0.314698f, -1.028872f, 0.164496f}, {-0.285495f, -0.333775f, -0.898380f}, {0.300972f, 0.309529f} },
    { {0.314698f, -1.028872f, 0.164496f}, {0.396435f, 0.052623f, -0.916554f}, {0.300972f, 0.309529f} },
    { {0.276238f, -1.110108f, 0.143196f}, {0.349506f, 0.196370f, -0.916125f}, {0.308022f, 0.316122f} },
    { {0.300594f, -0.992080f, 0.155309f}, {0.512798f, -0.017734f, -0.858326f}, {0.303557f, 0.306543f} },
    { {-0.200854f, -0.914135f, -0.017881f}, {0.982152f, 0.186317f, 0.025762f}, {0.336411f, 0.275454f} },
    { {-0.201861f, -0.913731f, 0.017583f}, {0.982152f, 0.186317f, 0.025762f}, {0.336444f, 0.270088f} },
    { {-0.173893f, -1.058972f, 0.001751f}, {0.982152f, 0.186317f, 0.025762f}, {0.324475f, 0.272484f} },
    { {-0.302564f, -0.919919f, -0.017806f}, {-0.814826f, 0.537926f, -0.216087f}, {0.414115f, 0.275443f} },
    { {-0.201861f, -0.913731f, 0.017583f}, {-0.078815f, 0.990822f, 0.109818f}, {0.395656f, 0.270088f} },
    { {-0.139557f, -0.513730f, 0.300960f}, {-0.541121f, 0.234597f, 0.807560f}, {0.335921f, 0.267720f} },
    { {-0.140259f, -0.513403f, 0.314811f}, {-0.634240f, 0.336972f, 0.695837f}, {0.350722f, 0.225114f} },
    { {-0.139557f, -0.513730f, 0.300960f}, {-0.541121f, 0.234597f, 0.807560f}, {0.350749f, 0.227210f} },
    { {0.284082f, -0.422479f, -0.110826f}, {0.926223f, 0.376660f, -0.015446f}, {0.413573f, 0.260314f} },
    { {0.070260f, -0.369245f, 0.270646f}, {0.876446f, -0.101116f, -0.470764f}, {0.381314f, 0.231797f} },
    { {0.059910f, -0.611080f, 0.303320f}, {0.876446f, -0.101116f, -0.470764f}, {0.361385f, 0.226853f} },
    { {-0.180187f, -0.992979f, 0.124349f}, {0.998759f, 0.039927f, 0.029777f}, {0.329913f, 0.253933f} },
    { {-0.318122f, -0.684050f, -0.035864f}, {-0.323595f, -0.624181f, -0.711115f}, {0.416966f, 0.281543f} },
    { {-0.284236f, -0.560511f, -0.107535f}, {-0.113595f, -0.328782f, -0.937549f}, {0.410755f, 0.271517f} },
    { {-0.297113f, -0.686801f, -0.037317f}, {-0.130855f, -0.517941f, -0.845349f}, {0.413116f, 0.281767f} },
    { {-0.317800f, -0.722819f, 0.043890f}, {-0.484642f, -0.862494f, 0.145694f}, {0.367980f, 0.266108f} },
    { {-0.318122f, -0.684050f, -0.035864f}, {-0.323595f, -0.624181f, -0.711115f}, {0.364785f, 0.278175f} },
    { {-0.302610f, -0.717268f, -0.000221f}, {-0.429636f, -0.813477f, -0.392005f}, {0.367522f, 0.272782f} },
    { {-0.193947f, -1.042042f, -0.178074f}, {-0.096467f, -0.108464f, -0.989409f}, {0.394206f, 0.310598f} },
    { {0.144131f, -0.446951f, -0.342507f}, {-0.312634f, -0.841394f, -0.440812f}, {0.387920f, 0.324574f} },
    { {0.128194f, -0.457749f, -0.310489f}, {-0.103891f, -0.925520f, -0.364169f}, {0.384999f, 0.319730f} },
    { {0.128194f, -0.457749f, -0.310489f}, {-0.103891f, -0.925520f, -0.364169f}, {0.346136f, 0.319730f} },
    { {-0.144325f, -0.581624f, 0.338538f}, {-0.468807f, 0.314963f, 0.825238f}, {0.356344f, 0.221524f} },
    { {-0.215457f, -0.794104f, 0.288576f}, {0.785472f, -0.147511f, -0.601061f}, {0.398148f, 0.290475f} },
    { {-0.247819f, -0.935326f, 0.283034f}, {0.685139f, -0.118337f, -0.718735f}, {0.404080f, 0.301937f} },
    { {-0.227209f, -0.488231f, -0.190018f}, {-0.865162f, 0.290214f, -0.408988f}, {0.400302f, 0.265651f} },
    { {0.159207f, -1.074088f, -0.188636f}, {-0.251116f, -0.511247f, -0.821929f}, {0.329473f, 0.313199f} },
    { {0.161460f, -1.101416f, -0.172327f}, {-0.251116f, -0.511247f, -0.821929f}, {0.329060f, 0.315417f} },
    { {0.129525f, -1.137688f, -0.140009f}, {-0.251116f, -0.511247f, -0.821929f}, {0.334914f, 0.318361f} },
    { {0.159207f, -1.074088f, -0.188636f}, {-0.171219f, -0.019715f, -0.985036f}, {0.323229f, 0.301292f} },
    { {-0.312584f, -0.711296f, -0.058727f}, {-0.522910f, -0.503191f, -0.688014f}, {0.367030f, 0.281635f} },
    { {-0.204140f, -0.921205f, -0.160832f}, {0.820485f, 0.468455f, -0.327651f}, {0.335828f, 0.297085f} },
    { {0.247098f, -0.848435f, -0.129000f}, {0.879752f, -0.147039f, -0.452124f}, {0.313363f, 0.294885f} },
    { {0.225727f, -0.901127f, -0.137092f}, {0.872143f, -0.224889f, -0.434501f}, {0.317280f, 0.299161f} },
    { {0.174369f, -0.748103f, -0.240960f}, {0.641142f, -0.388274f, -0.661952f}, {0.350093f, 0.309209f} },
    { {0.215152f, -0.558031f, -0.290774f}, {0.776473f, -0.293694f, -0.557524f}, {0.365757f, 0.316746f} },
    { {-0.264071f, -1.078958f, 0.054216f}, {-0.896140f, -0.441678f, -0.043064f}, {0.397329f, 0.264545f} },
    { {-0.219473f, -0.166351f, 0.024848f}, {0.150335f, 0.711498f, 0.686418f}, {0.321272f, 0.239527f} },
    { {-0.237818f, -0.163827f, 0.026305f}, {0.149598f, 0.631967f, 0.760419f}, {0.317910f, 0.239322f} },
    { {-0.222282f, -0.126612f, -0.031892f}, {0.152671f, 0.813024f, 0.561857f}, {0.320757f, 0.236302f} },
    { {-0.255926f, -0.932265f, 0.049536f}, {0.786893f, 0.584301f, -0.198475f}, {0.334917f, 0.265253f} },
    { {-0.255926f, -0.932265f, 0.049536f}, {0.190319f, -0.849286f, -0.492435f}, {0.405566f, 0.301688f} },
    { {0.150259f, -1.377143f, -0.011350f}, {0.408331f, -0.501507f, -0.762730f}, {0.298255f, 0.274466f} },
    { {-0.150560f, -0.597166f, 0.355619f}, {-0.391063f, 0.001719f, 0.920362f}, {0.357625f, 0.218939f} },
    { {-0.193753f, -1.019618f, -0.193537f}, {0.374649f, 0.047702f, -0.925939f}, {0.394170f, 0.308778f} },
    { {-0.193131f, -1.003442f, 0.314212f}, {-0.203019f, -0.979064f, 0.014708f}, {0.326100f, 0.225205f} },
    { {-0.006994f, -1.041614f, 0.342547f}, {-0.203019f, -0.979064f, 0.014708f}, {0.360219f, 0.220917f} },
    { {-0.145457f, -1.013057f, 0.332248f}, {-0.203019f, -0.979064f, 0.014708f}, {0.334839f, 0.222476f} },
    { {0.153937f, -0.288676f, 0.224427f}, {0.387064f, 0.356433f, 0.850375f}, {0.389717f, 0.249455f} },
    { {0.153937f, -0.288676f, 0.224427f}, {-0.767055f, 0.641281f, 0.019621f}, {0.332203f, 0.238790f} },
    { {-0.260804f, -1.045246f, -0.171204f}, {-0.055377f, 0.995676f, -0.074580f}, {0.406460f, 0.298654f} },
    { {-0.125430f, -0.450842f, 0.320475f}, {-0.830896f, 0.346776f, 0.435153f}, {0.345567f, 0.224257f} },
    { {0.271480f, -0.949773f, 0.070492f}, {0.385614f, 0.698060f, 0.603336f}, {0.411263f, 0.303109f} },
    { {0.260799f, -1.027230f, 0.113769f}, {0.432123f, 0.144839f, 0.890107f}, {0.409305f, 0.309396f} },
    { {0.278045f, -1.009056f, 0.102439f}, {0.813624f, -0.156726f, 0.559869f}, {0.412466f, 0.307921f} },
    { {-0.191470f, -0.735541f, -0.147466f}, {-0.101217f, -0.384720f, 0.917467f}, {0.326405f, 0.285722f} },
    { {-0.180031f, -0.786180f, -0.167439f}, {-0.421241f, 0.248833f, -0.872146f}, {0.391655f, 0.289832f} },
    { {-0.187146f, -0.072930f, -0.052016f}, {-0.879940f, 0.268215f, -0.392132f}, {0.392959f, 0.231945f} },
    { {-0.305152f, -0.913842f, 0.057258f}, {-0.230373f, -0.883120f, -0.408690f}, {0.305568f, 0.264085f} },
    { {-0.302655f, -0.905164f, -0.020699f}, {-0.248191f, -0.968106f, 0.034245f}, {0.306025f, 0.275881f} },
    { {-0.289097f, -0.917639f, 0.055867f}, {-0.245458f, -0.934452f, -0.257970f}, {0.308510f, 0.264295f} },
    { {-0.209350f, -0.070318f, -0.049753f}, {-0.904642f, 0.279954f, -0.321322f}, {0.314208f, 0.280277f} },
    { {-0.193753f, -1.019618f, -0.193537f}, {-0.991086f, -0.048758f, -0.123983f}, {0.392439f, 0.302033f} },
    { {-0.190855f, -1.107970f, -0.181955f}, {-0.991086f, -0.048758f, -0.123983f}, {0.399720f, 0.300281f} },
    { {-0.192200f, -1.104313f, -0.172642f}, {-0.991086f, -0.048758f, -0.123983f}, {0.399418f, 0.298872f} },
    { {-0.110577f, -1.157511f, -0.136918f}, {-0.597841f, -0.771772f, 0.216690f}, {0.403802f, 0.293466f} },
    { {-0.192200f, -1.104313f, -0.172642f}, {-0.597841f, -0.771772f, 0.216690f}, {0.399418f, 0.298872f} },
    { {-0.190855f, -1.107970f, -0.181955f}, {-0.597841f, -0.771772f, 0.216690f}, {0.399720f, 0.300281f} },
    { {-0.217829f, -0.709302f, -0.098559f}, {0.685377f, -0.543700f, -0.484406f}, {0.353291f, 0.287662f} },
    { {-0.283289f, -1.062825f, 0.164940f}, {0.320114f, -0.299388f, -0.898829f}, {0.410582f, 0.312285f} },
    { {-0.283289f, -1.062825f, 0.164940f}, {-0.401200f, 0.007334f, -0.915961f}, {0.410582f, 0.312285f} },
    { {-0.273453f, -1.024674f, 0.155736f}, {-0.508765f, -0.075737f, -0.857568f}, {0.408779f, 0.309188f} },
    { {-0.235912f, -1.139188f, 0.143577f}, {-0.370844f, 0.155469f, -0.915589f}, {0.401898f, 0.318482f} },
    { {-0.215918f, -0.941017f, -0.083447f}, {0.610669f, 0.595002f, 0.522547f}, {0.334195f, 0.285375f} },
    { {-0.252556f, -0.933344f, -0.049367f}, {0.610669f, 0.595002f, 0.522547f}, {0.334828f, 0.280219f} },
    { {-0.173893f, -1.058972f, 0.001751f}, {0.610669f, 0.595002f, 0.522547f}, {0.324475f, 0.272484f} },
    { {-0.215918f, -0.941017f, -0.083447f}, {0.131406f, -0.927461f, 0.350069f}, {0.321924f, 0.285375f} },
    { {-0.200854f, -0.914135f, -0.017881f}, {0.131406f, -0.927461f, 0.350069f}, {0.324685f, 0.275454f} },
    { {-0.252556f, -0.933344f, -0.049367f}, {0.131406f, -0.927461f, 0.350069f}, {0.315208f, 0.280219f} },
    { {0.162645f, -0.547640f, -0.376876f}, {0.637141f, -0.177016f, -0.750145f}, {0.366613f, 0.329775f} },
    { {-0.118673f, -1.190562f, -0.147013f}, {0.995211f, 0.055465f, -0.080493f}, {0.313631f, 0.294994f} },
    { {-0.121608f, -1.243944f, -0.067466f}, {0.999565f, -0.010484f, 0.027551f}, {0.309232f, 0.282957f} },
    { {-0.118936f, -1.200848f, -0.157354f}, {0.996292f, 0.044679f, -0.073524f}, {0.312783f, 0.296558f} },
    { {-0.139317f, -1.107505f, -0.192407f}, {0.973904f, 0.148042f, -0.172034f}, {0.320475f, 0.301862f} },
    { {0.155434f, -0.314211f, -0.077574f}, {0.600682f, 0.541411f, 0.588265f}, {0.389992f, 0.251527f} },
    { {0.156602f, -0.282254f, -0.096843f}, {0.999445f, -0.020855f, 0.025981f}, {0.388483f, 0.287402f} },
    { {0.192314f, -0.786076f, -0.156191f}, {-0.029624f, -0.191941f, 0.980959f}, {0.396752f, 0.289824f} },
    { {0.219415f, -0.827723f, -0.163522f}, {0.029841f, 0.192076f, -0.980926f}, {0.318437f, 0.293204f} },
    { {0.158529f, -0.207091f, 0.121621f}, {0.392054f, 0.069082f, -0.917345f}, {0.329597f, 0.242833f} },
    { {-0.236603f, -0.243718f, -0.097944f}, {-0.681869f, 0.318720f, -0.658386f}, {0.328498f, 0.287569f} },
    { {-0.236603f, -0.243718f, -0.097944f}, {-0.681869f, 0.318720f, -0.658386f}, {0.402024f, 0.245806f} },
    { {-0.232069f, -0.404961f, -0.174210f}, {-0.599521f, 0.305040f, -0.739949f}, {0.401193f, 0.258893f} },
    { {-0.269701f, -0.372927f, -0.130514f}, {-0.807930f, 0.273830f, -0.521791f}, {0.408091f, 0.256293f} },
    { {0.032002f, -0.251750f, 0.315597f}, {0.117215f, 0.151579f, 0.981471f}, {0.367367f, 0.246458f} },
    { {0.015018f, -0.597857f, 0.371079f}, {0.117215f, 0.151579f, 0.981471f}, {0.364254f, 0.274548f} },
    { {0.030294f, -0.416737f, 0.341282f}, {0.117215f, 0.151579f, 0.981471f}, {0.367054f, 0.259848f} },
    { {0.305717f, -0.833169f, -0.077685f}, {0.645520f, 0.696826f, -0.312630f}, {0.302618f, 0.284503f} },
    { {-0.304656f, -0.927990f, 0.052205f}, {-0.817748f, 0.543382f, 0.189803f}, {0.414498f, 0.264850f} },
    { {0.320499f, -0.892494f, 0.051740f}, {0.871665f, 0.471101f, 0.135148f}, {0.299909f, 0.264920f} },
    { {0.011862f, -0.623795f, 0.328603f}, {0.992833f, -0.109343f, -0.048236f}, {0.360337f, 0.223027f} },
    { {0.032127f, -0.417447f, 0.309849f}, {0.992134f, -0.044656f, 0.116948f}, {0.377342f, 0.225865f} },
    { {0.024617f, -0.511904f, 0.337492f}, {0.547454f, 0.078807f, 0.833117f}, {0.369558f, 0.221682f} },
    { {0.176161f, -0.683017f, 0.306509f}, {0.339039f, 0.940772f, -0.000493f}, {0.326366f, 0.226370f} },
    { {0.011862f, -0.623795f, 0.328603f}, {0.339039f, 0.940772f, -0.000493f}, {0.356481f, 0.223027f} },
    { {0.011020f, -0.623484f, 0.342455f}, {0.339039f, 0.940772f, -0.000493f}, {0.356636f, 0.220931f} },
    { {-0.288357f, -0.714357f, -0.060982f}, {-0.080117f, -0.994569f, -0.066439f}, {0.308646f, 0.281976f} },
    { {-0.259789f, -0.715647f, -0.076126f}, {-0.080117f, -0.994569f, -0.066439f}, {0.313882f, 0.284268f} },
    { {-0.302610f, -0.717268f, -0.000221f}, {-0.080117f, -0.994569f, -0.066439f}, {0.306033f, 0.272782f} },
    { {-0.288357f, -0.714357f, -0.060982f}, {-0.812973f, -0.205100f, -0.544986f}, {0.411511f, 0.284003f} },
    { {-0.238311f, -0.571670f, -0.180274f}, {-0.912089f, -0.001738f, -0.409989f}, {0.402337f, 0.272423f} },
    { {-0.259789f, -0.715647f, -0.076126f}, {-0.910044f, -0.168610f, -0.378670f}, {0.406274f, 0.284108f} },
    { {-0.251946f, -1.101339f, 0.239650f}, {-0.377267f, -0.527911f, 0.760907f}, {0.399173f, 0.236487f} },
    { {-0.285041f, -1.002126f, 0.235301f}, {-0.760501f, -0.131536f, 0.635875f}, {0.390997f, 0.237145f} },
    { {-0.296485f, -0.725490f, 0.042436f}, {-0.118300f, -0.989431f, 0.083854f}, {0.307156f, 0.266328f} },
    { {-0.286940f, -0.712309f, 0.080398f}, {-0.363538f, -0.767365f, 0.528196f}, {0.308906f, 0.260583f} },
    { {-0.317800f, -0.722819f, 0.043890f}, {-0.484642f, -0.862494f, 0.145694f}, {0.303249f, 0.266108f} },
    { {-0.302610f, -0.717268f, -0.000221f}, {-0.429636f, -0.813477f, -0.392005f}, {0.306033f, 0.272782f} },
    { {0.097610f, -1.127267f, 0.267544f}, {0.811201f, -0.581415f, 0.062529f}, {0.318847f, 0.232266f} },
    { {0.188294f, -0.999284f, 0.281119f}, {0.774192f, -0.629969f, 0.061374f}, {0.329394f, 0.230212f} },
    { {0.187451f, -0.998971f, 0.294970f}, {0.774192f, -0.629969f, 0.061374f}, {0.329419f, 0.228116f} },
    { {0.255845f, -0.934682f, 0.248293f}, {0.704752f, -0.707006f, 0.058888f}, {0.334717f, 0.235179f} },
    { {-0.274329f, -1.025951f, 0.138076f}, {-0.857508f, 0.052466f, 0.511788f}, {0.311217f, 0.309292f} },
    { {-0.251640f, -1.106677f, 0.129132f}, {-0.749892f, -0.345504f, 0.564170f}, {0.315376f, 0.315844f} },
    { {-0.262658f, -1.022599f, 0.145010f}, {-0.985237f, -0.164903f, -0.046000f}, {0.313356f, 0.309020f} },
    { {-0.264254f, -0.950713f, 0.092009f}, {-0.999362f, -0.026144f, -0.024327f}, {0.313064f, 0.303186f} },
    { {-0.228981f, -0.181087f, -0.088140f}, {-0.979498f, 0.141627f, -0.143268f}, {0.323336f, 0.286085f} },
    { {-0.273853f, -0.634210f, 0.147222f}, {0.080150f, -0.396049f, 0.914725f}, {0.311304f, 0.277498f} },
    { {-0.253908f, -0.636790f, 0.145767f}, {0.039342f, -0.253535f, 0.966526f}, {0.314960f, 0.277708f} },
    { {-0.286940f, -0.712309f, 0.080398f}, {0.100643f, -0.656512f, 0.747571f}, {0.308906f, 0.283837f} },
    { {0.126898f, -1.146976f, 0.231600f}, {0.349098f, -0.846877f, 0.401161f}, {0.384761f, 0.319114f} },
    { {-0.003096f, -1.160790f, 0.263804f}, {0.156961f, -0.940515f, 0.301323f}, {0.360934f, 0.320236f} },
    { {0.234194f, -0.723464f, 0.260061f}, {0.874774f, 0.218262f, 0.432587f}, {0.352123f, 0.233398f} },
    { {0.212585f, -0.870891f, 0.112094f}, {-0.838555f, 0.532646f, 0.114513f}, {0.380182f, 0.255787f} },
    { {0.221163f, -0.859057f, 0.119867f}, {-0.174980f, 0.812391f, 0.556239f}, {0.379207f, 0.254611f} },
    { {0.191248f, -0.943039f, 0.176449f}, {-0.843113f, 0.441319f, 0.307241f}, {0.386128f, 0.246050f} },
    { {-0.142288f, -1.220358f, 0.116669f}, {0.981734f, -0.023730f, 0.188775f}, {0.311175f, 0.255095f} },
    { {-0.143113f, -1.188016f, 0.152296f}, {0.978131f, -0.142218f, 0.151771f}, {0.313841f, 0.249704f} },
    { {-0.145320f, -1.232582f, 0.124757f}, {0.972292f, -0.102022f, 0.210333f}, {0.310168f, 0.253871f} },
    { {-0.134491f, -1.256046f, 0.079439f}, {0.978499f, -0.084648f, 0.188079f}, {0.308234f, 0.260729f} },
    { {0.246213f, -0.822077f, 0.023727f}, {-0.257505f, 0.962623f, 0.083949f}, {0.376160f, 0.269158f} },
    { {-0.117201f, -1.392289f, -0.008113f}, {-0.365109f, -0.512688f, -0.777076f}, {0.340018f, 0.273976f} },
    { {-0.117201f, -1.392289f, -0.008113f}, {-0.365109f, -0.512688f, -0.777076f}, {0.423150f, 0.273976f} },
    { {-0.190886f, -1.174778f, 0.017485f}, {-0.560639f, -0.826978f, 0.042325f}, {0.326512f, 0.270103f} },
    { {-0.203290f, -1.164332f, -0.060944f}, {-0.613758f, -0.745801f, -0.259003f}, {0.324239f, 0.281970f} },
    { {-0.185992f, -1.172784f, -0.046613f}, {-0.079360f, -0.996554f, -0.024127f}, {0.327409f, 0.279802f} },
    { {0.319713f, -1.085868f, 0.082258f}, {0.970167f, -0.226184f, 0.087270f}, {0.322258f, 0.260302f} },
    { {0.199603f, -1.129715f, 0.002324f}, {0.052337f, -0.987743f, -0.147052f}, {0.398088f, 0.272397f} },
    { {0.198292f, -1.094238f, -0.086159f}, {0.033077f, -0.761744f, -0.647034f}, {0.397847f, 0.285786f} },
    { {0.198292f, -1.094238f, -0.086159f}, {0.033077f, -0.761744f, -0.647034f}, {0.322309f, 0.314834f} },
    { {0.150259f, -1.377143f, -0.011350f}, {0.408331f, -0.501507f, -0.762730f}, {0.389043f, 0.274466f} },
    { {-0.180886f, -1.115633f, -0.205981f}, {0.063134f, -0.337075f, -0.939359f}, {0.400351f, 0.303916f} },
    { {0.190667f, -0.989950f, -0.207409f}, {-0.206502f, 0.287385f, -0.935290f}, {0.389994f, 0.304132f} },
    { {0.156728f, -1.094490f, -0.206055f}, {-0.381911f, -0.079921f, -0.920737f}, {0.398609f, 0.303927f} },
    { {0.249411f, -1.205879f, -0.016853f}, {0.698308f, 0.671099f, -0.248982f}, {0.312368f, 0.275299f} },
    { {0.236907f, -1.180343f, -0.091713f}, {0.130449f, 0.823315f, 0.552391f}, {0.315231f, 0.286626f} },
    { {0.225089f, -1.194477f, -0.054335f}, {0.241075f, 0.880105f, 0.409022f}, {0.317397f, 0.280970f} },
    { {0.249411f, -1.205879f, -0.016853f}, {-0.072035f, 0.940252f, 0.332771f}, {0.312939f, 0.275299f} },
    { {-0.198654f, -1.231320f, -0.016520f}, {-0.770153f, 0.587720f, -0.247891f}, {0.409885f, 0.275248f} },
    { {-0.189231f, -1.204539f, -0.091396f}, {-0.221987f, 0.803304f, 0.552652f}, {0.393341f, 0.286578f} },
    { {-0.198654f, -1.231320f, -0.016520f}, {-0.034368f, 0.942391f, 0.332743f}, {0.395068f, 0.275248f} },
    { {-0.175834f, -1.217241f, -0.054037f}, {-0.338544f, 0.847194f, 0.409452f}, {0.390886f, 0.280925f} },
    { {-0.262328f, -0.652900f, 0.223649f}, {-0.757364f, -0.261072f, 0.598533f}, {0.362218f, 0.238908f} },
    { {0.284058f, -1.017703f, 0.082546f}, {0.510237f, -0.474331f, -0.717404f}, {0.327876f, 0.260258f} },
    { {0.218382f, -1.092963f, -0.206278f}, {0.098443f, -0.407059f, -0.908081f}, {0.321674f, 0.303961f} },
    { {-0.283352f, -1.025524f, -0.081190f}, {-0.124024f, 0.555114f, -0.822476f}, {0.410593f, 0.309257f} },
    { {-0.291107f, -0.988062f, -0.054737f}, {-0.124024f, 0.555114f, -0.822476f}, {0.412015f, 0.306217f} },
    { {-0.272859f, -1.035981f, -0.089830f}, {-0.124024f, 0.555114f, -0.822476f}, {0.408670f, 0.310106f} },
    { {-0.271725f, -1.160446f, 0.113197f}, {-0.612366f, -0.563728f, 0.554273f}, {0.404044f, 0.255621f} },
    { {0.314182f, -1.127179f, 0.112761f}, {0.092136f, -0.627646f, 0.773027f}, {0.318854f, 0.255686f} },
    { {-0.226378f, -1.138849f, 0.214609f}, {-0.376562f, -0.819318f, 0.432342f}, {0.320007f, 0.318455f} },
    { {-0.226378f, -1.138849f, 0.214609f}, {-0.376562f, -0.819318f, 0.432342f}, {0.320007f, 0.240276f} },
    { {-0.111172f, -1.100829f, 0.195594f}, {0.212704f, -0.263508f, 0.940915f}, {0.341123f, 0.315369f} },
    { {-0.111172f, -1.100829f, 0.195594f}, {0.225155f, 0.478871f, -0.848521f}, {0.379033f, 0.315369f} },
    { {-0.184623f, -1.057023f, 0.200826f}, {0.225155f, 0.478871f, -0.848521f}, {0.392497f, 0.311814f} },
    { {-0.138141f, -1.054214f, 0.214745f}, {0.225155f, 0.478871f, -0.848521f}, {0.383976f, 0.311586f} },
    { {-0.245779f, -0.417356f, -0.111693f}, {-0.053856f, 0.159700f, -0.985695f}, {0.403706f, 0.259899f} },
    { {-0.264892f, -0.563285f, -0.108988f}, {-0.099497f, -0.168655f, -0.980640f}, {0.407210f, 0.271742f} },
    { {-0.094232f, -0.460171f, -0.374029f}, {-0.397959f, 0.890403f, 0.220933f}, {0.375928f, 0.329344f} },
    { {-0.003333f, -0.255153f, 0.313058f}, {-0.976921f, 0.204977f, -0.060081f}, {0.329440f, 0.225379f} },
    { {-0.002336f, -0.255552f, 0.295476f}, {-0.976921f, 0.204977f, -0.060081f}, {0.329473f, 0.228039f} },
    { {-0.029473f, -0.376766f, 0.323191f}, {-0.976921f, 0.204977f, -0.060081f}, {0.339462f, 0.223846f} },
    { {0.034585f, -0.308039f, -0.256211f}, {-0.000476f, 0.963618f, 0.267281f}, {0.352316f, 0.311516f} },
    { {0.294703f, -1.033427f, -0.094850f}, {0.768319f, -0.229974f, -0.597326f}, {0.326580f, 0.287101f} },
    { {0.294131f, -1.110348f, -0.053586f}, {0.799398f, -0.312556f, -0.513101f}, {0.320241f, 0.280857f} },
    { {0.162337f, -1.037323f, 0.200568f}, {-0.857920f, 0.294723f, 0.420847f}, {0.393898f, 0.242400f} },
    { {0.199752f, -0.936200f, 0.188717f}, {-0.125760f, 0.420442f, 0.898562f}, {0.385564f, 0.244193f} },
    { {-0.247334f, -0.958297f, -0.090426f}, {-0.834569f, 0.358956f, -0.417905f}, {0.403991f, 0.303801f} },
    { {-0.234618f, -0.951583f, -0.094915f}, {-0.960794f, -0.005341f, -0.277212f}, {0.401660f, 0.303256f} },
    { {-0.167559f, -0.810597f, -0.220215f}, {-0.018935f, 0.892322f, 0.451003f}, {0.389369f, 0.306070f} },
    { {-0.203269f, -0.832664f, -0.178055f}, {-0.018935f, 0.892322f, 0.451003f}, {0.395914f, 0.299691f} },
    { {-0.212506f, -0.849657f, -0.144821f}, {-0.018935f, 0.892322f, 0.451003f}, {0.397607f, 0.294662f} },
    { {0.015018f, -0.597857f, 0.371079f}, {0.306113f, 0.053819f, 0.950473f}, {0.364254f, 0.274548f} },
    { {-0.292233f, -1.064171f, 0.100507f}, {-0.873113f, -0.350844f, 0.338500f}, {0.396110f, 0.257541f} },
    { {-0.300248f, -1.049353f, 0.095191f}, {-0.911879f, -0.261595f, 0.316298f}, {0.394889f, 0.258345f} },
    { {-0.276381f, -1.141240f, 0.061516f}, {-0.850626f, -0.395494f, 0.346439f}, {0.402461f, 0.263441f} },
    { {-0.300248f, -1.049353f, 0.095191f}, {-0.032880f, 0.321702f, 0.946270f}, {0.306466f, 0.311191f} },
    { {-0.292233f, -1.064171f, 0.100507f}, {-0.032880f, 0.321702f, 0.946270f}, {0.307935f, 0.312394f} },
    { {-0.300051f, -1.008307f, 0.081243f}, {-0.032880f, 0.321702f, 0.946270f}, {0.306502f, 0.307860f} },
    { {-0.247795f, -0.277186f, -0.062667f}, {-0.028799f, 0.316673f, -0.948097f}, {0.404076f, 0.248522f} },
    { {-0.219339f, -0.174854f, -0.031498f}, {-0.031844f, 0.299315f, -0.953623f}, {0.398860f, 0.240217f} },
    { {-0.229715f, -0.279895f, -0.064121f}, {-0.027998f, 0.321424f, -0.946521f}, {0.400762f, 0.248742f} },
    { {-0.300688f, -0.969020f, 0.002224f}, {-0.985659f, 0.008232f, -0.168549f}, {0.388269f, 0.272412f} },
    { {0.175099f, -0.682619f, 0.324091f}, {0.399742f, 0.915198f, 0.051183f}, {0.326560f, 0.223710f} },
    { {0.026414f, -0.620213f, 0.369462f}, {0.399742f, 0.915198f, 0.051183f}, {0.353814f, 0.216845f} },
    { {0.135901f, -0.666576f, 0.343375f}, {0.399742f, 0.915198f, 0.051183f}, {0.333745f, 0.220792f} },
    { {-0.123154f, -1.268707f, -0.021974f}, {0.992194f, -0.102443f, 0.071114f}, {0.307191f, 0.276074f} },
    { {-0.125543f, -1.254395f, 0.027705f}, {0.991975f, -0.047077f, 0.117340f}, {0.308370f, 0.268557f} },
    { {-0.078557f, -0.465218f, -0.326241f}, {-0.216360f, 0.960996f, 0.172264f}, {0.346751f, 0.322113f} },
    { {0.189429f, -0.495783f, -0.334258f}, {0.797022f, 0.173668f, -0.578442f}, {0.370886f, 0.323326f} },
    { {0.189429f, -0.495783f, -0.334258f}, {0.797022f, 0.173668f, -0.578442f}, {0.323934f, 0.266264f} },
    { {0.201425f, -0.459872f, -0.306948f}, {0.807054f, 0.371000f, -0.459373f}, {0.321735f, 0.263349f} },
    { {0.114342f, -1.205787f, 0.116478f}, {-0.951967f, -0.189040f, 0.240880f}, {0.407781f, 0.255124f} },
    { {0.140857f, -1.138886f, 0.191370f}, {-0.130703f, -0.434231f, 0.891269f}, {0.402267f, 0.243792f} },
    { {0.135059f, -1.132190f, 0.178925f}, {-0.893110f, 0.075186f, 0.443511f}, {0.401716f, 0.245675f} },
    { {0.169583f, -1.036742f, 0.214516f}, {-0.095640f, -0.039659f, 0.994626f}, {0.393850f, 0.240290f} },
    { {0.232197f, -0.562849f, 0.279214f}, {0.915443f, -0.400497f, -0.039572f}, {0.365360f, 0.230500f} },
    { {0.205958f, -0.623267f, 0.283670f}, {0.915443f, -0.400497f, -0.039572f}, {0.360381f, 0.229826f} },
    { {0.265516f, -0.483372f, 0.245638f}, {0.915443f, -0.400497f, -0.039572f}, {0.371909f, 0.235581f} },
    { {0.138829f, -1.239384f, 0.027508f}, {-0.953117f, -0.293512f, -0.073613f}, {0.410549f, 0.268586f} },
    { {0.118751f, -1.217588f, 0.124561f}, {-0.133284f, -0.801411f, 0.583075f}, {0.408753f, 0.253901f} },
    { {-0.022817f, -0.668974f, 0.360478f}, {0.982246f, -0.091605f, -0.163713f}, {0.356614f, 0.218204f} },
    { {-0.001191f, -0.374046f, 0.325206f}, {0.982246f, -0.091605f, -0.163713f}, {0.380919f, 0.223541f} },
    { {-0.012861f, -0.580116f, 0.370493f}, {0.982246f, -0.091605f, -0.163713f}, {0.363937f, 0.216688f} },
    { {-0.022817f, -0.668974f, 0.360478f}, {-0.631542f, 0.170058f, -0.756462f}, {0.362838f, 0.280320f} },
    { {-0.023197f, -0.668812f, 0.360831f}, {-0.631542f, 0.170058f, -0.756462f}, {0.362907f, 0.280307f} },
    { {0.011020f, -0.623484f, 0.342455f}, {-0.631542f, 0.170058f, -0.756462f}, {0.356636f, 0.276628f} },
    { {0.227431f, -0.872906f, -0.145149f}, {-0.019475f, 0.047448f, -0.998684f}, {0.339808f, 0.294712f} },
    { {0.220731f, -0.848489f, -0.144835f}, {0.592096f, 0.701086f, 0.397367f}, {0.341820f, 0.294664f} },
    { {0.225727f, -0.901127f, -0.137092f}, {0.655624f, 0.170420f, 0.735605f}, {0.337483f, 0.293492f} },
    { {0.227431f, -0.872906f, -0.145149f}, {0.746172f, 0.196551f, 0.636078f}, {0.339808f, 0.294712f} },
    { {-0.232069f, -0.404961f, -0.174210f}, {-0.599521f, 0.305040f, -0.739949f}, {0.341786f, 0.299109f} },
    { {-0.203679f, -0.129011f, -0.033351f}, {-0.079850f, -0.013005f, -0.996722f}, {0.395989f, 0.236496f} },
    { {-0.219339f, -0.174854f, -0.031498f}, {-0.079850f, -0.013005f, -0.996722f}, {0.398860f, 0.240217f} },
    { {-0.222282f, -0.126612f, -0.031892f}, {-0.079850f, -0.013005f, -0.996722f}, {0.399399f, 0.236302f} },
    { {-0.203679f, -0.129011f, -0.033351f}, {0.148982f, 0.813400f, 0.562302f}, {0.324167f, 0.236496f} },
    { {-0.005022f, -1.042321f, 0.311114f}, {0.012946f, -0.999645f, 0.023287f}, {0.360581f, 0.225673f} },
    { {0.187451f, -0.998971f, 0.294970f}, {0.222445f, -0.974286f, 0.035858f}, {0.395860f, 0.228116f} },
    { {-0.005891f, -1.042010f, 0.324965f}, {0.012946f, -0.999645f, 0.023287f}, {0.360421f, 0.223577f} },
    { {-0.192115f, -1.003848f, 0.296630f}, {-0.202107f, -0.979319f, 0.009340f}, {0.326287f, 0.227865f} },
    { {0.153380f, -0.355773f, 0.005988f}, {0.500850f, 0.852682f, -0.148600f}, {0.382424f, 0.271843f} },
    { {0.153667f, -0.350668f, 0.036247f}, {0.500850f, 0.852682f, -0.148600f}, {0.382845f, 0.267264f} },
    { {0.191802f, -0.374010f, 0.030843f}, {0.500850f, 0.852682f, -0.148600f}, {0.380922f, 0.268082f} },
    { {0.260820f, -0.368920f, -0.125452f}, {0.887339f, 0.431791f, -0.161821f}, {0.310848f, 0.255967f} },
    { {0.211740f, -0.324816f, -0.147631f}, {0.670829f, 0.462755f, -0.579523f}, {0.319844f, 0.252388f} },
    { {-0.151958f, -0.505046f, -0.361585f}, {-0.723452f, 0.353624f, -0.592931f}, {0.350034f, 0.327461f} },
    { {-0.151958f, -0.505046f, -0.361585f}, {-0.723452f, 0.353624f, -0.592931f}, {0.386509f, 0.267015f} },
    { {-0.292819f, -0.676501f, 0.116131f}, {0.299953f, -0.648716f, 0.699426f}, {0.307828f, 0.280931f} },
    { {-0.292819f, -0.676501f, 0.116131f}, {-0.467927f, -0.661568f, 0.585980f}, {0.307828f, 0.280931f} },
    { {-0.317800f, -0.722819f, 0.043890f}, {-0.484642f, -0.862494f, 0.145694f}, {0.303249f, 0.284690f} },
    { {-0.286940f, -0.712309f, 0.080398f}, {-0.363538f, -0.767365f, 0.528196f}, {0.308906f, 0.283837f} },
    { {-0.202774f, -1.083182f, -0.145272f}, {-0.850627f, -0.357067f, -0.385924f}, {0.395824f, 0.313937f} },
    { {-0.186958f, -1.151442f, -0.110709f}, {-0.400281f, -0.909624f, -0.111169f}, {0.392924f, 0.319477f} },
    { {0.155301f, -1.090777f, -0.192627f}, {-0.965554f, 0.186429f, -0.181519f}, {0.398303f, 0.301895f} },
    { {0.138153f, -1.186250f, -0.157545f}, {-0.247612f, -0.582519f, -0.774183f}, {0.406171f, 0.296587f} },
    { {0.136743f, -1.176059f, -0.147202f}, {-0.990017f, -0.030187f, -0.137679f}, {0.405331f, 0.295022f} },
    { {0.135768f, -1.242706f, -0.072460f}, {-0.115201f, -0.956853f, -0.266762f}, {0.410823f, 0.283713f} },
    { {0.208718f, -0.935174f, -0.165600f}, {0.125732f, 0.342471f, -0.931077f}, {0.320398f, 0.301925f} },
    { {-0.201861f, -0.913731f, 0.017583f}, {0.197694f, -0.955343f, -0.219628f}, {0.324500f, 0.270088f} },
    { {-0.203125f, -0.921933f, 0.052125f}, {0.070603f, -0.822940f, -0.563724f}, {0.324269f, 0.264861f} },
    { {-0.255926f, -0.932265f, 0.049536f}, {0.190319f, -0.849286f, -0.492435f}, {0.314590f, 0.265253f} },
    { {-0.203125f, -0.921933f, 0.052125f}, {0.011579f, 0.809262f, 0.587334f}, {0.395888f, 0.264861f} },
    { {0.017571f, -0.302003f, 0.338610f}, {0.722834f, 0.105185f, 0.682969f}, {0.386856f, 0.221513f} },
    { {-0.216265f, -0.454873f, 0.167642f}, {0.095534f, 0.127698f, 0.987201f}, {0.321860f, 0.262943f} },
    { {0.091953f, -0.794021f, -0.259907f}, {0.516957f, -0.208865f, -0.830139f}, {0.341801f, 0.290469f} },
    { {0.174993f, -0.808260f, -0.204613f}, {0.516957f, -0.208865f, -0.830139f}, {0.326580f, 0.291624f} },
    { {0.208112f, -0.831801f, -0.178066f}, {0.516957f, -0.208865f, -0.830139f}, {0.320509f, 0.293535f} },
    { {0.174993f, -0.808260f, -0.204613f}, {0.387482f, 0.874415f, 0.291987f}, {0.326580f, 0.303709f} },
    { {0.220731f, -0.848489f, -0.144835f}, {0.592096f, 0.701086f, 0.397367f}, {0.318196f, 0.294664f} },
    { {0.208112f, -0.831801f, -0.178066f}, {0.462868f, 0.850104f, 0.251151f}, {0.320509f, 0.299692f} },
    { {-0.216691f, -0.660921f, 0.231745f}, {-0.811464f, -0.097665f, 0.576184f}, {0.321782f, 0.279666f} },
    { {-0.254001f, -0.754310f, 0.136353f}, {-0.951610f, 0.028338f, 0.306000f}, {0.314943f, 0.287246f} },
    { {0.262285f, -0.929234f, -0.000302f}, {0.548145f, 0.827302f, -0.122917f}, {0.310579f, 0.272794f} },
    { {0.271480f, -0.949773f, 0.070492f}, {0.385614f, 0.698060f, 0.603336f}, {0.308894f, 0.262082f} },
    { {0.279307f, -0.939542f, 0.021566f}, {0.957805f, 0.273020f, -0.089834f}, {0.307459f, 0.269486f} },
    { {0.262285f, -0.929234f, -0.000302f}, {0.548145f, 0.827302f, -0.122917f}, {0.335166f, 0.272794f} },
    { {-0.302610f, -0.717268f, -0.000221f}, {-0.429636f, -0.813477f, -0.392005f}, {0.414123f, 0.284239f} },
    { {0.133595f, -1.229454f, -0.067656f}, {-0.984968f, -0.172142f, -0.014339f}, {0.409731f, 0.282986f} },
    { {0.141953f, -1.252976f, 0.029368f}, {0.011337f, -0.989831f, 0.141796f}, {0.411669f, 0.268305f} },
    { {0.191802f, -0.374010f, 0.030843f}, {0.622065f, 0.546730f, -0.560466f}, {0.380922f, 0.268082f} },
    { {0.311317f, -0.899347f, -0.094209f}, {0.439410f, -0.784165f, 0.438183f}, {0.418565f, 0.299017f} },
    { {0.288327f, -0.930388f, -0.120492f}, {0.471286f, -0.689521f, 0.549955f}, {0.414351f, 0.301536f} },
    { {0.294508f, -0.958978f, -0.145845f}, {0.194054f, -0.494785f, 0.847072f}, {0.415484f, 0.303857f} },
    { {0.264313f, -0.998245f, -0.155548f}, {0.348423f, -0.335526f, 0.875228f}, {0.409949f, 0.307043f} },
    { {0.192282f, -1.154654f, 0.015868f}, {0.649959f, -0.751225f, -0.114959f}, {0.396746f, 0.270348f} },
    { {0.011020f, -0.623484f, 0.342455f}, {0.714213f, -0.056007f, 0.697684f}, {0.363521f, 0.276628f} },
    { {0.011020f, -0.623484f, 0.342455f}, {0.714213f, -0.056007f, 0.697684f}, {0.360363f, 0.220931f} },
    { {0.156981f, -0.748418f, 0.281129f}, {-0.198831f, -0.195563f, -0.960323f}, {0.329881f, 0.286768f} },
    { {0.260799f, -1.027230f, 0.113769f}, {0.432123f, 0.144839f, 0.890107f}, {0.327091f, 0.255534f} },
    { {0.090555f, -1.152624f, -0.121960f}, {-0.387079f, 0.327258f, -0.862016f}, {0.342057f, 0.319573f} },
    { {0.090555f, -1.152624f, -0.121960f}, {0.146717f, 0.582902f, 0.799187f}, {0.378100f, 0.319573f} },
    { {0.129525f, -1.137688f, -0.140009f}, {0.146717f, 0.582902f, 0.799187f}, {0.385243f, 0.318361f} },
    { {0.161460f, -1.101416f, -0.172327f}, {0.146717f, 0.582902f, 0.799187f}, {0.391096f, 0.315417f} },
    { {-0.249435f, -0.520515f, 0.262561f}, {-0.757160f, 0.119392f, 0.642226f}, {0.351308f, 0.233020f} },
    { {-0.133942f, -0.552410f, -0.397691f}, {-0.514009f, 0.032109f, -0.857184f}, {0.353937f, 0.332924f} },
    { {-0.090352f, -1.409800f, 0.027271f}, {-0.051209f, -0.971439f, -0.231698f}, {0.375217f, 0.340445f} },
    { {0.125765f, -1.376759f, -0.011337f}, {-0.923459f, 0.330603f, 0.194745f}, {0.421870f, 0.274464f} },
    { {0.126018f, -1.397541f, 0.025140f}, {0.160997f, -0.960843f, -0.225521f}, {0.335557f, 0.339450f} },
    { {0.265969f, -1.035970f, -0.164108f}, {0.163245f, -0.044573f, 0.985578f}, {0.410252f, 0.310105f} },
    { {0.236646f, -1.077330f, -0.154962f}, {0.363541f, 0.112597f, 0.924748f}, {0.404878f, 0.313462f} },
    { {0.201091f, -0.898982f, 0.051825f}, {-0.044126f, 0.864376f, 0.500906f}, {0.321796f, 0.264907f} },
    { {-0.078636f, -1.174550f, 0.005505f}, {0.267199f, -0.866632f, -0.421372f}, {0.347087f, 0.271916f} },
    { {-0.087209f, -1.187756f, 0.027231f}, {0.267199f, -0.866632f, -0.421372f}, {0.345516f, 0.268628f} },
    { {-0.186958f, -1.151442f, -0.110709f}, {0.267199f, -0.866632f, -0.421372f}, {0.327232f, 0.289500f} },
    { {-0.091955f, -1.168698f, 0.067352f}, {0.943868f, -0.240858f, 0.226056f}, {0.315432f, 0.262558f} },
    { {-0.087209f, -1.187756f, 0.027231f}, {0.943868f, -0.240858f, 0.226056f}, {0.313862f, 0.268628f} },
    { {-0.078636f, -1.174550f, 0.005505f}, {0.943868f, -0.240858f, 0.226056f}, {0.314950f, 0.271916f} },
    { {0.241421f, -1.118171f, -0.144865f}, {-0.075134f, 0.651125f, 0.755242f}, {0.405753f, 0.316777f} },
    { {0.221320f, -1.150861f, -0.118681f}, {0.238015f, 0.721060f, 0.650709f}, {0.402068f, 0.319430f} },
    { {0.236907f, -1.180343f, -0.091713f}, {0.130449f, 0.823315f, 0.552391f}, {0.404925f, 0.321823f} },
    { {0.236907f, -1.180343f, -0.091713f}, {0.130449f, 0.823315f, 0.552391f}, {0.314473f, 0.286626f} },
    { {0.221320f, -1.150861f, -0.118681f}, {0.238015f, 0.721060f, 0.650709f}, {0.316902f, 0.290707f} },
    { {0.225089f, -1.194477f, -0.054335f}, {0.241075f, 0.880105f, 0.409022f}, {0.313308f, 0.280970f} },
    { {-0.200832f, -1.143281f, -0.144536f}, {0.002069f, 0.655508f, 0.755186f}, {0.324689f, 0.318815f} },
    { {-0.189231f, -1.204539f, -0.091396f}, {-0.221987f, 0.803304f, 0.552652f}, {0.326815f, 0.323786f} },
    { {-0.177122f, -1.173484f, -0.118385f}, {-0.317141f, 0.689538f, 0.651121f}, {0.329035f, 0.321266f} },
    { {-0.189231f, -1.204539f, -0.091396f}, {-0.221987f, 0.803304f, 0.552652f}, {0.407678f, 0.286578f} },
    { {-0.175834f, -1.217241f, -0.054037f}, {-0.338544f, 0.847194f, 0.409452f}, {0.408724f, 0.280925f} },
    { {-0.177122f, -1.173484f, -0.118385f}, {-0.317141f, 0.689538f, 0.651121f}, {0.405119f, 0.290662f} },
    { {-0.147145f, -1.241755f, -0.119520f}, {-0.323648f, -0.851630f, -0.412284f}, {0.385627f, 0.326807f} },
    { {0.309755f, -1.113094f, -0.022871f}, {0.301791f, -0.923682f, -0.236080f}, {0.418278f, 0.276209f} },
    { {0.314229f, -1.121985f, 0.017637f}, {0.301791f, -0.923682f, -0.236080f}, {0.419098f, 0.270080f} },
    { {0.294131f, -1.110348f, -0.053586f}, {0.301791f, -0.923682f, -0.236080f}, {0.415414f, 0.280857f} },
    { {0.241421f, -1.118171f, -0.144865f}, {0.271525f, 0.260781f, 0.926427f}, {0.405753f, 0.316777f} },
    { {0.221320f, -1.150861f, -0.118681f}, {0.582894f, 0.258581f, 0.770305f}, {0.402068f, 0.319430f} },
    { {0.300763f, -0.875807f, -0.020594f}, {0.501991f, -0.834764f, 0.226217f}, {0.416630f, 0.275865f} },
    { {-0.234364f, -1.121563f, 0.039976f}, {0.794588f, 0.604450f, 0.057186f}, {0.319317f, 0.266700f} },
    { {-0.225506f, -1.126627f, -0.029572f}, {0.794588f, 0.604450f, 0.057186f}, {0.318899f, 0.277223f} },
    { {-0.232962f, -1.114357f, -0.055679f}, {0.794588f, 0.604450f, 0.057186f}, {0.319911f, 0.281174f} },
    { {0.091953f, -0.794021f, -0.259907f}, {-0.347637f, -0.890776f, 0.292689f}, {0.378356f, 0.312076f} },
    { {0.175827f, -0.812939f, -0.217862f}, {-0.434926f, -0.857324f, 0.275381f}, {0.393730f, 0.305714f} },
    { {0.174993f, -0.808260f, -0.204613f}, {-0.434926f, -0.857324f, 0.275381f}, {0.393577f, 0.303709f} },
    { {0.219415f, -0.827723f, -0.163522f}, {-0.568358f, -0.786407f, 0.241936f}, {0.376625f, 0.297492f} },
    { {0.174993f, -0.808260f, -0.204613f}, {-0.434926f, -0.857324f, 0.275381f}, {0.375021f, 0.303709f} },
    { {0.175827f, -0.812939f, -0.217862f}, {-0.434926f, -0.857324f, 0.275381f}, {0.375407f, 0.305714f} },
    { {-0.294974f, -0.933772f, -0.093759f}, {-0.347170f, -0.828828f, 0.438769f}, {0.307433f, 0.301811f} },
    { {0.180772f, -1.143986f, -0.107813f}, {0.343696f, -0.933901f, -0.098500f}, {0.325520f, 0.318872f} },
    { {0.080789f, -1.176341f, -0.062171f}, {0.195835f, -0.974954f, -0.105419f}, {0.343847f, 0.321498f} },
    { {0.161460f, -1.101416f, -0.172327f}, {0.363056f, -0.740649f, -0.565358f}, {0.329060f, 0.315417f} },
    { {-0.301982f, -0.987138f, 0.059498f}, {-0.792304f, 0.400518f, 0.460262f}, {0.389762f, 0.263746f} },
    { {-0.212506f, -0.849657f, -0.144821f}, {-0.181495f, -0.434436f, -0.882227f}, {0.378432f, 0.294662f} },
    { {-0.167559f, -0.810597f, -0.220215f}, {-0.018821f, -0.843922f, -0.536136f}, {0.375214f, 0.306070f} },
    { {-0.084038f, -0.393919f, 0.308830f}, {0.992833f, -0.105915f, 0.055362f}, {0.379281f, 0.226019f} },
    { {-0.083294f, -0.394242f, 0.294876f}, {0.992833f, -0.105915f, 0.055362f}, {0.379254f, 0.228130f} },
    { {-0.069826f, -0.277135f, 0.277381f}, {0.992833f, -0.105915f, 0.055362f}, {0.388905f, 0.230778f} },
    { {-0.029473f, -0.376766f, 0.323191f}, {-0.290670f, 0.956084f, -0.037614f}, {0.364058f, 0.223846f} },
    { {-0.083294f, -0.394242f, 0.294876f}, {-0.290670f, 0.956084f, -0.037614f}, {0.373923f, 0.228130f} },
    { {-0.084038f, -0.393919f, 0.308830f}, {-0.290670f, 0.956084f, -0.037614f}, {0.374059f, 0.226019f} },
    { {-0.220816f, -0.969240f, 0.304839f}, {-0.592385f, -0.110306f, 0.798068f}, {0.321026f, 0.304689f} },
    { {-0.247819f, -0.935326f, 0.283034f}, {-0.773263f, -0.633481f, -0.027679f}, {0.385492f, 0.229922f} },
    { {-0.193131f, -1.003442f, 0.314212f}, {-0.773263f, -0.633481f, -0.027679f}, {0.391106f, 0.225205f} },
    { {-0.220816f, -0.969240f, 0.304839f}, {-0.773263f, -0.633481f, -0.027679f}, {0.388287f, 0.226623f} },
    { {-0.215918f, -0.941017f, -0.083447f}, {0.958739f, 0.262167f, -0.109945f}, {0.334195f, 0.285375f} },
    { {-0.215918f, -0.941017f, -0.083447f}, {-0.197432f, 0.868663f, -0.454362f}, {0.398233f, 0.302399f} },
    { {0.159207f, -1.074088f, -0.188636f}, {0.530403f, 0.344654f, 0.774523f}, {0.390683f, 0.313199f} },
    { {0.129525f, -1.137688f, -0.140009f}, {0.530403f, 0.344654f, 0.774523f}, {0.385243f, 0.318361f} },
    { {0.154361f, -1.101528f, -0.173107f}, {0.530403f, 0.344654f, 0.774523f}, {0.389795f, 0.315426f} },
    { {0.231494f, -0.968975f, -0.087797f}, {0.322663f, 0.508417f, -0.798373f}, {0.316223f, 0.304668f} },
    { {0.247281f, -0.940642f, -0.049740f}, {0.453067f, 0.740807f, -0.495918f}, {0.313329f, 0.302368f} },
    { {0.259615f, -0.948466f, -0.050160f}, {0.730835f, 0.481789f, -0.483487f}, {0.311069f, 0.303003f} },
    { {0.247281f, -0.940642f, -0.049740f}, {0.453067f, 0.740807f, -0.495918f}, {0.334226f, 0.280275f} },
    { {0.231494f, -0.968975f, -0.087797f}, {0.322663f, 0.508417f, -0.798373f}, {0.331891f, 0.286033f} },
    { {0.311317f, -0.899347f, -0.094209f}, {0.439410f, -0.784165f, 0.438183f}, {0.418565f, 0.287004f} },
    { {-0.171510f, -0.808174f, -0.218587f}, {0.405562f, -0.854029f, 0.325814f}, {0.345143f, 0.305824f} },
    { {-0.097561f, -0.790293f, -0.263766f}, {0.286793f, -0.897812f, 0.334190f}, {0.346616f, 0.312660f} },
    { {-0.098351f, -0.785614f, -0.250517f}, {0.328927f, -0.702253f, 0.631386f}, {0.347002f, 0.310655f} },
    { {0.000338f, -0.780909f, -0.292811f}, {0.025480f, -0.679769f, 0.732983f}, {0.361563f, 0.317055f} },
    { {-0.098351f, -0.785614f, -0.250517f}, {0.328927f, -0.702253f, 0.631386f}, {0.343473f, 0.310655f} },
    { {-0.097561f, -0.790293f, -0.263766f}, {0.286793f, -0.897812f, 0.334190f}, {0.343618f, 0.312660f} },
    { {-0.287043f, -0.909182f, -0.020157f}, {-0.403938f, -0.886202f, 0.226891f}, {0.308887f, 0.275799f} },
    { {-0.294974f, -0.933772f, -0.093759f}, {-0.347170f, -0.828828f, 0.438769f}, {0.307433f, 0.286936f} },
    { {-0.231710f, -1.165649f, 0.191721f}, {0.073920f, -0.393253f, 0.916454f}, {0.404473f, 0.243739f} },
    { {-0.200832f, -1.143281f, -0.144536f}, {-0.297926f, 0.228448f, 0.926850f}, {0.324689f, 0.318815f} },
    { {-0.177122f, -1.173484f, -0.118385f}, {-0.607277f, 0.191004f, 0.771189f}, {0.329035f, 0.321266f} },
    { {-0.200727f, -1.102163f, -0.154637f}, {-0.372580f, 0.070800f, 0.925296f}, {0.324708f, 0.315477f} },
    { {-0.234556f, -1.064389f, -0.163736f}, {-0.155689f, -0.062683f, 0.985815f}, {0.318508f, 0.312412f} },
    { {-0.101261f, -1.388441f, 0.081025f}, {0.955500f, 0.286414f, 0.070611f}, {0.297324f, 0.260489f} },
    { {-0.127657f, -1.391714f, 0.081068f}, {-0.748267f, -0.653203f, 0.115857f}, {0.338102f, 0.338977f} },
    { {-0.095798f, -1.402583f, 0.064460f}, {-0.124923f, -0.948004f, 0.292717f}, {0.343941f, 0.339860f} },
    { {-0.101261f, -1.388441f, 0.081025f}, {0.093065f, -0.741884f, 0.664038f}, {0.342940f, 0.338712f} },
    { {0.134717f, -1.375048f, 0.080498f}, {-0.939726f, 0.333997f, -0.073223f}, {0.421729f, 0.260568f} },
    { {0.161310f, -1.375312f, 0.080501f}, {0.800354f, -0.596990f, 0.055103f}, {0.391069f, 0.337646f} },
    { {0.134717f, -1.375048f, 0.080498f}, {-0.007605f, -0.757132f, 0.653218f}, {0.386194f, 0.337625f} },
    { {0.130829f, -1.389727f, 0.063438f}, {0.232681f, -0.930085f, 0.284255f}, {0.385482f, 0.338816f} },
    { {0.275130f, -1.136871f, 0.191344f}, {0.066833f, -0.297090f, 0.952508f}, {0.318055f, 0.243796f} },
    { {-0.204242f, -0.745368f, 0.295243f}, {0.891285f, -0.146401f, -0.429160f}, {0.350318f, 0.228075f} },
    { {0.328155f, -1.044692f, 0.095130f}, {0.009641f, -0.300136f, 0.953848f}, {0.421651f, 0.310813f} },
    { {0.323642f, -1.029202f, 0.100049f}, {0.009641f, -0.300136f, 0.953848f}, {0.420824f, 0.309556f} },
    { {0.319713f, -1.085868f, 0.082258f}, {0.009641f, -0.300136f, 0.953848f}, {0.420104f, 0.314155f} },
    { {0.128194f, -0.457749f, -0.310489f}, {0.397022f, 0.878542f, 0.265590f}, {0.335158f, 0.319730f} },
    { {0.215444f, -0.999750f, 0.143816f}, {-0.906047f, 0.116362f, 0.406865f}, {0.390801f, 0.250988f} },
    { {0.209548f, -1.035375f, 0.140875f}, {0.120733f, -0.101506f, 0.987482f}, {0.399911f, 0.310057f} },
    { {0.033814f, -0.252462f, 0.284164f}, {0.565352f, 0.146800f, 0.811682f}, {0.390938f, 0.229751f} },
    { {-0.023197f, -0.668812f, 0.360831f}, {-0.201575f, 0.129257f, -0.970907f}, {0.362907f, 0.280307f} },
    { {-0.012861f, -0.580116f, 0.370493f}, {0.636340f, -0.156443f, 0.755378f}, {0.363937f, 0.216688f} },
    { {-0.023197f, -0.668812f, 0.360831f}, {0.636340f, -0.156443f, 0.755378f}, {0.356627f, 0.218150f} },
    { {-0.022817f, -0.668974f, 0.360478f}, {0.636340f, -0.156443f, 0.755378f}, {0.356614f, 0.218204f} },
    { {0.271480f, -0.949773f, 0.070492f}, {0.385614f, 0.698060f, 0.603336f}, {0.333474f, 0.262082f} },
    { {0.190114f, -0.500472f, -0.347507f}, {0.703896f, 0.031901f, -0.709587f}, {0.370500f, 0.325331f} },
    { {0.190114f, -0.500472f, -0.347507f}, {0.703896f, 0.031901f, -0.709587f}, {0.323808f, 0.266644f} },
    { {-0.227622f, -0.420054f, -0.113147f}, {-0.054718f, 0.162762f, -0.985147f}, {0.400378f, 0.260117f} },
    { {0.310175f, -0.991824f, -0.081631f}, {0.059170f, 0.565516f, -0.822612f}, {0.301801f, 0.306522f} },
    { {0.300920f, -1.003402f, -0.090257f}, {0.059170f, 0.565516f, -0.822612f}, {0.303498f, 0.307462f} },
    { {0.313678f, -0.953723f, -0.055186f}, {0.059170f, 0.565516f, -0.822612f}, {0.301159f, 0.303430f} },
    { {0.300920f, -1.003402f, -0.090257f}, {0.706408f, -0.038130f, -0.706777f}, {0.329054f, 0.286406f} },
    { {-0.230624f, -0.224731f, 0.146881f}, {0.168854f, 0.642285f, 0.747635f}, {0.319228f, 0.244265f} },
    { {-0.228205f, -0.163296f, 0.093557f}, {0.171772f, 0.728986f, 0.662626f}, {0.319672f, 0.239279f} },
    { {-0.234935f, -0.162364f, 0.094276f}, {0.171772f, 0.728986f, 0.662626f}, {0.318438f, 0.239203f} },
    { {-0.230048f, -0.086380f, -0.005475f}, {0.172312f, 0.779508f, 0.602225f}, {0.319334f, 0.233037f} },
    { {0.254571f, -0.891826f, 0.268940f}, {0.660520f, 0.036948f, 0.749899f}, {0.408163f, 0.298406f} },
    { {0.254775f, -0.934285f, 0.265875f}, {0.731143f, 0.052618f, -0.680193f}, {0.334750f, 0.232519f} },
    { {0.234194f, -0.723464f, 0.260061f}, {0.731143f, 0.052618f, -0.680193f}, {0.352123f, 0.233398f} },
    { {0.254571f, -0.891826f, 0.268940f}, {0.731143f, 0.052618f, -0.680193f}, {0.338249f, 0.232055f} },
    { {0.226305f, -0.851407f, -0.153134f}, {0.750690f, 0.590331f, 0.296603f}, {0.341580f, 0.295920f} },
    { {0.208112f, -0.831801f, -0.178066f}, {0.462868f, 0.850104f, 0.251151f}, {0.343196f, 0.299692f} },
    { {-0.006589f, -1.178168f, -0.094256f}, {-0.340062f, 0.344056f, -0.875205f}, {0.359863f, 0.321646f} },
    { {-0.269121f, -1.145962f, -0.022440f}, {-0.195653f, -0.951925f, -0.235710f}, {0.312172f, 0.276144f} },
    { {-0.253953f, -1.141468f, -0.053178f}, {-0.195653f, -0.951925f, -0.235710f}, {0.314952f, 0.280795f} },
    { {-0.272500f, -1.155299f, 0.018073f}, {-0.195653f, -0.951925f, -0.235710f}, {0.311552f, 0.270014f} },
    { {0.026256f, -0.140853f, 0.303008f}, {-0.034843f, 0.011104f, 0.999331f}, {0.366314f, 0.237458f} },
    { {0.038706f, -0.065001f, 0.292348f}, {0.064253f, 0.300626f, 0.951575f}, {0.368596f, 0.231301f} },
    { {0.022202f, -0.063290f, 0.291754f}, {-0.030296f, 0.312119f, 0.949560f}, {0.365571f, 0.231163f} },
    { {0.054291f, -0.071894f, 0.292968f}, {0.153047f, 0.267503f, 0.951325f}, {0.371453f, 0.231861f} },
    { {0.067857f, -0.083502f, 0.293570f}, {0.229163f, 0.217134f, 0.948861f}, {0.373939f, 0.232803f} },
    { {0.078518f, -0.099031f, 0.294115f}, {0.286505f, 0.155480f, 0.945379f}, {0.375893f, 0.234063f} },
    { {0.085641f, -0.117418f, 0.294567f}, {0.321399f, 0.087775f, 0.942867f}, {0.377199f, 0.235556f} },
    { {0.088836f, -0.137405f, 0.294901f}, {0.332431f, 0.016975f, 0.942975f}, {0.377784f, 0.237178f} },
    { {0.087924f, -0.157627f, 0.295094f}, {0.319212f, -0.055367f, 0.946065f}, {0.377617f, 0.238819f} },
    { {0.082929f, -0.176708f, 0.295131f}, {0.282059f, -0.126758f, 0.950986f}, {0.376702f, 0.240368f} },
    { {0.074095f, -0.193353f, 0.295009f}, {0.222970f, -0.192195f, 0.955691f}, {0.375083f, 0.241718f} },
    { {0.061932f, -0.206434f, 0.294730f}, {0.146325f, -0.244993f, 0.958419f}, {0.372853f, 0.242780f} },
    { {0.047228f, -0.215060f, 0.294313f}, {0.058010f, -0.279124f, 0.958501f}, {0.370158f, 0.243480f} },
    { {0.031024f, -0.218643f, 0.293788f}, {-0.036151f, -0.290946f, 0.956056f}, {0.367188f, 0.243771f} },
    { {0.014520f, -0.216932f, 0.293193f}, {-0.130595f, -0.279484f, 0.951227f}, {0.364163f, 0.243632f} },
    { {-0.001065f, -0.210039f, 0.292573f}, {-0.219129f, -0.246443f, 0.944059f}, {0.361306f, 0.243073f} },
    { {-0.014631f, -0.198431f, 0.291971f}, {-0.294851f, -0.196200f, 0.935184f}, {0.358819f, 0.242131f} },
    { {-0.025292f, -0.182902f, 0.291427f}, {-0.351765f, -0.134684f, 0.926349f}, {0.356865f, 0.240870f} },
    { {-0.032415f, -0.164515f, 0.290974f}, {-0.386348f, -0.067078f, 0.919911f}, {0.355560f, 0.239378f} },
    { {-0.035610f, -0.144528f, 0.290641f}, {-0.397305f, 0.003699f, 0.917679f}, {0.354974f, 0.237756f} },
    { {-0.034698f, -0.124306f, 0.290448f}, {-0.384275f, 0.076104f, 0.920076f}, {0.355141f, 0.236115f} },
    { {-0.029703f, -0.105225f, 0.290410f}, {-0.347500f, 0.147613f, 0.925988f}, {0.356057f, 0.234566f} },
    { {-0.020869f, -0.088580f, 0.290533f}, {-0.288830f, 0.213186f, 0.933343f}, {0.357676f, 0.233215f} },
    { {-0.008706f, -0.075500f, 0.290812f}, {-0.212523f, 0.266088f, 0.940229f}, {0.359905f, 0.232153f} },
    { {0.005998f, -0.066873f, 0.291229f}, {-0.124409f, 0.300280f, 0.945703f}, {0.362601f, 0.231453f} },
    { {0.052337f, 0.005530f, 0.261987f}, {0.116098f, 0.508707f, 0.853076f}, {0.371094f, 0.225577f} },
    { {0.019138f, 0.008760f, 0.260794f}, {-0.041899f, 0.527861f, 0.848297f}, {0.365009f, 0.225315f} },
    { {0.083174f, -0.007745f, 0.263210f}, {0.267056f, 0.447911f, 0.853262f}, {0.376747f, 0.226654f} },
    { {0.109264f, -0.030176f, 0.264368f}, {0.397205f, 0.356132f, 0.845812f}, {0.381529f, 0.228475f} },
    { {0.129111f, -0.060219f, 0.265394f}, {0.493831f, 0.249644f, 0.832952f}, {0.385167f, 0.230913f} },
    { {0.142045f, -0.095788f, 0.266241f}, {0.551860f, 0.141231f, 0.821891f}, {0.387538f, 0.233800f} },
    { {0.147865f, -0.134420f, 0.266873f}, {0.572260f, 0.033482f, 0.819388f}, {0.388604f, 0.236935f} },
    { {0.146456f, -0.173465f, 0.267257f}, {0.555979f, -0.078165f, 0.827513f}, {0.388346f, 0.240104f} },
    { {0.137633f, -0.210279f, 0.267359f}, {0.501538f, -0.196388f, 0.842550f}, {0.386729f, 0.243092f} },
    { {0.121315f, -0.242393f, 0.267146f}, {0.408694f, -0.314164f, 0.856896f}, {0.383738f, 0.245699f} },
    { {0.097934f, -0.267656f, 0.266612f}, {0.283644f, -0.415237f, 0.864364f}, {0.379452f, 0.247749f} },
    { {0.068800f, -0.284363f, 0.265782f}, {0.137986f, -0.483225f, 0.864554f}, {0.374112f, 0.249105f} },
    { {0.036181f, -0.291360f, 0.264722f}, {-0.017687f, -0.508873f, 0.860660f}, {0.368133f, 0.249673f} },
    { {0.002982f, -0.288130f, 0.263529f}, {-0.175616f, -0.489740f, 0.853998f}, {0.362048f, 0.249411f} },
    { {-0.027855f, -0.274855f, 0.262306f}, {-0.326174f, -0.429072f, 0.842323f}, {0.356395f, 0.248333f} },
    { {-0.053945f, -0.252424f, 0.261147f}, {-0.455418f, -0.337581f, 0.823792f}, {0.351613f, 0.246513f} },
    { {-0.073792f, -0.222380f, 0.260122f}, {-0.550832f, -0.231478f, 0.801874f}, {0.347975f, 0.244074f} },
    { {-0.086726f, -0.186812f, 0.259276f}, {-0.607865f, -0.123383f, 0.784395f}, {0.345604f, 0.241188f} },
    { {-0.092546f, -0.148180f, 0.258643f}, {-0.627959f, -0.015733f, 0.778087f}, {0.344538f, 0.238052f} },
    { {-0.091137f, -0.109135f, 0.258259f}, {-0.612196f, 0.096079f, 0.784847f}, {0.344796f, 0.234883f} },
    { {-0.082314f, -0.072321f, 0.258157f}, {-0.558844f, 0.214649f, 0.801012f}, {0.346413f, 0.231895f} },
    { {-0.065996f, -0.040207f, 0.258369f}, {-0.467130f, 0.332787f, 0.819172f}, {0.349404f, 0.229289f} },
    { {-0.042615f, -0.014944f, 0.258904f}, {-0.342824f, 0.434097f, 0.833085f}, {0.353690f, 0.227239f} },
    { {-0.013481f, 0.001763f, 0.259734f}, {-0.197484f, 0.502185f, 0.841909f}, {0.359030f, 0.225883f} },
    { {0.066766f, 0.065964f, 0.214011f}, {0.158535f, 0.697480f, 0.698847f}, {0.373739f, 0.220672f} },
    { {0.017273f, 0.070386f, 0.212236f}, {-0.051466f, 0.723153f, 0.688768f}, {0.364667f, 0.220313f} },
    { {0.111781f, 0.047271f, 0.215788f}, {0.365182f, 0.607647f, 0.705271f}, {0.381990f, 0.222189f} },
    { {0.148452f, 0.015535f, 0.217420f}, {0.543866f, 0.468224f, 0.696402f}, {0.388712f, 0.224765f} },
    { {0.175078f, -0.027035f, 0.218821f}, {0.669180f, 0.314025f, 0.673488f}, {0.393592f, 0.228220f} },
    { {0.191771f, -0.077428f, 0.219963f}, {0.738328f, 0.173542f, 0.651733f}, {0.396652f, 0.232310f} },
    { {0.142045f, -0.095788f, 0.266241f}, {0.551860f, 0.141231f, 0.821891f}, {0.403849f, 0.232463f} },
    { {0.199320f, -0.132100f, 0.220834f}, {0.762703f, 0.046840f, 0.645051f}, {0.400857f, 0.239334f} },
    { {0.191771f, -0.077428f, 0.219963f}, {0.738328f, 0.173542f, 0.651733f}, {0.405362f, 0.239466f} },
    { {0.147865f, -0.134420f, 0.266873f}, {0.572260f, 0.033482f, 0.819388f}, {0.400666f, 0.232368f} },
    { {0.198009f, -0.187280f, 0.221401f}, {0.748178f, -0.085359f, 0.657985f}, {0.396310f, 0.239248f} },
    { {0.146456f, -0.173465f, 0.267257f}, {0.555979f, -0.078165f, 0.827513f}, {0.397448f, 0.232309f} },
    { {0.187129f, -0.239251f, 0.221599f}, {0.688180f, -0.240190f, 0.684630f}, {0.392027f, 0.239218f} },
    { {0.187129f, -0.239251f, 0.221599f}, {0.688180f, -0.240190f, 0.684630f}, {0.395801f, 0.245444f} },
    { {0.165495f, -0.284584f, 0.221348f}, {0.571939f, -0.411536f, 0.709594f}, {0.391836f, 0.249123f} },
    { {0.132654f, -0.320298f, 0.220600f}, {0.404175f, -0.565635f, 0.718818f}, {0.385816f, 0.252021f} },
    { {0.090047f, -0.344006f, 0.219378f}, {0.208282f, -0.668477f, 0.713972f}, {0.378007f, 0.253945f} },
    { {0.041376f, -0.354047f, 0.217793f}, {0.002816f, -0.707649f, 0.706558f}, {0.369085f, 0.254760f} },
    { {-0.008118f, -0.349625f, 0.216018f}, {-0.207357f, -0.681922f, 0.701417f}, {0.360013f, 0.254402f} },
    { {-0.053133f, -0.330932f, 0.214241f}, {-0.413880f, -0.592128f, 0.691439f}, {0.351762f, 0.252884f} },
    { {-0.089804f, -0.299196f, 0.212609f}, {-0.591405f, -0.453075f, 0.667055f}, {0.345040f, 0.250309f} },
    { {-0.116430f, -0.256626f, 0.211208f}, {-0.714700f, -0.299519f, 0.632054f}, {0.340160f, 0.246854f} },
    { {-0.073792f, -0.222380f, 0.260122f}, {-0.550832f, -0.231478f, 0.801874f}, {0.326739f, 0.233389f} },
    { {-0.133123f, -0.206233f, 0.210066f}, {-0.782055f, -0.159606f, 0.602425f}, {0.325409f, 0.240963f} },
    { {-0.116430f, -0.256626f, 0.211208f}, {-0.714700f, -0.299519f, 0.632054f}, {0.329562f, 0.240790f} },
    { {-0.086726f, -0.186812f, 0.259276f}, {-0.607865f, -0.123383f, 0.784395f}, {0.323808f, 0.233517f} },
    { {-0.140672f, -0.151561f, 0.209196f}, {-0.805808f, -0.033104f, 0.591251f}, {0.320903f, 0.241095f} },
    { {-0.092546f, -0.148180f, 0.258643f}, {-0.627959f, -0.015733f, 0.778087f}, {0.320625f, 0.233613f} },
    { {-0.139361f, -0.096381f, 0.208628f}, {-0.792117f, 0.099361f, 0.602228f}, {0.316356f, 0.241181f} },
    { {-0.091137f, -0.109135f, 0.258259f}, {-0.612196f, 0.096079f, 0.784847f}, {0.317407f, 0.233671f} },
    { {-0.128481f, -0.044410f, 0.208430f}, {-0.734000f, 0.254792f, 0.629543f}, {0.312073f, 0.241211f} },
    { {-0.082314f, -0.072321f, 0.258157f}, {-0.558844f, 0.214649f, 0.801012f}, {0.314373f, 0.233686f} },
    { {-0.106847f, 0.000923f, 0.208681f}, {-0.619649f, 0.426740f, 0.658732f}, {0.308337f, 0.241173f} },
    { {-0.106847f, 0.000923f, 0.208681f}, {-0.619649f, 0.426740f, 0.658732f}, {0.341916f, 0.225951f} },
    { {-0.074006f, 0.036637f, 0.209429f}, {-0.452814f, 0.581136f, 0.676195f}, {0.347936f, 0.223052f} },
    { {-0.031399f, 0.060345f, 0.210651f}, {-0.256979f, 0.683996f, 0.682723f}, {0.355746f, 0.221128f} },
    { {0.080463f, 0.112152f, 0.151672f}, {0.188897f, 0.846849f, 0.497157f}, {0.376250f, 0.216924f} },
    { {0.016733f, 0.117389f, 0.149392f}, {-0.057420f, 0.874035f, 0.482459f}, {0.364568f, 0.216499f} },
    { {0.137317f, 0.089356f, 0.153907f}, {0.441605f, 0.736437f, 0.512490f}, {0.386671f, 0.218774f} },
    { {0.181953f, 0.050472f, 0.155896f}, {0.661630f, 0.551174f, 0.508383f}, {0.394853f, 0.221930f} },
    { {0.148452f, 0.015535f, 0.217420f}, {0.543866f, 0.468224f, 0.696402f}, {0.413023f, 0.239850f} },
    { {0.212796f, -0.001767f, 0.157551f}, {0.775547f, 0.371281f, 0.510566f}, {0.411598f, 0.248909f} },
    { {0.181953f, 0.050472f, 0.155896f}, {0.661630f, 0.551174f, 0.508383f}, {0.415902f, 0.249160f} },
    { {0.175078f, -0.027035f, 0.218821f}, {0.669180f, 0.314025f, 0.673488f}, {0.409515f, 0.239638f} },
    { {0.231284f, -0.063598f, 0.158883f}, {0.857940f, 0.212270f, 0.467845f}, {0.406502f, 0.248708f} },
    { {0.239695f, -0.130605f, 0.159921f}, {0.857985f, 0.072700f, 0.508505f}, {0.400980f, 0.248551f} },
    { {0.238924f, -0.198138f, 0.160644f}, {0.871774f, -0.073629f, 0.484344f}, {0.395415f, 0.248441f} },
    { {0.227556f, -0.261678f, 0.160954f}, {0.829651f, -0.259684f, 0.494209f}, {0.390179f, 0.248394f} },
    { {0.202827f, -0.317097f, 0.160708f}, {0.704713f, -0.480934f, 0.521615f}, {0.385612f, 0.248432f} },
    { {0.165495f, -0.284584f, 0.221348f}, {0.571939f, -0.411536f, 0.709594f}, {0.388291f, 0.239256f} },
    { {0.162882f, -0.360823f, 0.159801f}, {0.501321f, -0.685216f, 0.528353f}, {0.382008f, 0.248569f} },
    { {0.132654f, -0.320298f, 0.220600f}, {0.404175f, -0.565635f, 0.718818f}, {0.385348f, 0.239369f} },
    { {0.108978f, -0.389958f, 0.158245f}, {0.263467f, -0.814954f, 0.516173f}, {0.381476f, 0.257675f} },
    { {0.162882f, -0.360823f, 0.159801f}, {0.501321f, -0.685216f, 0.528353f}, {0.391357f, 0.255310f} },
    { {0.046253f, -0.402433f, 0.156197f}, {0.023005f, -0.863068f, 0.504564f}, {0.369979f, 0.258687f} },
    { {-0.017476f, -0.397195f, 0.153916f}, {-0.223716f, -0.835754f, 0.501465f}, {0.358298f, 0.258262f} },
    { {-0.074330f, -0.374400f, 0.151681f}, {-0.476791f, -0.725224f, 0.496709f}, {0.347877f, 0.256412f} },
    { {-0.053133f, -0.330932f, 0.214241f}, {-0.413880f, -0.592128f, 0.691439f}, {0.335685f, 0.240331f} },
    { {-0.118966f, -0.335516f, 0.149692f}, {-0.695854f, -0.540267f, 0.473180f}, {0.336063f, 0.250098f} },
    { {-0.074330f, -0.374400f, 0.151681f}, {-0.476791f, -0.725224f, 0.496709f}, {0.339267f, 0.249797f} },
    { {-0.089804f, -0.299196f, 0.212609f}, {-0.591405f, -0.453075f, 0.667055f}, {0.333070f, 0.240578f} },
    { {-0.149809f, -0.283277f, 0.148037f}, {-0.834649f, -0.339832f, 0.433446f}, {0.331758f, 0.250349f} },
    { {-0.168297f, -0.221446f, 0.146705f}, {-0.899679f, -0.176504f, 0.399279f}, {0.326662f, 0.250550f} },
    { {-0.176708f, -0.154439f, 0.145667f}, {-0.921420f, -0.045719f, 0.385869f}, {0.321140f, 0.250707f} },
    { {-0.175937f, -0.086906f, 0.144944f}, {-0.913366f, 0.090861f, 0.396871f}, {0.315575f, 0.250817f} },
    { {-0.164569f, -0.023366f, 0.144634f}, {-0.862757f, 0.270330f, 0.427285f}, {0.310339f, 0.250864f} },
    { {-0.139840f, 0.032054f, 0.144881f}, {-0.738954f, 0.491846f, 0.460472f}, {0.305772f, 0.250826f} },
    { {-0.099895f, 0.075779f, 0.145787f}, {-0.536367f, 0.696384f, 0.476822f}, {0.302169f, 0.250689f} },
    { {-0.074006f, 0.036637f, 0.209429f}, {-0.452814f, 0.581136f, 0.676195f}, {0.305394f, 0.241059f} },
    { {-0.045991f, 0.104914f, 0.147343f}, {-0.298142f, 0.826005f, 0.478359f}, {0.353071f, 0.217511f} },
    { {-0.099895f, 0.075779f, 0.145787f}, {-0.536367f, 0.696384f, 0.476822f}, {0.343191f, 0.219876f} },
    { {0.016733f, 0.117389f, 0.149392f}, {-0.057420f, 0.874035f, 0.482459f}, {0.355588f, 0.250144f} },
    { {0.091181f, 0.140870f, 0.079172f}, {0.208151f, 0.943548f, 0.257664f}, {0.341942f, 0.260769f} },
    { {0.017557f, 0.146566f, 0.076542f}, {-0.059164f, 0.968190f, 0.243120f}, {0.355437f, 0.261167f} },
    { {0.080463f, 0.112152f, 0.151672f}, {0.188897f, 0.846849f, 0.497157f}, {0.343907f, 0.249799f} },
    { {0.155998f, 0.115525f, 0.081714f}, {0.493216f, 0.824973f, 0.275966f}, {0.330061f, 0.260384f} },
    { {0.137317f, 0.089356f, 0.153907f}, {0.441605f, 0.736437f, 0.512490f}, {0.333486f, 0.249461f} },
    { {0.137317f, 0.089356f, 0.153907f}, {0.441605f, 0.736437f, 0.512490f}, {0.419107f, 0.249461f} },
    { {0.205557f, 0.072143f, 0.083923f}, {0.744137f, 0.606304f, 0.280457f}, {0.417688f, 0.260050f} },
    { {0.155998f, 0.115525f, 0.081714f}, {0.493216f, 0.824973f, 0.275966f}, {0.421263f, 0.260384f} },
    { {0.238516f, 0.013795f, 0.085721f}, {0.867960f, 0.385966f, 0.312532f}, {0.412880f, 0.259778f} },
    { {0.250011f, -0.041898f, 0.096808f}, {0.897665f, 0.255499f, 0.359050f}, {0.408290f, 0.258100f} },
    { {0.250258f, -0.057597f, 0.107114f}, {0.916657f, 0.180005f, 0.356844f}, {0.406997f, 0.256541f} },
    { {0.247805f, -0.113940f, 0.132320f}, {0.929309f, 0.120201f, 0.349195f}, {0.402353f, 0.252727f} },
    { {0.249141f, -0.130404f, 0.134366f}, {0.937185f, 0.014149f, 0.348547f}, {0.400997f, 0.252417f} },
    { {0.251568f, -0.270120f, 0.099398f}, {0.914046f, -0.154862f, 0.374884f}, {0.389483f, 0.257709f} },
    { {0.253261f, -0.275222f, 0.093951f}, {0.850471f, -0.345578f, 0.396580f}, {0.389062f, 0.258533f} },
    { {0.228839f, -0.337828f, 0.089290f}, {0.801491f, -0.522127f, 0.291540f}, {0.383903f, 0.259238f} },
    { {0.184512f, -0.386584f, 0.088287f}, {0.571867f, -0.765665f, 0.294493f}, {0.379885f, 0.259390f} },
    { {0.122984f, -0.419160f, 0.086503f}, {0.303048f, -0.910737f, 0.280570f}, {0.377201f, 0.259660f} },
    { {0.108978f, -0.389958f, 0.158245f}, {0.263467f, -0.814954f, 0.516173f}, {0.379607f, 0.248804f} },
    { {0.108978f, -0.389958f, 0.158245f}, {0.263467f, -0.814954f, 0.516173f}, {0.381476f, 0.248804f} },
    { {0.050482f, -0.433220f, 0.084132f}, {0.041341f, -0.962510f, 0.268076f}, {0.370754f, 0.260018f} },
    { {0.122984f, -0.419160f, 0.086503f}, {0.303048f, -0.910737f, 0.280570f}, {0.384044f, 0.259660f} },
    { {0.046253f, -0.402433f, 0.156197f}, {0.023005f, -0.863068f, 0.504564f}, {0.369979f, 0.249114f} },
    { {-0.023141f, -0.427524f, 0.081501f}, {-0.226320f, -0.937758f, 0.263419f}, {0.357259f, 0.260417f} },
    { {-0.017476f, -0.397195f, 0.153916f}, {-0.223716f, -0.835754f, 0.501465f}, {0.358298f, 0.249459f} },
    { {-0.087958f, -0.402179f, 0.078960f}, {-0.511875f, -0.819027f, 0.259188f}, {0.345379f, 0.260801f} },
    { {-0.074330f, -0.374400f, 0.151681f}, {-0.476791f, -0.725224f, 0.496709f}, {0.347877f, 0.249797f} },
    { {-0.137518f, -0.358797f, 0.076750f}, {-0.762330f, -0.600507f, 0.241340f}, {0.337981f, 0.261135f} },
    { {-0.087958f, -0.402179f, 0.078960f}, {-0.511875f, -0.819027f, 0.259188f}, {0.341556f, 0.260801f} },
    { {-0.170476f, -0.300449f, 0.074953f}, {-0.907860f, -0.362065f, 0.211423f}, {0.333173f, 0.261407f} },
    { {-0.189498f, -0.231394f, 0.073522f}, {-0.965359f, -0.182626f, 0.186360f}, {0.327482f, 0.261624f} },
    { {-0.198199f, -0.156618f, 0.072388f}, {-0.982981f, -0.053385f, 0.175780f}, {0.321320f, 0.261795f} },
    { {-0.198020f, -0.081334f, 0.071558f}, {-0.980185f, 0.079625f, 0.181378f}, {0.315116f, 0.261921f} },
    { {-0.186939f, -0.010556f, 0.071158f}, {-0.941381f, 0.270937f, 0.200983f}, {0.309283f, 0.261982f} },
    { {-0.160800f, 0.051174f, 0.071383f}, {-0.818362f, 0.528998f, 0.224601f}, {0.304196f, 0.261948f} },
    { {-0.116473f, 0.099930f, 0.072387f}, {-0.590394f, 0.771569f, 0.236889f}, {0.300178f, 0.261796f} },
    { {-0.054945f, 0.132506f, 0.074170f}, {-0.321145f, 0.916505f, 0.238505f}, {0.297494f, 0.261526f} },
    { {-0.045991f, 0.104914f, 0.147343f}, {-0.298142f, 0.826005f, 0.478359f}, {0.299768f, 0.250454f} },
    { {-0.045991f, 0.104914f, 0.147343f}, {-0.298142f, 0.826005f, 0.478359f}, {0.367085f, 0.250454f} },
    { {-0.054945f, 0.132506f, 0.074170f}, {-0.321145f, 0.916505f, 0.238505f}, {0.368727f, 0.261526f} },
    { {0.096872f, 0.150087f, 0.001408f}, {0.217065f, 0.976152f, -0.003125f}, {0.340899f, 0.272536f} },
    { {0.019687f, 0.155928f, -0.001348f}, {-0.056692f, 0.998306f, -0.013069f}, {0.355047f, 0.272953f} },
    { {0.164508f, 0.123878f, 0.004057f}, {0.513698f, 0.857922f, 0.009146f}, {0.328502f, 0.272135f} },
    { {0.215730f, 0.078961f, 0.006342f}, {0.777635f, 0.628337f, 0.021822f}, {0.418250f, 0.271789f} },
    { {0.164508f, 0.123878f, 0.004057f}, {0.513698f, 0.857922f, 0.009146f}, {0.421952f, 0.272135f} },
    { {0.249304f, 0.018524f, 0.008184f}, {0.894554f, 0.441182f, 0.071629f}, {0.413270f, 0.271510f} },
    { {0.251335f, -0.032668f, 0.086676f}, {0.938524f, 0.263532f, 0.222987f}, {0.409051f, 0.259633f} },
    { {0.249601f, -0.016630f, 0.068674f}, {0.953520f, 0.263017f, 0.147040f}, {0.410373f, 0.262357f} },
    { {0.248415f, -0.312873f, 0.039506f}, {0.909447f, -0.381411f, 0.165627f}, {0.385960f, 0.266771f} },
    { {0.239833f, -0.345472f, 0.011898f}, {0.814889f, -0.579600f, -0.004371f}, {0.383273f, 0.270948f} },
    { {0.251463f, -0.317436f, 0.011992f}, {0.917776f, -0.381075f, 0.111667f}, {0.385584f, 0.270934f} },
    { {0.194028f, -0.395943f, 0.010862f}, {0.607547f, -0.793745f, 0.029234f}, {0.379114f, 0.271105f} },
    { {0.129797f, -0.429699f, 0.008997f}, {0.326179f, -0.945059f, 0.021720f}, {0.376332f, 0.271387f} },
    { {0.053774f, -0.444310f, 0.006509f}, {0.056693f, -0.998306f, 0.013068f}, {0.371358f, 0.271764f} },
    { {0.129797f, -0.429699f, 0.008997f}, {0.326179f, -0.945059f, 0.021720f}, {0.385293f, 0.271387f} },
    { {-0.023410f, -0.438468f, 0.003753f}, {-0.217075f, -0.976149f, 0.003430f}, {0.357210f, 0.272181f} },
    { {-0.091046f, -0.412260f, 0.001104f}, {-0.513752f, -0.857905f, -0.007612f}, {0.344813f, 0.272582f} },
    { {-0.142268f, -0.367342f, -0.001181f}, {-0.777753f, -0.628299f, -0.018446f}, {0.338686f, 0.272927f} },
    { {-0.091046f, -0.412260f, 0.001104f}, {-0.513752f, -0.857905f, -0.007612f}, {0.342387f, 0.272582f} },
    { {-0.175843f, -0.306905f, -0.003023f}, {-0.927299f, -0.373408f, -0.026143f}, {0.333705f, 0.273206f} },
    { {-0.194930f, -0.235379f, -0.004483f}, {-0.982075f, -0.185955f, -0.030815f}, {0.327811f, 0.273427f} },
    { {-0.203680f, -0.157951f, -0.005649f}, {-0.997783f, -0.057111f, -0.034155f}, {0.321430f, 0.273603f} },
    { {-0.203753f, -0.080026f, -0.006517f}, {-0.996670f, 0.072698f, -0.036919f}, {0.315008f, 0.273735f} },
    { {-0.192886f, -0.006786f, -0.006952f}, {-0.963424f, 0.265189f, -0.038577f}, {0.308973f, 0.273801f} },
    { {-0.166371f, 0.057090f, -0.006737f}, {-0.843728f, 0.535490f, -0.037058f}, {0.303709f, 0.273768f} },
    { {-0.120566f, 0.107562f, -0.005701f}, {-0.607494f, 0.793728f, -0.030769f}, {0.299549f, 0.273611f} },
    { {-0.056335f, 0.141318f, -0.003837f}, {-0.326168f, 0.945055f, -0.022025f}, {0.296768f, 0.273329f} },
    { {-0.056335f, 0.141318f, -0.003837f}, {-0.326168f, 0.945055f, -0.022025f}, {0.368982f, 0.273329f} },
    { {0.096603f, 0.139142f, -0.076341f}, {0.215693f, 0.940428f, -0.262813f}, {0.340948f, 0.284300f} },
    { {0.022979f, 0.144838f, -0.078971f}, {-0.050449f, 0.961989f, -0.268388f}, {0.354443f, 0.284698f} },
    { {0.161420f, 0.113798f, -0.073799f}, {0.499613f, 0.826993f, -0.257816f}, {0.329068f, 0.283915f} },
    { {0.210979f, 0.070415f, -0.071589f}, {0.753555f, 0.612189f, -0.239540f}, {0.417546f, 0.283581f} },
    { {0.161420f, 0.113798f, -0.073799f}, {0.499613f, 0.826993f, -0.257816f}, {0.421121f, 0.283915f} },
    { {0.243938f, 0.012067f, -0.069792f}, {0.887833f, 0.420661f, -0.186540f}, {0.412738f, 0.283309f} },
    { {0.253324f, 0.003301f, 0.008490f}, {0.961748f, 0.255910f, 0.097733f}, {0.412015f, 0.271464f} },
    { {0.252392f, 0.004280f, 0.001332f}, {0.962645f, 0.256556f, -0.086565f}, {0.412096f, 0.272547f} },
    { {0.253326f, -0.294579f, -0.066066f}, {0.865594f, -0.374813f, -0.332057f}, {0.387467f, 0.282745f} },
    { {0.252224f, -0.297862f, -0.062525f}, {0.917857f, -0.385833f, -0.093119f}, {0.387197f, 0.282209f} },
    { {0.234261f, -0.339555f, -0.066222f}, {0.785123f, -0.562313f, -0.259587f}, {0.383761f, 0.282769f} },
    { {0.189934f, -0.388312f, -0.067226f}, {0.601677f, -0.762305f, -0.238487f}, {0.379743f, 0.282921f} },
    { {0.128406f, -0.420888f, -0.069009f}, {0.331403f, -0.912665f, -0.239195f}, {0.377058f, 0.283191f} },
    { {0.055905f, -0.434948f, -0.071381f}, {0.068272f, -0.967669f, -0.242809f}, {0.371748f, 0.283549f} },
    { {0.128406f, -0.420888f, -0.069009f}, {0.331403f, -0.912665f, -0.239195f}, {0.385038f, 0.283191f} },
    { {-0.017719f, -0.429252f, -0.074011f}, {-0.197594f, -0.946196f, -0.256261f}, {0.358253f, 0.283947f} },
    { {-0.082536f, -0.403907f, -0.076553f}, {-0.481087f, -0.832897f, -0.273566f}, {0.346372f, 0.284332f} },
    { {-0.132096f, -0.360525f, -0.078763f}, {-0.735517f, -0.617937f, -0.277791f}, {0.338124f, 0.284666f} },
    { {-0.082536f, -0.403907f, -0.076553f}, {-0.481087f, -0.832897f, -0.273566f}, {0.341699f, 0.284332f} },
    { {-0.165054f, -0.302177f, -0.080560f}, {-0.888468f, -0.375672f, -0.263620f}, {0.333315f, 0.284938f} },
    { {-0.184076f, -0.233122f, -0.081991f}, {-0.950067f, -0.190106f, -0.247451f}, {0.327625f, 0.285155f} },
    { {-0.192777f, -0.158346f, -0.083125f}, {-0.968379f, -0.058305f, -0.242576f}, {0.321462f, 0.285326f} },
    { {-0.192598f, -0.083062f, -0.083955f}, {-0.964921f, 0.072142f, -0.252436f}, {0.315258f, 0.285452f} },
    { {-0.181517f, -0.012284f, -0.084355f}, {-0.926672f, 0.257063f, -0.274221f}, {0.309426f, 0.285513f} },
    { {-0.155377f, 0.049446f, -0.084130f}, {-0.807567f, 0.510650f, -0.295079f}, {0.304339f, 0.285479f} },
    { {-0.111050f, 0.098202f, -0.083126f}, {-0.583018f, 0.756359f, -0.296666f}, {0.300321f, 0.285327f} },
    { {-0.049523f, 0.130778f, -0.081342f}, {-0.313235f, 0.906875f, -0.281888f}, {0.297636f, 0.285057f} },
    { {-0.049523f, 0.130778f, -0.081342f}, {-0.313235f, 0.906875f, -0.281888f}, {0.367733f, 0.285057f} },
    { {0.090938f, 0.108814f, -0.148755f}, {0.203437f, 0.841679f, -0.500190f}, {0.341987f, 0.295257f} },
    { {0.027208f, 0.114051f, -0.151036f}, {-0.041170f, 0.862028f, -0.505185f}, {0.353668f, 0.295602f} },
    { {0.147791f, 0.086018f, -0.146520f}, {0.454800f, 0.739941f, -0.495625f}, {0.331566f, 0.294919f} },
    { {0.192428f, 0.047134f, -0.144532f}, {0.679213f, 0.560146f, -0.474243f}, {0.415627f, 0.294618f} },
    { {0.147791f, 0.086018f, -0.146520f}, {0.454800f, 0.739941f, -0.495625f}, {0.418832f, 0.294919f} },
    { {0.223271f, -0.005105f, -0.142876f}, {0.838653f, 0.344280f, -0.422057f}, {0.411323f, 0.294367f} },
    { {0.253183f, -0.021487f, -0.069096f}, {0.916730f, 0.252345f, -0.309723f}, {0.409972f, 0.283204f} },
    { {0.251395f, -0.044306f, -0.093209f}, {0.914386f, 0.262159f, -0.308497f}, {0.408092f, 0.286852f} },
    { {0.241758f, -0.066936f, -0.141544f}, {0.880820f, 0.169452f, -0.442088f}, {0.406227f, 0.294166f} },
    { {0.252601f, -0.061850f, -0.104131f}, {0.936673f, 0.185969f, -0.296747f}, {0.406646f, 0.288505f} },
    { {0.251440f, -0.078019f, -0.114194f}, {0.951024f, 0.113214f, -0.287637f}, {0.405314f, 0.290028f} },
    { {0.253565f, -0.133598f, -0.128746f}, {0.959802f, 0.037384f, -0.278179f}, {0.400734f, 0.292230f} },
    { {0.252511f, -0.158914f, -0.131266f}, {0.958250f, -0.012429f, -0.285662f}, {0.398647f, 0.292611f} },
    { {0.250170f, -0.133943f, -0.140506f}, {0.888731f, 0.033792f, -0.457182f}, {0.400705f, 0.294009f} },
    { {0.249399f, -0.201476f, -0.139783f}, {0.875627f, -0.111875f, -0.469852f}, {0.395140f, 0.293900f} },
    { {0.253669f, -0.202633f, -0.125446f}, {0.943203f, -0.155652f, -0.293497f}, {0.395044f, 0.291730f} },
    { {0.251483f, -0.239457f, -0.112399f}, {0.937449f, -0.165559f, -0.306234f}, {0.392010f, 0.289756f} },
    { {0.238031f, -0.265016f, -0.139473f}, {0.840140f, -0.288992f, -0.458965f}, {0.389904f, 0.293853f} },
    { {0.213301f, -0.320435f, -0.139720f}, {0.745886f, -0.475309f, -0.466622f}, {0.385337f, 0.293890f} },
    { {0.173357f, -0.364161f, -0.140627f}, {0.556553f, -0.679305f, -0.478323f}, {0.381733f, 0.294027f} },
    { {0.119452f, -0.393296f, -0.142182f}, {0.317622f, -0.817857f, -0.479818f}, {0.379332f, 0.294263f} },
    { {0.056728f, -0.405771f, -0.144231f}, {0.075583f, -0.872995f, -0.481837f}, {0.371899f, 0.294573f} },
    { {0.119452f, -0.393296f, -0.142182f}, {0.317622f, -0.817857f, -0.479818f}, {0.383396f, 0.294263f} },
    { {-0.007002f, -0.400533f, -0.146511f}, {-0.168761f, -0.852729f, -0.494341f}, {0.360218f, 0.294918f} },
    { {-0.063855f, -0.377738f, -0.148746f}, {-0.419753f, -0.751110f, -0.509550f}, {0.349797f, 0.295256f} },
    { {-0.108491f, -0.338854f, -0.150735f}, {-0.644972f, -0.571057f, -0.507844f}, {0.336338f, 0.295557f} },
    { {-0.063855f, -0.377738f, -0.148746f}, {-0.419753f, -0.751110f, -0.509550f}, {0.339542f, 0.295256f} },
    { {-0.139334f, -0.286615f, -0.152391f}, {-0.795185f, -0.365225f, -0.484036f}, {0.332033f, 0.295807f} },
    { {-0.157822f, -0.224784f, -0.153722f}, {-0.867872f, -0.192814f, -0.457843f}, {0.326937f, 0.296009f} },
    { {-0.166234f, -0.157777f, -0.154760f}, {-0.892171f, -0.058084f, -0.447949f}, {0.321416f, 0.296166f} },
    { {-0.165462f, -0.090244f, -0.155483f}, {-0.884613f, 0.074376f, -0.460356f}, {0.315850f, 0.296275f} },
    { {-0.154094f, -0.026704f, -0.155793f}, {-0.836444f, 0.244184f, -0.490648f}, {0.310614f, 0.296322f} },
    { {-0.129365f, 0.028716f, -0.155547f}, {-0.719013f, 0.459284f, -0.521612f}, {0.306047f, 0.296285f} },
    { {-0.089420f, 0.072441f, -0.154640f}, {-0.521366f, 0.668092f, -0.530877f}, {0.302444f, 0.296148f} },
    { {-0.035516f, 0.101576f, -0.153084f}, {-0.282804f, 0.806762f, -0.518804f}, {0.300043f, 0.295912f} },
    { {-0.035516f, 0.101576f, -0.153084f}, {-0.282804f, 0.806762f, -0.518804f}, {0.365165f, 0.295912f} },
    { {0.027208f, 0.114051f, -0.151036f}, {-0.041170f, 0.862028f, -0.505185f}, {0.353668f, 0.216770f} },
    { {0.081579f, 0.061244f, -0.210857f}, {0.178916f, 0.690639f, -0.700719f}, {0.343702f, 0.221055f} },
    { {0.032086f, 0.065665f, -0.212632f}, {-0.029701f, 0.706110f, -0.707479f}, {0.352774f, 0.220697f} },
    { {0.090938f, 0.108814f, -0.148755f}, {0.203437f, 0.841679f, -0.500190f}, {0.341987f, 0.217195f} },
    { {0.126594f, 0.042551f, -0.209080f}, {0.385125f, 0.610813f, -0.691800f}, {0.335451f, 0.222573f} },
    { {0.147791f, 0.086018f, -0.146520f}, {0.454800f, 0.739941f, -0.495625f}, {0.331566f, 0.219045f} },
    { {0.163265f, 0.010815f, -0.207449f}, {0.568337f, 0.476802f, -0.670561f}, {0.412634f, 0.304138f} },
    { {0.126594f, 0.042551f, -0.209080f}, {0.385125f, 0.610813f, -0.691800f}, {0.415250f, 0.304385f} },
    { {0.189891f, -0.031756f, -0.206047f}, {0.701374f, 0.319724f, -0.637065f}, {0.409126f, 0.303926f} },
    { {0.206584f, -0.082149f, -0.204905f}, {0.776670f, 0.172637f, -0.605789f}, {0.404973f, 0.303753f} },
    { {0.214134f, -0.136821f, -0.204035f}, {0.805251f, 0.042904f, -0.591379f}, {0.400468f, 0.303622f} },
    { {0.212823f, -0.192000f, -0.203467f}, {0.795987f, -0.085722f, -0.599213f}, {0.395921f, 0.303536f} },
    { {0.201943f, -0.243972f, -0.203269f}, {0.744946f, -0.233083f, -0.625083f}, {0.391638f, 0.303506f} },
    { {0.180309f, -0.289304f, -0.203520f}, {0.639876f, -0.400471f, -0.655882f}, {0.387902f, 0.303544f} },
    { {0.147468f, -0.325019f, -0.204268f}, {0.479269f, -0.559313f, -0.676365f}, {0.384959f, 0.303657f} },
    { {0.173357f, -0.364161f, -0.140627f}, {0.556553f, -0.679305f, -0.478323f}, {0.326880f, 0.255581f} },
    { {0.104861f, -0.348727f, -0.205490f}, {0.284252f, -0.672137f, -0.683691f}, {0.339435f, 0.254329f} },
    { {0.147468f, -0.325019f, -0.204268f}, {0.479269f, -0.559313f, -0.676365f}, {0.331625f, 0.252404f} },
    { {0.119452f, -0.393296f, -0.142182f}, {0.317622f, -0.817857f, -0.479818f}, {0.336760f, 0.257946f} },
    { {0.056189f, -0.358767f, -0.207075f}, {0.078350f, -0.721614f, -0.687848f}, {0.348356f, 0.255143f} },
    { {0.056728f, -0.405771f, -0.144231f}, {0.075583f, -0.872995f, -0.481837f}, {0.348257f, 0.258958f} },
    { {0.006696f, -0.354346f, -0.208850f}, {-0.130218f, -0.706158f, -0.695977f}, {0.357428f, 0.254785f} },
    { {-0.007002f, -0.400533f, -0.146511f}, {-0.168761f, -0.852729f, -0.494341f}, {0.359939f, 0.258533f} },
    { {-0.038319f, -0.335653f, -0.210627f}, {-0.336485f, -0.626313f, -0.703214f}, {0.365679f, 0.253267f} },
    { {-0.063855f, -0.377738f, -0.148746f}, {-0.419753f, -0.751110f, -0.509550f}, {0.370360f, 0.256683f} },
    { {-0.074990f, -0.303917f, -0.212259f}, {-0.520629f, -0.492005f, -0.697765f}, {0.372401f, 0.250692f} },
    { {-0.108491f, -0.338854f, -0.150735f}, {-0.644972f, -0.571057f, -0.507844f}, {0.378542f, 0.253527f} },
    { {-0.101616f, -0.261347f, -0.213660f}, {-0.655554f, -0.334325f, -0.677108f}, {0.329951f, 0.305078f} },
    { {-0.074990f, -0.303917f, -0.212259f}, {-0.520629f, -0.492005f, -0.697765f}, {0.333459f, 0.304866f} },
    { {-0.118309f, -0.210953f, -0.214802f}, {-0.732731f, -0.186639f, -0.654424f}, {0.325798f, 0.305251f} },
    { {-0.125858f, -0.156281f, -0.215673f}, {-0.762146f, -0.056641f, -0.644922f}, {0.321292f, 0.305383f} },
    { {-0.124547f, -0.101102f, -0.216240f}, {-0.752260f, 0.071787f, -0.654944f}, {0.316745f, 0.305468f} },
    { {-0.113668f, -0.049130f, -0.216438f}, {-0.699427f, 0.218578f, -0.680460f}, {0.312462f, 0.305498f} },
    { {-0.092033f, -0.003798f, -0.216188f}, {-0.592338f, 0.385322f, -0.707575f}, {0.308726f, 0.305460f} },
    { {-0.059193f, 0.031917f, -0.215439f}, {-0.430571f, 0.543794f, -0.720345f}, {0.305783f, 0.305347f} },
    { {-0.089420f, 0.072441f, -0.154640f}, {-0.521366f, 0.668092f, -0.530877f}, {0.375046f, 0.220147f} },
    { {-0.016586f, 0.055625f, -0.214217f}, {-0.235430f, 0.656578f, -0.716573f}, {0.361696f, 0.221511f} },
    { {-0.059193f, 0.031917f, -0.215439f}, {-0.430571f, 0.543794f, -0.720345f}, {0.369505f, 0.223436f} },
    { {-0.035516f, 0.101576f, -0.153084f}, {-0.282804f, 0.806762f, -0.518804f}, {0.365165f, 0.217782f} },
    { {0.070480f, -0.000252f, -0.258368f}, {0.140619f, 0.499171f, -0.855018f}, {0.345737f, 0.226046f} },
    { {0.037281f, 0.002978f, -0.259562f}, {-0.016865f, 0.506895f, -0.861843f}, {0.351822f, 0.225784f} },
    { {0.101316f, -0.013526f, -0.257145f}, {0.292720f, 0.448226f, -0.844635f}, {0.340084f, 0.227124f} },
    { {0.127406f, -0.035958f, -0.255987f}, {0.427672f, 0.362036f, -0.828267f}, {0.335302f, 0.228944f} },
    { {0.163265f, 0.010815f, -0.207449f}, {0.568337f, 0.476802f, -0.670561f}, {0.328729f, 0.225148f} },
    { {0.147254f, -0.066001f, -0.254961f}, {0.532142f, 0.255552f, -0.807167f}, {0.331664f, 0.231383f} },
    { {0.189891f, -0.031756f, -0.206047f}, {0.701374f, 0.319724f, -0.637065f}, {0.323849f, 0.228603f} },
    { {0.160188f, -0.101570f, -0.254115f}, {0.598547f, 0.144247f, -0.787994f}, {0.403373f, 0.311199f} },
    { {0.147254f, -0.066001f, -0.254961f}, {0.532142f, 0.255552f, -0.807167f}, {0.406304f, 0.311327f} },
    { {0.166008f, -0.140201f, -0.253482f}, {0.626856f, 0.035151f, -0.778342f}, {0.400189f, 0.311104f} },
    { {0.164599f, -0.179247f, -0.253098f}, {0.619086f, -0.074210f, -0.781809f}, {0.396972f, 0.311045f} },
    { {0.155776f, -0.216061f, -0.252996f}, {0.574681f, -0.188484f, -0.796376f}, {0.393938f, 0.311030f} },
    { {0.201943f, -0.243972f, -0.203269f}, {0.744946f, -0.233083f, -0.625083f}, {0.321640f, 0.245827f} },
    { {0.139458f, -0.248174f, -0.253208f}, {0.491923f, -0.305240f, -0.815377f}, {0.333093f, 0.246168f} },
    { {0.155776f, -0.216061f, -0.252996f}, {0.574681f, -0.188484f, -0.796376f}, {0.330102f, 0.243561f} },
    { {0.180309f, -0.289304f, -0.203520f}, {0.639876f, -0.400471f, -0.655882f}, {0.325605f, 0.249506f} },
    { {0.116076f, -0.273437f, -0.253743f}, {0.373894f, -0.411226f, -0.831322f}, {0.337379f, 0.248218f} },
    { {0.086943f, -0.290144f, -0.254573f}, {0.231188f, -0.488830f, -0.841188f}, {0.342719f, 0.249574f} },
    { {0.054324f, -0.297141f, -0.255633f}, {0.076449f, -0.525883f, -0.847114f}, {0.348698f, 0.250142f} },
    { {0.021125f, -0.293912f, -0.256826f}, {-0.081121f, -0.518131f, -0.851445f}, {0.354783f, 0.249880f} },
    { {-0.009712f, -0.280637f, -0.258049f}, {-0.233535f, -0.467086f, -0.852814f}, {0.360436f, 0.248802f} },
    { {-0.035802f, -0.258205f, -0.259208f}, {-0.369234f, -0.380658f, -0.847800f}, {0.365218f, 0.246982f} },
    { {-0.055649f, -0.228162f, -0.260233f}, {-0.474837f, -0.273813f, -0.836395f}, {0.368856f, 0.244544f} },
    { {-0.101616f, -0.261347f, -0.213660f}, {-0.655554f, -0.334325f, -0.677108f}, {0.377281f, 0.247237f} },
    { {-0.068583f, -0.192593f, -0.261080f}, {-0.542331f, -0.162161f, -0.824367f}, {0.371227f, 0.241657f} },
    { {-0.118309f, -0.210953f, -0.214802f}, {-0.732731f, -0.186639f, -0.654424f}, {0.380341f, 0.243147f} },
    { {-0.074403f, -0.153962f, -0.261712f}, {-0.571158f, -0.052901f, -0.819134f}, {0.321101f, 0.312349f} },
    { {-0.068583f, -0.192593f, -0.261080f}, {-0.542331f, -0.162161f, -0.824367f}, {0.324285f, 0.312253f} },
    { {-0.072994f, -0.114917f, -0.262096f}, {-0.563081f, 0.056363f, -0.824478f}, {0.317883f, 0.312407f} },
    { {-0.124547f, -0.101102f, -0.216240f}, {-0.752260f, 0.071787f, -0.654944f}, {0.381485f, 0.234231f} },
    { {-0.064171f, -0.078102f, -0.262198f}, {-0.517680f, 0.170319f, -0.838450f}, {0.370418f, 0.232365f} },
    { {-0.072994f, -0.114917f, -0.262096f}, {-0.563081f, 0.056363f, -0.824478f}, {0.372035f, 0.235353f} },
    { {-0.113668f, -0.049130f, -0.216438f}, {-0.699427f, 0.218578f, -0.680460f}, {0.379490f, 0.230013f} },
    { {-0.047853f, -0.045989f, -0.261986f}, {-0.433709f, 0.286690f, -0.854228f}, {0.367427f, 0.229758f} },
    { {-0.092033f, -0.003798f, -0.216188f}, {-0.592338f, 0.385322f, -0.707575f}, {0.375525f, 0.226334f} },
    { {-0.024472f, -0.020726f, -0.261451f}, {-0.314775f, 0.392386f, -0.864263f}, {0.363141f, 0.227708f} },
    { {0.004662f, -0.004019f, -0.260621f}, {-0.171669f, 0.469863f, -0.865886f}, {0.357801f, 0.226352f} },
    { {0.058942f, -0.071449f, -0.288032f}, {0.091017f, 0.287654f, -0.953400f}, {0.347852f, 0.231825f} },
    { {0.042438f, -0.069739f, -0.288627f}, {-0.003824f, 0.288658f, -0.957425f}, {0.350877f, 0.231686f} },
    { {0.074527f, -0.078342f, -0.287412f}, {0.182434f, 0.263809f, -0.947166f}, {0.344995f, 0.232384f} },
    { {0.088093f, -0.089950f, -0.286810f}, {0.264225f, 0.220083f, -0.939015f}, {0.342508f, 0.233326f} },
    { {0.098753f, -0.105480f, -0.286266f}, {0.329930f, 0.161787f, -0.930038f}, {0.340554f, 0.234587f} },
    { {0.105877f, -0.123867f, -0.285813f}, {0.374556f, 0.095077f, -0.922317f}, {0.339249f, 0.236079f} },
    { {0.160188f, -0.101570f, -0.254115f}, {0.598547f, 0.144247f, -0.787994f}, {0.329293f, 0.234269f} },
    { {0.109072f, -0.143854f, -0.285480f}, {0.395692f, 0.024701f, -0.918051f}, {0.338663f, 0.237701f} },
    { {0.166008f, -0.140201f, -0.253482f}, {0.626856f, 0.035151f, -0.778342f}, {0.328227f, 0.237405f} },
    { {0.108160f, -0.164075f, -0.285287f}, {0.392820f, -0.046896f, -0.918419f}, {0.338830f, 0.239342f} },
    { {0.164599f, -0.179247f, -0.253098f}, {0.619086f, -0.074210f, -0.781809f}, {0.328485f, 0.240574f} },
    { {0.103164f, -0.183156f, -0.285249f}, {0.366122f, -0.118127f, -0.923039f}, {0.339746f, 0.240891f} },
    { {0.094331f, -0.199802f, -0.285372f}, {0.316552f, -0.185897f, -0.930181f}, {0.341365f, 0.242242f} },
    { {0.082168f, -0.212882f, -0.285651f}, {0.247016f, -0.244604f, -0.937631f}, {0.343594f, 0.243303f} },
    { {0.067463f, -0.221509f, -0.286068f}, {0.162800f, -0.287631f, -0.943803f}, {0.346290f, 0.244004f} },
    { {0.051260f, -0.225092f, -0.286593f}, {0.070265f, -0.309831f, -0.948192f}, {0.349260f, 0.244294f} },
    { {0.034756f, -0.223381f, -0.287187f}, {-0.024624f, -0.308811f, -0.950805f}, {0.352285f, 0.244156f} },
    { {0.019170f, -0.216488f, -0.287807f}, {-0.116235f, -0.284905f, -0.951482f}, {0.355142f, 0.243596f} },
    { {0.005605f, -0.204880f, -0.288409f}, {-0.198361f, -0.241072f, -0.950020f}, {0.357628f, 0.242654f} },
    { {-0.005056f, -0.189351f, -0.288954f}, {-0.264487f, -0.182642f, -0.946937f}, {0.359582f, 0.241394f} },
    { {-0.012179f, -0.170963f, -0.289406f}, {-0.309490f, -0.115811f, -0.943824f}, {0.360888f, 0.239901f} },
    { {-0.015374f, -0.150977f, -0.289740f}, {-0.330818f, -0.045374f, -0.942603f}, {0.361474f, 0.238279f} },
    { {-0.074403f, -0.153962f, -0.261712f}, {-0.571158f, -0.052901f, -0.819134f}, {0.372293f, 0.238521f} },
    { {-0.014462f, -0.130755f, -0.289933f}, {-0.327872f, 0.026198f, -0.944359f}, {0.361306f, 0.236638f} },
    { {-0.009467f, -0.111674f, -0.289971f}, {-0.300861f, 0.097330f, -0.948688f}, {0.360391f, 0.235089f} },
    { {-0.000634f, -0.095029f, -0.289847f}, {-0.250862f, 0.164964f, -0.953863f}, {0.358772f, 0.233738f} },
    { {0.011530f, -0.081948f, -0.289569f}, {-0.180931f, 0.223545f, -0.957753f}, {0.356542f, 0.232677f} },
    { {0.026234f, -0.073321f, -0.289152f}, {-0.096457f, 0.266488f, -0.959000f}, {0.353847f, 0.231977f} },
    { {0.047206f, -0.147529f, -0.297847f}, {0.034843f, -0.011104f, -0.999331f}, {0.350003f, 0.237999f} },
    { {0.248110f, -0.075162f, 0.118472f}, {0.928260f, 0.117459f, 0.352897f}, {0.405549f, 0.254822f} },
    { {0.247926f, -0.155657f, 0.137368f}, {0.934389f, -0.002826f, 0.356242f}, {0.398916f, 0.251963f} },
    { {0.249734f, -0.201022f, 0.132111f}, {0.921490f, -0.137962f, 0.363073f}, {0.395177f, 0.252759f} },
    { {0.249344f, -0.197420f, 0.133302f}, {0.934469f, -0.004019f, 0.356021f}, {0.395474f, 0.252578f} },
    { {0.250234f, -0.000890f, 0.036103f}, {0.957705f, 0.250214f, 0.142107f}, {0.411670f, 0.267286f} },
    { {0.250983f, -0.001757f, -0.033440f}, {0.960640f, 0.264252f, -0.085689f}, {0.411598f, 0.277808f} },
    { {0.252608f, -0.018217f, -0.065618f}, {0.960871f, 0.263191f, -0.086352f}, {0.410242f, 0.282678f} },
    { {0.252071f, -0.117095f, -0.127166f}, {0.956095f, 0.107890f, -0.272474f}, {0.402094f, 0.291990f} },
    { {0.253610f, -0.200575f, -0.126185f}, {0.955408f, -0.013964f, -0.294958f}, {0.395214f, 0.291842f} },
    { {0.252952f, -0.272529f, -0.090619f}, {0.937020f, -0.159527f, -0.310716f}, {0.389284f, 0.286460f} },
    { {0.253337f, -0.273788f, -0.089182f}, {0.877226f, -0.350452f, -0.328114f}, {0.389181f, 0.286243f} },
    { {0.248802f, -0.313762f, -0.030049f}, {0.920907f, -0.379292f, -0.089825f}, {0.385887f, 0.277295f} },
    { {0.250201f, -0.318727f, 0.004844f}, {0.920105f, -0.380831f, -0.091516f}, {0.385477f, 0.272016f} },
    { {0.249579f, -0.296254f, 0.071780f}, {0.908577f, -0.384671f, 0.162836f}, {0.387329f, 0.261887f} },
    { {0.253610f, -0.279454f, 0.089461f}, {0.899150f, -0.382185f, 0.213222f}, {0.388714f, 0.259212f} },
    { {0.248612f, -0.236574f, 0.120283f}, {0.921318f, -0.146134f, 0.360303f}, {0.392247f, 0.254548f} },
    { {0.200473f, -0.160133f, 0.001348f}, {0.997783f, 0.057110f, 0.034155f}, {0.398547f, 0.272545f} },
    { {0.195257f, -0.127489f, 0.099164f}, {0.919674f, -0.035614f, -0.391065f}, {0.401237f, 0.257744f} },
    { {0.196928f, -0.159003f, 0.103042f}, {0.858828f, 0.039152f, -0.510766f}, {0.398640f, 0.257157f} },
    { {0.193941f, -0.098201f, 0.088620f}, {0.866514f, -0.197784f, -0.458296f}, {0.403651f, 0.259339f} },
    { {0.198840f, -0.190593f, 0.099990f}, {0.936006f, 0.131806f, -0.326375f}, {0.396037f, 0.257619f} },
    { {0.193071f, -0.073132f, 0.072128f}, {0.920727f, -0.228319f, -0.316438f}, {0.405716f, 0.261835f} },
    { {0.192705f, -0.053993f, 0.050813f}, {0.900286f, -0.342502f, -0.268657f}, {0.407294f, 0.265060f} },
    { {0.192869f, -0.042087f, 0.026127f}, {0.908253f, -0.395765f, -0.135817f}, {0.408275f, 0.268795f} },
    { {0.193550f, -0.038225f, -0.000248f}, {0.863611f, -0.503280f, 0.029742f}, {0.408593f, 0.272786f} },
    { {0.194704f, -0.042672f, -0.026513f}, {0.951697f, -0.272403f, 0.141664f}, {0.408227f, 0.276760f} },
    { {0.196251f, -0.055123f, -0.050881f}, {0.893084f, -0.351252f, 0.281109f}, {0.407201f, 0.280448f} },
    { {0.198085f, -0.074730f, -0.071688f}, {0.859542f, -0.295538f, 0.416947f}, {0.405585f, 0.283596f} },
    { {0.200083f, -0.100158f, -0.087519f}, {0.856009f, -0.168651f, 0.488677f}, {0.403489f, 0.285991f} },
    { {0.202106f, -0.129672f, -0.097293f}, {0.929845f, -0.017248f, 0.367548f}, {0.401057f, 0.287470f} },
    { {0.204019f, -0.161263f, -0.100345f}, {0.826647f, 0.045111f, 0.560910f}, {0.398454f, 0.287932f} },
    { {0.205690f, -0.192776f, -0.096467f}, {0.929249f, 0.127861f, 0.346625f}, {0.395857f, 0.287345f} },
    { {0.207005f, -0.222065f, -0.085923f}, {0.848426f, 0.253513f, 0.464655f}, {0.393443f, 0.285750f} },
    { {0.207876f, -0.247133f, -0.069431f}, {0.901755f, 0.307883f, 0.303392f}, {0.391377f, 0.283255f} },
    { {0.208242f, -0.266272f, -0.048116f}, {0.938557f, 0.283281f, 0.197137f}, {0.389800f, 0.280029f} },
    { {0.208078f, -0.278178f, -0.023430f}, {0.916734f, 0.365015f, 0.162363f}, {0.388819f, 0.276294f} },
    { {0.207396f, -0.282040f, 0.002944f}, {0.913282f, 0.406349f, 0.028246f}, {0.388501f, 0.272303f} },
    { {0.206243f, -0.277594f, 0.029210f}, {0.926943f, 0.372062f, -0.048433f}, {0.388867f, 0.268329f} },
    { {0.204696f, -0.265142f, 0.053577f}, {0.882452f, 0.398859f, -0.249380f}, {0.389893f, 0.264642f} },
    { {0.202861f, -0.245535f, 0.074385f}, {0.933883f, 0.276808f, -0.226362f}, {0.391509f, 0.261493f} },
    { {0.200864f, -0.220108f, 0.090215f}, {0.858451f, 0.260242f, -0.441969f}, {0.393604f, 0.259098f} },
    { {0.250011f, -0.041898f, 0.096808f}, {0.565141f, -0.572786f, -0.593743f}, {0.408290f, 0.258100f} },
    { {0.250258f, -0.057597f, 0.107114f}, {0.557926f, -0.461168f, -0.689958f}, {0.312784f, 0.230700f} },
    { {0.193941f, -0.098201f, 0.088620f}, {0.866514f, -0.197784f, -0.458296f}, {0.323107f, 0.233996f} },
    { {0.193071f, -0.073132f, 0.072128f}, {0.920727f, -0.228319f, -0.316438f}, {0.323266f, 0.231961f} },
    { {0.250011f, -0.041898f, 0.096808f}, {0.565141f, -0.572786f, -0.593743f}, {0.312829f, 0.229426f} },
    { {0.251335f, -0.032668f, 0.086676f}, {0.562804f, -0.610863f, -0.556864f}, {0.409051f, 0.259633f} },
    { {0.247805f, -0.113940f, 0.132320f}, {0.556390f, -0.234367f, -0.797184f}, {0.313233f, 0.235273f} },
    { {0.195257f, -0.127489f, 0.099164f}, {0.919674f, -0.035614f, -0.391065f}, {0.322865f, 0.236373f} },
    { {0.249141f, -0.130404f, 0.134366f}, {0.548822f, -0.087894f, -0.831306f}, {0.312988f, 0.236610f} },
    { {0.196928f, -0.159003f, 0.103042f}, {0.858828f, 0.039152f, -0.510766f}, {0.322559f, 0.238931f} },
    { {0.250258f, -0.057597f, 0.107114f}, {0.557926f, -0.461168f, -0.689958f}, {0.406997f, 0.256541f} },
    { {0.248110f, -0.075162f, 0.118472f}, {0.562823f, -0.357839f, -0.745105f}, {0.405549f, 0.254822f} },
    { {0.248110f, -0.075162f, 0.118472f}, {0.562823f, -0.357839f, -0.745105f}, {0.313178f, 0.232126f} },
    { {0.249344f, -0.197420f, 0.133302f}, {0.554451f, 0.115711f, -0.824133f}, {0.312951f, 0.242049f} },
    { {0.198840f, -0.190593f, 0.099990f}, {0.936006f, 0.131806f, -0.326375f}, {0.322209f, 0.241494f} },
    { {0.249734f, -0.201022f, 0.132111f}, {0.564328f, 0.269609f, -0.780285f}, {0.312880f, 0.242341f} },
    { {0.200864f, -0.220108f, 0.090215f}, {0.858451f, 0.260242f, -0.441969f}, {0.321838f, 0.243890f} },
    { {0.247926f, -0.155657f, 0.137368f}, {0.557648f, 0.014865f, -0.829945f}, {0.313211f, 0.238659f} },
    { {0.251568f, -0.270120f, 0.099398f}, {0.581936f, 0.488330f, -0.650296f}, {0.389483f, 0.257709f} },
    { {0.253261f, -0.275222f, 0.093951f}, {0.574453f, 0.630920f, -0.521482f}, {0.389062f, 0.258533f} },
    { {0.248612f, -0.236574f, 0.120283f}, {0.582884f, 0.360276f, -0.728318f}, {0.313086f, 0.245226f} },
    { {0.248612f, -0.236574f, 0.120283f}, {0.582884f, 0.360276f, -0.728318f}, {0.392247f, 0.254548f} },
    { {0.250234f, -0.000890f, 0.036103f}, {0.589984f, -0.785986f, -0.184783f}, {0.411670f, 0.267286f} },
    { {0.249601f, -0.016630f, 0.068674f}, {0.586207f, -0.697555f, -0.412043f}, {0.410373f, 0.262357f} },
    { {0.252392f, 0.004280f, 0.001332f}, {0.583176f, -0.809731f, 0.065133f}, {0.412096f, 0.272547f} },
    { {0.253324f, 0.003301f, 0.008490f}, {0.576839f, -0.812426f, -0.084976f}, {0.412015f, 0.271464f} },
    { {0.248415f, -0.312873f, 0.039506f}, {0.647403f, 0.715905f, -0.261438f}, {0.385960f, 0.266771f} },
    { {0.251463f, -0.317436f, 0.011992f}, {0.642678f, 0.759913f, -0.097455f}, {0.385584f, 0.270934f} },
    { {0.253610f, -0.279454f, 0.089461f}, {0.596880f, 0.530244f, -0.602143f}, {0.388714f, 0.259212f} },
    { {0.249579f, -0.296254f, 0.071780f}, {0.622989f, 0.618672f, -0.478674f}, {0.387329f, 0.261887f} },
    { {0.253261f, -0.275222f, 0.093951f}, {-0.018168f, 0.726869f, -0.686536f}, {0.312233f, 0.248363f} },
    { {0.253610f, -0.279454f, 0.089461f}, {-0.018168f, 0.726869f, -0.686536f}, {0.312169f, 0.248706f} },
    { {0.253458f, -0.279404f, 0.089519f}, {-0.018168f, 0.726869f, -0.686536f}, {0.312197f, 0.248702f} },
    { {0.253261f, -0.275222f, 0.093951f}, {0.018168f, -0.726869f, 0.686536f}, {0.407923f, 0.248363f} },
    { {0.253458f, -0.279404f, 0.089519f}, {0.018168f, -0.726869f, 0.686536f}, {0.407959f, 0.248702f} },
    { {0.253610f, -0.279454f, 0.089461f}, {0.018168f, -0.726869f, 0.686536f}, {0.407987f, 0.248706f} },
    { {0.250983f, -0.001757f, -0.033440f}, {0.584363f, -0.765506f, 0.269295f}, {0.411598f, 0.277808f} },
    { {0.252608f, -0.018217f, -0.065618f}, {0.561522f, -0.659445f, 0.499824f}, {0.410242f, 0.282678f} },
    { {0.251395f, -0.044306f, -0.093209f}, {0.562406f, -0.546619f, 0.620409f}, {0.408092f, 0.286852f} },
    { {0.253183f, -0.021487f, -0.069096f}, {0.565082f, -0.611719f, 0.553608f}, {0.409972f, 0.283204f} },
    { {0.252608f, -0.018217f, -0.065618f}, {0.561522f, -0.659445f, 0.499824f}, {0.407804f, 0.227504f} },
    { {0.198085f, -0.074730f, -0.071688f}, {0.859542f, -0.295538f, 0.416947f}, {0.397810f, 0.232091f} },
    { {0.253183f, -0.021487f, -0.069096f}, {0.565082f, -0.611719f, 0.553608f}, {0.407909f, 0.227770f} },
    { {0.252224f, -0.297862f, -0.062525f}, {0.629915f, 0.670239f, 0.392411f}, {0.387197f, 0.282209f} },
    { {0.253326f, -0.294579f, -0.066066f}, {0.589078f, 0.598462f, 0.542983f}, {0.387467f, 0.282745f} },
    { {0.248802f, -0.313762f, -0.030049f}, {0.656414f, 0.724926f, 0.208812f}, {0.385887f, 0.277295f} },
    { {0.250201f, -0.318727f, 0.004844f}, {0.649909f, 0.759592f, 0.025264f}, {0.385477f, 0.272016f} },
    { {0.200083f, -0.100158f, -0.087519f}, {0.856009f, -0.168651f, 0.488677f}, {0.398176f, 0.234155f} },
    { {0.251440f, -0.078019f, -0.114194f}, {0.542869f, -0.327638f, 0.773270f}, {0.407590f, 0.232358f} },
    { {0.252601f, -0.061850f, -0.104131f}, {0.541701f, -0.430663f, 0.721865f}, {0.407802f, 0.231046f} },
    { {0.251395f, -0.044306f, -0.093209f}, {0.562406f, -0.546619f, 0.620409f}, {0.407581f, 0.229622f} },
    { {0.252071f, -0.117095f, -0.127166f}, {0.531410f, -0.167740f, 0.830341f}, {0.407705f, 0.235529f} },
    { {0.202106f, -0.129672f, -0.097293f}, {0.929845f, -0.017248f, 0.367548f}, {0.398547f, 0.236550f} },
    { {0.204019f, -0.161263f, -0.100345f}, {0.826647f, 0.045111f, 0.560910f}, {0.398897f, 0.239114f} },
    { {0.252511f, -0.158914f, -0.131266f}, {0.536237f, 0.032615f, 0.843437f}, {0.407786f, 0.238923f} },
    { {0.253565f, -0.133598f, -0.128746f}, {0.527985f, -0.077357f, 0.845723f}, {0.407979f, 0.236869f} },
    { {0.253610f, -0.200575f, -0.126185f}, {0.537134f, 0.179196f, 0.824242f}, {0.407987f, 0.242305f} },
    { {0.205690f, -0.192776f, -0.096467f}, {0.929249f, 0.127861f, 0.346625f}, {0.399204f, 0.241672f} },
    { {0.207005f, -0.222065f, -0.085923f}, {0.848426f, 0.253513f, 0.464655f}, {0.399445f, 0.244049f} },
    { {0.253477f, -0.202555f, -0.125484f}, {0.541710f, 0.297848f, 0.786026f}, {0.407963f, 0.242465f} },
    { {0.253669f, -0.202633f, -0.125446f}, {0.563436f, 0.248901f, 0.787774f}, {0.407998f, 0.242472f} },
    { {0.252952f, -0.272529f, -0.090619f}, {0.584237f, 0.513067f, 0.628832f}, {0.389284f, 0.286460f} },
    { {0.251483f, -0.239457f, -0.112399f}, {0.577081f, 0.359466f, 0.733323f}, {0.392010f, 0.289756f} },
    { {0.252952f, -0.272529f, -0.090619f}, {0.584237f, 0.513067f, 0.628832f}, {0.407867f, 0.248144f} },
    { {0.253326f, -0.294579f, -0.066066f}, {0.589078f, 0.598462f, 0.542983f}, {0.407935f, 0.249934f} },
    { {0.253337f, -0.273788f, -0.089182f}, {-0.065315f, 0.741915f, 0.667305f}, {0.407937f, 0.248247f} },
    { {0.251483f, -0.239457f, -0.112399f}, {0.577081f, 0.359466f, 0.733323f}, {0.407597f, 0.245460f} },
    { {0.017957f, 0.006347f, 0.299332f}, {-0.055538f, 0.431966f, 0.900178f}, {0.364792f, 0.225511f} },
    { {0.029569f, 0.058936f, 0.265485f}, {0.050241f, 0.673403f, 0.737566f}, {0.366921f, 0.221243f} },
    { {0.016085f, 0.060125f, 0.264083f}, {-0.043998f, 0.683832f, 0.728312f}, {0.364449f, 0.221146f} },
    { {0.042217f, 0.053912f, 0.268676f}, {0.138349f, 0.642459f, 0.753728f}, {0.369239f, 0.221650f} },
    { {0.053133f, 0.045393f, 0.273438f}, {0.213489f, 0.595063f, 0.774805f}, {0.371240f, 0.222342f} },
    { {0.061607f, 0.033962f, 0.279446f}, {0.269661f, 0.537176f, 0.799203f}, {0.372793f, 0.223270f} },
    { {0.067137f, 0.020401f, 0.286295f}, {0.303254f, 0.474417f, 0.826417f}, {0.373807f, 0.224370f} },
    { {0.069425f, 0.005640f, 0.293520f}, {0.312880f, 0.410173f, 0.856659f}, {0.374227f, 0.225568f} },
    { {0.068347f, -0.009314f, 0.300629f}, {0.298171f, 0.346010f, 0.889590f}, {0.374029f, 0.226782f} },
    { {0.063944f, -0.023443f, 0.307137f}, {0.259519f, 0.283702f, 0.923127f}, {0.373222f, 0.227929f} },
    { {0.056439f, -0.035789f, 0.312599f}, {0.199061f, 0.226896f, 0.953359f}, {0.371846f, 0.228931f} },
    { {0.046266f, -0.045516f, 0.316639f}, {0.121349f, 0.180879f, 0.975990f}, {0.369982f, 0.229720f} },
    { {0.034086f, -0.051961f, 0.318980f}, {0.032392f, 0.150772f, 0.988038f}, {0.367749f, 0.230243f} },
    { {0.020761f, -0.054684f, 0.319465f}, {-0.061911f, 0.139880f, 0.988231f}, {0.365306f, 0.230464f} },
    { {0.007276f, -0.053496f, 0.318062f}, {-0.155989f, 0.149093f, 0.976442f}, {0.362835f, 0.230368f} },
    { {-0.005371f, -0.048471f, 0.314871f}, {-0.243683f, 0.176829f, 0.953598f}, {0.360517f, 0.229960f} },
    { {-0.016287f, -0.039952f, 0.310109f}, {-0.318194f, 0.219324f, 0.922306f}, {0.358516f, 0.229268f} },
    { {-0.024761f, -0.028520f, 0.304101f}, {-0.373683f, 0.271886f, 0.886814f}, {0.356962f, 0.228341f} },
    { {-0.030291f, -0.014960f, 0.297252f}, {-0.406779f, 0.330777f, 0.851538f}, {0.355949f, 0.227240f} },
    { {-0.032579f, -0.000199f, 0.290028f}, {-0.416286f, 0.394103f, 0.819383f}, {0.355529f, 0.226042f} },
    { {-0.031501f, 0.014755f, 0.282919f}, {-0.401881f, 0.460639f, 0.791394f}, {0.355727f, 0.224828f} },
    { {-0.027099f, 0.028884f, 0.276410f}, {-0.363830f, 0.527630f, 0.767616f}, {0.356534f, 0.223682f} },
    { {-0.019594f, 0.041230f, 0.270949f}, {-0.304041f, 0.589648f, 0.748247f}, {0.357910f, 0.222680f} },
    { {-0.009420f, 0.050957f, 0.266909f}, {-0.226865f, 0.639821f, 0.734276f}, {0.359774f, 0.221890f} },
    { {0.002760f, 0.057402f, 0.264567f}, {-0.138226f, 0.672328f, 0.727234f}, {0.362007f, 0.221367f} },
    { {0.042402f, 0.100749f, 0.218865f}, {0.108243f, 0.820027f, 0.561996f}, {0.369273f, 0.217849f} },
    { {0.015274f, 0.102984f, 0.216119f}, {-0.049210f, 0.836813f, 0.545273f}, {0.364301f, 0.217668f} },
    { {0.067431f, 0.091077f, 0.225051f}, {0.257932f, 0.763614f, 0.591916f}, {0.373861f, 0.218634f} },
    { {0.088424f, 0.074614f, 0.234246f}, {0.386368f, 0.676079f, 0.627404f}, {0.377709f, 0.219970f} },
    { {0.104182f, 0.052495f, 0.245833f}, {0.481118f, 0.573232f, 0.663273f}, {0.380597f, 0.221765f} },
    { {0.114188f, 0.026259f, 0.259040f}, {0.537211f, 0.469748f, 0.700529f}, {0.382431f, 0.223895f} },
    { {0.118319f, -0.002274f, 0.272987f}, {0.555525f, 0.370821f, 0.744234f}, {0.383189f, 0.226210f} },
    { {0.116526f, -0.031146f, 0.286731f}, {0.536872f, 0.273175f, 0.798213f}, {0.382860f, 0.228554f} },
    { {0.108698f, -0.058402f, 0.299327f}, {0.479803f, 0.172832f, 0.860185f}, {0.381425f, 0.230766f} },
    { {0.094811f, -0.082218f, 0.309899f}, {0.384366f, 0.072950f, 0.920294f}, {0.378880f, 0.232699f} },
    { {0.075254f, -0.101003f, 0.317706f}, {0.257212f, -0.014396f, 0.966248f}, {0.375295f, 0.234223f} },
    { {0.051127f, -0.113488f, 0.322209f}, {0.110269f, -0.074629f, 0.991096f}, {0.370873f, 0.235237f} },
    { {0.024306f, -0.118811f, 0.323108f}, {-0.045767f, -0.098109f, 0.994123f}, {0.365956f, 0.235669f} },
    { {-0.002822f, -0.116576f, 0.320362f}, {-0.203112f, -0.082137f, 0.975704f}, {0.360984f, 0.235487f} },
    { {-0.027851f, -0.106904f, 0.314177f}, {-0.352165f, -0.030689f, 0.935435f}, {0.356396f, 0.234702f} },
    { {-0.048844f, -0.090441f, 0.304981f}, {-0.479156f, 0.045616f, 0.876543f}, {0.352548f, 0.233366f} },
    { {-0.064601f, -0.068321f, 0.293395f}, {-0.571974f, 0.133431f, 0.809347f}, {0.349660f, 0.231571f} },
    { {-0.074608f, -0.042086f, 0.280188f}, {-0.626480f, 0.224576f, 0.746383f}, {0.347826f, 0.229442f} },
    { {-0.078739f, -0.013553f, 0.266241f}, {-0.644305f, 0.319695f, 0.694742f}, {0.347068f, 0.227126f} },
    { {-0.076945f, 0.015319f, 0.252497f}, {-0.626479f, 0.423774f, 0.654171f}, {0.347397f, 0.224783f} },
    { {-0.069118f, 0.042576f, 0.239901f}, {-0.571143f, 0.537604f, 0.620304f}, {0.348832f, 0.222570f} },
    { {-0.055231f, 0.066392f, 0.229329f}, {-0.477512f, 0.651537f, 0.589475f}, {0.351377f, 0.220638f} },
    { {-0.035674f, 0.085176f, 0.221522f}, {-0.351546f, 0.748125f, 0.562782f}, {0.354962f, 0.219113f} },
    { {-0.011547f, 0.097661f, 0.217019f}, {-0.205105f, 0.812255f, 0.546053f}, {0.359385f, 0.218100f} },
    { {0.015274f, 0.102984f, 0.216119f}, {-0.049210f, 0.836813f, 0.545273f}, {0.355856f, 0.240047f} },
    { {0.056027f, 0.128962f, 0.162665f}, {0.090920f, 0.881366f, 0.463604f}, {0.348386f, 0.248135f} },
    { {0.015578f, 0.132003f, 0.158710f}, {-0.090013f, 0.888684f, 0.449597f}, {0.355800f, 0.248734f} },
    { {0.042402f, 0.100749f, 0.218865f}, {0.108243f, 0.820027f, 0.561996f}, {0.350883f, 0.239632f} },
    { {0.092576f, 0.115350f, 0.171452f}, {0.268738f, 0.824528f, 0.497929f}, {0.378470f, 0.216664f} },
    { {0.056027f, 0.128962f, 0.162665f}, {0.090920f, 0.881366f, 0.463604f}, {0.371771f, 0.215559f} },
    { {0.122079f, 0.092057f, 0.184450f}, {0.426777f, 0.723681f, 0.542353f}, {0.383878f, 0.218555f} },
    { {0.088424f, 0.074614f, 0.234246f}, {0.386368f, 0.676079f, 0.627404f}, {0.417892f, 0.237304f} },
    { {0.143181f, 0.060708f, 0.200795f}, {0.545375f, 0.599791f, 0.585506f}, {0.416746f, 0.242366f} },
    { {0.122079f, 0.092057f, 0.184450f}, {0.426777f, 0.723681f, 0.542353f}, {0.419329f, 0.244839f} },
    { {0.104182f, 0.052495f, 0.245833f}, {0.481118f, 0.573232f, 0.663273f}, {0.416069f, 0.235551f} },
    { {0.156022f, 0.023530f, 0.219428f}, {0.617544f, 0.477673f, 0.624875f}, {0.413682f, 0.239547f} },
    { {0.114188f, 0.026259f, 0.259040f}, {0.537211f, 0.469748f, 0.700529f}, {0.413907f, 0.233553f} },
    { {0.161306f, -0.016854f, 0.239132f}, {0.647844f, 0.367029f, 0.667523f}, {0.410354f, 0.236565f} },
    { {0.118319f, -0.002274f, 0.272987f}, {0.555525f, 0.370821f, 0.744234f}, {0.411556f, 0.231442f} },
    { {0.159328f, -0.057653f, 0.258588f}, {0.639553f, 0.261320f, 0.722969f}, {0.406992f, 0.233621f} },
    { {0.116526f, -0.031146f, 0.286731f}, {0.536872f, 0.273175f, 0.798213f}, {0.409176f, 0.229363f} },
    { {0.149568f, -0.096125f, 0.276448f}, {0.588582f, 0.149881f, 0.794422f}, {0.388916f, 0.233827f} },
    { {0.159328f, -0.057653f, 0.258588f}, {0.639553f, 0.261320f, 0.722969f}, {0.390705f, 0.230705f} },
    { {0.131112f, -0.129738f, 0.291439f}, {0.489264f, 0.031465f, 0.871568f}, {0.385534f, 0.236555f} },
    { {0.103638f, -0.156292f, 0.302486f}, {0.346895f, -0.079544f, 0.934525f}, {0.380498f, 0.238711f} },
    { {0.068366f, -0.174015f, 0.308815f}, {0.179254f, -0.162337f, 0.970317f}, {0.374032f, 0.240149f} },
    { {0.028352f, -0.181662f, 0.310016f}, {0.001863f, -0.203069f, 0.979163f}, {0.366698f, 0.240770f} },
    { {-0.012097f, -0.178621f, 0.306060f}, {-0.179002f, -0.196273f, 0.964072f}, {0.359284f, 0.240523f} },
    { {-0.048646f, -0.165008f, 0.297274f}, {-0.356429f, -0.142484f, 0.923394f}, {0.352584f, 0.239418f} },
    { {-0.078149f, -0.141715f, 0.284276f}, {-0.513095f, -0.052305f, 0.856736f}, {0.347176f, 0.237528f} },
    { {-0.099251f, -0.110366f, 0.267931f}, {-0.629332f, 0.053222f, 0.775312f}, {0.343309f, 0.234983f} },
    { {-0.064601f, -0.068321f, 0.293395f}, {-0.571974f, 0.133431f, 0.809347f}, {0.314044f, 0.228354f} },
    { {-0.112092f, -0.073188f, 0.249298f}, {-0.699133f, 0.156920f, 0.697559f}, {0.314445f, 0.235027f} },
    { {-0.099251f, -0.110366f, 0.267931f}, {-0.629332f, 0.053222f, 0.775312f}, {0.317508f, 0.232207f} },
    { {-0.074608f, -0.042086f, 0.280188f}, {-0.626480f, 0.224576f, 0.746383f}, {0.311882f, 0.230353f} },
    { {-0.117376f, -0.032805f, 0.229593f}, {-0.728202f, 0.257984f, 0.634953f}, {0.311117f, 0.238008f} },
    { {-0.078739f, -0.013553f, 0.266241f}, {-0.644305f, 0.319695f, 0.694742f}, {0.309530f, 0.232463f} },
    { {-0.115398f, 0.007995f, 0.210137f}, {-0.720434f, 0.367762f, 0.587985f}, {0.307755f, 0.240952f} },
    { {-0.076945f, 0.015319f, 0.252497f}, {-0.626479f, 0.423774f, 0.654171f}, {0.307151f, 0.234543f} },
    { {-0.105638f, 0.046466f, 0.192278f}, {-0.671575f, 0.495628f, 0.550763f}, {0.304584f, 0.243655f} },
    { {-0.069118f, 0.042576f, 0.239901f}, {-0.571143f, 0.537604f, 0.620304f}, {0.304905f, 0.236449f} },
    { {-0.087182f, 0.080080f, 0.177287f}, {-0.574902f, 0.634613f, 0.516482f}, {0.301814f, 0.245923f} },
    { {-0.055231f, 0.066392f, 0.229329f}, {-0.477512f, 0.651537f, 0.589475f}, {0.302942f, 0.238048f} },
    { {-0.059709f, 0.106634f, 0.166239f}, {-0.434380f, 0.759987f, 0.483460f}, {0.299626f, 0.247595f} },
    { {-0.035674f, 0.085176f, 0.221522f}, {-0.351546f, 0.748125f, 0.562782f}, {0.301394f, 0.239230f} },
    { {-0.024436f, 0.124357f, 0.159911f}, {-0.267377f, 0.847762f, 0.458050f}, {0.357022f, 0.215933f} },
    { {-0.059709f, 0.106634f, 0.166239f}, {-0.434380f, 0.759987f, 0.483460f}, {0.350557f, 0.217372f} },
    { {-0.011547f, 0.097661f, 0.217019f}, {-0.205105f, 0.812255f, 0.546053f}, {0.360772f, 0.239911f} },
    { {-0.024436f, 0.124357f, 0.159911f}, {-0.267377f, 0.847762f, 0.458050f}, {0.363135f, 0.248552f} },
    { {0.058455f, 0.110076f, 0.123308f}, {0.207407f, 0.886895f, -0.412795f}, {0.347941f, 0.254091f} },
    { {0.018006f, 0.113117f, 0.119353f}, {-0.085527f, 0.896198f, -0.435332f}, {0.355355f, 0.254689f} },
    { {0.015578f, 0.132003f, 0.158710f}, {0.012303f, 0.901798f, -0.431983f}, {0.355800f, 0.248734f} },
    { {0.056027f, 0.128962f, 0.162665f}, {0.305894f, 0.865578f, -0.396489f}, {0.348386f, 0.248135f} },
    { {0.095004f, 0.096464f, 0.132095f}, {0.495702f, 0.794541f, -0.350691f}, {0.419693f, 0.252761f} },
    { {0.058455f, 0.110076f, 0.123308f}, {0.207407f, 0.886895f, -0.412795f}, {0.420814f, 0.254091f} },
    { {0.056027f, 0.128962f, 0.162665f}, {0.305894f, 0.865578f, -0.396489f}, {0.422371f, 0.248135f} },
    { {0.092576f, 0.115350f, 0.171452f}, {0.585709f, 0.744246f, -0.321002f}, {0.421249f, 0.246806f} },
    { {0.124507f, 0.073171f, 0.145093f}, {0.740032f, 0.623043f, -0.253319f}, {0.417773f, 0.250794f} },
    { {0.122079f, 0.092057f, 0.184450f}, {0.803311f, 0.554758f, -0.216647f}, {0.419329f, 0.244839f} },
    { {0.145609f, 0.041822f, 0.161438f}, {0.896204f, 0.419008f, -0.145774f}, {0.415190f, 0.248321f} },
    { {0.143181f, 0.060708f, 0.200795f}, {0.928502f, 0.353869f, -0.112524f}, {0.416746f, 0.242366f} },
    { {0.158450f, 0.004644f, 0.180071f}, {0.970418f, 0.235511f, -0.053143f}, {0.412126f, 0.245502f} },
    { {0.156022f, 0.023530f, 0.219428f}, {0.982943f, 0.181966f, -0.026676f}, {0.413682f, 0.239547f} },
    { {0.163734f, -0.035740f, 0.199775f}, {0.996437f, 0.081293f, 0.022467f}, {0.408798f, 0.242520f} },
    { {0.161306f, -0.016854f, 0.239132f}, {0.998408f, 0.032886f, 0.045818f}, {0.410354f, 0.236565f} },
    { {0.161756f, -0.076539f, 0.219231f}, {0.993158f, -0.068860f, 0.094318f}, {0.405436f, 0.239576f} },
    { {0.159328f, -0.057653f, 0.258588f}, {0.985042f, -0.123586f, 0.120079f}, {0.406992f, 0.233621f} },
    { {0.151996f, -0.115011f, 0.237091f}, {0.952939f, -0.246180f, 0.176927f}, {0.402265f, 0.236874f} },
    { {0.149568f, -0.096125f, 0.276448f}, {0.926085f, -0.314705f, 0.208152f}, {0.403822f, 0.230919f} },
    { {0.133540f, -0.148624f, 0.252082f}, {0.844654f, -0.460434f, 0.273058f}, {0.399495f, 0.234606f} },
    { {0.131112f, -0.129738f, 0.291439f}, {0.787218f, -0.535628f, 0.305598f}, {0.401052f, 0.228650f} },
    { {0.106067f, -0.175178f, 0.263129f}, {0.643462f, -0.673893f, 0.363077f}, {0.397307f, 0.232934f} },
    { {0.103638f, -0.156292f, 0.302486f}, {0.557962f, -0.734232f, 0.386757f}, {0.398863f, 0.226979f} },
    { {0.070794f, -0.192901f, 0.269458f}, {0.374809f, -0.826616f, 0.419790f}, {0.395846f, 0.231976f} },
    { {0.068366f, -0.174015f, 0.308815f}, {0.278513f, -0.859082f, 0.429428f}, {0.397403f, 0.226021f} },
    { {0.030780f, -0.200548f, 0.270659f}, {0.085527f, -0.896198f, 0.435332f}, {0.367143f, 0.231795f} },
    { {0.070794f, -0.192901f, 0.269458f}, {0.374809f, -0.826616f, 0.419790f}, {0.374477f, 0.231976f} },
    { {0.068366f, -0.174015f, 0.308815f}, {0.278513f, -0.859082f, 0.429428f}, {0.374032f, 0.226021f} },
    { {0.028352f, -0.181662f, 0.310016f}, {-0.012303f, -0.901798f, 0.431984f}, {0.366698f, 0.225839f} },
    { {-0.009669f, -0.197507f, 0.266704f}, {-0.207408f, -0.886895f, 0.412795f}, {0.359729f, 0.232393f} },
    { {-0.012097f, -0.178621f, 0.306060f}, {-0.305894f, -0.865578f, 0.396489f}, {0.359284f, 0.226438f} },
    { {-0.046218f, -0.183894f, 0.257917f}, {-0.495703f, -0.794541f, 0.350690f}, {0.323568f, 0.233723f} },
    { {-0.009669f, -0.197507f, 0.266704f}, {-0.207408f, -0.886895f, 0.412795f}, {0.324690f, 0.232393f} },
    { {-0.012097f, -0.178621f, 0.306060f}, {-0.305894f, -0.865578f, 0.396489f}, {0.323133f, 0.226438f} },
    { {-0.048646f, -0.165008f, 0.297274f}, {-0.585709f, -0.744246f, 0.321002f}, {0.322011f, 0.227768f} },
    { {-0.075721f, -0.160601f, 0.244919f}, {-0.740032f, -0.623042f, 0.253320f}, {0.321648f, 0.235689f} },
    { {-0.078149f, -0.141715f, 0.284276f}, {-0.803310f, -0.554758f, 0.216648f}, {0.320092f, 0.229734f} },
    { {-0.096823f, -0.129252f, 0.228574f}, {-0.896204f, -0.419007f, 0.145775f}, {0.319065f, 0.238163f} },
    { {-0.099251f, -0.110366f, 0.267931f}, {-0.928502f, -0.353868f, 0.112524f}, {0.317508f, 0.232207f} },
    { {-0.109664f, -0.092074f, 0.209941f}, {-0.970418f, -0.235511f, 0.053142f}, {0.316001f, 0.240982f} },
    { {-0.112092f, -0.073188f, 0.249298f}, {-0.982943f, -0.181966f, 0.026675f}, {0.314445f, 0.235027f} },
    { {-0.114948f, -0.051691f, 0.190236f}, {-0.996437f, -0.081293f, -0.022467f}, {0.312673f, 0.243964f} },
    { {-0.117376f, -0.032805f, 0.229593f}, {-0.998408f, -0.032886f, -0.045817f}, {0.311117f, 0.238008f} },
    { {-0.112970f, -0.010892f, 0.170780f}, {-0.993158f, 0.068860f, -0.094318f}, {0.309311f, 0.246908f} },
    { {-0.115398f, 0.007995f, 0.210137f}, {-0.985042f, 0.123586f, -0.120078f}, {0.307755f, 0.240952f} },
    { {-0.103210f, 0.027580f, 0.152921f}, {-0.952939f, 0.246180f, -0.176926f}, {0.306141f, 0.249610f} },
    { {-0.105638f, 0.046466f, 0.192278f}, {-0.926085f, 0.314706f, -0.208153f}, {0.304584f, 0.243655f} },
    { {-0.084754f, 0.061193f, 0.137930f}, {-0.844654f, 0.460433f, -0.273059f}, {0.303371f, 0.251878f} },
    { {-0.087182f, 0.080080f, 0.177287f}, {-0.787219f, 0.535627f, -0.305599f}, {0.301814f, 0.245923f} },
    { {-0.057280f, 0.087748f, 0.126882f}, {-0.643462f, 0.673892f, -0.363078f}, {0.301182f, 0.253550f} },
    { {-0.059709f, 0.106634f, 0.166239f}, {-0.557961f, 0.734232f, -0.386758f}, {0.299626f, 0.247595f} },
    { {-0.022008f, 0.105471f, 0.120554f}, {-0.374808f, 0.826616f, -0.419791f}, {0.299722f, 0.254507f} },
    { {-0.024436f, 0.124357f, 0.159911f}, {-0.278512f, 0.859082f, -0.429429f}, {0.298165f, 0.248552f} },
    { {-0.022008f, 0.105471f, 0.120554f}, {-0.374808f, 0.826616f, -0.419791f}, {0.362689f, 0.254507f} },
    { {-0.024436f, 0.124357f, 0.159911f}, {-0.278512f, 0.859082f, -0.429429f}, {0.363135f, 0.248552f} },
};

WORD g_tind72[] = 
{
    0, 1, 2,    3, 4, 5,    6, 7, 8,    9, 10, 11,    12, 13, 14,
    15, 16, 17,    18, 19, 20,    21, 22, 23,    24, 25, 26,    27, 28, 29,
    30, 24, 31,    32, 33, 34,    34, 33, 35,    36, 37, 38,    39, 40, 41,
    42, 43, 44,    45, 46, 47,    48, 49, 50,    51, 52, 53,    54, 55, 56,
    57, 58, 59,    60, 61, 62,    63, 64, 65,    66, 67, 68,    69, 70, 71,
    72, 73, 74,    75, 76, 77,    78, 79, 80,    81, 82, 39,    83, 84, 85,
    86, 87, 88,    89, 90, 91,    92, 93, 94,    95, 96, 97,    45, 23, 15,
    98, 99, 100,    101, 102, 103,    104, 105, 46,    106, 107, 97,    108, 2, 1,
    109, 110, 111,    112, 87, 113,    11, 114, 9,    115, 116, 117,    118, 119, 120,
    121, 22, 21,    122, 123, 41,    124, 14, 13,    53, 52, 125,    126, 127, 128,
    129, 130, 131,    132, 133, 134,    135, 136, 137,    138, 92, 139,    140, 141, 142,
    143, 144, 145,    146, 147, 21,    51, 148, 52,    149, 150, 151,    152, 153, 154,
    155, 156, 157,    158, 159, 160,    161, 162, 163,    164, 165, 166,    167, 168, 169,
    170, 171, 172,    173, 174, 175,    131, 176, 177,    178, 179, 180,    181, 182, 183,
    184, 185, 186,    187, 188, 189,    190, 191, 99,    192, 193, 194,    195, 196, 197,
    198, 199, 200,    140, 201, 141,    202, 203, 204,    205, 206, 207,    208, 209, 210,
    211, 212, 97,    213, 214, 215,    216, 217, 218,    219, 220, 221,    222, 223, 224,
    225, 226, 227,    222, 224, 228,    229, 230, 231,    232, 233, 234,    235, 236, 237,
    238, 5, 64,    239, 240, 241,    122, 41, 40,    242, 243, 244,    245, 246, 247,
    248, 249, 250,    251, 252, 253,    254, 114, 255,    31, 24, 26,    256, 257, 258,
    259, 260, 29,    261, 262, 263,    264, 265, 266,    267, 268, 269,    270, 271, 272,
    203, 273, 204,    274, 275, 276,    277, 278, 279,    280, 281, 16,    79, 282, 283,
    284, 285, 286,    287, 35, 288,    289, 290, 291,    292, 293, 294,    295, 296, 297,
    298, 164, 166,    216, 299, 217,    300, 301, 302,    303, 304, 305,    131, 306, 307,
    56, 131, 307,    84, 308, 85,    308, 309, 85,    131, 130, 306,    310, 37, 311,
    312, 313, 314,    315, 260, 316,    317, 135, 137,    318, 319, 320,    321, 322, 318,
    323, 324, 325,    326, 327, 328,    181, 329, 330,    95, 331, 96,    332, 333, 334,
    335, 248, 336,    337, 338, 339,    340, 341, 342,    343, 344, 345,    346, 347, 348,
    348, 349, 346,    350, 351, 352,    353, 354, 355,    356, 357, 358,    26, 359, 31,
    360, 361, 362,    332, 334, 363,    364, 365, 366,    75, 367, 76,    284, 368, 369,
    303, 370, 371,    372, 373, 374,    327, 375, 328,    376, 81, 39,    377, 378, 58,
    379, 380, 381,    382, 367, 383,    384, 81, 385,    386, 83, 387,    388, 389, 52,
    390, 391, 392,    393, 309, 394,    395, 241, 396,    397, 398, 399,    400, 401, 402,
    5, 403, 3,    236, 404, 405,    406, 407, 408,    244, 409, 242,    410, 411, 190,
    412, 204, 413,    264, 261, 265,    414, 415, 416,    21, 414, 121,    417, 418, 419,
    420, 421, 422,    423, 424, 425,    198, 426, 199,    427, 428, 429,    430, 431, 5,
    432, 120, 433,    137, 432, 434,    435, 436, 437,    438, 439, 440,    441, 442, 443,
    261, 444, 262,    255, 445, 446,    287, 291, 290,    447, 448, 449,    447, 449, 450,
    451, 452, 100,    453, 454, 455,    251, 456, 457,    458, 459, 460,    461, 462, 463,
    464, 465, 466,    467, 468, 469,    470, 471, 472,    473, 474, 475,    476, 184, 186,
    477, 478, 479,    349, 480, 481,    397, 482, 398,    225, 227, 483,    458, 484, 459,
    485, 486, 487,    80, 488, 78,    77, 489, 75,    490, 491, 450,    333, 492, 334,
    493, 494, 495,    496, 497, 498,    499, 74, 73,    500, 149, 501,    502, 503, 504,
    505, 506, 507,    508, 509, 510,    511, 512, 513,    514, 515, 516,    517, 518, 519,
    520, 521, 522,    523, 524, 525,    526, 527, 528,    529, 530, 531,    532, 533, 534,
    535, 536, 537,    538, 539, 540,    541, 540, 542,    543, 544, 545,    546, 547, 548,
    159, 368, 549,    79, 550, 551,    552, 1, 553,    554, 555, 250,    556, 557, 558,
    559, 560, 561,    79, 562, 563,    379, 381, 564,    565, 89, 566,    567, 568, 569,
    570, 571, 572,    573, 570, 572,    574, 223, 222,    437, 436, 575,    576, 127, 126,
    577, 578, 579,    214, 580, 218,    581, 29, 28,    412, 582, 204,    470, 472, 583,
    467, 584, 468,    585, 279, 278,    586, 587, 308,    588, 589, 590,    538, 591, 539,
    592, 593, 594,    595, 596, 597,    598, 599, 82,    600, 601, 599,    53, 125, 602,
    246, 245, 248,    603, 604, 194,    290, 289, 605,    298, 296, 295,    606, 607, 66,
    608, 133, 609,    610, 609, 133,    611, 424, 423,    221, 220, 612,    86, 88, 613,
    400, 398, 401,    237, 104, 46,    614, 207, 206,    16, 136, 277,    280, 16, 277,
    615, 616, 617,    618, 619, 620,    621, 367, 622,    623, 624, 625,    626, 627, 628,
    629, 628, 627,    630, 631, 112,    632, 633, 634,    529, 531, 635,    526, 636, 527,
    523, 525, 637,    520, 638, 521,    639, 281, 640,    641, 642, 639,    304, 643, 644,
    304, 645, 646,    89, 91, 566,    318, 647, 648,    649, 650, 651,    652, 651, 653,
    654, 655, 656,    358, 656, 655,    535, 537, 657,    532, 658, 533,    659, 660, 661,
    662, 663, 664,    665, 666, 52,    496, 667, 497,    668, 103, 669,    670, 504, 503,
    639, 671, 672,    673, 572, 571,    674, 675, 676,    677, 678, 679,    680, 585, 278,
    319, 318, 322,    54, 34, 35,    164, 681, 165,    682, 683, 684,    419, 685, 417,
    414, 686, 415,    18, 687, 688,    131, 10, 176,    56, 55, 689,    690, 691, 692,
    690, 87, 691,    653, 693, 652,    206, 652, 614,    694, 695, 696,    276, 697, 274,
    698, 699, 505,    494, 700, 495,    701, 5, 238,    634, 702, 632,    440, 703, 438,
    704, 705, 706,    479, 239, 477,    707, 708, 709,    454, 452, 451,    710, 711, 712,
    299, 713, 302,    90, 89, 714,    433, 715, 432,    161, 163, 97,    716, 717, 718,
    68, 196, 288,    33, 288, 35,    132, 134, 719,    720, 111, 110,    613, 721, 86,
    112, 113, 630,    385, 187, 384,    597, 596, 722,    723, 364, 366,    588, 723, 589,
    724, 725, 463,    149, 151, 463,    726, 727, 728,    729, 730, 731,    732, 95, 733,
    733, 107, 734,    309, 180, 179,    44, 735, 180,    36, 311, 37,    108, 1, 552,
    736, 728, 727,    247, 56, 737,    738, 739, 740,    181, 741, 742,    211, 743, 212,
    717, 716, 744,    745, 96, 331,    743, 211, 745,    746, 747, 748,    749, 750, 751,
    752, 753, 226,    631, 754, 633,    176, 10, 9,    13, 421, 755,    756, 367, 757,
    284, 369, 758,    81, 598, 82,    759, 81, 384,    68, 67, 760,    761, 429, 428,
    623, 625, 762,    79, 763, 764,    404, 236, 235,    765, 766, 767,    444, 441, 443,
    768, 613, 88,    692, 768, 690,    47, 146, 21,    769, 48, 665,    275, 770, 276,
    581, 28, 771,    772, 45, 15,    45, 772, 773,    259, 316, 260,    774, 775, 506,
    181, 776, 182,    233, 777, 778,    628, 276, 770,    99, 410, 190,    779, 780, 781,
    60, 62, 782,    783, 784, 463,    233, 785, 234,    786, 594, 593,    270, 272, 787,
    788, 163, 162,    106, 734, 107,    142, 293, 292,    423, 789, 790,    15, 190, 411,
    639, 672, 791,    792, 371, 793,    270, 377, 271,    794, 795, 796,    336, 250, 555,
    336, 248, 250,    659, 797, 660,    798, 799, 800,    618, 253, 619,    801, 802, 803,
    804, 805, 806,    807, 808, 809,    810, 811, 812,    813, 814, 815,    816, 817, 818,
    11, 10, 819,    55, 820, 689,    821, 679, 822,    823, 824, 825,    273, 203, 826,
    827, 312, 314,    194, 828, 829,    430, 5, 4,    279, 280, 277,    386, 84, 83,
    830, 11, 831,    832, 833, 834,    394, 835, 393,    83, 393, 835,    836, 353, 837,
    838, 839, 840,    841, 842, 59,    842, 841, 376,    647, 120, 416,    414, 416, 121,
    843, 2, 108,    308, 42, 309,    844, 148, 51,    845, 846, 847,    848, 849, 717,
    718, 717, 849,    850, 376, 841,    851, 852, 722,    853, 543, 545,    230, 229, 854,
    855, 856, 857,    305, 304, 644,    713, 300, 302,    160, 858, 158,    859, 860, 861,
    181, 862, 863,    231, 464, 466,    648, 321, 318,    864, 865, 866,    601, 600, 122,
    122, 352, 351,    618, 620, 867,    868, 869, 870,    871, 872, 873,    874, 875, 876,
    669, 877, 878,    454, 878, 455,    879, 880, 194,    881, 882, 508,    883, 101, 237,
    235, 237, 101,    884, 303, 305,    885, 13, 886,    886, 13, 887,    888, 395, 889,
    396, 889, 395,    56, 307, 737,    890, 654, 656,    392, 388, 390,    891, 34, 54,
    37, 306, 130,    43, 735, 44,    236, 104, 237,    560, 892, 893,    894, 895, 896,
    897, 898, 899,    722, 900, 901,    901, 900, 902,    159, 158, 368,    76, 367, 903,
    904, 905, 906,    907, 706, 705,    908, 909, 910,    749, 911, 750,    773, 46, 45,
    237, 912, 883,    882, 881, 360,    255, 446, 254,    913, 914, 915,    14, 124, 913,
    440, 87, 703,    703, 632, 438,    483, 482, 397,    710, 916, 711,    333, 490, 492,
    214, 917, 215,    853, 545, 918,    919, 332, 363,    920, 921, 426,    752, 226, 225,
    59, 842, 906,    906, 905, 922,    923, 896, 895,    924, 925, 926,    927, 928, 929,
    167, 930, 168,    931, 932, 933,    50, 7, 6,    835, 934, 83,    387, 83, 934,
    935, 95, 97,    935, 733, 95,    574, 575, 223,    702, 438, 632,    23, 22, 136,
    432, 137, 136,    936, 937, 938,    667, 939, 497,    695, 940, 941,    942, 943, 335,
    944, 316, 259,    507, 698, 505,    633, 945, 631,    633, 87, 945,    946, 947, 194,
    197, 948, 195,    949, 246, 950,    389, 125, 52,    287, 831, 11,    819, 287, 11,
    951, 952, 953,    952, 954, 955,    111, 956, 109,    957, 838, 958,    959, 176, 9,
    959, 9, 114,    79, 283, 960,    961, 156, 155,    483, 227, 482,    721, 630, 86,
    179, 394, 309,    241, 477, 239,    962, 963, 964,    804, 965, 805,    966, 967, 968,
    810, 969, 811,    12, 14, 970,    268, 971, 269,    725, 972, 463,    738, 740, 375,
    1, 138, 139,    93, 577, 973,    602, 125, 974,    974, 975, 602,    96, 211, 97,
    96, 745, 211,    88, 690, 768,    88, 87, 690,    976, 367, 756,    286, 285, 977,
    558, 978, 556,    979, 980, 981,    982, 888, 983,    889, 983, 888,    984, 985, 986,
    984, 986, 987,    988, 989, 990,    991, 64, 63,    569, 137, 567,    434, 567, 137,
    460, 459, 992,    993, 994, 995,    996, 997, 998,    844, 999, 148,    769, 665, 1000,
    1001, 1002, 1003,    1004, 619, 253,    746, 1005, 747,    0, 138, 1,    585, 1006, 279,
    209, 1007, 1008,    1009, 1010, 1011,    331, 95, 732,    490, 450, 492,    321, 648, 1012,
    686, 1013, 415,    491, 447, 450,    299, 302, 217,    399, 398, 400,    142, 141, 293,
    1014, 844, 51,    66, 607, 67,    1015, 1016, 1017,    110, 109, 133,    133, 109, 610,
    1018, 1019, 1020,    816, 1021, 817,    51, 53, 688,    377, 1022, 271,    1023, 1024, 661,
    1025, 486, 485,    1025, 1026, 486,    580, 216, 218,    564, 381, 624,    383, 367, 621,
    566, 91, 1027,    1027, 118, 120,    127, 577, 579,    402, 144, 143,    1028, 1029, 518,
    448, 541, 542,    209, 1030, 210,    1031, 1032, 662,    1033, 1034, 1035,    454, 453, 452,
    1036, 1037, 1038,    1039, 1040, 1041,    1042, 981, 980,    995, 1043, 993,    1044, 1045, 1046,
    1028, 518, 517,    288, 196, 195,    288, 291, 287,    504, 205, 502,    102, 669, 103,
    50, 49, 7,    493, 7, 494,    1047, 18, 688,    807, 1048, 808,    813, 1049, 814,
    801, 1050, 802,    166, 6, 8,    166, 296, 298,    408, 1051, 406,    572, 1052, 573,
    719, 720, 132,    839, 358, 357,    151, 461, 463,    231, 466, 229,    1053, 617, 616,
    245, 249, 248,    730, 1054, 731,    315, 1055, 260,    207, 1056, 205,    1057, 367, 1058,
    903, 367, 1057,    643, 304, 646,    1059, 855, 857,    153, 152, 1060,    287, 1061, 35,
    55, 54, 35,    651, 629, 649,    772, 15, 411,    656, 736, 890,    727, 890, 736,
    1062, 320, 565,    568, 320, 319,    59, 906, 922,    1034, 1033, 1063,    1064, 382, 383,
    172, 171, 380,    1065, 1066, 1067,    1068, 640, 281,    1069, 1068, 281,    1070, 860, 859,
    175, 1071, 173,    1072, 1073, 1074,    891, 1075, 1076,    919, 363, 365,    734, 106, 788,
    1077, 1078, 1079,    667, 47, 939,    1080, 603, 194,    825, 824, 1081,    485, 487, 1082,
    679, 1083, 822,    304, 303, 371,    645, 304, 371,    457, 252, 251,    513, 914, 511,
    510, 1084, 508,    1085, 303, 1086,    303, 1085, 370,    221, 612, 611,    320, 1087, 318,
    647, 318, 1087,    712, 201, 140,    165, 6, 166,    932, 1088, 933,    1089, 1090, 1091,
    1092, 1007, 209,    1093, 1041, 1040,    899, 1094, 897,    509, 1095, 510,    1096, 1097, 1098,
    54, 56, 1099,    949, 1099, 56,    1100, 1101, 1102,    684, 1103, 682,    1104, 1105, 987,
    786, 593, 270,    1106, 422, 421,    481, 346, 349,    311, 555, 554,    555, 311, 36,
    1107, 1108, 120,    1108, 416, 120,    15, 639, 791,    17, 639, 15,    1109, 244, 243,
    595, 1110, 596,    1111, 561, 560,    893, 1111, 560,    920, 426, 198,    567, 434, 714,
    715, 434, 432,    904, 1112, 1113,    123, 122, 351,    841, 59, 58,    841, 593, 592,
    1114, 1115, 1116,    1117, 1114, 1116,    1118, 202, 1119,    260, 27, 29,    1009, 1011, 1120,
    1121, 1009, 1120,    1122, 1123, 1124,    1125, 1126, 1122,    908, 1127, 909,    79, 551, 282,
    549, 368, 284,    950, 248, 335,    950, 246, 248,    1128, 1129, 1130,    1131, 1132, 1133,
    40, 39, 82,    599, 601, 82,    1134, 1135, 1136,    1108, 1107, 22,    696, 695, 1137,
    928, 1138, 929,    391, 1139, 1140,    892, 1141, 1142,    990, 1143, 988,    228, 224, 753,
    754, 634, 633,    1144, 29, 581,    699, 274, 697,    1145, 1146, 1147,    1148, 1149, 1150,
    137, 569, 317,    1151, 1152, 1153,    576, 126, 1,    576, 1, 139,    162, 161, 848,
    723, 366, 589,    819, 1061, 287,    55, 819, 820,    596, 1154, 900,    1110, 1154, 596,
    1155, 1156, 1157,    1158, 1157, 1159,    1160, 1161, 1162,    1163, 1164, 1161,    831, 290, 605,
    287, 290, 831,    1165, 1166, 1167,    1168, 1169, 1170,    1171, 1172, 176,    421, 885, 1106,
    32, 66, 33,    997, 995, 994,    1173, 1174, 1175,    1176, 1177, 1178,    1179, 1180, 1181,
    1182, 1183, 1184,    1185, 441, 444,    1186, 1187, 1188,    1189, 1190, 1191,    21, 147, 414,
    1192, 846, 845,    1193, 1164, 1163,    1194, 1195, 1196,    877, 455, 878,    506, 670, 774,
    1197, 1198, 1199,    1200, 1201, 474,    28, 204, 771,    202, 204, 28,    782, 62, 1202,
    671, 1203, 1204,    568, 567, 89,    714, 89, 567,    1047, 53, 602,    688, 53, 1047,
    1205, 761, 428,    68, 760, 196,    962, 1206, 963,    966, 1207, 967,    326, 328, 185,
    1208, 724, 463,    91, 90, 119,    715, 433, 90,    1209, 1210, 1211,    1212, 1213, 1214,
    674, 1215, 675,    989, 1216, 1217,    998, 1218, 996,    181, 183, 862,    464, 232, 465,
    642, 1219, 1203,    1220, 982, 1221,    983, 1221, 982,    766, 1222, 767,    103, 235, 101,
    1223, 1224, 1225,    950, 335, 1226,    115, 833, 116,    255, 830, 445,    693, 614, 652,
    1118, 1227, 826,    1090, 1228, 1091,    1074, 1229, 1230,    1073, 1229, 1074,    1231, 1232, 1076,
    1075, 1231, 1076,    1087, 1027, 647,    120, 647, 1027,    320, 568, 1233,    89, 1233, 568,
    1038, 1234, 1235,    1236, 1235, 1234,    1237, 372, 374,    871, 873, 1238,    79, 78, 550,
    550, 78, 1239,    597, 722, 852,    1240, 595, 597,    688, 687, 1241,    1241, 51, 688,
    759, 598, 81,    1242, 1243, 1244,    513, 1245, 915,    1246, 1096, 1098,    460, 992, 1247,
    677, 679, 821,    1202, 62, 781,    191, 100, 99,    291, 195, 948,    195, 291, 288,
    1248, 987, 986,    1248, 1110, 595,    655, 356, 358,    1249, 1250, 1251,    938, 1252, 936,
    1079, 1253, 1077,    867, 615, 618,    253, 618, 251,    1254, 403, 765,    878, 668, 669,
    744, 212, 743,    1255, 1256, 1257,    1258, 944, 259,    775, 507, 506,    1259, 1260, 1261,
    1262, 1263, 1264,    1018, 1265, 1019,    1266, 1158, 1159,    1267, 1268, 1269,    1270, 1271, 1272,
    1273, 1274, 1275,    1231, 1276, 1232,    896, 899, 898,    1277, 1278, 1279,    1280, 1277, 1279,
    5, 766, 403,    403, 766, 765,    691, 440, 439,    691, 87, 440,    1086, 303, 884,
    1205, 428, 1281,    947, 1282, 194,    926, 1283, 924,    1046, 1284, 1044,    829, 879, 194,
    1285, 509, 508,    944, 1286, 316,    1287, 1288, 1289,    68, 288, 33,    66, 68, 33,
    1290, 1291, 1292,    664, 1031, 662,    519, 518, 1293,    143, 145, 435,    209, 1008, 1030,
    541, 538, 540,    181, 330, 776,    1200, 1294, 1201,    79, 960, 562,    155, 157, 1295,
    1296, 1297, 1298,    1299, 1300, 1301,    1302, 1303, 1304,    1305, 1306, 1307,    1006, 1308, 279,
    279, 1308, 1309,    576, 139, 973,    94, 139, 92,    514, 516, 219,    1122, 1126, 1123,
    319, 569, 568,    319, 317, 569,    360, 362, 882,    880, 192, 194,    972, 501, 149,
    972, 149, 463,    27, 202, 28,    1119, 202, 27,    1310, 1311, 1312,    1313, 1310, 1312,
    771, 204, 582,    770, 626, 628,    110, 132, 720,    110, 133, 132,    79, 563, 763,
    172, 380, 379,    181, 742, 329,    184, 326, 185,    114, 254, 337,    1084, 881, 508,
    1314, 1315, 1316,    1317, 1316, 1315,    1318, 1319, 1320,    1321, 1318, 1320,    632, 87, 633,
    703, 87, 632,    944, 1322, 1286,    503, 774, 670,    1037, 1323, 1324,    1325, 1324, 1323,
    1058, 367, 976,    284, 758, 285,    35, 1061, 55,    819, 55, 1061,    1326, 43, 42,
    1326, 42, 1327,    704, 1328, 705,    907, 705, 1328,    1329, 1330, 1125,    1331, 1330, 1329,
    1332, 1333, 1334,    1332, 1334, 1335,    118, 1027, 91,    119, 118, 91,    1125, 1330, 1336,
    1125, 1336, 1126,    855, 1337, 856,    73, 72, 1338,    1339, 1340, 1341,    93, 1341, 1340,
    591, 588, 590,    261, 263, 265,    437, 575, 574,    219, 516, 220,    181, 863, 72,
    863, 1338, 72,    1342, 646, 645,    576, 973, 577,    127, 576, 577,    1343, 1344, 354,
    730, 729, 1345,    859, 861, 1346,    488, 1239, 78,    1347, 364, 723,    444, 443, 262,
    1124, 1348, 1349,    1124, 1123, 1348,    1350, 1177, 1176,    1351, 1352, 1353,    1354, 1182, 1184,
    1355, 1356, 1357,    582, 412, 1358,    627, 649, 629,    100, 452, 98,    453, 98, 452,
    716, 718, 97,    718, 849, 97,    113, 87, 86,    113, 86, 630,    956, 610, 109,
    728, 957, 726,    434, 715, 714,    90, 714, 715,    134, 608, 1359,    133, 608, 134,
    39, 41, 842,    842, 376, 39,    1360, 222, 228,    611, 612, 424,    820, 131, 689,
    689, 131, 56,    1175, 1174, 1195,    1175, 1195, 1194,    948, 289, 291,    604, 946, 194,
    615, 867, 616,    1361, 1362, 1363,    565, 566, 1062,    1027, 1062, 566,    181, 1364, 741,
    327, 738, 375,    79, 764, 1365,    564, 624, 623,    1366, 587, 586,    1367, 138, 0,
    580, 1368, 216,    1369, 1370, 1371,    1210, 1372, 1373,    1373, 1211, 1210,    296, 495, 297,
    1041, 1374, 1039,    462, 783, 463,    232, 234, 465,    16, 23, 136,    15, 23, 16,
    1375, 1376, 1377,    661, 660, 1023,    1016, 1378, 1017,    64, 5, 65,    1379, 305, 1380,
    1379, 884, 305,    390, 52, 666,    390, 388, 52,    1381, 1382, 1331,    1331, 1382, 1330,
    22, 121, 1108,    323, 1383, 1384,    390, 666, 391,    1385, 1386, 1387,    1388, 57, 59,
    922, 1388, 59,    1389, 1390, 1391,    1392, 1393, 1394,    122, 40, 601,    82, 601, 40,
    898, 894, 896,    994, 998, 997,    1395, 1396, 1397,    1372, 1395, 1397,    1398, 620, 619,
    1180, 1269, 1181,    1180, 1267, 1269,    904, 1113, 905,    1399, 1400, 1401,    1278, 1402, 1279,
    1278, 1403, 1402,    836, 1343, 353,    354, 353, 1343,    129, 131, 177,    180, 420, 178,
    980, 1404, 1042,    1142, 893, 892,    11, 830, 255,    255, 114, 11,    1405, 66, 32,
    1406, 991, 1407,    1408, 1409, 1410,    1410, 1409, 1411,    755, 124, 13,    1412, 1413, 1414,
    1415, 1416, 1408,    1408, 1416, 1409,    1417, 1418, 1419,    1420, 1421, 1422,    1403, 1335, 1402,
    1403, 1332, 1335,    413, 204, 273,    650, 653, 651,    593, 58, 378,    58, 593, 841,
    1245, 14, 915,    14, 913, 915,    949, 1423, 1099,    1424, 1425, 1426,    1427, 315, 316,
    1056, 502, 205,    1428, 1429, 1430,    1234, 1431, 1236,    1432, 1433, 1434,    1434, 1435, 1432,
    1436, 1437, 1438,    431, 1439, 1440,    431, 1440, 5,    1441, 104, 236,    1442, 701, 238,
    1323, 1443, 1325,    1444, 1445, 1446,    8, 7, 493,    8, 296, 166,    107, 935, 97,
    107, 733, 935,    648, 416, 415,    1447, 1448, 324,    163, 106, 97,    163, 788, 106,
    939, 47, 105,    105, 47, 46,    832, 116, 833,    193, 1080, 194,    136, 1107, 432,
    120, 432, 1107,    1449, 1450, 1451,    1451, 1450, 1452,    240, 396, 241,    122, 600, 352,
    1186, 1188, 1228,    1090, 1186, 1228,    1453, 125, 389,    1453, 974, 125,    1454, 1455, 1456,
    1294, 1457, 1201,    377, 58, 57,    794, 1458, 795,    280, 279, 1309,    1309, 281, 280,
    1324, 1459, 1037,    1459, 1038, 1037,    799, 798, 1203,    798, 1204, 1203,    1460, 1461, 1462,
    1463, 1464, 1465,    779, 1466, 780,    779, 1467, 1466,    1468, 1469, 1470,    890, 727, 1471,
    773, 883, 912,    1211, 1472, 1209,    1451, 1452, 1473,    1473, 1452, 1474,    605, 1475, 831,
    945, 112, 631,    945, 87, 112,    1476, 1477, 1478,    1478, 1477, 1479,    1480, 552, 553,
    1480, 108, 552,    1481, 684, 683,    1298, 1482, 1296,    1000, 665, 148,    148, 665, 52,
    422, 178, 420,    478, 1483, 479,    1410, 1411, 1381,    1381, 1411, 1382,    1124, 1349, 1449,
    1449, 1349, 1450,    322, 680, 319,    1339, 1132, 1131,    356, 655, 1484,    37, 310, 306,
    376, 385, 81,    385, 376, 850,    695, 941, 1485,    1486, 1487, 1488,    1473, 1474, 1415,
    1415, 1474, 1416,    582, 1489, 771,    771, 1489, 581,    1327, 42, 308,    587, 1327, 308,
    586, 308, 84,    386, 586, 84,    49, 494, 7,    1490, 496, 498,    1104, 987, 595,
    1248, 595, 987,    150, 149, 500,    230, 854, 1491,    849, 161, 97,    849, 848, 161,
    1492, 77, 76,    160, 1493, 858,    56, 247, 246,    949, 56, 246,    1494, 1479, 1495,
    1478, 1479, 1494,    757, 367, 382,    1295, 157, 1496,    212, 716, 97,    212, 744, 716,
    1497, 1498, 1499,    1500, 1501, 1502,    1503, 1504, 1505,    1506, 1507, 1508,    1509, 1510, 1511,
    1512, 1513, 1514,    622, 367, 75,    622, 75, 489,    364, 919, 365,    441, 1515, 442,
    597, 852, 1240,    592, 850, 841,    228, 753, 752,    423, 425, 789,    1380, 305, 644,
    1516, 1517, 1518,    1519, 1495, 1520,    1494, 1495, 1519,    1158, 1155, 1157,    448, 542, 449,
    1163, 1161, 1160,    402, 401, 144,    1391, 253, 252,    1391, 252, 457,    439, 692, 691,
    1147, 1146, 1521,    1522, 1523, 1524,    1062, 1027, 1087,    1525, 1526, 1527,    1528, 1529, 1530,
    1531, 1165, 1167,    591, 590, 539,    1532, 1533, 1534,    1, 126, 553,    1535, 619, 1004,
    41, 123, 906,    842, 41, 906,    48, 1139, 391,    1536, 667, 1537,    1538, 1539, 1540,
    1541, 1542, 1543,    759, 384, 1544,    1545, 1546, 1547,    697, 505, 699,    1235, 1036, 1038,
    784, 1548, 463,    233, 1549, 785,    694, 940, 695,    1550, 1551, 1552,    1553, 1554, 1555,
    1556, 1471, 727,    577, 93, 578,    1447, 19, 1448,    819, 10, 820,    820, 10, 131,
    999, 1000, 148,    1000, 999, 769,    727, 726, 1557,    730, 1553, 1054,    1147, 1521, 1558,
    435, 145, 436,    1559, 1560, 1561,    1562, 1563, 1564,    1256, 1565, 1257,    1256, 1566, 1565,
    1567, 491, 490,    214, 218, 917,    1568, 1569, 1570,    1571, 1568, 1570,    1571, 1570, 1166,
    1165, 1571, 1166,    138, 1133, 1132,    138, 1367, 1133,    501, 972, 1572,    1573, 1574, 1575,
    45, 21, 23,    45, 47, 21,    1233, 565, 320,    89, 565, 1233,    489, 1576, 622,
    1577, 1578, 1579,    493, 495, 296,    296, 8, 493,    16, 281, 17,    281, 639, 17,
    378, 270, 593,    270, 378, 377,    1132, 92, 138,    92, 1132, 1341,    1580, 397, 399,
    712, 711, 201,    640, 641, 639,    1581, 870, 869,    671, 639, 642,    1203, 671, 642,
    792, 645, 371,    1582, 1583, 1584,    1040, 1585, 1093,    1217, 990, 989,    1064, 383, 1586,
    381, 1587, 624,    181, 72, 74,    181, 74, 1364,    1588, 1298, 1297,    887, 13, 12,
    1589, 662, 1032,    1590, 1591, 1592,    655, 654, 1593,    654, 890, 1593,    1276, 1594, 1232,
    298, 295, 1595,    1596, 1373, 1372,    1397, 1596, 1372,    1112, 904, 123,    906, 123, 904,
    1597, 1598, 1599,    1600, 884, 1379,    1119, 27, 260,    1055, 1119, 260,    433, 119, 90,
    119, 433, 120,    793, 371, 370,    1601, 1602, 1603,    1604, 1603, 1602,    350, 1605, 351,
    1606, 1607, 1608,    1609, 1610, 1424,    1426, 1609, 1424,    1118, 203, 202,    826, 203, 1118,
    1391, 1390, 253,    1390, 1004, 253,    456, 251, 615,    251, 618, 615,    1319, 1153, 1152,
    1152, 1320, 1319,    1611, 695, 1485,    1202, 781, 780,    1204, 672, 671,    617, 456, 615,
    1612, 1613, 1614,    123, 351, 1112,    1605, 1112, 351,    1615, 1616, 1617,    1615, 1618, 1616,
    1615, 1619, 1618,    1615, 1620, 1619,    1615, 1621, 1620,    1615, 1622, 1621,    1615, 1623, 1622,
    1615, 1624, 1623,    1615, 1625, 1624,    1615, 1626, 1625,    1615, 1627, 1626,    1615, 1628, 1627,
    1615, 1629, 1628,    1615, 1630, 1629,    1615, 1631, 1630,    1615, 1632, 1631,    1615, 1633, 1632,
    1615, 1634, 1633,    1615, 1635, 1634,    1615, 1636, 1635,    1615, 1637, 1636,    1615, 1638, 1637,
    1615, 1639, 1638,    1615, 1617, 1639,    1617, 1640, 1641,    1617, 1616, 1640,    1616, 1642, 1640,
    1616, 1618, 1642,    1618, 1643, 1642,    1618, 1619, 1643,    1619, 1644, 1643,    1619, 1620, 1644,
    1620, 1645, 1644,    1620, 1621, 1645,    1621, 1646, 1645,    1621, 1622, 1646,    1622, 1647, 1646,
    1622, 1623, 1647,    1623, 1648, 1647,    1623, 1624, 1648,    1624, 1649, 1648,    1624, 1625, 1649,
    1625, 1650, 1649,    1625, 1626, 1650,    1626, 1651, 1650,    1626, 1627, 1651,    1627, 1652, 1651,
    1627, 1628, 1652,    1628, 1653, 1652,    1628, 1629, 1653,    1629, 1654, 1653,    1629, 1630, 1654,
    1630, 1655, 1654,    1630, 1631, 1655,    1631, 1656, 1655,    1631, 1632, 1656,    1632, 1657, 1656,
    1632, 1633, 1657,    1633, 1658, 1657,    1633, 1634, 1658,    1634, 1659, 1658,    1634, 1635, 1659,
    1635, 1660, 1659,    1635, 1636, 1660,    1636, 1661, 1660,    1636, 1637, 1661,    1637, 1662, 1661,
    1637, 1638, 1662,    1638, 1663, 1662,    1638, 1639, 1663,    1639, 1641, 1663,    1639, 1617, 1641,
    1641, 1664, 1665,    1641, 1640, 1664,    1640, 1666, 1664,    1640, 1642, 1666,    1642, 1667, 1666,
    1642, 1643, 1667,    1643, 1668, 1667,    1643, 1644, 1668,    1644, 1669, 1668,    1644, 1645, 1669,
    1670, 1671, 1672,    1670, 1673, 1671,    1673, 1674, 1671,    1673, 1675, 1674,    1675, 1676, 1674,
    1647, 1648, 1677,    1648, 1678, 1677,    1648, 1649, 1678,    1649, 1679, 1678,    1649, 1650, 1679,
    1650, 1680, 1679,    1650, 1651, 1680,    1651, 1681, 1680,    1651, 1652, 1681,    1652, 1682, 1681,
    1652, 1653, 1682,    1653, 1683, 1682,    1653, 1654, 1683,    1654, 1684, 1683,    1654, 1655, 1684,
    1655, 1685, 1684,    1655, 1656, 1685,    1686, 1687, 1688,    1686, 1689, 1687,    1689, 1690, 1687,
    1689, 1691, 1690,    1691, 1692, 1690,    1691, 1693, 1692,    1693, 1694, 1692,    1693, 1695, 1694,
    1695, 1696, 1694,    1660, 1661, 1697,    1661, 1698, 1697,    1661, 1662, 1698,    1662, 1699, 1698,
    1662, 1663, 1699,    1663, 1665, 1699,    1663, 1641, 1665,    1665, 1700, 1701,    1665, 1664, 1700,
    1664, 1702, 1700,    1664, 1666, 1702,    1666, 1703, 1702,    1666, 1667, 1703,    1704, 1705, 1706,
    1704, 1707, 1705,    1707, 1708, 1705,    1707, 1672, 1708,    1672, 1709, 1708,    1672, 1671, 1709,
    1671, 1710, 1709,    1671, 1674, 1710,    1674, 1711, 1710,    1674, 1676, 1711,    1676, 1712, 1711,
    1676, 1713, 1712,    1713, 1714, 1712,    1713, 1715, 1714,    1679, 1716, 1717,    1679, 1680, 1716,
    1680, 1718, 1716,    1680, 1681, 1718,    1681, 1719, 1718,    1681, 1682, 1719,    1682, 1720, 1719,
    1682, 1683, 1720,    1721, 1722, 1723,    1721, 1724, 1722,    1724, 1725, 1722,    1724, 1688, 1725,
    1688, 1726, 1725,    1688, 1687, 1726,    1687, 1727, 1726,    1687, 1690, 1727,    1690, 1728, 1727,
    1690, 1692, 1728,    1692, 1729, 1728,    1692, 1694, 1729,    1694, 1730, 1729,    1694, 1696, 1730,
    1696, 1731, 1730,    1696, 1732, 1731,    1698, 1733, 1734,    1698, 1699, 1733,    1699, 1701, 1733,
    1699, 1665, 1701,    1735, 1736, 1737,    1735, 1738, 1736,    1738, 1739, 1736,    1738, 1740, 1739,
    1741, 1742, 1743,    1741, 1706, 1742,    1706, 1744, 1742,    1706, 1705, 1744,    1705, 1708, 1744,
    1744, 1708, 1745,    1746, 1745, 1708,    1708, 1709, 1747,    1748, 1747, 1709,    1709, 1710, 1748,
    1749, 1711, 1750,    1711, 1751, 1750,    1711, 1712, 1751,    1712, 1752, 1751,    1712, 1714, 1752,
    1714, 1753, 1752,    1714, 1754, 1753,    1755, 1756, 1757,    1755, 1758, 1756,    1758, 1759, 1756,
    1758, 1760, 1759,    1760, 1761, 1759,    1760, 1762, 1761,    1723, 1763, 1764,    1723, 1722, 1763,
    1722, 1765, 1763,    1722, 1725, 1765,    1725, 1766, 1765,    1725, 1726, 1766,    1726, 1767, 1766,
    1726, 1727, 1767,    1727, 1768, 1767,    1727, 1728, 1768,    1728, 1769, 1768,    1728, 1729, 1769,
    1729, 1770, 1769,    1729, 1730, 1770,    1730, 1771, 1770,    1730, 1731, 1771,    1731, 1772, 1771,
    1731, 1773, 1772,    1774, 1737, 1775,    1774, 1735, 1737,    1737, 1776, 1777,    1737, 1736, 1776,
    1736, 1778, 1776,    1736, 1739, 1778,    1743, 1779, 1780,    1743, 1742, 1779,    1742, 1781, 1779,
    1742, 1744, 1781,    1744, 1782, 1783,    1784, 1785, 1786,    1785, 1784, 1751,    1751, 1787, 1785,
    1751, 1752, 1787,    1752, 1788, 1787,    1752, 1753, 1788,    1757, 1789, 1790,    1757, 1756, 1789,
    1756, 1791, 1789,    1756, 1759, 1791,    1759, 1792, 1791,    1759, 1761, 1792,    1764, 1793, 1794,
    1764, 1763, 1793,    1763, 1795, 1793,    1763, 1765, 1795,    1765, 1796, 1795,    1765, 1766, 1796,
    1766, 1797, 1796,    1766, 1767, 1797,    1767, 1798, 1797,    1767, 1768, 1798,    1768, 1799, 1798,
    1768, 1769, 1799,    1769, 1800, 1799,    1769, 1770, 1800,    1770, 1801, 1800,    1770, 1771, 1801,
    1771, 1802, 1801,    1771, 1772, 1802,    1775, 1777, 1803,    1775, 1737, 1777,    1777, 1804, 1805,
    1777, 1776, 1804,    1776, 1806, 1804,    1776, 1778, 1806,    1780, 1807, 1808,    1780, 1779, 1807,
    1779, 1809, 1807,    1779, 1781, 1809,    1781, 1810, 1811,    1812, 1813, 1814,    1785, 1815, 1814,
    1785, 1787, 1815,    1787, 1816, 1815,    1787, 1788, 1816,    1790, 1817, 1818,    1790, 1789, 1817,
    1789, 1819, 1817,    1789, 1791, 1819,    1791, 1820, 1819,    1791, 1792, 1820,    1794, 1821, 1822,
    1794, 1793, 1821,    1793, 1823, 1821,    1793, 1795, 1823,    1795, 1824, 1823,    1795, 1796, 1824,
    1796, 1825, 1824,    1796, 1797, 1825,    1797, 1826, 1825,    1797, 1798, 1826,    1798, 1827, 1826,
    1798, 1799, 1827,    1799, 1828, 1827,    1799, 1800, 1828,    1800, 1829, 1828,    1800, 1801, 1829,
    1801, 1830, 1829,    1801, 1802, 1830,    1803, 1805, 1831,    1803, 1777, 1805,    1805, 1832, 1833,
    1805, 1804, 1832,    1804, 1834, 1832,    1804, 1806, 1834,    1808, 1835, 1836,    1808, 1807, 1835,
    1807, 1837, 1835,    1807, 1809, 1837,    1809, 1838, 1837,    1837, 1839, 1840,    1839, 1837, 1838,
    1841, 1842, 1840,    1843, 1844, 1845,    1846, 1845, 1844,    1847, 1848, 1846,    1849, 1846, 1848,
    1849, 1812, 1850,    1814, 1850, 1812,    1814, 1851, 1850,    1814, 1815, 1851,    1815, 1852, 1851,
    1815, 1816, 1852,    1818, 1853, 1854,    1818, 1817, 1853,    1817, 1855, 1853,    1817, 1819, 1855,
    1819, 1856, 1855,    1819, 1820, 1856,    1822, 1857, 1858,    1822, 1821, 1857,    1821, 1859, 1857,
    1821, 1823, 1859,    1823, 1860, 1859,    1823, 1824, 1860,    1824, 1861, 1860,    1824, 1825, 1861,
    1825, 1862, 1861,    1825, 1826, 1862,    1826, 1863, 1862,    1826, 1827, 1863,    1827, 1864, 1863,
    1827, 1828, 1864,    1828, 1865, 1864,    1828, 1829, 1865,    1829, 1866, 1865,    1829, 1830, 1866,
    1831, 1833, 1867,    1831, 1805, 1833,    1868, 1869, 1870,    1868, 1871, 1869,    1871, 1872, 1869,
    1871, 1873, 1872,    1836, 1874, 1875,    1836, 1835, 1874,    1835, 1876, 1874,    1835, 1837, 1876,
    1837, 1877, 1876,    1837, 1840, 1877,    1840, 1878, 1877,    1840, 1845, 1878,    1845, 1879, 1878,
    1845, 1846, 1879,    1846, 1880, 1879,    1846, 1849, 1880,    1849, 1881, 1880,    1849, 1850, 1881,
    1850, 1882, 1881,    1850, 1851, 1882,    1883, 1884, 1885,    1883, 1886, 1884,    1886, 1887, 1884,
    1886, 1888, 1887,    1888, 1889, 1887,    1888, 1890, 1889,    1890, 1891, 1889,    1890, 1892, 1891,
    1892, 1893, 1891,    1892, 1894, 1893,    1857, 1895, 1896,    1857, 1859, 1895,    1859, 1897, 1895,
    1859, 1860, 1897,    1860, 1898, 1897,    1860, 1861, 1898,    1861, 1899, 1898,    1861, 1862, 1899,
    1862, 1900, 1899,    1862, 1863, 1900,    1863, 1901, 1900,    1863, 1864, 1901,    1864, 1902, 1901,
    1864, 1865, 1902,    1903, 1904, 1905,    1903, 1906, 1904,    1906, 1870, 1904,    1906, 1868, 1870,
    1870, 1907, 1908,    1870, 1869, 1907,    1869, 1909, 1907,    1869, 1872, 1909,    1872, 1910, 1909,
    1872, 1911, 1910,    1911, 1912, 1910,    1911, 1913, 1912,    1876, 1914, 1915,    1876, 1877, 1914,
    1877, 1916, 1914,    1877, 1878, 1916,    1878, 1917, 1916,    1878, 1879, 1917,    1879, 1918, 1917,
    1879, 1880, 1918,    1919, 1920, 1921,    1919, 1922, 1920,    1922, 1923, 1920,    1922, 1885, 1923,
    1885, 1924, 1923,    1885, 1884, 1924,    1884, 1925, 1924,    1884, 1887, 1925,    1887, 1926, 1925,
    1887, 1889, 1926,    1889, 1927, 1926,    1889, 1891, 1927,    1891, 1928, 1927,    1891, 1893, 1928,
    1893, 1929, 1928,    1893, 1930, 1929,    1930, 1931, 1929,    1930, 1932, 1931,    1897, 1933, 1934,
    1897, 1898, 1933,    1898, 1935, 1933,    1898, 1899, 1935,    1936, 1937, 1938,    1936, 1939, 1937,
    1939, 1940, 1937,    1939, 1941, 1940,    1941, 1942, 1940,    1941, 1905, 1942,    1905, 1943, 1942,
    1905, 1904, 1943,    1904, 1908, 1943,    1904, 1870, 1908,    1908, 1944, 1945,    1908, 1907, 1944,
    1907, 1946, 1944,    1907, 1909, 1946,    1909, 1947, 1946,    1909, 1910, 1947,    1910, 1948, 1947,
    1910, 1912, 1948,    1912, 1949, 1948,    1912, 1950, 1949,    1950, 1951, 1949,    1950, 1952, 1951,
    1952, 1953, 1951,    1952, 1954, 1953,    1954, 1955, 1953,    1954, 1921, 1955,    1921, 1956, 1955,
    1921, 1920, 1956,    1920, 1957, 1956,    1920, 1923, 1957,    1923, 1958, 1957,    1923, 1924, 1958,
    1924, 1959, 1958,    1924, 1925, 1959,    1925, 1960, 1959,    1925, 1926, 1960,    1926, 1961, 1960,
    1926, 1927, 1961,    1927, 1962, 1961,    1927, 1928, 1962,    1928, 1963, 1962,    1928, 1929, 1963,
    1929, 1964, 1963,    1929, 1931, 1964,    1931, 1965, 1964,    1931, 1966, 1965,    1966, 1967, 1965,
    1966, 1938, 1967,    1938, 1968, 1967,    1938, 1937, 1968,    1937, 1969, 1968,    1937, 1940, 1969,
    1940, 1970, 1969,    1940, 1942, 1970,    1942, 1971, 1970,    1942, 1943, 1971,    1943, 1945, 1971,
    1943, 1908, 1945,    1972, 1945, 1944,    1972, 1944, 1946,    1972, 1946, 1947,    1972, 1947, 1948,
    1972, 1948, 1949,    1972, 1949, 1951,    1972, 1951, 1953,    1972, 1953, 1955,    1972, 1955, 1956,
    1972, 1956, 1957,    1972, 1957, 1958,    1972, 1958, 1959,    1972, 1959, 1960,    1972, 1960, 1961,
    1972, 1961, 1962,    1972, 1962, 1963,    1972, 1963, 1964,    1972, 1964, 1965,    1972, 1965, 1967,
    1972, 1967, 1968,    1972, 1968, 1969,    1972, 1969, 1970,    1972, 1970, 1971,    1972, 1971, 1945,
    1708, 1747, 1973,    1748, 1710, 1974,    1975, 1976, 1710,    1708, 1973, 1746,    1744, 1745, 1782,
    1744, 1783, 1781,    1783, 1977, 1781,    1781, 1977, 1810,    1781, 1811, 1809,    1811, 1978, 1809,
    1809, 1978, 1979,    1809, 1979, 1838,    1840, 1839, 1841,    1840, 1842, 1845,    1842, 1980, 1845,
    1845, 1980, 1843,    1846, 1844, 1981,    1846, 1981, 1847,    1849, 1848, 1982,    1849, 1982, 1983,
    1814, 1813, 1785,    1813, 1984, 1785,    1812, 1849, 1983,    1785, 1984, 1985,    1785, 1985, 1786,
    1751, 1784, 1986,    1751, 1986, 1987,    1711, 1749, 1710,    1749, 1988, 1710,    1750, 1751, 1987,
    1710, 1988, 1975,    1710, 1976, 1974,    1989, 1990, 1991,    1989, 1992, 1990,    1989, 1991, 1993,
    1989, 1994, 1992,    1989, 1995, 1994,    1989, 1996, 1995,    1989, 1997, 1996,    1989, 1998, 1997,
    1989, 1999, 1998,    1989, 2000, 1999,    1989, 2001, 2000,    1989, 2002, 2001,    1989, 2003, 2002,
    1989, 2004, 2003,    1989, 2005, 2004,    1989, 2006, 2005,    1989, 2007, 2006,    1989, 2008, 2007,
    1989, 2009, 2008,    1989, 2010, 2009,    1989, 2011, 2010,    1989, 2012, 2011,    1989, 2013, 2012,
    1989, 1993, 2013,    2014, 1994, 1995,    2015, 2016, 2017,    2017, 2018, 2015,    2014, 1995, 2019,
    2020, 2021, 2016,    2022, 2023, 2021,    2021, 2020, 2022,    2024, 2025, 1992,    2020, 2016, 2026,
    2027, 2028, 2023,    2029, 2030, 2028,    2028, 2027, 2029,    2022, 2031, 2023,    2027, 2023, 2031,
    2032, 2012, 2013,    2033, 2011, 2012,    2012, 2032, 2033,    2029, 2034, 2030,    2032, 2013, 2035,
    2036, 1996, 1997,    2037, 1995, 1996,    1996, 2036, 2037,    1997, 2038, 2039,    2036, 1997, 2039,
    2019, 1995, 2037,    2040, 2010, 2011,    2041, 2009, 2010,    2010, 2040, 2041,    2042, 2043, 2011,
    2040, 2011, 2043,    2044, 2045, 2046,    2042, 2011, 2033,    2047, 2048, 2049,    2050, 1998, 1999,
    2038, 1997, 2050,    1998, 2050, 1997,    2051, 1999, 2000,    2050, 1999, 2051,    2000, 2052, 2053,
    2054, 2055, 2056,    2057, 2007, 2008,    2058, 2006, 2007,    2007, 2057, 2058,    2059, 2008, 2009,
    2057, 2008, 2059,    2041, 2060, 2009,    2059, 2009, 2060,    2061, 2062, 2063,    2064, 2055, 2063,
    2061, 2063, 2055,    2065, 2066, 2067,    2062, 2061, 2065,    2066, 2065, 2061,    2067, 2068, 2069,
    2065, 2067, 2069,    2070, 2071, 2072,    2068, 2067, 2070,    2071, 2070, 2067,    2070, 2073, 2074,
    2058, 2075, 2006,    2076, 2005, 2075,    2006, 2075, 2005,    2077, 2078, 2079,    2074, 2072, 2080,
    2070, 2072, 2073,    2073, 2072, 2074,    2081, 2082, 2083,    2081, 2084, 2082,    2081, 2085, 2084,
    2081, 2086, 2085,    2081, 2087, 2086,    2081, 2088, 2087,    2081, 2089, 2088,    2081, 2090, 2089,
    2081, 2091, 2090,    2081, 2092, 2091,    2081, 2093, 2092,    2081, 2094, 2093,    2081, 2095, 2094,
    2081, 2096, 2095,    2081, 2097, 2096,    2081, 2098, 2097,    2081, 2099, 2098,    2081, 2100, 2099,
    2081, 2101, 2100,    2081, 2102, 2101,    2081, 2103, 2102,    2081, 2104, 2103,    2081, 2105, 2104,
    2081, 2083, 2105,    2083, 2106, 2107,    2083, 2082, 2106,    2082, 2108, 2106,    2082, 2084, 2108,
    2084, 2109, 2108,    2084, 2085, 2109,    2085, 2110, 2109,    2085, 2086, 2110,    2086, 2111, 2110,
    2086, 2087, 2111,    2087, 2112, 2111,    2087, 2088, 2112,    2088, 2113, 2112,    2088, 2089, 2113,
    2089, 2114, 2113,    2089, 2090, 2114,    2090, 2115, 2114,    2090, 2091, 2115,    2091, 2116, 2115,
    2091, 2092, 2116,    2092, 2117, 2116,    2092, 2093, 2117,    2093, 2118, 2117,    2093, 2094, 2118,
    2094, 2119, 2118,    2094, 2095, 2119,    2095, 2120, 2119,    2095, 2096, 2120,    2096, 2121, 2120,
    2096, 2097, 2121,    2097, 2122, 2121,    2097, 2098, 2122,    2098, 2123, 2122,    2098, 2099, 2123,
    2099, 2124, 2123,    2099, 2100, 2124,    2100, 2125, 2124,    2100, 2101, 2125,    2101, 2126, 2125,
    2101, 2102, 2126,    2102, 2127, 2126,    2102, 2103, 2127,    2103, 2128, 2127,    2103, 2104, 2128,
    2104, 2129, 2128,    2104, 2105, 2129,    2105, 2107, 2129,    2105, 2083, 2107,    2130, 2131, 2132,
    2130, 2133, 2131,    2106, 2134, 2135,    2106, 2108, 2134,    2108, 2136, 2134,    2108, 2109, 2136,
    2137, 2138, 2139,    2137, 2140, 2138,    2140, 2141, 2138,    2140, 2142, 2141,    2142, 2143, 2141,
    2142, 2144, 2143,    2144, 2145, 2143,    2144, 2146, 2145,    2113, 2147, 2148,    2113, 2114, 2147,
    2114, 2149, 2147,    2114, 2115, 2149,    2115, 2150, 2149,    2115, 2116, 2150,    2116, 2151, 2150,
    2116, 2117, 2151,    2117, 2152, 2151,    2117, 2118, 2152,    2118, 2153, 2152,    2118, 2119, 2153,
    2119, 2154, 2153,    2119, 2120, 2154,    2120, 2155, 2154,    2120, 2121, 2155,    2121, 2156, 2155,
    2121, 2122, 2156,    2157, 2158, 2159,    2157, 2160, 2158,    2160, 2161, 2158,    2160, 2162, 2161,
    2162, 2163, 2161,    2162, 2164, 2163,    2164, 2165, 2163,    2164, 2166, 2165,    2166, 2167, 2165,
    2166, 2168, 2167,    2168, 2169, 2167,    2168, 2170, 2169,    2128, 2171, 2172,    2128, 2129, 2171,
    2173, 2132, 2174,    2173, 2130, 2132,    2175, 2176, 2177,    2177, 2178, 2175,    2179, 2180, 2181,
    2181, 2182, 2179,    2183, 2179, 2182,    2182, 2184, 2183,    2185, 2183, 2184,    2184, 2186, 2185,
    2187, 2185, 2186,    2186, 2188, 2187,    2189, 2187, 2188,    2188, 2190, 2189,    2191, 2189, 2190,
    2190, 2192, 2191,    2193, 2191, 2192,    2192, 2194, 2193,    2195, 2193, 2194,    2194, 2196, 2195,
    2197, 2195, 2196,    2196, 2198, 2197,    2199, 2197, 2198,    2198, 2200, 2199,    2201, 2202, 2203,
    2203, 2204, 2201,    2205, 2201, 2204,    2204, 2206, 2205,    2207, 2208, 2209,    2209, 2210, 2207,
    2211, 2207, 2210,    2210, 2212, 2211,    2213, 2211, 2212,    2212, 2214, 2213,    2215, 2213, 2214,
    2214, 2216, 2215,    2217, 2215, 2216,    2216, 2218, 2217,    2219, 2217, 2218,    2218, 2220, 2219,
    2221, 2219, 2220,    2220, 2222, 2221,    2223, 2221, 2222,    2222, 2224, 2223,    2225, 2223, 2224,
    2224, 2226, 2225,    2227, 2225, 2226,    2226, 2228, 2227,    2176, 2229, 2230,    2230, 2177, 2176,

};

D3DMATRIX g_tmat73 = 
{
    -0.363944f, -0.921652f, 0.134548f, 0.000000f, 
    -0.152638f, -0.083485f, -0.984750f, 0.000000f, 
    0.918829f, -0.378931f, -0.110295f, 0.000000f, 
    0.334322f, -2.647761f, 1.540812f, 1.000000f, 
};

// Mesh #73 Tris:56 Verts:89
MODELVERT g_tmesh73[] = 
{
    { {-0.221663f, 0.026519f, -0.029924f}, {-0.481677f, 0.018348f, 0.876157f}, {0.298617f, 0.281047f} },
    { {-0.000000f, -0.003976f, -0.019619f}, {-0.032627f, 0.059165f, 0.997715f}, {0.364909f, 0.272266f} },
    { {-0.103317f, -0.205461f, -0.030516f}, {-0.388521f, -0.364599f, 0.846238f}, {0.334010f, 0.214252f} },
    { {-0.000000f, 0.020170f, -0.156860f}, {-0.012108f, 0.147609f, -0.988972f}, {0.355247f, 0.279218f} },
    { {-0.163641f, 0.157414f, -0.115789f}, {-0.316744f, 0.480629f, -0.817722f}, {0.404187f, 0.318735f} },
    { {-0.221663f, 0.036815f, -0.134890f}, {-0.570049f, 0.233977f, -0.787590f}, {0.421540f, 0.284011f} },
    { {-0.171178f, 0.155909f, 0.060423f}, {-0.290617f, 0.268225f, -0.918475f}, {0.318048f, 0.286669f} },
    { {-0.221663f, 0.045788f, 0.166104f}, {-0.711787f, 0.279293f, 0.644480f}, {0.350243f, 0.320025f} },
    { {-0.221663f, 0.026519f, 0.048235f}, {-0.379900f, 0.046362f, -0.923865f}, {0.355876f, 0.282822f} },
    { {-0.158446f, -0.132690f, 0.226689f}, {-0.317782f, -0.640520f, 0.699105f}, {0.317523f, 0.235205f} },
    { {-0.000000f, 0.020223f, 0.185665f}, {0.066462f, 0.255634f, 0.964486f}, {0.364909f, 0.279234f} },
    { {-0.103317f, -0.198469f, 0.154351f}, {0.280693f, -0.593913f, 0.753975f}, {0.337446f, 0.227042f} },
    { {-0.163641f, 0.161410f, 0.126855f}, {-0.251096f, 0.551780f, 0.795292f}, {0.315969f, 0.319886f} },
    { {-0.221663f, 0.045788f, 0.166104f}, {-0.711787f, 0.279293f, 0.644480f}, {0.298617f, 0.286595f} },
    { {-0.000000f, -0.003976f, 0.037930f}, {-0.031440f, 0.068544f, -0.997153f}, {0.355247f, 0.272266f} },
    { {-0.171178f, 0.155909f, 0.060423f}, {-0.290617f, 0.268225f, -0.918475f}, {0.406441f, 0.318302f} },
    { {-0.221663f, 0.026519f, 0.048235f}, {-0.379900f, 0.046362f, -0.923865f}, {0.421540f, 0.281046f} },
    { {-0.163641f, 0.157414f, -0.115789f}, {-0.316744f, 0.480629f, -0.817722f}, {0.317608f, 0.231051f} },
    { {-0.171178f, 0.155909f, -0.042112f}, {-0.413953f, 0.341882f, 0.843658f}, {0.318048f, 0.254306f} },
    { {-0.221663f, 0.036815f, -0.134890f}, {-0.570049f, 0.233977f, -0.787590f}, {0.352866f, 0.225022f} },
    { {-0.047997f, 0.225365f, -0.042112f}, {-0.058365f, 0.455646f, 0.888245f}, {0.350555f, 0.338300f} },
    { {-0.171178f, 0.155909f, -0.042112f}, {-0.413953f, 0.341882f, 0.843658f}, {0.313715f, 0.318302f} },
    { {-0.198769f, -0.094779f, -0.155732f}, {-0.591921f, -0.296227f, -0.749586f}, {0.414693f, 0.246121f} },
    { {-0.103317f, -0.198469f, -0.136040f}, {-0.238862f, -0.388868f, -0.889790f}, {0.386146f, 0.216265f} },
    { {-0.198769f, -0.094779f, -0.155732f}, {-0.591921f, -0.296227f, -0.749586f}, {0.391339f, 0.218444f} },
    { {-0.221663f, 0.026519f, -0.029924f}, {-0.481677f, 0.018348f, 0.876157f}, {0.355876f, 0.258153f} },
    { {-0.207924f, -0.111188f, -0.042112f}, {-0.858257f, -0.438526f, 0.266626f}, {0.396136f, 0.254306f} },
    { {-0.000000f, -0.003976f, 0.037930f}, {0.893619f, -0.446314f, 0.047421f}, {0.355365f, 0.279569f} },
    { {-0.103317f, -0.198469f, 0.154351f}, {0.893619f, -0.446314f, 0.047421f}, {0.298503f, 0.316315f} },
    { {-0.000000f, 0.020223f, 0.185665f}, {0.897911f, -0.434387f, 0.071155f}, {0.362440f, 0.326199f} },
    { {0.092705f, 0.211197f, 0.060423f}, {0.132270f, 0.421629f, -0.897070f}, {0.327522f, 0.286669f} },
    { {0.190779f, 0.127616f, 0.138327f}, {0.211404f, 0.604728f, 0.767862f}, {0.311419f, 0.305965f} },
    { {-0.045884f, 0.224285f, 0.105513f}, {0.030370f, 0.557933f, 0.829330f}, {0.368970f, 0.300900f} },
    { {-0.103317f, -0.198469f, -0.136040f}, {0.895365f, -0.441713f, -0.056657f}, {0.298503f, 0.224659f} },
    { {-0.000000f, -0.003976f, -0.019619f}, {0.895365f, -0.441713f, -0.056657f}, {0.355365f, 0.261405f} },
    { {-0.000000f, 0.020170f, -0.156860f}, {0.898707f, -0.431915f, -0.075992f}, {0.362424f, 0.218088f} },
    { {0.088623f, 0.209617f, -0.107520f}, {0.178283f, 0.625327f, -0.759724f}, {0.328743f, 0.233661f} },
    { {0.153297f, 0.173150f, -0.042112f}, {0.455449f, 0.797992f, 0.394684f}, {0.309401f, 0.254306f} },
    { {-0.047997f, 0.225365f, -0.042112f}, {-0.058365f, 0.455646f, 0.888245f}, {0.369602f, 0.254306f} },
    { {-0.103317f, -0.201073f, 0.049810f}, {-0.388787f, -0.386740f, -0.836228f}, {0.386146f, 0.215515f} },
    { {-0.207924f, -0.111188f, 0.060423f}, {-0.898142f, -0.427644f, -0.102285f}, {0.315341f, 0.286669f} },
    { {-0.158446f, -0.132690f, 0.226689f}, {-0.317782f, -0.640520f, 0.699105f}, {0.317523f, 0.339147f} },
    { {-0.103317f, -0.201073f, 0.049810f}, {-0.388787f, -0.386740f, -0.836228f}, {0.332587f, 0.286269f} },
    { {0.092705f, 0.211197f, 0.060423f}, {0.132270f, 0.421629f, -0.897070f}, {0.327522f, 0.334221f} },
    { {0.190779f, 0.112933f, 0.048235f}, {0.236695f, 0.348719f, -0.906846f}, {0.391194f, 0.286669f} },
    { {0.190779f, 0.127616f, 0.138327f}, {0.211404f, 0.604728f, 0.767862f}, {0.393837f, 0.311258f} },
    { {0.092705f, 0.211197f, 0.060423f}, {0.132270f, 0.421629f, -0.897070f}, {0.407150f, 0.286669f} },
    { {-0.047997f, 0.225365f, 0.060423f}, {-0.284579f, 0.833628f, -0.473369f}, {0.369602f, 0.286669f} },
    { {-0.163641f, 0.161410f, 0.126855f}, {-0.251096f, 0.551780f, 0.795292f}, {0.316439f, 0.307637f} },
    { {-0.163641f, 0.157414f, -0.115789f}, {-0.316744f, 0.480629f, -0.817722f}, {0.404187f, 0.231051f} },
    { {-0.171178f, 0.155909f, -0.042112f}, {-0.413953f, 0.341882f, 0.843658f}, {0.406441f, 0.254306f} },
    { {-0.045884f, 0.222994f, -0.105402f}, {-0.069427f, 0.474483f, -0.877522f}, {0.368970f, 0.234330f} },
    { {-0.198769f, -0.080376f, 0.208931f}, {-0.553133f, 0.085387f, 0.828706f}, {0.305464f, 0.250268f} },
    { {-0.207924f, -0.111188f, 0.060423f}, {-0.898142f, -0.427644f, -0.102285f}, {0.396136f, 0.286669f} },
    { {-0.198769f, -0.080376f, 0.208931f}, {-0.553133f, 0.085387f, 0.828706f}, {0.387128f, 0.333542f} },
    { {0.190779f, 0.112933f, -0.029924f}, {0.091667f, 0.173273f, 0.980599f}, {0.421965f, 0.305928f} },
    { {-0.000000f, 0.020170f, -0.156860f}, {0.508988f, -0.848486f, -0.144924f}, {0.364909f, 0.218088f} },
    { {-0.000000f, -0.003976f, -0.019619f}, {0.510806f, -0.846691f, -0.148968f}, {0.364909f, 0.261405f} },
    { {0.190779f, 0.112933f, -0.029924f}, {0.508988f, -0.848486f, -0.144924f}, {0.421965f, 0.258153f} },
    { {0.088623f, 0.209617f, -0.107520f}, {0.178283f, 0.625327f, -0.759724f}, {0.328743f, 0.333766f} },
    { {-0.045884f, 0.222994f, -0.105402f}, {-0.069427f, 0.474483f, -0.877522f}, {0.368970f, 0.337618f} },
    { {0.190779f, 0.127616f, -0.120016f}, {0.506182f, -0.851196f, -0.138725f}, {0.421965f, 0.229717f} },
    { {0.190779f, 0.127616f, 0.138327f}, {0.211404f, 0.604728f, 0.767862f}, {0.421965f, 0.310155f} },
    { {-0.045884f, 0.224285f, 0.105513f}, {0.030370f, 0.557933f, 0.829330f}, {0.351187f, 0.337989f} },
    { {0.190779f, 0.112933f, 0.048235f}, {0.511851f, -0.847818f, 0.138610f}, {0.421965f, 0.282822f} },
    { {-0.000000f, 0.020223f, 0.185665f}, {0.511851f, -0.847818f, 0.138610f}, {0.364909f, 0.326199f} },
    { {0.190779f, 0.127616f, 0.138327f}, {0.511649f, -0.848006f, 0.138204f}, {0.421965f, 0.311258f} },
    { {0.190779f, 0.112933f, 0.048235f}, {0.236695f, 0.348719f, -0.906846f}, {0.298191f, 0.305928f} },
    { {-0.000000f, -0.003976f, 0.037930f}, {0.511973f, -0.847704f, 0.138858f}, {0.364909f, 0.279569f} },
    { {-0.103317f, -0.205461f, -0.030516f}, {0.890090f, -0.454787f, -0.030136f}, {0.296458f, 0.257966f} },
    { {-0.198769f, -0.094779f, -0.155732f}, {-0.591921f, -0.296227f, -0.749586f}, {0.317523f, 0.215716f} },
    { {-0.103317f, -0.205461f, -0.030516f}, {-0.388521f, -0.364599f, 0.846238f}, {0.334010f, 0.257966f} },
    { {-0.103317f, -0.198469f, -0.136040f}, {-0.238862f, -0.388868f, -0.889790f}, {0.334010f, 0.224659f} },
    { {-0.103317f, -0.201073f, 0.049810f}, {0.885920f, -0.463695f, 0.011552f}, {0.297741f, 0.283319f} },
    { {-0.103317f, -0.201073f, 0.049810f}, {-0.388787f, -0.386740f, -0.836228f}, {0.424166f, 0.286269f} },
    { {-0.158446f, -0.132690f, 0.226689f}, {-0.317782f, -0.640520f, 0.699105f}, {0.402423f, 0.339147f} },
    { {-0.103317f, -0.198469f, 0.154351f}, {0.280693f, -0.593913f, 0.753975f}, {0.424326f, 0.308463f} },
    { {-0.047997f, 0.225365f, 0.060423f}, {-0.284579f, 0.833628f, -0.473369f}, {0.369602f, 0.338300f} },
    { {-0.171178f, 0.155909f, 0.060423f}, {-0.290617f, 0.268225f, -0.918475f}, {0.406441f, 0.286669f} },
    { {-0.163641f, 0.161410f, 0.126855f}, {-0.251096f, 0.551780f, 0.795292f}, {0.404187f, 0.307637f} },
    { {-0.207924f, -0.111188f, 0.060423f}, {-0.898142f, -0.427644f, -0.102285f}, {0.417431f, 0.241396f} },
    { {0.190779f, 0.127616f, -0.120016f}, {0.365411f, 0.487861f, -0.792759f}, {0.311419f, 0.231865f} },
    { {0.190779f, 0.127616f, -0.120016f}, {0.365411f, 0.487861f, -0.792759f}, {0.298191f, 0.310155f} },
    { {-0.207924f, -0.111188f, -0.042112f}, {-0.858257f, -0.438526f, 0.266626f}, {0.315341f, 0.254306f} },
    { {-0.207924f, -0.111188f, -0.042112f}, {-0.858257f, -0.438526f, 0.266626f}, {0.302726f, 0.241396f} },
    { {0.153297f, 0.173150f, -0.042112f}, {0.455449f, 0.797992f, 0.394684f}, {0.410756f, 0.323266f} },
    { {0.190779f, 0.127616f, -0.120016f}, {0.365411f, 0.487861f, -0.792759f}, {0.393837f, 0.229717f} },
    { {0.190779f, 0.112933f, -0.029924f}, {0.091667f, 0.173273f, 0.980599f}, {0.391194f, 0.254306f} },
    { {0.153297f, 0.173150f, -0.042112f}, {0.455449f, 0.797992f, 0.394684f}, {0.407150f, 0.254306f} },
};

WORD g_tind73[] = 
{
    2, 1, 0,    5, 4, 3,    8, 7, 6,    11, 10, 9,    13, 10, 12,
    16, 15, 14,    19, 18, 17,    21, 1, 20,    23, 22, 3,    26, 25, 24,
    29, 28, 27,    32, 31, 30,    35, 34, 33,    38, 37, 36,    39, 16, 14,
    42, 41, 40,    15, 43, 14,    46, 45, 44,    47, 32, 30,    7, 48, 6,
    50, 38, 49,    51, 38, 36,    52, 10, 13,    54, 7, 53,    24, 25, 19,
    22, 5, 3,    20, 1, 55,    58, 57, 56,    60, 59, 3,    61, 58, 56,
    63, 10, 62,    66, 65, 64,    43, 67, 14,    64, 65, 68,    34, 69, 33,
    72, 71, 70,    27, 28, 73,    76, 75, 74,    0, 1, 21,    25, 18, 19,
    15, 77, 43,    79, 47, 78,    49, 38, 51,    4, 60, 3,    39, 80, 16,
    53, 7, 8,    12, 10, 63,    79, 32, 47,    36, 37, 81,    59, 82, 3,
    71, 83, 70,    2, 0, 84,    9, 10, 52,    75, 54, 53,    20, 55, 85,
    88, 87, 86,
};

D3DMATRIX g_tmat74 = 
{
    0.994840f, -0.098402f, -0.024713f, 0.000000f, 
    0.095936f, 0.991626f, -0.086452f, 0.000000f, 
    0.033013f, 0.083635f, 0.995950f, 0.000000f, 
    1.070430f, -2.619616f, 2.366167f, 1.000000f, 
};

// Mesh #74 Tris:146 Verts:116
MODELVERT g_tmesh74[] = 
{
    { {-0.204615f, -0.052252f, 0.244361f}, {-0.997512f, 0.000287f, -0.070495f}, {0.295499f, 0.340509f} },
    { {-0.208380f, -0.178780f, 0.207417f}, {-0.998686f, 0.046078f, -0.022408f}, {0.295499f, 0.340509f} },
    { {-0.179375f, -0.058920f, 0.274322f}, {-0.772263f, -0.120768f, 0.623718f}, {0.295499f, 0.340509f} },
    { {-0.183372f, -0.193263f, 0.235096f}, {-0.780661f, -0.292446f, 0.552307f}, {0.295499f, 0.340509f} },
    { {-0.211390f, -0.278557f, 0.130977f}, {-0.997187f, -0.068817f, -0.029689f}, {0.295499f, 0.340509f} },
    { {-0.186203f, -0.287112f, 0.163198f}, {-0.643656f, -0.754834f, 0.126220f}, {0.295499f, 0.340509f} },
    { {-0.135943f, -0.333287f, -0.126742f}, {-0.601154f, -0.798625f, -0.028503f}, {0.295499f, 0.340509f} },
    { {-0.162842f, -0.312045f, 0.167306f}, {-0.728235f, -0.685113f, -0.017125f}, {0.295499f, 0.340509f} },
    { {-0.185411f, -0.326965f, 0.139068f}, {-0.962878f, 0.185848f, -0.195773f}, {0.295499f, 0.340509f} },
    { {-0.185870f, -0.342601f, 0.156927f}, {-0.997260f, 0.034366f, -0.065508f}, {0.295499f, 0.340509f} },
    { {-0.162842f, -0.312045f, 0.167306f}, {-0.540499f, 0.841252f, -0.012487f}, {0.295499f, 0.340509f} },
    { {-0.163387f, -0.330634f, 0.188538f}, {-0.825536f, 0.072620f, 0.559657f}, {0.295499f, 0.340509f} },
    { {-0.187322f, -0.390580f, 0.152904f}, {-0.996924f, 0.056607f, -0.054204f}, {0.295499f, 0.340509f} },
    { {-0.165450f, -0.398800f, 0.182822f}, {-0.817208f, -0.169667f, 0.550803f}, {0.295499f, 0.340509f} },
    { {-0.189934f, -0.476099f, 0.114256f}, {-0.988502f, -0.122454f, -0.088701f}, {0.295499f, 0.340509f} },
    { {-0.168523f, -0.499396f, 0.137361f}, {-0.823490f, -0.253447f, 0.507571f}, {0.295499f, 0.340509f} },
    { {-0.168884f, -0.510924f, 0.121265f}, {-0.845998f, -0.442281f, -0.297783f}, {0.325762f, 0.243112f} },
    { {-0.138224f, -0.406054f, -0.100942f}, {-0.967031f, -0.036549f, -0.252022f}, {0.295499f, 0.340509f} },
    { {-0.123205f, -0.432462f, -0.118509f}, {-0.911058f, -0.233934f, -0.339482f}, {0.335287f, 0.310600f} },
    { {-0.117891f, -0.360194f, -0.142061f}, {-0.960872f, -0.069518f, -0.268126f}, {0.295499f, 0.340509f} },
    { {-0.104243f, -0.364182f, -0.179382f}, {-0.901261f, 0.005910f, -0.433236f}, {0.295499f, 0.340509f} },
    { {-0.135943f, -0.333287f, -0.126742f}, {-0.934745f, 0.255390f, -0.247039f}, {0.295499f, 0.340509f} },
    { {-0.103255f, -0.333528f, -0.161490f}, {-0.669164f, 0.390569f, -0.632199f}, {0.295499f, 0.340509f} },
    { {-0.173710f, -0.298176f, -0.178653f}, {-0.725450f, -0.667070f, -0.169531f}, {0.295499f, 0.340509f} },
    { {-0.103255f, -0.333528f, -0.161490f}, {-0.357730f, -0.873389f, -0.330486f}, {0.295499f, 0.340509f} },
    { {-0.196568f, -0.276350f, -0.155346f}, {-0.989890f, 0.047741f, -0.133562f}, {0.295499f, 0.340509f} },
    { {-0.154796f, -0.209830f, -0.263899f}, {-0.918009f, -0.010902f, -0.396409f}, {0.295499f, 0.340509f} },
    { {-0.136806f, -0.226533f, -0.295113f}, {-0.865923f, 0.002056f, -0.500173f}, {0.295499f, 0.340509f} },
    { {-0.146281f, 0.064909f, -0.252157f}, {-0.988718f, 0.047169f, -0.142171f}, {0.295499f, 0.340509f} },
    { {-0.127566f, 0.071588f, -0.282373f}, {-0.823234f, 0.162226f, -0.544030f}, {0.295499f, 0.340509f} },
    { {-0.175209f, 0.435983f, -0.079824f}, {-0.991680f, 0.026987f, -0.125865f}, {0.295499f, 0.340509f} },
    { {-0.150919f, 0.462028f, -0.100931f}, {-0.798525f, 0.468991f, -0.377367f}, {0.295499f, 0.340509f} },
    { {-0.188965f, 0.480946f, 0.156366f}, {-0.974207f, 0.215584f, -0.066664f}, {0.295499f, 0.340509f} },
    { {-0.162618f, 0.512446f, 0.164612f}, {-0.773450f, 0.630889f, 0.061273f}, {0.295499f, 0.340509f} },
    { {-0.190281f, 0.434630f, 0.213896f}, {-0.878995f, 0.306438f, 0.365326f}, {0.295499f, 0.340509f} },
    { {-0.164348f, 0.451543f, 0.240261f}, {-0.769462f, 0.305416f, 0.560936f}, {0.295499f, 0.340509f} },
    { {-0.193525f, 0.323608f, 0.248646f}, {-0.998466f, 0.033569f, 0.044039f}, {0.295499f, 0.340509f} },
    { {-0.167953f, 0.328161f, 0.278880f}, {-0.767045f, 0.087274f, 0.635629f}, {0.295499f, 0.340509f} },
    { {-0.200589f, 0.083794f, 0.260203f}, {-0.997164f, 0.031147f, 0.068507f}, {0.295499f, 0.340509f} },
    { {-0.175202f, 0.082068f, 0.290740f}, {-0.769023f, -0.002218f, 0.639217f}, {0.295499f, 0.340509f} },
    { {-0.179375f, -0.058920f, 0.274322f}, {-0.004188f, -0.170432f, 0.985361f}, {0.295499f, 0.340509f} },
    { {-0.183372f, -0.193263f, 0.235096f}, {-0.010529f, -0.382792f, 0.923775f}, {0.295499f, 0.340509f} },
    { {0.176070f, -0.069443f, 0.274013f}, {0.047501f, -0.223082f, 0.973642f}, {0.295499f, 0.340509f} },
    { {0.172073f, -0.203786f, 0.234787f}, {0.042545f, -0.487257f, 0.872222f}, {0.295499f, 0.340509f} },
    { {-0.186203f, -0.287112f, 0.163198f}, {-0.017301f, -0.607737f, 0.793950f}, {0.295499f, 0.340509f} },
    { {0.169241f, -0.297634f, 0.162888f}, {0.223530f, -0.750999f, 0.621317f}, {0.295499f, 0.340509f} },
    { {-0.186203f, -0.287112f, 0.163198f}, {0.005828f, 0.167886f, 0.985789f}, {0.295499f, 0.340509f} },
    { {-0.162842f, -0.312045f, 0.167306f}, {0.012226f, 0.392426f, 0.919702f}, {0.295499f, 0.340509f} },
    { {0.169241f, -0.297634f, 0.162888f}, {0.005826f, 0.167919f, 0.985784f}, {0.295499f, 0.340509f} },
    { {0.146249f, -0.320949f, 0.166997f}, {0.138159f, 0.762952f, 0.631519f}, {0.295499f, 0.340509f} },
    { {-0.163387f, -0.330634f, 0.188538f}, {0.010424f, 0.329077f, 0.944245f}, {0.295499f, 0.340509f} },
    { {0.145703f, -0.339538f, 0.188229f}, {0.052153f, 0.073685f, 0.995917f}, {0.295499f, 0.340509f} },
    { {-0.165450f, -0.398800f, 0.182822f}, {-0.005749f, -0.233319f, 0.972383f}, {0.295499f, 0.340509f} },
    { {0.143640f, -0.407704f, 0.182513f}, {0.041987f, -0.333429f, 0.941840f}, {0.295499f, 0.340509f} },
    { {-0.168523f, -0.499396f, 0.137361f}, {-0.012043f, -0.449100f, 0.893400f}, {0.295499f, 0.340509f} },
    { {0.140567f, -0.508300f, 0.137052f}, {0.078933f, -0.523990f, 0.848059f}, {0.295499f, 0.340509f} },
    { {-0.168884f, -0.510924f, 0.121265f}, {-0.028393f, -0.978549f, -0.204048f}, {0.325762f, 0.243112f} },
    { {0.140207f, -0.519828f, 0.120955f}, {0.011554f, -0.957975f, -0.286619f}, {0.394395f, 0.243217f} },
    { {-0.168884f, -0.510924f, 0.121265f}, {-0.028393f, -0.978549f, -0.204048f}, {0.077008f, 0.135906f} },
    { {-0.123205f, -0.432462f, -0.118509f}, {-0.026054f, -0.924874f, -0.379381f}, {0.095224f, 0.403786f} },
    { {0.140207f, -0.519828f, 0.120955f}, {0.011554f, -0.957975f, -0.286619f}, {0.208268f, 0.136322f} },
    { {0.098670f, -0.438320f, -0.118818f}, {0.090687f, -0.855190f, -0.510319f}, {0.189439f, 0.404202f} },
    { {-0.123205f, -0.432462f, -0.118509f}, {-0.026054f, -0.924874f, -0.379381f}, {0.335287f, 0.310600f} },
    { {-0.104243f, -0.364182f, -0.179382f}, {-0.018201f, -0.661945f, -0.749331f}, {0.295499f, 0.340509f} },
    { {0.098670f, -0.438320f, -0.118818f}, {0.090687f, -0.855190f, -0.510319f}, {0.384550f, 0.310704f} },
    { {0.088700f, -0.369030f, -0.179691f}, {0.146038f, -0.637421f, -0.756550f}, {0.295499f, 0.340509f} },
    { {-0.104243f, -0.364182f, -0.179382f}, {0.011274f, 0.503774f, -0.863762f}, {0.295499f, 0.340509f} },
    { {-0.103255f, -0.333528f, -0.161490f}, {0.011274f, 0.503774f, -0.863762f}, {0.295499f, 0.340509f} },
    { {0.088700f, -0.369030f, -0.179691f}, {0.061845f, 0.501623f, -0.862873f}, {0.295499f, 0.340509f} },
    { {0.089689f, -0.338375f, -0.161799f}, {0.184395f, 0.490989f, -0.851427f}, {0.295499f, 0.340509f} },
    { {-0.103255f, -0.333528f, -0.161490f}, {-0.012918f, -0.457414f, -0.889160f}, {0.295499f, 0.340509f} },
    { {-0.173710f, -0.298176f, -0.178653f}, {-0.022482f, -0.754406f, -0.656023f}, {0.295499f, 0.340509f} },
    { {0.089689f, -0.338375f, -0.161799f}, {0.020548f, -0.518757f, -0.854675f}, {0.295499f, 0.340509f} },
    { {0.155410f, -0.307779f, -0.178962f}, {0.188229f, -0.887514f, -0.420582f}, {0.295499f, 0.340509f} },
    { {-0.136806f, -0.226533f, -0.295113f}, {-0.024702f, -0.847307f, -0.530528f}, {0.295499f, 0.340509f} },
    { {0.122358f, -0.233694f, -0.295423f}, {0.232218f, -0.743586f, -0.627021f}, {0.295499f, 0.340509f} },
    { {-0.136806f, -0.226533f, -0.295113f}, {-0.000012f, 0.042699f, -0.999088f}, {0.295499f, 0.340509f} },
    { {-0.127566f, 0.071588f, -0.282373f}, {0.004504f, 0.205271f, -0.978695f}, {0.295499f, 0.340509f} },
    { {0.122358f, -0.233694f, -0.295423f}, {-0.000012f, 0.042699f, -0.999088f}, {0.295499f, 0.340509f} },
    { {0.131597f, 0.064428f, -0.282682f}, {0.008598f, 0.337928f, -0.941133f}, {0.295499f, 0.340509f} },
    { {-0.150919f, 0.462028f, -0.100931f}, {0.011079f, 0.422218f, -0.906427f}, {0.295499f, 0.340509f} },
    { {0.178201f, 0.452424f, -0.101240f}, {0.011475f, 0.422448f, -0.906314f}, {0.295499f, 0.340509f} },
    { {-0.150919f, 0.462028f, -0.100931f}, {0.028487f, 0.982278f, -0.185251f}, {0.295499f, 0.340509f} },
    { {-0.162618f, 0.512446f, 0.164612f}, {0.029302f, 0.997764f, -0.060074f}, {0.295499f, 0.340509f} },
    { {0.178201f, 0.452424f, -0.101240f}, {0.139297f, 0.955564f, -0.259797f}, {0.295499f, 0.340509f} },
    { {0.192826f, 0.501924f, 0.164303f}, {0.104714f, 0.983581f, 0.146980f}, {0.295499f, 0.340509f} },
    { {-0.164348f, 0.451543f, 0.240261f}, {0.018803f, 0.611914f, 0.790701f}, {0.295499f, 0.340509f} },
    { {0.191096f, 0.441020f, 0.239952f}, {0.062273f, 0.452230f, 0.889725f}, {0.295499f, 0.340509f} },
    { {-0.167953f, 0.328161f, 0.278880f}, {0.006117f, 0.177718f, 0.984062f}, {0.295499f, 0.340509f} },
    { {0.187491f, 0.317639f, 0.278571f}, {0.047263f, 0.103311f, 0.993526f}, {0.295499f, 0.340509f} },
    { {-0.175202f, 0.082068f, 0.290740f}, {0.001210f, 0.011495f, 0.999933f}, {0.295499f, 0.340509f} },
    { {0.180243f, 0.071546f, 0.290430f}, {0.062487f, -0.037472f, 0.997342f}, {0.295499f, 0.340509f} },
    { {0.201557f, -0.066250f, 0.254002f}, {0.997451f, -0.043811f, 0.056327f}, {0.295499f, 0.340509f} },
    { {0.197715f, -0.195383f, 0.216298f}, {0.996275f, -0.065455f, 0.056146f}, {0.295499f, 0.340509f} },
    { {0.194765f, -0.293184f, 0.141371f}, {0.905161f, -0.424402f, 0.023802f}, {0.295499f, 0.340509f} },
    { {0.146249f, -0.320949f, 0.166997f}, {0.584016f, -0.811595f, -0.015431f}, {0.295499f, 0.340509f} },
    { {0.167999f, -0.331956f, 0.148135f}, {0.972221f, 0.146604f, -0.182468f}, {0.295499f, 0.340509f} },
    { {0.103465f, -0.339232f, -0.138671f}, {0.968667f, 0.130321f, -0.211427f}, {0.295499f, 0.340509f} },
    { {0.167511f, -0.348576f, 0.167118f}, {0.802186f, 0.012955f, 0.596934f}, {0.295499f, 0.340509f} },
    { {0.165856f, -0.403284f, 0.162531f}, {0.875505f, -0.191186f, 0.443778f}, {0.295499f, 0.340509f} },
    { {0.163029f, -0.495816f, 0.120714f}, {0.932335f, -0.201197f, 0.300451f}, {0.295499f, 0.340509f} },
    { {0.162957f, -0.498098f, 0.117527f}, {0.965534f, -0.094182f, -0.242641f}, {0.295499f, 0.340509f} },
    { {0.115071f, -0.421412f, -0.107144f}, {0.954426f, -0.112835f, -0.276294f}, {0.295499f, 0.340509f} },
    { {0.102571f, -0.366948f, -0.154847f}, {0.950722f, -0.049825f, -0.306014f}, {0.295499f, 0.340509f} },
    { {0.102571f, -0.366948f, -0.154847f}, {0.834319f, 0.257569f, -0.487412f}, {0.295499f, 0.340509f} },
    { {0.103465f, -0.339232f, -0.138671f}, {0.834319f, 0.257569f, -0.487411f}, {0.295499f, 0.340509f} },
    { {0.103465f, -0.339232f, -0.138671f}, {0.495152f, -0.867922f, -0.039177f}, {0.295499f, 0.340509f} },
    { {0.179352f, -0.294372f, -0.163461f}, {0.993490f, -0.007945f, -0.113642f}, {0.295499f, 0.340509f} },
    { {0.141217f, -0.223411f, -0.274650f}, {0.889758f, -0.032845f, -0.455250f}, {0.295499f, 0.340509f} },
    { {0.131597f, 0.064428f, -0.282682f}, {0.746901f, 0.090459f, -0.658753f}, {0.295499f, 0.340509f} },
    { {0.149973f, 0.059123f, -0.262575f}, {0.990382f, -0.013288f, -0.137718f}, {0.295499f, 0.340509f} },
    { {0.201188f, 0.433918f, -0.087206f}, {0.986431f, 0.054002f, -0.155041f}, {0.295499f, 0.340509f} },
    { {0.217576f, 0.479671f, 0.158769f}, {0.998668f, -0.035505f, -0.037427f}, {0.295499f, 0.340509f} },
    { {0.216122f, 0.428492f, 0.222338f}, {0.998869f, -0.045126f, -0.015002f}, {0.295499f, 0.340509f} },
    { {0.212758f, 0.313351f, 0.258378f}, {0.999176f, -0.034700f, -0.021044f}, {0.295499f, 0.340509f} },
    { {0.205633f, 0.071444f, 0.270036f}, {0.998264f, 0.009126f, -0.058193f}, {0.295499f, 0.340509f} },
};

WORD g_tind74[] = 
{
    0, 1, 2,    1, 3, 2,    1, 4, 3,    4, 5, 3,    4, 6, 5,
    6, 7, 5,    8, 9, 10,    9, 11, 10,    9, 12, 11,    12, 13, 11,
    12, 14, 13,    14, 15, 13,    15, 14, 16,    14, 17, 16,    17, 18, 16,
    17, 19, 18,    19, 20, 18,    19, 21, 20,    21, 22, 20,    6, 4, 23,
    6, 23, 24,    25, 26, 23,    26, 27, 23,    26, 28, 27,    28, 29, 27,
    28, 30, 29,    30, 31, 29,    30, 32, 31,    32, 33, 31,    32, 34, 33,
    34, 35, 33,    34, 36, 35,    36, 37, 35,    36, 38, 37,    38, 39, 37,
    38, 0, 39,    0, 2, 39,    40, 41, 42,    41, 43, 42,    41, 44, 43,
    44, 45, 43,    46, 47, 48,    47, 49, 48,    47, 50, 49,    50, 51, 49,
    50, 52, 51,    52, 53, 51,    52, 54, 53,    54, 55, 53,    54, 56, 55,
    56, 57, 55,    58, 59, 60,    59, 61, 60,    62, 63, 64,    63, 65, 64,
    66, 67, 68,    67, 69, 68,    70, 71, 72,    71, 73, 72,    71, 74, 73,
    74, 75, 73,    76, 77, 78,    77, 79, 78,    77, 80, 79,    80, 81, 79,
    82, 83, 84,    83, 85, 84,    83, 86, 85,    86, 87, 85,    86, 88, 87,
    88, 89, 87,    88, 90, 89,    90, 91, 89,    90, 40, 91,    40, 42, 91,
    42, 43, 92,    43, 93, 92,    43, 45, 93,    45, 94, 93,    45, 95, 73,
    49, 96, 97,    49, 51, 96,    51, 98, 96,    51, 53, 98,    53, 99, 98,
    53, 55, 99,    55, 100, 99,    55, 57, 100,    57, 101, 100,    57, 64, 101,
    64, 102, 101,    64, 65, 102,    65, 103, 102,    68, 69, 104,    69, 105, 104,
    72, 73, 106,    73, 107, 94,    73, 75, 107,    75, 108, 107,    75, 109, 108,
    109, 110, 108,    109, 84, 110,    84, 111, 110,    84, 85, 111,    85, 112, 111,
    85, 87, 112,    87, 113, 112,    87, 89, 113,    89, 114, 113,    89, 91, 114,
    91, 115, 114,    91, 42, 115,    42, 92, 115,    102, 103, 97,    107, 108, 110,
    110, 111, 112,    110, 112, 113,    110, 113, 114,    110, 114, 115,    107, 110, 115,
    107, 115, 92,    107, 92, 93,    107, 93, 94,    45, 73, 94,    95, 106, 73,
    101, 102, 97,    101, 97, 96,    100, 101, 96,    99, 100, 96,    98, 99, 96,
    12, 17, 14,    9, 17, 12,    8, 17, 9,    8, 21, 19,    8, 19, 17,
    8, 10, 21,    4, 25, 23,    25, 28, 26,    4, 28, 25,    1, 28, 4,
    0, 28, 1,    0, 30, 28,    38, 30, 0,    36, 30, 38,    36, 32, 30,
    34, 32, 36,
};

D3DMATRIX g_tmat75 = 
{
    0.131670f, 0.989906f, -0.052440f, 0.000000f, 
    0.028434f, 0.049108f, 0.998389f, 0.000000f, 
    0.990886f, -0.132949f, -0.021681f, 0.000000f, 
    0.668142f, -2.637097f, 2.365755f, 1.000000f, 
};

// Mesh #75 Tris:64 Verts:50
MODELVERT g_tmesh75[] = 
{
    { {-0.000000f, 0.000000f, 0.000000f}, {0.000000f, -0.000000f, -1.000000f}, {0.301432f, 0.446184f} },
    { {0.045762f, 0.045763f, 0.000000f}, {0.000000f, -0.000000f, -1.000000f}, {0.301432f, 0.420072f} },
    { {0.064718f, 0.000000f, 0.000000f}, {0.000000f, -0.000000f, -1.000000f}, {0.301432f, 0.446184f} },
    { {-0.000000f, 0.064718f, 0.000000f}, {0.000000f, -0.000000f, -1.000000f}, {0.301432f, 0.409256f} },
    { {-0.045763f, 0.045763f, 0.000000f}, {0.000000f, -0.000000f, -1.000000f}, {0.301432f, 0.420072f} },
    { {-0.064718f, 0.000000f, 0.000000f}, {0.000000f, -0.000000f, -1.000000f}, {0.301432f, 0.446184f} },
    { {-0.045763f, -0.045762f, 0.000000f}, {0.000000f, -0.000000f, -1.000000f}, {0.301432f, 0.472296f} },
    { {-0.000000f, -0.064718f, 0.000000f}, {0.000000f, -0.000000f, -1.000000f}, {0.301432f, 0.483112f} },
    { {0.045762f, -0.045762f, 0.000000f}, {0.000000f, -0.000000f, -1.000000f}, {0.301432f, 0.472296f} },
    { {0.064718f, 0.000000f, 0.000000f}, {0.907768f, 0.178110f, -0.379782f}, {0.301432f, 0.446184f} },
    { {0.082372f, 0.082373f, 0.123753f}, {0.688984f, 0.676097f, -0.261138f}, {0.343944f, 0.399183f} },
    { {0.116492f, 0.000000f, 0.123753f}, {0.965258f, -0.009113f, -0.261138f}, {0.343944f, 0.446184f} },
    { {0.045762f, 0.045763f, 0.000000f}, {0.515946f, 0.767832f, -0.379782f}, {0.301432f, 0.420072f} },
    { {-0.000000f, 0.116492f, 0.123753f}, {0.009113f, 0.965258f, -0.261138f}, {0.343944f, 0.379714f} },
    { {-0.000000f, 0.064718f, 0.000000f}, {-0.178110f, 0.907768f, -0.379782f}, {0.301432f, 0.409256f} },
    { {-0.082373f, 0.082372f, 0.123753f}, {-0.676097f, 0.688984f, -0.261138f}, {0.343944f, 0.399183f} },
    { {-0.045763f, 0.045763f, 0.000000f}, {-0.767832f, 0.515946f, -0.379782f}, {0.301432f, 0.420072f} },
    { {-0.116492f, 0.000000f, 0.123753f}, {-0.965258f, 0.009113f, -0.261138f}, {0.343944f, 0.446184f} },
    { {-0.064718f, 0.000000f, 0.000000f}, {-0.907768f, -0.178110f, -0.379782f}, {0.301432f, 0.446184f} },
    { {-0.082373f, -0.082372f, 0.123753f}, {-0.688984f, -0.676097f, -0.261138f}, {0.343944f, 0.493185f} },
    { {-0.045763f, -0.045762f, 0.000000f}, {-0.515946f, -0.767832f, -0.379782f}, {0.301432f, 0.472296f} },
    { {-0.000000f, -0.116492f, 0.123753f}, {-0.009112f, -0.965258f, -0.261138f}, {0.343944f, 0.512654f} },
    { {-0.000000f, -0.064718f, 0.000000f}, {0.178110f, -0.907768f, -0.379782f}, {0.301432f, 0.483112f} },
    { {0.082372f, -0.082372f, 0.123753f}, {0.676097f, -0.688984f, -0.261138f}, {0.343944f, 0.493185f} },
    { {0.045762f, -0.045762f, 0.000000f}, {0.767832f, -0.515946f, -0.379782f}, {0.301432f, 0.472296f} },
    { {0.082372f, 0.082373f, 0.181358f}, {0.678658f, 0.722502f, 0.131959f}, {0.363732f, 0.399183f} },
    { {0.116492f, 0.000000f, 0.181358f}, {0.982369f, 0.030740f, 0.184405f}, {0.363732f, 0.446184f} },
    { {-0.000000f, 0.116492f, 0.181358f}, {-0.031071f, 0.992974f, 0.114178f}, {0.363732f, 0.379714f} },
    { {-0.082373f, 0.082372f, 0.181358f}, {-0.721465f, 0.677684f, 0.142240f}, {0.363732f, 0.399183f} },
    { {-0.116492f, 0.000000f, 0.181358f}, {-0.979612f, -0.030653f, 0.198549f}, {0.363732f, 0.446184f} },
    { {-0.082373f, -0.082372f, 0.181358f}, {-0.663084f, -0.705922f, 0.248986f}, {0.363732f, 0.493185f} },
    { {-0.000000f, -0.116492f, 0.181358f}, {0.030154f, -0.963666f, 0.265403f}, {0.363732f, 0.512654f} },
    { {0.082372f, -0.082372f, 0.181358f}, {0.707692f, -0.664747f, 0.239340f}, {0.363732f, 0.493185f} },
    { {0.047891f, 0.067929f, 0.364230f}, {0.811364f, 0.550536f, 0.196467f}, {0.426552f, 0.407424f} },
    { {0.067728f, 0.020039f, 0.364230f}, {0.945157f, -0.181015f, 0.271867f}, {0.426552f, 0.434750f} },
    { {-0.000000f, 0.087767f, 0.364230f}, {0.185900f, 0.970666f, 0.152473f}, {0.426552f, 0.396105f} },
    { {-0.047891f, 0.067929f, 0.364230f}, {-0.553425f, 0.815622f, 0.168767f}, {0.426552f, 0.407424f} },
    { {-0.067728f, 0.020039f, 0.364230f}, {-0.954751f, 0.182852f, 0.234554f}, {0.426552f, 0.434750f} },
    { {-0.047891f, -0.027852f, 0.364230f}, {-0.787337f, -0.534233f, 0.307727f}, {0.426552f, 0.462076f} },
    { {-0.000000f, -0.047689f, 0.364230f}, {-0.176439f, -0.921266f, 0.346610f}, {0.426552f, 0.473395f} },
    { {0.047891f, -0.027852f, 0.364230f}, {0.529531f, -0.780407f, 0.332508f}, {0.426552f, 0.462076f} },
    { {-0.000000f, 0.020039f, 0.364230f}, {0.000000f, 0.000000f, 1.000000f}, {0.426552f, 0.434750f} },
    { {0.067728f, 0.020039f, 0.364230f}, {0.000000f, 0.000000f, 1.000000f}, {0.426552f, 0.434750f} },
    { {0.047891f, 0.067929f, 0.364230f}, {0.000000f, 0.000000f, 1.000000f}, {0.426552f, 0.407424f} },
    { {-0.000000f, 0.087767f, 0.364230f}, {0.000000f, 0.000000f, 1.000000f}, {0.426552f, 0.396105f} },
    { {-0.047891f, 0.067929f, 0.364230f}, {0.000000f, 0.000000f, 1.000000f}, {0.426552f, 0.407424f} },
    { {-0.067728f, 0.020039f, 0.364230f}, {0.000000f, 0.000000f, 1.000000f}, {0.426552f, 0.434750f} },
    { {-0.047891f, -0.027852f, 0.364230f}, {0.000000f, 0.000000f, 1.000000f}, {0.426552f, 0.462076f} },
    { {-0.000000f, -0.047689f, 0.364230f}, {0.000000f, 0.000000f, 1.000000f}, {0.426552f, 0.473395f} },
    { {0.047891f, -0.027852f, 0.364230f}, {0.000000f, 0.000000f, 1.000000f}, {0.426552f, 0.462076f} },
};

WORD g_tind75[] = 
{
    0, 1, 2,    0, 3, 1,    0, 4, 3,    0, 5, 4,    0, 6, 5,
    0, 7, 6,    0, 8, 7,    0, 2, 8,    9, 10, 11,    9, 12, 10,
    12, 13, 10,    12, 14, 13,    14, 15, 13,    14, 16, 15,    16, 17, 15,
    16, 18, 17,    18, 19, 17,    18, 20, 19,    20, 21, 19,    20, 22, 21,
    22, 23, 21,    22, 24, 23,    24, 11, 23,    24, 9, 11,    11, 25, 26,
    11, 10, 25,    10, 27, 25,    10, 13, 27,    13, 28, 27,    13, 15, 28,
    15, 29, 28,    15, 17, 29,    17, 30, 29,    17, 19, 30,    19, 31, 30,
    19, 21, 31,    21, 32, 31,    21, 23, 32,    23, 26, 32,    23, 11, 26,
    26, 33, 34,    26, 25, 33,    25, 35, 33,    25, 27, 35,    27, 36, 35,
    27, 28, 36,    28, 37, 36,    28, 29, 37,    29, 38, 37,    29, 30, 38,
    30, 39, 38,    30, 31, 39,    31, 40, 39,    31, 32, 40,    32, 34, 40,
    32, 26, 34,    41, 42, 43,    41, 43, 44,    41, 44, 45,    41, 45, 46,
    41, 46, 47,    41, 47, 48,    41, 48, 49,    41, 49, 42,
};

D3DMATRIX g_tmat76 = 
{
    -0.131670f, -0.989906f, 0.052440f, 0.000000f, 
    -0.028434f, -0.049107f, -0.998389f, 0.000000f, 
    0.990886f, -0.132949f, -0.021681f, 0.000000f, 
    1.462713f, -2.743706f, 2.348370f, 1.000000f, 
};

// Mesh #76 Tris:64 Verts:50
MODELVERT g_tmesh76[] = 
{
    { {0.000000f, 0.000000f, 0.000000f}, {0.000000f, -0.000000f, 1.000000f}, {0.301432f, 0.446184f} },
    { {-0.045762f, -0.045762f, 0.000000f}, {0.000000f, -0.000000f, 1.000000f}, {0.301432f, 0.472296f} },
    { {-0.064718f, 0.000000f, 0.000000f}, {0.000000f, -0.000000f, 1.000000f}, {0.301432f, 0.446184f} },
    { {0.000000f, -0.064718f, 0.000000f}, {0.000000f, -0.000000f, 1.000000f}, {0.301432f, 0.483112f} },
    { {0.045763f, -0.045762f, 0.000000f}, {0.000000f, -0.000000f, 1.000000f}, {0.301432f, 0.472296f} },
    { {0.064718f, 0.000000f, 0.000000f}, {0.000000f, -0.000000f, 1.000000f}, {0.301432f, 0.446184f} },
    { {0.045763f, 0.045763f, 0.000000f}, {0.000000f, -0.000000f, 1.000000f}, {0.301432f, 0.420072f} },
    { {0.000000f, 0.064718f, 0.000000f}, {0.000000f, -0.000000f, 1.000000f}, {0.301432f, 0.409256f} },
    { {-0.045762f, 0.045763f, 0.000000f}, {0.000000f, -0.000000f, 1.000000f}, {0.301432f, 0.420072f} },
    { {-0.064718f, 0.000000f, 0.000000f}, {-0.907768f, -0.178110f, 0.379782f}, {0.301432f, 0.446184f} },
    { {-0.082372f, -0.082372f, -0.123753f}, {-0.688984f, -0.676097f, 0.261138f}, {0.343944f, 0.493185f} },
    { {-0.116492f, 0.000000f, -0.123753f}, {-0.965258f, 0.009113f, 0.261138f}, {0.343944f, 0.446184f} },
    { {-0.045762f, -0.045762f, 0.000000f}, {-0.515946f, -0.767832f, 0.379782f}, {0.301432f, 0.472296f} },
    { {0.000000f, -0.116492f, -0.123753f}, {-0.009113f, -0.965258f, 0.261138f}, {0.343944f, 0.512654f} },
    { {0.000000f, -0.064718f, 0.000000f}, {0.178110f, -0.907768f, 0.379782f}, {0.301432f, 0.483112f} },
    { {0.082373f, -0.082372f, -0.123753f}, {0.676097f, -0.688984f, 0.261138f}, {0.343944f, 0.493185f} },
    { {0.045763f, -0.045762f, 0.000000f}, {0.767832f, -0.515946f, 0.379782f}, {0.301432f, 0.472296f} },
    { {0.116492f, 0.000000f, -0.123753f}, {0.965258f, -0.009113f, 0.261138f}, {0.343944f, 0.446184f} },
    { {0.064718f, 0.000000f, 0.000000f}, {0.907768f, 0.178110f, 0.379782f}, {0.301432f, 0.446184f} },
    { {0.082373f, 0.082373f, -0.123753f}, {0.688984f, 0.676097f, 0.261138f}, {0.343944f, 0.399183f} },
    { {0.045763f, 0.045763f, 0.000000f}, {0.515946f, 0.767832f, 0.379782f}, {0.301432f, 0.420072f} },
    { {0.000000f, 0.116492f, -0.123753f}, {0.009113f, 0.965258f, 0.261138f}, {0.343944f, 0.379714f} },
    { {0.000000f, 0.064718f, 0.000000f}, {-0.178110f, 0.907768f, 0.379782f}, {0.301432f, 0.409256f} },
    { {-0.082372f, 0.082373f, -0.123753f}, {-0.676097f, 0.688984f, 0.261138f}, {0.343944f, 0.399183f} },
    { {-0.045762f, 0.045763f, 0.000000f}, {-0.767832f, 0.515946f, 0.379782f}, {0.301432f, 0.420072f} },
    { {-0.082372f, -0.082372f, -0.181357f}, {-0.678658f, -0.722502f, -0.131959f}, {0.363732f, 0.493185f} },
    { {-0.116492f, 0.000000f, -0.181357f}, {-0.982369f, -0.030740f, -0.184405f}, {0.363732f, 0.446184f} },
    { {0.000000f, -0.116492f, -0.181357f}, {0.031071f, -0.992974f, -0.114178f}, {0.363732f, 0.512654f} },
    { {0.082373f, -0.082372f, -0.181357f}, {0.721465f, -0.677684f, -0.142240f}, {0.363732f, 0.493185f} },
    { {0.116492f, 0.000000f, -0.181357f}, {0.979612f, 0.030653f, -0.198549f}, {0.363732f, 0.446184f} },
    { {0.082373f, 0.082373f, -0.181357f}, {0.663084f, 0.705922f, -0.248986f}, {0.363732f, 0.399183f} },
    { {0.000000f, 0.116492f, -0.181357f}, {-0.030154f, 0.963666f, -0.265403f}, {0.363732f, 0.379714f} },
    { {-0.082372f, 0.082373f, -0.181357f}, {-0.707692f, 0.664747f, -0.239340f}, {0.363732f, 0.399183f} },
    { {-0.047891f, -0.067929f, -0.364230f}, {-0.811364f, -0.550536f, -0.196467f}, {0.426552f, 0.484944f} },
    { {-0.067728f, -0.020038f, -0.364230f}, {-0.945157f, 0.181015f, -0.271867f}, {0.426552f, 0.457618f} },
    { {0.000000f, -0.087766f, -0.364230f}, {-0.185900f, -0.970666f, -0.152473f}, {0.426552f, 0.496263f} },
    { {0.047891f, -0.067929f, -0.364230f}, {0.553425f, -0.815622f, -0.168767f}, {0.426552f, 0.484944f} },
    { {0.067728f, -0.020038f, -0.364230f}, {0.954751f, -0.182852f, -0.234554f}, {0.426552f, 0.457618f} },
    { {0.047891f, 0.027853f, -0.364230f}, {0.787337f, 0.534233f, -0.307727f}, {0.426552f, 0.430292f} },
    { {0.000000f, 0.047690f, -0.364230f}, {0.176439f, 0.921266f, -0.346610f}, {0.426552f, 0.418973f} },
    { {-0.047891f, 0.027853f, -0.364230f}, {-0.529531f, 0.780407f, -0.332508f}, {0.426552f, 0.430292f} },
    { {0.000000f, -0.020038f, -0.364230f}, {0.000000f, 0.000000f, -1.000000f}, {0.426552f, 0.457618f} },
    { {-0.067728f, -0.020038f, -0.364230f}, {0.000000f, 0.000000f, -1.000000f}, {0.426552f, 0.457618f} },
    { {-0.047891f, -0.067929f, -0.364230f}, {0.000000f, 0.000000f, -1.000000f}, {0.426552f, 0.484944f} },
    { {0.000000f, -0.087766f, -0.364230f}, {0.000000f, 0.000000f, -1.000000f}, {0.426552f, 0.496263f} },
    { {0.047891f, -0.067929f, -0.364230f}, {0.000000f, 0.000000f, -1.000000f}, {0.426552f, 0.484944f} },
    { {0.067728f, -0.020038f, -0.364230f}, {0.000000f, 0.000000f, -1.000000f}, {0.426552f, 0.457618f} },
    { {0.047891f, 0.027853f, -0.364230f}, {0.000000f, 0.000000f, -1.000000f}, {0.426552f, 0.430292f} },
    { {0.000000f, 0.047690f, -0.364230f}, {0.000000f, 0.000000f, -1.000000f}, {0.426552f, 0.418973f} },
    { {-0.047891f, 0.027853f, -0.364230f}, {0.000000f, 0.000000f, -1.000000f}, {0.426552f, 0.430292f} },
};

WORD g_tind76[] = 
{
    2, 1, 0,    1, 3, 0,    3, 4, 0,    4, 5, 0,    5, 6, 0,
    6, 7, 0,    7, 8, 0,    8, 2, 0,    11, 10, 9,    10, 12, 9,
    10, 13, 12,    13, 14, 12,    13, 15, 14,    15, 16, 14,    15, 17, 16,
    17, 18, 16,    17, 19, 18,    19, 20, 18,    19, 21, 20,    21, 22, 20,
    21, 23, 22,    23, 24, 22,    23, 11, 24,    11, 9, 24,    26, 25, 11,
    25, 10, 11,    25, 27, 10,    27, 13, 10,    27, 28, 13,    28, 15, 13,
    28, 29, 15,    29, 17, 15,    29, 30, 17,    30, 19, 17,    30, 31, 19,
    31, 21, 19,    31, 32, 21,    32, 23, 21,    32, 26, 23,    26, 11, 23,
    34, 33, 26,    33, 25, 26,    33, 35, 25,    35, 27, 25,    35, 36, 27,
    36, 28, 27,    36, 37, 28,    37, 29, 28,    37, 38, 29,    38, 30, 29,
    38, 39, 30,    39, 31, 30,    39, 40, 31,    40, 32, 31,    40, 34, 32,
    34, 26, 32,    43, 42, 41,    44, 43, 41,    45, 44, 41,    46, 45, 41,
    47, 46, 41,    48, 47, 41,    49, 48, 41,    42, 49, 41,
};

#define MODELDATAMESH(_x) \
    { &g_tmat##_x, \
      sizeof(g_tmesh##_x) / sizeof(g_tmesh##_x[0]), g_tmesh##_x, \
      sizeof(g_tind##_x)  / sizeof(g_tind##_x[0]),  g_tind##_x }
MODELDATA g_ModelData[] =
{
    MODELDATAMESH(0),
    MODELDATAMESH(1),
    MODELDATAMESH(2),
    MODELDATAMESH(3),
    MODELDATAMESH(4),
    MODELDATAMESH(5),
    MODELDATAMESH(6),
    MODELDATAMESH(7),
    MODELDATAMESH(8),
    MODELDATAMESH(9),
    MODELDATAMESH(10),
    MODELDATAMESH(11),
    MODELDATAMESH(12),
    MODELDATAMESH(13),
    MODELDATAMESH(14),
    MODELDATAMESH(15),
    MODELDATAMESH(16),
    MODELDATAMESH(17),
    MODELDATAMESH(18),
    MODELDATAMESH(19),
    MODELDATAMESH(20),
    MODELDATAMESH(21),
    MODELDATAMESH(22),
    MODELDATAMESH(23),
    MODELDATAMESH(24),
    MODELDATAMESH(25),
    MODELDATAMESH(26),
    MODELDATAMESH(27),
    MODELDATAMESH(28),
    MODELDATAMESH(29),
    MODELDATAMESH(30),
    MODELDATAMESH(31),
    MODELDATAMESH(32),
    MODELDATAMESH(33),
    MODELDATAMESH(34),
    MODELDATAMESH(35),
    MODELDATAMESH(36),
    MODELDATAMESH(37),
    MODELDATAMESH(38),
    MODELDATAMESH(39),
    MODELDATAMESH(40),
    MODELDATAMESH(41),
    MODELDATAMESH(42),
    MODELDATAMESH(43),
    MODELDATAMESH(44),
    MODELDATAMESH(45),
    MODELDATAMESH(46),
    MODELDATAMESH(47),
    MODELDATAMESH(48),
    MODELDATAMESH(49),
    MODELDATAMESH(50),
    MODELDATAMESH(51),
    MODELDATAMESH(52),
    MODELDATAMESH(53),
    MODELDATAMESH(54),
    MODELDATAMESH(55),
    MODELDATAMESH(56),
    MODELDATAMESH(57),
    MODELDATAMESH(58),
    MODELDATAMESH(59),
    MODELDATAMESH(60),
    MODELDATAMESH(61),
    MODELDATAMESH(62),
    MODELDATAMESH(63),
    MODELDATAMESH(64),
    MODELDATAMESH(65),
    MODELDATAMESH(66),
    MODELDATAMESH(67),
    MODELDATAMESH(68),
    MODELDATAMESH(69),
    MODELDATAMESH(70),
    MODELDATAMESH(71),
    MODELDATAMESH(72),
    MODELDATAMESH(73),
    MODELDATAMESH(74),
    MODELDATAMESH(75),
    MODELDATAMESH(76),
};
DWORD g_cModelData = sizeof(g_ModelData) / sizeof(g_ModelData[0]);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TextureCompression\TextureCompression.cpp ===
//-----------------------------------------------------------------------------
// File: TextureCompression.cpp
//
// Desc: 
//
// Hist: 3.29.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Next method" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Next texture" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Next format" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"show difference" },
};

#define NUM_HELP_CALLOUTS 4


typedef struct 
{
    D3DXVECTOR4 p;
    D3DXVECTOR2 t;
} CUSTOMVERTEX;
#define FVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)

WCHAR * g_aszLabels[] = {
    L"Original",
    L"D3DX",
    L"S3TCEncode",
};
#define NUM_LABELS 3

char * g_aszFiles[] = {
    "Textures\\tuscan.tga",
    "Textures\\gamepad.tga",
    "Textures\\Flame1.bmp",
    "Textures\\forestground.bmp",
    "Textures\\grydirt1.bmp",
    "Textures\\LightOakSm.bmp",
    "Textures\\procwood4.bmp",
    "Textures\\sdirt.bmp",
    "Textures\\StonehengeGround.bmp",
    "Textures\\stonehengerock.bmp",
    "Textures\\temprock.bmp",
    "Textures\\volslice003.bmp",
    "Textures\\Waterbumps.bmp",
};

D3DFORMAT g_adwFormats[] = { 
    D3DFMT_DXT1,
    D3DFMT_DXT2,
    D3DFMT_DXT3,
    D3DFMT_DXT4,
    D3DFMT_DXT5,
};


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    HRESULT ReloadTexture();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    DWORD       m_dwCompression;
    DWORD       m_dwTexture;
    DWORD       m_dwFormat;
	DWORD		m_bDifference;
    LPDIRECT3DTEXTURE8 m_pTexOrig;
    LPDIRECT3DTEXTURE8 m_pTexD3DX;
    LPDIRECT3DTEXTURE8 m_pTexCompressed;
    LPDIRECT3DVERTEXBUFFER8 m_pvb;

    DWORD       m_dwCompPShader;     // Handle for pixel shader 1

    BOOL        m_bDrawHelp;
};


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

D3DFORMAT LinearFromSwizzled( D3DFORMAT fmt )
{
    switch( fmt )
    {
    case D3DFMT_A1R5G5B5:
        return D3DFMT_LIN_A1R5G5B5;
    case D3DFMT_A4R4G4B4:
        return D3DFMT_LIN_A4R4G4B4;
    case D3DFMT_A8B8G8R8:
        return D3DFMT_LIN_A8B8G8R8;
    case D3DFMT_A8R8G8B8:
        return D3DFMT_LIN_A8R8G8B8;
    case D3DFMT_B8G8R8A8:
        return D3DFMT_LIN_B8G8R8A8;
    case D3DFMT_R4G4B4A4:
        return D3DFMT_LIN_R4G4B4A4;
    case D3DFMT_R5G5B5A1:
        return D3DFMT_LIN_R5G5B5A1;
    case D3DFMT_R5G6B5:
        return D3DFMT_LIN_R5G6B5;
    case D3DFMT_R6G5B5:
        return D3DFMT_LIN_R6G5B5;
    case D3DFMT_R8G8B8A8:
        return D3DFMT_LIN_R8G8B8A8;
    case D3DFMT_X1R5G5B5:
        return D3DFMT_LIN_X1R5G5B5;
    case D3DFMT_X8R8G8B8:
        return D3DFMT_LIN_X8R8G8B8;
    }
    return D3DFMT_UNKNOWN;
}


//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;

    m_dwFormat       = NULL;
    m_dwTexture      = NULL;
    m_dwCompression  = 0;
    m_pTexOrig       = NULL;
    m_pTexD3DX       = NULL;
    m_pTexCompressed = NULL;

    m_bDifference    = 0;
}


HRESULT
CXBoxSample::ReloadTexture()
{
    D3DSURFACE_DESC sdSrc, sdDest, sdD3DX;
    D3DLOCKED_RECT lrSrc, lrDest, lrD3DX;
    BYTE * pb;
    LARGE_INTEGER liFreq, liA, liB, liC, liD;
    FLOAT fSecsPerTick, f1, f2;

    QueryPerformanceFrequency( &liFreq );
    fSecsPerTick = 1.0f / liFreq.QuadPart;

    if( m_pTexOrig )
        m_pTexOrig->Release();
    if( m_pTexD3DX )
        m_pTexD3DX->Release();
    if( m_pTexCompressed )
        m_pTexCompressed->Release();

    if( FAILED( XBUtil_CreateTexture( m_pd3dDevice, g_aszFiles[ m_dwTexture ], &m_pTexOrig, D3DFMT_A8R8G8B8 ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_pTexOrig->GetLevelDesc( 0, &sdSrc );
    m_pTexOrig->LockRect( 0, &lrSrc, NULL, D3DLOCK_READONLY );

    if( FAILED( m_pd3dDevice->CreateTexture( sdSrc.Width, sdSrc.Height, 1, 0, g_adwFormats[ m_dwFormat ], 0, &m_pTexD3DX ) ) )
        return E_OUTOFMEMORY;

    m_pTexD3DX->GetLevelDesc( 0, &sdD3DX );
    m_pTexD3DX->LockRect( 0, &lrD3DX, NULL, D3DLOCK_READONLY );
    LPDIRECT3DSURFACE8 pDest, pSrc;

    m_pTexD3DX->GetSurfaceLevel( 0, &pDest );
    m_pTexOrig->GetSurfaceLevel( 0, &pSrc );

    QueryPerformanceCounter( &liA );
    D3DXLoadSurfaceFromSurface( pDest, NULL, NULL, pSrc, NULL, NULL, D3DX_DEFAULT, 0 );
    QueryPerformanceCounter( &liB );

    D3DXSetDXT3DXT5( m_dwFormat == 1 || m_dwFormat == 3 );
    if( FAILED( m_pd3dDevice->CreateTexture( sdSrc.Width, sdSrc.Height, 1, 0, g_adwFormats[ m_dwFormat ], 0, &m_pTexCompressed ) ) )
        return E_OUTOFMEMORY;

    m_pTexCompressed->GetLevelDesc( 0, &sdDest );
    m_pTexCompressed->LockRect( 0, &lrDest, NULL, D3DLOCK_READONLY );

    XBUtil_UnswizzleTexture2D( &lrSrc, &sdSrc );

    DWORD dwSize = sdSrc.Width * sdSrc.Height;
    if( m_dwFormat == 0 )
        dwSize /= 2;
    
    dwSize = max( dwSize, m_dwFormat==0 ? DWORD(8) : DWORD(16) );

    pb = new BYTE[ dwSize ];
    QueryPerformanceCounter( &liC );
    XGCompressRect( pb, 
                    g_adwFormats[ m_dwFormat ], 
                    0,
                    sdSrc.Width, 
                    sdSrc.Height, 
                    lrSrc.pBits, 
                    LinearFromSwizzled( sdSrc.Format ), 
                    lrSrc.Pitch, 
                    0.5f,
                    ( m_dwFormat == 1 || m_dwFormat == 3 ) ? XGCOMPRESS_PREMULTIPLY : 0);
    QueryPerformanceCounter( &liD );
    memcpy( lrDest.pBits, pb, dwSize );
    delete[] pb;

    XBUtil_SwizzleTexture2D( &lrSrc, &sdSrc );

    m_pTexOrig->UnlockRect( 0 );
    m_pTexD3DX->UnlockRect( 0 );
    m_pTexCompressed->UnlockRect( 0 );

    f1 = fSecsPerTick * ( liB.QuadPart - liA.QuadPart );
    f2 = fSecsPerTick * ( liD.QuadPart - liC.QuadPart );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;    

    if( FAILED( m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( CUSTOMVERTEX ), 0, 0, 0, &m_pvb ) ) )
        return E_FAIL;

    CUSTOMVERTEX * pVertices;
    m_pvb->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR4(  60 - 0.5f, 440 - 0.5f, 1.0f, 1.0f );  pVertices[0].t = D3DXVECTOR2( 0.0f, 1.0f );
    pVertices[1].p = D3DXVECTOR4(  60 - 0.5f,  40 - 0.5f, 1.0f, 1.0f );  pVertices[1].t = D3DXVECTOR2( 0.0f, 0.0f );
    pVertices[2].p = D3DXVECTOR4( 580 - 0.5f, 440 - 0.5f, 1.0f, 1.0f );  pVertices[2].t = D3DXVECTOR2( 1.0f, 1.0f );
    pVertices[3].p = D3DXVECTOR4( 580 - 0.5f,  40 - 0.5f, 1.0f, 1.0f );  pVertices[3].t = D3DXVECTOR2( 1.0f, 0.0f );
    m_pvb->Unlock();

    if( FAILED( XBUtil_CreatePixelShader( m_pd3dDevice, "Shaders\\comp.xpu", &m_dwCompPShader ) ) )
		return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( ReloadTexture() ) )
        return XBAPPERR_MEDIANOTFOUND;


    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        m_dwCompression = ( m_dwCompression + 1 ) % NUM_LABELS;
    }
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        m_dwTexture = ( m_dwTexture + 1 ) % ( sizeof( g_aszFiles ) / sizeof( g_aszFiles[0] ) );
        if( FAILED( ReloadTexture() ) )
            return XBAPPERR_MEDIANOTFOUND;
    }
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_dwFormat = ( m_dwFormat + 1 ) % ( sizeof( g_adwFormats ) / sizeof( g_adwFormats[0] ) );
        ReloadTexture();
    }
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_BLACK ] )
    {
        m_bDifference = (m_bDifference + 1) % 3;
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ); 
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xa0a0a0a0 ) ;

    if(m_bDifference == 2) {
        m_pd3dDevice->SetTexture( 1, m_dwCompression == 0 ? m_pTexOrig : ( m_dwCompression == 1 ? m_pTexD3DX : m_pTexCompressed ) );
        m_pd3dDevice->SetTexture( 0, m_pTexOrig );
    } else {
        m_pd3dDevice->SetTexture( 0, m_dwCompression == 0 ? m_pTexOrig : ( m_dwCompression == 1 ? m_pTexD3DX : m_pTexCompressed ) );
        m_pd3dDevice->SetTexture( 1, m_pTexOrig );
    }

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG2 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TEXTURE );
    m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pvb, sizeof( CUSTOMVERTEX ) );

    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXCOORDINDEX, 0); 
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_TEXCOORDINDEX, 0);
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_TEXCOORDINDEX, 0);  

    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_CURRENT  );


    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLORARG1, D3DTA_CURRENT  ); 
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG1, D3DTA_CURRENT  ); 

    if(!m_bDifference) {
        m_pd3dDevice->SetPixelShader( 0 ); 
	
    } else {
        m_pd3dDevice->SetPixelShader( m_dwCompPShader ); 

/*
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_SUBTRACT );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_CURRENT  );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_TEXTURE );

        m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_ADDSIGNED2X  );
        m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLORARG1, D3DTA_CURRENT  );
        m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLORARG2, D3DTA_TFACTOR  );
        m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_ADDSIGNED2X );
        m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG1, D3DTA_CURRENT  );
        m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG2, D3DTA_CURRENT  );

*/		
    }
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );  

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR ch[100];

        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"TextureCompression" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        swprintf( ch, L"%S", g_aszFiles[ m_dwTexture ] );
        m_Font.DrawText(  64, 80,  0xffffff00, ch );
        swprintf( ch, L"DXT%d", m_dwFormat + 1 );
        m_Font.DrawText(  64, 110, 0xffffff00, ch );
        m_Font.DrawText(  64, 140, 0xffffff00, g_aszLabels[ m_dwCompression ] );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\SwapCallback\SwapCallback.cpp ===
//-----------------------------------------------------------------------------
// File: SwapCallback.cpp
//
// Desc: Example code showing how to use Swap and VBlank callbacks to determine
//       when the app is close to dropping frames. An app can use this
//       information to scale back rendering quality instead of dropping frames.
//
//       The app is made to be fill bound by drawing a bunch of big,
//       anti-aliased quads on the screen. The user can control the number of
//       quads (and thereby control the overall frame time) and observe how
//       close the app is to dropping frames.
//
// Hist: 12.01.01 - New for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include <XBMesh.h>


//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,   XBHELP_PLACEMENT_2, L"Vary amount of\nquads drawn." },
    { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_2, L"Display\nhelp" },
};

#define NUM_HELP_CALLOUTS 2




//-----------------------------------------------------------------------------
// Vertices for drawing a bunch of pixel-fill-eating quads
//-----------------------------------------------------------------------------
#define MAX_QUADS 1000

struct SCREENVERTEX
{
    D3DXVECTOR4 pos;
    D3DCOLOR    color;
};

SCREENVERTEX g_vQuads[4*MAX_QUADS];


// Helper macro
#define rnd()  (((FLOAT)rand() ) / RAND_MAX) 




//-----------------------------------------------------------------------------
// Swap callback to determine whether we are close to dropping frames
//-----------------------------------------------------------------------------
DWORD g_dwCyclesUntilVBlank = 0;
DWORD g_dwNumMissedVBlanks  = 0;

VOID _cdecl SwapCallback( D3DSWAPDATA* pSwapData )
{
    // NOTE: This callback is called as a DPC (a "Deferred Procedure Call"
    // which is a high-priority kernel callback queued by an Interrupt Service
    // Routines). As such, do your business and get out. Do not make any XTL
    // calls from here, and do not use any floating point.

    // Store time until the next VBlank
    g_dwCyclesUntilVBlank = pSwapData->TimeUntilSwapVBlank;
    g_dwNumMissedVBlanks  = pSwapData->MissedVBlanks;
}




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBFont            m_Font;             // Font class
    CXBHelp            m_Help;             // Help class
    BOOL               m_bDrawHelp;        // Whether to draw help

    DWORD              m_dwNumQuads;       // # of quads to render

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;
    m_d3dpp.MultiSampleType = D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR;

    // Don't draw help initially
    m_bDrawHelp = FALSE;

    // Seed the random number generator
    srand((DWORD)m_fTime);

    // Randomly generate data for onscreen, pixel-fill-eating quads
    for( WORD i=0; i<MAX_QUADS; i++)
    {
        FLOAT x   = (FLOAT)(int)(320+200*(rnd()-rnd())) - 0.5f;
        FLOAT y   = (FLOAT)(int)(280+150*(rnd()-rnd())) - 0.5f;
        FLOAT w_2 = (FLOAT)(int)(160*rnd()/2);
        FLOAT h_2 = (FLOAT)(int)(100*rnd()/2);

        g_vQuads[4*i+0].pos = D3DXVECTOR4( x - w_2, y - h_2, 0, 0 );
        g_vQuads[4*i+1].pos = D3DXVECTOR4( x + w_2, y - h_2, 0, 0 );
        g_vQuads[4*i+2].pos = D3DXVECTOR4( x + w_2, y + h_2, 0, 0 );
        g_vQuads[4*i+3].pos = D3DXVECTOR4( x - w_2, y + h_2, 0, 0 );

        DWORD r = (int)(255*rnd());
        DWORD g = (int)(255*rnd());
        DWORD b = (int)(255*rnd());
        DWORD a = 0x0e;

        g_vQuads[4*i+0].color = (a<<24)|(r<<16)|(g<<8)|(b<<0);
        g_vQuads[4*i+1].color = (a<<24)|(r<<16)|(g<<8)|(b<<0);
        g_vQuads[4*i+2].color = (a<<24)|(r<<16)|(g<<8)|(b<<0);
        g_vQuads[4*i+3].color = (a<<24)|(r<<16)|(g<<8)|(b<<0);
    }

    m_dwNumQuads = 100;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set the transform matrices
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, 0.75f, 4.0f/3.0f, 1.0f, 1000.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set a swap callback to regulate framerate
    m_pd3dDevice->SetSwapCallback( SwapCallback );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Let the user control the number of quads drawn
    static FLOAT fNumQuads = 500;
    fNumQuads += m_DefaultGamepad.fY1*m_fElapsedTime*500;
    fNumQuads = max( 1.0f, min( MAX_QUADS, fNumQuads ) );

    m_dwNumQuads = (DWORD)fNumQuads;


    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: App_Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x00000000, 1.0f, 0L );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG2 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG2 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );

    // Turn on alphablending, z-buffering, and multisample to eat fill
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEMODE,  D3DMULTISAMPLEMODE_2X );

    // Set the vertex shader
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );

    // Draw a bunch of quads to make the app fillbound
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, m_dwNumQuads, g_vQuads, sizeof(SCREENVERTEX) );

    // Restore state
    m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEMODE, D3DMULTISAMPLEMODE_1X );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.DrawText(  64, 50, 0xffffff00, L"SwapCallback" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        WCHAR str[80];
        m_Font.DrawText(  64, 80, 0xffffff00, L"Time until VBlank:" );
    
        if( g_dwNumMissedVBlanks > 0 )
        {
            // Display the time by which we exceeded the VBlank
            swprintf( str, L"%.3f ms", (1000.0f/60.0f) - g_dwCyclesUntilVBlank/733000.0f );
            m_Font.DrawText( 240,  80, 0xffff0000, str );
            m_Font.DrawText(  64, 105, 0xffff0000, L"Missed VBlank" );
        }
        else
        {
            // Display the time we have left before the VBlank
            swprintf( str, L"%.3f ms", g_dwCyclesUntilVBlank/733000.0f );
            m_Font.DrawText( 240, 80, 0xffffffff, str );
        }
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Tiling\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Tiling\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\swizzle\swizzle.cpp ===
//-----------------------------------------------------------------------------
// File: Swizzle.cpp
//
// Desc: Example code showing how to lock and access data from swizzled
//       textures.
//
// Hist: 12.15.00 - New for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBUtil.h>
#include <xgraphics.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Rotate\ntexture" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\nformat" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\nlinear" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Lock every frame" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Toggle use of\nswizzler class" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Toggle use of\nswizzler API" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display\nhelp" },
};

#define NUM_HELP_CALLOUTS 7




//-----------------------------------------------------------------------------
// Vertex structure
//-----------------------------------------------------------------------------
struct VERTEX 
{ 
    D3DXVECTOR3 p; 
    FLOAT       tu, tv; 
};

#define D3DFVF_VERTEX (D3DFVF_XYZ|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Font
    CXBFont                 m_Font;
    CXBHelp                 m_Help;
    BOOL                    m_bDrawHelp;

    // Geometry
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    LPDIRECT3DTEXTURE8      m_pTexture;

    // Support for textures
    D3DFORMAT               m_d3dFormat;         // Current texture format
    BOOL                    m_bUpdateEveryFrame; // Whether to update the texture every frame
    BOOL                    m_bUseSwizzlerClass; // Whether to use the swizzler class
    BOOL                    m_bUseSwizzlerAPI;   // Whether to use the swizzler API
	DWORD*                  m_pTextureData;      // Intermediate storage for texture data
    
	HRESULT CreateGeometry();
    HRESULT UpdateTexture();

protected:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Override base members
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Initialize members
    m_bDrawHelp            = FALSE;
    m_pVB                  = NULL;
    m_pTexture             = NULL;
    m_d3dFormat            = D3DFMT_LIN_R5G6B5;
	m_bUpdateEveryFrame    = FALSE;
    m_bUseSwizzlerClass    = FALSE;
    m_bUseSwizzlerAPI      = FALSE;
	m_pTextureData         = NULL;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the texture and vertex buffer
    if( FAILED( hr = CreateGeometry() ) )
        return hr;

    // Set the transform matrices
    D3DXMATRIX matWorld, matView, matProj;
    D3DXVECTOR3 vFrom( 0.0f, 0.0f, 3.0f );
    D3DXVECTOR3 vAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &vFrom, &vAt, &vUp );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4.0f, 4.0f/3.0f, 1.0f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateGeometry()
// Desc: To test out different lock schemes
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateGeometry()
{
    // Release the existing objects
    SAFE_RELEASE( m_pTexture );
    SAFE_RELEASE( m_pVB );
        
    // Generate some geometry for the app
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                                  0L, D3DPOOL_DEFAULT, &m_pVB ) ) )
        return E_FAIL;

    VERTEX* v;
    m_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
    v[0].p = D3DXVECTOR3(-1.0f,-1.0f, 0.0f ); v[0].tu = 0.0f; v[0].tv = 0.0f;
    v[1].p = D3DXVECTOR3( 1.0f,-1.0f, 0.0f ); v[1].tu = 1.0f; v[1].tv = 0.0f;
    v[2].p = D3DXVECTOR3(-1.0f, 1.0f, 0.0f ); v[2].tu = 0.0f; v[2].tv = 1.0f;
    v[3].p = D3DXVECTOR3( 1.0f, 1.0f, 0.0f ); v[3].tu = 1.0f; v[3].tv = 1.0f;

    // Linear textures use literal textcoords (range from 0 to width or height)
    if( m_d3dFormat == D3DFMT_LIN_R5G6B5 || m_d3dFormat ==D3DFMT_LIN_A8R8G8B8 )
    {
        v[0].tu =   0.0f; v[0].tv =   0.0f;
        v[1].tu = 255.0f; v[1].tv =   0.0f;
        v[2].tu =   0.0f; v[2].tv = 255.0f;
        v[3].tu = 255.0f; v[3].tv = 255.0f;
    }
    
    m_pVB->Unlock();

    // Create the texture
    if( FAILED( m_pd3dDevice->CreateTexture( 256, 256, 0, 0L, m_d3dFormat, 
                                             D3DPOOL_DEFAULT, &m_pTexture ) ) )
        return E_FAIL;

	// Fill the newly created texture
	UpdateTexture();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: UpdateTexture()
// Desc: To test out different lock schemes
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::UpdateTexture()
{
    // Get the texture dimensions
    D3DSURFACE_DESC desc;
    m_pTexture->GetLevelDesc( 0, &desc );
    DWORD dwTexWidth  = desc.Width;
    DWORD dwTexHeight = desc.Height;
    DWORD dwTexDepth  = 0;

    // Lock the texture. D3D on Xbox only returns rawdata, that may be in
    // swizzled form.
    D3DLOCKED_RECT lock;
    m_pTexture->LockRect( 0, &lock, 0, 0L );
	VOID* pBits = lock.pBits;

	// If using the swizzler API, we need to use the intermediate storage area
	// area for the texture data.
    if( m_bUseSwizzlerAPI && XGIsSwizzledFormat(m_d3dFormat) )
		pBits = m_pTextureData;

	// If using the swizzler class, we will swizzle the texture on the fly.
    if( m_bUseSwizzlerClass && XGIsSwizzledFormat(m_d3dFormat) )
    {
        // Initialize a swizzler. The swizzler lets us easily convert texel
		// addresses when the texture is swizzled.
        Swizzler s( dwTexWidth, dwTexHeight, dwTexDepth );

        // Loop through and touch the texels. Note that SetU()/SetV() and
		// IncU()/IncV() are used to control texture addressed. This way,
		// the Get2D() function can be used to get the current address.

        s.SetV( 0 ); // Initialize the V texture coordinate

        for( DWORD y = 0; y < dwTexHeight; y++ )
        {
            s.SetU( 0 ); // Reset the U texture coordinate

            for( DWORD x = 0; x < dwTexWidth; x++ )
            {
                if( m_d3dFormat == D3DFMT_R5G6B5 || m_d3dFormat == D3DFMT_LIN_R5G6B5 )
                {
                    ((WORD*)pBits)[s.Get2D()] = (WORD)(((x>>3)<<11) | ((y>>3)<<0));
                }
                else
                {
                    ((DWORD*)pBits)[s.Get2D()] = (DWORD)(((x>>0)<<16) | ((y>>0)<<0));
                }

                s.IncU(); // Increment the U texture coordinate
            }

            s.IncV(); // Increment the V texture coordinate
        }
    }
    else
    {
        // Loop through and touch the texels.
        for( DWORD y = 0; y < dwTexHeight; y++ )
        {
            for( DWORD x = 0; x < dwTexWidth; x++ )
            {
                if( m_d3dFormat == D3DFMT_R5G6B5 || m_d3dFormat == D3DFMT_LIN_R5G6B5 )
                {
                    ((WORD*)pBits)[y*dwTexWidth+x] = (WORD)(((x>>3)<<11) | ((y>>3)<<0));
                }
                else
                {
                    ((DWORD*)pBits)[y*dwTexWidth+x] = (DWORD)(((x>>0)<<16) | ((y>>0)<<0));
                }
            }
        }
    }

    if( m_bUseSwizzlerAPI && XGIsSwizzledFormat(m_d3dFormat) )
	{
        if( m_d3dFormat == D3DFMT_R5G6B5 || m_d3dFormat == D3DFMT_LIN_R5G6B5 )
		    XGSwizzleRect( pBits, 0, NULL, lock.pBits, dwTexWidth, dwTexHeight, NULL, sizeof(WORD) );
        else
		    XGSwizzleRect( pBits, 0, NULL, lock.pBits, dwTexWidth, dwTexHeight, NULL, sizeof(DWORD) );
	}

	// Unlock the texture
    m_pTexture->UnlockRect( 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    BOOL bRecreateGeometry = FALSE;

    // Rotate the world
    static FLOAT fRotateAngle = 0.0f;
    fRotateAngle += m_DefaultGamepad.fX1*m_fElapsedTime;
    D3DXMATRIX matWorld;
    D3DXMatrixRotationZ( &matWorld, fRotateAngle );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Change texture format bit depth
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
    {
        switch( m_d3dFormat )
        {
            case D3DFMT_R5G6B5:       m_d3dFormat = D3DFMT_A8R8G8B8;     break;
            case D3DFMT_LIN_R5G6B5:   m_d3dFormat = D3DFMT_LIN_A8R8G8B8; break;
            case D3DFMT_A8R8G8B8:     m_d3dFormat = D3DFMT_R5G6B5;       break;
            case D3DFMT_LIN_A8R8G8B8: m_d3dFormat = D3DFMT_LIN_R5G6B5;   break;
        }

        bRecreateGeometry = TRUE;
    }

    // Toggle between linear and swizzled textures
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
    {
        switch( m_d3dFormat )
        {
            case D3DFMT_R5G6B5:       m_d3dFormat = D3DFMT_LIN_R5G6B5;   break;
            case D3DFMT_LIN_R5G6B5:   m_d3dFormat = D3DFMT_R5G6B5;       break;
            case D3DFMT_A8R8G8B8:     m_d3dFormat = D3DFMT_LIN_A8R8G8B8; break;
            case D3DFMT_LIN_A8R8G8B8: m_d3dFormat = D3DFMT_A8R8G8B8;     break;
        }

        bRecreateGeometry = TRUE;
    }

	// Toggle updating the texture every frame
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        m_bUpdateEveryFrame = !m_bUpdateEveryFrame;

	// Toggle use of swizzler class
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
	{
		m_bUseSwizzlerClass = !m_bUseSwizzlerClass;

		// Swizzler class is mutually exclusive with using swizzler API
		if( m_bUseSwizzlerClass )
			m_bUseSwizzlerAPI = FALSE;
	}

	// Toggle use of swizzler API
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
	{
		m_bUseSwizzlerAPI = !m_bUseSwizzlerAPI;

		// If using the swizzler API, we need an intermediate storage area for the
		// texture data.
		if( m_bUseSwizzlerAPI )
			m_pTextureData = new DWORD[ 256 * 256 ];
		else
			SAFE_DELETE( m_pTextureData );

		// Swizzler class is mutually exclusive with using swizzler API
		if( m_bUseSwizzlerAPI )
			m_bUseSwizzlerClass = FALSE;
	}

	// Only use swizzler if also using swizzled textures
	m_bUseSwizzlerClass &= XGIsSwizzledFormat( m_d3dFormat );
	m_bUseSwizzlerAPI   &= XGIsSwizzledFormat( m_d3dFormat );

	// Re-create the geometry, if necessary
	if( bRecreateGeometry )
		CreateGeometry();

	// Test the swizzle texture lock
	if( m_bUpdateEveryFrame )
		UpdateTexture();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0xff000044, 1.0f, 0L );

    // Set state
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_NONE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );

    // Note: The hardware requires CLAMP for linear textures
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    // Note: swizzled textures (the default) use texture coordinates that range
    // [0,1], but when using linear textures, they range [0, width or height].
    // To see this in code, see the VB creation in the CreateGeometry() function.

    // Render a rotating square
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetVertexShader( D3DFVF_VERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(VERTEX) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
		m_Font.Begin();

        m_Font.DrawText(  64, 48, 0xffffffff, L"Swizzle" );
        m_Font.DrawText( 450, 48, 0xffffff00, m_strFrameRate );

        m_Font.DrawText(  64, 100, 0xffffffff, L"Texture format:" );
        switch( m_d3dFormat )
        {
            case D3DFMT_R5G6B5:       m_Font.DrawText( 250, 100, 0xffffff00, L"D3DFMT_R5G6B5" );       break;
            case D3DFMT_A8R8G8B8:     m_Font.DrawText( 250, 100, 0xffffff00, L"D3DFMT_A8R8G8B8" );     break;
            case D3DFMT_LIN_R5G6B5:   m_Font.DrawText( 250, 100, 0xffffff00, L"D3DFMT_LIN_R5G6B5" );   break;
            case D3DFMT_LIN_A8R8G8B8: m_Font.DrawText( 250, 100, 0xffffff00, L"D3DFMT_LIN_A8R8G8B8" ); break;
        }

		m_Font.DrawText(  64, 125, 0xffffffff, L"Update every frame:" );
		m_Font.DrawText( 250, 125, 0xffffff00, m_bUpdateEveryFrame ? L"TRUE" : L"FALSE" );

		if( m_bUpdateEveryFrame )
		{
			if( XGIsSwizzledFormat( m_d3dFormat ) )
			{
				m_Font.DrawText(  64, 150, 0xffffffff, L"Using swizzler class:" );
				m_Font.DrawText( 250, 150, 0xffffff00, m_bUseSwizzlerClass ? L"TRUE" : L"FALSE" );

				m_Font.DrawText(  64, 175, 0xffffffff, L"Using swizzler API:" );
				m_Font.DrawText( 250, 175, 0xffffff00, m_bUseSwizzlerAPI ? L"TRUE" : L"FALSE" );
			}
		}

		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Tiling\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Tiling\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Tiling\obj\i386\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Tiling\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\comp2.inl ===
// Xbox Shader Assembler 1.00.4355.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    1,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_NONE,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

psd.PSC0Mapping = 0xffffffff;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\comp3.inl ===
// Xbox Shader Assembler 1.00.4355.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    2,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0x00000000;
psd.PSConstant1[1] = 0x00000000;

psd.PSC0Mapping = 0xffffffff;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Tiling\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 7UL

#define resource_Light_OFFSET 0UL
#define resource_SkyBoxXP_OFFSET 20UL
#define resource_SkyBoxXN_OFFSET 40UL
#define resource_SkyBoxYP_OFFSET 60UL
#define resource_SkyBoxYN_OFFSET 80UL
#define resource_SkyBoxZP_OFFSET 100UL
#define resource_SkyBoxZN_OFFSET 120UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Tiling\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\Mipmap.h ===
//-----------------------------------------------------------------------------
//  
//  File: mipmap.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Mipmap filtering using the GPU
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>

//////////////////////////////////////////////////////////////////////
// Filter coefficients and offsets for separable mipmap filtering.
//
class MipmapFilter {
 public:
	UINT m_nSuperSample;		// number of source samples per destination pixel
	float m_fHalfWidth;			// size of filter support
	UINT m_nSample;				// number of filter samples
	struct Sample {
		float m_fOffset;		// offset in destination pixel coords
		float m_fValue;			// value at offset
	} *m_rSample;
	int m_iSuperMin, m_iSuperMax;	// range of supersamples
 public:
#define MIPMAPFILTER_NORMALIZE_ADD		001 /* add (1-sum)/N to each filter coefficient */
#define MIPMAPFILTER_NORMALIZE_MULTIPLY	002 /* multiply each value by 1/sum */
#define MIPMAPFILTER_STRETCH				010 /* expand filter slightly to make tighter frequency bound */
#define MIPMAPFILTER_KEEPZEROS			020 /* filter values that quantize to zero are usually culled, when 255 * f < 0.5 */
	MipmapFilter(UINT nSuperSample = 2,	// number of source samples per output pixel
		   float fHalfWidth = 2.f,	// in destination pixel coords, filter is assumed to be zero outside this bound
		   float (*pfFilter)(float x, float fHalfWidth) = lanczos,	// filter kernel
		   DWORD dwFlags = MIPMAPFILTER_NORMALIZE_ADD);	// normalization flags
	~MipmapFilter() { delete [] m_rSample; }

	// kernel helper functions
	void NormalizeAdd();		// add (1 - sum)/N to each value
	void NormalizeMultiply();	// multiply each value by 1/sum
	static float triangle(float x, float fHalfWidth);
	static float mitchell(float x, float fHalfWidth);
	static float sinc(float x);							// sin(x) / x
	static float lanczos(float x, float fHalfWidth);	// sinc windowed sinc
	static float hamming(float x, float fHalfWidth);	// hamming-windowed sinc
};

//////////////////////////////////////////////////////////////////////
// Use filter coefficients to resample from higher resolution
// pTextureSrc to lower resolution pSurfaceDst.
// The width of Src must be m_nSuperSample * width of Dst and
// the height of Src must be m_nSuperSample * height of Dst.
// The scratch texture must be swizzled and have width >= Src and height >= Src
// If either pTextureScratchY or pTextureScratchX are NULL, temporary
// textures will be created and then released when done.
//
HRESULT Decimate(LPDIRECT3DSURFACE8 pSurfaceDst,
				 LPDIRECT3DTEXTURE8 pTextureSrc,
				 UINT iSourceLevel,	// index of source miplevel in pTextureSrc
				 D3DTEXTUREADDRESS WrapU = D3DTADDRESS_WRAP, 
				 D3DTEXTUREADDRESS WrapV = D3DTADDRESS_WRAP,
				 LPDIRECT3DTEXTURE8 pTextureScratchY = NULL,	// destination for filtering in Y
				 LPDIRECT3DTEXTURE8 pTextureScratchX = NULL,	// destination for filtering in X
				 MipmapFilter *pFilter = NULL);

//////////////////////////////////////////////////////////////////////
// Compute mipmaps starting from iSourceLevel
// The scratch textures must be swizzled and have width >= Src and height >= Src
// If either pTextureScratchY or pTextureScratchX are NULL, temporary
// textures will be created and then released when done.
// The filter must have nSuperSample = 2.
//
HRESULT GenerateMipmaps(LPDIRECT3DTEXTURE8 pTexture,
						UINT iSourceLevel,
						D3DTEXTUREADDRESS WrapU = D3DTADDRESS_WRAP, 
						D3DTEXTUREADDRESS WrapV = D3DTADDRESS_WRAP,
						LPDIRECT3DTEXTURE8 pTextureScratchY = NULL,
						LPDIRECT3DTEXTURE8 pTextureScratchX = NULL,
						MipmapFilter *pFilter = NULL);

//////////////////////////////////////////////////////////////////////
// Create a new texture the same size as the source texture, with the
// same number of mipmap levels, and then copy the source to the
// destination, with a format change.  This function handles swizzled and
// unswizzled textures.
//
HRESULT CopyTexture(LPDIRECT3DTEXTURE8 *ppTextureDst, D3DFORMAT fmtNew, LPDIRECT3DTEXTURE8 pTextureSrc);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\Clip.h ===
//-----------------------------------------------------------------------------
//  Blinn clipping.
//
//  Note that clipping range is assumed to be 0 to 1 in X, Y, and Z,
//  so the standard D3D clipping coords must be scaled and offset in
//  X and Y by 0.5, as done by BlinnClipMatrix().
//
//  See Jim Blinn's "A Trip Down the Graphics Pipeline", pp. 119-134.
//
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//-----------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////
// Convert D3D world.view.projection matrix to Blinn-style clip matrix.
//    D3D's clip volume is [-1,1] in X and Y, and [0,1] in Z.
//    Blinn's clip volume is [0,1] in X, Y, and Z.
//
inline D3DXMATRIX *BlinnClipMatrix(D3DXMATRIX *pmatBlinnClip, const D3DXMATRIX *pmatD3DClip)
{
	D3DXMATRIX matClipScale;
	D3DXMatrixScaling(&matClipScale, 0.5f, 0.5f, 1.f);
	D3DXMATRIX matClipOffset;
	D3DXMatrixTranslation(&matClipOffset, 0.5f, 0.5f, 0.f);
	*pmatBlinnClip = *pmatD3DClip * matClipScale * matClipOffset;
	return pmatBlinnClip;
}

//////////////////////////////////////////////////////////////////////
// Move float sign bit into bit 0 of the returned DWORD
//
inline DWORD FloatSignBit(float f)
{
	return *(DWORD *)&f >> 31;
}

//////////////////////////////////////////////////////////////////////
// Blinn boundary codes packed into a DWORD
//
inline DWORD BlinnBoundaryCode(const float *p)
{
	return FloatSignBit(p[0])				// X == 0
		| (FloatSignBit(p[3] - p[0]) << 1)	// X == 1
		| (FloatSignBit(p[1])        << 2)	// Y == 0
		| (FloatSignBit(p[3] - p[1]) << 3)	// Y == 1
		| (FloatSignBit(p[2])        << 4)	// Z == 0
		| (FloatSignBit(p[3] - p[2]) << 5); // Z == 1
}

//////////////////////////////////////////////////////////////////////
// Checks to see if points in [0,1] clip coordinates touch the clip frustum.
//
inline bool BoundingPointsInFrustum(UINT nPoint,				// number of points to test
									const D3DXVECTOR4 *rvPoint)	// array of bounding points in [0,1] clip coords
{
	DWORD Ocumulate = 0;
	DWORD Acumulate = -1;
	for (UINT i = 0; i < nPoint; i++)	// 8 points on bounding volume
	{
		DWORD BC = BlinnBoundaryCode(rvPoint[i]);
		Ocumulate |= BC;
		Acumulate &= BC;
	}
	if (Acumulate != 0)
		return false;	// all points are outside of frustum
	if (Ocumulate == 0)
		return true;	// all points are inside of frustum
	// TODO: Now a more elaborate test is needed, since the bounding box is
	// straddling a clip plane. Currently, this returns false positives.
	return true;
}

//////////////////////////////////////////////////////////////////////
// Culling helper. Checks to see if bounding box touches the clip frustum.
//    The matClip transformaion takes world coords to [0,1] clip range in X, Y, and Z.
//
inline bool BoundingBoxInFrustum(const D3DXMATRIX &matClip,  // current world/view/proj/clip matrix
								 const D3DXVECTOR3 &vMin, // bounding box
								 const D3DXVECTOR3 &vMax)
{
	float rv[8][3] = {
		vMin.x, vMin.y, vMin.z,
		vMin.x, vMin.y, vMax.z,
		vMin.x, vMax.y, vMin.z,
		vMin.x, vMax.y, vMax.z,
		vMax.x, vMin.y, vMin.z,
		vMax.x, vMin.y, vMax.z,
		vMax.x, vMax.y, vMin.z,
		vMax.x, vMax.y, vMax.z
	};
	D3DXVECTOR4 rvClip[8];
	for (UINT i = 0; i < 8; i++)
		D3DXVec3Transform(&rvClip[i], (D3DXVECTOR3 *)&rv[i], &matClip);
	return BoundingPointsInFrustum(8, rvClip);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Tiling\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 7UL

#define resource_Light_OFFSET 0UL
#define resource_SkyBoxXP_OFFSET 20UL
#define resource_SkyBoxXN_OFFSET 40UL
#define resource_SkyBoxYP_OFFSET 60UL
#define resource_SkyBoxYN_OFFSET 80UL
#define resource_SkyBoxZP_OFFSET 100UL
#define resource_SkyBoxZN_OFFSET 120UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Tiling\Tiling.cpp ===
//-----------------------------------------------------------------------------
// File: Tiling.cpp
//
// Desc: Sample code to show off how tiling and z-compression of rendertargets
//       has an effect on performance.
//
// Hist: 05.15.01 - New for the June XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBMesh.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <xgraphics.h>
#include "Resource.h" // Resource header produced by the bundler tool




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Tile primary\nframe buffer" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Tile primary\ndepth buffer" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Tile texture\nframe buffer" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Tile texture\ndepth buffer" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Toggle\nrendertarget" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS 6




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Light.bmp",    resource_Light_OFFSET },
    { "SkyBoxXP.bmp", resource_SkyBoxXP_OFFSET },
    { "SkyBoxXN.bmp", resource_SkyBoxXN_OFFSET },
    { "SkyBoxYP.bmp", resource_SkyBoxYP_OFFSET },
    { "SkyBoxYN.bmp", resource_SkyBoxYN_OFFSET },
    { "SkyBoxZP.bmp", resource_SkyBoxZP_OFFSET },
    { "SkyBoxZN.bmp", resource_SkyBoxZN_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Info for rendering the fill-eating streaks
//-----------------------------------------------------------------------------
struct STREAKVERTEX
{
    D3DXVECTOR4 p;
    DWORD       color;
};

const DWORD NUM_STREAKS              = 10;
const DWORD NUM_PARTICLES_PER_STREAK = 100;




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                  m_Font16;         // System font
    CXBFont                  m_Font12;         // System font
    CXBHelp                  m_Help;           // Application help
    BOOL                     m_bDrawHelp;      // Whether to display help

    CXBPackedResource        m_xprResource;    // Packed resources (textures)
    
    CXBMesh                  m_SkyBoxObject;   // The skybox geometry

    // Members for rendering streaks
    LPDIRECT3DTEXTURE8       m_pStreakTexture;
    STREAKVERTEX*            m_vParticleStreak[NUM_STREAKS];
    FLOAT                    m_fStreakTimeScale[NUM_STREAKS];
    FLOAT                    m_fStreakSinScale[NUM_STREAKS];
    DWORD                    m_dwStreakColor[NUM_STREAKS];
    DWORD                    m_dwActiveStreakParticle;

    // Members for the secondary rendertarget
    LPDIRECT3DTEXTURE8       m_pSecondaryTexture;
    LPDIRECT3DSURFACE8       m_pSecondaryColorSurface;
    VOID*                    m_pColorBufferMemory; 
    LPDIRECT3DSURFACE8       m_pSecondaryDepthSurface;
    VOID*                    m_pDepthBufferMemory;
    BOOL                     m_bUseSecondaryRenderTarget;

    // Members for tiling the color and depth buffers
    D3DTILE                  m_tile0;
    D3DTILE                  m_tile1;
    BOOL                     m_bPrimaryColorBufferTiled;
    BOOL                     m_bPrimaryDepthBufferTiled;
    BOOL                     m_bPrimaryDepthBufferCompressed;
    BOOL                     m_bSecondaryColorBufferTiled;
    BOOL                     m_bSecondaryDepthBufferTiled;
    BOOL                     m_bSecondaryDepthBufferCompressed;

    // Internal functions
    HRESULT CreateSecondaryRenderTarget();
    VOID    TilePrimaryColorBuffer( BOOL bTiled );
    VOID    TilePrimaryDepthBuffer( BOOL bTiled, BOOL bCompressed );
    VOID    TileSecondaryColorBuffer( BOOL bTile );
    VOID    TileSecondaryDepthBuffer( BOOL bTile, BOOL bCompressed );
    HRESULT RenderStreaks();

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Initialize options
    m_bDrawHelp                       = FALSE;

    m_bUseSecondaryRenderTarget       = FALSE;

    m_bPrimaryColorBufferTiled        = TRUE;
    m_bPrimaryDepthBufferTiled        = TRUE;
    m_bPrimaryDepthBufferCompressed   = TRUE;

    m_bSecondaryColorBufferTiled      = FALSE;
    m_bSecondaryDepthBufferTiled      = FALSE;
    m_bSecondaryDepthBufferCompressed = FALSE;

    // Initialize the streaks
    for( DWORD k=0; k<NUM_STREAKS; k++ )
    {
        m_vParticleStreak[k]  = new STREAKVERTEX[NUM_PARTICLES_PER_STREAK];
        m_fStreakTimeScale[k] = 0.5f + 1*((FLOAT)(k))/NUM_STREAKS;
        m_fStreakSinScale[k]  = 4.0f - 3*((FLOAT)(k))/NUM_STREAKS;

        switch( k%10 )
        {
            case 0: m_dwStreakColor[k] = 0x00ffffff; break;
            case 1: m_dwStreakColor[k] = 0x00ff0000; break;
            case 2: m_dwStreakColor[k] = 0x0000ff00; break;
            case 3: m_dwStreakColor[k] = 0x000000ff; break;
            case 4: m_dwStreakColor[k] = 0x00ffff00; break;
            case 5: m_dwStreakColor[k] = 0x00ff00ff; break;
            case 6: m_dwStreakColor[k] = 0x0000ffff; break;
            case 7: m_dwStreakColor[k] = 0x00ff0000; break;
            case 8: m_dwStreakColor[k] = 0x0000ff00; break;
            case 9: m_dwStreakColor[k] = 0x000000ff; break;
        }
    }
    m_dwActiveStreakParticle = 0;
    m_pStreakTexture         = NULL;
}




//-----------------------------------------------------------------------------
// Name: CreateSecondaryRenderTarget()
// Desc: Creates a texture and depth buffer to render into
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateSecondaryRenderTarget()
{
    DWORD dwWidth  = 640;
    DWORD dwHeight = 480;

    // Create a new 32-bit color surface using allocated tile-able memory
    m_pSecondaryTexture = new D3DTexture;
    XGSetTextureHeader( dwWidth, dwHeight, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, 
                        m_pSecondaryTexture, 0, 0 );
    m_pColorBufferMemory = D3D_AllocContiguousMemory( 4*dwWidth*dwHeight, 
                                                      D3DTILE_ALIGNMENT );
    m_pSecondaryTexture->Register( m_pColorBufferMemory );
    m_pSecondaryTexture->GetSurfaceLevel( 0, &m_pSecondaryColorSurface );

    // Create a new 32-bit depth surface using allocated tile-able memory
    m_pSecondaryDepthSurface = new D3DSurface;
    XGSetSurfaceHeader( dwWidth, dwHeight, D3DFMT_LIN_D24S8, m_pSecondaryDepthSurface, 0, 0 );
    m_pDepthBufferMemory = D3D_AllocContiguousMemory( 4*dwWidth*dwHeight, 
                                                      D3DTILE_ALIGNMENT );
    m_pSecondaryDepthSurface->Register( m_pDepthBufferMemory );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font16.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    if( FAILED( m_Font12.Create( m_pd3dDevice, "Font12.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the geometry models
    if( FAILED( m_SkyBoxObject.Create( m_pd3dDevice, "Models\\SkyBox.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get the light's texture
    m_pStreakTexture = m_xprResource.GetTexture( "Light.bmp" );
    
    // Set the matrices
    D3DXMATRIX matWorld, matView, matProj;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixIdentity( &matView );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, 4.0f/3.0f, 1.0f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Save the default tiles
    m_pd3dDevice->GetTile( 0, &m_tile0 );
    m_pd3dDevice->GetTile( 1, &m_tile1 );

    // Create a secondary render target
    CreateSecondaryRenderTarget();
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: TilePrimaryColorBuffer()
// Desc: Tiles (or untiles) the primary color buffer. The primary color buffer
//       always uses tile 0.
//-----------------------------------------------------------------------------
VOID CXBoxSample::TilePrimaryColorBuffer( BOOL bTiled )
{
    m_pd3dDevice->SetTile( 0, NULL );

    if( bTiled )
        m_pd3dDevice->SetTile( 0, &m_tile0 );
}




//-----------------------------------------------------------------------------
// Name: TilePrimaryDepthBuffer()
// Desc: Tiles (or untiles) and compresses (or uncompresses) the primary
//       depth buffer. The primary depth buffer always uses tile 1.
//-----------------------------------------------------------------------------
VOID CXBoxSample::TilePrimaryDepthBuffer( BOOL bTiled, BOOL bCompressed )
{
    g_pd3dDevice->SetTile( 1, NULL );

    if( bTiled )
    {
        D3DTILE tile = m_tile1;

        if( FALSE == bCompressed )
            tile.Flags &= ~D3DTILE_FLAGS_ZCOMPRESS;

        m_pd3dDevice->SetTile( 1, &tile );
    }
}




//-----------------------------------------------------------------------------
// Name: TileSecondaryColorBuffer()
// Desc: Tiles (or untiles) the secondary color buffer.  This arbitrarily uses
//       tile 4.
//-----------------------------------------------------------------------------
VOID CXBoxSample::TileSecondaryColorBuffer( BOOL bTiled )
{
    g_pd3dDevice->SetTile( 3, NULL );

    if( bTiled )
    {
        D3DSURFACE_DESC desc;
        m_pSecondaryColorSurface->GetDesc( &desc );

        D3DTILE tile;
        ZeroMemory( &tile, sizeof(tile) );
        tile.Flags     = 0;
        tile.Pitch     = desc.Size / desc.Height;
        tile.pMemory   = m_pColorBufferMemory;
        tile.Size      = desc.Size;
        g_pd3dDevice->SetTile( 3, &tile );
    }
}




//-----------------------------------------------------------------------------
// Name: TileSecondaryDepthBuffer()
// Desc: Tiles (or untiles) and compresses (or uncompresses) the secondary
//       depth buffer. This arbitrarily uses tile 4.
//-----------------------------------------------------------------------------
VOID CXBoxSample::TileSecondaryDepthBuffer( BOOL bTiled, BOOL bCompressed )
{
    g_pd3dDevice->SetTile( 4, NULL );

    if( bTiled )
    {
        D3DSURFACE_DESC desc;
        m_pSecondaryDepthSurface->GetDesc( &desc );

        D3DTILE tile;
        ZeroMemory( &tile, sizeof(tile) );
        tile.Flags     = D3DTILE_FLAGS_ZBUFFER | D3DTILE_FLAGS_Z32BITS;
        tile.Pitch     = desc.Size / desc.Height;
        tile.pMemory   = m_pDepthBufferMemory;
        tile.Size      = desc.Size;

        if( bCompressed )
        {
            tile.Flags    |= D3DTILE_FLAGS_ZCOMPRESS;
            tile.ZStartTag = D3DTILE_ZENDTAG( &m_tile1 );
            tile.ZOffset   = 0;
        }

        g_pd3dDevice->SetTile( 4, &tile );
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Toggle the render target
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
    {
        m_bUseSecondaryRenderTarget = !m_bUseSecondaryRenderTarget;
    }

    // Toggle whether the primary color buffer is tiled
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
    {
        m_bPrimaryColorBufferTiled = !m_bPrimaryColorBufferTiled;
        TilePrimaryColorBuffer( m_bPrimaryColorBufferTiled );
    }

    // Toggle whether the primary depth buffer is tiled
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
    {
        if( m_bPrimaryDepthBufferTiled )
        {
            if( m_bPrimaryDepthBufferCompressed )
            {
                m_bPrimaryDepthBufferTiled      = FALSE;
                m_bPrimaryDepthBufferCompressed = FALSE;
            }
            else
            {
                m_bPrimaryDepthBufferTiled      = TRUE;
                m_bPrimaryDepthBufferCompressed = TRUE;
            }
        }
        else
        {
            m_bPrimaryDepthBufferTiled      = TRUE;
            m_bPrimaryDepthBufferCompressed = FALSE;
        }

        TilePrimaryDepthBuffer( m_bPrimaryDepthBufferTiled, m_bPrimaryDepthBufferCompressed );
    }

    // Toggle whether the secondary color buffer is tiled
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
    {
        m_bSecondaryColorBufferTiled = !m_bSecondaryColorBufferTiled;
        TileSecondaryColorBuffer( m_bSecondaryColorBufferTiled );
    }

    // Toggle whether the secondary depth buffer is tiled
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
    {
        if( m_bSecondaryDepthBufferTiled )
        {
            if( m_bSecondaryDepthBufferCompressed )
            {
                m_bSecondaryDepthBufferTiled      = FALSE;
                m_bSecondaryDepthBufferCompressed = FALSE;
            }
            else
            {
                m_bSecondaryDepthBufferTiled      = TRUE;
                m_bSecondaryDepthBufferCompressed = TRUE;
            }
        }
        else
        {
            m_bSecondaryDepthBufferTiled      = TRUE;
            m_bSecondaryDepthBufferCompressed = FALSE;
        }

        TileSecondaryDepthBuffer( m_bSecondaryDepthBufferTiled, m_bSecondaryDepthBufferCompressed );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawBox()
// Desc: Helper function to draw an outlined, filled, screen-space rectangle
//-----------------------------------------------------------------------------
HRESULT DrawBox( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2,
                 DWORD dwFillColor, DWORD dwOutlineColor )
{
    D3DXVECTOR4 v[4];
    v[0] = D3DXVECTOR4( x1-0.5f, y1-0.5f, 0, 0 );
    v[1] = D3DXVECTOR4( x2-0.5f, y1-0.5f, 0, 0 );
    v[2] = D3DXVECTOR4( x2-0.5f, y2-0.5f, 0, 0 );
    v[3] = D3DXVECTOR4( x1-0.5f, y2-0.5f, 0, 0 );

    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );

    // Render the box
    g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwFillColor );
    g_pd3dDevice->DrawVerticesUP( D3DPT_QUADLIST, 4, v, sizeof(v[0]) );

    // Render the lines
    g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwOutlineColor );
    g_pd3dDevice->DrawVerticesUP( D3DPT_LINELOOP, 4, v, sizeof(v[0]) );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderStreaks()
// Desc: Render a bunch of streaks to eat up fill. Note: since this sample
//       tries to show off tiling compression of the depth buffer, it's 
//       important to have the zbuffer enabled.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderStreaks()
{
    // Update the streaks' main particles
    for( DWORD k=0; k<NUM_STREAKS; k++ )
    {
        FLOAT fTime = m_fStreakTimeScale[k]*m_fTime;
        FLOAT fX = fabsf( 2 * ( (fTime/2) - floorf(fTime/2) ) - 1 );
        FLOAT fY = fabsf( sinf( m_fStreakSinScale[k]*fTime ) );

        m_vParticleStreak[k][m_dwActiveStreakParticle].p = D3DXVECTOR4( 640*fX, 480*fY, 1.0f, 1.0f );
    }
    if( ++m_dwActiveStreakParticle >= NUM_PARTICLES_PER_STREAK )
        m_dwActiveStreakParticle = 0;

    // Fade the colors for the particles that make up the tail each streak
    for( DWORD i=0; i<NUM_PARTICLES_PER_STREAK; i++ )
    {
        int j = i + m_dwActiveStreakParticle;
        if( j>=NUM_PARTICLES_PER_STREAK )
            j -= NUM_PARTICLES_PER_STREAK;

        for( DWORD k=0; k<NUM_STREAKS; k++ )
            m_vParticleStreak[k][j].color = (0x00010101*i) & m_dwStreakColor[k];
    }

    // Render the streaks
    m_pd3dDevice->SetTexture( 3, m_pStreakTexture );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSIZE,         FtoDW(64.0f) );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );

    // Render the streaks
    for( k=0; k<NUM_STREAKS; k++ )
    {
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_POINTLIST, NUM_PARTICLES_PER_STREAK, 
                                       m_vParticleStreak[k], sizeof(STREAKVERTEX) );
    }

    // Restore state
    m_pd3dDevice->SetTexture( 3, NULL );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, FALSE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // If we're rendering to the secondary render target (a texture), then 
    // set that now, before drawing anything.
    if( m_bUseSecondaryRenderTarget )
        m_pd3dDevice->SetRenderTarget( m_pSecondaryColorSurface, m_pSecondaryDepthSurface );

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Set default state
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );

    // Render the background skybox
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    m_SkyBoxObject.Render( m_pd3dDevice );

    // Render the streaks
    RenderStreaks();

    // Show title, frame rate, and help
    if( m_bDrawHelp )
    {
        DrawBox( 59,  45, 571, 435, 0x40008000, 0xff008000 );
        m_Help.Render( &m_Font16, g_HelpCallouts, NUM_HELP_CALLOUTS );
    }
    else
    {
        // Draw boxes to contain text
        DrawBox( 59,  45, 571,  99, 0x40008000, 0xff008000 );
        DrawBox( 59, 106, 571, 435, 0x40008000, 0xff008000 );

        // Draw title and frame rate
        m_Font16.Begin();
        m_Font16.DrawText(  64, 50, 0xffffffff, L"Tiling" );
        m_Font16.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font16.End();

        // Draw the text output
        m_Font12.Begin();

        m_Font12.DrawText(  64, 75, 0xff00ffff, L"Press BACK for help" );

        // Whether rendering to a texture or to the backbuffer
        m_Font12.DrawText(  64, 114, 0xffffffff, L"Rendering to:" );
        if( m_bUseSecondaryRenderTarget )
            m_Font12.DrawText( 200, 114, 0xffffff00, L"Texture" );
        else
            m_Font12.DrawText( 200, 114, 0xffffff00, L"Backbuffer" );
            
        // Whether the render target is tiled
        m_Font12.DrawText(  64, 133, 0xffffffff, L"Render target:" );
        if( m_bUseSecondaryRenderTarget )
        {
            if( m_bSecondaryColorBufferTiled )
                m_Font12.DrawText( 200, 133, 0xffffff00, L"Tiled (using tile 3)" );
            else
                m_Font12.DrawText( 200, 133, 0xffffff00, L"Not tiled" );
        }
        else
        {
            if( m_bPrimaryColorBufferTiled )
                m_Font12.DrawText( 200, 133, 0xffffff00, L"Tiled (using tile 0)" );
            else
                m_Font12.DrawText( 200, 133, 0xffffff00, L"Not tiled" );
        }
            
        // Whether the depthbuffer is tiled and compressed
        m_Font12.DrawText(  64, 152, 0xffffffff, L"Depth buffer:" );
        if( m_bUseSecondaryRenderTarget )
        {
            if( m_bSecondaryDepthBufferTiled )
            {
                if( m_bSecondaryDepthBufferCompressed )
                    m_Font12.DrawText( 200, 152, 0xffffff00, L"Tiled (using tile 4), compressed" );
                else
                    m_Font12.DrawText( 200, 152, 0xffffff00, L"Tiled (using tile 4)" );
            }
            else
                m_Font12.DrawText( 200, 152, 0xffffff00, L"Not tiled" );
        }
        else
        {
            if( m_bPrimaryDepthBufferTiled )
            {
                if( m_bPrimaryDepthBufferCompressed )
                    m_Font12.DrawText( 200, 152, 0xffffff00, L"Tiled (using tile 1), compressed Z" );
                else
                    m_Font12.DrawText( 200, 152, 0xffffff00, L"Tiled (using tile 1)" );
            }
            else
                m_Font12.DrawText( 200, 152, 0xffffff00, L"Not tiled" );
        }
            
        // Dump info about all tiles
        FLOAT fCursorY = 209.0f;

        for( DWORD i=0; i<D3DTILE_MAXTILES; i++ )
        {
            D3DTILE tile;

            if( SUCCEEDED( m_pd3dDevice->GetTile( i, &tile ) ) )
            {
                WCHAR strBuffer[80];
                WCHAR strType[80] = L"(not used)";

                if( tile.Pitch )
                {
                    if( i==0 || i==1 )
                        wcscpy( strType, L"Primary" );
                    else
                        wcscpy( strType, L"Secondary" );

                    if( tile.Flags & D3DTILE_FLAGS_ZBUFFER )
                        wcscat( strType, L" depth buffer" );
                    else
                        wcscat( strType, L" color buffer" );

                    if( tile.Flags & D3DTILE_FLAGS_ZBUFFER )
                    {
                        if( tile.Flags & D3DTILE_FLAGS_Z32BITS )
                            wcscat( strType, L" ( 32-bit" );
                        else
                            wcscat( strType, L" ( 16-bit" );
                        if( tile.Flags & D3DTILE_FLAGS_ZCOMPRESS )
                            wcscat( strType, L" compressed Z" );
                        wcscat( strType, L" )" );
                    }
                }

                swprintf( strBuffer, L"Tile %d: %s", i, strType );
                m_Font12.DrawText( 64.0f, fCursorY, 0xffffffff, strBuffer );
                fCursorY+=19;
            }
        }
        m_Font12.End();
    }

    // If we rendered the scene to a secondary render target, then we now need
    // to render the texture to the primary backbuffer.
    if( m_bUseSecondaryRenderTarget )
    {
        // Set the render target back to be the app's main backbuffer
        m_pd3dDevice->SetRenderTarget( m_pBackBuffer, m_pDepthBuffer );

        // Render the secondary color surface to the screen
        struct VERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
        VERTEX v[4];
        v[0].p = D3DXVECTOR4(   0 - 0.5f,   0 - 0.5f, 0, 0 );  v[0].tu =   0; v[0].tv =   0;
        v[1].p = D3DXVECTOR4( 640 - 0.5f,   0 - 0.5f, 0, 0 );  v[1].tu = 640; v[1].tv =   0;
        v[2].p = D3DXVECTOR4( 640 - 0.5f, 480 - 0.5f, 0, 0 );  v[2].tu = 640; v[2].tv = 480;
        v[3].p = D3DXVECTOR4(   0 - 0.5f, 480 - 0.5f, 0, 0 );  v[3].tu =   0; v[3].tv = 480;
        m_pd3dDevice->SetTexture( 0, m_pSecondaryTexture );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,   FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,   FALSE );
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, v, 6*sizeof(FLOAT) );
    }
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\debug.h ===
//-----------------------------------------------------------------------------
//  
//  File: debug.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>

//////////////////////////////////////////////////////////////////////
// Clear backbuffer
//
extern D3DXCOLOR g_DebugClearColor;
extern float g_fDebugClearZ;
extern DWORD g_dwDebugClearStencil;
extern HRESULT DebugClear();

//////////////////////////////////////////////////////////////////////
// Clear region of current render target (even if it's swizzled)
//
extern HRESULT DebugRect(RECT *pRect, DWORD dwColor);

//////////////////////////////////////////////////////////////////////
// Swap backbuffer to the front
//
extern DWORD g_dwDebugPresentPause;	// Sleep delay after presentation
extern HRESULT DebugPresent();

//////////////////////////////////////////////////////////////////////
// Display texture
//
extern bool g_bDebugExpand ;		// expand to fill screen
extern bool g_bDebugExpandAspect;	// preserve aspect ratio when expanding
extern bool g_bDebugAlpha;			// replicate alpha to the color channels
extern D3DXCOLOR g_bDebugTFACTOR;	// modulation factor
HRESULT DebugTexture(LPDIRECT3DTEXTURE8 pTexture, UINT iLevel);

//////////////////////////////////////////////////////////////////////
// Draw bounding box in world coords
//
extern D3DXVECTOR3 g_vDebugMin, g_vDebugMax;	// used if NULL is passed as pvMin or pvMax
extern HRESULT DebugBoundingBox(const D3DXVECTOR3 *pvMin, const D3DXVECTOR3 *pvMax, D3DCOLOR color);

//////////////////////////////////////////////////////////////////////
// Draw line segment in world coords
//
extern D3DXVECTOR3 g_vDebugStart, g_vDebugEnd;	// used if NULL is passed as pvStart or pvEnd
extern HRESULT DebugLine(const D3DXVECTOR3 *pvStart, const D3DXVECTOR3 *pvEnd);
extern HRESULT DebugLineColor(const D3DXVECTOR3 *pvStart, D3DCOLOR colorStart, const D3DXVECTOR3 *pvEnd, D3DCOLOR colorEnd);

//////////////////////////////////////////////////////////////////////
// Debug frustum
//
extern D3DXVECTOR3 g_vDebugFromDir;		// offset for viewing from "outside" of current frustum
extern D3DXVECTOR3 g_vDebugFrom;	// camera coords (post world and view), set by DebugSetFrustum depending on g_DebugFrustumMode
extern D3DXVECTOR3 g_vDebugAt;		// also set by DebugSetFrustum
extern D3DXVECTOR3 g_vDebugUp;		// used as up direction in DebugSetFrustum
enum DebugFrustumMode { 
	FRUSTUM_CENTER, // default is FRUSTUM_CENTER, where FromDir is scaled and offset from center of frustum
	FRUSTUM_FRONT,	// FromDir is offset (without scaling) from center of front clip plane
	FRUSTUM_POINT	// From and Up are left unchanged and used to set the offset frustum matrix
};
extern DebugFrustumMode g_DebugFrustumMode; 
HRESULT DebugSetFrustum();		// replaces current projection matrix with offset projection

HRESULT DebugFrustumBegin();	// set render target to back buffer and calls DebugSetFrustum
HRESULT DebugFrustumEnd();		// restores original projection and render target

/* Example use:
  // set projection before we get to here
  DebugFrustumBegin();
  // regular drawing calls 
  DebugFrustumEnd();
  DebugPresent(); // to show results
*/

//////////////////////////////////////////////////////////////////////
// Debug save texture
//
// Calls XGWriteSurfaceToFile after unswizzling, if needed.
//
HRESULT DebugSaveTexture(LPDIRECT3DTEXTURE8 pTexture, UINT iLevel, CHAR *strPath);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\debug.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: debug.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Media viewers for debugging texture generation
//-----------------------------------------------------------------------------
#include "debug.h"
#include "SwizzleFormat.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//////////////////////////////////////////////////////////////////////
// State set and restore on scope exit
//
#define SET_D3DTSS(STAGE, NAME, VALUE)\
	struct _D3DTSS_STAGE##STAGE##_##NAME {\
 		DWORD m_dw; \
		 _D3DTSS_STAGE##STAGE##_##NAME(DWORD dw) { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetTextureStageState(STAGE, NAME, &m_dw);\
			g_pd3dDevice->SetTextureStageState(STAGE, NAME, dw);\
		}\
		 ~_D3DTSS_STAGE##STAGE##_##NAME() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetTextureStageState(STAGE, NAME, m_dw);\
		}\
	} __D3DTSS_STAGE##STAGE##_##NAME(VALUE)
#define SET_D3DTEXTURE(STAGE, TEXTURE)\
	struct _D3DTEXTURE_STAGE##STAGE {\
 		D3DBaseTexture *m_pTexture; \
		 _D3DTEXTURE_STAGE##STAGE(D3DBaseTexture *pTexture) { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetTexture(STAGE, &m_pTexture);\
			g_pd3dDevice->SetTexture(STAGE, pTexture);\
		}\
		 ~_D3DTEXTURE_STAGE##STAGE() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetTexture(STAGE, m_pTexture);\
			 if (m_pTexture != NULL) m_pTexture->Release();\
		}\
	} __D3DTEXTURE_STAGE##STAGE(TEXTURE)
#define SET_D3DRS(NAME, VALUE)\
	struct _D3DRS_##NAME {\
 		DWORD m_dw; \
		 _D3DRS_##NAME(DWORD dw) { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetRenderState(NAME, &m_dw);\
			g_pd3dDevice->SetRenderState(NAME, dw);\
		}\
		 ~_D3DRS_##NAME() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetRenderState(NAME, m_dw);\
		}\
	} __D3DRS_##NAME(VALUE)
#define SET_D3DVERTEXSHADER(VALUE)\
	struct _D3DVERTEXSHADER {\
 		DWORD m_dw; \
		 _D3DVERTEXSHADER(DWORD dw) { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetVertexShader(&m_dw);\
			g_pd3dDevice->SetVertexShader(dw);\
		}\
		 ~_D3DVERTEXSHADER() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetVertexShader(m_dw);\
		}\
	} __D3DVERTEXSHADER(VALUE)
#define SET_D3DPIXELSHADER(VALUE)\
	struct _D3DPIXELSHADER {\
 		DWORD m_dw; \
		 _D3DPIXELSHADER(DWORD dw) { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetPixelShader(&m_dw);\
			g_pd3dDevice->SetPixelShader(dw);\
		}\
		 ~_D3DPIXELSHADER() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetPixelShader(m_dw);\
		}\
	} __D3DPIXELSHADER(VALUE)
#define SET_D3DVIEWPORT(PVIEWPORT)\
	struct _D3DVIEWPORT {\
 		D3DVIEWPORT8 m_viewport; \
		 _D3DVIEWPORT(D3DVIEWPORT *pViewport) { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetViewport(&m_viewport);\
			g_pd3dDevice->SetViewport(pViewport);\
		}\
		 ~_D3DVIEWPORT() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetViewport(&m_viewport);\
		}\
	} __D3DVIEWPORT(PVIEWPORT)
#define SET_D3DTRANSFORM(NAME, PTRANSFORM)\
	struct _D3DTRANSFORM_##NAME {\
 		D3DMATRIX m_transform; \
		 _D3DTRANSFORM_##NAME(D3DMATRIX *pTransform) { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetTransform(NAME, &m_transform);\
			g_pd3dDevice->SetTransform(NAME, pTransform);\
		}\
		 ~_D3DTRANSFORM_##NAME() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetTransform(NAME, &m_transform);\
		}\
	} __D3DTRANSFORM_##NAME(PTRANSFORM)

//////////////////////////////////////////////////////////////////////
// Make the backbuffer the render target temporarily
//
#define DEBUG_NSTACK 10
struct DebugSave {
	IDirect3DSurface8 *pBackBuffer, *pZBuffer;
	bool bBeginScene;
} g_rDebugSave[DEBUG_NSTACK];
UINT g_iDebugSave = 0;

HRESULT DebugPush(bool bSetRenderTarget = true)
{
	if (g_iDebugSave >= DEBUG_NSTACK)
		return E_FAIL;	// stack overflow
	
	// make sure we're not inside a BeginScene block
	g_rDebugSave[g_iDebugSave].bBeginScene = false;
	HRESULT hr = g_pd3dDevice->BeginScene();
	if (FAILED(hr))
		g_rDebugSave[g_iDebugSave].bBeginScene = true; // assume BeginScene failed because we're already inside a BeginScene
	g_pd3dDevice->EndScene();

	// make the backbuffer the current render target
	g_pd3dDevice->GetRenderTarget(&g_rDebugSave[g_iDebugSave].pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&g_rDebugSave[g_iDebugSave].pZBuffer);
	IDirect3DSurface8 *pBackBuffer = NULL;
	g_pd3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer);
	g_pd3dDevice->SetRenderTarget(pBackBuffer, NULL);
	pBackBuffer->Release();
	
	// make sure all the commands so far are done
	g_pd3dDevice->BlockUntilIdle();
	
	g_iDebugSave++;
	return S_OK;
}

HRESULT DebugPop()
{
	if (g_iDebugSave == 0 || g_iDebugSave >= DEBUG_NSTACK)
		return E_FAIL;	// stack underflow or wackiness
	g_iDebugSave--;

	// restore render target, etc.
	g_pd3dDevice->SetRenderTarget(g_rDebugSave[g_iDebugSave].pBackBuffer, g_rDebugSave[g_iDebugSave].pZBuffer);
	if (g_rDebugSave[g_iDebugSave].pBackBuffer) g_rDebugSave[g_iDebugSave].pBackBuffer->Release();
	if (g_rDebugSave[g_iDebugSave].pZBuffer) g_rDebugSave[g_iDebugSave].pZBuffer->Release();
	if (g_rDebugSave[g_iDebugSave].bBeginScene)
		g_pd3dDevice->BeginScene();
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Clear backbuffer
//
D3DXCOLOR g_DebugClearColor(0.3f, 0.3f, 0.4f, 1.f);
float g_fDebugClearZ = 1.f;
DWORD g_dwDebugClearStencil = 0L;

HRESULT DebugClear()
{
	HRESULT hr = DebugPush();
	if (FAILED(hr))
		return hr;

	// clear
	g_pd3dDevice->BeginScene();
	hr = g_pd3dDevice->Clear(0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, g_DebugClearColor, g_fDebugClearZ, g_dwDebugClearStencil);
	g_pd3dDevice->EndScene();
	
	return DebugPop();
}

//////////////////////////////////////////////////////////////////////
// Clear region of current render target (even if it's swizzled)
//
RECT g_DebugRect;	// scratch rectangle
HRESULT DebugRect(RECT *pRect, DWORD dwColor)
{
	struct quad {
		float x, y, z, w1;
	} aQuad[4] =
	  { //   X                  Y                     Z     1/W
		  {pRect->left  - 0.5f, pRect->top - 0.5f,    1.0f, 1.0f },
		  {pRect->right - 0.5f, pRect->top - 0.5f,    1.0f, 1.0f },
		  {pRect->left  - 0.5f, pRect->bottom - 0.5f, 1.0f, 1.0f },
		  {pRect->right - 0.5f, pRect->bottom - 0.5f, 1.0f, 1.0f }
	  };
	SET_D3DVERTEXSHADER( D3DFVF_XYZRHW );
	SET_D3DPIXELSHADER(0);
	SET_D3DRS( D3DRS_ZFUNC, D3DCMP_ALWAYS );
	SET_D3DRS( D3DRS_ZWRITEENABLE, FALSE );
	SET_D3DRS( D3DRS_ALPHATESTENABLE, FALSE );
	SET_D3DRS( D3DRS_NORMALIZENORMALS, FALSE );
	SET_D3DRS( D3DRS_ALPHABLENDENABLE, TRUE );
	SET_D3DRS( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
	SET_D3DRS( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
	SET_D3DRS( D3DRS_LIGHTING, FALSE );
	SET_D3DRS( D3DRS_TEXTUREFACTOR, dwColor );
	SET_D3DTEXTURE( 0, NULL );
	SET_D3DTSS( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
	SET_D3DTSS( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
	SET_D3DTSS( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
	SET_D3DTSS( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
	SET_D3DTSS( 0, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 1, NULL );
	SET_D3DTSS( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 1, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 2, NULL );
	SET_D3DTSS( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 2, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 3, NULL );
	SET_D3DTSS( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 3, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );

	// make sure we're not inside a BeginScene block
	bool bBeginScene = false;
	HRESULT hr = g_pd3dDevice->BeginScene();
	if (FAILED(hr))
		bBeginScene = true; // assume BeginScene failed because we're already inside a BeginScene
	g_pd3dDevice->EndScene();

	// make sure all the commands so far are done before we draw the texture
	g_pd3dDevice->BlockUntilIdle();
	
	// clear rectangle
	g_pd3dDevice->BeginScene();
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad));
	g_pd3dDevice->EndScene();

	// clean up
	if (bBeginScene)
		g_pd3dDevice->BeginScene();
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Swap backbuffer to the front
//
DWORD g_dwDebugPresentPause = 0;
HRESULT DebugPresent()
{
	HRESULT hr;
	hr = g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	if (g_dwDebugPresentPause)
		Sleep(g_dwDebugPresentPause);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Display texture
//
bool g_bDebugExpand = true;
bool g_bDebugExpandAspect = true;	// preserve aspect ratio when expanding
bool g_bDebugAlpha = false;
D3DXCOLOR g_bDebugTFACTOR(1.f, 1.f, 1.f, 1.f);

HRESULT DebugTexture(LPDIRECT3DTEXTURE8 pTexture, UINT iLevel)
{
	if (pTexture == NULL)
		return S_FALSE;
	DWORD nLevel = pTexture->GetLevelCount();
	if (iLevel >= nLevel) 
		return S_FALSE;
	HRESULT	hr = DebugPush();
	if (FAILED(hr))
		return hr;
	D3DDISPLAYMODE DisplayMode;
	g_pd3dDevice->GetDisplayMode(&DisplayMode);
	UINT Width, Height;
	if (g_bDebugExpand)
	{
		if (!g_bDebugExpandAspect)
			Width = Height = 400;
		else
		{
			// Maintain aspect ratio.  Shrink longest dimension to screen.
			D3DSURFACE_DESC desc;
			pTexture->GetLevelDesc(iLevel, &desc);
			if (desc.Width > desc.Height)
			{
				Width = 400;
				Height = desc.Height * Width / desc.Width;
			}
			else
			{
				Height = 400;
				Width = desc.Width * Height / desc.Height;
			}
		}
	}
	else
	{
		D3DSURFACE_DESC desc;
		pTexture->GetLevelDesc(iLevel, &desc);
		Width = desc.Width;
		Height = desc.Height;
	}
	UINT WidthOffset = (DisplayMode.Width - Width) / 2;		// center texture
	UINT HeightOffset = (DisplayMode.Height - Height) / 2;
	struct quad {
		float x, y, z, w1;
		float u, v;
	} aQuad[4] =
	  { //   X             Y                                          Z    1/W    u     v
		  {WidthOffset - 0.5f,         HeightOffset - 0.5f,          1.0f, 1.0f, 0.0f, 0.0f },
		  {WidthOffset + Width - 0.5f, HeightOffset - 0.5f,          1.0f, 1.0f, 1.0f, 0.0f },
		  {WidthOffset - 0.5f,         HeightOffset + Height - 0.5f, 1.0f, 1.0f, 0.0f, 1.0f },
		  {WidthOffset + Width - 0.5f, HeightOffset + Height - 0.5f, 1.0f, 1.0f, 1.0f, 1.0f }
	  };
	SET_D3DVERTEXSHADER( D3DFVF_XYZRHW | D3DFVF_TEX1 );
	SET_D3DPIXELSHADER(0);
	SET_D3DRS( D3DRS_ZFUNC, D3DCMP_ALWAYS );
	SET_D3DRS( D3DRS_ZWRITEENABLE, FALSE );
	SET_D3DRS( D3DRS_ALPHATESTENABLE, FALSE );
	SET_D3DRS( D3DRS_NORMALIZENORMALS, FALSE );
	SET_D3DRS( D3DRS_ALPHABLENDENABLE, FALSE );
	SET_D3DRS( D3DRS_LIGHTING, FALSE );
	SET_D3DRS( D3DRS_TEXTUREFACTOR, g_bDebugTFACTOR );
	SET_D3DTEXTURE( 0, pTexture );
	SET_D3DTSS( 0, D3DTSS_MAXMIPLEVEL, iLevel);
	float fBias = -1000.f; // bias mipmap toward the more detailed level
	SET_D3DTSS( 0, D3DTSS_MIPMAPLODBIAS, *((LPDWORD) (&fBias)));
	SET_D3DTSS( 0, D3DTSS_MINFILTER, D3DTEXF_POINT);
	SET_D3DTSS( 0, D3DTSS_MIPFILTER, D3DTEXF_POINT);
	SET_D3DTSS( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT);
	SET_D3DTSS( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );
	SET_D3DTSS( 0, D3DTSS_COLORARG1, g_bDebugAlpha ? D3DTA_TEXTURE | D3DTA_ALPHAREPLICATE : D3DTA_TEXTURE );
	SET_D3DTSS( 0, D3DTSS_COLORARG2, D3DTA_TFACTOR );
	SET_D3DTSS( 0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	SET_D3DTSS( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	SET_D3DTSS( 0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR );
	SET_D3DTSS( 0, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 1, NULL );
	SET_D3DTSS( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 1, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 2, NULL );
	SET_D3DTSS( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 2, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 3, NULL );
	SET_D3DTSS( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 3, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );

	// draw the texture
	g_pd3dDevice->BeginScene();
	g_pd3dDevice->Clear(0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
		g_DebugClearColor, g_fDebugClearZ, g_dwDebugClearStencil);
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad));
	g_pd3dDevice->EndScene();
	DebugPresent();
	
	return DebugPop();
}

//////////////////////////////////////////////////////////////////////
// Draw bounding box in world coords
//
D3DXVECTOR3 g_vDebugMin, g_vDebugMax;	// used if NULL is passed as pvMin or pvMax
HRESULT DebugBoundingBox(const D3DXVECTOR3 *pvMin, const D3DXVECTOR3 *pvMax, D3DCOLOR color)
{
	// set and save state
	SET_D3DRS(D3DRS_LIGHTING, FALSE);
//	SET_D3DRS(D3DRS_ZENABLE, D3DZB_FALSE);
//	SET_D3DRS(D3DRS_ZWRITEENABLE, FALSE );
	SET_D3DRS(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
	SET_D3DVERTEXSHADER(D3DFVF_XYZ|D3DFVF_DIFFUSE); // vertex shader
	SET_D3DTEXTURE( 0, NULL);
	SET_D3DTSS( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
	SET_D3DTSS( 0,D3DTSS_COLORARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	SET_D3DTSS( 0,D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 1, NULL);
	SET_D3DTSS( 1,D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 1,D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 1,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 2, NULL);
	SET_D3DTSS( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 2, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 3, NULL);
	SET_D3DTSS( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 3, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );

	// draw world-coordinate bounding box
	D3DXVECTOR3 vMin = pvMin ? *pvMin : g_vDebugMin;
	D3DXVECTOR3 vMax = pvMax ? *pvMax : g_vDebugMax;
	struct BoundingBoxVertex {
		D3DVECTOR xyz;
		D3DCOLOR color;
	} rBoundingBoxVertex[8] = {
		{ vMin.x, vMin.y, vMin.z, 0xff444444 & color },	// masks highlight the different corners
		{ vMax.x, vMin.y, vMin.z, 0xffff4444 & color },
		{ vMin.x, vMax.y, vMin.z, 0xff44ff44 & color },
		{ vMax.x, vMax.y, vMin.z, 0xffffff44 & color },
		{ vMin.x, vMin.y, vMax.z, 0xff4444ff & color },
		{ vMax.x, vMin.y, vMax.z, 0xffff44ff & color },
		{ vMin.x, vMax.y, vMax.z, 0xff44ffff & color },
		{ vMax.x, vMax.y, vMax.z, 0xffffffff & color },
	};
	static WORD rBoundingBoxLines[] = {
		0, 1,	1, 3,	3, 2,	2, 0,
		0, 4,	1, 5,	2, 6,	3, 7,
		4, 5,	5, 7,	7, 6,	6, 4,
	};
	static UINT nBoundingBoxLines = sizeof(rBoundingBoxLines) / sizeof(WORD) / 2;
    g_pd3dDevice->DrawIndexedPrimitiveUP(D3DPT_LINELIST, 0, 8, nBoundingBoxLines, rBoundingBoxLines, 
		D3DFMT_INDEX16, rBoundingBoxVertex, sizeof(BoundingBoxVertex));
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Draw line segment in world coords
//
D3DXVECTOR3 g_vDebugStart, g_vDebugEnd;	// used if NULL is passed as pvStart or pvEnd

HRESULT DebugLine(const D3DXVECTOR3 *pvStart, const D3DXVECTOR3 *pvEnd)
{
	return DebugLineColor(pvStart, 0xffff0000, pvEnd, 0xff00ffff);	// red to cyan
}

HRESULT DebugLineColor(const D3DXVECTOR3 *pvStart, D3DCOLOR colorStart, const D3DXVECTOR3 *pvEnd, D3DCOLOR colorEnd)
{
	// set and save state
	SET_D3DRS(D3DRS_LIGHTING, FALSE);
//	SET_D3DRS(D3DRS_ZENABLE, D3DZB_FALSE);
//	SET_D3DRS(D3DRS_ZWRITEENABLE, FALSE );
	SET_D3DRS(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
	SET_D3DVERTEXSHADER(D3DFVF_XYZ|D3DFVF_DIFFUSE); // vertex shader
	SET_D3DTEXTURE( 0, NULL);
	SET_D3DTSS( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
	SET_D3DTSS( 0,D3DTSS_COLORARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	SET_D3DTSS( 0,D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 1, NULL);
	SET_D3DTSS( 1,D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 1,D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 1,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 2, NULL);
	SET_D3DTSS( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 2, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 3, NULL);
	SET_D3DTSS( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 3, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );

	// draw world-coordinate line
 	D3DXVECTOR3 vStart = pvStart ? *pvStart : g_vDebugStart;
	D3DXVECTOR3 vEnd = pvEnd ? *pvEnd : g_vDebugEnd;
	struct LineVertex {
		D3DVECTOR xyz;
		D3DCOLOR color;
	} rLineVertex[2] = {
		{ vStart.x, vStart.y, vStart.z, colorStart },
		{ vEnd.x, vEnd.y, vEnd.z, colorEnd }
	};
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINELIST, 1, rLineVertex, sizeof(LineVertex));
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Debug frustum drawing
//
D3DXVECTOR3 g_vDebugFromDir(0.1f, 0.2f, -0.9f);
DebugFrustumMode g_DebugFrustumMode = FRUSTUM_CENTER;
D3DXVECTOR3 g_vDebugFrustumWorldPoint(0.f, 0.f, 0.f);
bool g_bDebugFromFront = false;	// if set, the debug frustum is offset from the front of the clip region rather than the center
bool g_bDebugFrustumOverrideClip = true;
float g_bDebugFrustumNear = 0.1f;	// used when g_bDebugFrustumOverrideClip is true
float g_bDebugFrustumFar = 10000.f;
D3DXVECTOR3 g_vDebugFrom; // set by DebugFrustumBegin to center of frustum + radius * g_vDebugFromDir
D3DXVECTOR3 g_vDebugAt; // set by DebugFrustumBegin to center of frustum
D3DXVECTOR3 g_vDebugUp(0.f, 1.f, 0.f);
D3DXMATRIX g_matDebugFrustumSave;
D3DXMATRIX g_matDebugFrustumSaveInv;
D3DXMATRIX g_matDebugFrustumOutside;	// modified from g_matDebugFrustumSave to view from "outside" of original frustum
bool g_bDebugFrustumBegin = false;
bool g_bDebugFrustumBeginScene;

static struct FrustumVertex {
	D3DVECTOR xyz;
	D3DCOLOR color;
} rFrustumVertex[8] = {
	{ -1.f, -1.f, 0.f, 0xff444400 },
	{  1.f, -1.f, 0.f, 0xffff4400 },
	{ -1.f,  1.f, 0.f, 0xff44ff00 },
	{  1.f,  1.f, 0.f, 0xffffff00 },
	{ -1.f, -1.f, 1.f, 0xff4444ff },
	{  1.f, -1.f, 1.f, 0xffff44ff },
	{ -1.f,  1.f, 1.f, 0xff44ffff },
	{  1.f,  1.f, 1.f, 0xffffffff },
};
static WORD rFrustumLines[] = {
	0, 1,	1, 3,	3, 2,	2, 0,
	0, 4,	1, 5,	2, 6,	3, 7,
	4, 5,	5, 7,	7, 6,	6, 4,
};
static UINT nFrustumLines = sizeof(rFrustumLines) / sizeof(WORD) / 2;

HRESULT DebugDrawFrustum()
{
	// set and save state
	SET_D3DRS(D3DRS_LIGHTING, FALSE);
//	SET_D3DRS(D3DRS_ZENABLE, D3DZB_FALSE);
//	SET_D3DRS(D3DRS_ZWRITEENABLE, FALSE );
	SET_D3DRS(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
	SET_D3DVERTEXSHADER(D3DFVF_XYZ|D3DFVF_DIFFUSE); // vertex shader
	SET_D3DTEXTURE( 0, NULL);
	SET_D3DTSS( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
	SET_D3DTSS( 0,D3DTSS_COLORARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	SET_D3DTSS( 0,D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 1, NULL);
	SET_D3DTSS( 1,D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 1,D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 1,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 2, NULL);
	SET_D3DTSS( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 2, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 3, NULL);
	SET_D3DTSS( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 3, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	D3DXMATRIX matIdentity;
	D3DXMatrixIdentity(&matIdentity);
	SET_D3DTRANSFORM( D3DTS_WORLD, &matIdentity);
	SET_D3DTRANSFORM( D3DTS_VIEW, &matIdentity);

	// transform frustum vertices
	FrustumVertex rVertex[8];
	for (UINT i = 0; i < 8; i++)
	{
		D3DXVec3TransformCoord((D3DXVECTOR3 *)&rVertex[i].xyz, (D3DXVECTOR3 *)&rFrustumVertex[i].xyz, &g_matDebugFrustumSaveInv);
		rVertex[i].color = rFrustumVertex[i].color;
	}
	
	// draw world-coordinate frustum
    g_pd3dDevice->DrawIndexedPrimitiveUP(D3DPT_LINELIST, 0, 8, nFrustumLines, rFrustumLines, D3DFMT_INDEX16, rVertex, sizeof(FrustumVertex));
	return S_OK;
}

inline float MAX(float a, float b) { return a > b ? a : b; }
inline float MIN(float a, float b) { return a < b ? a : b; }
static void UnionBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax, const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax)
{
	pvMin->x = MIN(pvMin->x, vMin.x);
	pvMin->y = MIN(pvMin->y, vMin.y);
	pvMin->z = MIN(pvMin->z, vMin.z);
	pvMax->x = MAX(pvMax->x, vMax.x);
	pvMax->y = MAX(pvMax->y, vMax.y);
	pvMax->z = MAX(pvMax->z, vMax.z);
}

HRESULT DebugSetFrustum()
{
	// Invert current frustum
	g_pd3dDevice->GetTransform( D3DTS_PROJECTION, &g_matDebugFrustumSave );
	float fDet;
	D3DXMatrixInverse(&g_matDebugFrustumSaveInv, &fDet, &g_matDebugFrustumSave);
	
	// Get bounding box of inverse frustum in view coords
	D3DXVECTOR3 vMin(FLT_MAX, FLT_MAX, FLT_MAX), vMax(-FLT_MAX, -FLT_MAX, -FLT_MAX);
	FrustumVertex rVertex[8];
	for (UINT i = 0; i < 8; i++)
	{
		D3DXVec3TransformCoord((D3DXVECTOR3 *)&rVertex[i].xyz, (D3DXVECTOR3 *)&rFrustumVertex[i].xyz, &g_matDebugFrustumSaveInv);
		UnionBox(&vMin, &vMax, rVertex[i].xyz, rVertex[i].xyz);
	}

	// Find a reasonable viewing position 
	switch (g_DebugFrustumMode)
	{
	case FRUSTUM_CENTER:
	{
		// offset from center of bounding box
		D3DXVECTOR3 vCenter = 0.5f * (vMin + vMax);
		D3DXVECTOR3 vCorner = vMax - vCenter;
		float fRadius = D3DXVec3Length(&vCorner);
		g_vDebugAt = vCenter;
		g_vDebugFrom = vCenter + fRadius * g_vDebugFromDir;
		break;
	}

	case FRUSTUM_FRONT:
	{
		// offset from center of near clip plane
		D3DXVECTOR3 vCenter = 0.5f * (vMin + vMax);
		vCenter.z = vMin.z;
		g_vDebugAt = vCenter;
		g_vDebugFrom = vCenter + g_vDebugFromDir;
		break;
	}

	case FRUSTUM_POINT:
		// leave From and At as is
		break;
	}
	D3DXMATRIX matViewOutside;
	D3DXMatrixLookAtLH( &matViewOutside, &g_vDebugFrom, &g_vDebugAt, &g_vDebugUp);

	// Get clipping planes
	D3DXVECTOR3 vEye = g_vDebugAt - g_vDebugFrom;
	D3DXVec3Normalize(&vEye, &vEye);
	float fMin = FLT_MAX, fMax = -FLT_MAX;
	for (i = 0; i < 8; i++)
	{
		D3DXVECTOR3 vOffset = *(D3DXVECTOR3 *)&rVertex[i].xyz - g_vDebugFrom;
		float f = D3DXVec3Dot(&vOffset, &vEye);
		if (f < fMin) fMin = f;
		if (f > fMax) fMax = f;
	}
	// override clip
	if (g_bDebugFrustumOverrideClip)
	{
		fMin = g_bDebugFrustumNear;
		fMax = g_bDebugFrustumFar;
	}
	
	// Make new projection that maps to "outside view"
	D3DXMATRIX matProj;
	D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.f/480.f, MAX(0.1f, fMin), fMax );
	g_matDebugFrustumOutside = /* g_matDebugFrustumSave * g_matDebugFrustumSaveInv * */ matViewOutside * matProj;
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &g_matDebugFrustumOutside );

	float fEps = 1e-6f;
	if (fabs(fDet) < fEps)
		return S_FALSE;	// singular matrix
	else
		return S_OK;
}

HRESULT DebugFrustumBegin()
{
	HRESULT hr;
	if (g_bDebugFrustumBegin)
		return E_FAIL;	// DebugFrustumBegin called twice
	g_bDebugFrustumBegin = true;
	hr = DebugPush();
	if (FAILED(hr))
		return hr;

	hr = DebugSetFrustum();
	if (FAILED(hr))
		return hr;

//	// Draw the frustum
//	g_pd3dDevice->Clear(0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, g_DebugClearColor, g_fDebugClearZ, g_dwDebugClearStencil);
//	DebugDrawFrustum();

	return hr;
}

HRESULT DebugFrustumEnd()
{
	if (!g_bDebugFrustumBegin)
		return E_FAIL;
	
	// Draw the frustum at the end
	DebugDrawFrustum();

	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &g_matDebugFrustumSave );	// restore projection
	g_bDebugFrustumBegin = false;
	return DebugPop();
}

//////////////////////////////////////////////////////////////////////
// Debug save texture level to a file
//
HRESULT DebugSaveTexture(LPDIRECT3DTEXTURE8 pTexture, UINT iLevel, CHAR *strPath)
{
	HRESULT hr;
	if (pTexture == NULL)
		return S_FALSE;
	DWORD nLevel = pTexture->GetLevelCount();
	if (iLevel >= nLevel) 
		return S_FALSE;
	D3DSURFACE_DESC desc;
	hr = pTexture->GetLevelDesc(iLevel, &desc);
	if (FAILED(hr))
		return hr;
	LPDIRECT3DSURFACE8 pSurface = NULL;
	hr = pTexture->GetSurfaceLevel(iLevel, &pSurface);
	if (FAILED(hr))
		return hr;
	if (XGIsSwizzledFormat(desc.Format))
	{
		D3DFORMAT fmt = MapSwizzledToLinearFormat(desc.Format);
		if (fmt == desc.Format)
		{
			pSurface->Release();
			return E_FAIL;	// format not supported
		}

		// Create temporary surface to unswizzle
		LPDIRECT3DSURFACE8 pSurfaceLinear = NULL;
		hr = g_pd3dDevice->CreateImageSurface(desc.Width, desc.Height, fmt, &pSurfaceLinear);
		if (FAILED(hr))
		{
			pSurface->Release();
			return hr;
		}

		// Unswizzle the texture
		D3DLOCKED_RECT lockedRect;
		hr = pSurface->LockRect(&lockedRect, NULL, D3DLOCK_READONLY);
		if (FAILED(hr))
		{
			pSurface->Release();
			pSurfaceLinear->Release();
			return hr;
		}
		D3DLOCKED_RECT lockedRectLinear;
		hr = pSurfaceLinear->LockRect(&lockedRectLinear, NULL, 0);
		if (FAILED(hr))
		{
			pSurface->UnlockRect();
			pSurface->Release();
			pSurfaceLinear->Release();
			return hr;
		}
		XGUnswizzleRect(lockedRect.pBits, desc.Width, desc.Height, NULL, 
			lockedRectLinear.pBits, lockedRectLinear.Pitch, NULL, 
			XGBytesPerPixelFromFormat(desc.Format));
		pSurfaceLinear->UnlockRect();
		pSurface->UnlockRect();

		// Use the linear surface instead of the swizzled one
		pSurface->Release();
		pSurface = pSurfaceLinear; // this will be Release'd below
	}
	hr = XGWriteSurfaceToFile(pSurface, strPath);
	pSurface->Release();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\Mipmap.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: mipmap.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Mipmap filtering using the GPU
//
//-----------------------------------------------------------------------------
#include "mipmap.h"
#include <XBUtil.h>
#include "SwizzleFormat.h"
#include <assert.h>

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//////////////////////////////////////////////////////////////////////
// Default filter is lanczos with halfwidth 2 and 2 supersamples.  That
// works out to 8 taps per output pixel, with a small negative lobe for
// sharpness.
static MipmapFilter s_MipmapFilterDefault(2, 2.f, MipmapFilter::lanczos, MIPMAPFILTER_NORMALIZE_ADD);

//////////////////////////////////////////////////////////////////////
// Sample filter kernel, weight by super sample area, and normalize.
//
MipmapFilter::MipmapFilter(UINT nSuperSample,
						   float fHalfWidth,
						   float (*pfFilter)(float x, float fHalfWidth),
						   DWORD dwFlags)
{
	if (nSuperSample == 0) nSuperSample = 1;
	m_nSuperSample = nSuperSample;
	m_fHalfWidth = fHalfWidth;

	// If number of supersamples is even, offset by half pixel.
	float fSampleOffset;
	if (nSuperSample % 2)
		fSampleOffset = 0.f;
	else
		fSampleOffset = 0.5f;		

	// Get number of supersamples in support
	int iSuperMin = (int)ceilf(-fHalfWidth * nSuperSample - fSampleOffset);
	int iSuperMax = (int)floorf(fHalfWidth * nSuperSample - fSampleOffset);
	m_nSample = iSuperMax - iSuperMin + 1;

	// Get adjusted filter support width
	float fStretch = 1.f;
	if (dwFlags & MIPMAPFILTER_STRETCH) 
	{
		fStretch = 1.f - 0.5f / fHalfWidth;
		float fStretchWidth = fHalfWidth / fStretch;
		iSuperMin = (int)ceilf(-fHalfWidth * nSuperSample - fSampleOffset);
		iSuperMax = (int)floorf(fHalfWidth * nSuperSample - fSampleOffset);
		m_nSample = iSuperMax - iSuperMin + 1;
	}

	// Allocate sample array
	m_rSample = new Sample [ m_nSample ];

	// Sample filter at supersample positions
	float fStep = 1.f / nSuperSample;
	float fWeight = fStretch * fStep;
	UINT iSample = 0;
	m_iSuperMin = m_iSuperMax = 0;
	for (int iSuper = iSuperMin; iSuper <= iSuperMax; iSuper++)
	{
		float fOffset = (iSuper + fSampleOffset) * fStep;
		float fValue = fWeight * (*pfFilter)(fOffset * fStretch, fHalfWidth);
		if (!(dwFlags & MIPMAPFILTER_KEEPZEROS))
		{
			float fQuant = 255.f * fabsf(fValue);
			if (fQuant < 0.5f) continue; // remove values that quantize to zero
		}
		m_rSample[iSample].m_fOffset = fOffset;
		m_rSample[iSample].m_fValue = fValue;
		iSample++;
		if (iSuper < m_iSuperMin) m_iSuperMin = iSuper;
		if (iSuper > m_iSuperMax) m_iSuperMax = iSuper;
	}

	// Re-allocate sample array after removing zeros
	if (iSample < m_nSample)
	{
		Sample *rSampleOld = m_rSample;
		m_nSample = iSample;
		m_rSample = new Sample [ m_nSample ];
		for (iSample = 0; iSample < m_nSample; iSample++)
			m_rSample[iSample] = rSampleOld[iSample];
		delete [] rSampleOld;
	}

	// Normalize
	if (dwFlags & MIPMAPFILTER_NORMALIZE_MULTIPLY)
		NormalizeMultiply();
	else if (dwFlags & MIPMAPFILTER_NORMALIZE_ADD)
		NormalizeAdd();
}

//////////////////////////////////////////////////////////////////////
// Add (1 - sum)/N to each filter value.
//
void MipmapFilter::NormalizeAdd()
{
	float fSum = 0.f;
	for (UINT iSample = 0; iSample < m_nSample; iSample++)
		fSum += m_rSample[iSample].m_fValue;
	float fOffset = (1.f - fSum) / m_nSample;
	for ( iSample = 0; iSample < m_nSample; iSample++)
		m_rSample[iSample].m_fValue += fOffset;
}

//////////////////////////////////////////////////////////////////////
// Multiply each filter coefficient by 1/sum of the original coefficients.
//
void MipmapFilter::NormalizeMultiply()
{
	float fSum = 0.f;
	for (UINT iSample = 0; iSample < m_nSample; iSample++)
		fSum += m_rSample[iSample].m_fValue;
	float fScale = 1.f/fSum;
	for ( iSample = 0; iSample < m_nSample; iSample++)
		m_rSample[iSample].m_fValue *= fScale;
}

//////////////////////////////////////////////////////////////////////
// Standard sin(pi*x)/(pi*x) function that is the inverse fourier
// transform of a box filter in the frequency domain.  The problem with
// the sinc is that it has infinite extent. The lanczos and hamming filters
// below take a finite window and smoothly "roll off" at the edges.
//
float MipmapFilter::sinc(float x)
{
	if (x == 0.f)
		return 1.f;
	else
		return sinf(D3DX_PI * x) / (D3DX_PI * x);
}

//////////////////////////////////////////////////////////////////////
// Triangle filter is not a too bad approximation to a windowed sinc,
// but doesn't have a negative lobe to make the result sharp.  The
// lanczos, hamming, and mitchell filters are better.
//
float MipmapFilter::triangle(float x, float fHalfWidth)
{
	float r = x / fHalfWidth;
	if (r < -1.f || r > 1.f)
		return 0.0;
	else if (r < 0.0) 
		return (1 + r) / fHalfWidth;
	else 
		return (1 - r) / fHalfWidth;
}

//////////////////////////////////////////////////////////////////////
// Sinc-windowed sinc
//
float MipmapFilter::lanczos(float x, float fHalfWidth)
{
	if (x < -fHalfWidth || x > fHalfWidth)
		return 0.f;
	else
		return sinc(x/fHalfWidth) * sinc(x);
}

//////////////////////////////////////////////////////////////////////
// Hamming-windowed sinc
//
float MipmapFilter::hamming(float x, float fHalfWidth)
{
	if (x < -fHalfWidth || x > fHalfWidth)
		return 0.f;
	else
		return (0.46f * cosf(D3DX_PI * x / fHalfWidth) + 0.54f) * sinc(x);
}

//////////////////////////////////////////////////////////////////////
// Cubic filter that has a shape similar to the lanczos and hamming filters,
// but has slightly smaller negative lobes.
//
float MipmapFilter::mitchell(float x, float fHalfWidth)
{
	const float B = 0.3f;
	const float C = 0.3f;
	float r = (x < 0.f) ? -x : x;
	r /= 0.5f * fHalfWidth;
	if (r <= 1.f)
		return (6 - 2*B + r*r*(-18 + 12*B + 6*C + r*(12 - 9*B - 6*C)))/6;
	else if (r <= 2.f)
		return (8*B + 24*C + r*(-12*B - 48*C + r*(6*B + 30*C + r*(-B - 6*C))))/6;
	else 
		return 0.f;
}

//////////////////////////////////////////////////////////////////////
// CopyRects even if the formats are swizzled.
// 
HRESULT CopyRects(D3DSurface *pSurfaceSrc, CONST RECT *pSrcRectsArray, UINT cRects, D3DSurface *pSurfaceDst, CONST POINT *pDstPointsArray)
{
	HRESULT hr;
	D3DSURFACE_DESC descSrc;
	pSurfaceSrc->GetDesc(&descSrc);
	BOOL bSwizzledSrc = XGIsSwizzledFormat(descSrc.Format);
	D3DSURFACE_DESC descDst;
	pSurfaceDst->GetDesc(&descDst);
	BOOL bSwizzledDst = XGIsSwizzledFormat(descDst.Format);
	if (! bSwizzledSrc && !bSwizzledDst ) // if formats are both unswizzled, use regular CopyRects
		return g_pd3dDevice->CopyRects(pSurfaceSrc, pSrcRectsArray, cRects, pSurfaceDst, pDstPointsArray);
	if (MapSwizzledToLinearFormat(descSrc.Format) != MapSwizzledToLinearFormat(descDst.Format))
		return D3DERR_WRONGTEXTUREFORMAT;

	// Otherwise, copy pixel by pixel
	DWORD cbPixel = XGBytesPerPixelFromFormat(descSrc.Format);
	D3DLOCKED_RECT lockedRectSrc;
	hr = pSurfaceSrc->LockRect(&lockedRectSrc, NULL, 0);
	if (FAILED(hr))
		return hr;
	D3DLOCKED_RECT lockedRectDst;
	hr = pSurfaceDst->LockRect(&lockedRectDst, NULL, 0);
	if (FAILED(hr))
	{
		pSurfaceSrc->UnlockRect();
		return hr;
	}
	for (UINT iRect = 0; iRect < cRects; iRect++)
	{
		RECT rectSrc;
		if (pSrcRectsArray)
			rectSrc = pSrcRectsArray[iRect];
		else
		{
			rectSrc.left = 0;
			rectSrc.right = descSrc.Width;
			rectSrc.top = 0;
			rectSrc.bottom = descSrc.Height;
		}
		POINT pointDst;
		if (pDstPointsArray)
			pointDst = pDstPointsArray[iRect];
		else
			pointDst.x = pointDst.y = 0;
		if (bSwizzledSrc && bSwizzledDst)
		{
			Swizzler swizSrc(descSrc.Width, descSrc.Height, 0);
			Swizzler swizDst(descDst.Width, descDst.Height, 0);
			swizSrc.SetV(swizSrc.SwizzleV(rectSrc.top));
			swizDst.SetV(swizDst.SwizzleV(pointDst.y));
			for (long v = rectSrc.top; v < rectSrc.bottom; v++)
			{
				swizSrc.SetU(swizSrc.SwizzleU(rectSrc.left));
				swizDst.SetU(swizDst.SwizzleU(pointDst.x));
				for (long u = rectSrc.left; u < rectSrc.right; u++)
				{
					BYTE *pSrc = (BYTE *)lockedRectSrc.pBits + cbPixel * swizSrc.Get2D();
					BYTE *pDst = (BYTE *)lockedRectDst.pBits + cbPixel * swizDst.Get2D();
					memcpy(pDst, pSrc, cbPixel);
					swizSrc.IncU();
					swizDst.IncU();
				}
				swizSrc.IncV();
				swizDst.IncV();
			}
		}
		else if (bSwizzledSrc) // && !bSwizzledDst
		{
			Swizzler swizSrc(descSrc.Width, descSrc.Height, 0);
			swizSrc.SetV(swizSrc.SwizzleV(rectSrc.top));
			for (long v = rectSrc.top; v < rectSrc.bottom; v++)
			{
				long vDst = pointDst.y + v - rectSrc.top;
				swizSrc.SetU(swizSrc.SwizzleU(rectSrc.left));
				for (long u = rectSrc.left; u < rectSrc.right; u++)
				{
					long uDst = pointDst.x + u - rectSrc.left;
					BYTE *pSrc = (BYTE *)lockedRectSrc.pBits + cbPixel * swizSrc.Get2D();
					BYTE *pDst = (BYTE *)lockedRectDst.pBits + vDst * lockedRectDst.Pitch + uDst * cbPixel;
					memcpy(pDst, pSrc, cbPixel);
					swizSrc.IncU();
				}
				swizSrc.IncV();
			}
		}
		else // !bSwizzledSrc && bSwizzledDst
		{
			Swizzler swizDst(descDst.Width, descDst.Height, 0);
			swizDst.SetV(swizDst.SwizzleV(pointDst.y));
			for (long v = rectSrc.top; v < rectSrc.bottom; v++)
			{
				swizDst.SetU(swizDst.SwizzleU(pointDst.x));
				for (long u = rectSrc.left; u < rectSrc.right; u++)
				{
					BYTE *pSrc = (BYTE *)lockedRectSrc.pBits + v * lockedRectSrc.Pitch + u * cbPixel;
					BYTE *pDst = (BYTE *)lockedRectDst.pBits + cbPixel * swizDst.Get2D();
					memcpy(pDst, pSrc, cbPixel);
					swizDst.IncU();
				}
				swizDst.IncV();
			}
		}
	}
	pSurfaceSrc->UnlockRect();
	pSurfaceDst->UnlockRect();
	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// Helper function for allocating scratch textures, if needed.
//
static HRESULT AllocScratchYX(MipmapFilter *pFilter,
							  D3DSURFACE_DESC &descSrc,
							  LPDIRECT3DTEXTURE8 &pTextureScratchY,
							  LPDIRECT3DTEXTURE8 &pTextureScratchX)
{
	HRESULT hr;
	if (pTextureScratchY == NULL)
	{
		DWORD width = descSrc.Width;
		DWORD height = descSrc.Height / pFilter->m_nSuperSample;	// result will be decimated in Y
		if (height < 1) height = 1;
		if (width * XGBytesPerPixelFromFormat(descSrc.Format) < 64  // Xbox render target must have at least the minimum pitch
			|| width * height < 64)
		{
			width = 64;	// 16 is smallest reasonable render target
			if (height < width)	// if source height is larger use it, otherwise use reasonable default
				height = width;
		}
		hr = g_pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_RENDERTARGET, descSrc.Format, D3DPOOL_DEFAULT, &pTextureScratchY);
		if (FAILED(hr))
			return hr;
	}
	else
	{
		D3DSURFACE_DESC descScratchY;
		pTextureScratchY->GetLevelDesc(0, &descScratchY);
		if (descScratchY.Width < descSrc.Width										// Y scratch must match _source_ width
			|| descScratchY.Height < descSrc.Height / pFilter->m_nSuperSample		// ... and destination height
			|| descScratchY.Width * XGBytesPerPixelFromFormat(descScratchY.Format) < 64  // Xbox render target must have at least the minimum pitch
			|| descScratchY.Width * descScratchY.Height < 64
			|| MapSwizzledToLinearFormat(descSrc.Format) != MapSwizzledToLinearFormat(descScratchY.Format))	// formats must be compatible
			return E_INVALIDARG;
		pTextureScratchY->AddRef();	// to balance Release, below
	}
	if (pTextureScratchX == NULL)
	{
		DWORD width = descSrc.Width / pFilter->m_nSuperSample;		// result will be decimated in X
		if (width < 1) width = 1;
		DWORD height = descSrc.Height / pFilter->m_nSuperSample;	// result will be decimated in Y by previous filter pass
		if (height < 1) height = 1;
		if (width * XGBytesPerPixelFromFormat(descSrc.Format) < 64  // Xbox render target must have at least the minimum pitch
			|| width * height < 64)
		{
			width = 64;	// 16 is smallest reasonable render target
			if (height < width)	// if source height is larger use it, otherwise use reasonable default
				height = width;
		}
		hr = g_pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_RENDERTARGET, descSrc.Format, D3DPOOL_DEFAULT, &pTextureScratchX);
		if (FAILED(hr))
		{
			SAFE_RELEASE(pTextureScratchY);
			return hr;
		}
	}
	else
	{
		D3DSURFACE_DESC descScratchX;
		pTextureScratchX->GetLevelDesc(0, &descScratchX);
		if (descScratchX.Width < descSrc.Width / pFilter->m_nSuperSample			// X scratch must match destination width
			|| descScratchX.Height < descSrc.Height / pFilter->m_nSuperSample		// ... and destination height
			|| descScratchX.Width * XGBytesPerPixelFromFormat(descScratchX.Format) < 64  // Xbox render target must have at least the minimum pitch
			|| descScratchX.Width * descScratchX.Height < 64
			|| MapSwizzledToLinearFormat(descSrc.Format) != MapSwizzledToLinearFormat(descScratchX.Format))	// formats must be compatible
		{
			SAFE_RELEASE(pTextureScratchY);
			return E_INVALIDARG;
		}
		pTextureScratchX->AddRef();	// to balance Release, below
	}
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Uses Decimate to compute mipmaps starting with iSourceLevel
//
HRESULT GenerateMipmaps(LPDIRECT3DTEXTURE8 pTexture,
						UINT iSourceLevel,
						D3DTEXTUREADDRESS WrapU, 
						D3DTEXTUREADDRESS WrapV,
						LPDIRECT3DTEXTURE8 pTextureScratchY,
						LPDIRECT3DTEXTURE8 pTextureScratchX,
						MipmapFilter *pFilter)
{
	HRESULT hr;
	DWORD nMip = pTexture->GetLevelCount();
	if (iSourceLevel >= nMip - 1) return S_FALSE;	// nothing to filter
	if (!pFilter) pFilter = &s_MipmapFilterDefault;
	D3DSURFACE_DESC descSrc;
	hr = pTexture->GetLevelDesc(iSourceLevel, &descSrc);
	if (FAILED(hr))
		return hr;
	hr = AllocScratchYX(pFilter, descSrc, pTextureScratchY, pTextureScratchX);
	if (FAILED(hr))
		return hr;
	LPDIRECT3DSURFACE8 pSurfaceDst = NULL;
	for (UINT iMip = iSourceLevel + 1; iMip < nMip; iMip++)
	{
		hr = pTexture->GetSurfaceLevel(iMip, &pSurfaceDst); // get destination surface
		if (FAILED(hr))
			goto e_Exit;
		hr = Decimate(pSurfaceDst, pTexture, iMip - 1, WrapU, WrapV, pTextureScratchY, pTextureScratchX, pFilter);
		if (FAILED(hr))
			goto e_Exit;
		SAFE_RELEASE(pSurfaceDst);
	}
 e_Exit:
	SAFE_RELEASE(pSurfaceDst);
	SAFE_RELEASE(pTextureScratchX);
	SAFE_RELEASE(pTextureScratchY);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Use filter coefficients to resample from higher resolution
// pSurfaceSrc to lower resolution pSurfaceDst.
// The width of Src must be m_nSuperSample * width of Dst and
// the height of Src must be m_nSuperSample * height of Dst.
// The Y scratch texture must have width >= Src and height >= Src / 2.
// The X scratch texture must have width >= Src / 2 and height >= Src / 2.
HRESULT Decimate(LPDIRECT3DSURFACE8 pSurfaceDst,
				 LPDIRECT3DTEXTURE8 pTextureSrc,
				 UINT iSourceLevel,	// index of source miplevel in pTextureSrc
				 D3DTEXTUREADDRESS WrapU, 
				 D3DTEXTUREADDRESS WrapV,
				 LPDIRECT3DTEXTURE8 pTextureScratchY,
				 LPDIRECT3DTEXTURE8 pTextureScratchX,
				 MipmapFilter *pFilter)
{
	HRESULT hr;
	if (!pFilter) pFilter = &s_MipmapFilterDefault;

	// Get sizes of intermediate and final render targets
	D3DSURFACE_DESC descSrc;
	pTextureSrc->GetLevelDesc(iSourceLevel, &descSrc);
	D3DSURFACE_DESC descDst;
	pSurfaceDst->GetDesc(&descDst);
	if ((descDst.Width != 1 && descDst.Width > descSrc.Width / pFilter->m_nSuperSample)
		|| (descDst.Height != 1 && descDst.Height > descSrc.Height / pFilter->m_nSuperSample))
		return E_INVALIDARG;	// texture sizes don't match
	hr = AllocScratchYX(pFilter, descSrc, pTextureScratchY, pTextureScratchX);
	if (FAILED(hr))
		return hr;
	D3DSURFACE_DESC descScratchY, descScratchX;
	pTextureScratchY->GetLevelDesc(0, &descScratchY);
	pTextureScratchX->GetLevelDesc(0, &descScratchX);
	DWORD dwStateBlock = -1;
	hr = g_pd3dDevice->CreateStateBlock(D3DSBT_ALL, &dwStateBlock);
	if (FAILED(hr))
		return hr;
	
	// save current back buffer, z buffer, and pixel shader
	struct {
		IDirect3DSurface8 *pBackBuffer, *pZBuffer;
	} save;
	g_pd3dDevice->GetRenderTarget(&save.pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&save.pZBuffer);

	// set render state for filtering
	g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_TEX4);	// for screen-space texture-mapped quadrilateral
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);

	// use pixel shaders to add contributions from four samples at a time
	DWORD dwPS = 0;
#include "mipmap.inl"
	g_pd3dDevice->CreatePixelShader(&psd, &dwPS);
	g_pd3dDevice->SetPixelShader(dwPS);

	// set texture stage state
	UINT xx; // texture stage index
	for (xx = 0; xx < 4; xx++)
	{
		g_pd3dDevice->SetTexture(xx, pTextureSrc);	// use our source texture for all four stages
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);	// pass texture coords without transformation
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXCOORDINDEX, xx); // each texture has different tex coords
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSU, WrapU);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSV, WrapV);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAXMIPLEVEL, iSourceLevel);	// set most-detailed level to the desired source texture
		float fBias = -1000.f; 														// bias mipmap toward the most detailed level
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPMAPLODBIAS, *((LPDWORD) (&fBias)));
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MINFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAGFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORSIGN, 0);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE);
	}

	//
	// Pass 1: Filter in Y from Src to ScratchY
	//
	{
		LPDIRECT3DSURFACE8 pSurfaceScratchY = NULL;
		pTextureScratchY->GetSurfaceLevel(0, &pSurfaceScratchY);
		hr = g_pd3dDevice->SetRenderTarget(pSurfaceScratchY, NULL); // no depth buffering
		pSurfaceScratchY->Release();
		if (FAILED(hr))
			goto e_Exit;
		DWORD width = descSrc.Width;
		DWORD height = descSrc.Height / pFilter->m_nSuperSample;
		if (height < 1) height = 1;
		struct quad {
			float x, y, z, w1;
			struct uv {
				float u, v;
			} tex[4];	// each texture has different offset
		} aQuad[4] =
		  { //   X             Y              Z   1/W     u0  v0      u1  v1      u2  v2      u3  v3
			  {-0.5f,        -0.5f,         1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f},
			  {width - 0.5f, -0.5f,         1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f},
			  {-0.5f,        height - 0.5f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f},
			  {width - 0.5f, height - 0.5f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f}
		  };
		g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		g_pd3dDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
		g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
		g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);	// on first rendering, copy new value over current render target contents
		g_pd3dDevice->BeginScene();
		xx = 0;	// current texture stage
		float rfZero[4] = {0.f, 0.f, 0.f, 0.f};
		float fOffsetScale = (float)pFilter->m_nSuperSample / (float)descSrc.Height;	// source texture coords
		for (UINT iSample = 0; iSample < pFilter->m_nSample; iSample++)
		{
			// set filter coefficients
			float fValue = pFilter->m_rSample[iSample].m_fValue;
			if (fValue > 0.f)
			{
				float rf[4] = {fValue, fValue, fValue, fValue};
				g_pd3dDevice->SetPixelShaderConstant(xx, rf, 1);			// positive coeff
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rfZero, 1);	// negative coeff set to zero
			}
			else
			{
				float rf[4] = {-fValue, -fValue, -fValue, -fValue};
				g_pd3dDevice->SetPixelShaderConstant(xx, rfZero, 1);		// positive coeff set to zero
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rf, 1);		// negative coeff
			}
			// Align supersamples with center of destination pixels
			float fOffset = pFilter->m_rSample[iSample].m_fOffset * fOffsetScale;
			aQuad[0].tex[xx].u = 0.f;
			aQuad[0].tex[xx].v = fOffset;
			aQuad[1].tex[xx].u = 1.f;
			aQuad[1].tex[xx].v = fOffset;
			aQuad[2].tex[xx].u = 0.f;
			aQuad[2].tex[xx].v = 1.f + fOffset;
			aQuad[3].tex[xx].u = 1.f;
			aQuad[3].tex[xx].v = 1.f + fOffset;
			if (!XGIsSwizzledFormat(descSrc.Format))
			{
				for (int i = 0; i < 4; i++)
				{
					aQuad[i].tex[xx].u *= descSrc.Width;
					aQuad[i].tex[xx].v *= descSrc.Height;
				}
			}
			xx++;
			if (xx == 4)	// max texture stages
			{
				// draw the quad to filter the coefficients so far
				g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
				g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE); // on subsequent renderings, add to what's in the render target
				xx = 0;
			}
		}
		if (xx != 0) // add in results of final filter coefficients
		{
			// zero out rest of texture stage coefficients
			for (xx; xx < 4; xx++)
			{
				g_pd3dDevice->SetPixelShaderConstant(xx, rfZero, 1);		// positive coeff set to zero
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rfZero, 1);	// negative coeff set to zero
			}
			g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
		}
		g_pd3dDevice->EndScene();
	}

	//
	// Pass 2: Filter in X from ScratchY to ScratchX
	//
	{
		DWORD width = descSrc.Width / pFilter->m_nSuperSample;
		if (width < 1) width = 1;
		DWORD height = descSrc.Height / pFilter->m_nSuperSample;
		if (height < 1) height = 1;
		for (xx = 0; xx < 4; xx++)
			g_pd3dDevice->SetTexture(xx, pTextureScratchY);	// use the Y scratch texture as source for all four stages
		// Adjust scratch texture coords to include just the used region
		D3DXVECTOR2 vOrigin(0.f, 0.f);
		D3DXVECTOR2 vSize((float)descSrc.Width/(float)descScratchY.Width, (float)height/(float)descScratchY.Height);
#if 0
		if (descDst.Width * XGBytesPerPixelFromFormat(descDst.Format) >= 64  // Xbox render target must have at least the minimum pitch
			&& descDst.Width * descDst.Height >= 64)
		{
			// If destination surface is large enough, use it as a render target.
			hr = g_pd3dDevice->SetRenderTarget(pSurfaceDst, NULL); // no depth buffering
			if (FAILED(hr))
				goto e_Exit;
		}
		else
#endif
		{
			// Set scratchX as render target
			LPDIRECT3DSURFACE8 pSurfaceScratchX = NULL;
			pTextureScratchX->GetSurfaceLevel(0, &pSurfaceScratchX);
			hr = g_pd3dDevice->SetRenderTarget(pSurfaceScratchX, NULL); // no depth buffering
			pSurfaceScratchX->Release();
			if (FAILED(hr))
				goto e_Exit;
		}
		struct quad {
			float x, y, z, w1;
			struct uv {
				float u, v;
			} tex[4];	// each texture has different offset
		} aQuad[4] =
		  { //   X             Y              Z   1/W     u0  v0      u1  v1      u2  v2      u3  v3
			  {-0.5f,        -0.5f,         1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f},
			  {width - 0.5f, -0.5f,         1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f},
			  {-0.5f,        height - 0.5f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f},
			  {width - 0.5f, height - 0.5f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f}
		  };
		g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		g_pd3dDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
		g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
		g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);	// on first rendering, copy new value over current render target contents
		xx = 0;	// current texture stage
		float rfZero[4] = {0.f, 0.f, 0.f, 0.f};
		// TODO: review offset scale when width gets close to 1
		float fOffsetScale = (float)pFilter->m_nSuperSample / (float)descScratchY.Width;	// source texture coords
		g_pd3dDevice->BeginScene();	
		for (UINT iSample = 0; iSample < pFilter->m_nSample; iSample++)
		{
			// set filter coefficients
			float fValue = pFilter->m_rSample[iSample].m_fValue;
			if (fValue > 0.f)
			{
				float rf[4] = {fValue, fValue, fValue, fValue};
				g_pd3dDevice->SetPixelShaderConstant(xx, rf, 1);			// positive coeff
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rfZero, 1);	// negative coeff set to zero
			}
			else
			{
				float rf[4] = {-fValue, -fValue, -fValue, -fValue};
				g_pd3dDevice->SetPixelShaderConstant(xx, rfZero, 1);		// positive coeff set to zero
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rf, 1);		// negative coeff
			}
			// Align supersamples with center of destination pixels
			float fOffset = pFilter->m_rSample[iSample].m_fOffset * fOffsetScale;
			aQuad[0].tex[xx].u = vOrigin.x + fOffset;
			aQuad[0].tex[xx].v = vOrigin.y;
			aQuad[1].tex[xx].u = vOrigin.x + vSize.x + fOffset;
			aQuad[1].tex[xx].v = vOrigin.y;
			aQuad[2].tex[xx].u = vOrigin.x + fOffset;
			aQuad[2].tex[xx].v = vOrigin.y + vSize.y;
			aQuad[3].tex[xx].u = vOrigin.x + vSize.x + fOffset;
			aQuad[3].tex[xx].v = vOrigin.y + vSize.y;
			if (!XGIsSwizzledFormat(descScratchY.Format))
			{
				for (int i = 0; i < 4; i++)
				{
					aQuad[i].tex[xx].u *= descScratchY.Width;
					aQuad[i].tex[xx].v *= descScratchY.Height;
				}
			}
			xx++;
			if (xx == 4)	// max texture stages
			{
				// draw the quad to filter the coefficients so far
				g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
				g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE); // on subsequent renderings, add to what's in the render target
				xx = 0;
			}
		}
		if (xx != 0) // add in results of final filter coefficients
		{
			// zero out rest of texture stage coefficients
			for (xx; xx < 4; xx++)
			{
				g_pd3dDevice->SetPixelShaderConstant(xx, rfZero, 1);		// positive coeff set to zero
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rfZero, 1);	// negative coeff set to zero
			}
			g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
		}
		g_pd3dDevice->EndScene();
	}

	// 
	// Copy result to output
	//
	{
		DWORD width = descDst.Width;
		DWORD height = descDst.Height;
		
		// Stop using the scratch texture
		g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
		for (xx = 0; xx < 4; xx++)
			g_pd3dDevice->SetTexture(xx, NULL);
		g_pd3dDevice->BlockUntilIdle();

		// Copy result from scratch texture to destination surface
		LPDIRECT3DSURFACE8 pSurfaceScratchX = NULL;
		pTextureScratchX->GetSurfaceLevel(0, &pSurfaceScratchX);
		RECT rect = { 0, 0, width, height };
		POINT point = { 0, 0 };
		hr = CopyRects(pSurfaceScratchX, &rect, 1, pSurfaceDst, &point);
		pSurfaceScratchX->Release();
		if (FAILED(hr))
			goto e_Exit;
	}

e_Exit:
	SAFE_RELEASE(pTextureScratchX);
	SAFE_RELEASE(pTextureScratchY);

	// clean up pixel shaders
	g_pd3dDevice->SetPixelShader(0);
	g_pd3dDevice->DeletePixelShader(dwPS);
	
	// restore render states
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);

	// clear texture stages
	for (xx=0; xx<4; xx++)
	{
		g_pd3dDevice->SetTexture(xx, NULL);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPMAPLODBIAS, 0);
	}

	// restore back buffer and z buffer
	g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
	SAFE_RELEASE(save.pBackBuffer);
	SAFE_RELEASE(save.pZBuffer);
	g_pd3dDevice->ApplyStateBlock(dwStateBlock);
	g_pd3dDevice->DeleteStateBlock(dwStateBlock);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Create a new texture and copy the current texture to the new
// texture, with a format conversion.
//
HRESULT CopyTexture(LPDIRECT3DTEXTURE8 *ppTextureDst, D3DFORMAT fmtNew, LPDIRECT3DTEXTURE8 pTextureSrc)
{
	HRESULT hr;
	if (!pTextureSrc)
		return S_FALSE;
	*ppTextureDst = NULL;
	UINT nLevel = pTextureSrc->GetLevelCount();
	BYTE *pUnswizzledSrc = NULL;
	BYTE *pUnswizzledDst = NULL;
	LPDIRECT3DTEXTURE8 pTextureDst = NULL;
	LPDIRECT3DSURFACE8 pSurfaceSrc = NULL;
	LPDIRECT3DSURFACE8 pSurfaceDst = NULL;
	D3DSURFACE_DESC desc0;
	pTextureSrc->GetLevelDesc(0, &desc0);
	hr = g_pd3dDevice->CreateTexture(desc0.Width, desc0.Height, nLevel, 0, fmtNew, 0, &pTextureDst);
	if (FAILED(hr))
		goto e_Exit;
	// XGCompressRect doesn't understand swizzled formats
	if (XGIsSwizzledFormat(desc0.Format))
	{
		pUnswizzledSrc = new BYTE [ desc0.Width * desc0.Height * XGBytesPerPixelFromFormat(desc0.Format)]; 
		if (pUnswizzledSrc == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto e_Exit;
		}
	}
	if (XGIsSwizzledFormat(fmtNew))
	{
		pUnswizzledDst = new BYTE [ desc0.Width * desc0.Height * XGBytesPerPixelFromFormat(fmtNew)];
		if (pUnswizzledDst == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto e_Exit;
		}
	}
	for (UINT iLevel = 0; iLevel < nLevel; iLevel++)
	{
		D3DSURFACE_DESC desc;
		pTextureSrc->GetLevelDesc(iLevel, &desc);
		assert(desc.Format == desc0.Format);
		assert(desc.Width <= desc0.Width);
		assert(desc.Height <= desc0.Height);
		hr = pTextureSrc->GetSurfaceLevel(iLevel, &pSurfaceSrc);
		if (FAILED(hr))
			goto e_Exit;
		hr = pTextureDst->GetSurfaceLevel(iLevel, &pSurfaceDst);
		if (FAILED(hr))
			goto e_Exit;
		D3DLOCKED_RECT lockedRectSrc;
		hr = pSurfaceSrc->LockRect(&lockedRectSrc, NULL, D3DLOCK_READONLY);
		if (FAILED(hr))
			goto e_Exit;
		D3DLOCKED_RECT lockedRectDst;
		hr = pSurfaceDst->LockRect(&lockedRectDst, NULL, 0);
		if (FAILED(hr))
		{
			pSurfaceSrc->UnlockRect();
			goto e_Exit;
		}
		VOID *pBufSrc;
		DWORD dwPitchSrc;
		D3DFORMAT fmtSrc;
		if (XGIsSwizzledFormat(desc.Format))
		{
			XGUnswizzleRect(lockedRectSrc.pBits, desc.Width, desc.Height, NULL, pUnswizzledSrc, 0, NULL, XGBytesPerPixelFromFormat(desc.Format));
			pBufSrc = pUnswizzledSrc;
			dwPitchSrc = 0;
			fmtSrc = MapSwizzledToLinearFormat(desc.Format);
		}
		else
		{
			pBufSrc = lockedRectSrc.pBits;
			dwPitchSrc = lockedRectSrc.Pitch;
			fmtSrc = desc.Format;
		}
		VOID *pBufDst;
		DWORD dwPitchDst;
		D3DFORMAT fmtDst;
		if (XGIsSwizzledFormat(fmtNew))
		{
			pBufDst = pUnswizzledDst;
			dwPitchDst = 0;
			fmtDst = MapSwizzledToLinearFormat(fmtNew);
		}
		else
		{
			pBufDst = lockedRectDst.pBits;
			dwPitchDst = lockedRectDst.Pitch;
			fmtDst = fmtNew;
		}
		hr = XGCompressRect(pBufDst, fmtDst, dwPitchDst, desc.Width, desc.Height, pBufSrc, fmtSrc, dwPitchSrc, 0.f, 0 );
		if (FAILED(hr))
		{
			pSurfaceSrc->UnlockRect();
			pSurfaceDst->UnlockRect();
			goto e_Exit;
		}
		if (XGIsSwizzledFormat(fmtNew))
			XGSwizzleRect(pBufDst /* compressed result from XGCompressRect */, dwPitchDst, NULL, lockedRectDst.pBits, desc.Width, desc.Height, NULL, XGBytesPerPixelFromFormat(fmtNew));
		pSurfaceSrc->UnlockRect();
		pSurfaceDst->UnlockRect();
		SAFE_RELEASE(pSurfaceSrc);
		SAFE_RELEASE(pSurfaceDst);
	}
	*ppTextureDst = pTextureDst;	// already AddRef'd
	pTextureDst = NULL;	// to avoid a Release below
 e_Exit:
	SAFE_RELEASE(pTextureDst);
	SAFE_DELETE(pUnswizzledSrc);
	SAFE_DELETE(pUnswizzledDst);
	SAFE_RELEASE(pSurfaceSrc);
	SAFE_RELEASE(pSurfaceDst);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\Mipmap.inl ===
// Xbox Shader Assembler 1.00.3723.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    8,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x40404040;
psd.PSConstant1[0] = 0x00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0x40404040;
psd.PSConstant1[1] = 0x00000000;

//------------- Stage 2 -------------
psd.PSRGBInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[2] = 0x40404040;
psd.PSConstant1[2] = 0x00000000;

//------------- Stage 3 -------------
psd.PSRGBInputs[3]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[3]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[3]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[3]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[3] = 0x40404040;
psd.PSConstant1[3] = 0x00000000;

//------------- Stage 4 -------------
psd.PSRGBInputs[4]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[4]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[4]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[4]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[4] = 0x00000000;
psd.PSConstant1[4] = 0x00000000;

//------------- Stage 5 -------------
psd.PSRGBInputs[5]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[5]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[5]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[5]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[5] = 0x00000000;
psd.PSConstant1[5] = 0x00000000;

//------------- Stage 6 -------------
psd.PSRGBInputs[6]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[6]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[6]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[6]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[6] = 0x00000000;
psd.PSConstant1[6] = 0x00000000;

//------------- Stage 7 -------------
psd.PSRGBInputs[7]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[7]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[7]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[7]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[7] = 0x00000000;
psd.PSConstant1[7] = 0x00000000;

psd.PSC0Mapping = 0x76543210;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_TerrainTexture_OFFSET 0UL
#define resource_undergrass_OFFSET 20UL
#define resource_leaf2_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\SliceObject.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: SliceObject.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
// 	CSliceObject represents a geometric object as textured slices that
// 	move relative to one another for parallax.  This is a good level-
// 	of-detail representation for complex objects such as trees.
//-----------------------------------------------------------------------------
#include <assert.h>
#include <stdlib.h>
#include "SliceObject.h"
#include <XBUtil.h>
#include <XPath.h>

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//////////////////////////////////////////////////////////////////////
// Slice() creates the slice textures based on the SliceInfo values,
// and then uses the SliceTexture::GenerateSlices() routine with a
// callback to draw the geometry into each slice texture.
//
HRESULT CSliceObject::Slice(UINT nDirection, SliceInfo *rSliceInfo)	// slice in each of the directions
{
	HRESULT hr;
	if (nDirection != m_nDirection
		|| m_rSliceTexture == NULL)
	{
		SAFE_DELETE_ARRAY(m_rSliceInfo);
		SAFE_DELETE_ARRAY(m_rSliceTexture);
		SAFE_DELETE_ARRAY(m_rfFade);
		m_nDirection = nDirection;
		if (m_nDirection == 0)
			return S_FALSE;	// nothing to do
		m_rSliceInfo = new SliceInfo [ m_nDirection ];
		if (m_rSliceInfo == NULL)
			return E_OUTOFMEMORY;
		m_rSliceTexture = new CSliceTexture [ m_nDirection ];
		if (m_rSliceTexture == NULL)
			return E_OUTOFMEMORY;
		m_rfFade = new float [ m_nDirection ];
		if (m_rfFade == NULL)
			return E_OUTOFMEMORY;
	}
	for (m_iDirection = 0; m_iDirection < m_nDirection; m_iDirection++)
	{
		m_rSliceInfo[m_iDirection] = rSliceInfo[m_iDirection];
		DWORD nSlice = rSliceInfo[m_iDirection].nSlice;
		DWORD Width = rSliceInfo[m_iDirection].Width;
		DWORD Height = rSliceInfo[m_iDirection].Height;
		D3DTEXTUREADDRESS WrapU = rSliceInfo[m_iDirection].WrapU;
		D3DTEXTUREADDRESS WrapV = rSliceInfo[m_iDirection].WrapV;
		D3DFORMAT Format =  rSliceInfo[m_iDirection].Format;
		
		OUTPUT_DEBUG_STRING( " Slice..." );
		hr = m_rSliceTexture[m_iDirection].GenerateSlices(Width, Height, nSlice, this, WrapU, WrapV);
		if (FAILED(hr))
			return hr;
		OUTPUT_DEBUG_STRING( " LOD..." );
		hr = m_rSliceTexture[m_iDirection].ComputeLevelOfDetailTextures();
		if (FAILED(hr))
			return hr;
		extern bool g_bCompressTextures;
		if (g_bCompressTextures
			&& Format != D3DFMT_A8R8G8B8)	// default format of slice textures
		{
			// TODO: migrate texture format setting down into the GenerateSlices routine
			// so that the overhead of allocating all the uncompressed textures would
			// not be so large.
			OUTPUT_DEBUG_STRING( " Compress..." );
			hr = m_rSliceTexture[m_iDirection].SetTextureFormat(Format);
			if (FAILED(hr))
				return hr;
		}
		m_rfFade[m_iDirection] = 1.f;	// default fade value
		hr = m_rSliceTexture[m_iDirection].SetLevelOfDetail(0.f);
		if (FAILED(hr))
			return hr;
		OUTPUT_DEBUG_STRING( " done.\n" );
	}
	return S_OK;
}

HRESULT CSliceObject::Cleanup()
{
	SAFE_DELETE_ARRAY(m_rSliceInfo);
	SAFE_DELETE_ARRAY(m_rSliceTexture);
	SAFE_DELETE_ARRAY(m_rfFade);
	m_iDirection = m_nDirection = 0;
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Set up state for rendering object multiple times into a slice
// texture.  If bWorldCoords is false, then the world matrix is
// set to map the extents to a -1,1 cube.
//
HRESULT CSliceObject::Begin(bool bWorldCoords)
{
	if (!bWorldCoords)
	{
		// set world transformation to scale model to unit cube [-1,1] in all dimensions
		D3DXVECTOR3 va = m_vMin, vb = m_vMax;
		D3DXVECTOR3 vwidth(vb-va), vcenter(0.5f*(vb+va)); // width and center of geometry
		D3DXMATRIX matWorld, matTranslate, matScale;
		D3DXMatrixTranslation(&matTranslate, -vcenter.x, -vcenter.y, -vcenter.z);
		D3DXMatrixScaling(&matScale, 2.f/vwidth.x, 2.f/vwidth.y, 2.f/vwidth.z);
		matWorld = matTranslate * matScale;
		
		// rotate to align Y-axis with slice direction
		D3DXVECTOR3 XAxis = m_rSliceInfo[m_iDirection].vXAxis;
		D3DXVECTOR3 YAxis = m_rSliceInfo[m_iDirection].vDirection;
		D3DXVECTOR3 ZAxis;
		D3DXVec3Cross(&ZAxis, &XAxis, &YAxis);
		D3DMATRIX matAxis = {
			XAxis.x, XAxis.y, XAxis.z, 0.f,
			YAxis.x, YAxis.y, YAxis.z, 0.f,
			ZAxis.x, ZAxis.y, ZAxis.z, 0.f,
			0.f,     0.f,     0.f,     1.f
		};
		matWorld *= matAxis;
		g_pd3dDevice->MultiplyTransform( D3DTS_WORLD, &matWorld);
	}
	return S_OK;
}

HRESULT CSliceObject::End()
{
	// does nothing
	return S_OK;
}

// set level-of-detail for slice textures
HRESULT CSliceObject::SetLevelOfDetail(const float *rfLevelOfDetail)
{
	for (UINT iDirection = 0; iDirection < m_nDirection; iDirection++)
		m_rSliceTexture[iDirection].SetLevelOfDetail(rfLevelOfDetail[iDirection]);
	return S_OK;
}

// Get matrix that maps from [0,1] cube to m_vMin, m_vMax.
// Using Q = P . Matrix, (0,0,0,1) maps to m_vMin. (1,1,1,1) maps to m_vMax
HRESULT CSliceObject::GetCubeMapping(D3DXMATRIX *pMatrix)
{
	D3DXMATRIX matScale, matTranslate;
	D3DXVECTOR3 vWidth(m_vMax - m_vMin);
	D3DXMatrixScaling(&matScale, vWidth.x, vWidth.y, vWidth.z);
	D3DXMatrixTranslation(&matTranslate, m_vMin.x, m_vMin.y, m_vMin.z);
	*pMatrix = matScale * matTranslate;
	return S_OK;
}

extern bool g_bDebugSlice;
extern bool g_bDebugSliceOpaque;

//////////////////////////////////////////////////////////////////////
// Setup render state for drawing cube of slices
//
HRESULT CSliceObject::BeginDrawCubeSlices()
{
	g_pd3dDevice->SetVertexShader(D3DFVF_XYZ | D3DFVF_TEX1);
	g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE);
	g_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	static DWORD dwAlphaRef = 0;
	g_pd3dDevice->SetRenderState( D3DRS_ALPHAREF, dwAlphaRef );
	static BOOL bAlphaBlend = TRUE;
	g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, bAlphaBlend );
	g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
	g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
	g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
	g_pd3dDevice->LightEnable(0, FALSE);
	DWORD xx = 0;
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_MODULATE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG2, D3DTA_TFACTOR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG2, D3DTA_TFACTOR );
	if (g_bDebugSlice && g_bDebugSliceOpaque)
	{
		g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
		g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TFACTOR );
		g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
		g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
	}
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Set fade values for each of the slice textures based on the local eye direction
//
HRESULT CSliceObject::SetCubeFade(const D3DXVECTOR3 &vFrom, DWORD dwFlags)
{
	for (UINT iDirection = 0; iDirection < m_nDirection; iDirection++)
		m_rfFade[iDirection] = 0.f;
	for (UINT iCorner = 0; iCorner < 1 /*5*/; iCorner++)
	{
		D3DXVECTOR3 vCenter;
		if (iCorner == 0) 
			vCenter = 0.5f * (m_vMin + m_vMax);
		/*
		else if (iCorner == 1)
			vCenter = 0.5f * (
			*/
		D3DXVECTOR3 vEye = vFrom - vCenter;
		D3DXVec3Normalize(&vEye, &vEye);
		for (iDirection = 0; iDirection < m_nDirection; iDirection++)
		{
			float fFade = fabsf(D3DXVec3Dot(&vEye, (D3DXVECTOR3 *)&m_rSliceInfo[iDirection].vDirection));
			float fZero = m_rSliceInfo[iDirection].fZero;
			float fOne = m_rSliceInfo[iDirection].fOne;
			if (fFade > fOne) fFade = 1.f;
			else if (fFade < fZero) fFade = 0.f;
			else fFade = (fFade - fZero) / (fOne - fZero);
			if (m_rfFade[iDirection] < fFade)
				m_rfFade[iDirection] = fFade;
		}
	}
	if (dwFlags & SLICEOBJECT_MAXFADE)
	{
		// find maximum fade and set it to one and the others to 0
		UINT iDirectionMax = 0;
		for (iDirection = 1; iDirection < m_nDirection; iDirection++)
			if (m_rfFade[iDirection] > m_rfFade[iDirectionMax])
				iDirectionMax = iDirection;
		for (iDirection = 0; iDirection < m_nDirection; iDirection++)
			m_rfFade[iDirection] = (iDirection == iDirectionMax) ? 1.f : 0.f;
	}
	else if (dwFlags & SLICEOBJECT_UNITFADE)
	{
		// make fade values sum to one
		float fSum = 0.f;
		for (iDirection = 0; iDirection < m_nDirection; iDirection++)
			fSum += m_rfFade[iDirection];
		float fScale = 1.f / fSum;
		for (iDirection = 0; iDirection < m_nDirection; iDirection++)
			m_rfFade[iDirection] *= fScale;
	}
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Draw slices from front to back based on local eye
//
HRESULT CSliceObject::DrawCubeSlices(const D3DXVECTOR3 &vFrom)
{
	D3DXVECTOR3 vCenter = 0.5f * (m_vMin + m_vMax);
	D3DXVECTOR3 vEye = vFrom - vCenter;
	struct quad_vertex {
		D3DXVECTOR3 pos;
		D3DXVECTOR2 tex;
	} aVertex[4];
	const float fZeroBlend = 0.5f/255.f;	// blend values below this quantize to zero
	for (UINT iDirection = 0; iDirection < m_nDirection; iDirection++)
	{
		float fFade = m_rfFade[iDirection];
		if (fFade < fZeroBlend)	// quantization threshold
			continue; // skip to next direction 

		D3DXVECTOR3 vSweep(0.f, 0.f, 0.f);
		bool bReverse = false;
		switch (iDirection)
		{
		case 0: // sweep along x
			if (vEye.x < 0.f)
			{
				vSweep.x = m_vMin.x - m_vMax.x;
				aVertex[0].pos.x = aVertex[1].pos.x = aVertex[2].pos.x = aVertex[3].pos.x = m_vMax.x;
				bReverse = true;
			}
			else
			{
				vSweep.x = m_vMax.x - m_vMin.x;
				aVertex[0].pos.x = aVertex[1].pos.x = aVertex[2].pos.x = aVertex[3].pos.x = m_vMin.x;
			}
			
			aVertex[0].pos.y = m_vMin.y;    aVertex[0].pos.z = m_vMin.z;
			aVertex[1].pos.y = m_vMax.y;    aVertex[1].pos.z = m_vMin.z;
			aVertex[2].pos.y = m_vMin.y;    aVertex[2].pos.z = m_vMax.z;
			aVertex[3].pos.y = m_vMax.y;    aVertex[3].pos.z = m_vMax.z;
			aVertex[0].tex.x = 0.f;    aVertex[0].tex.y = 0.f;
			aVertex[1].tex.x = 1.f;    aVertex[1].tex.y = 0.f;
			aVertex[2].tex.x = 0.f;    aVertex[2].tex.y = 1.f;
			aVertex[3].tex.x = 1.f;    aVertex[3].tex.y = 1.f; 
			break;
		case 1: // sweep along y
			if (vEye.y < 0.f)
			{
				vSweep.y = m_vMin.y - m_vMax.y;
				aVertex[0].pos.y = aVertex[1].pos.y = aVertex[2].pos.y = aVertex[3].pos.y = m_vMax.y;
				bReverse = true;
			}
			else
			{
				vSweep.y = m_vMax.y - m_vMin.y;
				aVertex[0].pos.y = aVertex[1].pos.y = aVertex[2].pos.y = aVertex[3].pos.y = m_vMin.y;
			}
			aVertex[0].pos.x = m_vMin.x;	aVertex[0].pos.z = m_vMin.z;
			aVertex[1].pos.x = m_vMax.x;	aVertex[1].pos.z = m_vMin.z;
			aVertex[2].pos.x = m_vMin.x;	aVertex[2].pos.z = m_vMax.z;
			aVertex[3].pos.x = m_vMax.x;	aVertex[3].pos.z = m_vMax.z;
			aVertex[0].tex.x = 0.f;    aVertex[0].tex.y = 1.f;
			aVertex[1].tex.x = 1.f;    aVertex[1].tex.y = 1.f;
			aVertex[2].tex.x = 0.f;    aVertex[2].tex.y = 0.f;
			aVertex[3].tex.x = 1.f;    aVertex[3].tex.y = 0.f; 
			break;
		case 2: // sweep along z
			if (vEye.z < 0.f)
			{
				vSweep.z = m_vMin.z - m_vMax.z;
				aVertex[0].pos.z = aVertex[1].pos.z = aVertex[2].pos.z = aVertex[3].pos.z = m_vMax.z;
				bReverse = true;
			}
			else
			{
				vSweep.z = m_vMax.z - m_vMin.z;
				aVertex[0].pos.z = aVertex[1].pos.z = aVertex[2].pos.z = aVertex[3].pos.z = m_vMin.z;
			}
			aVertex[0].pos.x = m_vMin.x;	aVertex[0].pos.y = m_vMin.y;
			aVertex[1].pos.x = m_vMax.x;	aVertex[1].pos.y = m_vMin.y;
			aVertex[2].pos.x = m_vMin.x;	aVertex[2].pos.y = m_vMax.y;
			aVertex[3].pos.x = m_vMax.x;	aVertex[3].pos.y = m_vMax.y;
			aVertex[0].tex.x = 1.f;    aVertex[0].tex.y = 1.f;
			aVertex[1].tex.x = 0.f;    aVertex[1].tex.y = 1.f;
			aVertex[2].tex.x = 1.f;    aVertex[2].tex.y = 0.f;
			aVertex[3].tex.x = 0.f;    aVertex[3].tex.y = 0.f; 
			break;
		default:
			return E_NOTIMPL;
		}

		D3DXCOLOR colorFade(fFade, fFade, fFade, fFade);
		g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, colorFade );
		D3DTEXTUREADDRESS WrapU = m_rSliceInfo[iDirection].WrapU;
		D3DTEXTUREADDRESS WrapV = m_rSliceInfo[iDirection].WrapV;
		g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, WrapU );
		g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, WrapV );
		CSliceTexture *pSliceTexture = &m_rSliceTexture[iDirection];
		UINT dwNumSlicesLOD = pSliceTexture->m_dwNumSlicesLOD;
		vSweep /= (float)dwNumSlicesLOD;
		static float fHalf = 0.5f;
		for (UINT i = 0; i < 4; i++)	// move to first plane
			aVertex[i].pos += fHalf * vSweep;
		for (UINT iSlice = 0; iSlice < dwNumSlicesLOD; iSlice++)
		{
			int iSliceFlip;
			if (bReverse)
				iSliceFlip = dwNumSlicesLOD - 1 - iSlice;
			else
				iSliceFlip = iSlice;
			g_pd3dDevice->SetTexture( 0, pSliceTexture->m_rpTextureLOD[iSliceFlip] );
			if (g_bDebugSlice)
			{
				colorFade = D3DXCOLOR(fFade,
									  fFade *(float)iSlice/(float)dwNumSlicesLOD,
									  fFade * (m_nDirection == 1 ? 1.f : (float)iDirection/(float)(m_nDirection - 1)), 
									  fFade);
				static D3DCOLOR colorMask = 0xffffffff;
				D3DCOLOR color = (D3DCOLOR)colorFade & colorMask;
				g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, color );
				extern DWORD g_dwTotalSliceCount;
				g_dwTotalSliceCount++;
			}
			g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aVertex, sizeof(quad_vertex));	
			for (UINT i = 0; i < 4; i++)	// move to next plane
				aVertex[i].pos += vSweep;
		}
	}
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Cleanup after drawing cube slices
//
HRESULT CSliceObject::EndDrawCubeSlices()
{
	// does nothing
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Draw slices from front to back based on local eye
//
HRESULT CSliceObject::DrawSlices(const D3DXVECTOR3 &vFromFade, const D3DXVECTOR3 &vFromSliceOrder, DWORD dwFlags)
{
	BeginDrawCubeSlices();
	SetCubeFade(vFromFade, dwFlags);
	DrawCubeSlices(vFromSliceOrder);
	EndDrawCubeSlices();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\SwizzleFormat.h ===
//////////////////////////////////////////////////////////////////////
// Swizzled to linear and back format mapping.
//
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//////////////////////////////////////////////////////////////////////
inline D3DFORMAT MapLinearToSwizzledFormat(D3DFORMAT fmt)
{
	switch (fmt)
	{
    case D3DFMT_LIN_A1R5G5B5: 	return D3DFMT_A1R5G5B5;
    case D3DFMT_LIN_A4R4G4B4: 	return D3DFMT_A4R4G4B4;
    case D3DFMT_LIN_A8: 		return D3DFMT_A8;
    case D3DFMT_LIN_A8B8G8R8: 	return D3DFMT_A8B8G8R8;
    case D3DFMT_LIN_A8R8G8B8: 	return D3DFMT_A8R8G8B8;
    case D3DFMT_LIN_B8G8R8A8: 	return D3DFMT_B8G8R8A8;
    case D3DFMT_LIN_G8B8: 		return D3DFMT_G8B8;
    case D3DFMT_LIN_R4G4B4A4: 	return D3DFMT_R4G4B4A4;
    case D3DFMT_LIN_R5G5B5A1: 	return D3DFMT_R5G5B5A1;
    case D3DFMT_LIN_R5G6B5: 	return D3DFMT_R5G6B5;
    case D3DFMT_LIN_R6G5B5: 	return D3DFMT_R6G5B5;
    case D3DFMT_LIN_R8B8: 		return D3DFMT_R8B8;
    case D3DFMT_LIN_R8G8B8A8: 	return D3DFMT_R8G8B8A8;
    case D3DFMT_LIN_X1R5G5B5: 	return D3DFMT_X1R5G5B5;
    case D3DFMT_LIN_X8R8G8B8: 	return D3DFMT_X8R8G8B8;
    case D3DFMT_LIN_A8L8: 		return D3DFMT_A8L8;
    case D3DFMT_LIN_AL8: 		return D3DFMT_AL8;
    case D3DFMT_LIN_L16: 		return D3DFMT_L16;
    case D3DFMT_LIN_L8: 		return D3DFMT_L8;
    case D3DFMT_LIN_V16U16: 	return D3DFMT_V16U16;
    case D3DFMT_LIN_D24S8: 		return D3DFMT_D24S8;
    case D3DFMT_LIN_F24S8: 		return D3DFMT_F24S8;
    case D3DFMT_LIN_D16: 		return D3DFMT_D16;
    case D3DFMT_LIN_F16: 		return D3DFMT_F16;
	default:
		return fmt;
	}
}

inline D3DFORMAT MapSwizzledToLinearFormat(D3DFORMAT fmt)
{
	switch (fmt)
	{
    case D3DFMT_A1R5G5B5: 	return D3DFMT_LIN_A1R5G5B5;
    case D3DFMT_A4R4G4B4: 	return D3DFMT_LIN_A4R4G4B4;
    case D3DFMT_A8: 		return D3DFMT_LIN_A8;
    case D3DFMT_A8B8G8R8: 	return D3DFMT_LIN_A8B8G8R8;
    case D3DFMT_A8R8G8B8: 	return D3DFMT_LIN_A8R8G8B8;
    case D3DFMT_B8G8R8A8: 	return D3DFMT_LIN_B8G8R8A8;
    case D3DFMT_G8B8: 		return D3DFMT_LIN_G8B8;
    case D3DFMT_R4G4B4A4: 	return D3DFMT_LIN_R4G4B4A4;
    case D3DFMT_R5G5B5A1: 	return D3DFMT_LIN_R5G5B5A1;
    case D3DFMT_R5G6B5: 	return D3DFMT_LIN_R5G6B5;
    case D3DFMT_R6G5B5: 	return D3DFMT_LIN_R6G5B5;
    case D3DFMT_R8B8: 		return D3DFMT_LIN_R8B8;
    case D3DFMT_R8G8B8A8: 	return D3DFMT_LIN_R8G8B8A8;
    case D3DFMT_X1R5G5B5: 	return D3DFMT_LIN_X1R5G5B5;
    case D3DFMT_X8R8G8B8: 	return D3DFMT_LIN_X8R8G8B8;
    case D3DFMT_A8L8: 		return D3DFMT_LIN_A8L8;
    case D3DFMT_AL8: 		return D3DFMT_LIN_AL8;
    case D3DFMT_L16: 		return D3DFMT_LIN_L16;
    case D3DFMT_L8: 		return D3DFMT_LIN_L8;
    case D3DFMT_V16U16: 	return D3DFMT_LIN_V16U16;
    case D3DFMT_D24S8: 		return D3DFMT_LIN_D24S8;
    case D3DFMT_F24S8: 		return D3DFMT_LIN_F24S8;
    case D3DFMT_D16: 		return D3DFMT_LIN_D16;
    case D3DFMT_F16: 		return D3DFMT_LIN_F16;
	default:
		return fmt;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\SliceTexture.h ===
#pragma once
//-----------------------------------------------------------------------------
//  File: SliceTexture.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//
//   A set of textures generated by rendering with a tight set of
//   Znear and Zfar clipping planes that sweep across the full
//   geometric object.  Slice textures can be used for concentric
//   shell textures (good for phenomena like fur), or used by
//   SliceObject as a level-of-detail representation for complex
//   objects such as trees.
//-----------------------------------------------------------------------------
#ifdef _XBOX
#include <xtl.h>
#include <xgraphics.h>
#else
#include <d3d8.h>
#endif

#define SLICETEXTURE_MAXSLICE_LOG2 7
#define SLICETEXTURE_MAXSLICE (1 << SLICETEXTURE_MAXSLICE_LOG2)

struct CSliceTextureDrawCallback {
	virtual HRESULT Begin(bool bWorldCoords = false) = 0;	// prepare for drawing
	virtual HRESULT Draw(const D3DXVECTOR3 &vMin,			// draw parts of model that intersect with box
						 const D3DXVECTOR3 &vMax) = 0;
	virtual HRESULT End() = 0;								// cleanup
};

class CSliceTexture {
public:
	DWORD m_Width, m_Height, m_dwNumSlices;
	LPDIRECT3DTEXTURE8 m_rpTexture[SLICETEXTURE_MAXSLICE * 2 - 1];	// slices of volume texture
					// ... followed by level-of-detail textures  N/2, N/4, N/8, ... 1
	DWORD m_dwNumSlicesLOD; // number of slices in current level of detail
	float m_fLevelOfDetail;	// current LOD value
	DWORD m_iLOD;			// current integer LOD value
	float m_fLODFraction;	// fraction towards next coarser level-of-detail
	DWORD m_dwLODMax;		// maximum LOD index
	LPDIRECT3DTEXTURE8 *m_rpTextureLOD; // current level of detail pointer into m_rpSliceTexture array

	CSliceTexture();
	~CSliceTexture();
	
	// Create textures and render a series of slices using the draw callback routine.
	HRESULT GenerateSlices(
		DWORD width, 
		DWORD height, 
		DWORD dwNumSlices, 
		CSliceTextureDrawCallback *pDrawCB, 				
		D3DTEXTUREADDRESS WrapU = D3DTADDRESS_WRAP, 
		D3DTEXTUREADDRESS WrapV = D3DTADDRESS_WRAP);
	
	// fLevelOfDetail can range from 0 to log2(NumSlices)
	HRESULT SetLevelOfDetail(float fLevelOfDetail);
	HRESULT ComputeLevelOfDetailTextures();
	inline UINT LevelOfDetailCount(UINT iLOD)
	{
		return m_dwNumSlices >> iLOD;
	}
	inline UINT LevelOfDetailIndex(UINT iLOD)
	{
		UINT offset = 0;
		for (UINT i = 1; i <= iLOD; i++)
			offset += LevelOfDetailCount(i-1);
		return offset;
	}

	// Convert all slice textures to a new format
	HRESULT SetTextureFormat(D3DFORMAT fmtNew);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\SliceObject.h ===
#pragma once
//-----------------------------------------------------------------------------
//  File: SliceObject.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//
// 	CSliceObject represents a geometric object as textured slices that
// 	move relative to one another for parallax.  This is a good level-
// 	of-detail representation for complex objects such as trees.
//-----------------------------------------------------------------------------
#include "SliceTexture.h"

struct SliceInfo {
	UINT nSlice;				// number of slice textures
	UINT Width;					// width of each texture
	UINT Height;				// height of each texture
	D3DTEXTUREADDRESS WrapU;	// wrapping modes
	D3DTEXTUREADDRESS WrapV;
	D3DFORMAT Format;			// format of each texture
	D3DVECTOR vDirection;		// slice direction. y-axis is rotated to align to this.
	D3DVECTOR vXAxis;			// x-axis is rotated to align to this axis during slicing
	float fZero;				// when fabs(dot(vEye, vDirection)) < fZero, fade value is set to 0
	float fOne;					// when fabs(dot(vEye, vDirection)) >= fOne, fade value is set to 1
};

#define SLICEOBJECT_MAXDIRECTIONS 10

class CSliceObject : public CSliceTextureDrawCallback {
public:
	D3DXVECTOR3		m_vMin, m_vMax;				// bounding box
	UINT			m_nDirection;				// number of slice directions
	SliceInfo		*m_rSliceInfo;				// slice direction attributes
	CSliceTexture	*m_rSliceTexture;			// slice textures
	float			*m_rfFade;					// blend values for each direction
	UINT			m_iDirection; 				// current slicing direction
public:
	CSliceObject() { m_nDirection = 0; m_rSliceInfo = NULL; m_rSliceTexture = NULL; m_rfFade = NULL; }
	~CSliceObject()	{ Cleanup(); }

	HRESULT Slice(UINT nDirection, SliceInfo *rSliceInfo);	// slice in each of the directions
	HRESULT Cleanup();

	// CSliceTextureDrawCallback overrides
	virtual HRESULT Begin(bool bWorldCoords = false); 		// transform to unit cube and rotate to the current m_iDirection
	// Draw() is not overridden, and must be supplied by the subclass.
	virtual HRESULT End();
	
	// Get matrix that maps from [0,1] cube to m_vMin, m_vMax.
	// Using Q = P . Matrix, (0,0,0,1) maps to m_vMin. (1,1,1,1) maps to m_vMax
	HRESULT GetCubeMapping(D3DXMATRIX *pMatrix);	

	//-----------------------------------------------------------------------------
	// Draw cube of slices
	//
	HRESULT BeginDrawCubeSlices();	// setup render state
	HRESULT SetLevelOfDetail(const float *rfLevelOfDetail); // set level-of-detail for slice textures
	// set fade values for each of the slice textures based on the local eye
#define	SLICEOBJECT_MAXFADE    001	/* only one set of planes is drawn */
#define	SLICEOBJECT_UNITFADE   002	/* fade directions are normalized */
	// default, dwFlags == 0, means to fade based on angle ranges
	HRESULT SetCubeFade(const D3DXVECTOR3 &vFrom, DWORD dwFlags);
	HRESULT DrawCubeSlices(const D3DXVECTOR3 &vFrom);	// draw slices from front to back based on local eye
	HRESULT EndDrawCubeSlices();

	// draw slices from front to back based on local eye
	HRESULT DrawSlices(const D3DXVECTOR3 &vFromFade, const D3DXVECTOR3 &vFromSliceOrder, DWORD dwFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\SliceTexture.cpp ===
//-----------------------------------------------------------------------------
//  File: SliceTexture.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//-----------------------------------------------------------------------------
#include <assert.h>
#include <stdlib.h>
#include "SliceTexture.h"
#include "SwizzleFormat.h"
#include "XBUtil.h"
#include "XPath.h"
#include "mipmap.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//////////////////////////////////////////////////////////////////////
// To see the slicing of the geometry and creation of the slice
// textures, set the following define to 1 and recompile.
// The slicing frustum is drawn "from the side" so the current
// clipping range can be seen.   Also, the texture is displayed
// at the end, after filtering down from the supersamples.

#define DEBUG_SHOW_SLICING 0

//-----------------------------------------------------------------------------
// Name: Constructor
// Desc: 
//-----------------------------------------------------------------------------
CSliceTexture::CSliceTexture()
{
	ZeroMemory(this, sizeof(CSliceTexture));
}

//-----------------------------------------------------------------------------
// Name: Destructor
// Desc: 
//-----------------------------------------------------------------------------
CSliceTexture::~CSliceTexture()
{
	DWORD i;
	for(i=0; i<SLICETEXTURE_MAXSLICE*2-1; i++)
		SAFE_RELEASE(m_rpTexture[i]);
}

//-----------------------------------------------------------------------------
// Name: GenerateSlices
// Desc: Call draw callback with z range set to take a series of slices
// and capturing the result in the slice textures.
//-----------------------------------------------------------------------------
HRESULT CSliceTexture::GenerateSlices(DWORD width,
									  DWORD height, 
									  DWORD nslices, 
									  CSliceTextureDrawCallback *pDrawCB, 				
									  D3DTEXTUREADDRESS WrapU, 
									  D3DTEXTUREADDRESS WrapV)
{
	HRESULT hr;
	assert(nslices <= SLICETEXTURE_MAXSLICE);
	if (WrapU != D3DTADDRESS_CLAMP && WrapU != D3DTADDRESS_WRAP) return E_NOTIMPL;
	if (WrapV != D3DTADDRESS_CLAMP && WrapV != D3DTADDRESS_WRAP) return E_NOTIMPL;
		
	// Check the format of the textures
	bool bFormatOK = true;
	if (m_dwNumSlices > 0)
	{
		D3DSURFACE_DESC desc;
		m_rpTexture[0]->GetLevelDesc(0, &desc);
		if (desc.Format != D3DFMT_A8R8G8B8)		// this is the only render target format we support
			bFormatOK = false;
	}

	// make sure volume info is up to date
	if ( m_Width != width
		 || m_Height != height
		 || !bFormatOK )
	{
		m_dwNumSlices = 0;
		m_dwNumSlicesLOD = 0;
		for(UINT i=0; i<SLICETEXTURE_MAXSLICE*2-1; i++)
			SAFE_RELEASE(m_rpTexture[i]);
	}
	m_Width = width;
	m_Height = height;

	// create textures if necessary
	if (m_dwNumSlices != nslices)
	{
		UINT i;
		// count number of level-of-detail textures needed
		UINT nLOD = 0;
		for (i = 1; (1u << i) <= nslices; i++)
			nLOD += nslices >> i;
		m_dwLODMax = i - 1;

		// create new textures and level-of-detail textures
		static DWORD nLevel = 0;
		for(i=0; i<nslices+nLOD; i++)
			if(!m_rpTexture[i])
			{
				hr = g_pd3dDevice->CreateTexture(width, height, nLevel, 0, D3DFMT_A8R8G8B8, 0, &m_rpTexture[i]);
				if (FAILED(hr))
					return hr;
			}
			
		// release unused textures
		for(i=nslices+nLOD; i<SLICETEXTURE_MAXSLICE*2-1; i++)
			SAFE_RELEASE(m_rpTexture[i]);
	}
	m_dwNumSlices = nslices;

	// Render into volume slices
	struct { // save current back buffer, z buffer, and transforms
		IDirect3DSurface8 *pBackBuffer, *pZBuffer;
		D3DMATRIX matWorld, matView, matProjection;
	} save;
	g_pd3dDevice->GetRenderTarget(&save.pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&save.pZBuffer);
	g_pd3dDevice->GetTransform( D3DTS_WORLD, &save.matWorld);
	g_pd3dDevice->GetTransform( D3DTS_VIEW, &save.matView);
	g_pd3dDevice->GetTransform( D3DTS_PROJECTION, &save.matProjection);

	// Set up antialiasing filter and temporary render target
	UINT nSuper = 4;
	MipmapFilter filter(nSuper);
	LPDIRECT3DTEXTURE8 pTextureSuper = NULL;
	hr = g_pd3dDevice->CreateTexture(m_Width * nSuper, m_Height * nSuper, 1, D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &pTextureSuper);
	if (FAILED(hr))
		return hr;
	LPDIRECT3DSURFACE8 pZBufferSuper = NULL;
	LPDIRECT3DSURFACE8 pSurfaceSuper = NULL;
	// make a new depth buffer
	hr = g_pd3dDevice->CreateDepthStencilSurface(m_Width * nSuper, m_Height * nSuper, D3DFMT_LIN_D24S8, D3DMULTISAMPLE_NONE, &pZBufferSuper);
	if (FAILED(hr))
	{
		SAFE_RELEASE(pTextureSuper);
		return hr;
	}
	pTextureSuper->GetSurfaceLevel(0, &pSurfaceSuper);
	hr = g_pd3dDevice->SetRenderTarget(pSurfaceSuper, pZBufferSuper);
	if (FAILED(hr))
	{
		SAFE_RELEASE(pZBufferSuper);
		SAFE_RELEASE(pSurfaceSuper);
		SAFE_RELEASE(pTextureSuper);
		return hr;
	}

	// Create scratch textures for filtering down to the final texture
	LPDIRECT3DTEXTURE8 pTextureScratchY = NULL;
	LPDIRECT3DTEXTURE8 pTextureScratchX = NULL;
	hr = g_pd3dDevice->CreateTexture(m_Width * nSuper, m_Height, 1, D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &pTextureScratchY);
	if (FAILED(hr))
	{
		SAFE_RELEASE(pTextureSuper);
		return hr;
	}
	hr = g_pd3dDevice->CreateTexture(m_Width, m_Height, 1, D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &pTextureScratchX);
	if (FAILED(hr))
	{
		SAFE_RELEASE(pTextureScratchY);
		SAFE_RELEASE(pTextureSuper);
		return hr;
	}

	// set transformation to flip z and look down y axis, with bottom-most slice scaled and translated to map to [0,1]
	D3DMATRIX matView;
	matView.m[0][0] = 1.f;	matView.m[0][1] =  0.f;	matView.m[0][2] = 0.f;				matView.m[0][3] = 0.f;
	matView.m[1][0] = 0.f;	matView.m[1][1] =  0.f;	matView.m[1][2] = 0.5f * nslices;	matView.m[1][3] = 0.f;
	matView.m[2][0] = 0.f;	matView.m[2][1] =  1.f;	matView.m[2][2] = 0.f;				matView.m[2][3] = 0.f;
	matView.m[3][0] = 0.f;	matView.m[3][1] =  0.f;	matView.m[3][2] = 0.5f * nslices;	matView.m[3][3] = 1.f;
	D3DXMATRIX matIdentity;
	D3DXMatrixIdentity(&matIdentity);
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matIdentity);
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &matIdentity);
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &matIdentity);
	hr = pDrawCB->Begin(false);
	if (FAILED(hr))
		goto e_Exit;

	// draw each slice
	int i;
	for (i = 0; i < (int)nslices; i++)
	{
		g_pd3dDevice->SetRenderTarget(pSurfaceSuper, pZBufferSuper);
		g_pd3dDevice->BeginScene();
		g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, D3DCOLOR_RGBA(0,0,0,0), 1.0f, 0);
		matView.m[1][2] = 0.5f * nslices;
		matView.m[3][2] = 0.5f * nslices - (float)i;	// offset to next slice
		D3DXVECTOR3 vMin(-1.f, (float)i/(float)nslices, -1.f), vMax(1.f, (float)(i+1)/(float)nslices, 1.f);
		// We want the texture to wrap, so draw multiple times with offsets in the plane so that 
		// the boundaries will be filled in by the overlapping geometry.
		int iX0, iX1;
		if (WrapU == D3DTADDRESS_WRAP)
		{
			iX0 = -1; 
			iX1 = 1;
		}
		else
			iX0 = iX1 = 0;
		int iY0, iY1;
		if (WrapV == D3DTADDRESS_WRAP)
		{
			iY0 = -1; 
			iY1 = 1;
		}
		else
			iY0 = iY1 = 0;
#if DEBUG_SHOW_SLICING
		// Show the slicing in action by drawing the clip frustum.
		extern HRESULT DebugFrustumBegin();
		extern HRESULT DebugFrustumEnd();
		extern HRESULT DebugPresent();
#endif
		for (int iX = iX0; iX <= iX1; iX++)
		{
			for (int iY = iY0; iY <= iY1; iY++)
			{
				matView.m[3][0] = 2.f * iX;
				matView.m[3][1] = 2.f * iY;
				g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView);	// position the current slice
#if DEBUG_SHOW_SLICING
				{
					// Draw the geometry in the "from-the-side" view
					DebugFrustumBegin();
					pDrawCB->Draw(vMin, vMax);
					DebugFrustumEnd();
				}
#endif	
				pDrawCB->Draw(vMin, vMax);
			}
		}
#if DEBUG_SHOW_SLICING
		DebugPresent();
#endif
		g_pd3dDevice->EndScene();

		// Before we filter the texture, make sure we're done rendering
		g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
		g_pd3dDevice->BlockUntilIdle();

		// Filter down from high-resolution original buffer to texture
		LPDIRECT3DTEXTURE8 pTexture = m_rpTexture[i];
		LPDIRECT3DSURFACE8 pSurface = NULL;
		pTexture->GetSurfaceLevel(0, &pSurface);
		hr = Decimate(pSurface, pTextureSuper, 0, WrapU, WrapV, pTextureScratchY, pTextureScratchX, &filter);
		if (FAILED(hr))
			goto e_Exit;
#if DEBUG_SHOW_SLICING
		// Display the resulting slice texture
		extern HRESULT DebugTexture(LPDIRECT3DTEXTURE8 pTexture, UINT iLevel);
		DebugTexture(pTexture, 0);
#endif		
		GenerateMipmaps(pTexture, 0, WrapU, WrapV, pTextureScratchY, pTextureScratchX);
	}

e_Exit:
	pDrawCB->End();

	// restore back and z buffer and transforms
	g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
	SAFE_RELEASE(save.pBackBuffer);
	SAFE_RELEASE(save.pZBuffer);
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &save.matWorld);
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &save.matView);
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &save.matProjection);
	SAFE_RELEASE(pZBufferSuper);
	SAFE_RELEASE(pSurfaceSuper);
	SAFE_RELEASE(pTextureScratchX);
	SAFE_RELEASE(pTextureScratchY);
	SAFE_RELEASE(pTextureSuper);
	return S_OK;
}

//-----------------------------------------------------------------------------
// Choose level of detail 
//
// 0       = finest detail, all slices of original source textures
// ...
// i       = reduced number of slices, N / (1 << i)
// i + f   = odd slices fade to clear, texLOD[2*j+1] = tex[2*j+1] * (1-f) + clear * f
//           even slices compensate,   texLOD[2*j] = (tex[2*j+1] * f) OVER tex[2*j]
// i + 1   = reduced number of slices, N / (1 << (i+1))
// ...
// log2(N) = coarsest, one slice with composite of all source textures
//-----------------------------------------------------------------------------
HRESULT CSliceTexture::SetLevelOfDetail(float fLevelOfDetail)
{
	// Choose number of LOD slices
	if (fLevelOfDetail < 0.f)
	{
		m_fLevelOfDetail = 0.f;
		m_iLOD = 0;
		m_fLODFraction = 0.f;
	}
	else if (fLevelOfDetail > (float)m_dwLODMax)
	{
		m_fLevelOfDetail = (float)m_dwLODMax;
		m_iLOD = m_dwLODMax;
		m_fLODFraction = 0.f;
	}
	else
	{
		m_fLevelOfDetail = fLevelOfDetail;
		m_iLOD = (UINT)floorf(fLevelOfDetail);
		m_fLODFraction = fLevelOfDetail - (float)m_iLOD;
	}
	m_dwNumSlicesLOD = LevelOfDetailCount(m_iLOD);
	UINT index = LevelOfDetailIndex(m_iLOD);
	m_rpTextureLOD = m_rpTexture + index;
	return S_OK;
}

//-----------------------------------------------------------------------------
//
// Generate level-of-detail textures by compositing together alternating layers.
//
//-----------------------------------------------------------------------------
HRESULT CSliceTexture::ComputeLevelOfDetailTextures()
{
	// All the textures must have the same number of mip levels.
	DWORD nMip = m_rpTexture[0]->GetLevelCount();

	// save current back buffer and z buffer
	struct {
		IDirect3DSurface8 *pBackBuffer, *pZBuffer;
	} save;
	g_pd3dDevice->GetRenderTarget(&save.pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&save.pZBuffer);

	// set render state for compositing textures
	g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_TEX1);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);

	// use pixel shaders to composite two or three layers at a time
	DWORD dwPS2 = 0;
	{
#include "comp2.inl"
		g_pd3dDevice->CreatePixelShader(&psd, &dwPS2);
	}
	DWORD dwPS3 = 0;
	{
#include "comp3.inl"
		g_pd3dDevice->CreatePixelShader(&psd, &dwPS3);
	}

	// set default texture stage states
	UINT xx; // texture stage index
	for (xx = 0; xx < 4; xx++)
	{
		g_pd3dDevice->SetTexture(xx, NULL);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);	// Are the COLOROP and ALPHAOP needed since we're using a pixel shader?
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);	// pass texture coords without transformation
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXCOORDINDEX, 0);			// all the textures use the same tex coords
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAGFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MINFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPMAPLODBIAS, 0);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAXMIPLEVEL, 0);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORSIGN, 0);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE);
	}
	
	// Compute all the level-of-detail textures
	for (UINT iLOD = 1; m_dwNumSlices >> iLOD; iLOD++)
	{
		UINT nSliceSrc = LevelOfDetailCount(iLOD-1);
		LPDIRECT3DTEXTURE8 *apTextureSrc = m_rpTexture + LevelOfDetailIndex(iLOD - 1);
		UINT nSliceDst = LevelOfDetailCount(iLOD);
		LPDIRECT3DTEXTURE8 *apTextureDst = m_rpTexture + LevelOfDetailIndex(iLOD);
		
		// Composite source textures into LOD textures
		UINT iMipNotHandled = -1;
		for (UINT iSliceDst = 0; iSliceDst < nSliceDst; iSliceDst++)
		{
			LPDIRECT3DTEXTURE8 pTextureDst = apTextureDst[iSliceDst];
			UINT nComp;
			if (iSliceDst == nSliceDst-1 && nSliceSrc > nSliceDst * 2)
			{
				// composite 3 textures into the top-most level when number of source textures is odd
				nComp = 3;
				g_pd3dDevice->SetPixelShader(dwPS3);
			}
			else
			{
				// composite 2 textures (this is the default)
				nComp = 2;
				g_pd3dDevice->SetPixelShader(dwPS2);
			}
			for (xx = 0; xx < nComp; xx++)
			{
				g_pd3dDevice->SetTexture(xx, apTextureSrc[ iSliceDst * 2 + xx]);
				g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
				g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
			}
			for (; xx<4; xx++)
			{
				g_pd3dDevice->SetTexture(xx, NULL);
				g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
				g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
			}
			for (UINT iMip = 0; iMip < nMip; iMip++)
			{
				DWORD width = m_Width / (1 << iMip);
				if (width == 0) width = 1;
				DWORD height = m_Height / (1 << iMip);
				if (height == 0) height = 1;

				// Xbox render target must of be at least 16x16
				if (width*4 < 64 || width * height < 64)			
				{
					iMipNotHandled = iMip;
					break; // skip rest of coarser mipmaps and go to next slice
				}

				// Use a screen space quad to do the compositing.
				struct quad {
					float x, y, z, w;
					float u, v;
				} aQuad[4] =
				{
					{-0.5f,        -0.5f,         1.0f, 1.0f, 0.0f, 0.0f},
					{width - 0.5f, -0.5f,         1.0f, 1.0f, 1.0f, 0.0f},
					{-0.5f,        height - 0.5f, 1.0f, 1.0f, 0.0f, 1.0f},
					{width - 0.5f, height - 0.5f, 1.0f, 1.0f, 1.0f, 1.0f}
				};

				// get destination surface and set as render target
				IDirect3DSurface8 *pSurface;
				pTextureDst->GetSurfaceLevel(iMip, &pSurface);
				g_pd3dDevice->SetRenderTarget(pSurface, NULL); // no depth buffering
				g_pd3dDevice->BeginScene();	
				g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 2 or 3 textures
				g_pd3dDevice->EndScene();
				pSurface->Release();
			}
		}
		if (iMipNotHandled > 0 && iMipNotHandled != -1)
		{
			// fill in the small mips with filtered versions of the previous levels
			for (UINT iSliceDst = 0; iSliceDst < nSliceDst; iSliceDst++)
			{
				LPDIRECT3DTEXTURE8 pTextureDst = apTextureDst[iSliceDst];
				// D3DXFilterTexture(pTextureDst, NULL, iMipNotHandled - 1, D3DX_FILTER_BOX | D3DX_FILTER_MIRROR);
				GenerateMipmaps(pTextureDst, iMipNotHandled - 1);
			}
		}
	}

	// clean up pixel shaders
	g_pd3dDevice->SetPixelShader(0);
	g_pd3dDevice->DeletePixelShader(dwPS2);
	g_pd3dDevice->DeletePixelShader(dwPS3);
	
	// restore render states
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);

	// clear texture stage states
	for (xx=0; xx<4; xx++)
	{
		g_pd3dDevice->SetTexture(xx, NULL);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	}

	// restore back buffer and z buffer
	g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
	save.pBackBuffer->Release();
	save.pZBuffer->Release();
	return S_OK;
}

//-----------------------------------------------------------------------------
//
// Copy textures to new texture format
//
//-----------------------------------------------------------------------------
HRESULT CSliceTexture::SetTextureFormat(D3DFORMAT fmtNew)
{
	HRESULT hr;
	for (UINT iTexture = 0; iTexture < SLICETEXTURE_MAXSLICE * 2 - 1; iTexture++)	// convert all the slice textures
	{
		LPDIRECT3DTEXTURE8 pTextureDst = NULL;
		LPDIRECT3DTEXTURE8 pTextureSrc = m_rpTexture[iTexture];
		if (pTextureSrc == NULL)
			break;
		hr = CopyTexture(&pTextureDst, fmtNew, pTextureSrc);
		if (FAILED(hr))
			return hr;
		m_rpTexture[iTexture] = pTextureDst; // already addref'd
		pTextureSrc->Release();	// we're done with the old texture
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\Tree.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: Tree.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
// A tree represented by three different levels of detail:
//   full geometry, slice-texture branches, and whole tree slice textures
//-----------------------------------------------------------------------------
#ifdef _XBOX
#include <xtl.h>
#include <xgraphics.h>
#else
#include <d3d8.h>
#endif
#include <XBApp.h>
#include "Tree.h"
#include "Xfvf.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//////////////////////////////////////////////////////////////////////
// Simple branch rotations and offsets. In a game, these would
// be defined from a model file or procedurally.
//
static struct BranchXfm {
	float x, y, z;	// translation
	float yrot; // rotation in y
} s_rBranchXfm[] = {
	{0.2f, 4.65f, 0.25f,	-63.f * D3DX_PI / 180.f },
	{0.0f, 7.f, -0.1f,		49.6f * D3DX_PI / 180.f },
	{-0.4f, 8.4f, 0.6f,		167.f * D3DX_PI / 180.f },
};
static UINT s_nBranch = sizeof(s_rBranchXfm) / sizeof(BranchXfm);

//////////////////////////////////////////////////////////////////////
// load mesh and create slice textures
//
HRESULT CTree::Create(CHAR *strName, CXBPackedResource *pResource)
{
	HRESULT hr;
	if (strcmp(strName, "tree1"))
		return E_NOTIMPL;

	// Load the tree vertex shader
	{
		DWORD vsdecl[] = 
		{
			D3DVSD_STREAM(0),
			D3DVSD_REG(0, D3DVSDT_FLOAT3),		// position
			D3DVSD_REG(1, D3DVSDT_FLOAT3),		// normal
			D3DVSD_REG(2, D3DVSDT_FLOAT2),		// texcoords
			D3DVSD_END()
		};
		m_dwVertexShader = 0;
		hr = XBUtil_CreateVertexShader(g_pd3dDevice, "Shaders\\Tree.xvu", vsdecl, &m_dwVertexShader);
		if(FAILED(hr) || !m_dwVertexShader)
		{
			OUTPUT_DEBUG_STRING( "CTree::Create : error loading Tree.xvu\n" );
			return XBAPPERR_MEDIANOTFOUND;
		}
	}

	// Load the tree branch
	CHAR *strBranch = "Models\\branch4.xbg";
	hr = m_TreeBranch.Create(strBranch, pResource);
	if (FAILED(hr))
		return hr;
	// Put the instances in place
	m_nBranch = s_nBranch;
	m_rBranch = new Branch [ m_nBranch ];
	if (m_rBranch == NULL)
		return E_OUTOFMEMORY;
	for (UINT iBranch = 0; iBranch < m_nBranch; iBranch++)
	{
		D3DXMATRIX matRotY;
		D3DXMatrixRotationY(&matRotY, s_rBranchXfm[iBranch].yrot);
		D3DXMATRIX matTranslate;
		D3DXMatrixTranslation(&matTranslate, s_rBranchXfm[iBranch].x, s_rBranchXfm[iBranch].y, s_rBranchXfm[iBranch].z);
		m_rBranch[iBranch].m_matXfm =  matRotY * matTranslate;
		D3DXMatrixInverse(&m_rBranch[iBranch].m_matXfmInv, NULL, &m_rBranch[iBranch].m_matXfm);
	}

	// Load the trunk
	CHAR *strTrunk = "Models\\trunk.xbg";
	m_pMeshTrunk = NULL;
	m_pMeshTrunk = new CTreeShaderMesh;
	if (!m_pMeshTrunk)
		return E_OUTOFMEMORY;
	if( FAILED( m_pMeshTrunk->Create( g_pd3dDevice, strTrunk, pResource )))
		return XBAPPERR_MEDIANOTFOUND;
	
	// Get the overall bounding box
	hr = ComputeBoundingBox(&m_vMin, &m_vMax);
	if (FAILED(hr))
		return hr;

	// Slice the branch
	D3DXMATRIX matWorld;
	D3DXMatrixIdentity(&matWorld);
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld);
	Begin(true);	// setup vertex shader, etc.
	hr = m_TreeBranch.Slice();	// turn geometry into texture by taking slices
	End();
	if (FAILED(hr))
		return hr;
	D3DXMatrixIdentity(&matWorld);
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld);
	return hr;
}

//////////////////////////////////////////////////////////////////////
//  Take the union of two boxes
//
inline float MAX(float a, float b) { return a > b ? a : b; }
inline float MIN(float a, float b) { return a < b ? a : b; }
static void UnionBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax, const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax)
{
	pvMin->x = MIN(pvMin->x, vMin.x);
	pvMin->y = MIN(pvMin->y, vMin.y);
	pvMin->z = MIN(pvMin->z, vMin.z);
	pvMax->x = MAX(pvMax->x, vMax.x);
	pvMax->y = MAX(pvMax->y, vMax.y);
	pvMax->z = MAX(pvMax->z, vMax.z);
}

//////////////////////////////////////////////////////////////////////
// Calculate bounding box of tree trunk and foliage
//
HRESULT CTree::ComputeBoundingBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
	// start with bounding box of trunk
	HRESULT hr = m_pMeshTrunk->ComputeBoundingBox(pvMin, pvMax);
	if (FAILED(hr))
		return hr;

	// union in branch bounding boxes
#define MAXMAT 100	
	D3DXMATRIX matSave[MAXMAT];
	if (m_TreeBranch.m_pMesh->m_dwNumFrames > MAXMAT) 
		return E_NOTIMPL;
	// Save original xfms
	for (UINT iFrame = 0; iFrame < m_TreeBranch.m_pMesh->m_dwNumFrames; iFrame++)
	{
		XBMESH_FRAME *pFrame = &m_TreeBranch.m_pMesh->m_pMeshFrames[iFrame];
		matSave[iFrame] = pFrame->m_matTransform;
	}
	for (UINT iBranch = 0; iBranch < m_nBranch; iBranch++)
	{
		// Brain surgery on top-level frame of branch mesh
		for (UINT iFrame = 0; iFrame < m_TreeBranch.m_pMesh->m_dwNumFrames; iFrame++)
		{
			XBMESH_FRAME *pFrame = &m_TreeBranch.m_pMesh->m_pMeshFrames[iFrame];
			pFrame->m_matTransform = matSave[iFrame] * m_rBranch[iBranch].m_matXfm;
		}

		// Get new bounding box of transformed mesh
		m_TreeBranch.m_pMesh->ComputeBoundingBox(&m_rBranch[iBranch].m_vMin, &m_rBranch[iBranch].m_vMax);
		UnionBox(pvMin, pvMax, m_rBranch[iBranch].m_vMin, m_rBranch[iBranch].m_vMax);

	}
	// Restore original xfms
	for (iFrame = 0; iFrame < m_TreeBranch.m_pMesh->m_dwNumFrames; iFrame++)
	{
		XBMESH_FRAME *pFrame = &m_TreeBranch.m_pMesh->m_pMeshFrames[iFrame];
		pFrame->m_matTransform = matSave[iFrame];
	}
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Compute slice texture from whole tree geometry
//
HRESULT CTree::Slice()
{
	SliceInfo rSliceInfo[3] = {
		{ 8, 128, 128, D3DTADDRESS_CLAMP, D3DTADDRESS_CLAMP, D3DFMT_DXT4,
		  { 1.f, 0.f, 0.f }, { 0.f, 1.f, 0.f }, 0.4f, 0.6f },
		{ 8, 128, 128, D3DTADDRESS_CLAMP, D3DTADDRESS_CLAMP, D3DFMT_DXT4,
		  { 0.f, 1.f, 0.f }, { 1.f, 0.f, 0.f }, 0.4f, 0.6f },
		{ 8, 128, 128, D3DTADDRESS_CLAMP, D3DTADDRESS_CLAMP, D3DFMT_DXT4,
		  { 0.f, 0.f, 1.f }, { -1.f, 0.f, 0.f }, 0.4f, 0.6f },
	};
	return CSliceObject::Slice(3, rSliceInfo);
}

//////////////////////////////////////////////////////////////////////
// Prepare for drawing into slice textures or for drawing
// the full geometry.
//
HRESULT CTree::Begin(bool bWorldCoords)
{
	HRESULT hr;
	hr = CSliceObject::Begin(bWorldCoords);
	if (FAILED(hr))
		return hr;
	
	DWORD xx = 0;
#if 1
	/* Use global light */
	g_pd3dDevice->LightEnable(0, TRUE);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_MODULATE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
#else
   g_pd3dDevice->LightEnable(0, FALSE);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
#endif
 	g_pd3dDevice->SetPixelShader(0);
 	g_pd3dDevice->SetTexture( xx, NULL );
	for (xx = 1; xx < 4; xx++)
	{
		g_pd3dDevice->SetTexture( xx, NULL );
		g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_DISABLE );
		g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
	}
	g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
	g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
	g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE);
	g_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	static DWORD dwAlphaRef = 0;
	g_pd3dDevice->SetRenderState( D3DRS_ALPHAREF, dwAlphaRef );
	static BOOL bAlphaBlend = TRUE;
	g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, bAlphaBlend );
	g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
	g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
	SetupVertexShader();
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Setup the vertex shader to prepare for drawing
//
HRESULT CTree::SetupVertexShader()
{
	D3DXVECTOR3 vCenter = 0.5f * (m_vMin + m_vMax);
	static float fFractionY = 0.3f; // scale y to be near base of tree
	D3DXVECTOR3 vCenterOffset(vCenter.x, fFractionY * vCenter.y, vCenter.z);
	D3DXVECTOR4 vShadowCenter(vCenterOffset.x, vCenterOffset.y, vCenterOffset.z, 1.f);
	D3DXVECTOR3 vCorner = m_vMax - vCenterOffset;
	static float fColorScaleExtra = 1.f;
	float f1_R2 = fColorScaleExtra / D3DXVec3LengthSq(&vCorner);
	static D3DXCOLOR colorOffset(0.2f, 0.2f, 0.2f, 1.f);
	D3DXCOLOR colorScale = f1_R2 * (D3DXCOLOR(1.f, 1.f, 1.f, 1.f) - colorOffset);
	m_pMeshTrunk->m_dwVertexShader = m_dwVertexShader;
	m_pMeshTrunk->m_vShadowCenter = vShadowCenter;
	m_pMeshTrunk->m_colorOffset = colorOffset;
	m_pMeshTrunk->m_colorScale = colorScale;
	
	// take average of shadow center mapped back into branch coords
	D3DXVECTOR3 vBranchShadowCenterAvg(0.f, 0.f, 0.f);
	for (UINT iBranch = 0; iBranch < m_nBranch; iBranch++)
	{
		D3DXVECTOR3 vBranchShadowCenter;
		D3DXVec3TransformCoord(&vBranchShadowCenter, &vCenterOffset, &m_rBranch[iBranch].m_matXfmInv);
		vBranchShadowCenterAvg += (1.f / m_nBranch) * vBranchShadowCenter;
	}
	m_TreeBranch.m_pMesh->m_dwVertexShader = m_dwVertexShader;
	m_TreeBranch.m_pMesh->m_vShadowCenter = D3DXVECTOR4(vBranchShadowCenterAvg.x, vBranchShadowCenterAvg.y, vBranchShadowCenterAvg.z, 1.f);
	m_TreeBranch.m_pMesh->m_colorOffset = colorOffset;
	m_TreeBranch.m_pMesh->m_colorScale = colorScale;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Draw tree into slice texture
//
HRESULT CTree::Draw(const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax)		// draw all that intersects range
{
	D3DXVECTOR3 vFrom = 0.5f * (m_vMin + m_vMax); // start at center
	D3DXVECTOR3 vDiag = 0.5f * (m_vMax - m_vMin);
	static float fScale = 1000.f;
	((float *)vFrom)[m_iDirection] += fScale * ((float *)vDiag)[m_iDirection];	// offset in current slice direction
	return DrawLOD(vFrom, vFrom, TREE_DRAWFULLGEOMETRY);
}

//////////////////////////////////////////////////////////////////////
// Cleanup after drawing into slice textures
//
HRESULT CTree::End()
{
	return CSliceObject::End();
}

//////////////////////////////////////////////////////////////////////
// Used by SortBranches as an ordering function to sort models from
// far to near.
static int __cdecl CompareDist2(const void *arg1, const void *arg2 )
{
    float f1 = *(float *)arg1;
    float f2 = *(float *)arg2;
    if (f1 > f2) 
        return -1;
    else if (f1 < f2) 
        return 1;
    else
        return 0;
}

//////////////////////////////////////////////////////////////////////
// Sort the instances by distance from the eye
//
HRESULT CTree::SortBranches(const D3DXVECTOR3 &vFrom)
{
	for (UINT iBranch = 0; iBranch < m_nBranch; iBranch++)
	{
		D3DXVECTOR3 vCenter = 0.5f * (m_rBranch[iBranch].m_vMin + m_rBranch[iBranch].m_vMax);
		D3DXVECTOR3 vDiff = vCenter - vFrom;
		m_rBranch[iBranch].m_fDistance2 = D3DXVec3LengthSq(&vDiff);
	}
    qsort( (void *)m_rBranch, m_nBranch, sizeof(Branch), &CompareDist2 );
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// draw the trunk geometry
//
HRESULT CTree::DrawTrunk(const D3DXVECTOR3 &vFrom)
{
	g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
	g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
	g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE);
	static DWORD dwFlags = XBMESH_NOFVF;
	return m_pMeshTrunk->Render( g_pd3dDevice, dwFlags);
}

//////////////////////////////////////////////////////////////////////
// draw the branch geometry
//
HRESULT CTree::DrawBranches(const D3DXVECTOR3 &vFrom)
{
	HRESULT hr = S_OK;
	extern D3DLIGHT8 g_d3dLight;
	D3DXMATRIX matWorldSaved;
	g_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorldSaved);
	m_TreeBranch.Begin(true);
	for (UINT iBranch = 0; iBranch < m_nBranch; iBranch++)
	{
		D3DXMATRIX matWorld = m_rBranch[iBranch].m_matXfm * matWorldSaved;
		g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld);
		D3DXVECTOR3 vFrom2;
		D3DXVec3TransformCoord(&vFrom2, &vFrom, &m_rBranch[iBranch].m_matXfmInv);
	
		// put global light into local coords
		D3DLIGHT8 light = g_d3dLight;
		D3DXVECTOR3 vDirection(light.Direction);
		D3DXVec3TransformNormal((D3DXVECTOR3 *)&light.Direction, &vDirection, &m_rBranch[iBranch].m_matXfmInv);
		D3DXVECTOR3 vPosition(light.Position);
		D3DXVec3TransformCoord((D3DXVECTOR3 *)&light.Position, &vPosition, &m_rBranch[iBranch].m_matXfmInv);
		g_pd3dDevice->SetLight(0, &light);
	
		SetupVertexShader();
		
		hr = m_TreeBranch.DrawLOD(vFrom2, vFrom2, TREEBRANCH_DRAWFULLGEOMETRY);
		if (FAILED(hr))
			break;
	}
	m_TreeBranch.End();
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorldSaved);
	g_pd3dDevice->SetLight(0, &g_d3dLight);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// draw the whole tree as slices, or the trunk with slice branches, or
// the full geometry
//
HRESULT CTree::DrawLOD(const D3DXVECTOR3 &vFromFade, const D3DXVECTOR3 &vFromSliceOrder, DWORD dwFlags)
{
	HRESULT hr;
	if (m_pMeshTrunk == NULL)
		return E_FAIL;	// not initialized properly
	
	if (dwFlags == 0)	// draw the whole tree as slices
		return CSliceObject::DrawSlices(vFromFade, vFromSliceOrder, 0);

	// draw the tree trunk
	if (dwFlags & TREE_DRAWTRUNK)
	{
		hr = DrawTrunk(vFromFade);
		if (FAILED(hr))
			return hr;
	}

	// save current transformation
	if (dwFlags & TREE_DRAWBRANCHES)	// TODO: if the branches have opaque limbs, we will need to render the opaque subset here
	{
		// draw branch geometry
		hr = DrawBranches(vFromFade);
		if (FAILED(hr))
			return hr;
	}
	else
	{
		// draw branches as slice textures
		D3DXMATRIX matWorldSaved;
		g_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorldSaved);
		SortBranches(vFromSliceOrder);	// sort branches by distance from local eye
		m_TreeBranch.BeginDrawCubeSlices();
		g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
		for (UINT iBranch = 0; iBranch < m_nBranch; iBranch++)
		{
			D3DXMATRIX matWorld = m_rBranch[iBranch].m_matXfm * matWorldSaved;
			g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld);
			D3DXVECTOR3 vFromFade2;
			D3DXVec3TransformCoord(&vFromFade2, &vFromFade, &m_rBranch[iBranch].m_matXfmInv);
			hr = m_TreeBranch.SetCubeFade(vFromFade2, 0);
			if (FAILED(hr))
				break;
			D3DXVECTOR3 vFromSliceOrder2;
			D3DXVec3TransformCoord(&vFromSliceOrder2, &vFromSliceOrder, &m_rBranch[iBranch].m_matXfmInv);
			hr = m_TreeBranch.DrawCubeSlices(vFromSliceOrder2);
			if (FAILED(hr))
				break;
		}
		m_TreeBranch.EndDrawCubeSlices();
		g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorldSaved);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\TreeBranch.h ===
//-----------------------------------------------------------------------------
//  
//  File: TreeBranch.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
// A tree branch represented by two levels of detail:
//   full geometry and whole tree branch slice textures
//-----------------------------------------------------------------------------
#include <XBMesh.h>
#include <XBResource.h>
#include "SliceObject.h"

class CTreeShaderMesh : public CXBMesh {
public:
	// vertex shader constants
#define TREE_WORLD_VIEW_PROJECTION 50	
#define TREE_SHADOW_CENTER 54
#define TREE_COLOR_OFFSET 55
#define TREE_COLOR_SCALE 56
	DWORD		m_dwVertexShader;
	D3DXVECTOR4 m_vShadowCenter;
	D3DXCOLOR	m_colorOffset;
	D3DXCOLOR	m_colorScale;

	virtual BOOL RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset, XBMESH_SUBSET* pSubset, DWORD dwFlags );
};

class CTreeBranch : public CSliceObject
{
public:
	CTreeShaderMesh	*m_pMesh;				// branch mesh
public:
	HRESULT Create(CHAR *strName, CXBPackedResource *pResource);	// load tree
	HRESULT Scale(const D3DXVECTOR3 &vScale);
	HRESULT Slice();	// render geometry repeatedly to create slice textures
	
	// CSliceTextureDrawCallback overrides for drawing underlying mesh
	virtual HRESULT Begin(bool bWorldCoords = false);	// prepare for drawing
	virtual HRESULT Draw(const D3DXVECTOR3 &vMin,	// draw all that intersects range
						 const D3DXVECTOR3 &vMax);
	virtual HRESULT End();							// cleanup
	HRESULT SetState();	// Begin helper that sets up rendering state
#define TREEBRANCH_DRAWLIMBS		(1<<0)
#define TREEBRANCH_DRAWLEAVES		(1<<1)
#define TREEBRANCH_DRAWFULLGEOMETRY	(TREEBRANCH_DRAWLIMBS|TREEBRANCH_DRAWLEAVES)
	HRESULT DrawLOD(const D3DXVECTOR3 &vFromFade, const D3DXVECTOR3 &vFromSliceOrder, DWORD dwFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\TreeBranch.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: TreeBranch.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//	TreeBranch represented as both geometry and as a set of slice textures.
//-----------------------------------------------------------------------------
#ifdef _XBOX
#include <xtl.h>
#include <xgraphics.h>
#else
#include <d3d8.h>
#endif
#include <XBApp.h>
#include "TreeBranch.h"
#include "Xfvf.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//////////////////////////////////////////////////////////////////////
// Callback from XBMESH that allows us to set the vertex shader and
// associated constants.
//
BOOL CTreeShaderMesh::RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset, XBMESH_SUBSET* pSubset, DWORD dwFlags )
{
	g_pd3dDevice->SetVertexShader(m_dwVertexShader);
	D3DXMATRIX matProjection;
	g_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProjection );
	D3DXMATRIX matView;
	g_pd3dDevice->GetTransform( D3DTS_VIEW, &matView );
	D3DXMATRIX matWorld;
	g_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorld );
	D3DXMATRIX mat = matWorld * matView * matProjection;
	D3DXMATRIX matTranspose;
	D3DXMatrixTranspose(&matTranspose, &mat);
	g_pd3dDevice->SetVertexShaderConstant( TREE_WORLD_VIEW_PROJECTION, &matTranspose, 4 );
	g_pd3dDevice->SetVertexShaderConstant( TREE_SHADOW_CENTER, &m_vShadowCenter, 1 );
	D3DXCOLOR colorOffset;
	D3DXColorModulate(&colorOffset, &m_colorOffset, (D3DXCOLOR *)&pSubset->mtrl.Diffuse);
	g_pd3dDevice->SetVertexShaderConstant( TREE_COLOR_OFFSET, &colorOffset, 1 );
	D3DXCOLOR colorScale;
	D3DXColorModulate(&colorScale, &m_colorScale, (D3DXCOLOR *)&pSubset->mtrl.Diffuse);
	g_pd3dDevice->SetVertexShaderConstant( TREE_COLOR_SCALE, &colorScale, 1 );
	return TRUE;
}


//////////////////////////////////////////////////////////////////////
// load mesh and create slice textures
//
HRESULT CTreeBranch::Create(CHAR *strName, CXBPackedResource *pResource)
{
	m_pMesh = NULL;
	m_pMesh = new CTreeShaderMesh;
	if (!m_pMesh)
		return E_OUTOFMEMORY;
	if( FAILED( m_pMesh->Create( g_pd3dDevice, strName, pResource )))
		return XBAPPERR_MEDIANOTFOUND;
#if 1
	// TODO: fix media instead of this
	if (m_pMesh->m_dwNumFrames == 1)
		if (m_pMesh->m_dwNumFrames == 1)
			if (m_pMesh->m_pMeshFrames->m_MeshData.m_dwNumSubsets == 2)
			{
				if (!strcmp(m_pMesh->m_pMeshFrames->m_MeshData.m_pSubsets[1].strTexture, "leaf2"))
				{
					m_pMesh->m_pMeshFrames->m_MeshData.m_pSubsets[0].mtrl.Diffuse.a = 0.9999f;	// branches, too
					m_pMesh->m_pMeshFrames->m_MeshData.m_pSubsets[1].mtrl.Diffuse.a = 0.9999f;	// leaves
				}
			}
			else
			{
				m_pMesh->m_pMeshFrames->m_MeshData.m_pSubsets[0].mtrl.Diffuse.a = 0.9999f;	// branches, too
			}
#endif
	m_pMesh->ComputeBoundingBox(&m_vMin, &m_vMax);
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Scale the mesh
//
HRESULT CTreeBranch::Scale(const D3DXVECTOR3 &vScale)
{
	D3DXMATRIX matScale;
	D3DXMatrixScaling(&matScale, vScale.x, vScale.y, vScale.z);
	for (UINT iFrame = 0; iFrame < m_pMesh->m_dwNumFrames; iFrame++)
	{
		XBMESH_FRAME *pFrame = &m_pMesh->m_pMeshFrames[iFrame];
		pFrame->m_matTransform = matScale * pFrame->m_matTransform;
	}
	return m_pMesh->ComputeBoundingBox(&m_vMin, &m_vMax);
}

//////////////////////////////////////////////////////////////////////
// Compute slice texture from tree branch geometry
//
HRESULT CTreeBranch::Slice()
{
	SliceInfo rSliceInfo[3] = {
		{ 8, 256, 256, D3DTADDRESS_CLAMP, D3DTADDRESS_CLAMP, D3DFMT_DXT4,
		  { 1.f, 0.f, 0.f }, { 0.f, 1.f, 0.f }, 0.4f, 0.6f },
		{ 8, 256, 256, D3DTADDRESS_CLAMP, D3DTADDRESS_CLAMP, D3DFMT_DXT4,
		  { 0.f, 1.f, 0.f }, { 1.f, 0.f, 0.f }, 0.4f, 0.6f },
		{ 8, 256, 256, D3DTADDRESS_CLAMP, D3DTADDRESS_CLAMP, D3DFMT_DXT4,
		  { 0.f, 0.f, 1.f }, { -1.f, 0.f, 0.f }, 0.4f, 0.6f },
	};
	return CSliceObject::Slice(3, rSliceInfo);
}

//////////////////////////////////////////////////////////////////////
// Prepare for drawing into slice textures or for drawing
// the full geometry.
//
HRESULT CTreeBranch::Begin(bool bWorldCoords)
{
	HRESULT hr;
	hr = CSliceObject::Begin(bWorldCoords);
	if (FAILED(hr))
		return hr;
	return SetState();
}

//////////////////////////////////////////////////////////////////////
// Set render state for drawing into slice textures or for drawing
// the full geometry.
//
HRESULT CTreeBranch::SetState()
{
	/* Use global light */
	DWORD xx = 0;
	g_pd3dDevice->LightEnable(0, TRUE);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_MODULATE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
	g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
	g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE);		// tree texture uses, effectively, a 1-bit alpha
	g_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	static DWORD dwAlphaRef = 100;
	g_pd3dDevice->SetRenderState( D3DRS_ALPHAREF, dwAlphaRef );
	g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
	return S_OK;
}
	
HRESULT CTreeBranch::Draw(const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax)		// draw all that intersects range
{
	if (m_pMesh == NULL)
		return E_FAIL;	// not initialized properly
	// draw the whole mesh every time (ignore bounding box)
	static DWORD dwFlags = XBMESH_ALPHAONLY | XBMESH_NOFVF;
	return m_pMesh->Render( g_pd3dDevice, dwFlags);
}

HRESULT CTreeBranch::End()						// cleanup
{
	return CSliceObject::End();
}

//////////////////////////////////////////////////////////////////////
// Draw tree level-of-detail representation based on flags
//
HRESULT CTreeBranch::DrawLOD(const D3DXVECTOR3 &vFromFade, 
							 const D3DXVECTOR3 &vFromSliceOrder,
							 DWORD dwFlags)
{
	if (m_pMesh == NULL)
		return E_FAIL;	// not initialized properly
	if (dwFlags == 0)
		return CSliceObject::DrawSlices(vFromFade, vFromSliceOrder, 0);

	// draw the whole mesh every time (ignore bounding box)
	DWORD dwMeshFlags = XBMESH_NOFVF;
	if (dwFlags == TREEBRANCH_DRAWLIMBS)
		dwFlags |= XBMESH_OPAQUEONLY;
	else if (dwFlags == TREEBRANCH_DRAWLEAVES)
		dwFlags |= XBMESH_ALPHAONLY;
	// else dwFlags == TREEBRANCH_DRAWFULLGEOMETRY
	return m_pMesh->Render( g_pd3dDevice, dwMeshFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\Tree.h ===
//-----------------------------------------------------------------------------
//  
//  File: Tree.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//
// A tree represented by three different levels of detail:
//   full geometry, slice-texture branches, and whole tree slice textures
//-----------------------------------------------------------------------------
#include <XBMesh.h>
#include <XBResource.h>
#include "TreeBranch.h"

class CTree : public CSliceObject
{
public:
	CTreeShaderMesh		*m_pMeshTrunk;		// trunk mesh
	CTreeBranch			m_TreeBranch;		// branch represented as slice texture and as geometry
	UINT				m_nBranch;			// number of instances of tree branch
	struct Branch {
		float			m_fDistance2;		// used for sorting order
		D3DXVECTOR3		m_vMin, m_vMax;		// bounding box of branch in tree coords
		D3DXMATRIX		m_matXfm;			// local to tree coord transformation
		D3DXMATRIX		m_matXfmInv;		// inverse for mapping tree eye back into branch coordinates
	} *m_rBranch;
	DWORD				m_dwVertexShader;	// tree canopy shader
public:
	HRESULT Create(CHAR *strName, CXBPackedResource *pResource);	// load tree
	HRESULT ComputeBoundingBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);
	HRESULT Slice();	// render geometry repeatedly to create slice textures
	
	// CSliceTextureDrawCallback overrides for drawing underlying mesh during slicing
	virtual HRESULT Begin(bool bWorldCoords = false);	// prepare for drawing
	virtual HRESULT Draw(const D3DXVECTOR3 &vMin,	// draw all that intersects range
						 const D3DXVECTOR3 &vMax);
	virtual HRESULT End();							// cleanup

	HRESULT SetupVertexShader();	// set current matrices as vertex shader constants
	HRESULT SortBranches(const D3DXVECTOR3 &vFrom);	 // sort branches far to near based on distance to local eye
	HRESULT DrawTrunk(const D3DXVECTOR3 &vFrom);
	HRESULT DrawBranches(const D3DXVECTOR3 &vFrom);
#define TREE_DRAWTRUNK	        (1<<0)
#define TREE_DRAWBRANCHES		(1<<1)
#define TREE_DRAWFULLGEOMETRY   (TREE_DRAWTRUNK|TREE_DRAWBRANCHES)
	HRESULT DrawLOD(const D3DXVECTOR3 &vFromFade, 
		            const D3DXVECTOR3 &vFromSliceOrder,
					DWORD dwFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_TerrainTexture_OFFSET 0UL
#define resource_undergrass_OFFSET 20UL
#define resource_leaf2_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TrueTypeFont\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\Terrain.cpp ===
//-----------------------------------------------------------------------------
//  File: Terrain.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//-----------------------------------------------------------------------------
#include <assert.h>
#include <xtl.h>
#include <xgraphics.h>
#include <XBApp.h>
#include <XPath.h>
#include <XBUtil.h>
#include "Clip.h"
#include "Terrain.h"
#include "debug.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//////////////////////////////////////////////////////////////////////
// Helpers for filling geometric data from height-field image
//
UINT GetPixelSize(D3DFORMAT format);
D3DXCOLOR *GetPixelColor(D3DXCOLOR *pColor, BYTE *pPixel, D3DFORMAT format);
HRESULT CopyRectsVB(IDirect3DSurface8* pSourceSurface, CONST RECT* pSourceRectsArray,
					UINT cRects, void *pvDestinationVertices, UINT cbDestinationStride,
					UINT cbDestinationPitch, CONST POINT* pDestinationPointsArray);

//////////////////////////////////////////////////////////////////////
// Name: Grid::Initialize
// Desc: Allocate grid vertex buffer and allocate and fill index buffer.
//
HRESULT	Grid::Initialize(UINT width, UINT height, UINT cbVertexSize)
{
	HRESULT hr;

	m_width = width;
	m_height = height;
	
	// Create the vertex buffer
	SAFE_RELEASE(m_pVB);
	hr = g_pd3dDevice->CreateVertexBuffer(m_width * m_height * cbVertexSize, 0, 0, D3DPOOL_DEFAULT, &m_pVB);

	// Create the index buffer
	SAFE_RELEASE(m_pIB);
	hr = g_pd3dDevice->CreateIndexBuffer(3*2*(m_width-1)*(m_height-1)*sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pIB);
	if (FAILED(hr))
        return hr;

	// Fill the index buffer
	hr = FillIndexBuffer(m_pIB, NULL, NULL);
	if (FAILED(hr))
		return hr;

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Name: FillIndexbuffer
// Desc: Fill index buffer with tile indices from a region of the mesh
//
HRESULT Grid::FillIndexBuffer(LPDIRECT3DINDEXBUFFER8 pIB, const RECT *pRect, UINT *pnTri )
{
	assert(pIB);
	RECT rectFull = {0, 0, m_width, m_height};
	RECT rect;
	if (!pRect)
		rect = rectFull;
	else
	{
		// Clip rect to full rect
		rect = *pRect;
		if (rect.left   < rectFull.left)   rect.left   = rectFull.left;
		if (rect.top    < rectFull.top)    rect.top    = rectFull.top;
		if (rect.right  > rectFull.right)  rect.right  = rectFull.right;
		if (rect.bottom > rectFull.bottom) rect.bottom = rectFull.bottom;
	}
	if (pnTri) *pnTri = 0;
	if (rect.left >= rect.right - 1
		|| rect.top >= rect.bottom - 1)
		return S_FALSE;	// empty rect
	WORD *pIndices;
	if( FAILED( pIB->Lock( 0, 0, (BYTE**)&pIndices, 0 ) ) )
		return E_FAIL;
	long iiTri = 0;
	for (long iY = rect.top; iY < rect.bottom - 1; iY++ )
	{
		for (long iX = rect.left; iX < rect.right - 1; iX++ )
		{
			long lVertex = iY*m_width + iX;
			assert(lVertex >= 0 && lVertex <= 0xffff);
			WORD iVertex = (WORD)lVertex;
#if 0
			if ((iX ^ iY) & 1)
			{
				// flip alternating tiles to get coverage along both 45-degree lines
#endif				
				// tri 0
				pIndices[iiTri] = iVertex;
				pIndices[iiTri+1] = iVertex+m_width;
				pIndices[iiTri+2] = iVertex+m_width+1;
				// tri 1
				pIndices[iiTri+3] = iVertex;
				pIndices[iiTri+4] = iVertex+m_width+1;
				pIndices[iiTri+5] = iVertex+1;
#if 0				
			}
			else
			{
				// tri 0
				pIndices[iiTri] = iVertex;
				pIndices[iiTri+1] = iVertex+m_width;
				pIndices[iiTri+2] = iVertex+1;
				// tri 1
				pIndices[iiTri+3] = iVertex+1;
				pIndices[iiTri+4] = iVertex+m_width;
				pIndices[iiTri+5] = iVertex+m_width+1;
			}
#endif			
			iiTri += 6;
			if (pnTri) *pnTri += 2;
		}
	}
	pIB->Unlock();
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Name: Grid::Cleanup
// Desc: Clean up buffers.
//
HRESULT	Grid::Cleanup()
{
	SAFE_RELEASE(m_pVB);
	SAFE_RELEASE(m_pIB);
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Name: Terrain constructor
// Desc: Set defaults.
//
Terrain::Terrain()
{
	m_pTerrain = NULL;			// terrain height field
	m_pTexture = NULL;			// terrain texture
	m_pTexture2 = NULL;
}

//////////////////////////////////////////////////////////////////////
// Name: Initialize()
// Desc: Create the height field vertex buffers from m_pTerrain
//       height field texture
//
HRESULT Terrain::Initialize(LPDIRECT3DTEXTURE8 pTerrain,
							LPDIRECT3DTEXTURE8 pTexture,
							LPDIRECT3DTEXTURE8 pTexture2,
							const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax,
							const D3DXVECTOR2 &vTextureScale, const D3DXVECTOR2 &vTextureOffset,
							UINT width, UINT height)
{
	HRESULT hr;
	m_vMin = vMin;
	m_vMax = vMax;
	m_vTextureScale = vTextureScale;
	m_vTextureOffset = vTextureOffset;
	
	LPDIRECT3DTEXTURE8 pTerrainOld = m_pTerrain;
	m_pTerrain = pTerrain;
	pTerrain->AddRef();
	SAFE_RELEASE(pTerrainOld);
	
	LPDIRECT3DTEXTURE8 pTextureOld = m_pTexture;
	m_pTexture = pTexture;
	pTexture->AddRef();
	SAFE_RELEASE(pTextureOld);

	LPDIRECT3DTEXTURE8 pTexture2Old = m_pTexture2;
	m_pTexture2 = pTexture2;
	pTexture2->AddRef();
	SAFE_RELEASE(pTexture2Old);

	// Allocate terrain grid
	hr = m_grid.Initialize(width, height, sizeof(TERRAINVERTEX));
	if (FAILED(hr))
		return hr;

	// Fill terrain VB with height field data
	hr = ResetGrid();
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: GetHeightFieldNeighbors
// Desc: Returns four neighbors of normalized point
//-----------------------------------------------------------------------------
HRESULT Terrain::GetHeightFieldNeighbors(const D3DXVECTOR2 &vP, D3DXVECTOR2 *pvFraction, TERRAINVERTEX rVertex[4])
{
	HRESULT hr;
	IDirect3DSurface8 *pSurfaceTerrainLevel = NULL;
	static UINT iLevel = 0;
	hr = m_pTerrain->GetSurfaceLevel(iLevel, &pSurfaceTerrainLevel );
	if (FAILED(hr))
		return hr;
	D3DSURFACE_DESC desc;
	pSurfaceTerrainLevel->GetDesc(&desc);
	D3DFORMAT pixelFormat = desc.Format;
	DWORD dwPixelStride = GetPixelSize(pixelFormat);
	if (dwPixelStride == -1)
	{
		pSurfaceTerrainLevel->Release();
		return E_NOTIMPL;	// we can't handle the format
	}
	float fx0 = vP.x;
	float fy0 = vP.y;
#if 0
	// mirror wrap
	fx0 = fmodf(fx0, 2.f);
	if (fx0 <= -1.f) fx0 += 2.f;			// -2.f to -1.f
	else if (fx0 < 0.f) fx0 = -fx0;			// -1.f to 0.f
	else if (fx0 > 1.f) fx0 = 2.f - fx0;	//  1.f to 2.f
	fy0 = fmodf(fy0, 2.f);
	if (fy0 <= -1.f) fy0 += 2.f;			// -2.f to -1.f
	else if (fy0 < 0.f) fy0 = -fy0;			// -1.f to 0.f
	else if (fy0 > 1.f) fy0 = 2.f - fy0;	//  1.f to 2.f
#endif
	// get pixel coordinates
	float fx = fx0 * desc.Width + 0.5f;
	float fy = fy0 * desc.Height + 0.5f;
	int ix = (int)floorf(fx);
	int iy = (int)floorf(fy);
	pvFraction->x = fx - ix;
	pvFraction->y = fy - iy;
			
	// clamp to edge
	// TODO: better handling of right and bottom wrap boundaries
	if (ix < 0) ix = 0;
	if (iy < 0) iy = 0;
	if (ix >= (int)desc.Width - 1)
		ix = desc.Width - 2;
	if (iy >= (int)desc.Height - 1)
		iy = desc.Height - 2;
		
	// grab neighboring points from height-field texture
	RECT rect = {ix, iy, ix + 2, iy + 2};
	POINT point = {0, 0};
	hr = CopyRectsVB( pSurfaceTerrainLevel, &rect, 1, rVertex, sizeof(TERRAINVERTEX), 2 * sizeof(TERRAINVERTEX), &point);
	pSurfaceTerrainLevel->Release();
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: ResampleGrid
// Desc: Sample the height field at the current uv positions
//-----------------------------------------------------------------------------
HRESULT Terrain::ResampleGrid()
{
	HRESULT hr;
	// Loop through all the vertices in the mesh, getting height value from array
	// TODO: use mipmaps for coarser sampling densities
	TERRAINVERTEX *pVertices;
	hr = m_grid.m_pVB->Lock(0, 0, (BYTE**)&pVertices, 0);
	if (FAILED(hr))
		return hr;
	for (UINT iYGrid = 0; iYGrid < m_grid.m_height; iYGrid++)
	for (UINT iXGrid = 0; iXGrid < m_grid.m_width; iXGrid++)
	{
		TERRAINVERTEX *pVertex = &pVertices[iYGrid * m_grid.m_width + iXGrid];
		D3DXVECTOR2 vP(pVertex->vBase.x, pVertex->vBase.z);
		
		// lookup neighboring points from height-field texture
		D3DXVECTOR2 vFraction;
		TERRAINVERTEX rVertex[4];
		hr = GetHeightFieldNeighbors(vP, &vFraction, rVertex);
		if (FAILED(hr))
			goto e_Exit;
		
		// Get interpolated height value
		pVertex->vBase.y  = (1-vFraction.x) * (1-vFraction.y) * rVertex[0].vBase.y;
		pVertex->vBase.y +=   vFraction.x   * (1-vFraction.y) * rVertex[1].vBase.y;
		pVertex->vBase.y += (1-vFraction.x) *   vFraction.y   * rVertex[2].vBase.y;
		pVertex->vBase.y +=   vFraction.x   *   vFraction.y   * rVertex[3].vBase.y;
	}

 e_Exit:
	m_grid.m_pVB->Unlock();
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: RefineGrid
// Desc: Expand sampling grid around specified point to get more local samples
//-----------------------------------------------------------------------------
HRESULT Terrain::RefineGrid(const D3DXVECTOR3 &vPosition, float fEpsilon)
{
	HRESULT hr;
	
	// Map to normalized coords
	D3DXVECTOR3 vSize = m_vMax - m_vMin;
	D3DXVECTOR3 vP = vPosition - m_vMin;
	vP.x /= vSize.x;
	vP.z /= vSize.z;

	// Distort sampling field to get more local samples around point.
	// Center grid on point, and shrink samples to be close by.  Then
	// gradually move samples back out to default sampling rate.
	TERRAINVERTEX *pVertices;
	hr = m_grid.m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0);
	if (FAILED(hr))
		return hr;
	float fWidthScale = 1.f / (m_grid.m_width - 1);
	float fHeightScale = 1.f / (m_grid.m_height - 1);
	static float fShrink = 0.2f; // shrink factor for highest sampling rate
	static float fRadius = 0.45f; // radius of region with highest sampling rate
	float fRadius2 = fRadius*fRadius;
	float fExpandExp = logf(fShrink) / (fRadius - 0.5f);
	for (UINT iY = 0; iY < m_grid.m_height; iY++)
	for (UINT iX = 0; iX < m_grid.m_width; iX++)
	{
		TERRAINVERTEX *pVertex = &pVertices[iY * m_grid.m_width + iX];
		float u = iX * fWidthScale - 0.5f;	// -0.5 to 0.5
		float v = iY * fHeightScale - 0.5f;
#if 0
		// L2 norm maps a circle
		float r2 = u*u + v*v;
		if (r2 < fRadius2)
		{
			// uniform shrink
			u *= fShrink;
			v *= fShrink;
		}
		else if (r2 < 0.25f) // 0.5*0.5
		{
			// make samples further apart based on distance from point,
			// returning to unit scaling at 0.5
			float fExpand = fShrink * expf(fExpandExp * (sqrtf(r2) - fRadius));
			u *= fExpand;
			v *= fExpand;
		}
#else
		// L infinity norm maps squares
		float fu = fabsf(u), fv = fabsf(v);
		float r = fu > fv ? fu : fv;
		if (r < fRadius)
		{
			// uniform shrink
			u *= fShrink;
			v *= fShrink;
		}
		else if (r < 0.5f)
		{
			// make samples further apart based on distance from point,
			// returning to unit scaling at 0.5
			float fExpand = fShrink * expf(fExpandExp * (r - fRadius));
			u *= fExpand;
			v *= fExpand;
		}
#endif		
		pVertex->vBase.x = u + vP.x; // center on desired point
		pVertex->vBase.y = 0.f;
		pVertex->vBase.z = v + vP.z;
	}
	m_grid.m_pVB->Unlock();
	
	return ResampleGrid();
}

//-----------------------------------------------------------------------------
// Name: ResetGrid
// Desc: Drop all refinements and use just the base height field
//-----------------------------------------------------------------------------
HRESULT Terrain::ResetGrid()
{
	HRESULT hr;
	
	// Reset sampling grid to uniform sampling.
	TERRAINVERTEX *pVertices;
	hr = m_grid.m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0);
	if (FAILED(hr))
		return hr;
	float fWidthScale = 1.f / (m_grid.m_width - 1);
	float fHeightScale = 1.f / (m_grid.m_height - 1);
	for (UINT iY = 0; iY < m_grid.m_height; iY++)
	for (UINT iX = 0; iX < m_grid.m_width; iX++)
	{
		TERRAINVERTEX *pVertex = &pVertices[iY * m_grid.m_width + iX];
		float u = iX * fWidthScale;
		float v = iY * fHeightScale;
		pVertex->vBase.x = u;
		pVertex->vBase.y = 0.f;
		pVertex->vBase.z = v;
	}
	m_grid.m_pVB->Unlock();
	
	return ResampleGrid();
}

//-----------------------------------------------------------------------------
// Name: DrawTerrain()
// Desc: Draws the scene
//
HRESULT Terrain::DrawTerrain()
{
	if (m_grid.m_pVB == NULL)
		return S_FALSE;

	// Set vertex shader
	g_pd3dDevice->SetVertexShader( D3DFVF_XYZ );

	// Set render state
	g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
	g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE/*D3DCULL_CW */ );
	g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
	g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );

	// Set texture state
	UINT xx = 0;
	g_pd3dDevice->SetTexture( xx, m_pTexture );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_OBJECT);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);
	D3DXMATRIX matXZScale(m_vTextureScale.x,  0.f,                0.f, 0.f,
                          0.f,                0.f,                1.f, 0.f,
                          0.f,                m_vTextureScale.y,  0.f, 0.f,
                          m_vTextureOffset.x, m_vTextureOffset.y, 0.f, 1.f);
    g_pd3dDevice->SetTransform( D3DTS_TEXTURE0, &matXZScale );	// map (X,Z) to (U,V)
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE );
#if 0
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
#else		
	g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffaaaaaa);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG2, D3DTA_TFACTOR );
#endif		
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MAXANISOTROPY, 3 ); // make the terrain texture a little sharper as it recedes
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
#if 1
	// Use a second texture for tree shadows
	xx = 1;
	g_pd3dDevice->SetTexture( xx, m_pTexture2 );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXCOORDINDEX, xx | D3DTSS_TCI_OBJECT);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);
	D3DXMATRIX matXZ(1.f, 0.f, 0.f, 0.f,
                     0.f, 0.f, 1.f, 0.f,
                     0.f, 1.f, 0.f, 0.f,
                     0.f, 0.f, 0.f, 1.f);
    g_pd3dDevice->SetTransform( D3DTS_TEXTURE1, &matXZ );	// map (X,Z) to (U,V)
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG2, D3DTA_CURRENT );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MAXANISOTROPY, 3 ); // make the terrain texture a little sharper as it recedes
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
	for (xx = 2; xx < 4; xx++)
#else		
	for (xx = 1; xx < 4; xx++)
#endif		
	{
		g_pd3dDevice->SetTexture( xx, NULL );
		g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXCOORDINDEX, xx);
	}

	// Set world matrix
	D3DXVECTOR3 vSize = m_vMax - m_vMin;
    D3DXMATRIX matScale;
	D3DXMatrixScaling(&matScale, vSize.x, vSize.y, vSize.z);
	D3DXMATRIX matOffset;
	D3DXMatrixTranslation(&matOffset, m_vMin.x, m_vMin.y, m_vMin.z);
    D3DXMATRIX matWorld;
    g_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorld );
	D3DXMATRIX matWorldNew = matScale * matOffset * matWorld;
    g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorldNew );

	// Draw the terrain
	UINT width = m_grid.m_width;
	UINT height = m_grid.m_height;
	g_pd3dDevice->SetIndices( m_grid.m_pIB, 0 );
	g_pd3dDevice->SetStreamSource( 0, m_grid.m_pVB, sizeof(TERRAINVERTEX));
	g_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, width*height, 0, (width-1)*(height-1)*2 );

	// Cleanup
	g_pd3dDevice->SetTexture( 0, NULL);
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAXANISOTROPY, 1 );
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTexture( 1, NULL);
 	g_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXCOORDINDEX, 1 );
	g_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
	g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAXANISOTROPY, 1 );
	g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );	// restore world matrix
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Get interpolated point from within a terrain cell, based
// on which triangle the point falls within.
//
//         X -->
//       0       1
//     0 A-------B                           A-------B
//   Z   |\      |  a = 1-z                  |\    * |  a = 1-x
//   |   |  \    |  b = 0                    |  \    |  b = x-z
//   |   |    \  |  c = z-x                  |    \  |  c = 0
//   v   | *    \|  d = x                    |      \|  d = z
//     1 C-------D                           C-------D
//
inline void CellPoint(D3DXVECTOR3 *pv,
					  float x, float z,
					  const D3DXVECTOR3 *rvCorner)
{
	float a, b, c, d;
	if (x > z)
	{
		a = 1 - x;
		b = x - z;
		// c = 0
		d = z;
		*pv = a * rvCorner[0]
			+ b * rvCorner[1]
		//	+ c * rvCorner[2]
			+ d * rvCorner[3];
	}
	else
	{
		a = 1 - z;
		// b = 0
		c = z - x;
		d = x;
		*pv = a * rvCorner[0]
		//	+ b * rvCorner[1]
			+ c * rvCorner[2]
			+ d * rvCorner[3];
	}
}

//////////////////////////////////////////////////////////////////////
// Works like CellPoint but uses a float array instead of a point array.
//
inline void CellHeight(float *pfHeight,
					   float x, float z,
					   const float *rfCornerHeight)
{
	float a, b, c, d;
	if (x > z)
	{
		a = 1 - x;
		b = x - z;
		// c = 0
		d = z;
		*pfHeight = a * rfCornerHeight[0]
			+ b * rfCornerHeight[1]
		//	+ c * rfCornerHeight[2]
			+ d * rfCornerHeight[3];
	}
	else
	{
		a = 1 - z;
		// b = 0
		c = z - x;
		d = x;
		*pfHeight = a * rfCornerHeight[0]
		//	+ b * rfCornerHeight[1]
			+ c * rfCornerHeight[2]
			+ d * rfCornerHeight[3];
	}
}

//-----------------------------------------------------------------------------
// Name: GetTerrainPoint
// Desc: Returns height and normal of point directly below vPosition.
//-----------------------------------------------------------------------------
HRESULT Terrain::GetTerrainPoint(const D3DXVECTOR3 &vPosition,
								 float *pfTerrainHeight,
								 D3DXVECTOR3 *pvTerrainNormal)
{
	// TODO: return normal, too
	*pvTerrainNormal = D3DXVECTOR3(0.f, 1.f, 0.f);
	*pfTerrainHeight = 0.f; // default height

	// Map position to normalized coords
	// height field is indexed by (X,Z), with height stored in Y	
	D3DXVECTOR3 vSize = m_vMax - m_vMin;
	D3DXVECTOR3 vP;	
	vP.x = (vPosition.x - m_vMin.x) / vSize.x;
	// vP.y = (vPosition.x - m_vMin.y) / vSize.y; // Y coord is not needed
	vP.z = (vPosition.z - m_vMin.z) / vSize.z;

	long width = m_grid.m_width;
	long height = m_grid.m_height;
	
	// Use normalized position to choose terrain cell
	long XCenter, ZCenter;	// indices of upper-left corner of terrain cell
	float fX = vP.x * (width - 1);
	XCenter = (long)fX;
	fX -= (float)XCenter;	// X fraction
	if (XCenter < 0) XCenter = 0;
	if (XCenter > width - 2) XCenter = width - 2;
	float fZ = vP.z * (height - 1);
	ZCenter = (long)fZ;
	fZ -= (float)ZCenter;	// Z fraction
	if (ZCenter < 0) ZCenter = 0;
	if (ZCenter > height - 2) ZCenter = height - 2;
	
	// get indices into vertex array
	long lVertex0 = ZCenter * width + XCenter;
	long lVertex1 = lVertex0 + 1;
	long lVertex2 = lVertex0 + width;
	long lVertex3 = lVertex2 + 1;
	assert(lVertex0 >= 0 && lVertex0 <= 0xffff);
	assert(lVertex1 >= 0 && lVertex1 <= 0xffff);
	assert(lVertex2 >= 0 && lVertex2 <= 0xffff);
	assert(lVertex3 >= 0 && lVertex3 <= 0xffff);
	WORD iVertex0 = (WORD)lVertex0;
	WORD iVertex1 = (WORD)lVertex1;
	WORD iVertex2 = (WORD)lVertex2;
	WORD iVertex3 = (WORD)lVertex3;

	// Gather the corner heights
	LPDIRECT3DVERTEXBUFFER8 pVB = m_grid.m_pVB;
	if (pVB == NULL) return S_FALSE;
	TERRAINVERTEX *pVertices;
	if( FAILED( pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
		return E_FAIL;
	float rfCornerHeight[4];
	rfCornerHeight[0] = pVertices[iVertex0].vBase.y;
	rfCornerHeight[1] = pVertices[iVertex1].vBase.y;
	rfCornerHeight[2] = pVertices[iVertex2].vBase.y;
	rfCornerHeight[3] = pVertices[iVertex3].vBase.y;
	pVB->Unlock();

	// Get interpolated height
	CellHeight(pfTerrainHeight, fX, fZ, rfCornerHeight);

	// Scale and offset to output coords
	*pfTerrainHeight *= vSize.y;
	*pfTerrainHeight += m_vMin.y;
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT Terrain::Cleanup()
{
	SAFE_RELEASE(m_pTexture2);
	SAFE_RELEASE(m_pTexture);
	SAFE_RELEASE(m_pTerrain);
	m_grid.Cleanup();
    return S_OK;
}

// Returns size in bytes of pixel of given format, or -1 if size can
// not be determined from the format alone (e.g., D3DFMT_VERTEXDATA).
UINT GetPixelSize(D3DFORMAT format)
{
    switch (format)
    {
		case D3DFMT_A8R8G8B8:   return 4;
		case D3DFMT_X8R8G8B8:   return 4;
		case D3DFMT_A8:         return 1;
		case D3DFMT_LIN_A8R8G8B8:   return 4;
		case D3DFMT_LIN_X8R8G8B8:   return 4;
		case D3DFMT_LIN_A8:         return 1;
		default:
			return -1;
    }
}

// Unpacks color into pColor and returns pointer to pColor,
// or returns NULL if unpacking is not possible (or unimplemented.)
D3DXCOLOR *GetPixelColor(D3DXCOLOR *pColor, BYTE *pPixel, D3DFORMAT format)
{
    switch (format)
    {
		case D3DFMT_A8R8G8B8:
		case D3DFMT_LIN_A8R8G8B8:
		{
			float f = 1.f / 255.f;
			pColor->b = f * pPixel[0];
			pColor->g = f * pPixel[1];
			pColor->r = f * pPixel[2];
			pColor->a = f * pPixel[3];
			return pColor;
		}
		
		case D3DFMT_X8R8G8B8:
		case D3DFMT_LIN_X8R8G8B8:
		{
			float f = 1.f / 255.f;
			pColor->b = f * pPixel[0];
			pColor->g = f * pPixel[1];
			pColor->r = f * pPixel[2];
			pColor->a = 1.f;
			return pColor;
		}
		
		case D3DFMT_A8:
		case D3DFMT_LIN_A8:
		{
			float f = 1.f / 255.f;
			pColor->b = 0.f;
			pColor->g = 0.f;
			pColor->r = 0.f;
			pColor->a = f * pPixel[0];
			return pColor;
		}
		default:
			return NULL;
    }
}

//-----------------------------------------------------------------------------
// Name: CopyRectsVB()
// Desc: Like IDirect3DDevice8's CopyRects, but copies pixel data
// to vertex buffers
//-----------------------------------------------------------------------------
HRESULT CopyRectsVB(
	IDirect3DSurface8* pSourceSurface,
	CONST RECT* pSourceRectsArray,
	UINT cRects,
	void *pvDestinationVertices,
	// we'd like to use IDirect3DVertexBuffer8* pDestinationVB, but
	// multiple locks on the destination with DISCARD_CONTENTS doesn't work
	UINT cbDestinationStride,
	UINT cbDestinationPitch,
	CONST POINT* pDestinationPointsArray)
{
	HRESULT hr;
	D3DSURFACE_DESC desc;
	hr = pSourceSurface->GetDesc(&desc);
	if (FAILED(hr))
		return hr;
	D3DFORMAT pixelFormat = desc.Format;
	DWORD dwPixelStride = GetPixelSize(pixelFormat);
	if (dwPixelStride == -1)
		return E_NOTIMPL;	// we can't handle the format
	RECT rectFull;
	rectFull.left = 0;
	rectFull.top = 0;
	rectFull.right = desc.Width;
	rectFull.bottom = desc.Height;
	if (pSourceRectsArray == NULL)
	{
		if (cRects != 1
			&& cRects != 0)
			return E_INVALIDARG;
		pSourceRectsArray = &rectFull;
		cRects = 1;
	}
	for (UINT iRect = 0; iRect < cRects; iRect++)
	{
		// validate size of source rect
		const RECT *pRect = &pSourceRectsArray[iRect];
		if (pRect->top < rectFull.top
			|| pRect->left < rectFull.left
			|| pRect->bottom > rectFull.bottom
			|| pRect->right > rectFull.right)
			return E_INVALIDARG;
		// Get offset to upper left corner of destination
		POINT pointDestinationOffset;
		if (pDestinationPointsArray != NULL)
		{
			pointDestinationOffset.x = pDestinationPointsArray[iRect].x - pRect->left;
			pointDestinationOffset.y = pDestinationPointsArray[iRect].y - pRect->top;
		}
		else
		{
			pointDestinationOffset.x = 0;
			pointDestinationOffset.y = 0;
		}
		// WARNING: No validation is done on the destination rect
		D3DLOCKED_RECT lockedRect;
		hr = pSourceSurface->LockRect(&lockedRect, NULL, D3DLOCK_READONLY);
		if (FAILED(hr))
			return hr;
		if (XGIsSwizzledFormat(pixelFormat))
		{
			Swizzler s(desc.Width, desc.Height, 0);
			// Expand and copy the colors
			for (LONG iY = pRect->top; iY < pRect->bottom; iY++)
			{
				BYTE *pDestinationRow = (BYTE *)pvDestinationVertices + (iY + pointDestinationOffset.y) * cbDestinationPitch;
				s.SetV(s.SwizzleV(iY));
				s.SetU(s.SwizzleU(pRect->left));
				for (LONG iX = pRect->left; iX < pRect->right; iX++)
				{
					// Unpack and then pack color
					D3DXCOLOR pixelColor;
					BYTE *pPixel = (BYTE *)lockedRect.pBits + dwPixelStride * s.Get2D();
					if (GetPixelColor(&pixelColor, pPixel, pixelFormat) == NULL)
					{
						pSourceSurface->UnlockRect();
						return E_NOTIMPL;
					}
					D3DXVECTOR3 *pxyz = (D3DXVECTOR3 *)(pDestinationRow + (iX + pointDestinationOffset.x) * cbDestinationStride);
					pxyz->x = pixelColor.r;
					pxyz->y = pixelColor.g; 	// height
					pxyz->z = pixelColor.b;
					s.IncU();
				}
			}
		}
		else
		{
			// Expand and copy the colors
			for (LONG iY = pRect->top; iY < pRect->bottom; iY++)
			{
				BYTE *pSourceRow = (BYTE *)lockedRect.pBits + lockedRect.Pitch * (iY - pRect->top);
				BYTE *pDestinationRow = (BYTE *)pvDestinationVertices + (iY + pointDestinationOffset.y) * cbDestinationPitch;
				for (LONG iX = pRect->left; iX < pRect->right; iX++)
				{
					// Unpack color and copy to xyz
					D3DXCOLOR pixelColor;
					BYTE *pPixel = pSourceRow + (iX - pRect->left) * dwPixelStride;
					if (GetPixelColor(&pixelColor, pPixel, pixelFormat) == NULL)
					{
						pSourceSurface->UnlockRect();
						return E_NOTIMPL;
					}
					D3DXVECTOR3 *pxyz = (D3DXVECTOR3 *)(pDestinationRow + (iX + pointDestinationOffset.x) * cbDestinationStride);
					pxyz->x = pixelColor.r;
					pxyz->y = pixelColor.g;		// height
					pxyz->z = pixelColor.b;
				}
			}
		}
		pSourceSurface->UnlockRect();
		if (FAILED(hr))
			return hr;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\Terrain.h ===
#pragma once
//-----------------------------------------------------------------------------
//  
//  File: Terrain.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
#include "Terrain.h"

struct Grid {
	UINT m_width, m_height;					// size of grid
	LPDIRECT3DVERTEXBUFFER8 m_pVB;	 		// vertex buffer
	LPDIRECT3DINDEXBUFFER8  m_pIB;			// triangle indices for base layer
	Grid() {
		m_pVB = NULL; m_pIB = NULL;
	}
	~Grid() { Cleanup(); }
	HRESULT Initialize(UINT width, UINT height, UINT cbVertexSize);
	HRESULT FillIndexBuffer(LPDIRECT3DINDEXBUFFER8 pIB, const RECT *pRect, UINT *pnTri);
	HRESULT Cleanup();
};

struct TERRAINVERTEX
{
	D3DXVECTOR3 vBase; // texture coords + height field
};

class Terrain
{
public:
	Grid	m_grid;							// grid sampled from height field
	LPDIRECT3DTEXTURE8      m_pTerrain;		// terrain height field texture
	LPDIRECT3DTEXTURE8      m_pTexture;		// terrain texture
	LPDIRECT3DTEXTURE8		m_pTexture2;	// second terrain modulation texture (tree shadows, etc)
	D3DXVECTOR3 m_vMin, m_vMax;				// bounds of terrain
	D3DXVECTOR2 m_vTextureScale, m_vTextureOffset;	// terrain texture transformation
	HRESULT GetHeightFieldNeighbors(const D3DXVECTOR2 &vP, D3DXVECTOR2 *pvFraction, TERRAINVERTEX rVertex[4]);
	HRESULT ResampleGrid(); // fill vertex buffer with current sampling densities
public:
	Terrain();
	~Terrain() { Cleanup(); }
	HRESULT Initialize(LPDIRECT3DTEXTURE8 pTerrain,	// height field texture
					   LPDIRECT3DTEXTURE8 pTexture,	// texture to apply to terrain
					   LPDIRECT3DTEXTURE8 pTexture2,	// tree-shadow texture
					   const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax,	// bounds of terrain in world coords
					   const D3DXVECTOR2 &vTextureScale, const D3DXVECTOR2 &vTextureOffset, 	// terrain texture transformation
					   UINT width, UINT height);	// sanmpling density for mesh
	HRESULT GetTerrainPoint(const D3DXVECTOR3 &vPosition, // lookup point from terrain grid
							float *pfTerrainHeight,
							D3DXVECTOR3 *pvTerrainNormal);
	HRESULT RefineGrid(const D3DXVECTOR3 &vPosition, float fEpsilon); // add more samples near vPosition in the domain
	HRESULT ResetGrid();					// drop to lowest level LOD, uniform sampling
	HRESULT DrawTerrain();					// draw raw terrain geometry. Bracket with Begin .. End to set up rendering state.
	HRESULT Cleanup();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TrueTypeFont\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TrueTypeFont\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Trees\Trees.cpp ===
//-----------------------------------------------------------------------------
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//
//  Tree rendering with a hierarchy of slice texture level-of-detail 
// representations.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XPath.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <assert.h>
#include <xgraphics.h>
#include "Clip.h"
#include "Terrain.h"
#include "Tree.h"
#include "mipmap.h"

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
	{ XBHELP_LEFTSTICK,	   XBHELP_PLACEMENT_2, L"Move in-out\nand left-right" },
	{ XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Rotate and\ntilt view" },
	{ XBHELP_DPAD,		   XBHELP_PLACEMENT_2, L"Move up\nand down" },
	{ XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_1, L"Wire-frame" },
	{ XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_1, L"Slice debug" },
	{ XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle help" },
	{ XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Tree count +" },
	{ XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, L"Tree count -" },
	{ XBHELP_MISC_CALLOUT, XBHELP_PLACEMENT_2, L"Left trigger shows\nview-frustum culling" },
};
#define NUM_HELP_CALLOUTS (sizeof(g_HelpCallouts) / sizeof(XBHELP_CALLOUT))

//-----------------------------------------------------------------------------
// Global parameters and view toggles
//-----------------------------------------------------------------------------
D3DLIGHT8 g_d3dLight; 
D3DXVECTOR3 g_vLightDirection = D3DXVECTOR3(0.1f, 0.95f, 0.2f);
D3DXVECTOR3 g_vMin(-1000.f, 0.f, -1000.f), g_vMax(1000.f, 20.f, 1000.f);	// scale of height field in world coords
D3DXVECTOR2 g_vTerrainTextureScale(150.f, 150.f), g_vTerrainTextureOffset(0.f, 0.f);

bool g_bWireFrame = false;
bool g_bDrawHelp = false;

bool g_bCompressTextures = false;	// compress slice textures
bool g_bDebugSlice = false;			// draw slices with color coding and print out stats
bool g_bDebugSliceOpaque = false;	// draw slices without using slice texture

// tree and slice stats
struct TREESTATS {
	DWORD	dwActiveCount;
	DWORD	dwFullGeometryCount;
	DWORD	dwBranchSliceCount;
	DWORD	dwSliceCount;
} g_TREESTATS;
DWORD	g_dwTotalSliceCount = 0;

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//		 from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
	CXBFont			m_Font;					// Font for rendering stats and help
	CXBHelp			m_Help;					// Help class
    CXBPackedResource m_xprResources;		// Packed texture resources
    LPDIRECT3DTEXTURE8 m_pBlendTexture;		// Render target for level-of-detail transitions
    LPDIRECT3DSURFACE8 m_pBlendDepthBuffer; // Depth buffer for level-of-detail transitions
	float			m_fBlendFactor;			// Blend factor that smoothly changes from 0 to 1
	D3DXVECTOR3		m_vFrom, m_vAt, m_vUp;	// Viewing parameters
	D3DXMATRIX		m_matWorld;
	D3DXMATRIX		m_matView;
	D3DXMATRIX		m_matViewInverse;
	D3DXMATRIX		m_matProjection;
	Terrain		   *m_pTerrain; // current terrain representation
	LPDIRECT3DTEXTURE8 m_pTextureTerrainShadow;	// shadows cast on terrain by trees
#define NTREELIBRARY 1
	CTree			m_rTreeLibrary[NTREELIBRARY];
#define NTREEX 50
#define NTREEZ 50
#define NMAXTREEINSTANCE (NTREEX * NTREEZ)
    float			m_fLevelOfDetail;			// scale factor for level of detail calculation
	D3DXVECTOR3		m_rvFromLevelOfDetail[2];	// position of previous level-of-detail update
	D3DXVECTOR3		m_rvAtLevelOfDetail[2];		// view position of previous level-of-detail update
    int				m_riNumTrees[2];			// current and previous number of trees
	float			m_fNumTrees;				// for incrementing/decrementing number of trees
    struct TreeSort {
        float fDist2;			// squared distance from eye. This field must be first for qsort to work.
		UINT iTree;				// index into m_rTree array
    } *m_rrTreeSort[2];			// model instances, sorted by distance from eye
	struct TreeData {
        D3DXVECTOR3 vPosition;	// position of instance
		float fYRot;			// Y rotation of instance
		D3DXMATRIX mat;			// tree to world coords
		D3DXMATRIX matInv;		// world to tree coords
		struct LOD {
			float fLevelOfDetail;   // level-of-detail values for this object
			D3DXVECTOR3 vFrom;		// local eye position determines sorting order for branches, etc.
			DWORD dwDrawFlags;		// set to TREE_DRAWTRUNK | TREE_DRAWBRANCHES depending on level of detail
			float fTreeSliceTextureLOD;
			float fBranchSliceTextureLOD;
		} rLOD[2];
		bool bSameLevelOfDetail; // the level-of-detail representation is the same for both rendering passes
		bool bVisible;			// is tree visible?
		D3DXVECTOR3 vFromFade;	// current vFrom value in local tree coords
		UINT iTreeLibrary;		// index into m_rTreeLibrary
	} *m_rTree;
public:
	CXBoxSample();
    HRESULT UpdateTrees();	// update sorting and level-of-detail parameters
    HRESULT CullTrees();	// cull trees based on current viewing matrices
	HRESULT ShadowTrees();	// render current set of trees onto terrain texture
	HRESULT BlendScreenTexture(LPDIRECT3DTEXTURE8 pTexture, D3DCOLOR colorBlend); // blend texture with backbuffer
	
	// CXBApplication overrides
	HRESULT Initialize();
	HRESULT FrameMove();
	HRESULT Render();
	HRESULT Cleanup();
};

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//		 message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
void __cdecl main()
{
	CXBoxSample xbApp;
	if( FAILED( xbApp.Create() ) )
		return;
	xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
			:CXBApplication()
{
#ifdef _DEBUG
	m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;	// Allow unlimited frame rate
#else
	m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_TWO;	// 30Hz
#endif
	m_pTerrain = NULL;
	m_pTextureTerrainShadow = NULL;
    m_fLevelOfDetail = 1.f; // 0.045f;
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
	HRESULT hr;
	m_bPaused = true; // false;

	XPath_SetBasePath(_T("d:\\media\\"));

	// Create a font
	if(FAILED(hr = m_Font.Create(m_pd3dDevice, "Font.xpr")))
		return XBAPPERR_MEDIANOTFOUND;

	// Create the help
	if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
		return XBAPPERR_MEDIANOTFOUND;

    // Load resources from the packed resource file. Resources (textures, vertex
    // buffers,etc.) can be packed this way so they load super quick and require
    // no load-time processing (like parsing a .bmp file, changing formats,
    // swizzling, etc.). See the code in XBResource.cpp to see how simple it is.
	static XBRESOURCE rResource[resource_NUM_RESOURCES] = {
		{ "TerrainTexture",	 resource_TerrainTexture_OFFSET },
		{ "undergrass", 	resource_undergrass_OFFSET },
		{ "leaf2",		resource_leaf2_OFFSET },
	};
    if( FAILED( m_xprResources.Create( m_pd3dDevice, "Resource.xpr", resource_NUM_RESOURCES, rResource ) ) )
        return E_FAIL;

    // create the texture used for blending level-of-detail transitions
	D3DSURFACE_DESC descBackBuffer;
	m_pBackBuffer->GetDesc(&descBackBuffer);
    hr = m_pd3dDevice->CreateTexture(descBackBuffer.Width, descBackBuffer.Height, 1, 0, D3DFMT_LIN_A8R8G8B8, D3DPOOL_DEFAULT, &m_pBlendTexture);
	if (FAILED(hr))
		return hr;
	hr = m_pd3dDevice->CreateDepthStencilSurface(descBackBuffer.Width, descBackBuffer.Height, D3DFMT_LIN_D24S8, D3DMULTISAMPLE_NONE, &m_pBlendDepthBuffer);
	if (FAILED(hr))
		return hr;

	// set light parameters
	ZeroMemory(&g_d3dLight, sizeof(D3DLIGHT8));
	g_d3dLight.Type = D3DLIGHT_DIRECTIONAL;
	g_d3dLight.Position = D3DXVECTOR3(10000.f, 10000.f, 10000.f); // sun
	g_d3dLight.Direction = g_vLightDirection;
	g_d3dLight.Ambient  = D3DXCOLOR(0.4f, 0.4f, 0.4f, 1.f); // D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.f);
	g_d3dLight.Diffuse = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
	g_d3dLight.Specular = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
	g_pd3dDevice->SetLight(0, &g_d3dLight);
	g_pd3dDevice->LightEnable(0, TRUE);

	// load the terrain image and create the height field mesh
	m_pTerrain = new Terrain;
	if (m_pTerrain == NULL)
		return E_OUTOFMEMORY;
	LPDIRECT3DTEXTURE8 pTextureTerrain = m_xprResources.GetTexture( (DWORD)resource_TerrainTexture_OFFSET );
	LPDIRECT3DTEXTURE8 pTextureUndergrass = m_xprResources.GetTexture( (DWORD)resource_undergrass_OFFSET );
	hr = m_pd3dDevice->CreateTexture(512, 512, 0, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &m_pTextureTerrainShadow);
	if (FAILED(hr))
		return hr;
	UINT widthTerrain = 40, heightTerrain = 40;	// number of samples in terrain mesh
	hr = m_pTerrain->Initialize(pTextureTerrain, pTextureUndergrass, m_pTextureTerrainShadow,
								g_vMin, g_vMax, g_vTerrainTextureScale, g_vTerrainTextureOffset,
								widthTerrain, heightTerrain);
	if (FAILED(hr))
		return hr;

	// create the tree library
#define BOUNDSET_XMIN 001
#define BOUNDSET_YMIN 002
#define BOUNDSET_ZMIN 004
#define BOUNDSET_XMAX 010
#define BOUNDSET_YMAX 020
#define BOUNDSET_ZMAX 040
#define BOUNDSET_XZ (BOUNDSET_XMIN|BOUNDSET_XMAX|BOUNDSET_ZMIN|BOUNDSET_ZMAX)
	static struct TreeLibraryData {
		CHAR *strName;
		DWORD dwFlags;
		struct Vector { float x, y, z; } vScale, vMin, vMax;
	} rTreeLibraryData[NTREELIBRARY] = 	{
		{ "tree1",	0,        { 1.f, 1.f, 1.f} },	// use tree's bbox
	};
	for (UINT iTreeLibrary = 0; iTreeLibrary < NTREELIBRARY; iTreeLibrary++)
	{
		CTree *pTreeLibrary = &m_rTreeLibrary[iTreeLibrary];
		TreeLibraryData *pTreeLibraryData = &rTreeLibraryData[iTreeLibrary];
		if ( FAILED( pTreeLibrary->Create( pTreeLibraryData->strName, &m_xprResources ) ) )
			return XBAPPERR_MEDIANOTFOUND;
		// pTreeLibrary->Scale(*(D3DXVECTOR3 *)&pTreeLibraryData->vScale); // scale top-level frames and then get new bounding box
		// Set bounds to be different than actual geometry bounding box
		if (pTreeLibraryData->dwFlags & BOUNDSET_XMIN) pTreeLibrary->m_vMin.x = pTreeLibraryData->vMin.x;
		if (pTreeLibraryData->dwFlags & BOUNDSET_YMIN) pTreeLibrary->m_vMin.y = pTreeLibraryData->vMin.y;
		if (pTreeLibraryData->dwFlags & BOUNDSET_ZMIN) pTreeLibrary->m_vMin.z = pTreeLibraryData->vMin.z;
		if (pTreeLibraryData->dwFlags & BOUNDSET_XMAX) pTreeLibrary->m_vMax.x = pTreeLibraryData->vMax.x;
		if (pTreeLibraryData->dwFlags & BOUNDSET_YMAX) pTreeLibrary->m_vMax.y = pTreeLibraryData->vMax.y;
		if (pTreeLibraryData->dwFlags & BOUNDSET_ZMAX) pTreeLibrary->m_vMax.z = pTreeLibraryData->vMax.z;
		pTreeLibrary->Slice();	// turn geometry into texture by taking slices
	}

	// position the tree instances
	srand(123456);
#define irand(a) ((rand()*(a))>>15)
#define frand(a) ((float)rand()*(a)/32768.0f)
	m_rrTreeSort[0] = new TreeSort [ NMAXTREEINSTANCE ];
	m_rrTreeSort[1] = new TreeSort [ NMAXTREEINSTANCE ];
	m_rTree = new TreeData [ NMAXTREEINSTANCE ];
	D3DXVECTOR3 vTerrainCell = g_vMax - g_vMin;
	vTerrainCell.x /= NTREEX;
	vTerrainCell.z /= NTREEZ;
	for (int iTreeZ = 0; iTreeZ < NTREEZ; iTreeZ++)
	for (int iTreeX = 0; iTreeX < NTREEX; iTreeX++)
	{
		int iTree = iTreeZ * NTREEX + iTreeX;
		TreeData *pTree = &m_rTree[iTree];
		pTree->iTreeLibrary = irand(NTREELIBRARY);
		CTree *pTreeLibrary = &m_rTreeLibrary[pTree->iTreeLibrary];
		static float fCenter = 0.75f;	// radius from center of cell for semi-random tree placement
		pTree->vPosition = g_vMin +
			D3DXVECTOR3((iTreeX + 0.5f  + (frand(1.f) - 0.5f) * fCenter) * vTerrainCell.x,
						0.f,
						(iTreeZ + 0.5f  + (frand(1.f) - 0.5f) * fCenter) * vTerrainCell.z);
		float fTerrainHeight;
		D3DXVECTOR3 vTerrainNormal;
		m_pTerrain->GetTerrainPoint(pTree->vPosition, &fTerrainHeight, &vTerrainNormal);
		pTree->vPosition.y = fTerrainHeight - pTreeLibrary->m_vMin.y;
		pTree->fYRot = frand(2.f * D3DX_PI);			// Y rotation of instance
		D3DXMATRIX matRotY;
		D3DXMatrixRotationY(&matRotY, pTree->fYRot);
		D3DXMATRIX matTrans;
		D3DXMatrixTranslation(&matTrans, pTree->vPosition.x, pTree->vPosition.y, pTree->vPosition.z);
		pTree->mat = matRotY * matTrans;
		D3DXMatrixInverse(&pTree->matInv, NULL, &pTree->mat);
		pTree->vPosition.y += 0.5f * (pTreeLibrary->m_vMax.y + pTreeLibrary->m_vMin.y);	// offset level-of-detail center to center of tree
	}
	// randomize tree ordering so that a subset will appear in random places
	for (int iTree = 0; iTree < NMAXTREEINSTANCE; iTree++)
	{
		TreeData t = m_rTree[iTree];
		int jTree = irand(NMAXTREEINSTANCE);
		m_rTree[iTree] = m_rTree[jTree];
		m_rTree[jTree] = t;
	}
	m_fNumTrees = NMAXTREEINSTANCE; // default number of trees to start
	if (m_fNumTrees > NMAXTREEINSTANCE)
		m_fNumTrees = NMAXTREEINSTANCE;
	m_riNumTrees[0] = m_riNumTrees[1] = 0;	// set when UpdateTrees is called

	// Set camera parameters
	m_vFrom = D3DXVECTOR3( 27.1533f, 30.f, -6.41251f);
	m_vAt = m_vFrom + D3DXVECTOR3(-0.97f, -0.1f, 0.2f);
	m_vUp = D3DXVECTOR3( 0.0f, 1.0f , 0.0f);
	D3DXMatrixPerspectiveFovLH( &m_matProjection, D3DX_PI/4, 640.f/480.f, 0.4f, 4000.0f );
	D3DXMatrixLookAtLH( &m_matView, &m_vFrom, &m_vAt, &m_vUp);
	D3DXMatrixInverse(&m_matViewInverse, NULL, &m_matView);
	D3DXMatrixIdentity(&m_matWorld);

	// Set up level-of-detail processing
	m_fBlendFactor = 0.f;
	UpdateTrees();
	UpdateTrees();	// call twice to initialize double-buffered level-of-detail values
	ShadowTrees();	// render current set of tree shadows onto terrain texture
	return hr;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Cleanup()
{
	SAFE_DELETE(m_pTerrain);
	SAFE_RELEASE(m_pTextureTerrainShadow);
	SAFE_RELEASE(m_pBlendDepthBuffer);
	SAFE_RELEASE(m_pBlendTexture);
	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//		 the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
		g_bDrawHelp = !g_bDrawHelp;

	if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE])
		g_bWireFrame = !g_bWireFrame;

	if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK])
	{
		if (g_bDebugSlice)
		{
			if (!g_bDebugSliceOpaque)
				g_bDebugSliceOpaque = true;
			else
			{
				g_bDebugSlice = false;
				g_bDebugSliceOpaque = false;
			}
		}
		else
			g_bDebugSlice = true;
	}
	
	// Scale translation by height above ground plane
	float fTranslateScale = fabsf(m_vFrom.y) + 0.01f;

	// update view position
	static float fOffsetScale = 0.5f;
	float fX1 = m_DefaultGamepad.fX1;
	fX1 *= fX1 * fX1; // fX1 cubed
	float fY1 = m_DefaultGamepad.fY1;
	fY1 *= fY1 * fY1; // fY1 cubed
	D3DXVECTOR3 vOffset(fX1, 0.f, fY1);	// screen space offset, X moves left-right, Y moves in-out in depth
	D3DXVec3TransformNormal(&vOffset, &vOffset, &m_matViewInverse);
	D3DXVec3Normalize(&m_vUp, &m_vUp);
	vOffset -= D3DXVec3Dot(&vOffset, &m_vUp) * m_vUp; // don't move up or down with thumb sticks
	D3DXVec3Normalize(&vOffset, &vOffset);
	vOffset *= fTranslateScale * fOffsetScale * m_fElapsedTime;
	m_vFrom += vOffset;
	m_vAt += vOffset;
	
	// move up and down with DPAD
	static float fVerticalScale = 1.f;
	D3DXVECTOR3 vVerticalOffset(0.f, 0.f, 0.f);
	if (m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
		vVerticalOffset.y += fTranslateScale * fVerticalScale * m_fElapsedTime;
	if(m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
		vVerticalOffset.y -= fTranslateScale * fVerticalScale * m_fElapsedTime;
	m_vFrom += vVerticalOffset;
	m_vAt += vVerticalOffset;

	// update view angle
	static float fAtOffsetScale = 4.f;
	D3DXVECTOR3 vAtOffset(0.f, 0.f, 0.f);
	float fX2 = m_DefaultGamepad.fX2;
	fX2 *= fX2 * fX2; // fX2 cubed
	float fY2 = m_DefaultGamepad.fY2;
	fY2 *= fY2 * fY2; // fY2 cubed
	vAtOffset.x += fAtOffsetScale * fX2 * m_fElapsedTime;
	D3DXVECTOR3 vE = m_vAt - m_vFrom;
	D3DXVec3Normalize(&vE, &vE);
	float fThreshold = 0.99f;
	float fEdotU = D3DXVec3Dot(&vE, &m_vUp);
	if ((fEdotU < -fThreshold && fY2 < 0.f) // near -vUp, but positive movement
		|| (fEdotU > fThreshold && fY2 > 0.f)	// near vUp, but negative movement
		|| (fEdotU > -fThreshold && fEdotU < fThreshold))		// ordinary case
		vAtOffset.y -= fAtOffsetScale * fY2 * m_fElapsedTime;	// screen-space Y displacement means up-down view turn
	D3DXVec3TransformNormal(&vAtOffset, &vAtOffset, &m_matViewInverse);
	m_vAt += vAtOffset;

	// Check to make sure we're not beneath the ground plane

	// For the projection matrix, we set up a perspective transform (which
	// transforms geometry from 3D view space to 2D viewport space, with
	// a perspective divide making objects smaller in the distance). To build
	// a perpsective transform, we need the field of view (1/4 pi is common),
	// the aspect ratio, and the near and far clipping planes (which define at
	// what distances geometry should be no longer be rendered).
	D3DXMatrixPerspectiveFovLH( &m_matProjection, D3DX_PI/4, 640.f/480.f, 0.4f, 4000.0f );

	// Set up our view matrix.
	D3DXMatrixLookAtLH( &m_matView, &m_vFrom, &m_vAt, &m_vUp);
	D3DXMatrixInverse(&m_matViewInverse, NULL, &m_matView);

	// Set world matrix to identity
	D3DXMatrixIdentity(&m_matWorld);

	// change number of trees
	BYTE buttonA = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_A];
	BYTE buttonB = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_B];
	static int iThreshold = 1;
	if (buttonA >= iThreshold || buttonB >= iThreshold)
	{
		static float fMinTreesPerSecond = 0.5f;
		static float fMaxTreesPerSecond = 100.f;
		float fx = (buttonA - iThreshold) / (255.f - iThreshold);
		fx = (fx <= 0.f) ? 0.f : fMinTreesPerSecond + fMaxTreesPerSecond * fx * fx;
		float fy = (buttonB - iThreshold) / (255.f - iThreshold);
		fy = (fy <= 0.f) ? 0.f : fMinTreesPerSecond + fMaxTreesPerSecond * fy * fy;
		m_fNumTrees += m_fElapsedTime * (fx - fy);
		if (m_fNumTrees < 1) 
			m_fNumTrees = 1;
		if (m_fNumTrees > NMAXTREEINSTANCE) 
			m_fNumTrees = NMAXTREEINSTANCE;
		static float fBlendTreeFactor = 5.f;
		m_fBlendFactor += fBlendTreeFactor * m_fElapsedTime;
	}

	// smoothly go to next level-of-detail representation
	D3DXVECTOR3 vFromDelta = m_vFrom - m_rvFromLevelOfDetail[0];
	float fFromDelta = D3DXVec3LengthSq(&vFromDelta);
	static float fFromDeltaThreshold = 1e-4f;
	static float fBlendTimeFactor = 1.f;
	static float fBlendTimeFactorSlow = 0.25f;

	static float fBlendHeight0 = 10.f;
	static float fBlendHeight1 = 200.f;
	float fBlendHeightScale = expf((m_vFrom.z - fBlendHeight0) * logf(3.f) / (fBlendHeight1 - fBlendHeight0));
	static float fBlendHeightScaleMax = 3.f;
	static float fBlendHeightScaleMin = 1.f;
	if (fBlendHeightScale > fBlendHeightScaleMax)
		fBlendHeightScale = fBlendHeightScaleMax;
	if (fBlendHeightScale < fBlendHeightScaleMin)
		fBlendHeightScale = fBlendHeightScaleMin;

	if (fFromDelta > fFromDeltaThreshold)
	{
		// change LOD's quickly when moving
		m_fBlendFactor += fBlendHeightScale * fBlendTimeFactor * m_fElapsedTime;
	}
	else
	{
		// change LOD slowly when stopped
		m_fBlendFactor += fBlendHeightScale * fBlendTimeFactorSlow * m_fElapsedTime;
	}
	if (m_fBlendFactor > 1.f)
	{
		m_fBlendFactor = 0.f;	// triggers level-of-detail update

		// update tree level of detail and sorting order
		UINT iNumTrees = m_riNumTrees[1];
		UpdateTrees();
		if (iNumTrees != m_riNumTrees[1])
			ShadowTrees();	// render current set of trees onto terrain texture
	}
	CullTrees();		// update tree visibility
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: CompareDist2()
// Desc: Used by UpdateTrees as an ordering function to sort models from
//   near to far.
//-----------------------------------------------------------------------------
static int __cdecl CompareDist2(const void *arg1, const void *arg2 )
{
    float f1 = *(float *)arg1;
    float f2 = *(float *)arg2;
    if (f1 < f2) 
        return -1;
    else if (f1 > f2) 
        return 1;
    else
        return 0;
}

//-----------------------------------------------------------------------------
// Name: UpdateTrees()
// Desc: set level-of-detail and sort the instances by distance from the eye
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::UpdateTrees()
{
	memcpy(m_rrTreeSort[0], m_rrTreeSort[1], sizeof(TreeSort) * m_riNumTrees[1]);
	m_riNumTrees[0] = m_riNumTrees[1];
	m_riNumTrees[1] = (int)floorf(m_fNumTrees);
	m_rvFromLevelOfDetail[0] = m_rvFromLevelOfDetail[1];
	m_rvAtLevelOfDetail[0] = m_rvAtLevelOfDetail[1];
	m_rvFromLevelOfDetail[1] = m_vFrom;
	m_rvAtLevelOfDetail[1] = m_vAt;
	for (int iTree = 0; iTree < m_riNumTrees[1]; iTree++)
	{
		TreeData *pTree = &m_rTree[iTree];
		
		// save previous LOD factors
		pTree->rLOD[0] = pTree->rLOD[1];

		// compute distance squared
		D3DXVECTOR3 vEye = pTree->vPosition - m_vFrom;
		m_rrTreeSort[1][iTree].fDist2 = D3DXVec3LengthSq(&vEye);
		m_rrTreeSort[1][iTree].iTree = iTree;

		// compute level of detail based on squared distance
		pTree->rLOD[1].fLevelOfDetail = m_fLevelOfDetail * m_rrTreeSort[1][iTree].fDist2;
		D3DXVec3TransformCoord(&pTree->rLOD[1].vFrom, &m_vFrom, &pTree->matInv );

		// TODO: move all of this level-of-detail stuff down into CTree
		static float fTreeSliceLODMin = 6000.f;
		static float fTreeSliceLODScale = 1.f/100000.f;
		static float fBranchSliceLODMin = 1000.f;
		static float fBranchSliceLODScale = 1.f/30000.f;
		if (pTree->rLOD[1].fLevelOfDetail > fTreeSliceLODMin)
		{
			pTree->rLOD[1].dwDrawFlags = 0;						// draw the whole tree as slices
			pTree->rLOD[1].fTreeSliceTextureLOD = (pTree->rLOD[1].fLevelOfDetail - fTreeSliceLODMin) * fTreeSliceLODScale;
			pTree->bSameLevelOfDetail = (pTree->rLOD[0].dwDrawFlags == 0)
				&& ((DWORD)(pTree->rLOD[1].fTreeSliceTextureLOD) == (DWORD)(pTree->rLOD[1].fTreeSliceTextureLOD));
		}
		else if (pTree->rLOD[1].fLevelOfDetail > fBranchSliceLODMin)
		{
			pTree->rLOD[1].dwDrawFlags = TREE_DRAWTRUNK;	// draw the trunk as geometry and the branches as slice textures
			pTree->rLOD[1].fBranchSliceTextureLOD = (pTree->rLOD[1].fLevelOfDetail - fBranchSliceLODMin) * fBranchSliceLODScale;
			pTree->bSameLevelOfDetail = (pTree->rLOD[0].dwDrawFlags == TREE_DRAWTRUNK)
				&& ((DWORD)(pTree->rLOD[1].fBranchSliceTextureLOD) == (DWORD)(pTree->rLOD[1].fBranchSliceTextureLOD));
		}
		else
		{
			pTree->rLOD[1].dwDrawFlags = TREE_DRAWFULLGEOMETRY;		// if close enough, draw all the geometry of the tree
			pTree->bSameLevelOfDetail = (pTree->rLOD[0].dwDrawFlags == TREE_DRAWFULLGEOMETRY);
		}
	}
    qsort( (void *)m_rrTreeSort[1], m_riNumTrees[1], sizeof(TreeSort), &CompareDist2 );
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: CullTrees()
// Desc: cull trees based on current transformation matrices
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CullTrees()
{
	// get Blinn-style clipping matrix for bounding box culling
	D3DXMATRIX matViewProj = m_matView * m_matProjection;
	D3DXMATRIX matViewProjClip;
	BlinnClipMatrix(&matViewProjClip, &matViewProj);

	g_TREESTATS.dwActiveCount = 0;	// keep track of number of visible trees
	
	// cull trees
#if NTREELIBRARY == 1
	CTree *pTreeLibrary = &m_rTreeLibrary[0];
#endif
	int iLOD = m_riNumTrees[0] > m_riNumTrees[1] ? 0 : 1;
	for (int iTree = m_riNumTrees[iLOD] - 1; iTree >= 0; iTree--)
	{
		TreeData *pTree = &m_rTree[m_rrTreeSort[iLOD][iTree].iTree];
#if NTREELIBRARY > 1			
		CTree *pTreeLibrary = &m_rTreeLibrary[pTree->iTreeLibrary];
#endif
		// Cull tree if bounding box is outside of current frustum
		D3DXMATRIX matWorldViewProjClip = pTree->mat * matViewProjClip;
		pTree->bVisible = BoundingBoxInFrustum(matWorldViewProjClip, pTreeLibrary->m_vMin, pTreeLibrary->m_vMax);

		if (pTree->bVisible)
			g_TREESTATS.dwActiveCount++;

		// Transform current from vector
		D3DXVec3TransformCoord(&pTree->vFromFade, &m_vFrom, &pTree->matInv );
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: ShadowTrees()
// Desc: render trees onto ground plane
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::ShadowTrees()
{
	HRESULT	hr;
	LPDIRECT3DSURFACE8 pSurface = NULL;
	hr = m_pTextureTerrainShadow->GetSurfaceLevel( 0, &pSurface );
	if (FAILED(hr))
		return hr;
	hr = m_pd3dDevice->SetRenderTarget( pSurface, NULL );
	pSurface->Release();
	if (FAILED(hr))
		return hr;
	g_pd3dDevice->BeginScene();

	// start with all the transformations set to identity
	D3DXMATRIX matIdentity;
	D3DXMatrixIdentity(&matIdentity);
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matIdentity );
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &matIdentity );
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &matIdentity );

	// clear to white
    struct BACKGROUNDVERTEX { D3DXVECTOR3 p; };
    BACKGROUNDVERTEX v[4];
    v[0].p = D3DXVECTOR3(-1.f,  1.f, 0.5f);
    v[1].p = D3DXVECTOR3( 1.f,  1.f, 0.5f);
    v[2].p = D3DXVECTOR3(-1.f, -1.f, 0.5f);
    v[3].p = D3DXVECTOR3( 1.f, -1.f, 0.5f);
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
	m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
	m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ );
 	m_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, v, sizeof(BACKGROUNDVERTEX));	

	// draw shadows for each tree
	D3DXMATRIX matProj;
	D3DXMatrixIdentity(&matProj);
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
	D3DXVECTOR3 vSize = g_vMax - g_vMin;
	D3DXMATRIX matSize(      1.f/vSize.x,               0.f,               0.f, 0.f,
		                             0.f,               0.f,       1.f/vSize.y, 0.f,
					                 0.f,       1.f/vSize.z,               0.f, 0.f,
					   -g_vMin.x/vSize.x, -g_vMin.z/vSize.z, -g_vMin.y/vSize.y, 1.f);	// map to 0,1 range, swap Y and Z
	D3DXMATRIX mat2(  2.f,  0.f, 0.f, 0.f,
		              0.f, -2.f, 0.f, 0.f,
					  0.f,  0.f, 1.f, 0.f,
					 -1.f,  1.f, 0.f, 1.f);	// map X and -Y from 0,1 to -1,1 range, leave Z alone
	D3DXMATRIX matView = matSize * mat2;
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
	D3DXVECTOR3 vFrom(g_d3dLight.Direction.x, g_d3dLight.Direction.y, g_d3dLight.Direction.z);
	// This assumes we're mapping to a planar shadow receiver, and so works only 
	// when the terrain is not too hilly.
	D3DXMATRIX matShadow(1.f,  0.f,	 0.f, 0.f,
		                -vFrom.x/vFrom.y,  0.f, -vFrom.z/vFrom.y, 0.f,
						 0.f,  0.f,  1.f, 0.f,
						 0.f,  0.f,  0.f, 1.f);
	UINT iLOD = 1;
	DWORD dwCubeFadeFlags = 0;
	for (int iTree = m_riNumTrees[iLOD] - 1; iTree >= 0; iTree--)
	{
		TreeData *pTree = &m_rTree[m_rrTreeSort[iLOD][iTree].iTree];
		D3DXMATRIX mat = pTree->mat * matShadow;
		g_pd3dDevice->SetTransform( D3DTS_WORLD, &mat);
		CTree *pTreeLibrary = &m_rTreeLibrary[pTree->iTreeLibrary];
		pTreeLibrary->BeginDrawCubeSlices();
		pTreeLibrary->SetCubeFade(vFrom, dwCubeFadeFlags);
		static float fShadowFactor = 0.25f;
		for (UINT iDir = 0; iDir < pTreeLibrary->m_nDirection; iDir++)
		{
			pTreeLibrary->m_rfFade[iDir] *= fShadowFactor;		// adjust the fade value to make the shadow less dark
			pTreeLibrary->m_rSliceTexture[iDir].SetLevelOfDetail(0.f);
		}
		pTreeLibrary->DrawCubeSlices(vFrom);
		pTreeLibrary->EndDrawCubeSlices();
	}
	g_pd3dDevice->EndScene();
	return GenerateMipmaps(m_pTextureTerrainShadow, 0, D3DTADDRESS_CLAMP, D3DTADDRESS_CLAMP);
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//		 rendering. This function sets up render states, clears the
//		 viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	const float fZeroBlend = 0.5f/255.f;	// blend values below this quantize to zero
	
	// reset tree stats
	g_TREESTATS.dwFullGeometryCount = 0;
	g_TREESTATS.dwBranchSliceCount = 0;	
	g_TREESTATS.dwSliceCount = 0;	
	g_dwTotalSliceCount = 0;
	
	// To make smooth level-of-detail transitions, we draw the scene in
	// passes and then blend the results.  The schedule of blending is updated in
	// FrameMove and depends on whether the camera is moving or the rendering
	// load is getting too high.  The typical blending schedule is to make a
	// complete level-of-detail transition every second.  This lets all the
	// objects in the scene transition in a smooth way.
	
	// Each object in the scene has two LOD's associated with it, the current
	// and the LOD that is being transitioned to.  Once the new LOD is reached,
	// all the LOD targets are updated.
	
	// First pass: render sky, terrain, and non-LOD-changing non-transparent geometry,
	// then copy current result to temporary texture.
	// Second pass: Render previous LOD to backbuffer
	// Third pass: Render next LOD to temporary texture, then blend with backbuffer.
	for (UINT iPass = 0; iPass < 3; iPass++)
	{
		UINT iLOD = (iPass == 0) ? 0 : iPass - 1;
		if (iPass == 0 || iPass == 1)
			m_pd3dDevice->SetRenderTarget( m_pBackBuffer, m_pDepthBuffer );
		else
		{
			if (m_fBlendFactor < fZeroBlend)
				break;			// No need to render a whole image and then multiply by zero
			LPDIRECT3DSURFACE8 pBlendSurface = NULL;
			m_pBlendTexture->GetSurfaceLevel( 0, &pBlendSurface );
			m_pd3dDevice->SetRenderTarget( pBlendSurface, m_pBlendDepthBuffer );
			pBlendSurface->Release();
		}
		g_pd3dDevice->BeginScene();

		g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProjection );
		g_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
		g_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld);

		// If culling debug is turned on, render "from-the-side" to show the current projection frustum.
		bool bDebugCulling = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0;
		if (bDebugCulling)
		{
			extern HRESULT DebugSetFrustum();	// replaces current projection matrix with offset projection
			DebugSetFrustum();		// replaces current projection matrix with offset projection
		}
		g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
		if (iPass == 0)	// draw sky background
			RenderGradientBackground(D3DXCOLOR(0.3f, 0.3f, 0.4f, 1.f), D3DXCOLOR(0.45f, 0.45f, 0.9f, 1.f));
		g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
		g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
		g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );
		g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );

		if (g_bWireFrame)
			g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
		else
			g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);

		if (iPass == 0)
		{
			// draw the ground
			m_pTerrain->DrawTerrain();
		}

		// draw our trees from back to front
#if NTREELIBRARY == 1
		CTree *pTreeLibrary = &m_rTreeLibrary[0];
		pTreeLibrary->Begin(true);
#endif
		for (int iTree = m_riNumTrees[iLOD] - 1; iTree >= 0; iTree--)
		{
			TreeData *pTree = &m_rTree[m_rrTreeSort[iLOD][iTree].iTree];
			if (!pTree->bVisible)
				continue;

#if NTREELIBRARY > 1			
			CTree *pTreeLibrary = &m_rTreeLibrary[pTree->iTreeLibrary];
#endif
			bool bFullGeometryBothPasses = pTree->rLOD[0].dwDrawFlags == TREE_DRAWFULLGEOMETRY
					&& pTree->rLOD[1].dwDrawFlags == TREE_DRAWFULLGEOMETRY;
			if (iPass == 0)
			{
				// for the pass shared by both blend buffers, draw the
				// tree only if the most-detailed geometry-only
				// version is active for both LOD's
				if (!bFullGeometryBothPasses)
					continue;
			}
			else
			{
				// don't redraw the tree, if already drawn in pass 0
				if (bFullGeometryBothPasses)
					continue;
			}	
			
			g_pd3dDevice->SetTransform( D3DTS_WORLD, &pTree->mat );
#if NTREELIBRARY > 1			
			pTreeLibrary->Begin(true);
#endif
			// Draw the current level-of-detail representation of the tree
			// TODO: Move all the LOD stuff to the tree class
			if (pTree->rLOD[iLOD].dwDrawFlags == 0)
			{
				// set texture level-of-detail for whole tree
				for (UINT iDir = 0; iDir < pTreeLibrary->m_nDirection; iDir++)
					pTreeLibrary->m_rSliceTexture[iDir].SetLevelOfDetail(pTree->rLOD[iLOD].fTreeSliceTextureLOD);
				g_TREESTATS.dwSliceCount++;
			}
			else if (!(pTree->rLOD[iLOD].dwDrawFlags & TREE_DRAWBRANCHES))
			{
				// set texture level-of-detail for branches
				for (UINT iDir = 0; iDir < pTreeLibrary->m_TreeBranch.m_nDirection; iDir++)
					pTreeLibrary->m_TreeBranch.m_rSliceTexture[iDir].SetLevelOfDetail(pTree->rLOD[iLOD].fBranchSliceTextureLOD);
				g_TREESTATS.dwBranchSliceCount++;
			}
			else
				g_TREESTATS.dwFullGeometryCount++;
			pTreeLibrary->DrawLOD(pTree->vFromFade, pTree->rLOD[iLOD].vFrom, pTree->rLOD[iLOD].dwDrawFlags);
#if NTREELIBRARY > 1			
			pTreeLibrary->End();
#endif			
		}
#if NTREELIBRARY == 1
		pTreeLibrary->End();
#endif

		g_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );	// restore world transform
		g_pd3dDevice->EndScene();

		if (bDebugCulling)
		{
			extern HRESULT DebugDrawFrustum();
			DebugDrawFrustum();
		}

		if (iPass == 0 && m_fBlendFactor >= fZeroBlend)
		{
			// Copy backbuffer to temporary texture, and depth buffer to temporary depth buffer
			LPDIRECT3DSURFACE8 pBlendSurface = NULL;
			m_pBlendTexture->GetSurfaceLevel( 0, &pBlendSurface );
			m_pd3dDevice->CopyRects(m_pBackBuffer, NULL, 1, pBlendSurface, NULL);
			pBlendSurface->Release();
			m_pd3dDevice->CopyRects(m_pDepthBuffer, NULL, 1, m_pBlendDepthBuffer, NULL);
		}
		else if (iPass == 2)
		{
			// Add result to frame buffer, blending in smoothly according to the blend factor
			m_pd3dDevice->SetRenderTarget( m_pBackBuffer, NULL );
			D3DXCOLOR colorBlend(m_fBlendFactor, m_fBlendFactor, m_fBlendFactor, m_fBlendFactor);
			BlendScreenTexture(m_pBlendTexture, colorBlend);
		}
	}

	// show game title or help
	g_pd3dDevice->BeginScene();
	if( g_bDrawHelp )
		m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
	else
	{
		m_Font.Begin();
		m_Font.DrawText(64, 50, 0xffffffff, L"TREES");
#ifdef _DEBUG
		m_Font.DrawText(575, 50, 0xffffff00, m_strFrameRate, XBFONT_RIGHT);
#endif
		if (m_fNumTrees >= 1.f)
		{
			float x = 64.f, y = 200.f, dy = 30.f;	// text positioning
			const int buflen = 100;
			WCHAR buf[buflen];
			_snwprintf(buf, buflen, L"Tree count %d", (int)floorf(m_fNumTrees));
			buf[buflen - 1] = L'\0';
 			m_Font.DrawText(x, y += dy, 0xffffffff, buf);
			if (g_bDebugSlice)
			{
				if (g_bDebugSliceOpaque)
	 				m_Font.DrawText(64, 80, 0xffffffff, L"Debug opaque");
				else
	 				m_Font.DrawText(64, 80, 0xffffffff, L"Debug");

				_snwprintf(buf, buflen, L"Active trees %d", g_TREESTATS.dwActiveCount);
				buf[buflen - 1] = L'\0';
				m_Font.DrawText(x, y += dy, 0xffffffff, buf);

				_snwprintf(buf, buflen, L"Full geometry trees %d", g_TREESTATS.dwFullGeometryCount);
				buf[buflen - 1] = L'\0';
				m_Font.DrawText(x, y += dy, 0xffffffff, buf);

				_snwprintf(buf, buflen, L"Branch slice trees %d", g_TREESTATS.dwBranchSliceCount);
				buf[buflen - 1] = L'\0';
				m_Font.DrawText(x, y += dy, 0xffffffff, buf);

				_snwprintf(buf, buflen, L"Slice trees %d", g_TREESTATS.dwSliceCount);
				buf[buflen - 1] = L'\0';
				m_Font.DrawText(x, y += dy, 0xffffffff, buf);

				_snwprintf(buf, buflen, L"Total slices %d", g_dwTotalSliceCount);
				buf[buflen - 1] = L'\0';
				m_Font.DrawText(x, y += dy, 0xffffffff, buf);
			}
		}
		m_Font.End();
	}
	g_pd3dDevice->EndScene();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: BlendScreenTexture
// Desc: This function renders the level-of-detail blend texture to
//       the screen with a specified blending factor.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::BlendScreenTexture(LPDIRECT3DTEXTURE8 pTexture, D3DCOLOR colorBlend )
{
	// Texture coordinates in linear format textures go from 0 to n-1 rather
	// than the 0 to 1 that is used for swizzled textures.
	D3DSURFACE_DESC desc;
	pTexture->GetLevelDesc(0, &desc);
    struct BACKGROUNDVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; } v[4];
    v[0].p = D3DXVECTOR4( -0.5f,             -0.5f,              1.0f, 1.0f ); v[0].tu = 0.0f;              v[0].tv = 0.0f;
    v[1].p = D3DXVECTOR4( desc.Width - 0.5f, -0.5f,              1.0f, 1.0f ); v[1].tu = (float)desc.Width; v[1].tv = 0.0f;
    v[2].p = D3DXVECTOR4( -0.5f,             desc.Height - 0.5f, 1.0f, 1.0f ); v[2].tu = 0.0f;              v[2].tv = (float)desc.Height;
    v[3].p = D3DXVECTOR4( desc.Width - 0.5f, desc.Height - 0.5f, 1.0f, 1.0f ); v[3].tu = (float)desc.Width; v[3].tv = (float)desc.Height;
	
    // Set states
    g_pd3dDevice->SetPixelShader( 0 );
    g_pd3dDevice->SetTexture( 0, pTexture );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
	g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, colorBlend );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
	g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
	g_pd3dDevice->SetRenderState( D3DRS_ALPHAREF, 0 );
	g_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATER );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
	g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);

	// Render the screen-aligned quadrilateral
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADSTRIP, 1, v, sizeof(BACKGROUNDVERTEX) );

    // Reset render states
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    // Remove linear texture before setting address mode to Wrap
    g_pd3dDevice->SetTexture( 0, NULL );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TrueTypeFont\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TrueTypeFont\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut01_createdevice\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut02_vertices\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut03_matrices\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TrueTypeFont\TrueTypeFont.cpp ===
//-----------------------------------------------------------------------------
// File: TrueTypeFont.cpp
//
// Desc: Shows how to use the New XFONT extensions for TrueType Fonts on Xbox
//
// Hist: 11.16.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>

//-----------------------------------------------------------------------------
// XFONT_TRUETYPE must be defined before the include of xfont.h or the 
// XFONT_OpenTrueTypeFont function will not be defined.  This function is
// used to load the raw .ttf TrueType Font files and use them directly in the
// XFONT class on the fly.
//-----------------------------------------------------------------------------
#define XFONT_TRUETYPE
#include <xfont.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,  XBHELP_PLACEMENT_2, L"Change Font Style" },
};

#define NUM_HELP_CALLOUTS ( sizeof( g_HelpCallouts ) / sizeof( g_HelpCallouts[0] ) )




//-----------------------------------------------------------------------------
// defines for the FontDrawStyle
//-----------------------------------------------------------------------------
#define FONT_DRAW_STYLE_1       1
#define FONT_DRAW_STYLE_2       2
#define FONT_DRAW_STYLE_3       3
#define FONT_DRAW_STYLE_4       4
#define FONT_DRAW_STYLE_5       5
#define FONT_DRAW_STYLE_6       6
#define FONT_DRAW_STYLE_MAX     FONT_DRAW_STYLE_6




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    CXBFont     m_Font;             // Font object
    CXBHelp     m_Help;             // Help object
    BOOL        m_bDrawHelp;        // TRUE to draw help screen

    XFONT*      m_pDefaultTrueTypeFont;  // Pointer to the Default Arial TrueTypeFont
    XFONT*      m_pArialTrueTypeFont;    // Pointer to the Arial TrueTypeFont
    XFONT*      m_pArial16BitmapFont;    // Pointer to the Arial16Normal Bitmap font
                                         // Created with the MakeFont tool.
    XFONT*      m_pKanji16BitmapFont;    // Pointer to the Arial16Kanji Bitmap font
                                         // Created with the MakeFont tool.
    USHORT*     m_pKanjiMessage;         // Contains the first 20 Unicode Kanji Characters

    void*       m_pFontMemory;           // Memory to hold image of below font.
    XFONT*      m_pArial24BitmapFont;    // Pointer to the Arial24Italic Bitmap font
                                         // Created with the MakeFont tool.


    DWORD       m_dwFontDrawStyle;       // Which Font draw style are we showing.
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Size of the Font Cache in Bytes
    DWORD dwFontCacheSize = 16 * 1024;

    // Create the Default Arial TrueTypeFont
    if( FAILED( XFONT_OpenDefaultFont( &m_pDefaultTrueTypeFont ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the Arial TrueTypeFont
    if( FAILED( XFONT_OpenTrueTypeFont( L"D:\\media\\fonts\\arialuni.ttf",
                                        dwFontCacheSize,&m_pArialTrueTypeFont ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // If the FontCacheSize is as large as the bitmap font file or larger, the font
    // renders MUCH more quickly.  If its smaller then file size, the cache holds
    // the most recently drawn glyphs and recycles them as it needs to.  This can
    // be fast if you experiment with the size.
    dwFontCacheSize = 16*1024;

    // Create the Arial16Normal Bitmap Font
    if( FAILED( XFONT_OpenBitmapFont( L"D:\\media\\fonts\\Arial16Normal.bmf",
                                      dwFontCacheSize,&m_pArial16BitmapFont ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the Arial16Kanji Bitmap Font
    if( FAILED( XFONT_OpenBitmapFont( L"D:\\media\\fonts\\Arial16Kanji.bmf",
                                      dwFontCacheSize,&m_pKanji16BitmapFont ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    //Preload the Arial24Italic Bitmap Font
    HANDLE hFileHandle = CreateFile( "D:\\media\\fonts\\Arial24Italic.bmf",
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     0,
                                     OPEN_EXISTING,
                                     0,0);

    if( hFileHandle == INVALID_HANDLE_VALUE )
        return XBAPPERR_MEDIANOTFOUND;

    DWORD dwNumBytesRead = 0;
    DWORD dwFontMemorySize = GetFileSize( hFileHandle, 0 );

    m_pFontMemory = malloc( dwFontMemorySize );

    if( ReadFile( hFileHandle, m_pFontMemory, dwFontMemorySize, &dwNumBytesRead, 0 ) == 0 )
        return XBAPPERR_MEDIANOTFOUND;

    CloseHandle( hFileHandle );

    // Create the Arial24Italic Bitmap Font from the file loaded above.
    // The memory associated with this file must NOT be deleted until you no
    // longer wish to draw text with this font!
    if( FAILED( XFONT_OpenBitmapFontFromMemory( m_pFontMemory,
                                                dwFontMemorySize, &m_pArial24BitmapFont ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_dwFontDrawStyle = FONT_DRAW_STYLE_1;

    m_pKanjiMessage = new USHORT[21];
    for (USHORT i=0x4e00; i<0x4e14; i++)
        m_pKanjiMessage[i-0x4e00] = i;

    m_pKanjiMessage[20] = 0;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Toggle Font Draw Styles
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
    {
        ++m_dwFontDrawStyle;
        if( m_dwFontDrawStyle > FONT_DRAW_STYLE_MAX )
            m_dwFontDrawStyle = FONT_DRAW_STYLE_1;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    LPDIRECT3DSURFACE8 pFrontBuffer;
    m_pd3dDevice->GetBackBuffer(-1,D3DBACKBUFFER_TYPE_MONO,&pFrontBuffer);

    switch (m_dwFontDrawStyle)
    {
        case FONT_DRAW_STYLE_1:
        {
            // NOTE:  Cannot set the Font Style, Height and Anti-alias if font is the default font.

            // Draw a message in the defined TrueType Font.
			m_pDefaultTrueTypeFont->TextOut( pFrontBuffer, 
                                           L"This is the Default Arial 24 Pixel Font", -1, 60, 100 );
        }
        break;

        case FONT_DRAW_STYLE_2:
        {
			// Changing the Font Size, Style and Anti-Alias on the fly
			// like this is VERY slow.

            // Change Font Size - In Pixels
			m_pArialTrueTypeFont->SetTextHeight( 20 );

            // Change Font Style - XFONT_NORMAL, XFONT_BOLD, 
			//                     XFONT_ITALICS, XFONT_BOLDITALICS
			m_pArialTrueTypeFont->SetTextStyle( XFONT_NORMAL );

            // Anti-Alias the font -- 0 for no anti-alias, 2 for some, 4 for MAX!
			m_pArialTrueTypeFont->SetTextAntialiasLevel( 0 );

            // Draw a message in the defined TrueType Font.
			m_pArialTrueTypeFont->TextOut( pFrontBuffer, 
                                            L"This is Arial True Type 20 Pixel Normal", -1, 60, 100 );
        }
        break;

        case FONT_DRAW_STYLE_3:
        {
			// Changing the Font Size, Style and Anti-Alias on the fly
			// like this is VERY slow.

            // Change Font Size - In Pixels
			m_pArialTrueTypeFont->SetTextHeight( 18 );

            // Change Font Style - XFONT_NORMAL, XFONT_BOLD, 
			//                     XFONT_ITALICS, XFONT_BOLDITALICS
			m_pArialTrueTypeFont->SetTextStyle( XFONT_BOLDITALICS );

            // Anti-Alias the font -- 0 for no anti-alias, 2 for some, 4 for MAX!
			m_pArialTrueTypeFont->SetTextAntialiasLevel( 0 );

            // Draw a message in the defined TrueType Font.
			m_pArialTrueTypeFont->TextOut( pFrontBuffer, 
                                            L"This is Arial TrueType 18 pixel Bold Italic", 
                                            -1, 60, 120 );
        }
        break;

        case FONT_DRAW_STYLE_4:
        {
            // NOTE:  Cannot set the Font Parameters if font is from Bitmap file.
            // These are set when the font is created using the MakeFont tool.

            // Draw a message in the defined TrueType Font.
            m_pArial16BitmapFont->TextOut( pFrontBuffer, 
                                           L"This is Arial Bitmap in 16 Pixel Normal", 
                                           -1, 60, 100 );
        }
        break;
    
        case FONT_DRAW_STYLE_5:
        {
            // NOTE:  Cannot set the Font Parameters if font is from Bitmap file.
            // These are set when the font is created using the MakeFont tool.
    
            // Draw a message in the defined TrueType Font.
            m_pArial24BitmapFont->TextOut( pFrontBuffer, 
                                           L"This is Arial Bitmap 24 pixel Italic", 
                                           -1, 60, 120 );
        }
        break;

        case FONT_DRAW_STYLE_6:
        {
            // NOTE:  Cannot set the Font Parameters if font is from Bitmap file.
            // These are set when the font is created using the MakeFont tool.
    
            // Draw a message in the defined TrueType Font.
            m_pArial16BitmapFont->TextOut( pFrontBuffer, 
                                           L"The first 20 characters in Kanji Bitmap 16 pixel", 
                                           -1, 60, 120 );

            m_pKanji16BitmapFont->TextOut( pFrontBuffer,
                                           m_pKanjiMessage, -1, 60, 140 );
        }
        break;
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"TrueTypeFont" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    pFrontBuffer->Release();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut02_vertices\vertices.cpp ===
//-----------------------------------------------------------------------------
// File: Vertices.cpp
//
// Desc: In this tutorial, we are rendering some vertices. This introduces the
//       concept of the vertex buffer, a Direct3D object used to store
//       vertices. Vertices can be defined any way we want by defining a
//       custom structure and a custom FVF (flexible vertex format). In this
//       tutorial, we are using vertices that are transformed (meaning they
//       are already in 2D viewport coordinates) and lit (meaning we are not
//       using Direct3D lighting, but are supplying our own colors).
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>




//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
LPDIRECT3D8             g_pD3D       = NULL; // Used to create the D3DDevice
LPDIRECT3DDEVICE8       g_pd3dDevice = NULL; // Our rendering device
LPDIRECT3DVERTEXBUFFER8 g_pVB        = NULL; // Buffer to hold vertices

// A structure for our custom vertex type
struct CUSTOMVERTEX
{
    FLOAT x, y, z, rhw; // The transformed position for the vertex
    DWORD color;        // The vertex color
};

// Our custom FVF, which describes our custom vertex structure
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)




//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
HRESULT InitD3D()
{
    // Create the D3D object.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp; 
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.BackBufferWidth        = 640;
    d3dpp.BackBufferHeight       = 480;
    d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // After creating the device, initial state would normally be set here.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitVB()
// Desc: Creates a vertex buffer and fills it with our vertices. The vertex
//       buffer is basically just a chuck of memory that holds vertices. After
//       creating it, we must Lock()/Unlock() it to fill it. For indices, D3D
//       also uses index buffers. The special thing about vertex and index
//       buffers is that the ycan be created in device memory, allowing some
//       cards to process them in hardware, resulting in a dramatic
//       performance gain.
//-----------------------------------------------------------------------------
HRESULT InitVB()
{
    // Initialize three vertices for rendering a triangle
    CUSTOMVERTEX g_Vertices[] =
    {
        { 320.0f, 150.0f, 0.5f, 1.0f, 0xffff0000, }, // x, y, z, rhw, color
        { 420.0f, 330.0f, 0.5f, 1.0f, 0xff00ff00, },
        { 220.0f, 330.0f, 0.5f, 1.0f, 0xff00ffff, },
    };

    // Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( 3*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY, 
                                                  D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &g_pVB ) ) )
        return E_FAIL;

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
    CUSTOMVERTEX* pVertices;
    if( FAILED( g_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
        return E_FAIL;
    memcpy( pVertices, g_Vertices, 3*sizeof(CUSTOMVERTEX) );
    g_pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID Render()
{
    // Clear the backbuffer to a blue color
    g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         D3DCOLOR_XRGB(0,0,255), 1.0f, 0L );

    // Draw the triangles in the vertex buffer. This is broken into a few
    // steps. We are passing the vertices down a "stream", so first we need
    // to specify the source of that stream, which is our vertex buffer. Then
    // we need to let D3D know what vertex shader to use. Full, custom vertex
    // shaders are an advanced topic, but in many cases the vertex shader is
    // just the FVF, so that D3D knows what type of vertices we are dealing
    // with. Finally, we call DrawPrimitive() which does the actual rendering
    // of our geometry (in this case, just one triangle).
    g_pd3dDevice->SetStreamSource( 0, g_pVB, sizeof(CUSTOMVERTEX) );
    g_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, 1 );
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
void __cdecl main()
{
    // Initialize Direct3D
    if( FAILED( InitD3D() ) )
        return;

    // Initialize the vertex buffer
    InitVB();

    while( TRUE )
    {
        // Render the scene
        Render();

        // Present the backbuffer contents to the display
        g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut01_createdevice\createdevice.cpp ===
//-----------------------------------------------------------------------------
// File: CreateDevice.cpp
//
// Desc: This is the first tutorial for using Direct3D. In this tutorial, all
//       we are doing is creating a Direct3D device and using it to clear the
//       window.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>




//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
LPDIRECT3D8             g_pD3D       = NULL; // Used to create the D3DDevice
LPDIRECT3DDEVICE8       g_pd3dDevice = NULL; // Our rendering device




//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
HRESULT InitD3D()
{
    // Create the D3D object, which is used to create the D3DDevice.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp; 
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    
    // Set fullscreen 640x480x32 mode
    d3dpp.BackBufferWidth        = 640;
    d3dpp.BackBufferHeight       = 480;
    d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;

    // Create one backbuffer and a zbuffer
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;

    // Set up how the backbuffer is "presented" to the frontbuffer each frame
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device. Hardware vertex processing is specified 
    // since all vertex processing takes place on Xbox hardware.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // After creating the device, initial state would normally be set

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID Render()
{
    // Cycle through some colors to clear the screen (just to show some output)
    static FLOAT r = 0.0f; if( (r+=1.3f) > 255.0f ) r = 0.0f;
    static FLOAT g = 0.0f; if( (g+=1.7f) > 255.0f ) g = 0.0f;
    static FLOAT b = 0.0f; if( (b+=1.5f) > 255.0f ) b = 0.0f;

    // Clear the backbuffer to a changing color
    g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         D3DCOLOR_XRGB( (int)r, (int)g, (int)b ), 1.0f, 0L );
    
    // Rendering of scene objects happens here
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
void __cdecl main()
{
    // Initialize Direct3D
    if( FAILED( InitD3D() ) )
        return;

    while( TRUE )
    {
        // Render the scene
        Render();

        // Present the backbuffer contents to the display
        g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut03_matrices\matrices.cpp ===
//-----------------------------------------------------------------------------
// File: Matrices.cpp
//
// Desc: Now that we know how to create a device and render some 2D vertices,
//       this tutorial goes the next step and renders 3D geometry. To deal with
//       3D geometry we need to introduce the use of 4x4 matrices to transform
//       the geometry with translations, rotations, scaling, and setting up our
//       camera.
//
//       Geometry is defined in model space. We can move it (translation),
//       rotate it (rotation), or stretch it (scaling) using a world transform.
//       The geometry is then said to be in world space. Next, we need to
//       position the camera, or eye point, somewhere to look at the geometry.
//       Another transform, via the view matrix, is used, to position and
//       rotate our view. With the geometry then in view space, our last
//       transform is the projection transform, which "projects" the 3D scene
//       into our 2D viewport.
//
//       Note that in this tutorial, we are introducing the use of D3DX, which
//       is a set up helper utilities for D3D. In this case, we are using some
//       of D3DX's useful matrix initialization functions.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>




//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
LPDIRECT3D8             g_pD3D       = NULL; // Used to create the D3DDevice
LPDIRECT3DDEVICE8       g_pd3dDevice = NULL; // Our rendering device
LPDIRECT3DVERTEXBUFFER8 g_pVB        = NULL; // Buffer to hold vertices

// A structure for our custom vertex type
struct CUSTOMVERTEX
{
    FLOAT x, y, z;      // The untransformed, 3D position for the vertex
    DWORD color;        // The vertex color
};

// Our custom FVF, which describes our custom vertex structure
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)




//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
HRESULT InitD3D()
{
    // Create the D3D object.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp; 
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.BackBufferWidth        = 640;
    d3dpp.BackBufferHeight       = 480;
    d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // Turn off culling, so we see the front and back of the triangle
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    // Turn off D3D lighting, since we are providing our own vertex colors
    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitGeometry()
// Desc: Creates the scene geometry
//-----------------------------------------------------------------------------
HRESULT InitGeometry()
{
    // Initialize three vertices for rendering a triangle
    CUSTOMVERTEX g_Vertices[] =
    {
        { -1.0f,-1.0f, 0.0f, 0xffff0000, }, // x, y, z, color
        {  1.0f,-1.0f, 0.0f, 0xff0000ff, },
        {  0.0f, 1.0f, 0.0f, 0xffffffff, },
    };

    // Create the vertex buffer.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( 3*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &g_pVB ) ) )
        return E_FAIL;

    // Fill the vertex buffer.
    CUSTOMVERTEX* pVertices;
    if( FAILED( g_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
        return E_FAIL;
    memcpy( pVertices, g_Vertices, 3*sizeof(CUSTOMVERTEX) );
    g_pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetupMatrices()
// Desc: Sets up the world, view, and projection transform matrices.
//-----------------------------------------------------------------------------
VOID SetupMatrices()
{
    // For our world matrix, we will just rotate the object about the y-axis.
    D3DXMATRIX matWorld;
    D3DXMatrixRotationY( &matWorld, timeGetTime()/150.0f );
    g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set up our view matrix. A view matrix can be defined given an eye point,
    // a point to lookat, and a direction for which way is up. Here, we set the
    // eye five units back along the z-axis and up three units, look at the
    // origin, and define "up" to be in the y-direction.
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 3.0f,-5.0f ),
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ),
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // For the projection matrix, we set up a perspective transform (which
    // transforms geometry from 3D view space to 2D viewport space, with
    // a perspective divide making objects smaller in the distance). To build
    // a perpsective transform, we need the field of view (1/4 pi is common),
    // the aspect ratio, and the near and far clipping planes (which define at
    // what distances geometry should be no longer be rendered).
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f );
    g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
}



//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID Render()
{
    // Clear the backbuffer to a black color
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         D3DCOLOR_XRGB(0,0,0), 1.0f, 0 );

    // Setup the world, view, and projection matrices
    SetupMatrices();

    // Render the vertex buffer contents
    g_pd3dDevice->SetStreamSource( 0, g_pVB, sizeof(CUSTOMVERTEX) );
    g_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 1 );
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
void __cdecl main()
{
    // Initialize Direct3D
    if( FAILED( InitD3D() ) )
        return;

    // Initialize the vertex buffer
    InitGeometry();

    while( TRUE )
    {
        // Render the scene
        Render();

        // Present the backbuffer contents to the display
        g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut04_lights\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut05_textures\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut06_meshes\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut04_lights\lights.cpp ===
//-----------------------------------------------------------------------------
// File: Lights.cpp
//
// Desc: Rendering 3D geometry is much more interesting when dynamic lighting
//       is added to the scene. To use lighting in D3D, you must create one or
//       lights, setup a material, and make sure your geometry contains surface
//       normals. Lights may have a position, a color, and be of a certain type
//       such as directional (light comes from one direction), point (light
//       comes from a specific x,y,z coordinate and radiates in all directions)
//       or spotlight. Materials describe the surface of your geometry,
//       specifically, how it gets lit (diffuse color, ambient color, etc.).
//       Surface normals are part of a vertex, and are needed for the D3D's
//       internal lighting calculations.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>




//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
LPDIRECT3D8             g_pD3D       = NULL; // Used to create the D3DDevice
LPDIRECT3DDEVICE8       g_pd3dDevice = NULL; // Our rendering device
LPDIRECT3DVERTEXBUFFER8 g_pVB        = NULL; // Buffer to hold vertices

// A structure for our custom vertex type. We added a normal, and omitted the
// color (which is provided by the material)
struct CUSTOMVERTEX
{
    D3DXVECTOR3 position; // The 3D position for the vertex
    D3DXVECTOR3 normal;   // The surface normal for the vertex
};

// Our custom FVF, which describes our custom vertex structure
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL)




//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
HRESULT InitD3D()
{
    // Create the D3D object.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp; 
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.BackBufferWidth        = 640;
    d3dpp.BackBufferHeight       = 480;
    d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // Turn off culling
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    // Turn on the zbuffer
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitGeometry()
// Desc: Creates the scene geometry
//-----------------------------------------------------------------------------
HRESULT InitGeometry()
{
    // Create the vertex buffer.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( 50*2*sizeof(CUSTOMVERTEX),
                                                  0, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, &g_pVB ) ) )
        return E_FAIL;

    // Fill the vertex buffer. We are algorithmically generating a cylinder
    // here, including the normals, which are used for lighting.
    CUSTOMVERTEX* pVertices;
    if( FAILED( g_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
        return E_FAIL;
    for( DWORD i=0; i<50; i++ )
    {
        FLOAT theta = (2*D3DX_PI*i)/(50-1);
        pVertices[2*i+0].position = D3DXVECTOR3( sinf(theta),-1.0f, cosf(theta) );
        pVertices[2*i+0].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
        pVertices[2*i+1].position = D3DXVECTOR3( sinf(theta), 1.0f, cosf(theta) );
        pVertices[2*i+1].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
    }
    g_pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetupMatrices()
// Desc: Sets up the world, view, and projection transform matrices.
//-----------------------------------------------------------------------------
VOID SetupMatrices()
{
    // For our world matrix, we will just leave it as the identity
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixRotationX( &matWorld, timeGetTime()/500.0f );
    g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set up our view matrix. A view matrix can be defined given an eye point,
    // a point to lookat, and a direction for which way is up. Here, we set the
    // eye five units back along the z-axis and up three units, look at the
    // origin, and define "up" to be in the y-direction.
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 3.0f,-5.0f ),
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ),
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // For the projection matrix, we set up a perspective transform (which
    // transforms geometry from 3D view space to 2D viewport space, with
    // a perspective divide making objects smaller in the distance). To build
    // a perpsective transform, we need the field of view (1/4 pi is common),
    // the aspect ratio, and the near and far clipping planes (which define at
    // what distances geometry should be no longer be rendered).
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f );
    g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
}




//-----------------------------------------------------------------------------
// Name: SetupLights()
// Desc: Sets up the lights and materials for the scene.
//-----------------------------------------------------------------------------
VOID SetupLights()
{
    // Set up a material. The material here just has the diffuse and ambient
    // colors set to yellow. Note that only one material can be used at a time.
    D3DMATERIAL8 mtrl;
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = 1.0f;
    mtrl.Diffuse.g = mtrl.Ambient.g = 1.0f;
    mtrl.Diffuse.b = mtrl.Ambient.b = 0.0f;
    mtrl.Diffuse.a = mtrl.Ambient.a = 1.0f;
    g_pd3dDevice->SetMaterial( &mtrl );

    // Set up a white, directional light, with an oscillating direction.
    // Note that many lights may be active at a time (but each one slows down
    // the rendering of our scene). However, here we are just using one.

    // Direction vector for the light
    FLOAT       fAngle = 3.0f * timeGetTime()*0.001f;
    D3DXVECTOR3 vDirection( cosf(fAngle), 0.1f, sinf(fAngle) );
    D3DXVec3Normalize( &vDirection, &vDirection );

    // The light structure
    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type       = D3DLIGHT_DIRECTIONAL;
    light.Diffuse.r  = 1.0f;
    light.Diffuse.g  = 1.0f;
    light.Diffuse.b  = 1.0f;
    light.Direction  = vDirection;
    light.Range      = 1000.0f;
    g_pd3dDevice->SetLight( 0, &light );
    g_pd3dDevice->LightEnable( 0, TRUE );
    
    // When using lights, we must turn lighting on
    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );

    // Finally, turn on some ambient light.
    g_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x00202020 );
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID Render()
{
    // Clear the backbuffer and the zbuffer
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         D3DCOLOR_XRGB(0,0,255), 1.0f, 0 );

    // Setup the lights and materials
    SetupLights();

    // Setup the world, view, and projection matrices
    SetupMatrices();

    // Render the vertex buffer contents
    g_pd3dDevice->SetStreamSource( 0, g_pVB, sizeof(CUSTOMVERTEX) );
    g_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2*50-2 );

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
void __cdecl main()
{
    // Initialize Direct3D
    if( FAILED( InitD3D() ) )
        return;

    // Create the geometry
    if( FAILED( InitGeometry() ) )
        return;

    // Enter the render loop
    while( TRUE )
    {
        Render();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut05_textures\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Banana_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut05_textures\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Banana_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut05_textures\textures.cpp ===
//-----------------------------------------------------------------------------
// File: Textures.cpp
//
// Desc: Better than just lights and materials, 3D objects look much more
//       convincing when texture-mapped. Textures can be thought of as a sort
//       of wallpaper, that is shrinkwrapped to fit a texture. Textures are
//       typically loaded from image files, and D3DX provides a utility
//       function to do this for us. Like a vertex buffer, textures have
//       Lock() and Unlock() functions to access (read or write) the image
//       data. Textures have a width, height, miplevel, and pixel format. The
//       miplevel is for "mipmapped" textures, an advanced performance-
//       enhancing feature which uses lower resolutions of the texture for
//       objects in the distance where detail is less noticeable. The pixel
//       format determines how the colors are stored in a texel. The most
//       common formats are the 16-bit R5G6B5 format (5 bits of red, 6-bits of
//       green and 5 bits of blue) and the 32-bit A8R8G8B8 format (8 bits each
//       of alpha, red, green, and blue).
//
//       Textures are associated with geometry through texture coordinates.
//       Each vertex has one or more sets of texture coordinates, which are
//       named tu and tv and range from 0.0 to 1.0. Texture coordinates can be
//       supplied by the geometry, or can be automatically generated using
//       Direct3D texture coordinate generation (which is an advanced feature).
//
//       Textures start out as image files (.bmp, .tga, etc.) on the
//       development machine. For space and performance, it doesn't make sense
//       for the Xbox to load these image files, but rather load textures (and
//       other resources) in a native format. Therefore, these image files are
//       processed by the Bundler tool, which takes one or more resources and
//       packs them into a format that is fast and easy for the Xbox to load.
//       The resources (textures, in this case) to be bundled are referenced
//       in the resource.rdf file, and then they get bundled into the binary 
//       resource.xpr file that is loaded by this tutorial. See the bundler
//       tool for more information on it's usage.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "Resource.h"



// Use this define to show texture-coordinate generation
//#define SHOW_HOW_TO_USE_TCI




//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
LPDIRECT3D8             g_pD3D       = NULL;          // Used to create the D3DDevice
LPDIRECT3DDEVICE8       g_pd3dDevice = NULL;          // Our rendering device
LPDIRECT3DVERTEXBUFFER8 g_pVB        = NULL;          // Buffer to hold vertices
BYTE*                   g_pResourceSysMemData = NULL; // Sysmem data for the packed resource
BYTE*                   g_pResourceVidMemData = NULL; // Vidmem data for the packed resource
LPDIRECT3DTEXTURE8      g_pTexture            = NULL; // Our texture


// A structure for our custom vertex type. We added texture coordinates
struct CUSTOMVERTEX
{
    D3DXVECTOR3 position; // The position
    D3DCOLOR    color;    // The color
    FLOAT       tu, tv;   // The texture coordinates
};

// Our custom FVF, which describes our custom vertex structure
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
HRESULT InitD3D()
{
    // Create the D3D object.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp; 
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.BackBufferWidth        = 640;
    d3dpp.BackBufferHeight       = 480;
    d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // Turn off culling
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    // Turn off D3D lighting
    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    // Turn on the zbuffer
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadPackedResource()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT LoadPackedResource()
{
    // Open the fileto read the XPR headers
	FILE* file = fopen( "D:\\media\\Resource.xpr", "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    if(fread( &xprh, sizeof(XPR_HEADER), 1, file) != 1)
	{
		fclose(file);
		return E_FAIL;
	}

    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugStringA( "ERROR: Invalid Xbox Packed Resource (.xpr) file" );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    g_pResourceSysMemData = new BYTE[dwSysMemDataSize];
    g_pResourceVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
	if(fread( g_pResourceSysMemData, dwSysMemDataSize, 1, file ) != 1 ||
	   fread( g_pResourceVidMemData, dwVidMemDataSize, 1, file ) != 1 )
		
	{
		delete [] g_pResourceSysMemData;
		D3D_FreeContiguousMemory(g_pResourceVidMemData);
		fclose(file);
		return E_FAIL;
	}

    // Done with the file
    fclose( file );
    
    // Loop over resources, calling Register()
    BYTE* pData = g_pResourceSysMemData;

    for( DWORD i = 0; i < resource_NUM_RESOURCES; i++ )
    {
        // Get the resource
        LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;

        // Register the resource
        pResource->Register( g_pResourceVidMemData );
    
        // Advance the pointer
        switch( pResource->GetType() )
        {
            case D3DRTYPE_TEXTURE:       pData += sizeof(D3DTexture);       break;
            case D3DRTYPE_VOLUMETEXTURE: pData += sizeof(D3DVolumeTexture); break;
            case D3DRTYPE_CUBETEXTURE:   pData += sizeof(D3DCubeTexture);   break;
            case D3DRTYPE_VERTEXBUFFER:  pData += sizeof(D3DVertexBuffer);  break;
            case D3DRTYPE_INDEXBUFFER:   pData += sizeof(D3DIndexBuffer);   break;
            case D3DRTYPE_PALETTE:       pData += sizeof(D3DPalette);       break;
            default:                     return E_FAIL;
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitGeometry()
// Desc: Create the textures and vertex buffers
//-----------------------------------------------------------------------------
HRESULT InitGeometry()
{
    // Load the packed resource
    if( FAILED( LoadPackedResource() ) )
        return E_FAIL;

    // Get access to the texture
    g_pTexture = (LPDIRECT3DTEXTURE8)&g_pResourceSysMemData[ resource_Banana_OFFSET ];

    // Create the vertex buffer.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( 50*2*sizeof(CUSTOMVERTEX),
                                                  0, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, &g_pVB ) ) )
    {
        OutputDebugStringA( "ERROR: Could not create vertex buffer\n" );
        return E_FAIL;
    }

    // Fill the vertex buffer. We are setting the tu and tv texture
    // coordinates, which range from 0.0 to 1.0
    CUSTOMVERTEX* pVertices;
    if( FAILED( g_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
        return E_FAIL;
    for( DWORD i=0; i<50; i++ )
    {
        FLOAT theta = (2*D3DX_PI*i)/(50-1);

        pVertices[2*i+0].position = D3DXVECTOR3( sinf(theta),-1.0f, cosf(theta) );
        pVertices[2*i+0].color    = 0xffffffff;
        pVertices[2*i+0].tu       = ((FLOAT)(50-i))/(50-1);
        pVertices[2*i+0].tv       = 1.0f;

        pVertices[2*i+1].position = D3DXVECTOR3( sinf(theta), 1.0f, cosf(theta) );
        pVertices[2*i+1].color    = 0xff808080;
        pVertices[2*i+1].tu       = ((FLOAT)(50-i))/(50-1);
        pVertices[2*i+1].tv       = 0.0f;
    }
    g_pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetupMatrices()
// Desc: Sets up the world, view, and projection transform matrices.
//-----------------------------------------------------------------------------
VOID SetupMatrices()
{
    // For our world matrix, we will just leave it as the identity
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixRotationX( &matWorld, timeGetTime()/1000.0f );
    g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set up our view matrix. A view matrix can be defined given an eye point,
    // a point to lookat, and a direction for which way is up. Here, we set the
    // eye five units back along the z-axis and up three units, look at the
    // origin, and define "up" to be in the y-direction.
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 3.0f,-5.0f ),
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ),
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // For the projection matrix, we set up a perspective transform (which
    // transforms geometry from 3D view space to 2D viewport space, with
    // a perspective divide making objects smaller in the distance). To build
    // a perpsective transform, we need the field of view (1/4 pi is common),
    // the aspect ratio, and the near and far clipping planes (which define at
    // what distances geometry should be no longer be rendered).
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f );
    g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID Render()
{
    // Clear the backbuffer and the zbuffer
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         D3DCOLOR_XRGB(0,0,255), 1.0f, 0 );

    // Setup the world, view, and projection matrices
    SetupMatrices();

    // Setup our texture. Using textures introduces the texture stage states,
    // which govern how textures get blended together (in the case of multiple
    // textures) and lighting information. In this case, we are modulating
    // (blending) our texture with the diffuse color of the vertices.
    g_pd3dDevice->SetTexture( 0, g_pTexture );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

#ifdef SHOW_HOW_TO_USE_TCI
    // Note: to use D3D texture coordinate generation, use the stage state
    // D3DTSS_TEXCOORDINDEX, as shown below. In this example, we are using
    // the position of the vertex in camera space to generate texture
    // coordinates. The tex coord index (TCI) parameters are passed into a
    // texture transform, which is a 4x4 matrix which transforms the x,y,z
    // TCI coordinates into tu, tv texture coordinates.

    // In this example, the texture matrix is setup to 
    // transform the texture from (-1,+1) position coordinates to (0,1) 
    // texture coordinate space:
    //    tu =  0.5*x + 0.5
    //    tv = -0.5*y + 0.5
    D3DXMATRIX mat;
    mat._11 = 0.25f; mat._12 = 0.00f;
    mat._21 = 0.00f; mat._22 =-0.25f;
    mat._31 = 0.00f; mat._32 = 0.00f;
    mat._41 = 0.50f; mat._42 = 0.50f;

    g_pd3dDevice->SetTransform( D3DTS_TEXTURE0, &mat );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION );
#endif

    // Render the vertex buffer contents
    g_pd3dDevice->SetStreamSource( 0, g_pVB, sizeof(CUSTOMVERTEX) );
    g_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2*50-2 );

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
void __cdecl main()
{
    // Initialize Direct3D
    if( FAILED( InitD3D() ) )
        return;

    // Create the scene geometry
    if( FAILED( InitGeometry() ) )
        return;

    // Enter render loop
    while( TRUE )
    {
        Render();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut07_vertexshaders\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut06_meshes\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Tiger_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TwoSidedLighting\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TwoSidedLighting\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut06_meshes\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Tiger_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TwoSidedLighting\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut06_meshes\meshes.cpp ===
//-----------------------------------------------------------------------------
// File: Meshes.cpp
//
// Desc: For advanced geometry, most apps will prefer to load pre-authored
//       meshes from a file. An ideal file format would have geometry that are
//       really just binary dumps of pre-built index- and vertex-buffers, so
//       that costly load time file processing can be avoided. Samples on the
//       Xbox XDK use a custom formats called .XBG (for "Xbox geometry"). The
//       geometry files start out as .X files, then are processed by the 
//       MakeXBG tool, where they can be stripified and have their FVF code
//       modified. In the .xbg file format, textures are referenced by ASCII
//       name, so they can be loaded by a texture manager (which would be based
//       on "bundled" resources. See the Textures tutorial for more info.). The
//       .XBG format also contains embedded structures for info on the
//       rendering subsets, and also support for heirachial transformations.
//
//       A real Xbox game will likely use a custom format, but should still have
//       a number of similiarities to the .XBG format...most notably that any
//       file format will likely boil down to a set up simple structures that
//       wrap binary dumps of pre-built index- and vertex-buffer resources.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "Resource.h"




//-----------------------------------------------------------------------------
// Name: struct XBMESH_SUBSET
// Desc: Struct to hold data for rendering a mesh
//-----------------------------------------------------------------------------
struct XBMESH_SUBSET
{
    D3DMATERIAL8       mtrl;            // Material for this subset
    LPDIRECT3DTEXTURE8 pTexture;        // Texture
    CHAR               strTexture[64];
    DWORD              dwVertexStart;   // Range of vertices to render
    DWORD              dwVertexCount;
    DWORD              dwIndexStart;    // Range of vertex indices to render
    DWORD              dwIndexCount;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESH_DATA
// Desc: Struct for mesh data
//-----------------------------------------------------------------------------
struct XBMESH_DATA
{
    D3DVertexBuffer   m_VB;            // Mesh geometry
    DWORD             m_dwNumVertices;
    D3DIndexBuffer    m_IB;
    DWORD             m_dwNumIndices;
    
    DWORD             m_dwFVF;         // Mesh vertex info
    DWORD             m_dwVertexSize;
    D3DPRIMITIVETYPE  m_dwPrimType;

    DWORD             m_dwNumSubsets;  // Subset info for rendering calls
    XBMESH_SUBSET*    m_pSubsets;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESHFRAME
// Desc: Struct for building a hierarchy of meshes.
//-----------------------------------------------------------------------------
__declspec(align(16)) struct XBMESH_FRAME
{
    D3DXMATRIX        m_matTransform; // The transformation matrix for this frame
    
    XBMESH_DATA       m_MeshData;     // The mesh data belonging to this frame

    CHAR              m_strName[64];
    
    XBMESH_FRAME*     m_pChild;       // Child and sibling ptrs for the hierarchy
    XBMESH_FRAME*     m_pNext;
};




//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
LPDIRECT3D8             g_pD3D                = NULL; // Used to create the D3DDevice
LPDIRECT3DDEVICE8       g_pd3dDevice          = NULL; // Our rendering device

BYTE*                   g_pResourceSysMemData = NULL; // Sysmem data for the packed resource
BYTE*                   g_pResourceVidMemData = NULL; // Vidmem data for the packed resource

VOID*                   g_pMeshSysMemData     = NULL; // Sysmem data for the mesh
VOID*                   g_pMeshVidMemData     = NULL; // Vidmem data for the mesh
XBMESH_FRAME*           g_pMeshFrames         = NULL; // Num of hierarchial frames in the mesh
DWORD                   g_dwNumMeshFrames     = 0L;   // Heirarchy of frames for the mesh




//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
HRESULT InitD3D()
{
    // Create the D3D object.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp; 
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.BackBufferWidth        = 640;
    d3dpp.BackBufferHeight       = 480;
    d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // Turn on the zbuffer
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );

    // Turn on ambient lighting 
    g_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0xffffffff );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadPackedResource()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT LoadPackedResource( const CHAR* strResourceFilename )
{
    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourceFilename, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    if(fread( &xprh, sizeof(XPR_HEADER), 1, file) != 1)
	{
		fclose(file);
		return E_FAIL;
	}

    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugStringA( "ERROR: Invalid Xbox Packed Resource (.xpr) file" );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    g_pResourceSysMemData = new BYTE[dwSysMemDataSize];
    g_pResourceVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
	if(fread( g_pResourceSysMemData, dwSysMemDataSize, 1, file ) != 1 ||
	   fread( g_pResourceVidMemData, dwVidMemDataSize, 1, file ) != 1 )
		
	{
		delete [] g_pResourceSysMemData;
		D3D_FreeContiguousMemory(g_pResourceVidMemData);
		fclose(file);
		return E_FAIL;
	}

    // Done with the file
    fclose( file );
    
    // Loop over resources, calling Register()
    BYTE* pData = g_pResourceSysMemData;

    for( DWORD i = 0; i < resource_NUM_RESOURCES; i++ )
    {
        // Get the resource
        LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;

        // Register the resource
        pResource->Register( g_pResourceVidMemData );
    
        // Advance the pointer
        switch( pResource->GetType() )
        {
            case D3DRTYPE_TEXTURE:       pData += sizeof(D3DTexture);       break;
            case D3DRTYPE_VOLUMETEXTURE: pData += sizeof(D3DVolumeTexture); break;
            case D3DRTYPE_CUBETEXTURE:   pData += sizeof(D3DCubeTexture);   break;
            case D3DRTYPE_VERTEXBUFFER:  pData += sizeof(D3DVertexBuffer);  break;
            case D3DRTYPE_INDEXBUFFER:   pData += sizeof(D3DIndexBuffer);   break;
            case D3DRTYPE_PALETTE:       pData += sizeof(D3DPalette);       break;
            default:                     return E_FAIL;
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FindResourceByName()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* FindResourceByName( const CHAR* strName )
{
    if( NULL==g_pResourceSysMemData || NULL==strName )
        return NULL;

    // For this simple tutorial, this is hard-coded.
    if( !_stricmp( strName, "Tiger.bmp" ) )
        return &g_pResourceSysMemData[resource_Tiger_OFFSET];

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: LoadXBGFile()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT LoadXBGFile( const CHAR* strMeshFilename )
{
    // Open the file
    FILE* file = fopen( strMeshFilename, "rb" );
    if( file == NULL )
    {
        OutputDebugStringA( "ERROR: Mesh file not found!\n" );
        return E_FAIL;
    }

    // Read the magic number
    DWORD dwFileID;
    fread( &dwFileID, 1, sizeof(DWORD), file ); 

    // The magic number to identify .xbg files
    const DWORD XBG_FILE_ID  = (((DWORD)'X'<<0)|(((DWORD)'B'<<8))|(((DWORD)'G'<<16))|(2<<24));

    if( dwFileID != XBG_FILE_ID )
    {
        OutputDebugStringA( "ERROR: Invalid XBG file type!\n" );
        fclose( file );
        return E_FAIL;
    }

    // Read in header
    DWORD dwNumFrames;  // Number of mesh frames in the file
    DWORD dwSysMemSize; // Num bytes needed for system memory objects
    DWORD dwVidMemSize; // Num bytes needed for video memory objects

    fread( &dwNumFrames,  1, sizeof(DWORD), file );
    fread( &dwSysMemSize, 1, sizeof(DWORD), file );
    fread( &dwVidMemSize, 1, sizeof(DWORD), file );

    // Read in system memory objects
    g_pMeshSysMemData = (VOID*)new BYTE[dwSysMemSize];
    fread( g_pMeshSysMemData, dwSysMemSize, 1, file );

    // Read in video memory objects
    g_pMeshVidMemData = D3D_AllocContiguousMemory( dwVidMemSize, D3DVERTEXBUFFER_ALIGNMENT );
    fread( g_pMeshVidMemData, dwVidMemSize, 1, file ); 
    
    // Done with the file
    fclose( file );

    // Now we need to patch the mesh data. Any pointers read from the file were
    // stored as file offsets. So, we simply need to add a base address to patch
    // things up.
    g_pMeshFrames = (XBMESH_FRAME*)g_pMeshSysMemData;
    g_dwNumMeshFrames = dwNumFrames;

    for( DWORD i=0; i<g_dwNumMeshFrames; i++ )
    {
        XBMESH_FRAME* pFrame = &g_pMeshFrames[i];
        XBMESH_DATA*  pMesh  = &g_pMeshFrames[i].m_MeshData;

        if( pFrame->m_pChild )
            pFrame->m_pChild  = (XBMESH_FRAME*)( (DWORD)pFrame->m_pChild - 16 + (DWORD)g_pMeshFrames );
        if( pFrame->m_pNext )
            pFrame->m_pNext   = (XBMESH_FRAME*)( (DWORD)pFrame->m_pNext  - 16 + (DWORD)g_pMeshFrames );
        if( pMesh->m_pSubsets )
            pMesh->m_pSubsets = (XBMESH_SUBSET*)( (DWORD)pMesh->m_pSubsets - 16 + (DWORD)g_pMeshFrames);
        
        if( pMesh->m_dwNumIndices )
            pMesh->m_IB.Data  = pMesh->m_IB.Data - 16 + (DWORD)g_pMeshFrames;
        if( pMesh->m_dwNumVertices )
            pMesh->m_VB.Register( g_pMeshVidMemData );
    }

    // Finally, create any textures used by the meshes' subsets. In this 
    // implementation, we are pulling textures out of the global resource.
    for( DWORD i=0; i<g_dwNumMeshFrames; i++ )
    {
        XBMESH_DATA* pMesh = &g_pMeshFrames[i].m_MeshData;

        for( DWORD j = 0; j < pMesh->m_dwNumSubsets; j++ )
        {
            XBMESH_SUBSET* pSubset = &pMesh->m_pSubsets[j];

            pSubset->pTexture = (LPDIRECT3DTEXTURE8)FindResourceByName( pSubset->strTexture );
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitGeometry()
// Desc: Load the mesh and build the material and texture arrays
//-----------------------------------------------------------------------------
HRESULT InitGeometry()
{
    // Load the packed resource (containing the app's textures)
    if( FAILED( LoadPackedResource( "D:\\Media\\Resource.xpr" ) ) )
        return E_FAIL;

    // Load geometry from the XBG file
    if( FAILED( LoadXBGFile( "D:\\Media\\Tiger.xbg" ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetupMatrices()
// Desc: Sets up the world, view, and projection transform matrices.
//-----------------------------------------------------------------------------
VOID SetupMatrices()
{
    // For our world matrix, we will just leave it as the identity
    D3DXMATRIX matWorld;
    D3DXMatrixRotationY( &matWorld, timeGetTime()/1000.0f );
    g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set up our view matrix. A view matrix can be defined given an eye point,
    // a point to lookat, and a direction for which way is up. Here, we set the
    // eye five units back along the z-axis and up three units, look at the 
    // origin, and define "up" to be in the y-direction.
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 3.0f,-5.0f ), 
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), 
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // For the projection matrix, we set up a perspective transform (which
    // transforms geometry from 3D view space to 2D viewport space, with
    // a perspective divide making objects smaller in the distance). To build
    // a perpsective transform, we need the field of view (1/4 pi is common),
    // the aspect ratio, and the near and far clipping planes (which define at
    // what distances geometry should be no longer be rendered).
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f );
    g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
}




//-----------------------------------------------------------------------------
// Name: RenderMesh()
// Desc: Renders the mesh geometry.
//-----------------------------------------------------------------------------
HRESULT RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh )
{
    if( pMesh->m_dwNumVertices == 0 )
        return S_OK;

    // Set the vertex stream
    pd3dDevice->SetStreamSource( 0, &pMesh->m_VB, pMesh->m_dwVertexSize );
    pd3dDevice->SetIndices( &pMesh->m_IB, 0 );

    // Set the FVF code, unless the user asked us not to
    pd3dDevice->SetVertexShader( pMesh->m_dwFVF );

    // Render the subsets
    for( DWORD i = 0; i < pMesh->m_dwNumSubsets; i++ )
    {
        // Set the material
        pd3dDevice->SetMaterial( &pMesh->m_pSubsets[i].mtrl );

        // Set the texture.
        pd3dDevice->SetTexture( 0, pMesh->m_pSubsets[i].pTexture );

        // Draw the mesh subset
        if( D3DPT_TRIANGLESTRIP == pMesh->m_dwPrimType )
            pd3dDevice->DrawIndexedPrimitive( pMesh->m_dwPrimType, 0, 
                                              pMesh->m_pSubsets[i].dwIndexCount,
                                              pMesh->m_pSubsets[i].dwIndexStart, 
                                              pMesh->m_pSubsets[i].dwIndexCount-2 );
        else // D3DPT_TRIANGLELIST
            pd3dDevice->DrawIndexedPrimitive( pMesh->m_dwPrimType, 0, 
                                              pMesh->m_pSubsets[i].dwIndexCount,
                                              pMesh->m_pSubsets[i].dwIndexStart, 
                                              pMesh->m_pSubsets[i].dwIndexCount/3 );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderFrame()
// Desc: Renders a frame (save state, apply matrix, render children, restore).
//-----------------------------------------------------------------------------
HRESULT RenderFrame( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_FRAME* pFrame )
{
    // Apply the frame's local transform
    D3DXMATRIX matSavedWorld, matWorld;
    pd3dDevice->GetTransform( D3DTS_WORLD, &matSavedWorld );
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, &matSavedWorld );
    pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Render the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets ) 
        RenderMesh( pd3dDevice, &pFrame->m_MeshData );

    // Render any child frames
    if( pFrame->m_pChild ) 
        RenderFrame( pd3dDevice, pFrame->m_pChild );

    // Restore the transformation matrix
    pd3dDevice->SetTransform( D3DTS_WORLD, &matSavedWorld );
    
    // Render any sibling frames
    if( pFrame->m_pNext )  
        RenderFrame( pd3dDevice, pFrame->m_pNext );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID Render()
{
    // Clear the backbuffer and the zbuffer
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         D3DCOLOR_XRGB(0,0,255), 1.0f, 0 );
    
    // Setup the world, view, and projection matrices
    SetupMatrices();

    // Render the first frame in the mesh. This will render the entire 
    // hierarchy (in any) of frames and meshes for the loaded geometry.
    RenderFrame( g_pd3dDevice, g_pMeshFrames );

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
void __cdecl main()
{
    // Initialize Direct3D
    if( FAILED( InitD3D() ) )
        return;

    // Create the scene geometry
    if( FAILED( InitGeometry() ) )
        return;

    // Enter render loop
    while( TRUE )
    {
        Render();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TwoSidedLighting\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TwoSidedLighting\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\UserClipPlane\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\UserClipPlane\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\UserClipPlane\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\UserClipPlane\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\tutorials\tut07_vertexshaders\vertexshaders.cpp ===
//-----------------------------------------------------------------------------
// File: VertexShaders.cpp
//
// Desc: Shows how to use vertex shaders. Note that the vertex shader is 
//       precompiled into a .xvu file, and that the vertex declaration and
//       vertex shader constants used by an app, must be in agreement with the
//       vertex shader itself.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>




//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
LPDIRECT3D8       g_pD3D           = NULL; // Used to create the D3DDevice
LPDIRECT3DDEVICE8 g_pd3dDevice     = NULL; // Our rendering device
DWORD             g_dwVertexShaderHandle;  // Handle for the vertex shader




//-----------------------------------------------------------------------------
// Define our triangle.
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{ 
    FLOAT x,y,z; 
    DWORD color; 
};

CUSTOMVERTEX g_Vertices[] =
{
    { -0.6f, -1.0f, 0.0f, 0xffff0000, },
    {  0.0f,  1.0f, 0.0f, 0xff00ff00, },
    {  0.6f, -1.0f, 0.0f, 0xff0000ff, },
};

DWORD dwShaderVertexDecl[] =
{
    D3DVSD_STREAM( 0 ),
    D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),   // Position
    D3DVSD_REG( 1, D3DVSDT_D3DCOLOR ), // Diffuse color
    D3DVSD_END()
};




//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
HRESULT InitD3D()
{
    // Create the D3D object.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp; 
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.BackBufferWidth        = 640;
    d3dpp.BackBufferHeight       = 480;
    d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // Load the pre-compiled vertex shader microcode
    HANDLE hFile = CreateFileA( "D:\\media\\Shader.xvu", GENERIC_READ, FILE_SHARE_READ, 
                                NULL, OPEN_EXISTING, 
                                FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        OutputDebugStringA( "ERROR: Could not load the vertex shader!\n" );
        return E_FAIL;
    }

    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize];
	DWORD dwSizeRead;
    if(!ReadFile( hFile, pData, dwSize, &dwSizeRead, NULL ) ||
		dwSizeRead != dwSize )
	{
		CloseHandle(hFile);
		OutputDebugStringA( "ERROR: Could not load the vertex shader!\n" );
		return E_FAIL;
	}

    CloseHandle( hFile );

    // Create the vertex shader
    HRESULT hr = g_pd3dDevice->CreateVertexShader( dwShaderVertexDecl, (DWORD*)pData,
                                                   &g_dwVertexShaderHandle, 0 );
    delete pData;
    if( FAILED(hr) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Animates the scene
//-----------------------------------------------------------------------------
VOID FrameMove()
{
    // Rotate around the Y axis
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixRotationY( &matWorld, timeGetTime()/600.0f );

    // Set up our view matrix. A view matrix can be defined given an eye point,
    // a point to lookat, and a direction for which way is up.
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 0.0f,-3.0f ), 
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), 
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );

    // For the projection matrix, we set up a perspective transform (which
    // transforms geometry from 3D view space to 2D viewport space, with
    // a perspective divide making objects smaller in the distance). To build
    // a perpsective transform, we need the field of view (1/4 pi is common),
    // the aspect ratio, and the near and far clipping planes (which define at
    // what distances geometry should be no longer be rendered).
    D3DXMATRIX matProj;
    FLOAT fAspectRatio = 640.0f / 480.0f;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, fAspectRatio, 1.0f, 800.0f );

    // Calculate concatenated World x ( View x Projection) matrix.
    // We transpose the matrix at the end because that's how matrix math
    // works in vertex shaders. (Because the vertex shader DP4 operator works on
    // rows, not on columns.)
    D3DXMATRIX mat;
    D3DXMatrixMultiply( &mat, &matView, &matProj );
    D3DXMatrixMultiply( &mat, &matWorld, &mat );
    D3DXMatrixTranspose( &mat, &mat );
    g_pd3dDevice->SetVertexShaderConstant( 0, &mat, 4 );
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID Render()
{
    // Clear the backbuffer and the zbuffer
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         D3DCOLOR_XRGB(0,0,255), 1.0f, 0 );
    
    // Set state
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    // Draw the vertices using the vertex shader
    g_pd3dDevice->SetVertexShader( g_dwVertexShaderHandle );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLELIST, 1, g_Vertices, 
                                   sizeof(g_Vertices[0]) );

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
void __cdecl main()
{
    // Initialize Direct3D
    if( FAILED( InitD3D() ) )
        return;

    // Enter render loop
    while( TRUE )
    {
        // Animate the scene
        FrameMove();
 
        // Render
        Render();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\UserClipPlane\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexblend\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexblend\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TwoSidedLighting\TwoSidedLighting.cpp ===
//-----------------------------------------------------------------------------
// File: TwoSidedLighting.cpp
//
// Desc: Example code showing how to do two-sided lighting.
//
// Hist: 08.13.01 - New for September XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_1, L"Toggle vertex shader" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 3




//-----------------------------------------------------------------------------
// Name: struct CUSTOMVERTEX
// Desc: Custom vertex 
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{
    D3DXVECTOR3 position; // The 3D position for the vertex
    D3DXVECTOR3 normal;   // The surface normal for the vertex
};

#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL)




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont      m_Font;              // Font class
    CXBHelp      m_Help;              // Help class
    BOOL         m_bDrawHelp;         // Whether to draw help

    LPDIRECT3DVERTEXBUFFER8 m_pVB;    // Object to use for two-sdied lighting

    DWORD        m_dwVertexShader;    // Vertex shader
    BOOL         m_bUseVertexShader;

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp        = FALSE;
    m_pVB              = NULL;
    m_dwVertexShader   = 0L;
    m_bUseVertexShader = FALSE;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create geometry for a cylinder
    {
        // Create the vertex buffer
        if( FAILED( g_pd3dDevice->CreateVertexBuffer( 50*2*sizeof(CUSTOMVERTEX),
                                                      0, D3DFVF_CUSTOMVERTEX,
                                                      D3DPOOL_DEFAULT, &m_pVB ) ) )
            return E_FAIL;

        // Fill the vertex buffer
        CUSTOMVERTEX* pVertices;
        m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );
        for( DWORD i=0; i<50; i++ )
        {
            FLOAT theta = (2*D3DX_PI*i)/(50-1);
            pVertices[2*i+0].position = D3DXVECTOR3( sinf(theta), 1.0f, cosf(theta) );
            pVertices[2*i+0].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
            pVertices[2*i+1].position = D3DXVECTOR3( sinf(theta),-1.0f, cosf(theta) );
            pVertices[2*i+1].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
        }
        m_pVB->Unlock();
    }

    // Setup the vertex declaration
    DWORD dwDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),     // v0 = Position
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ),     // v3 = Normal
        D3DVSD_END()
    };

    // Create vertex shader from a file
    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\TwoSided.xvu", 
                                           dwDecl, &m_dwVertexShader ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set transforms
    D3DXMATRIX matWorld, matView,  matProj;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 3.0f,-5.0f ),
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ),
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Create a directional light. (Use yellow light to distinguish from
    // vertex shader case.)
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, -0.5f, -1.0f, 1.0f );
    light.Diffuse.r = 1.0f;
    light.Diffuse.g = 1.0f;
    light.Diffuse.b = 0.0f;
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Toggle use of vertex shader
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        m_bUseVertexShader = !m_bUseVertexShader; 

    // Rotate the object
    D3DXMATRIX matWorld;
    D3DXMatrixRotationX( &matWorld, m_fAppTime );

    // Set up a white, directional light, with an oscillating direction.
    FLOAT       fAngle = 3.0f * m_fAppTime;
    D3DXVECTOR3 vLightDirection( cosf(fAngle), 0.1f, sinf(fAngle) );
    D3DXVec3Normalize( &vLightDirection, &vLightDirection );

    // Set the vertex shader constants. 
    if( m_bUseVertexShader )        
    {
        // Some basic constants
        D3DXVECTOR4 vZero(0,0,0,0);
        D3DXVECTOR4 vOne(1,1,1,1);

        // Material colors. Frontside is yellow, and backside is red
        D3DXVECTOR4 vFrontDiffuse( 1.00f, 1.00f, 0.00f, 1.00f );
        D3DXVECTOR4 vFrontAmbient( 0.25f, 0.25f, 0.25f, 1.00f );
        D3DXVECTOR4 vBackDiffuse( 1.00f, 0.00f, 0.00f, 1.00f );
        D3DXVECTOR4 vBackAmbient( 0.25f, 0.25f, 0.25f, 1.00f );

        // Vertex shader operations use transposed matrices
        D3DXMATRIX matView, matProj;
        D3DXMATRIX matWorldView, matWorldViewProj;
        D3DXMATRIX matWorldTranspose, matWorldViewProjTranspose;
        m_pd3dDevice->GetTransform( D3DTS_VIEW,       &matView );
        m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
        D3DXMatrixMultiply( &matWorldView, &matWorld, &matView );
        D3DXMatrixMultiply( &matWorldViewProj, &matWorldView, &matProj );
        D3DXMatrixTranspose( &matWorldTranspose, &matWorld );
        D3DXMatrixTranspose( &matWorldViewProjTranspose, &matWorldViewProj );

        // Set the vertex shader constants
        m_pd3dDevice->SetVertexShaderConstant(  0, &vZero, 1 );
        m_pd3dDevice->SetVertexShaderConstant(  1, &vOne,  1 );
        m_pd3dDevice->SetVertexShaderConstant(  4, &matWorldTranspose,         4 );
        m_pd3dDevice->SetVertexShaderConstant( 12, &matWorldViewProjTranspose, 4 );
        m_pd3dDevice->SetVertexShaderConstant( 20, &vLightDirection, 1 );
        m_pd3dDevice->SetVertexShaderConstant( 21, &vFrontDiffuse,   1 );
        m_pd3dDevice->SetVertexShaderConstant( 22, &vFrontAmbient,   1 );
        m_pd3dDevice->SetVertexShaderConstant( 23, &vBackDiffuse,    1 );
        m_pd3dDevice->SetVertexShaderConstant( 24, &vBackAmbient,    1 );
    }
    else
    {
        // Set the world matrix
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

        // Set up the materials. The frontside material here is yellow, and the
        // backside material is red.
        D3DMATERIAL8 mtrl;
        ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
        mtrl.Diffuse.r = mtrl.Ambient.r = 1.0f;
        mtrl.Diffuse.g = mtrl.Ambient.g = 1.0f;
        mtrl.Diffuse.b = mtrl.Ambient.b = 0.0f;
        mtrl.Diffuse.a = mtrl.Ambient.a = 1.0f;
        g_pd3dDevice->SetMaterial( &mtrl );

        mtrl.Diffuse.r = mtrl.Ambient.r = 1.0f;
        mtrl.Diffuse.g = mtrl.Ambient.g = 0.0f;
        mtrl.Diffuse.b = mtrl.Ambient.b = 0.0f;
        mtrl.Diffuse.a = mtrl.Ambient.a = 1.0f;
        g_pd3dDevice->SetBackMaterial( &mtrl );

        // Setup a directional light
        D3DLIGHT8 light;
        ZeroMemory( &light, sizeof(D3DLIGHT8) );
        light.Type       = D3DLIGHT_DIRECTIONAL;
        light.Diffuse.r  = 1.0f;
        light.Diffuse.g  = 1.0f;
        light.Diffuse.b  = 1.0f;
        light.Direction  = vLightDirection;
        light.Range      = 1000.0f;
        g_pd3dDevice->SetLight( 0, &light );
        g_pd3dDevice->LightEnable( 0, TRUE );
    }
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Render a background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Set miscellaneous render states
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );

    // Enable two-sided lighting
    m_pd3dDevice->SetRenderState( D3DRS_TWOSIDEDLIGHTING, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,    D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,     0xff404040 );
    m_pd3dDevice->SetRenderState( D3DRS_BACKAMBIENT, 0xff404040 );
    
    // Set the vertex shader (programmable or fixed)
    if( m_bUseVertexShader )        
        m_pd3dDevice->SetVertexShader( m_dwVertexShader );
    else
        m_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );

    // Render the cyclinder
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(CUSTOMVERTEX) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2*50-2 );

    // Restore state
    m_pd3dDevice->SetRenderState( D3DRS_TWOSIDEDLIGHTING, FALSE );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"TwoSidedLighting" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        if( m_bUseVertexShader )        
            m_Font.DrawText( 64, 75, 0xffffffff, L"Using vertex shader" );
        else
            m_Font.DrawText( 64, 75, 0xffffffff, L"Using fixed-function API" );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexblend\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexblend\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexblend\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\MultiShader\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\MultiShader\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\MultiShader\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\UserClipPlane\UserClipPlane.cpp ===
//-----------------------------------------------------------------------------
// File: UserClipPlane.cpp
//
// Desc: Demonstrates how to use pixel shaders to create user-defined clip
//       planes
//
// Hist: 4.9.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <xgraphics.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_2, L"Pause" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Enable/\nDisable" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Next plane" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Rotate\nplane X/Z" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Rotate\nplane Y and\nmove" },
};

#define NUM_HELP_CALLOUTS 6

D3DXMATRIX g_matView, g_matProj;

#define NUM_PLANES 4

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    HRESULT InitVertexShader();
    HRESULT InitPixelShader();
    HRESULT DrawPlanes();

    BOOL        m_bDrawHelp;        // True if we should draw help
    CXBFont     m_Font;             // Font object
    CXBHelp     m_Help;             // Help object

    CXBMesh     m_Model;            // Teapot model

    DWORD       m_dwPixelShader;    // Pixel shader
    DWORD       m_dwVertexShader;   // Vertex shader


    DWORD       m_dwCurrentPlane;               // Selected plane
    D3DXVECTOR3 m_avNormals[ NUM_PLANES ];      // Plane normals
    D3DXVECTOR3 m_avIntercepts[ NUM_PLANES ];   // Plane intercepts
    BOOL        m_abActive[ NUM_PLANES];        // Enabled planes
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_dwCurrentPlane = 0;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_Model.Create( m_pd3dDevice, "Models\\Teapot.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set projection transform
    D3DXMatrixPerspectiveFovLH( &g_matProj, D3DX_PI/4, 640.0f/480.0f, 0.1f, 100.0 );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &g_matProj );

    // Set view position
    D3DXVECTOR3 vCameraPos( 0.0f, 2.0f, -5.0f );
    D3DXVECTOR3 vLookAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );
    D3DXMatrixLookAtLH( &g_matView, &vCameraPos, &vLookAt, &vUp );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &g_matView );

    // Create our shaders
    InitVertexShader();
    InitPixelShader();

    //
    // Initialize our clip planes:
    // * Normal points in the positive Y direction
    // * Intercept is at the origin
    // * Only plane 0 is active
    //
    for( int i = 0; i < NUM_PLANES; i++ )
    {
        m_avNormals[i]      = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
        m_avIntercepts[i]   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
        m_abActive[i]       = ( i == 0 );
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Toggle frame on/off
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        m_abActive[ m_dwCurrentPlane ] = !m_abActive[ m_dwCurrentPlane ];
    }

    // Cycle through frames
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        m_dwCurrentPlane = ( m_dwCurrentPlane + 1 ) % NUM_PLANES;
    }

    // If frame is active, allow it to be manipulated
    if( m_abActive[ m_dwCurrentPlane ] )
    {
        FLOAT fRotX = m_DefaultGamepad.fY1 * m_fElapsedTime;
        FLOAT fRotY = m_DefaultGamepad.fX2 * m_fElapsedTime;
        FLOAT fRotZ = m_DefaultGamepad.fX1 * m_fElapsedTime;
        D3DXMATRIX matTransformNormal;

        D3DXMatrixRotationYawPitchRoll( &matTransformNormal, fRotY, fRotX, -fRotZ );
        D3DXVec3TransformNormal( &m_avNormals[ m_dwCurrentPlane ], &m_avNormals[ m_dwCurrentPlane ], &matTransformNormal );

        m_avIntercepts[ m_dwCurrentPlane ] += m_avNormals[ m_dwCurrentPlane ] * m_DefaultGamepad.fY2 * m_fElapsedTime;
    }

    // Set up our clip planes
    D3DXMATRIX matClipPlanes;
    ZeroMemory( &matClipPlanes, sizeof( D3DXMATRIX ) );
    for( int i = 0; i < NUM_PLANES; i++ )
    {
        if( m_abActive[ i ] )
        {
            matClipPlanes( i, 0 ) = m_avNormals[ i ].x;
            matClipPlanes( i, 1 ) = m_avNormals[ i ].y;
            matClipPlanes( i, 2 ) = m_avNormals[ i ].z;
            matClipPlanes( i, 3 ) = -D3DXVec3Dot( &m_avNormals[ i ], 
                                                  &m_avIntercepts[ i ] );
        }
    }

    m_pd3dDevice->SetVertexShaderConstant( 8, &matClipPlanes, 4 );

	D3DXMATRIX matWorld, m;
	static float fRot = 0.0f;

	// Rotate teapot
	fRot += 1.57f*m_fElapsedAppTime;
	D3DXMatrixRotationY(&matWorld, fRot);
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set WVP and World transforms for vertex shader
    D3DXMATRIX matWVP;
    D3DXMatrixMultiply( &matWVP, &g_matView, &g_matProj );
    D3DXMatrixMultiply( &matWVP, &matWorld, &matWVP );
    D3DXMatrixTranspose( &matWVP, &matWVP );
    m_pd3dDevice->SetVertexShaderConstant( 0, &matWVP, 4 );
    D3DXMatrixTranspose( &matWorld, &matWorld );
    m_pd3dDevice->SetVertexShaderConstant( 4, &matWorld, 4 );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Set default state
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,     TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE);
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_NONE );

    // Render the object using the clip planes
    m_pd3dDevice->SetVertexShader( m_dwVertexShader );
    m_pd3dDevice->SetPixelShader( m_dwPixelShader );
    m_pd3dDevice->SetRenderState( D3DRS_PSCONSTANT0_0, 0xFFFFFF00 );
    m_Model.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOMATERIALS | XBMESH_NOTEXTURES );
    m_pd3dDevice->SetPixelShader( NULL );

    // Show the active clipping planes
    DrawPlanes();

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR sz[100];

        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"UserClipPlane" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        swprintf( sz, L"Plane %d of %d (%s)", m_dwCurrentPlane + 1, 
                                              NUM_PLANES, 
                                              m_abActive[ m_dwCurrentPlane ] ? L"Enabled" : L"Disabled" );
        m_Font.DrawText( 64, 80, 0xffffff00, sz );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitVertexShader
// Desc: Initializes and creates our vertex shader.  Also sets up vertex
//       shader constants that don't change:
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::InitVertexShader()
{
    // Setup the vertex declaration
    DWORD dwDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // v0 = Position
        D3DVSD_REG( 2, D3DVSDT_FLOAT3 ), // v2 = Normal
        D3DVSD_END()
    };

    // Create the vertex shader
    XBUtil_CreateVertexShader( m_pd3dDevice, "shaders\\UserClipPlane.xvu", dwDecl, &m_dwVertexShader );

    D3DXVECTOR4 vLightDir( 0.7f, 0.7f, -0.14f, 0.0f );
    m_pd3dDevice->SetVertexShaderConstant( 13, &vLightDir, 1 );
    D3DXVECTOR3 vColor( 1.0f, 0.7f, 0.0f );
    m_pd3dDevice->SetVertexShaderConstant( 14, &vColor, 1 );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: InitPixelShader
// Desc: Creates our pixel shader via D3DPIXELSHADERDEF.
//       Texture stage 0 performs a standard 2d projection
//       Texture stage 1 performs the clip plane operation
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::InitPixelShader()
{
    D3DPIXELSHADERDEF psd;

    ZeroMemory( &psd, sizeof( D3DPIXELSHADERDEF ) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 1, 0 );
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_CLIPPLANE,  // Clip Plane(s)
                                           PS_TEXTUREMODES_NONE,       // Not used
                                           PS_TEXTUREMODES_NONE,       // Not used
                                           PS_TEXTUREMODES_NONE );     // Not used

    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 0, 0 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0,
                                         0,
                                         0,
                                         0);
    psd.PSCompareMode   = PS_COMPAREMODE( 
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    //--------------------------
    // Stage 0 
    //--------------------------

    // A=T0.rgb, B=V0, C=0, D=0 (so that AB.rgb = C0 and CD = 0 )
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS(
        PS_REGISTER_V0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
    // A=0, B=0, C=0, D=0 (so that AB = 0 and CD = 0 )
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // R0.rgb = AB
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    
    // R0.a = AB
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    
    psd.PSConstant0[0]    = 0x00000000;
    psd.PSConstant1[0]    = 0x00000000;

    //--------------------------
    // Final combiner
    //--------------------------
    psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // E = 0, F = 0, G = 1. (From above, EF is not used. G is alpha and is set to 1.)
    psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        0 | 0 | 0 );
    psd.PSC0Mapping = 0x00000000;
    psd.PSC1Mapping = 0x00000000;

    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwPixelShader ) ) )
    {
        OUTPUT_DEBUG_STRING( "Couldn't create pixel shader.\n" );
        return E_FAIL;
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: DrawPlanes
// Desc: Draws the active clipping planes and normals
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::DrawPlanes()
{
    typedef struct
    {
        D3DXVECTOR3 p;
        D3DCOLOR c;
    } PLANE_VERTEX;
#define FVF_PLANE_VERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)

    // Set up our rendering state
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ); 
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( FVF_PLANE_VERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    
    // Loop over each plane, drawing it if it's active
    for( int i = 0; i < NUM_PLANES; i++ )
    {
        PLANE_VERTEX apvNormalLine[2];
        PLANE_VERTEX apvPlane[4];

        const DWORD colors[ NUM_PLANES ] =
        {
            0x00FF0000,
            0x0000FF00,
            0x000000FF,
            0x00646464,
        };

        if( m_abActive[i] )
        {
            DWORD dwAlpha = i == m_dwCurrentPlane ? 0x40000000 : 0x20000000;

            //
            // Create the normal vector
            //
            apvNormalLine[0].p = m_avIntercepts[i];
            apvNormalLine[0].c = 0xFF000000 | colors[i];
            apvNormalLine[1].p = m_avIntercepts[i] + m_avNormals[i];
            apvNormalLine[1].c = 0xFF000000 | colors[i];

            //
            // Draw the normal vector
            //
            D3DXMATRIX matIdentity;
            D3DXMatrixIdentity( &matIdentity );
            m_pd3dDevice->SetTransform( D3DTS_WORLD, &matIdentity );
            m_pd3dDevice->DrawVerticesUP( D3DPT_LINELIST, 2, apvNormalLine, sizeof( PLANE_VERTEX ) );

            //
            // Create the plane:
            // Since we're going to use the cross-product of the quad
            // normal and the plane normal as our rotation axis, we
            // want to make sure they're not close to parallel.  So
            // we face the quad into x or y depending on which is
            // less represented in the plane normal
            // Note that this will give some artifacts when we switch
            // from one to the other, but the plane quads are just a
            // visual aid.
            //
            for( int j = 0; j < 4; j++ )
                apvPlane[j].c = dwAlpha | colors[i];

            D3DXVECTOR3 vQuadNorm;
            if( fabs( m_avNormals[i].x ) > fabs( m_avNormals[i].y ) )
            {
                // X has greater magnitude, so face quad in y
                vQuadNorm = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
                apvPlane[0].p = D3DXVECTOR3( -2.0f, 0.0f, -2.0f );
                apvPlane[1].p = D3DXVECTOR3( -2.0f, 0.0f, 2.0f );
                apvPlane[2].p = D3DXVECTOR3(  2.0f, 0.0f, -2.0f );
                apvPlane[3].p = D3DXVECTOR3(  2.0f, 0.0f, 2.0f );
            }
            else
            {
                // Y has greater magnitude, so face quad in x
                vQuadNorm = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
                apvPlane[0].p = D3DXVECTOR3( 0.0f, -2.0f, -2.0f );
                apvPlane[1].p = D3DXVECTOR3( 0.0f, -2.0f, 2.0f );
                apvPlane[2].p = D3DXVECTOR3( 0.0f,  2.0f, -2.0f );
                apvPlane[3].p = D3DXVECTOR3( 0.0f,  2.0f, 2.0f );
            }

            // 
            // Now, calculate the cross product of the quad normal
            // and plane normal to get our rotation axis.
            // Then, take the dot product to get the angle between
            // them.  Set up a rotation matrix to rotate that much
            // around the axis, then translate to the intercept
            // point.
            //
            D3DXVECTOR3 vAxis;
            D3DXMATRIX matRotation, matTranslation, matWorld;
            FLOAT fDot;
            FLOAT fAngle;

            // Calculate rotation axis
            D3DXVec3Cross( &vAxis, &vQuadNorm, &m_avNormals[i] );
            D3DXVec3Normalize( &vAxis, &vAxis );

            // Calculate angle
            fDot = D3DXVec3Dot( &vQuadNorm, &m_avNormals[i] );
            fAngle = (FLOAT)acos( fDot );

            // Set up transform matrix
            D3DXMatrixRotationAxis( &matRotation, &vAxis, fAngle );
            D3DXMatrixTranslation( &matTranslation, m_avIntercepts[i].x, m_avIntercepts[i].y, m_avIntercepts[i].z );
            D3DXMatrixMultiply( &matWorld, &matRotation, &matTranslation );
            m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );
            m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );

            // Draw the plane
            m_pd3dDevice->DrawVerticesUP( D3DPT_TRIANGLESTRIP, 4, apvPlane, sizeof( PLANE_VERTEX ) );
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\MultiShader\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\MultiShader\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\ripple\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexblend\vertexblend.cpp ===
//-----------------------------------------------------------------------------
// File: VertexBlend.cpp
//
// Desc: Example code showing how to do a skinning effect, using the vertex
//       blending feature of Direct3D. Normally, Direct3D transforms each
//       vertex through the world matrix. The vertex blending feature,
//       however, uses mulitple world matrices and a per-vertex blend factor
//       to transform each vertex.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_1, L"Toggle vertex shader" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 3




//-----------------------------------------------------------------------------
// Name: struct BLENDVERTEX
// Desc: Custom vertex which includes a blending factor
//-----------------------------------------------------------------------------
struct BLENDVERTEX
{
    D3DXVECTOR3 v;       // Referenced as v0 in the vertex shader
    FLOAT       blend;   // Referenced as v1.x in the vertex shader
    D3DXVECTOR3 n;       // Referenced as v3 in the vertex shader
    FLOAT       tu, tv;  // Referenced as v7 in the vertex shader
};

#define D3DFVF_BLENDVERTEX (D3DFVF_XYZB1|D3DFVF_NORMAL|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont      m_Font;              // Font class
    CXBHelp      m_Help;              // Help class
    BOOL         m_bDrawHelp;         // Whether to draw help

    CXBMesh*     m_pObject;           // Object to use for vertex blending

    D3DXMATRIX   m_matUpperArm;       // Vertex blending matrices
    D3DXMATRIX   m_matLowerArm;

    DWORD        m_dwVertexShader;    // Vertex shader
    BOOL         m_bUseVertexShader;

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp         = FALSE;
    m_pObject           = new CXBMesh();
    m_dwVertexShader    = 0L;
    m_bUseVertexShader  = FALSE;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load an object to render.
    if( FAILED( m_pObject->Create( m_pd3dDevice, "Models\\MSLogo.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Make sure the loaded object has the correct FVF. It needs to be pre-
    // authored to match (i.e. with space for blend weights) or this app will
    // not work. See the MakeXBG tool for converting meshes.
    if( m_pObject->GetMesh(0)->m_dwFVF != D3DFVF_BLENDVERTEX )
	{
		OUTPUT_DEBUG_STRING( "Error: Mesh must have blend weights!\n" );
        return E_FAIL;
	}

    // Add blending weights to the mesh
    {
        // Gain acces to the mesh's vertices
        LPDIRECT3DVERTEXBUFFER8 pVB = &m_pObject->GetMesh(0)->m_VB;
        DWORD        dwNumVertices = m_pObject->GetMesh(0)->m_dwNumVertices;
        BLENDVERTEX* pVertices;
        pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

        // Calculate the min/max z values for all the vertices
        FLOAT fMinX =  1e10f;
        FLOAT fMaxX = -1e10f;

        for( DWORD i=0; i<dwNumVertices; i++ )
        {
            if( pVertices[i].v.x < fMinX ) 
                fMinX = pVertices[i].v.x;
            if( pVertices[i].v.x > fMaxX ) 
                fMaxX = pVertices[i].v.x;
        }

        for( i=0; i<dwNumVertices; i++ )
        {
            // Set the blend factors for the vertices
            FLOAT a = ( pVertices[i].v.x - fMinX ) / ( fMaxX - fMinX );
            pVertices[i].blend = 1.0f-sinf(a*D3DX_PI*1.0f);
        }

        // Done with the mesh's vertex buffer data
        pVB->Unlock();
    }

    // Setup the vertex declaration
    DWORD dwDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),     // v0 = Position
        D3DVSD_REG( 1, D3DVSDT_FLOAT1 ),     // v1 = Blend weight
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ),     // v3 = Normal
        D3DVSD_REG( 7, D3DVSDT_FLOAT2 ),     // v7 = Texcoords
        D3DVSD_END()
    };

    // Create vertex shader from a file
    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Blend.xvu", 
                                           dwDecl, &m_dwVertexShader ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set the projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 10000.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set the app view matrix for normal viewing
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f,-5.0f,-10.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f,  0.0f );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f,  0.0f );
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Create a directional light. (Use yellow light to distinguish from
    // vertex shader case.)
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, -0.5f, -1.0f, 1.0f );
    light.Diffuse.r = 1.0f;
    light.Diffuse.g = 1.0f;
    light.Diffuse.b = 0.0f;
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Toggle use of vertex shader
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        m_bUseVertexShader = !m_bUseVertexShader; 

    // Set the vertex blending matrices for this frame
    D3DXVECTOR3 vAxis( 2+sinf(m_fAppTime*3.1f), 2+sinf(m_fAppTime*3.3f), sinf(m_fAppTime*3.5f) ); 
    D3DXMatrixRotationAxis( &m_matLowerArm, &vAxis, sinf(3*m_fAppTime) );
    D3DXMatrixIdentity( &m_matUpperArm );

    // Set the vertex shader constants. 
    {
        // Some basic constants
        D3DXVECTOR4 vZero(0,0,0,0);
        D3DXVECTOR4 vOne(1,1,1,1);

        // Lighting vector (normalized) and material colors. (Use red light
        // to show difference from non-vertex shader case.)
        D3DXVECTOR4 vLight( 0.5f, 1.0f, -1.0f, 0.0f );
        D3DXVec4Normalize( &vLight, &vLight );
        D3DXVECTOR4 vDiffuse( 1.00f, 0.00f, 0.00f, 1.00f );
        D3DXVECTOR4 vAmbient( 0.25f, 0.25f, 0.25f, 0.25f );

        // Vertex shader operations use transposed matrices
        D3DXMATRIX matWorld0Transpose, matWorld1Transpose;
        D3DXMATRIX matView, matProj, matViewProj, matViewProjTranspose;
        m_pd3dDevice->GetTransform( D3DTS_VIEW,       &matView );
        m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
        D3DXMatrixMultiply( &matViewProj, &matView, &matProj );
        D3DXMatrixTranspose( &matWorld0Transpose, &m_matUpperArm );
        D3DXMatrixTranspose( &matWorld1Transpose, &m_matLowerArm );
        D3DXMatrixTranspose( &matViewProjTranspose, &matViewProj );

        // Set the vertex shader constants
        m_pd3dDevice->SetVertexShaderConstant(  0, &vZero,    1 );
        m_pd3dDevice->SetVertexShaderConstant(  1, &vOne,     1 );
        m_pd3dDevice->SetVertexShaderConstant(  4, &matWorld0Transpose,   4 );
        m_pd3dDevice->SetVertexShaderConstant(  8, &matWorld1Transpose,   4 );
        m_pd3dDevice->SetVertexShaderConstant( 12, &matViewProjTranspose, 4 );
        m_pd3dDevice->SetVertexShaderConstant( 20, &vLight,   1 );
        m_pd3dDevice->SetVertexShaderConstant( 21, &vDiffuse, 1 );
        m_pd3dDevice->SetVertexShaderConstant( 22, &vAmbient, 1 );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Render a background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Set miscellaneous render states
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0x00404040 );

    // Render the bendy object
    if( m_bUseVertexShader )        
    {
        // Enable vertex blending using the vertex shader
        m_pd3dDevice->SetVertexShader( m_dwVertexShader );

        // Display the object. Don't use the mesh's FVF code (will use vertex shader instead)
        m_pObject->Render( m_pd3dDevice, XBMESH_NOFVF );
    }
    else
    {
        // Enable vertex blending using API
        m_pd3dDevice->SetTransform( D3DTS_WORLD,  &m_matUpperArm );
        m_pd3dDevice->SetTransform( D3DTS_WORLD1, &m_matLowerArm );
        m_pd3dDevice->SetRenderState( D3DRS_VERTEXBLEND, D3DVBF_1WEIGHTS );

        // Display the object. Use the mesh's FVF code (for fixed-lighting)
        m_pObject->Render( m_pd3dDevice );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"VertexBlend" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        if( m_bUseVertexShader )        
            m_Font.DrawText( 64, 75, 0xffffffff, L"Using vertex shader" );
        else
            m_Font.DrawText( 64, 75, 0xffffffff, L"Using blending API" );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\ripple\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\ripple\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\ripple\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\ShaderSplicer\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\ripple\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\ShaderSplicer\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\MultiShader\MultiShader.cpp ===
//-----------------------------------------------------------------------------
// File: MultiShader.cpp
//
// Desc: Illustrates having multiple vertex shaders loaded at once.
//
//       Typically, since an app only can use one vertex shader at a time, they
//       use the SetVertexShader() API to load and select a vertex shader.
//       However, there are 136 instruction slots available, so several small
//       vertex shaders could potentially be resident in memory at the same
//       time. To do this, an app uses the LoadVertexShader() and 
//       SelectVertexShader() API, as this sample demonstrates.
//
// Hist: 01.10.00 - New for February XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBUtil.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Select new\nvertex shader" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display\nhelp" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 3




//-----------------------------------------------------------------------------
// Define our triangle.
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{ 
    FLOAT x,y,z; // Position
    DWORD color; // Diffuse color
};


CUSTOMVERTEX g_Vertices[] =
{
    {-0.6f,-1.0f, 0.0f, 0xffff0000, },
    { 0.0f, 1.0f, 0.0f, 0xff00ff00, },
    { 0.6f,-1.0f, 0.0f, 0xff0000ff, },
};


DWORD g_dwVertexDecl[] =
{
    D3DVSD_STREAM( 0 ),
    D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),   // Position
    D3DVSD_REG( 1, D3DVSDT_D3DCOLOR ), // Diffuse color
    D3DVSD_END()
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont m_Font;
    CXBHelp m_Help;               // Help class
    BOOL    m_bDrawHelp;          // Whether to draw help

    DWORD   m_dwWhichShader;
 
    DWORD   m_dwVertexShader1;
    DWORD   m_dwVertexShader2;
    DWORD   m_dwVertexShader3;
    DWORD   m_dwVertexShader1Address;
    DWORD   m_dwVertexShader2Address;
    DWORD   m_dwVertexShader3Address;

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp     = FALSE;

    m_dwWhichShader = 1;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Now, load the vertex shaders into memory. 
    DWORD ip = 0;
    UINT  length;

    // NOTE: THIS IS VERY IMPORTANT. Ater loading vertex shaders into memory with
    // the LoadVertexShader API, it will stay resident until it gets kicked out,
    // such as by a call to SetVertexShader(). What is very important to keep in
    // mind, is that the fixed-pipeline, when used with vertices of type
    // D3DXYZ_RHW, uses the first several vertex shader address locations.
    // Therefore, any vertex shaders loaded there will be overwritten.

    // As per the comment above, skip the reserved instruction slots
    ip = D3DVS_XBOX_RESERVEDXYZRHWSLOTS;

    // Create the first vertex shader
    m_dwVertexShader1Address = ip;
    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Shader1.xvu", 
                                           g_dwVertexDecl, &m_dwVertexShader1 ) ) )
        return E_FAIL;

    // Up the instruction pointer
    m_pd3dDevice->GetVertexShaderSize( m_dwVertexShader1, &length );
    ip += length;

    // Create the second vertex shader
    m_dwVertexShader2Address = ip;
    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Shader2.xvu", 
                                           g_dwVertexDecl, &m_dwVertexShader2 ) ) )
        return E_FAIL;

    // Up the instruction pointer
    m_pd3dDevice->GetVertexShaderSize( m_dwVertexShader2, &length );
    ip += length;

    // Create the third vertex shader
    m_dwVertexShader3Address = ip;
    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Shader3.xvu", 
                                           g_dwVertexDecl, &m_dwVertexShader3 ) ) )
        return E_FAIL;

    // Up the instruction pointer
    m_pd3dDevice->GetVertexShaderSize( m_dwVertexShader3, &length );
    ip += length;

    // Load the vertex shaders. It's safe to do this here, since nothing in our
    // rendering loop will "unload" them. However, if we had any calls to
    // SetVertexShader(), etc., then we would need to reload them afterwards.
    m_pd3dDevice->LoadVertexShader( m_dwVertexShader1, m_dwVertexShader1Address );
    m_pd3dDevice->LoadVertexShader( m_dwVertexShader2, m_dwVertexShader2Address );
    m_pd3dDevice->LoadVertexShader( m_dwVertexShader3, m_dwVertexShader3Address );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Let user select a new vertex shader
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] ) 
        if( ++m_dwWhichShader > 3 )
            m_dwWhichShader = 1;

    // Build some different rotation matrices
    D3DXMATRIX matWorld1, matWorld2, matWorld3;
    D3DXMatrixRotationX( &matWorld1, 1.6f*m_fAppTime );
    D3DXMatrixRotationY( &matWorld2, 1.6f*m_fAppTime );
    D3DXMatrixRotationZ( &matWorld3, 1.6f*m_fAppTime );

    // Set our view matrix
    D3DXMATRIX matView;
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 6.0f );

    // Calc projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 480.0f / 640.0f, 1.0f, 800.0f );

    // Build three sets of WVP matrices: one for each vertex shader
    D3DXMATRIX mat1, mat2, mat3;
    D3DXMatrixMultiply( &mat1, &matWorld1, &matView );
    D3DXMatrixMultiply( &mat1, &mat1, &matProj );
    D3DXMatrixMultiply( &mat2, &matWorld2, &matView );
    D3DXMatrixMultiply( &mat2, &mat2, &matProj );
    D3DXMatrixMultiply( &mat3, &matWorld3, &matView );
    D3DXMatrixMultiply( &mat3, &mat3, &matProj );
    
    D3DXMatrixTranspose( &mat1, &mat1 );
    D3DXMatrixTranspose( &mat2, &mat2 );
    D3DXMatrixTranspose( &mat3, &mat3 );
    
    m_pd3dDevice->SetVertexShaderConstant( 0, &mat1, 4 ); // This matrix rotates in X
    m_pd3dDevice->SetVertexShaderConstant( 4, &mat2, 4 ); // This matrix rotates in Y
    m_pd3dDevice->SetVertexShaderConstant( 8, &mat3, 4 ); // This matrix rotates in Z

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the frame buffer, Zbuffer.
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         0x00000000, 1.0f, 0L );

    // Set state
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_NONE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE  );

    // Select a shader. Since the vertex shaders were previously loaded with
    // LoadVertexShader(), they can now be selected with the SelectVertexShader()
    // API. Note that this replaces the conventional call to SetVertexShader().
    // Also note that SetVertexShader() only allows one vertex shader to be
    // resident at one time. Remember that the whole point of using the 
    // load/select API is to keep several shaders resident at once.
    if( 1 == m_dwWhichShader )
        m_pd3dDevice->SelectVertexShader( m_dwVertexShader1, m_dwVertexShader1Address ); 
    if( 2 == m_dwWhichShader )
        m_pd3dDevice->SelectVertexShader( m_dwVertexShader2, m_dwVertexShader2Address ); 
    if( 3 == m_dwWhichShader )
        m_pd3dDevice->SelectVertexShader( m_dwVertexShader3, m_dwVertexShader3Address ); 

    // Display the test triangle
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLELIST, 1, g_Vertices, 
                                   sizeof(CUSTOMVERTEX) );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();

        m_Font.DrawText(  64, 50, 0xffffffff, L"MultiShader" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        if( 1 == m_dwWhichShader )
            m_Font.DrawText( 64, 75, 0xffffff00, L"Shader 1: Rotate about X" );
        if( 2 == m_dwWhichShader )
            m_Font.DrawText( 64, 75, 0xffffff00, L"Shader 2: Rotate about Y" );
        if( 3 == m_dwWhichShader )
            m_Font.DrawText( 64, 75, 0xffffff00, L"Shader 3: Rotate about Z" );
    
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\ShaderSplicer\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\ShaderSplicer\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\ShaderSplicer\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\StateShader\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\StateShader\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\StateShader\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\StateShader\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\ripple\ripple.cpp ===
//-----------------------------------------------------------------------------
// File: Ripple.cpp
//
// Desc: Uses a vertex shader to create a ripple effect in a mesh of vertices.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBUtil.h>


// Mesh size for the grid
#define MESH_SIZE 128




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move ripple\norigin" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display\nhelp" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 3




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont      m_Font;
    CXBHelp      m_Help;
    BOOL         m_bDrawHelp;

    // Scene
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    LPDIRECT3DINDEXBUFFER8  m_pIB;
    DWORD        m_dwNumVertices;
    DWORD        m_dwNumIndices;
    DWORD        m_dwShader;

    // Transforms
    D3DXMATRIX   m_matPosition;
    D3DXMATRIX   m_matView;
    D3DXMATRIX   m_matProj;

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample d3dApp;
    if( FAILED( d3dApp.Create() ) )
        return;
    d3dApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp        = FALSE;

    m_pIB              = NULL;
    m_pVB              = NULL;
    m_dwNumIndices     = 4*(MESH_SIZE-1) * (MESH_SIZE - 1);
    m_dwNumVertices    = MESH_SIZE * MESH_SIZE;
    m_dwShader         = 0;

    // Setup the view matrix
    D3DXVECTOR3 vEye = D3DXVECTOR3( 3.0f, 3.0f, 5.0f );
    D3DXVECTOR3 vAt  = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp  = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMatrixLookAtRH( &m_matView, &vEye, &vAt, &vUp );

    // Set the position matrix
    D3DXMatrixInverse( &m_matPosition, NULL, &m_matView );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create index buffer
    {
        WORD* pIndices;

        if( FAILED( hr = m_pd3dDevice->CreateIndexBuffer( m_dwNumIndices*sizeof(WORD),
                                                          0, D3DFMT_INDEX16,
                                                          D3DPOOL_DEFAULT, &m_pIB ) ) )
            return hr;

        m_pIB->Lock( 0, m_dwNumIndices*sizeof(WORD), (BYTE**)&pIndices, 0 );

        for( DWORD y=0; y<MESH_SIZE-1; y++ )
        {
            for( DWORD x=0; x<MESH_SIZE-1; x++ )
            {
                *pIndices++ = (WORD)( (x+0) + (y+0)*MESH_SIZE );
                *pIndices++ = (WORD)( (x+1) + (y+0)*MESH_SIZE );
                *pIndices++ = (WORD)( (x+1) + (y+1)*MESH_SIZE );
                *pIndices++ = (WORD)( (x+0) + (y+1)*MESH_SIZE );
            }
        }

        m_pIB->Unlock();
    }

    // Create vertex buffer
    {
        D3DXVECTOR2* pVertices;

        if( FAILED( hr = m_pd3dDevice->CreateVertexBuffer( m_dwNumVertices*sizeof(D3DXVECTOR2),
                                                           0, 0, D3DPOOL_DEFAULT, &m_pVB ) ) )
            return hr;

        m_pVB->Lock( 0, m_dwNumVertices*sizeof(D3DXVECTOR2), (BYTE**)&pVertices, 0 );

        for( DWORD y=0; y<MESH_SIZE; y++ )
            for( DWORD x=0; x<MESH_SIZE; x++ )
                *pVertices++ = D3DXVECTOR2( 4 * ((FLOAT)x / (FLOAT)(MESH_SIZE-1) - 0.5f),
                                            4 * ((FLOAT)y / (FLOAT)(MESH_SIZE-1) - 0.5f) );
        m_pVB->Unlock();
    }

    // Create vertex shader
    {
        DWORD dwDecl[] =
        {
            D3DVSD_STREAM(0),
            D3DVSD_REG(D3DVSDE_POSITION,  D3DVSDT_FLOAT2),
            D3DVSD_END()
        };

        if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Ripple.xvu",
                                               dwDecl, &m_dwShader ) ) )
            return XBAPPERR_MEDIANOTFOUND;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    static FLOAT fFrequency = 15.0f;
    static FLOAT fXOffset   =  0.0f;
    static FLOAT fYOffset   =  0.0f;

    // Move the origin around with the gamepad control
    fXOffset -= m_DefaultGamepad.fX1 * m_fElapsedTime;
    fYOffset += m_DefaultGamepad.fY1 * m_fElapsedTime;

    // Navigation
    static D3DXVECTOR3 vVelocity( 0.0f, 0.0f, 0.0f );
    static D3DXVECTOR3 vAngularVelocity( 0.0f, 0.0f, 0.0f );
    static FLOAT       fSpeed           = 5.0f;
    static FLOAT       fAngularSpeed    = 1.0f;

    // Process input
    D3DXVECTOR3 vT( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vR( 0.0f, 0.0f, 0.0f );

    vVelocity        = 0.1f*vT + 0.9f*vVelocity;
    vAngularVelocity = 0.1f*vR + 0.9f*vAngularVelocity;

    // Update position and view matricies
    D3DXMATRIX     matT, matR;
    D3DXQUATERNION qR;

    vT = m_fElapsedAppTime * vVelocity * fSpeed;
    vR = m_fElapsedAppTime * vAngularVelocity * fAngularSpeed;

    D3DXMatrixTranslation( &matT, vT.x, vT.y, vT.z);
    D3DXMatrixMultiply( &m_matPosition, &matT, &m_matPosition );

    D3DXQuaternionRotationYawPitchRoll( &qR, vR.y, vR.x, vR.z );
    D3DXMatrixRotationQuaternion( &matR, &qR );

    // Build the matrices
    D3DXMatrixMultiply( &m_matPosition, &matR, &m_matPosition );
    D3DXMatrixInverse( &m_matView, NULL, &m_matPosition );
    D3DXMatrixPerspectiveFovRH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 0.1f, 100.0f );

    // Set up the vertex shader constants
    {
        D3DXMATRIX mat;
        D3DXMatrixMultiply( &mat, &m_matView, &m_matProj );
        D3DXMatrixTranspose( &mat, &mat );

        D3DXVECTOR4 vA( sinf(m_fAppTime)*15.0f, 0.0f, 0.5f, 1.0f );
        D3DXVECTOR4 vB( -m_fAppTime, fFrequency, fXOffset, fYOffset );
        D3DXVECTOR4 vD( D3DX_PI, 1.0f/(2.0f*D3DX_PI), 2.0f*D3DX_PI, 0.05f );

        // Series coefficients for sin and cos
        D3DXVECTOR4 vSin( 6.274509804000f, -40.993464050000f, 76.967320260000f, -53.542483660000f );
        D3DXVECTOR4 vCos( 1.000000000000f, -19.555555555556f, 60.444444444444f, -56.888888888889f );
        D3DXVECTOR4 vMisc( 0.5f, 0.5f/D3DX_PI, D3DX_PI, 1.0f);

        m_pd3dDevice->SetVertexShaderConstant(  0, &mat,   4 );
        m_pd3dDevice->SetVertexShaderConstant(  4, &vA,    1 );
        m_pd3dDevice->SetVertexShaderConstant(  5, &vB,    1 );
        m_pd3dDevice->SetVertexShaderConstant(  7, &vD,    1 );
        m_pd3dDevice->SetVertexShaderConstant( 10, &vSin,  1 );
        m_pd3dDevice->SetVertexShaderConstant( 11, &vCos,  1 );
        m_pd3dDevice->SetVertexShaderConstant( 12, &vMisc, 1 );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: App_Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff000000, 0xff0000ff );

    // Setup render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_NONE );

    // Render the vertices using the vertex shader
    m_pd3dDevice->SetVertexShader( m_dwShader );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(D3DXVECTOR2) );
    m_pd3dDevice->SetIndices( m_pIB, 0 );
    m_pd3dDevice->DrawIndexedPrimitive( D3DPT_QUADLIST, 0, m_dwNumIndices, 
                                        0, m_dwNumIndices/4 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"Ripple" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\StateShader\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\ShaderSplicer\ShaderSplicer.cpp ===
//-----------------------------------------------------------------------------
// File: ShaderSplicer.cpp
//
// Desc: Example code showing how to splice two vertex shaders together.
//
// Hist: 07.23.01 - Changes for August XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>
#include <xgraphics.h> 


//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Rotate" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_1, L"Zoom" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"More Lights" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, L"Fewer Lights" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_1, L"Change Optimization Level" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle help" },
};

#define NUM_HELP_CALLOUTS 6




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
#define MAX_OPTIMIZATION_LEVELS 2

const DWORD MAX_LIGHTS[MAX_OPTIMIZATION_LEVELS]    = { 22, 28 };
const BOOL  OPTIMIZATIONS[MAX_OPTIMIZATION_LEVELS] = { FALSE, TRUE };




//-----------------------------------------------------------------------------
// A simple string buffer utility class
//-----------------------------------------------------------------------------
class StringBuffer 
{
public:
    DWORD m_size;
    CHAR* m_buf;
    DWORD m_used;

public:
    StringBuffer() { m_size = 0; m_buf = NULL; m_used = 0; }

    ~StringBuffer() { delete [] m_buf; }

    HRESULT Initialize( DWORD size )
    {
        m_used = 0;
        return GrowTo( size );
    }

    HRESULT GrowTo( DWORD size )
    {
        if( size+1 > m_size )
        {
            size += 4*1024;
            char* newBuf = new char[size];

            if( NULL == newBuf )
                return E_OUTOFMEMORY;
            else
            {
                memcpy( newBuf,m_buf, m_used );
                delete [] m_buf;
                m_buf = newBuf;
                m_size = size;
                m_buf[m_used] = 0;
            }
        }
        return S_OK;
    }

    HRESULT Printf( const char *msg, ... )
    {
        if( m_size - m_used < 1000 )
        {
            if( FAILED( GrowTo( m_size + 2000 ) ) )
                return E_OUTOFMEMORY;
        }

        va_list list;
        va_start(list, msg );
        m_used += _vsnprintf( m_buf + m_used, m_size - m_used, msg, list );
        va_end( list );
        return S_OK;
    }

    HRESULT Append( const VOID* data, DWORD length )
    {
        if( FAILED( GrowTo( m_used + length ) ) )
            return E_OUTOFMEMORY;

        memcpy( m_buf + m_used, data, length );
        m_used += length;
        m_buf[m_used] = '\0';
        return S_OK;
    }

    HRESULT Append( char c )               { return Append( &c, sizeof(char) ); }
    HRESULT Append( const char* c )        { return Append( c, strlen(c) ); }
    HRESULT Append( StringBuffer& buffer ) { return Append( buffer.GetText(), buffer.GetUsed() ); }
    char*   GetText()                      { return m_buf; }
    char*   GetTextEnd()                   { return m_buf + m_used; }
    DWORD   GetUsed()                      { return m_used; }

    void Clear()
    {
        m_used = 0;
        if( m_buf )
            m_buf[0] = 0;
    }
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont    m_Font;                     // Font class
    CXBHelp    m_Help;                     // Help class
    BOOL       m_bDrawHelp;                // Whether to draw help

    D3DXMATRIX m_matProj;

    DWORD      m_dwNumLights;              // Num lights to render
    DWORD      m_dwShader;                 // The current shader
    DWORD      m_dwOptimizationLevel;      // The current optimization number

    CXBMesh    m_Teapot;

    LPXGBUFFER m_pHeader;                  // Buffers for assembling the shaders
    LPXGBUFFER m_pFooter;
    LPXGBUFFER m_pLight4[7];
    LPXGBUFFER m_pLight1[28];

    HRESULT CreateShader();
    HRESULT ComputeLightPositionAndColor( DWORD dwIndex, FLOAT* fLightPosition,
                                          FLOAT* pfLightDiffuse );

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
    HRESULT SetLights();
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp; 
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    m_bDrawHelp           = FALSE;
    m_dwNumLights         = 4;
    m_dwShader            = 0;
    m_dwOptimizationLevel = MAX_OPTIMIZATION_LEVELS-1;

    ZeroMemory( &m_pLight4, sizeof(m_pLight4) );
    ZeroMemory( &m_pLight1, sizeof(m_pLight1) );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set up proj matrix
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 200.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    // Create a mesh (vertex and index buffers) for the teapot
    if( FAILED( m_Teapot.Create( m_pd3dDevice, "Models\\Teapot.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set up a shader
    HRESULT hr = CreateShader();
    if( FAILED(hr) )
        return hr;

    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Add or remove lights
    BOOL bLightsChanged = FALSE;

    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
    {
        if( ++m_dwOptimizationLevel >= MAX_OPTIMIZATION_LEVELS) 
            m_dwOptimizationLevel = 0;

        bLightsChanged = TRUE;
        
        if( m_dwNumLights > MAX_LIGHTS[m_dwOptimizationLevel] ) 
            m_dwNumLights = MAX_LIGHTS[m_dwOptimizationLevel];
    }

    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
    {
        if( m_dwNumLights < MAX_LIGHTS[m_dwOptimizationLevel] )
        {
            m_dwNumLights++;
            bLightsChanged = TRUE;
        }
    }
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
    {
        if( m_dwNumLights > 0 )
        {
            m_dwNumLights--;
            bLightsChanged = TRUE;
        }
    }
    if( bLightsChanged )
    {
        HRESULT hr = SetLights();
        if( FAILED(hr) )
        {
            m_dwNumLights = 0;
            hr = SetLights();
            if( FAILED(hr) )
                return hr;
        }
    }

    // Set up view matrix
    static D3DXVECTOR3 vEyePt( 0,0,-6 );
    if( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP )
        vEyePt.z += 10.0f*m_fElapsedTime;
    if( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        vEyePt.z -= 10.0f*m_fElapsedTime;

    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &D3DXVECTOR3(0,0,0), &D3DXVECTOR3(0,1,0) );

    // Setup object matrix
    D3DXMATRIX matRotate;
    FLOAT fXRotate = m_DefaultGamepad.fX1*D3DX_PI*m_fElapsedTime;
    FLOAT fYRotate = m_DefaultGamepad.fY1*D3DX_PI*m_fElapsedTime;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate, -fYRotate, 0.0f );
    
    static D3DXMATRIX  matWorld( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );
    matWorld._41 = matWorld._42 = 0.f;
    D3DXMatrixMultiply( &matWorld, &matWorld, &matRotate );

    // Set the WVP matrix in the vertex shader    
    D3DXMATRIX mat;
    D3DXMatrixMultiply( &mat, &matWorld, &matView );
    D3DXMatrixMultiply( &mat, &mat, &m_matProj );
    D3DXMatrixTranspose( &mat, &mat );
    m_pd3dDevice->SetVertexShaderConstant( 0, &mat, 4 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HSVToRGB()
// Desc: 
//-----------------------------------------------------------------------------
VOID HSVToRGB( FLOAT h, FLOAT s, FLOAT v, FLOAT* pRGB )
{
    FLOAT hue      = (FLOAT)(h - floor(h))* 6.0f; // 0..6
    INT   sector   = (INT)floor(hue);
    FLOAT fraction = hue - sector;

    if( (sector&1)== 0 ) // if i is even
        fraction = 1.0f - fraction;

    FLOAT m = v * (1-s);  
    FLOAT n = v * (1-s*fraction);

    switch( sector ) 
    {  
        case 6:  
        case 0: pRGB[0] = v; pRGB[1] = n; pRGB[2] = m; break;  
        case 1: pRGB[0] = n; pRGB[1] = v; pRGB[2] = m; break;  
        case 2: pRGB[0] = m; pRGB[1] = v; pRGB[2] = n; break;  
        case 3: pRGB[0] = m; pRGB[1] = n; pRGB[2] = v; break;  
        case 4: pRGB[0] = n; pRGB[1] = m; pRGB[2] = v; break;  
        case 5: pRGB[0] = v; pRGB[1] = m; pRGB[2] = n; break;  
    }
}




//-----------------------------------------------------------------------------
// Name: ComputeLightPositionAndColor()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::ComputeLightPositionAndColor( DWORD  index, 
                                                   FLOAT* vLightPosition, 
                                                   FLOAT* vLightDiffuse )
{
    FLOAT u = (FLOAT)index / m_dwNumLights;
    FLOAT fTheta = D3DX_PI * 2 * u;
    FLOAT fLightRadius = 20.0f;

    vLightPosition[0] = cosf(fTheta) * fLightRadius; // x
    vLightPosition[1] = sinf(fTheta) * fLightRadius; // y
    vLightPosition[2] = sinf(fTheta) * fLightRadius; // z
    vLightPosition[3] = 1.0f;                        // w

    FLOAT hue   = (FLOAT)index / 6.0f;
    FLOAT sat   = 1.0f;
    FLOAT value = (m_dwNumLights<5.0f) ? 1.0f : 5.0f/m_dwNumLights;

    HSVToRGB( hue, sat, value, vLightDiffuse );
    
    vLightDiffuse[3] = 1.0f; // Alpha
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateShader()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateShader()
{
    HRESULT hr;

    // Delete the old vertex shader
    if( m_dwShader )
    {
        m_pd3dDevice->DeleteVertexShader( m_dwShader );
        m_dwShader = 0;
    }

    // Compile the new vertex shader
    StringBuffer buffer;
    hr = buffer.Initialize( 1024 );
    if( FAILED(hr) )
        return hr;

    // How many instructions in an Xbox vertex shader? It depends. There are
    // 136 slots, and shaders have an overhead of two slots, which leaves 134
    // slots for instructions. The prefix takes 5 instructions. Each light
    // macro takes 7 instructions. Each group of 4 lights takes 22
    // instructions. And the postfix takes 1 instruction. So there should be
    // room for about 22 lights. However, the shader assembler is able to
    // optimize the code, to use fewer slots. With global or local
    // optimizations, there is room for 28 lights.

    const char* strPrefix =
        "xvs.1.1\n"
        "#pragma screenspace\n"
        "\n"
        "#define R_LIGHT_COEF r8\n"
        "#define R_VERTEX_TO_LIGHT r9\n"
        "#define R_FINAL_COLOR r11\n"
        "#define XYZW_LIGHT_N_DOT_L x\n"
        "#define XYZW_V_TO_L_DIST w\n"
        "#define ZERO c4.x\n"
        "\n"
        "macro addLight Position, Diffuse\n"
        "add R_VERTEX_TO_LIGHT, c[%Position],-v0\n"
        "dp3 R_VERTEX_TO_LIGHT.XYZW_V_TO_L_DIST, R_VERTEX_TO_LIGHT, R_VERTEX_TO_LIGHT\n"
        "rsq R_VERTEX_TO_LIGHT.XYZW_V_TO_L_DIST, R_VERTEX_TO_LIGHT.XYZW_V_TO_L_DIST\n"
        "dp3 R_LIGHT_COEF.XYZW_LIGHT_N_DOT_L, v1, R_VERTEX_TO_LIGHT\n"
        "max R_LIGHT_COEF.XYZW_LIGHT_N_DOT_L, R_LIGHT_COEF.XYZW_LIGHT_N_DOT_L, ZERO\n"
        "mul R_LIGHT_COEF.XYZW_LIGHT_N_DOT_L, R_LIGHT_COEF.XYZW_LIGHT_N_DOT_L, R_VERTEX_TO_LIGHT.XYZW_V_TO_L_DIST\n"
        "mad R_FINAL_COLOR, R_LIGHT_COEF.XYZW_LIGHT_N_DOT_L, c[%Diffuse], R_FINAL_COLOR\n"
        "endm\n"
        "\n"
        "macro addLight4 Position, Diffuse\n"
        "add r9,		c[%Position],					-v0\n"
        "dp3 r9.w,	r9,		r9\n"
        "rsq r1.w,	r9.w\n"
        "dp3 r2.w,	v1,		r9\n"

        "add r7,		c[%inc(%Position)],				-v0\n"
        "dp3 r7.w,	r7,		r7\n"
        "rsq r1.z,	r7.w\n"
        "dp3 r2.z,	v1,		r7\n"

        "add r5,		c[%inc(%inc(%Position))],		-v0\n"
        "dp3 r5.w,	r5,		r5\n"
        "rsq r1.y,	r5.w\n"
        "dp3 r2.y,	v1,		r5\n"

        "add r3,		c[%inc(%inc(%inc(%Position)))],	-v0\n"
        "dp3 r3.w,	r3,		r3\n"
        "rsq r1.x,	r3.w\n"
        "dp3 r2.x,	v1,		r3\n"
        "\n"
        "max r2.xyzw,r2.xyzw,c4.xxxx\n"
        "mul r2.xyzw,r2.xyzw,r1.xyzw\n"
        "\n"
        "mad R_FINAL_COLOR,	r2.w,	c[%Diffuse],					R_FINAL_COLOR\n"
        "mad R_FINAL_COLOR,	r2.z,	c[%inc(%Diffuse)],				R_FINAL_COLOR\n"
        "mad R_FINAL_COLOR,	r2.y,	c[%inc(%inc(%Diffuse))],		R_FINAL_COLOR\n"
        "mad R_FINAL_COLOR,	r2.x,	c[%inc(%inc(%inc(%Diffuse)))],	R_FINAL_COLOR\n"
        "endm\n"
        "\n";

    const char* strHeaderString = 
        "xvs.1.1\n"
        "#pragma screenspace\n"
        "#define R_FINAL_COLOR r11\n"
        "m4x4 oPos,v0,c0\n"
        "mov R_FINAL_COLOR,c4\n";

    const char* strLightMacro =
        "addLight %d,%d\n";
    const char* strLightMacro4 =
        "addLight4 %d,%d\n";
 
    const char* strPostfix =
        "xvs.1.1\n"
        "#define R_FINAL_COLOR r11\n"
        "mov oD0,R_FINAL_COLOR\n";

    // Emit the prefix
    const int dwLightPositionBase = 6;
    int       dwLightDiffuseBase  = dwLightPositionBase + 32;

    // Do single-lights first
    for( DWORD light = 0; light < 28; light++ )
    {
        buffer.Clear();
        buffer.Append( strPrefix );
        buffer.Printf( strLightMacro, dwLightPositionBase + light, dwLightDiffuseBase + light );
        
        hr = AssembleShader( "", buffer.GetText(), buffer.GetUsed(), SASM_DONOTOPTIMIZE | SASM_SKIPVALIDATION,
                             NULL, &m_pLight1[light], NULL, NULL, NULL, NULL, NULL );
    }

    for( light = 0; light < 28; light += 4 )
    {
        buffer.Clear();
        buffer.Append( strPrefix );
        buffer.Printf( strLightMacro4, dwLightPositionBase + light, dwLightDiffuseBase + light );
        hr = AssembleShader( "", buffer.GetText(), buffer.GetUsed(), SASM_DONOTOPTIMIZE | SASM_SKIPVALIDATION,
                             NULL, &m_pLight4[light >> 2], NULL, NULL, NULL, NULL, NULL);
    }

    buffer.Clear();
    buffer.Printf( strPostfix );
    AssembleShader( "", buffer.GetText(), buffer.GetUsed(), SASM_DONOTOPTIMIZE | SASM_SKIPVALIDATION,
                    NULL, &m_pFooter, NULL, NULL, NULL, NULL, NULL);

    buffer.Clear();
    buffer.Printf( strHeaderString );
    AssembleShader( "", buffer.GetText(), buffer.GetUsed(), SASM_DONOTOPTIMIZE | SASM_SKIPVALIDATION,
                    NULL, &m_pHeader, NULL, NULL, NULL, NULL, NULL);

    SetLights();

    return hr;
}




//-----------------------------------------------------------------------------
// Name: SetLights()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::SetLights()
{
    HRESULT hr; 

    // Set the vertex shader constants as:
    //    c0..3 = World view position matrix
    //    c4    = Useful constants { 0.0f, 0.0f, 0.0f, 1.0f}
    const int dwLightPositionBase = 6;
    int       dwLightDiffuseBase  = dwLightPositionBase + 32;

    for( DWORD light = 0; light < m_dwNumLights; light++ )
    {
        float afLightPosition[4];
        float afLightDiffuse[4];
        ComputeLightPositionAndColor( light, afLightPosition, afLightDiffuse );
        m_pd3dDevice->SetVertexShaderConstant( dwLightPositionBase + light, afLightPosition, 1 );
        m_pd3dDevice->SetVertexShaderConstant( dwLightDiffuseBase + light,  afLightDiffuse,  1 );
    };

    float afConstants[4] = { 0.0f, 0.0f, 0.0f, 1.0f };
    m_pd3dDevice->SetVertexShaderConstant( 4, afConstants, 1 );

    // Splice the vertex shaders together
    DWORD  i;
    int    index=0;
    DWORD* shaderarray[32] = {0};

    shaderarray[index++] = (DWORD*)m_pHeader->pData;
    for( i = 0; i < (m_dwNumLights & ~3); i += 4 )
    {
        shaderarray[index++] = (DWORD*)m_pLight4[i >> 2]->pData;
    }
    for( ; i < m_dwNumLights; i++ ) 
    {
        shaderarray[index++] = (DWORD*)m_pLight1[i]->pData;
    }
    shaderarray[index++] = (DWORD*)m_pFooter->pData;

    // Get the size needed to splice the vertex shaders together
    DWORD size = 0;
    XGSpliceVertexShaders( NULL, &size, NULL, shaderarray, index,
                           OPTIMIZATIONS[m_dwOptimizationLevel] );

    // Splice the shaders together
    DWORD* pSplicedVertexShaderData = new DWORD[size/4];
    XGSpliceVertexShaders( pSplicedVertexShaderData, NULL, NULL, shaderarray, index,
                           OPTIMIZATIONS[m_dwOptimizationLevel] );

    // Create the vertex shader
    DWORD dwDecl[] =
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG( 0,  D3DVSDT_FLOAT3 ), // Position
        D3DVSD_REG( 1,  D3DVSDT_FLOAT3 ), // Normal
        D3DVSD_END()
    };

    hr = m_pd3dDevice->CreateVertexShader( dwDecl, pSplicedVertexShaderData, &m_dwShader, 0 );
    delete[] pSplicedVertexShaderData;

    return hr;
}

 
 

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x00000000, 1.0f, 0L );
    
    // Draw a gradient filled background
    RenderGradientBackground( 0xff000000, 0xff0000ff );

    // Set default state
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );

    // Draw the teapot
    m_pd3dDevice->SetVertexShader( m_dwShader );
    m_Teapot.Render( m_pd3dDevice, XBMESH_NOFVF|XBMESH_NOMATERIALS|XBMESH_NOTEXTURES );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR strBuffer[20];
        swprintf( strBuffer, L"Lights: %d", m_dwNumLights );
        WCHAR* strOptName[MAX_OPTIMIZATION_LEVELS] = { L"Optimizations: Off", L"Optimizations: On" };

        m_Font.DrawText(  64, 50, 0xffffffff, L"ShaderSplicer" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.DrawText(  64, 80, 0xffffffff, strBuffer );
        m_Font.DrawText(  64, 110,0xffffffff, strOptName[m_dwOptimizationLevel] );

    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\VSLights\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\VSLights\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\VSLights\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\VSLights\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\VSLights\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VisibilityTest\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VisibilityTest\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\StateShader\StateShader.cpp ===
//-----------------------------------------------------------------------------
// File: StateShader.cpp
//
// Desc: Illustrates using vertex state shaders.
//       This example uses a shader that inverts a matrix.
//
// Hist: 01.10.00 - New for February XDK release
//       
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBUtil.h>




//-----------------------------------------------------------------------------
// Define our triangle.
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{ 
    FLOAT x,y,z; 
    DWORD color; 
};

CUSTOMVERTEX g_Vertices[] =
{
    {-0.6f,-1.0f, 0.0f, 0xffff0000, },
    { 0.0f, 1.0f, 0.0f, 0xff00ff00, },
    { 0.6f,-1.0f, 0.0f, 0xff0000ff, },
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
	CXBFont	m_Font;

    DWORD   m_dwVertexShaderHandle;
    DWORD   m_dwVertexShaderAddress;
    DWORD   m_dwVertexStateShaderHandle;
    DWORD   m_dwVertexStateShaderAddress;

	D3DXMATRIX m_matProj;
 
public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

	// Calc projection matrix
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 480.0f / 640.0f, 1.0f, 800.0f );

	// Disable lighting so our diffuse colors show up
	m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    DWORD dwShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position
        D3DVSD_REG( 1, D3DVSDT_D3DCOLOR ), // Diffuse color
        D3DVSD_END()
    };

	// Create the vertex shader
	if( FAILED(XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\VertShdr.xvu", 
									      dwShaderVertexDecl, &m_dwVertexShaderHandle ) ) )
		return E_FAIL;

	// Load it into vertex shader memory at m_dwVertexShaderAddress
    DWORD ip = 0;
    UINT  length;

    m_dwVertexShaderAddress = ip;

	// get the size of the shader so we can load the state shader at the
	// following address
    if( FAILED( m_pd3dDevice->GetVertexShaderSize( m_dwVertexShaderHandle, &length ) ) )
        return E_FAIL;
    ip += length;

    // Create state shader and load it into vertex shader program memory
	// note that we pass null for the shader declaration because the
	// state shader does not use the vertex stream at all
    m_dwVertexStateShaderAddress = ip;
	if(FAILED(XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\MatInv.xvu", 
									     NULL, &m_dwVertexStateShaderHandle)))
		return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Rotate the object about its y axis
    D3DXMATRIX matWorld;
    D3DXMatrixRotationY( &matWorld, 1.6f*m_fAppTime );

	// Set our view matrix
    D3DXMATRIX matView;
	D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 6.0f );

	// Set the WVP matrix in the vertex shader    
    D3DXMATRIX mat;
    D3DXMatrixMultiply( &mat, &matWorld, &matView );
    D3DXMatrixMultiply( &mat, &mat, &m_matProj );
    D3DXMatrixTranspose( &mat, &mat );
    m_pd3dDevice->SetVertexShaderConstant( 0, &mat, 4 );

	// Run the state shader twice to invert and 'revert' the display matrix
	m_pd3dDevice->LoadVertexShader( m_dwVertexStateShaderHandle, m_dwVertexStateShaderAddress );
	m_pd3dDevice->SelectVertexShader( m_dwVertexStateShaderHandle, m_dwVertexStateShaderAddress ); 
	m_pd3dDevice->RunVertexStateShader( m_dwVertexStateShaderAddress, NULL );
	m_pd3dDevice->RunVertexStateShader( m_dwVertexStateShaderAddress, NULL );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the frame buffer, Zbuffer.
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         0x00404040, 1.0, 0 );

	// Restore state that font clobbers
    m_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    m_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
    m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
    m_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

	// Display the test triangle
	m_pd3dDevice->LoadVertexShader( m_dwVertexShaderHandle, m_dwVertexShaderAddress );
    m_pd3dDevice->SelectVertexShader( m_dwVertexShaderHandle, m_dwVertexShaderAddress ); 
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE  );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLELIST, 1, g_Vertices, 
                                   sizeof(g_Vertices[0]) );

	// Show title
	m_Font.Begin();
	m_Font.DrawText(  64, 50, 0xffffffff, L"StateShader" );
	m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
	m_Font.End();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VisibilityTest\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VisibilityTest\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VisibilityTest\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeFog\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeFog\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeFog\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeFog\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\vertexshader\VSLights\vslights.cpp ===
//-----------------------------------------------------------------------------
// File: VSLights.cpp
//
// Desc: Example code showing how to assemble vertex shaders on the fly.
//
// Hist: 03.15.00 - Changes for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>
#include <xgraphics.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Rotate" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_1, L"Zoom" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"More Lights" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, L"Fewer Lights" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_1, L"Change Optimization Level" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle help" },
};

#define NUM_HELP_CALLOUTS 6




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
#define MAX_OPTIMIZATION_LEVELS 3

const DWORD MAX_LIGHTS[MAX_OPTIMIZATION_LEVELS]    =  {22,26,28};
const int   OPTIMIZATIONS[MAX_OPTIMIZATION_LEVELS] = { SASM_DONOTOPTIMIZE, SASM_DISABLE_GLOBAL_OPTIMIZATIONS, 0};




//-----------------------------------------------------------------------------
// A simple string buffer utility class
//-----------------------------------------------------------------------------
class StringBuffer 
{
    DWORD m_size;
    CHAR* m_buf;
    DWORD m_used;

public:
    StringBuffer() { m_size = 0; m_buf = NULL; m_used = 0; }

    ~StringBuffer() { delete [] m_buf; }

    HRESULT Initialize( DWORD size )
    {
        m_used = 0;
        return GrowTo( size );
    }

    HRESULT GrowTo( DWORD size )
    {
        HRESULT hr = S_OK;
        if(size+1>m_size)
        {
            size += 4*1024;
            char* newBuf = new char[size];

            if(!newBuf)
                hr = E_OUTOFMEMORY;
            else
            {
                memcpy(newBuf,m_buf, m_used);
                delete [] m_buf;
                m_buf = newBuf;
                m_size = size;
                m_buf[m_used] = 0;
            }
        }
        return hr;
    }

    HRESULT Printf( const char *msg, ... )
    {
        HRESULT hr = S_OK;
        if(m_size - m_used < 1000)
            hr = GrowTo(m_size + 2000);

        if(SUCCEEDED(hr))
        {
            va_list list;
            va_start(list, msg );
            m_used += _vsnprintf(m_buf + m_used, m_size - m_used, msg, list);
            va_end(list);
        }
        return hr;
    }

    HRESULT Append(LPCVOID data, DWORD length)
    {
        HRESULT hr = GrowTo(m_used + length);

        if(SUCCEEDED(hr))
        {
            memcpy(m_buf + m_used, data, length);
            m_used += length;
            m_buf[m_used] = '\0';
        }
        return hr;
    }

    HRESULT Append(char c) {return Append(&c, sizeof(char));}
    HRESULT Append(const char* c) {return Append(c, strlen(c));}
    HRESULT Append(StringBuffer& buffer) 
                {return Append(buffer.GetText(), buffer.GetUsed());}
    char *GetText() {return m_buf;}
    char *GetTextEnd() {return m_buf + m_used;}
    DWORD GetUsed() {return m_used;}

    void Clear()
    {
        m_used = 0;
        if(m_buf)
            m_buf[0] = 0;
    }
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont    m_Font;                     // Font class
    CXBHelp    m_Help;                     // Help class
    BOOL       m_bDrawHelp;                // Whether to draw help

    D3DXMATRIX m_matProj;

    DWORD      m_dwNumLights;              // Num lights to render
    DWORD      m_dwShader;                 // The current shader
    int        m_iOpt;                     // The current optimization number

    CXBMesh    m_Teapot;

    HRESULT CreateShader();
    HRESULT ComputeLightPositionAndColor( DWORD dwIndex, FLOAT* fLightPosition,
                                          FLOAT* pfLightDiffuse );

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    m_bDrawHelp = FALSE;
    m_dwNumLights = 4;
    m_dwShader = 0;
    m_iOpt = MAX_OPTIMIZATION_LEVELS-1;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set up proj matrix
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 200.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    // Create a mesh (vertex and index buffers) for the teapot
    if( FAILED( m_Teapot.Create( m_pd3dDevice, "Models\\Teapot.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set up a shader
    HRESULT hr = CreateShader();
    if( FAILED(hr) )
        return hr;

    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
      m_bDrawHelp = !m_bDrawHelp;

    // Add or remove lights
    bool lightsChanged = false;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
    {
        m_iOpt++; 
        if(m_iOpt >= MAX_OPTIMIZATION_LEVELS) 
        {
            m_iOpt = 0;
        }
        lightsChanged = true;
        if(m_dwNumLights > MAX_LIGHTS[m_iOpt]) {
            m_dwNumLights = MAX_LIGHTS[m_iOpt];
        }
    }

    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
    {
        if( m_dwNumLights < MAX_LIGHTS[m_iOpt] )
        {
            m_dwNumLights++;
            lightsChanged = true;
        }
    }
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
    {
        if( m_dwNumLights > 0 )
        {
            m_dwNumLights--;
            lightsChanged = true;
        }
    }
    if(lightsChanged)
    {
        HRESULT hr = CreateShader();
        if(FAILED(hr))
        {
            m_dwNumLights = 0;
            hr = CreateShader();
            if(FAILED(hr))
                return hr;
        }
    }

    // Set up view matrix
    static D3DXVECTOR3 vEyePt( 0,0,-6 );
    if( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP )
        vEyePt.z += 10.0f*m_fElapsedTime;
    if( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        vEyePt.z -= 10.0f*m_fElapsedTime;

    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &D3DXVECTOR3(0,0,0), &D3DXVECTOR3(0,1,0) );

    // Setup object matrix
    D3DXMATRIX matRotate;
    FLOAT fXRotate = m_DefaultGamepad.fX1*D3DX_PI*m_fElapsedTime;
    FLOAT fYRotate = m_DefaultGamepad.fY1*D3DX_PI*m_fElapsedTime;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate, -fYRotate, 0.0f );
    
    static D3DXMATRIX  matWorld( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );
    matWorld._41 = matWorld._42 = 0.f;
    D3DXMatrixMultiply( &matWorld, &matWorld, &matRotate );

    // Set the WVP matrix in the vertex shader    
    D3DXMATRIX mat;
    D3DXMatrixMultiply( &mat, &matWorld, &matView );
    D3DXMatrixMultiply( &mat, &mat, &m_matProj );
    D3DXMatrixTranspose( &mat, &mat );
    m_pd3dDevice->SetVertexShaderConstant( 0, &mat, 4 );

    return S_OK;
}




void HSVToRGB(float h, float s, float v, float* pRGB)
{
    float hue;
    int sector;
    float fraction, m, n;

    hue = (float)(h - floor(h))* 6.0f; // 0..6
    sector = (int)floor(hue);
    fraction = hue - sector;

    if((sector&1)== 0) // if i is even
        fraction = 1.0f - fraction;

    m = v * (1-s);  
    n = v * (1-s*fraction);

    switch (sector) 
    {  
        case 6:  
        case 0: pRGB[0] = v; pRGB[1] = n; pRGB[2] = m; break;  
        case 1: pRGB[0] = n; pRGB[1] = v; pRGB[2] = m; break;  
        case 2: pRGB[0] = m; pRGB[1] = v; pRGB[2] = n; break;  
        case 3: pRGB[0] = m; pRGB[1] = n; pRGB[2] = v; break;  
        case 4: pRGB[0] = n; pRGB[1] = m; pRGB[2] = v; break;  
        case 5: pRGB[0] = v; pRGB[1] = m; pRGB[2] = n; break;  
    }
}




HRESULT CXBoxSample::ComputeLightPositionAndColor(DWORD index, float* lightPosition, float* lightDiffuse)
{
    float u, theta, lightRadius;
    float hue, sat, value;

    u = (float)index / m_dwNumLights;
    theta = 3.14159f * 2 * u;
    lightRadius = 20.0f;

    lightPosition[0] = cosf(theta) * lightRadius; // x
    lightPosition[1] = sinf(theta) * lightRadius; // y
    lightPosition[2] = sinf(theta) * lightRadius; // z
    lightPosition[3] = 1.0;             // w

    hue = (float)index / 6.0f;
    sat = 1.0;
    value = (m_dwNumLights<5.0f) ? 1.0f : 5.0f/m_dwNumLights;

    HSVToRGB(hue, sat, value, lightDiffuse);

    lightDiffuse[3] = 1.0;              // alpha
    
    return S_OK;
}




HRESULT CXBoxSample::CreateShader()
{
    HRESULT hr = S_OK;

    // Delete the old vertex shader
    if(m_dwShader)
    {
        m_pd3dDevice->DeleteVertexShader(m_dwShader);
        m_dwShader = 0;
    }

    // Compile the new vertex shader
    StringBuffer buffer;

    hr = buffer.Initialize(1024);
    if(FAILED(hr))
        return hr;

    // Constants 0..3 - world view position matrix
    // Constant 4 - useful constants { 0.f, 0.f, 0.f, 1.f}
    const int dwLightPositionBase = 6;
    int       dwLightDiffuseBase  = dwLightPositionBase + MAX_LIGHTS[m_iOpt];

    // How many instructions in an Xbox vertex shader? It depends.
    // There are 136 slots, and shaders have an overhead of two slots,
    // which leaves 134 slots for instructions.
    // The prefix takes 5 instructions.
    // Each light macro takes 7 instructions
    // Each group of 4 lights takes 22 instructions
    // And the postfix takes 1 instruction.
    // So there should be room for about 22 lights.
    // However, the shader assembler is able to optimize the code,
    // to use fewer slots. With global or local optimizations, there
    // is room for 28 lights.

    const char* strPrefix =
        "xvs.1.1\n"
        "\n"
        "#define R_LIGHT_COEF r8\n"
        "#define R_VERTEX_TO_LIGHT r9\n"
        "#define R_FINAL_COLOR r11\n"
        "#define XYZW_LIGHT_N_DOT_L x\n"
        "#define XYZW_V_TO_L_DIST w\n"
        "#define ZERO c4.x\n"
        "\n"
        "macro addLight Position, Diffuse\n"
        "add R_VERTEX_TO_LIGHT, c[%Position],-v0\n"
        "dp3 R_VERTEX_TO_LIGHT.XYZW_V_TO_L_DIST, R_VERTEX_TO_LIGHT, R_VERTEX_TO_LIGHT\n"
        "rsq R_VERTEX_TO_LIGHT.XYZW_V_TO_L_DIST, R_VERTEX_TO_LIGHT.XYZW_V_TO_L_DIST\n"
        "dp3 R_LIGHT_COEF.XYZW_LIGHT_N_DOT_L, v1, R_VERTEX_TO_LIGHT\n"
        "max R_LIGHT_COEF.XYZW_LIGHT_N_DOT_L, R_LIGHT_COEF.XYZW_LIGHT_N_DOT_L, ZERO\n"
        "mul R_LIGHT_COEF.XYZW_LIGHT_N_DOT_L, R_LIGHT_COEF.XYZW_LIGHT_N_DOT_L, R_VERTEX_TO_LIGHT.XYZW_V_TO_L_DIST\n"
        "mad R_FINAL_COLOR, R_LIGHT_COEF.XYZW_LIGHT_N_DOT_L, c[%Diffuse], R_FINAL_COLOR\n"
        "endm\n"
        "\n"
        "macro addLight4 Position, Diffuse\n"
        "add r9,		c[%Position],					-v0\n"
        "dp3 r9.w,	r9,		r9\n"
        "rsq r1.w,	r9.w\n"
        "dp3 r2.w,	v1,		r9\n"

        "add r7,		c[%inc(%Position)],				-v0\n"
        "dp3 r7.w,	r7,		r7\n"
        "rsq r1.z,	r7.w\n"
        "dp3 r2.z,	v1,		r7\n"

        "add r5,		c[%inc(%inc(%Position))],		-v0\n"
        "dp3 r5.w,	r5,		r5\n"
        "rsq r1.y,	r5.w\n"
        "dp3 r2.y,	v1,		r5\n"

        "add r3,		c[%inc(%inc(%inc(%Position)))],	-v0\n"
        "dp3 r3.w,	r3,		r3\n"
        "rsq r1.x,	r3.w\n"
        "dp3 r2.x,	v1,		r3\n"
        "\n"
        "max r2.xyzw,r2.xyzw,c4.xxxx\n"
        "mul r2.xyzw,r2.xyzw,r1.xyzw\n"
        "\n"
        "mad R_FINAL_COLOR,	r2.w,	c[%Diffuse],					R_FINAL_COLOR\n"
        "mad R_FINAL_COLOR,	r2.z,	c[%inc(%Diffuse)],				R_FINAL_COLOR\n"
        "mad R_FINAL_COLOR,	r2.y,	c[%inc(%inc(%Diffuse))],		R_FINAL_COLOR\n"
        "mad R_FINAL_COLOR,	r2.x,	c[%inc(%inc(%inc(%Diffuse)))],	R_FINAL_COLOR\n"
        "endm\n"
        "\n"
        "m4x4 oPos,v0,c0\n"
        "mov R_FINAL_COLOR,c4\n"; // Initial color - opaque black

    const char* strLightMacro =
        "addLight %d,%d\n";
    const char* strLightMacro4 =
        "addLight4 %d,%d\n";

    const char* strPostfix =
        "mov oD0,R_FINAL_COLOR\n";

    // Emit the prefix
    hr = buffer.Append( strPrefix );
    if( FAILED(hr) )
        return hr;

    DWORD light;
    for( light = 0; light < (m_dwNumLights & ~3); light += 4 ) 
    {
        hr = buffer.Printf( strLightMacro4, dwLightPositionBase + light, dwLightDiffuseBase + light );
        if( FAILED(hr) )
            return hr;
    }
    for( ; light < m_dwNumLights; light++ ) 
    {
        hr = buffer.Printf( strLightMacro, dwLightPositionBase + light, dwLightDiffuseBase + light );
        if( FAILED(hr) )
            return hr;
    }

    for(light = 0; light < m_dwNumLights; light++)
    {
        float lightPosition[4];
        float lightDiffuse[4];
        ComputeLightPositionAndColor(light, lightPosition, lightDiffuse);
        m_pd3dDevice->SetVertexShaderConstant( dwLightPositionBase + light, lightPosition, 1 );
        m_pd3dDevice->SetVertexShaderConstant( dwLightDiffuseBase + light,  lightDiffuse,  1 );
    };

    hr = buffer.Append( strPostfix );
    if( FAILED(hr) )
        return hr;

    float fConstants[4] = {0.f,0.f,0.f,1.f};
    m_pd3dDevice->SetVertexShaderConstant( 4, fConstants, 1 );

    LPXGBUFFER pUcode;
    hr = AssembleShader( "", buffer.GetText(), buffer.GetUsed(), OPTIMIZATIONS[m_iOpt], NULL,
                         &pUcode, NULL, NULL, NULL, NULL, NULL );
    if( FAILED(hr) )
        return hr;

    // Create the vertex shader
    DWORD dwDecl[] =
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG( 0,  D3DVSDT_FLOAT3 ), // Position
        D3DVSD_REG( 1,  D3DVSDT_FLOAT3 ), // Normal
        D3DVSD_END()
    };

    hr = m_pd3dDevice->CreateVertexShader( dwDecl, (DWORD*)pUcode->pData,
                                           &m_dwShader, 0 );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );
    
    // Draw a gradient filled background
    RenderGradientBackground( 0xff000000, 0xff0000ff );

    // Set default state
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE);

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );

    // Draw the teapot
    m_pd3dDevice->SetVertexShader( m_dwShader );
    m_Teapot.Render( m_pd3dDevice, XBMESH_NOFVF|XBMESH_NOMATERIALS|XBMESH_NOTEXTURES );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR buf[20];
        swprintf( buf, L"Lights: %d", m_dwNumLights );
        WCHAR* strOptName[MAX_OPTIMIZATION_LEVELS] = {L"Optimizations: None", L"Optimizations: Local",L"Optimizations: Global"};

        m_Font.DrawText(  64, 50, 0xffffffff, L"VSLights" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.DrawText(  64, 80, 0xffffffff, buf );
        m_Font.DrawText(  64, 110,0xffffffff, strOptName[m_iOpt] );
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VisibilityTest\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Floor_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeFog\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeFog\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 8UL

#define Resource_Treebark_OFFSET 0UL
#define Resource_VolGroun_OFFSET 20UL
#define Resource_SkyBoxXN_OFFSET 40UL
#define Resource_SkyBoxXP_OFFSET 60UL
#define Resource_SkyBoxYN_OFFSET 80UL
#define Resource_SkyBoxYP_OFFSET 100UL
#define Resource_SkyBoxZN_OFFSET 120UL
#define Resource_SkyBoxZP_OFFSET 140UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeLight\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VisibilityTest\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Floor_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeLight\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeLight\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeLight\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 9UL

#define resource_Light_OFFSET 0UL
#define resource_SkyBoxXP_OFFSET 20UL
#define resource_SkyBoxXN_OFFSET 40UL
#define resource_SkyBoxYP_OFFSET 60UL
#define resource_SkyBoxYN_OFFSET 80UL
#define resource_SkyBoxZP_OFFSET 100UL
#define resource_SkyBoxZN_OFFSET 120UL
#define resource_StoneHen_OFFSET 140UL
#define resource_StoneHea_OFFSET 160UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeFog\VolumeFog.cpp ===
//-----------------------------------------------------------------------------
// File: VolumeFog.cpp
//
// Desc: Example of fogging using an arbitrary fog volume.
//
// Hist: 02.21.00 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBUtil.h>

#include "D3D8Perf.h"

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "TreeBark.bmp", Resource_Treebark_OFFSET },
    { "VolGroun.bmp", Resource_VolGroun_OFFSET },
    { "SkyBoxXP.bmp", Resource_SkyBoxXP_OFFSET },
    { "SkyBoxXN.bmp", Resource_SkyBoxXN_OFFSET },
    { "SkyBoxYP.bmp", Resource_SkyBoxYP_OFFSET },
    { "SkyBoxYN.bmp", Resource_SkyBoxYN_OFFSET },
    { "SkyBoxZP.bmp", Resource_SkyBoxZP_OFFSET },
    { "SkyBoxZN.bmp", Resource_SkyBoxZN_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move camera" },
    { XBHELP_LEFT_BUTTON,  XBHELP_PLACEMENT_1, L"Move Out" },
    { XBHELP_RIGHT_BUTTON, XBHELP_PLACEMENT_1, L"Move In" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS (sizeof(g_HelpCallouts)/sizeof(g_HelpCallouts[0]))




//-----------------------------------------------------------------------------
// Custom vertex types
//-----------------------------------------------------------------------------
struct FOGVERT
{
    FOGVERT(const D3DXVECTOR4& pos, float u1, float v1, float u2, float v2)
    {
        Pos = pos;
        U1 = u1;
        V1 = v1;
        U2 = u2;
        V2 = v2;
    }

    D3DXVECTOR4 Pos;
    float U1, V1;
    float U2, V2;
    float S3, T3, R3, Q3;
    float S4, T4, R4, Q4;
};


FOGVERT g_FogVerts[] =
{
    FOGVERT( D3DXVECTOR4(   0 - 0.5f,   0 - 0.5f, 0.0f, 1.0f ),   0,   0,   0,   0 ),
    FOGVERT( D3DXVECTOR4( 640 - 0.5f,   0 - 0.5f, 0.0f, 1.0f ), 640,   0, 640,   0 ),
    FOGVERT( D3DXVECTOR4( 640 - 0.5f, 480 - 0.5f, 0.0f, 1.0f ), 640, 480, 640, 480 ),
    FOGVERT( D3DXVECTOR4(   0 - 0.5f, 480 - 0.5f, 0.0f, 1.0f ),   0, 480,   0, 480 ),
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont            m_Font;               // Font class
    CXBHelp            m_Help;               // Help class
    BOOL               m_bDrawHelp;          // Whether to draw help

    CXBMesh            m_Room;               // XBG file object to render
    CXBMesh            m_FogVolume;          // Fog hull.

    CXBMesh            m_SkyboxObject;

    float              m_fFogVolumeRadius;   // Radius of the fog volume.

    D3DXVECTOR3        m_vEye;
    D3DXMATRIX         m_matWorld;
    D3DXMATRIX         m_matView;
    D3DXMATRIX         m_matProjection;

    DWORD              m_dwFogVertexShader;
    DWORD              m_dwFogPixelShader;

    IDirect3DTexture8 *m_pFogBufferNear;
    IDirect3DTexture8 *m_pFogBufferFar;

    IDirect3DTexture8 *m_pDepthTexture;
    IDirect3DSurface8 *m_pColorBuffer;
    IDirect3DSurface8 *m_pZBuffer;

    HRESULT RenderScene();

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    HRESULT CreatePixelShader();
    HRESULT CreateTextures();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    m_bDrawHelp     = false;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      Resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the skybox
    if( FAILED( m_SkyboxObject.Create( m_pd3dDevice, "Models\\SkyBox.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the main file object
    if( FAILED( m_Room.Create( m_pd3dDevice, "Models\\VolFogTerrain.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the main file object
    if( FAILED( m_FogVolume.Create( m_pd3dDevice, "Models\\VolFogFog.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    
    // Save radius for later use.
    m_fFogVolumeRadius = m_FogVolume.ComputeRadius();

    // Create vertex shader.
    DWORD vdecl[] =
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG(0, D3DVSDT_FLOAT3), // v0 = XYZ
        D3DVSD_REG(1, D3DVSDT_FLOAT3), // v1 = normals
        D3DVSD_END()
    };

    if ( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\DepthShader.xvu", vdecl, &m_dwFogVertexShader ) ) )
        return E_FAIL;

    // Create render targets for fog depth.
    m_pd3dDevice->CreateTexture( 640, 480, 1, D3DUSAGE_RENDERTARGET, D3DFMT_LIN_A8R8G8B8, 0, &m_pFogBufferNear );
    m_pd3dDevice->CreateTexture( 640, 480, 1, D3DUSAGE_RENDERTARGET, D3DFMT_LIN_A8R8G8B8, 0, &m_pFogBufferFar );

    CreateTextures();
    CreatePixelShader();

    // Get the original color and z-buffer.
    m_pd3dDevice->GetRenderTarget(&m_pColorBuffer);
    m_pd3dDevice->GetDepthStencilSurface(&m_pZBuffer);

    // Set the matrices
    D3DXMatrixIdentity( &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );

    m_vEye = D3DXVECTOR3( 10.0f, 5.0f, 0.0f );
    D3DXVECTOR3 vAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

    D3DXMatrixLookAtLH( &m_matView, &m_vEye, &vAt, &vUp );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    D3DXMatrixPerspectiveFovLH( &m_matProjection, D3DX_PI/3, 4.0f/3.0f, 0.1f, 40.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProjection );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DXMATRIX matView, matRotate;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    D3DXVECTOR3 vAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

    // Rotate eye around up axis.
    D3DXMatrixRotationAxis( &matRotate, &vUp, 
                                        m_DefaultGamepad.fX1*m_fElapsedTime );
    D3DXVec3TransformCoord( &m_vEye, &m_vEye, &matRotate );

    // Rotate eye points around side axis.
    D3DXVECTOR3 vView = (vAt - m_vEye);
	float dist = D3DXVec3Length( &vView );

    D3DXVec3Normalize( &vView, &vView );

    // Place limits so we dont go over the top or under the bottom.
    FLOAT dot = D3DXVec3Dot( &vView, &vUp );
    if( (dot < 0.0f/*0.99f*/ || m_DefaultGamepad.fY1 < 0.0f) && (dot > -0.99f || m_DefaultGamepad.fY1 > 0.0f) )
    {
        D3DXVECTOR3 axis;
        D3DXVec3Cross( &axis, &vView, &vUp );
        D3DXMatrixRotationAxis( &matRotate, &axis, m_DefaultGamepad.fY1 * m_fElapsedTime );
        D3DXVec3TransformCoord( &m_vEye, &m_vEye, &matRotate );
    }

    // Move in/out.
    float fIn = (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] / 255.0f);
    float fOut = (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] / 255.0f);


    if( fIn > 0.1f  && dist > 1.0f )
        m_vEye += vView * 4.0f * fIn * m_fElapsedTime;

    if( fOut > 0.1f )
        m_vEye -= vView * 4.0f * fOut * m_fElapsedTime;

    D3DXMatrixLookAtLH( &m_matView, &m_vEye, &vAt, &vUp );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateTextures()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateTextures()
{
    HRESULT hr;

    // Create a 4k x 1 texture to encode the depth values.
    {
        hr = m_pd3dDevice->CreateTexture( 4096, 1, 1, 0, D3DFMT_A8R8G8B8, 0, &m_pDepthTexture );

        // Lock and fill the texture
        D3DSURFACE_DESC desc;
        D3DLOCKED_RECT lock;
        m_pDepthTexture->GetLevelDesc( 0, &desc );
        m_pDepthTexture->LockRect( 0, &lock, 0, 0 );
        DWORD* pBits = (DWORD*)lock.pBits;

        for( int v = 0; v < 1; v++ )
        {
            for( int u = 0; u < 4096; u++ )
            {
                int blue =  (u & 0x00f00) >> 8;
                int green = (u & 0x000f0) >> 4;
                int red =   (u & 0x0000f);
                (*pBits++) = (red << 16) | (green << 8) | blue;
            }
        }
        
        // Swizzle and unlock the texture
        XBUtil_SwizzleTexture2D( &lock, &desc );
        m_pDepthTexture->UnlockRect( 0 );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreatePixelShader()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreatePixelShader()
{
    //
    // Setup the pixel shader 
    //
    // Fog depth is 12 bits split up as follows:
    //
    // B = 4 bits for carry + 4 high bits of fog.
    // G = 4 bits for carry + 4 middle bits of fog.
    // R = 4 bits for carry + 4 low bits of fog.
    //
    // Compute dB * 16 + dG + dR / 16
    //
    //
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 4,
                                            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_PROJECT2D,
                                           PS_TEXTUREMODES_NONE, PS_TEXTUREMODES_NONE );
    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 0, 0 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0, PS_DOTMAPPING_ZERO_TO_ONE,
                                         PS_DOTMAPPING_ZERO_TO_ONE, PS_DOTMAPPING_ZERO_TO_ONE );
    psd.PSCompareMode   = PS_COMPAREMODE( PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    psd.PSC0Mapping = 0xffffffff;
    psd.PSC1Mapping = 0xffffffff;
    psd.PSFinalCombinerConstants = 0x000000ff;

    //------------- Stage 0 -------------
    // r1 = T1-T0
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS( PS_REGISTER_T0 | PS_INPUTMAPPING_SIGNED_NEGATE | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                               PS_REGISTER_T1 | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );

    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R1,
                                                0 );

    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_T0 | PS_INPUTMAPPING_SIGNED_NEGATE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_T1 | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );

    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R1,
                                                0 );

    //------------- Stage 1 -------------
    // r0.rgb = G + 1/16 * R = r1.rgb dot (0,1/16,1,0)
    psd.PSRGBInputs[1]    = PS_COMBINERINPUTS( PS_REGISTER_R1 | PS_INPUTMAPPING_SIGNED_IDENTITY | PS_CHANNEL_RGB,
                                               PS_REGISTER_C0 | PS_CHANNEL_RGB,
                                               PS_REGISTER_ZERO | PS_CHANNEL_RGB,
                                               PS_REGISTER_ZERO | PS_CHANNEL_RGB );

    psd.PSRGBOutputs[1]   = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_DOT_PRODUCT | PS_COMBINEROUTPUT_CD_DOT_PRODUCT );

    // r0.a = B * 4 = r1.b << 2
    psd.PSAlphaInputs[1]  = PS_COMBINERINPUTS( PS_REGISTER_R1 | PS_INPUTMAPPING_SIGNED_IDENTITY | PS_CHANNEL_BLUE,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ZERO | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ZERO | PS_CHANNEL_ALPHA );

    psd.PSAlphaOutputs[1] = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_SHIFTLEFT_2 );

    psd.PSConstant0[1] = 0x0010ff00;

    //------------- Stage 2 -------------
    // r0.a = B * 16 = r0.a << 2
    psd.PSAlphaInputs[2]  = PS_COMBINERINPUTS( PS_REGISTER_R0 | PS_INPUTMAPPING_SIGNED_IDENTITY | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_R0 | PS_INPUTMAPPING_SIGNED_IDENTITY | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );

    psd.PSAlphaOutputs[2] = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_R1,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_SHIFTLEFT_2 );

    //------------- Stage 3 -------------
    // r0.a = B * 16 + G + R * 1/16 = r0.a + r0.b
    psd.PSAlphaInputs[3]  = PS_COMBINERINPUTS( PS_REGISTER_R0 | PS_INPUTMAPPING_SIGNED_IDENTITY | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_R0 | PS_INPUTMAPPING_SIGNED_IDENTITY | PS_CHANNEL_BLUE,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );

    psd.PSAlphaOutputs[3] = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                0 );

    psd.PSConstant0[3] = 0x00ff0000;



    //------------- Final combiner -------------
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_ZERO | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO | PS_CHANNEL_RGB,
                                                       PS_REGISTER_C0   | PS_CHANNEL_RGB );

    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_ZERO | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ZERO | PS_CHANNEL_RGB,
                                                      PS_REGISTER_R0   | PS_CHANNEL_ALPHA,
                                                      0 );

	// Fog color.
    psd.PSFinalCombinerConstant0 = 0xffffffff;

    // Create the pixel shader, as defined above.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwFogPixelShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderScene()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderScene()
{
    // Set up the light
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, 0.7071067f, 0.7071067f, 0.0f );
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );

    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x00555555 );

    // Draw the room.
    m_Room.Render( m_pd3dDevice );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport, zbuffer, and stencil buffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00008000f, 1.0f, 0 );

    // Set state
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0x44444444 );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,     TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,   FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the Skybox
    {
        D3DXMatrixIdentity( &m_matWorld );
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
        
        // Center view matrix for skybox and disable zbuffer
        D3DXMATRIX matView, matViewSave;
        m_pd3dDevice->GetTransform( D3DTS_VIEW,      &matViewSave );
        matView = matViewSave;
        matView._41 = 0.0f; matView._42 = -0.0f; matView._43 = 0.0f;
        m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );

        // Render the skybox
        m_SkyboxObject.Render( m_pd3dDevice );

        // Restore the render states
        m_pd3dDevice->SetTransform( D3DTS_VIEW, &matViewSave );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    }

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    // Set up misc render states
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_LESSEQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    // Render the scene normally.
    RenderScene();

    //
    // Setup common state for all passes.
    //
    m_pd3dDevice->SetVertexShader( m_dwFogVertexShader );

    // Calculate and set composite matrix.
    D3DXMATRIX matComposite, matWorldViewInverse, matProjectionViewport;
    D3DXMatrixMultiply( &matComposite, &m_matWorld, &m_matView );
    D3DXMatrixInverse( &matWorldViewInverse, NULL, &matComposite );
    m_pd3dDevice->GetProjectionViewportMatrix( &matProjectionViewport );
    D3DXMatrixMultiply( &matComposite, &matComposite, &matProjectionViewport );
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 0, &matComposite, 4 );

    // Set viewport offsets.
    float fViewportOffsets[4] = { 0.53125f, 0.53125f, 0.0f, 0.0f };
    m_pd3dDevice->SetVertexShaderConstant( 4, &fViewportOffsets, 1 );

    // Set local viewer position.
    D3DXVECTOR3 v3ViewPos( 0.0f, 0.0f, 0.0f );
    D3DXVec3TransformCoord( &v3ViewPos, &v3ViewPos, &matWorldViewInverse );
    m_pd3dDevice->SetVertexShaderConstant( 5, &v3ViewPos, 1 );

    // Scale distance values between 0 and 1.
    float fFogScale[4];
    fFogScale[0] = 1.0f / 40.0f;    // scale
    fFogScale[1] = 0.0f;            // offset (scaled)
    m_pd3dDevice->SetVertexShaderConstant( 6, fFogScale, 1 );

    //
    // Pass 0: Setup the stencil values correctly for when the viewpoint is in
    //         the fog volume.
    //
    m_pd3dDevice->SetTexture( 0, NULL );

    m_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_ALWAYS );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE, TRUE );

    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, 0 );

    // Increment back faces.
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS, D3DSTENCILOP_INCRSAT );
    m_FogVolume.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOTEXTURES );

    // Decrement front faces.
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS, D3DSTENCILOP_DECRSAT );
    m_FogVolume.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOTEXTURES );

    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALL );

    //
    // Common setup for the following passes.
    //
    m_pd3dDevice->SetTexture( 0, m_pDepthTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT  );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT  );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

    m_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_LESSEQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE, TRUE );

    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );

    //
    // Pass 1: Draw the visible front faces of the fog volume(s) with additive 
    //         blend.  Increment stencil values.
    //
    IDirect3DSurface8* surf;
    m_pFogBufferNear->GetSurfaceLevel( 0, &surf );
    m_pd3dDevice->SetRenderTarget( surf, m_pZBuffer );
    surf->Release();

    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0L );

    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS, D3DSTENCILOP_INCRSAT );

    m_FogVolume.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOTEXTURES );

    //
    // Pass 2: Draw the visible back faces of the fog volume(s) with additive 
    //         blend.  Decrement stencil values.
    //
    m_pFogBufferFar->GetSurfaceLevel( 0, &surf );
    m_pd3dDevice->SetRenderTarget( surf, m_pZBuffer );
    surf->Release();

    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0L );

    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS, D3DSTENCILOP_DECRSAT );

    m_FogVolume.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOTEXTURES );

    // If the viewpoint is in the fog, then we should start the stencil at one
    // instead of zero.

    //
    // Pass 3: Draw any objects intersecting the fog volume.  Add to the far
    //         values where stencil != 0 (where the object is inside the fog).
    //
    // Note: Z invariance needs to be maintained.
    //
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_EQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS, D3DSTENCILOP_KEEP );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFUNC, D3DCMP_NOTEQUAL );

    m_Room.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOTEXTURES );

    //
    // Pass 4: Compute the final fog value for each pixel and apply it.
    //
    m_pd3dDevice->SetRenderTarget( m_pColorBuffer, m_pZBuffer );

    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_BLENDOP, D3DBLENDOP_ADD );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFUNC, D3DCMP_ALWAYS );

    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_TEX4 | D3DFVF_TEXCOORDSIZE4(2) | D3DFVF_TEXCOORDSIZE4(3) );
    m_pd3dDevice->SetPixelShader( m_dwFogPixelShader );

    m_pd3dDevice->SetTexture( 0, m_pFogBufferNear );
    m_pd3dDevice->SetTexture( 1, m_pFogBufferFar );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_POINT );

    // Draw the overlay polygon.
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, g_FogVerts, sizeof(FOGVERT) );

    //
    // Restore state.
    //
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR  );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR  );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
    m_pd3dDevice->SetPixelShader(0);

    // Show title, frame rate, and help
    if( m_bDrawHelp )
    {
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    }
    else
    {
        // Show frame rate
        m_Font.DrawText(  64, 50, 0xffffffff, L"VolumeFog" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VisibilityTest\VisibilityTest.cpp ===
//-----------------------------------------------------------------------------
// File: VisibilityTest.cpp
//
// Desc: Illustrates how to do visibility testing on the XBox.
//
//       This sample draws two objects. One is possibly occluded by the other.
//       After starting the vis test on the back object, we wait for the
//       test to complete before either rendering or not rendering the object.
//       In a real game situation, you would do several different things...
//       First, you would intertwine vis tests with actual rendering so the
//       vis test would have time to complete before you check the results.
//       Second when you finally got around to checking the results, if a test
//       had not yet concluded, you would either draw additional geometry, or
//       if no additional geometry was able to be drawn, proceed as if the 
//       object was visible. The point is to not sit around waiting for tests 
//       to conclude. The graphics pipe needs to be busy 100% of the time.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>

#include "resource.h"

#include <xpath.h>
#include <xmenu.h>
#include <xobj.h>




//-----------------------------------------------------------------------------
// Help screen definitions
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] =
{
    { XBHELP_LEFTSTICK,   XBHELP_PLACEMENT_1, L"Move wall in X, Y" },
    { XBHELP_RIGHTSTICK,  XBHELP_PLACEMENT_1, L"Move wall in Z" },
    { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, L"Display\nhelp" },
};
#define NUM_HELP_CALLOUTS 3


//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "floor.bmp", resource_Floor_OFFSET },
    { NULL, 0 },
};



//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont     m_Font;
    CXBHelp     m_Help;
    BOOL        m_bDrawHelp;

    D3DXVECTOR3 m_vCameraPos;
    D3DXVECTOR3 m_vCameraRot;

    CXBPackedResource  m_xprResource;

    CXObject    m_WallObj;
    CXObject    m_SphereObj;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp  = FALSE;

    m_vCameraPos = D3DXVECTOR3( 0.0f, 0.0f,-15.0f );
    m_vCameraRot = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create a font
    if( FAILED( hr = m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the help system
    if( FAILED( hr = m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 0.1f, 1000.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set the view matrix based on the camera position
    D3DXMATRIX matView;
    D3DXMatrixTranslation( &matView, -m_vCameraPos.x, -m_vCameraPos.y, -m_vCameraPos.z);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set base path for creating/loading geometry
    XPath_SetBasePath( _T("D:\\Media\\") );

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

	// set pointer to resources for models
	g_pModelResource = &m_xprResource;

    // Create the wall object
    m_WallObj.m_Model = new CXModel;
    m_WallObj.m_Model->GridXZ( 16, 16, 20.0f, 20.0f, FVF_XYZTEX1, "floor.bmp", 20.0f, 20.0f);
    m_WallObj.SetPosition(0.0f, 0.0f, 20.0f);
    m_WallObj.m_vRotation.y = +(D3DX_PI/2.0f);
    m_WallObj.m_vRotation.z = -(D3DX_PI/2.0f);

    // Create the sphere object
    m_SphereObj.m_Model = new CXModel;
    m_SphereObj.m_Model->Sphere( 10.0f, 16, 16, FVF_XYZTEX1, "floor.bmp", 5.0f);
    m_SphereObj.SetPosition( 0.0f, 0.0f, 30.0f );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Move the wall around
    m_WallObj.m_vPosition.x += m_DefaultGamepad.fX1*m_fElapsedTime*15.0f;
    m_WallObj.m_vPosition.y += m_DefaultGamepad.fY1*m_fElapsedTime*15.0f;
    m_WallObj.m_vPosition.z += m_DefaultGamepad.fY2*m_fElapsedTime*25.0f;

    // Rotate the sphere
    m_SphereObj.m_vRotation.y += m_fElapsedTime*2.0f;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         0xff400000, 1.0f, 0L );

    // Restore state that text clobbers
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    // Render the wall
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_WallObj.Render( 0 );

    // Do the visibility test on the sphere.
    //
    // Note 1: We would normally send simple test geometry for the vis test
    //         and not the full object.
    // Note 2: We could send multiple objects between the
    //         BeginVisibilityTest() EndVisibilityTest() pair. The call to 
    //         GetVisibilityTestResult() would then return the total number of
    //         pixels drawn by all objects.

    // We dont want color or z buffer updated, so we disable them.
    m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, 0x00000000 );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,     FALSE );

    m_pd3dDevice->BeginVisibilityTest();
    m_SphereObj.Render( 0 );
    m_pd3dDevice->EndVisibilityTest( 0 );

    // Re-enable color and z writes
    m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALL );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,     TRUE );

    // Check the number of pixels that would have been drawn by 
    // the visibility test geometry. keep trying till we get a
    // complete result. (***SEE NOTE AT TOP OF FILE***)
    UINT    dwNumPixelsDrawn;
    HRESULT hr;
    do
    {
        hr = m_pd3dDevice->GetVisibilityTestResult( 0, &dwNumPixelsDrawn, NULL );
    }
    while( hr==D3DERR_TESTINCOMPLETE );

    // If pixels would have been drawn, we send the object again
    // with all writes enabled
    if( dwNumPixelsDrawn > 0 )
        m_SphereObj.Render(0);

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
		m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"VisibilityTest" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Report if sphere was rendered, and if so, show number of pixels
        if( dwNumPixelsDrawn == 0 )
            m_Font.DrawText( 320, 405, 0xffff0000, L"Sphere not rendered.", XBFONT_CENTER_X );
        else
        {
            WCHAR str[80];
            swprintf( str, L" %d", dwNumPixelsDrawn );
            m_Font.DrawText( 320, 380, 0xff00ff00, L"Sphere rendered.", XBFONT_CENTER_X );
            m_Font.DrawText( 320, 405, 0xff00ff00, L"# Pixels:", XBFONT_RIGHT );
            m_Font.DrawText( 320, 405, 0xff00ff00, str, XBFONT_LEFT );
        }
		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeLight\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeLight\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeLight\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 9UL

#define resource_Light_OFFSET 0UL
#define resource_SkyBoxXP_OFFSET 20UL
#define resource_SkyBoxXN_OFFSET 40UL
#define resource_SkyBoxYP_OFFSET 60UL
#define resource_SkyBoxYN_OFFSET 80UL
#define resource_SkyBoxZP_OFFSET 100UL
#define resource_SkyBoxZN_OFFSET 120UL
#define resource_StoneHen_OFFSET 140UL
#define resource_StoneHea_OFFSET 160UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeSprites\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeSprites\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeSprites\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeSprites\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeFog\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 8UL

#define Resource_Treebark_OFFSET 0UL
#define Resource_VolGroun_OFFSET 20UL
#define Resource_SkyBoxXN_OFFSET 40UL
#define Resource_SkyBoxXP_OFFSET 60UL
#define Resource_SkyBoxYN_OFFSET 80UL
#define Resource_SkyBoxYP_OFFSET 100UL
#define Resource_SkyBoxZN_OFFSET 120UL
#define Resource_SkyBoxZP_OFFSET 140UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeSprites\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\volumetexture\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\volumetexture\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeSprites\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Ground2_OFFSET 0UL
#define resource_Particle_OFFSET 20UL
#define resource_ParticleVolume_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\volumetexture\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeSprites\VolumeSprites.cpp ===
//-----------------------------------------------------------------------------
// File: VolumeSprites.cpp
//
// Desc: Sample showing how to use point sprites with a volume texture. A
//       vertex shader is used to provide the third texture coordinate.

// Perf: Volume textures have about a 50% reduction in fillrate potential than
//       just using 2D textures.
//
// Hist: 06.25.01 - New for August XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"



#define NUM_PARTICLE_BUFFERS 3                  // # of vertex buffers for the particle system
#define KICKOFF_SIZE         (4 * (1<<10))      // Kick off size. Must be power of 2.
#define PUSHBUFFER_SIZE      (128*KICKOFF_SIZE) // Push buffer size as a multiple of kickoff size




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_DPAD,         XBHELP_PLACEMENT_1, L"Zoom" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move\ncamera" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Rotate\ncamera" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display\nhelp" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 5




//-----------------------------------------------------------------------------
// Custom vertex type
//-----------------------------------------------------------------------------
struct PARTICLEVERTEX
{
    D3DXVECTOR3 v;
    D3DCOLOR    color;
};

#define D3DFVF_PARTICLEVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)

struct GROUNDVERTEX
{
    D3DXVECTOR3 v;
    D3DCOLOR    color;
    FLOAT       tu;
    FLOAT       tv;
};

#define D3DFVF_GROUNDVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)





//-----------------------------------------------------------------------------
// Global structs and data for the ground object
//-----------------------------------------------------------------------------
#define GROUND_SIZE  20.0f
#define GROUND_COLOR 0xddeeeeff




//-----------------------------------------------------------------------------
// Global data for the particles
//-----------------------------------------------------------------------------
struct PARTICLE
{
    BOOL        m_bSpark;     // Spark? or real particle?

    D3DXVECTOR3 m_vPos;       // Current position
    D3DXVECTOR3 m_vVel;       // Current velocity

    D3DXVECTOR3 m_vPos0;      // Initial position
    D3DXVECTOR3 m_vVel0;      // Initial velocity
    FLOAT       m_fTime0;     // Time of creation

    D3DXCOLOR   m_clrDiffuse; // Initial diffuse color
    D3DXCOLOR   m_clrFade;    // Faded diffuse color
    FLOAT       m_fFade;      // Fade progression
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;      // Packed resources for the app
    CXBFont            m_Font;             // Font class
    CXBHelp            m_Help;             // Help class
    BOOL               m_bDrawHelp;        // Whether to draw help

    // Particle system timing
    BOOL               m_bParticleSystemRunning;
    FLOAT              m_fParticleSystemTime;
    FLOAT              m_fElapsedParticleSystemTime;

    // Ground stuff
    LPDIRECT3DVERTEXBUFFER8 m_pGroundVB;
    LPDIRECT3DTEXTURE8 m_pGroundTexture;
    D3DXPLANE          m_planeGround;

    // Particle stuff
    LPDIRECT3DTEXTURE8 m_pParticleTexture;
    DWORD              m_dwNumParticlesToEmit;

    // Static vectors for determining view position
    D3DXVECTOR3        m_vPosition;
    D3DXVECTOR3        m_vVelocity;
    FLOAT              m_fYaw;
    FLOAT              m_fYawVelocity;
    FLOAT              m_fPitch;
    FLOAT              m_fPitchVelocity;
    D3DXMATRIX         m_matView;
    D3DXMATRIX         m_matReflectedView;
    D3DXMATRIX         m_matOrientation;

    FLOAT                    m_fRadius;
    PARTICLE*                m_pParticles;
    DWORD                    m_dwMaxParticles;
    DWORD                    m_dwNumParticles;

    // Geometry
    LPDIRECT3DVERTEXBUFFER8  m_pPointSpritesVBs[NUM_PARTICLE_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8  m_pPointSpritesVB;
    DWORD                    m_dwCurrentBuffer;
    DWORD                    m_dwNumParticlesToRender;

    DWORD                    m_dwVertexShader;
    LPDIRECT3DVOLUMETEXTURE8 m_pVolumeTexture;

    HRESULT InitParticleSystem();
    HRESULT DeleteParticleSystem();

    HRESULT UpdateParticleSystem( FLOAT fSecsPerFrame, DWORD dwNumParticlesToEmit,
                                  const D3DXCOLOR& dwEmitColor, const D3DXCOLOR& dwFadeColor,
                                  FLOAT fEmitVel, D3DXVECTOR3 vPosition );

    HRESULT RenderParticleSystem( LPDIRECT3DTEXTURE8 pTexture );

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Set the push buffer and kickoff size. See comment about performance at
    // the top of this file.
    Direct3D_SetPushBufferSize( PUSHBUFFER_SIZE, KICKOFF_SIZE );

    // Init member variables
    m_bDrawHelp            = FALSE;

    m_bParticleSystemRunning     = TRUE;
    m_fParticleSystemTime        = 0.0f;
    m_fElapsedParticleSystemTime = 0.0f;

    m_pGroundTexture       = NULL;
    m_pGroundVB            = NULL;
    m_planeGround          = D3DXPLANE( 0.0f, 1.0f, 0.0f, 0.0f );

    m_pParticleTexture     = NULL;
    m_dwNumParticlesToEmit = 10;

    m_vPosition            = D3DXVECTOR3( 0.0f, 3.0f,-4.0f );
    m_vVelocity            = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_fYaw                 = 0.0f;
    m_fYawVelocity         = 0.0f;
    m_fPitch               = 0.5f;
    m_fPitchVelocity       = 0.0f;
    D3DXMatrixTranslation( &m_matView, 0.0f, 0.0f, 10.0f );
    D3DXMatrixTranslation( &m_matOrientation, 0.0f, 0.0f, 0.0f );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create textures
    m_pGroundTexture   = m_xprResource.GetTexture( resource_Ground2_OFFSET );
    m_pParticleTexture = m_xprResource.GetTexture( resource_Particle_OFFSET );
    m_pVolumeTexture   = m_xprResource.GetVolumeTexture( resource_ParticleVolume_OFFSET );

    // Create vertex buffer for ground object
    hr = m_pd3dDevice->CreateVertexBuffer( 4*sizeof(GROUNDVERTEX),
                                           D3DUSAGE_WRITEONLY, D3DFVF_GROUNDVERTEX,
                                           D3DPOOL_MANAGED, &m_pGroundVB );
    if( FAILED(hr) )
        return E_FAIL;

    // Fill vertex buffer
    GROUNDVERTEX* pVertices;
    m_pGroundVB->Lock( 0, 0, (BYTE**)&pVertices, NULL );
    pVertices[0].v     = GROUND_SIZE * D3DXVECTOR3( -0.5f, 0.0f, -0.5f );
    pVertices[0].color = GROUND_COLOR;
    pVertices[0].tu    = 0.0f;
    pVertices[0].tv    = 0.0f;
    pVertices[1].v     = GROUND_SIZE * D3DXVECTOR3( -0.5f, 0.0f, +0.5f );
    pVertices[1].color = GROUND_COLOR;
    pVertices[1].tu    = 0.0f;
    pVertices[1].tv    = 3.0f;
    pVertices[2].v     = GROUND_SIZE * D3DXVECTOR3( +0.5f, 0.0f, +0.5f );
    pVertices[2].color = GROUND_COLOR;
    pVertices[2].tu    = 3.0f;
    pVertices[2].tv    = 3.0f;
    pVertices[3].v     = GROUND_SIZE * D3DXVECTOR3( +0.5f, 0.0f, -0.5f );
    pVertices[3].color = GROUND_COLOR;
    pVertices[3].tu    = 3.0f;
    pVertices[3].tv    = 0.0f;
    m_pGroundVB->Unlock();

    // Create vertex shader for the billboards
    DWORD dwVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),   // v0 = Position
        D3DVSD_REG( 3, D3DVSDT_D3DCOLOR ),   // v3 = Color
        D3DVSD_END()
    };

    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\PSprite.xvu",
                                           dwVertexDecl,
                                           &m_dwVertexShader ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the particle system
    if( FAILED( hr = InitParticleSystem() ) )
        return hr;

    // Set the world matrix
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 0.1f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Animate the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // De-accelerate the camera movement (for smooth motion)
    FLOAT fScale = max( 0.0f, ( 1.0f - 2.0f*m_fElapsedTime) );
    m_vVelocity      *= fScale;
    m_fYawVelocity   *= fScale;
    m_fPitchVelocity *= fScale;

    // Update velocities from the gamepad
    m_vVelocity.x    += 1.0f*m_fElapsedTime*m_DefaultGamepad.fX1; // Slide left/right
    m_vVelocity.y    += 1.0f*m_fElapsedTime*m_DefaultGamepad.fY1; // Slide up/down
    if( m_DefaultGamepad.wButtons&XINPUT_GAMEPAD_DPAD_UP )   
        m_vVelocity.z += 1.0f*m_fElapsedTime;
    if( m_DefaultGamepad.wButtons&XINPUT_GAMEPAD_DPAD_DOWN ) 
        m_vVelocity.z -= 1.0f*m_fElapsedTime;

    m_fYawVelocity   += 1.0f*m_fElapsedTime*m_DefaultGamepad.fX2; // Turn left/right
    m_fPitchVelocity += 1.0f*m_fElapsedTime*m_DefaultGamepad.fY2; // Turn up/down

    // Handle options
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Update the position vector
    D3DXVECTOR3 vT = m_vVelocity * 5.0f * m_fElapsedTime;
    D3DXVec3TransformNormal( &vT, &vT, &m_matOrientation );
    m_vPosition += vT;
    if( m_vPosition.y < 1.0f )
        m_vPosition.y = 1.0f;

    // Update the yaw-pitch-rotation vector
    m_fYaw   += 5.0f * m_fElapsedTime * m_fYawVelocity;
    m_fPitch += 5.0f * m_fElapsedTime * m_fPitchVelocity;
    if( m_fPitch < 0.0f )      m_fPitch = 0.0f;
    if( m_fPitch > D3DX_PI/2 ) m_fPitch = D3DX_PI/2;

    // Set the view matrix
    D3DXQUATERNION qR;
    D3DXQuaternionRotationYawPitchRoll( &qR, m_fYaw, m_fPitch, 0.0f );
    D3DXMatrixAffineTransformation( &m_matOrientation, 1.25f, NULL, &qR, &m_vPosition );
    D3DXMatrixInverse( &m_matView, NULL, &m_matOrientation );

    // Computed the reflected view
    D3DXMatrixReflect( &m_matReflectedView, &m_planeGround );
    D3DXMatrixMultiply( &m_matReflectedView, &m_matReflectedView, &m_matView );

    // Check the Start button to start/stop the particle system
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
        m_bParticleSystemRunning = !m_bParticleSystemRunning;

    if( m_bParticleSystemRunning )
        m_fElapsedParticleSystemTime = m_fElapsedTime;
    else
        m_fElapsedParticleSystemTime = 0.0f;
    m_fParticleSystemTime += m_fElapsedParticleSystemTime;

    // Update particle system
    UpdateParticleSystem( m_fElapsedParticleSystemTime, m_dwNumParticlesToEmit,
                          D3DXCOLOR( 1.0f, 1.0f, 1.0f, 1.0f ),
                          D3DXCOLOR( 1.0f, 0.2f, 0.2f, 1.0f ),
                          8.0f,
                          D3DXVECTOR3( 0.0f, 0.0f, 0.0f ) );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x000000ff, 1.0f, 0L );

    // Set state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,   D3DZB_FALSE ); // we don't require z-buffer

    // Draw the ground
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
    m_pd3dDevice->SetTexture( 0, m_pGroundTexture );
    m_pd3dDevice->SetVertexShader( D3DFVF_GROUNDVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pGroundVB, sizeof(GROUNDVERTEX) );
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, 1 );

    // Render the particles
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff000000 );
    RenderParticleSystem( m_pParticleTexture );

    // Draw reflection of particles
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matReflectedView );
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0x40000000 );
    RenderParticleSystem( m_pParticleTexture );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64,  50, 0xffffffff, L"VolumeSprites" );
        m_Font.DrawText( 450,  50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitParticleSystem()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitParticleSystem()
{
    HRESULT hr;

    m_fRadius          = 0.03f;

    m_pParticles       = new PARTICLE[4096];
    m_dwMaxParticles   = 4096;
    m_dwNumParticles   = 0;

    m_pPointSpritesVB  = NULL;
    m_dwCurrentBuffer  = 0;

    m_dwNumParticlesToRender = 0;

    // Create the particle texture
    // Create the particle system's vertex buffers. Each point sprite particle
    // requires one vertex and each light takes four vertices.
    for( DWORD buf = 0; buf < NUM_PARTICLE_BUFFERS; buf++ )
    {
        hr = m_pd3dDevice->CreateVertexBuffer( (m_dwMaxParticles+1)*sizeof(PARTICLEVERTEX),
                                               D3DUSAGE_WRITEONLY, D3DFVF_PARTICLEVERTEX,
                                               D3DPOOL_DEFAULT, &m_pPointSpritesVBs[buf] );
        if( FAILED(hr) )
            return E_FAIL;
    }

    // Select starting vertex buffers
    m_dwCurrentBuffer = 0;
    m_pPointSpritesVB = m_pPointSpritesVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DeleteParticleSystem()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DeleteParticleSystem()
{
    SAFE_DELETE( m_pParticles );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: UpdateParticleSystem()
// Desc: Update the particles in the particle system.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::UpdateParticleSystem( FLOAT fSecsPerFrame, DWORD dwNumParticlesToEmit,
                                 const D3DXCOLOR &clrEmitColor,
                                 const D3DXCOLOR &clrFadeColor, float fEmitVel,
                                 D3DXVECTOR3 vPosition )
{
    static float fTime = 0.0f;
    fTime += fSecsPerFrame;

    // For performance reasons, vertex buffers are multi-buffered. Each time
    // the vertex buffer contents are updated, use a new vertex buffer.
    if( m_pPointSpritesVB->IsBusy() )
    {
        if( ++m_dwCurrentBuffer >= NUM_PARTICLE_BUFFERS )
            m_dwCurrentBuffer = 0;
        m_pPointSpritesVB = m_pPointSpritesVBs[m_dwCurrentBuffer];
    }
 
    // Lock vertex buffers
    PARTICLEVERTEX* pPointSpriteVertices;
    m_pPointSpritesVB->Lock( 0, 0, (BYTE**)&pPointSpriteVertices, NULL );
    m_dwNumParticlesToRender = 0;

    // Update particles
    for( DWORD i=0; i<m_dwNumParticles; i++ )
    {
        PARTICLE* pParticle = &m_pParticles[i];

        // Calculate new position
        FLOAT t = fTime - pParticle->m_fTime0;

        if( pParticle->m_bSpark )
        {
            pParticle->m_vPos    = pParticle->m_vVel0 * t + pParticle->m_vPos0;
            pParticle->m_vPos.y -= (0.5f * 5.0f) * (t * t);
            pParticle->m_vVel.y  = pParticle->m_vVel0.y - 5.0f * t;
            pParticle->m_fFade  -= fSecsPerFrame * 2.25f;
        }
        else
        {
            pParticle->m_vPos    = pParticle->m_vVel0 * t + pParticle->m_vPos0;
            pParticle->m_vPos.y -= (0.5f * 9.8f) * (t * t);
            pParticle->m_vVel.y  = pParticle->m_vVel0.y - 9.8f * t;
            pParticle->m_fFade  -= fSecsPerFrame * 0.25f;
        }

        if( pParticle->m_fFade < 0.0f )
            pParticle->m_fFade = 0.0f;

        // Kill old particles
        if( pParticle->m_vPos.y < m_fRadius || pParticle->m_bSpark && pParticle->m_fFade <= 0.0f )
        {
            // Emit sparks
            if( !pParticle->m_bSpark )
            {
                for( int j=0; j<4; j++ )
                {
                    FLOAT fRand1 = ((FLOAT)rand()/(FLOAT)RAND_MAX) * D3DX_PI * 2.00f;
                    FLOAT fRand2 = ((FLOAT)rand()/(FLOAT)RAND_MAX) * D3DX_PI * 0.25f;

                    PARTICLE* pSpark = &m_pParticles[m_dwNumParticles++];
                    pSpark->m_bSpark   = TRUE;
                    pSpark->m_vPos0    = pParticle->m_vPos;
                    pSpark->m_vPos0.y  = m_fRadius;
                    pSpark->m_vVel0.x  = pParticle->m_vVel.x * 0.25f + cosf(fRand1) * sinf(fRand2);
                    pSpark->m_vVel0.z  = pParticle->m_vVel.z * 0.25f + sinf(fRand1) * sinf(fRand2);
                    pSpark->m_vVel0.y  = cosf(fRand2);
                    pSpark->m_vVel0.y *= ((FLOAT)rand()/(FLOAT)RAND_MAX) * 1.5f;
                    pSpark->m_vPos     = pSpark->m_vPos0;
                    pSpark->m_vVel     = pSpark->m_vVel0;
                    D3DXColorLerp( &pSpark->m_clrDiffuse, &pParticle->m_clrFade,
                                   &pParticle->m_clrDiffuse, pParticle->m_fFade );
                    pSpark->m_clrFade  = D3DXCOLOR(0.0f, 0.0f, 0.0f, 1.0f);
                    pSpark->m_fFade    = 1.0f;
                    pSpark->m_fTime0   = fTime;
                }
            }

            // Kill this particle (we can do this fast, by simply moving the
            // last particle to take the current particle's place).
            m_pParticles[i--] = m_pParticles[--m_dwNumParticles];
        }
        else
        {
            // Build vertex buffers for the particles
            FLOAT fSpeed = D3DXVec3LengthSq( &pParticle->m_vVel );
            UINT  dwSteps;
            if( fSpeed < 1.0f )        dwSteps = 2;
            else if( fSpeed <  4.00f ) dwSteps = 3;
            else if( fSpeed <  9.00f ) dwSteps = 4;
            else if( fSpeed < 12.25f ) dwSteps = 5;
            else if( fSpeed < 16.00f ) dwSteps = 6;
            else if( fSpeed < 20.25f ) dwSteps = 7;
            else                       dwSteps = 8;

            D3DXVECTOR3 vPos = pParticle->m_vPos;
            D3DXVECTOR3 vVel = pParticle->m_vVel * -0.04f / (FLOAT)dwSteps;

            D3DXCOLOR clrDiffuse;
            D3DXColorLerp( &clrDiffuse, &pParticle->m_clrFade, &pParticle->m_clrDiffuse, 
                                        pParticle->m_fFade );
            DWORD dwDiffuse = (DWORD)clrDiffuse;

            // Use multiple pointsprites per particle to get a motion-blur effect
            for( DWORD j = 0; j < dwSteps; j++ )
            {
                if( vPos.y >= 0.0f )
                {
                    pPointSpriteVertices->v     = vPos;
                    pPointSpriteVertices->color = dwDiffuse;
                    pPointSpriteVertices++;
                    m_dwNumParticlesToRender++;

                    // Stop if the VB gets full.
                    if( m_dwNumParticlesToRender >= m_dwMaxParticles )
                        break;
                }
                vPos += vVel;
            }
        }
    }

    // Unlock the vertex buffers
    m_pPointSpritesVB->Unlock();

    // Emit new particles
    while( dwNumParticlesToEmit > 0 && m_dwNumParticles < m_dwMaxParticles/4 )
    {
        FLOAT fRand1 = ((FLOAT)rand()/(FLOAT)RAND_MAX) * D3DX_PI * 2.00f;
        FLOAT fRand2 = ((FLOAT)rand()/(FLOAT)RAND_MAX) * D3DX_PI * 0.25f;

        PARTICLE* pParticle = &m_pParticles[m_dwNumParticles];
        pParticle->m_bSpark     = FALSE;
        pParticle->m_vPos0      = vPosition + D3DXVECTOR3( 0.0f, m_fRadius, 0.0f );
        pParticle->m_vVel0.x    = cosf(fRand1) * sinf(fRand2) * 2.5f;
        pParticle->m_vVel0.z    = sinf(fRand1) * sinf(fRand2) * 2.5f;
        pParticle->m_vVel0.y    = cosf(fRand2);
        pParticle->m_vVel0.y   *= ((FLOAT)rand()/(FLOAT)RAND_MAX) * fEmitVel;
        pParticle->m_vPos       = pParticle->m_vPos0;
        pParticle->m_vVel       = pParticle->m_vVel0;
        pParticle->m_clrDiffuse = clrEmitColor;
        pParticle->m_clrFade    = clrFadeColor;
        pParticle->m_fFade      = 1.0f;
        pParticle->m_fTime0     = fTime;

        dwNumParticlesToEmit--;
        m_dwNumParticles++;
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: RenderParticleSystem()
// Desc: Renders the particle system using pointsprites.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderParticleSystem( LPDIRECT3DTEXTURE8 pTexture )
{
    if( 0 == m_dwNumParticlesToRender )
        return S_OK;

    // Set the render states for using point sprites. Note that pointsprites
    // use texture stage 3 only.
//    m_pd3dDevice->SetTexture( 3, pTexture );
    m_pd3dDevice->SetTexture( 3, m_pVolumeTexture );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG2, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAARG2, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  TRUE );

    // Turn on alphablending
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );

    D3DXMATRIX mat, matWV, matWVP, matWorld, matView, matProj;
    m_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorld );
    m_pd3dDevice->GetTransform( D3DTS_VIEW, &matView );
    m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
    D3DXMatrixMultiply( &mat, &matWorld, &matView );
    D3DXMatrixTranspose( &matWV, &mat );
    D3DXMatrixMultiply( &mat, &mat, &matProj );
    D3DXMatrixTranspose( &matWVP, &mat );

    FLOAT tw = (sinf(m_fAppTime)+1)/2;

    FLOAT eye[4] = { -matView._41, -matView._42, -matView._43, 0.0f };
    FLOAT constants[4] = { 480.0f * 0.10f, 0.0f, tw, 0.0f };

    m_pd3dDevice->SetVertexShaderConstant( 0, constants, 1 );
    m_pd3dDevice->SetVertexShaderConstant( 1, eye, 1 );
    m_pd3dDevice->SetVertexShaderConstant( 8, matWV, 4 );
    m_pd3dDevice->SetVertexShaderConstant( 12, matWVP, 4 );
    m_pd3dDevice->SetVertexShader( m_dwVertexShader );

    // Render particles
    m_pd3dDevice->SetStreamSource( 0, m_pPointSpritesVB, sizeof(PARTICLEVERTEX) );
    m_pd3dDevice->DrawPrimitive( D3DPT_POINTLIST, 0, m_dwNumParticlesToRender );

    // Reset render states
    m_pd3dDevice->SetTexture( 3, NULL );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,  FALSE );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeLight\VolumeLight.cpp ===
//-----------------------------------------------------------------------------
// File: VolumeLight.cpp
//
// Desc: Example code showing how to use volume textures in place of lightmaps.
//
// Hist: 01.05.00 - New for February XDK release
//       03.12.01 - Added Xfest art changes for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBMesh.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <xgraphics.h>
#include "Resource.h" // Resource header produced by the bundler tool




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move light" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Move camera" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Change light\nFOV" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS 5




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Light.bmp",    resource_Light_OFFSET },
    { "SkyBoxXP.bmp", resource_SkyBoxXP_OFFSET },
    { "SkyBoxXN.bmp", resource_SkyBoxXN_OFFSET },
    { "SkyBoxYP.bmp", resource_SkyBoxYP_OFFSET },
    { "SkyBoxYN.bmp", resource_SkyBoxYN_OFFSET },
    { "SkyBoxZP.bmp", resource_SkyBoxZP_OFFSET },
    { "SkyBoxZN.bmp", resource_SkyBoxZN_OFFSET },
    { "StoneHen.bmp", resource_StoneHen_OFFSET },
    { "StoneHea.bmp", resource_StoneHea_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
#define VOLTEX_WIDTH  256
#define VOLTEX_HEIGHT 256
#define VOLTEX_DEPTH   16

FLOAT       g_fFlashLightFOV    = D3DX_PI/4; // Field of view of flashlight beam
FLOAT       g_fFlashLightExtent = 25.0f;     // How far lighting effects extend
D3DXVECTOR3 g_vFlashLightPos;
D3DXVECTOR3 g_vFlashLightDir;

FLOAT       g_fMinOffset = 0.050f; // Parameters for the volume light
FLOAT       g_fMaxOffset = 0.200f;
FLOAT       g_fMinSigma  = 0.020f;
FLOAT       g_fMaxSigma  = 0.500f;
FLOAT       g_fScale     = 3.0f;




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                  m_Font;           // System font
    CXBHelp                  m_Help;           // Application help
    BOOL                     m_bDrawHelp;      // Whether to display help

    CXBPackedResource        m_xprResource;    // Packed resources (textures)
    
    CXBMesh                  m_SkyBoxObject;   // The skybox geometry
    D3DXMATRIX               m_matSkyBox;      // Matrix to orient skybox

    CXBMesh                  m_TerrainObject;  // The terrain geometry
    D3DXMATRIX               m_matWorld;       // Matrix set
    D3DXMATRIX               m_matView;
    D3DXMATRIX               m_matProj;

    CXBMesh                  m_FlashLightObject;    // The flashlight geometry
    D3DXMATRIX               m_matLightOrientation; // Matrix to orient flashlight

    LPDIRECT3DTEXTURE8       m_pLightTexture;  // Texture for flahlight lens flare

    LPDIRECT3DVOLUMETEXTURE8 m_pVolumeTexture; // Volumetexture for the light beam

    DWORD                    m_dwVertexShader; // Vertex shader for the lit terrain
    DWORD                    m_dwPixelShader;  // Pixel shader for the lit terrain

    HRESULT CreateVolumeTexture();             // Creates the volume light texture
    HRESULT CreatePixelShader();               // Creates the pixel shader

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    m_bDrawHelp      = FALSE;
    m_pLightTexture  = NULL;
    m_pVolumeTexture = NULL;
}




//-----------------------------------------------------------------------------
// Name: CreatePixelShader()
// Desc: Creates the pixel shader for the lit terrain
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreatePixelShader()
{
    // Setup the pixel shader
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 2,
                                            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_PROJECT3D,
                                           PS_TEXTUREMODES_NONE, PS_TEXTUREMODES_NONE );

    //------------- Stage 0 -------------
    // Combine base texture (t0) with the diffuse lighting contribution (v0)
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS( PS_REGISTER_T0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    //------------- Stage 1 -------------
    // Modulate in volume light (t1) and add in some ambient (c0)
    psd.PSRGBInputs[1]    = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_T1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_C0  | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[1]  = PS_COMBINERINPUTS( PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[1]   = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[1] = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSConstant0[1] = 0x40404040;

    //------------- Final combiner -------------
    
    // Output r0
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_ONE     | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_R0      | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO     | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO    | PS_CHANNEL_RGB );

    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      0 | 0 | 0 );

    // Create the pixel shader, as defined above.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwPixelShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateVolumeTexture()
// Desc: Creates the volume light. The flashlight's beam is modelled here in
//       the 3D space of a volume texture.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateVolumeTexture()
{
    HRESULT hr;

    // Create a volume texture
    hr = m_pd3dDevice->CreateVolumeTexture( VOLTEX_WIDTH, VOLTEX_HEIGHT, VOLTEX_DEPTH, 
                                            1, 0, D3DFMT_L8, D3DPOOL_MANAGED,
                                            &m_pVolumeTexture );
    if( FAILED(hr) )
        return hr;

    // Lock and fill the volume texture
    D3DVOLUME_DESC desc;
    D3DLOCKED_BOX lock;
    m_pVolumeTexture->GetLevelDesc( 0, &desc );
    m_pVolumeTexture->LockBox( 0, &lock, 0, 0L );
    BYTE* pBits = (BYTE*)lock.pBits;

    for( UINT w=0; w<VOLTEX_DEPTH; w++ )
    {
        FLOAT z = (1.0f*w)/(VOLTEX_DEPTH-1); // Ranges from 0 to +1

        // Paramaters for Gaussian falloff
        FLOAT fOffset = g_fMinOffset + (g_fMaxOffset-g_fMinOffset)*z;
        FLOAT fSigma  = g_fMinSigma + (g_fMaxSigma-g_fMinSigma)*z;
        FLOAT fBias   = expf( -(1.0f-fOffset)*(1.0f-fOffset)/(2*fSigma*fSigma) );
        FLOAT fMaxAmplitude = ( expf( -(fOffset*fOffset)/(2*fSigma*fSigma) ) - fBias );
        FLOAT fScale  = 1.0f / fMaxAmplitude;

        for( UINT v=0; v<VOLTEX_HEIGHT; v++ )
        {
            for( UINT u=0; u<VOLTEX_WIDTH; u++ )
            {
                FLOAT x = (2.0f*u)/(VOLTEX_HEIGHT-1) - 1.0f; // Ranges from -1 to +1
                FLOAT y = (2.0f*v)/(VOLTEX_WIDTH-1) - 1.0f;  // Ranges from -1 to +1
                FLOAT r = sqrtf( x*x + y*y );

                // Compute the intensity
                FLOAT fIntensity = fScale * ( expf( -(r-fOffset)*(r-fOffset)/(2*fSigma*fSigma) ) - fBias );
                if( fIntensity > 1.0f ) fIntensity = 1.0f;
                if( fIntensity < 0.0f ) fIntensity = 0.0f;

                // Write the texel
                (*pBits++) = (BYTE)(255*fIntensity);
            }
        }
    }
    
    // Swizzle and unlock the texture
    XBUtil_SwizzleTexture3D( &lock, &desc );
    m_pVolumeTexture->UnlockBox( 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the geometry models
    if( FAILED( m_SkyBoxObject.Create( m_pd3dDevice, "Models\\SkyBox.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_TerrainObject.Create( m_pd3dDevice, "Models\\StoneHenge.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_FlashLightObject.Create( m_pd3dDevice, "Models\\Light.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get the light's texture
    m_pLightTexture = m_xprResource.GetTexture( "Light.bmp" );
    
    // Create the volume texture
    if( FAILED( CreateVolumeTexture() ) )
        return E_FAIL;

    // Create the pixel shader
    if( FAILED( CreatePixelShader() ) )
        return E_FAIL;

    // Set the matrices
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/3, 4.0f/3.0f, 1.0f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    // Create vertex shader
    DWORD dwVertexDecl[20];
    XBUtil_DeclaratorFromFVF( m_TerrainObject.GetMesh(0)->m_dwFVF, dwVertexDecl );

    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Shader.xvu",
                                           dwVertexDecl, &m_dwVertexShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Change the field of view of the flashlight
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        g_fFlashLightFOV += D3DX_PI * ( 5.0f / 180.0f );
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
        g_fFlashLightFOV -= D3DX_PI * ( 5.0f / 180.0f );

    // Rotate and position the camera with the gamepad
    static FLOAT fViewAngle =  3.53f;
    static FLOAT fCameraX   =  4.54f;
    static FLOAT fCameraY   =  2.00f;
    static FLOAT fCameraZ   =  6.75f;
    fViewAngle += 2.0f * m_DefaultGamepad.fX2*m_fElapsedTime;
    fCameraX   += 5.0f * m_DefaultGamepad.fY2*m_fElapsedTime*sinf(fViewAngle);
    fCameraZ   += 5.0f * m_DefaultGamepad.fY2*m_fElapsedTime*cosf(fViewAngle);

    // Set the view transform
    D3DXVECTOR3 from = D3DXVECTOR3( fCameraX, fCameraY, fCameraZ );
    D3DXVECTOR3 at   = D3DXVECTOR3( sinf(fViewAngle), 0.0f, cosf(fViewAngle) ) + from;
    D3DXVECTOR3 up   = D3DXVECTOR3(0.0f, 1.0f, 0.0f);
    D3DXMatrixLookAtLH( &m_matView, &from, &at, &up );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Set the skybox view transform (which retains the view orientation, but not
    // the translation)
    m_matSkyBox     = m_matView;
    m_matSkyBox._41 = 0.0f; 
    m_matSkyBox._42 = 0.0f; 
    m_matSkyBox._43 = 0.0f;

    // Position and orient the light
    static FLOAT fLightPhi   = +0.00f;
    static FLOAT fLightTheta = -0.32f;
    fLightPhi   += +3.0f * m_DefaultGamepad.fX1*m_fElapsedTime;
    fLightTheta += +3.0f * m_DefaultGamepad.fY1*m_fElapsedTime;
    fLightTheta = min( +D3DX_PI/2, max( fLightTheta, -D3DX_PI/2 ) );

    g_vFlashLightPos.x = 3.0f * sinf( 1.0f * m_fAppTime ) + 1.0f;
    g_vFlashLightPos.y = 0.0f * sinf( 5.0f * m_fAppTime ) + 1.0f;
    g_vFlashLightPos.z = 2.0f * cosf( 1.0f * m_fAppTime ) - 1.0f;
    
    g_vFlashLightDir.x = +cosf( fLightPhi + m_fAppTime );
    g_vFlashLightDir.y = +sinf( fLightTheta );
    g_vFlashLightDir.z = -sinf( fLightPhi + m_fAppTime );
    D3DXVec3Normalize( &g_vFlashLightDir, &g_vFlashLightDir );
    
    // Use the inverse of a camera lookat matrix to get an orientation matrix
    // for the light. Note: the inverse step could be optimized out, since we
    // re-invert the matrix later, but we don't do that here, to illustrate the
    // math the really happens.
    D3DXMATRIX matLookAt;
    D3DXMatrixLookAtLH( &matLookAt, &g_vFlashLightPos, 
                                    &(g_vFlashLightPos+g_vFlashLightDir), 
                                    &D3DXVECTOR3(0,1,0) );
    D3DXMatrixInverse( &m_matLightOrientation, NULL, &matLookAt );

    // Set up texture matrix used to orient the volume texture. First, orient
    // to the desired volume texture orientation.
    D3DXMATRIX matTexGen, matTrans1, matScale, matTrans2;
    D3DXMatrixInverse( &matTexGen, NULL, &m_matLightOrientation );

    // Scale to mimic the light beam, and translate the result to the volume
    // texture's origin
    FLOAT fBeamWidth  = g_fFlashLightExtent * cosf( (D3DX_PI-g_fFlashLightFOV)/2 );
    FLOAT fBeamLength = g_fFlashLightExtent * sinf( (D3DX_PI-g_fFlashLightFOV)/2 );
    D3DXMatrixScaling( &matScale, 1.0f/fBeamWidth, 1.0f/fBeamWidth, 1.0f/fBeamLength );
    D3DXMatrixTranslation( &matTrans2, 0.5f, 0.5f, 0.0f );
    D3DXMatrixMultiply( &matTexGen, &matTexGen, &matScale );
    D3DXMatrixMultiply( &matTexGen, &matTexGen, &matTrans2 );

    // Finally, pass the transformed texture matrix to the vertex shader
    D3DXMatrixTranspose( &matTexGen, &matTexGen );
    m_pd3dDevice->SetVertexShaderConstant( 16, &matTexGen, 4 );

    // Pass the transform set to the vertex shader
    D3DXMATRIX matW, matWV, matWVP;
    D3DXMatrixMultiply( &matWV, &m_matWorld, &m_matView );
    D3DXMatrixMultiply( &matWVP, &matWV, &m_matProj );
    D3DXMatrixTranspose( &matW,   &m_matWorld );
    D3DXMatrixTranspose( &matWV,  &matWV );
    D3DXMatrixTranspose( &matWVP, &matWVP );
    m_pd3dDevice->SetVertexShaderConstant(  4, &matW,   4 );
    m_pd3dDevice->SetVertexShaderConstant(  8, &matWV,  4 );
    m_pd3dDevice->SetVertexShaderConstant( 12, &matWVP, 4 );

    // Pass the unattenuated point light values to the vertex shader
    D3DXVECTOR4 v0( 0.0f, 1.0f, 1.0f, 1.0f );
    D3DXVECTOR4 v1( 1.0f, 1.0f, 1.0f, 1.0f );
    D3DXVECTOR4 vLightPos( g_vFlashLightPos.x, g_vFlashLightPos.y, g_vFlashLightPos.z, 0.0f );
    D3DXVECTOR4 vLightColor( 1.0f, 1.0f, 1.0f, 1.0f );
    D3DXVECTOR4 vAmbientColor( 0.0f, 0.0f, 0.0f, 0.0f );
    m_pd3dDevice->SetVertexShaderConstant(  0,  &v0, 1 );
    m_pd3dDevice->SetVertexShaderConstant(  1,  &v1, 1 );
    m_pd3dDevice->SetVertexShaderConstant( 20, &vLightPos,     1 );
    m_pd3dDevice->SetVertexShaderConstant( 21, &vLightColor,   1 );
    m_pd3dDevice->SetVertexShaderConstant( 22, &vAmbientColor, 1 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Render the skybox
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,  &m_matSkyBox );
    m_SkyBoxObject.Render( m_pd3dDevice );

    // Set default state
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Draw the terrain, using the vertex shader, pixel shader, and the volume
    // light in stage 1
    m_pd3dDevice->SetTexture( 1, m_pVolumeTexture );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_BORDER );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_BORDER );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSW,  D3DTADDRESS_BORDER );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_BORDERCOLOR, 0x00000000 );
    m_pd3dDevice->SetPixelShader( m_dwPixelShader );
    m_pd3dDevice->SetVertexShader( m_dwVertexShader );
    m_TerrainObject.Render( m_pd3dDevice, XBMESH_NOFVF );

    // Restore state
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetTexture( 1, NULL );

    // Render the flashlight body
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE ); 
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0xff808080 );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matLightOrientation );
    m_FlashLightObject.Render( m_pd3dDevice );

    // Render the flashlight lens flare
    m_pd3dDevice->SetTexture( 3, m_pLightTexture );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSIZE,         FtoDW(0.2f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_A,      FtoDW(0.0f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_B,      FtoDW(0.0f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_C,      FtoDW(1.0f) );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_POINTLIST, 1, g_vFlashLightPos, sizeof(D3DXVECTOR3) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, FALSE );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"VolumeLight" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\volumetexture\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\VolumeSprites\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Ground2_OFFSET 0UL
#define resource_Particle_OFFSET 20UL
#define resource_ParticleVolume_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\volumetexture\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\xprviewer\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\xprviewer\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\xprviewer\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\xprviewer\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\xprviewer\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\XRay\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\XRay\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\XRay\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\volumetexture\volumetexture.cpp ===
//-----------------------------------------------------------------------------
// File: VolumeTexture.cpp
//
// Desc: Example code showing how to do volume textures in D3D.
//
// Hist: 12.15.00 - New for December XDK release
//       01.10.00 - Added texture swizzling
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBUtil.h>
#include <xgraphics.h>

// Dimension of volume texture
#define VOLTEXSIZE 64




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Rotate\nscene" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 3




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
struct VOLUMEVERTEX
{
    FLOAT      x, y, z;
    DWORD      color;
    FLOAT      tu, tv, tw;
};

#define D3DFVF_VOLUMEVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1|D3DFVF_TEXCOORDSIZE3(0))

// Vertices for rendering a quad that is textured with the volume texture
VOLUMEVERTEX g_vVertices[4] =
{
    { 1.0f, 1.0f, 0.0f, 0xffffffff, 1.0f, 1.0f, 0.0f },
    {-1.0f, 1.0f, 0.0f, 0xffffffff, 0.0f, 1.0f, 0.0f },
    { 1.0f,-1.0f, 0.0f, 0xffffffff, 1.0f, 0.0f, 0.0f },
    {-1.0f,-1.0f, 0.0f, 0xffffffff, 0.0f, 0.0f, 0.0f }
};


// Vertices for rendering the wireframe box
FLOAT g_vWireframeBox[] =
{
    -1.0f,  1.0f,  1.0f,    1.0f,  1.0f,  1.0f,
    -1.0f,  1.0f, -1.0f,   -1.0f,  1.0f,  1.0f,
     1.0f,  1.0f, -1.0f,   -1.0f,  1.0f, -1.0f,
     1.0f,  1.0f,  1.0f,    1.0f,  1.0f, -1.0f,
    
    -1.0f, -1.0f,  1.0f,    1.0f, -1.0f,  1.0f,
    -1.0f, -1.0f, -1.0f,   -1.0f, -1.0f,  1.0f,
     1.0f, -1.0f, -1.0f,   -1.0f, -1.0f, -1.0f,
     1.0f, -1.0f,  1.0f,    1.0f, -1.0f, -1.0f,
    
    -1.0f,  1.0f,  1.0f,   -1.0f, -1.0f,  1.0f,
    -1.0f,  1.0f, -1.0f,   -1.0f, -1.0f, -1.0f,
     1.0f,  1.0f, -1.0f,    1.0f, -1.0f, -1.0f,
     1.0f,  1.0f,  1.0f,    1.0f, -1.0f,  1.0f,
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                  m_Font;
    CXBHelp                  m_Help;
    BOOL                     m_bDrawHelp;

    LPDIRECT3DVOLUMETEXTURE8 m_pVolumeTexture;
    LPDIRECT3DVERTEXBUFFER8  m_pVB;

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp      = FALSE;
    m_pVolumeTexture = NULL;
    m_pVB            = NULL;
}


#if 0
typedef struct D3DVOLUME_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    UINT                Size;

    UINT                Width;
    UINT                Height;
    UINT                Depth;
} aD3DVOLUME_DESC;
#endif


//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a volume texture
    hr = m_pd3dDevice->CreateVolumeTexture( VOLTEXSIZE, VOLTEXSIZE, VOLTEXSIZE, 
                                            1, 0, D3DFMT_A8R8G8B8, 
                                            D3DPOOL_DEFAULT, &m_pVolumeTexture );
    if( FAILED(hr) )
        return hr;

    // Fill the volume texture
    D3DVOLUME_DESC  desc;
    D3DLOCKED_BOX   lock;
    m_pVolumeTexture->GetLevelDesc( 0, &desc );
    m_pVolumeTexture->LockBox( 0, &lock, 0, 0L );
    DWORD* pBits = (DWORD*)lock.pBits;

    for( UINT w=0; w<VOLTEXSIZE; w++ )
    {
        for( UINT v=0; v<VOLTEXSIZE; v++ )
        {
            for( UINT u=0; u<VOLTEXSIZE; u++ )
            {
                FLOAT du = (2.0f*u)/(VOLTEXSIZE-1) - 1.0f;
                FLOAT dv = (2.0f*v)/(VOLTEXSIZE-1) - 1.0f;
                FLOAT dw = (2.0f*w)/(VOLTEXSIZE-1) - 1.0f;
                
                FLOAT fScale = 1.0f - sqrtf( du*du + dv*dv + dw*dw );
                if( fScale < 0.0f ) fScale = 0.0f;
                if( fScale > 1.0f ) fScale = 1.0f;

                DWORD r = (DWORD)(0xff*fScale);
                DWORD g = (DWORD)(0xff*fScale);
                DWORD b = (DWORD)(0xff*fScale);
                DWORD a = (DWORD)(0xff*fScale);
                if( a < 0x20 ) a = 0x20;

                // Write the texel
                *pBits++ = (a<<24) + (r<<16) + (g<<8) + (b<<0);
            }
        }
    }

    // Swizzle and unlock the texture
    XBUtil_SwizzleTexture3D( &lock, &desc );
    m_pVolumeTexture->UnlockBox( 0 );

    // Create a vertex buffer
    if( FAILED( hr = m_pd3dDevice->CreateVertexBuffer( 4*sizeof(VOLUMEVERTEX), D3DUSAGE_WRITEONLY,
                                                       D3DFVF_VOLUMEVERTEX, D3DPOOL_DEFAULT, &m_pVB ) ) )
        return hr;

    VOLUMEVERTEX* pVertices;
    m_pVB->Lock( 0, 4*sizeof(VOLUMEVERTEX), (BYTE**)&pVertices, 0 );
    memcpy( pVertices, g_vVertices, sizeof(VOLUMEVERTEX)*4 );
    m_pVB->Unlock();

    // Set the matrices
    D3DXVECTOR3 vEye(-2.5f, 2.0f, -4.0f );
    D3DXVECTOR3 vAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );
    D3DXMATRIX matWorld, matView, matProj;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &vEye,&vAt, &vUp );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Perform object rotation
    static D3DXMATRIX matWorld( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );
    D3DXMATRIX matRotate;
    FLOAT fXRotate1 = m_DefaultGamepad.fX1*m_fElapsedTime*D3DX_PI*0.5f;
    FLOAT fYRotate1 = m_DefaultGamepad.fY1*m_fElapsedTime*D3DX_PI*0.5f;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate1, -fYRotate1, 0.0f );
    D3DXMatrixMultiply( &matWorld, &matWorld, &matRotate );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Play with the volume texture coordinate
    VOLUMEVERTEX* pVertices = NULL;
    m_pVB->Lock( 0, 4*sizeof(VOLUMEVERTEX), (BYTE**)&pVertices, 0 );
    for( int i=0; i<4; i++ )
    {
        pVertices[i].z  = sinf(2*m_fAppTime);
        pVertices[i].tw = ( 1.0f + pVertices[i].z ) / 2.0f;
    }
    m_pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Set default state
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,     D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,     FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      TRUE );

    // Draw the wireframe box
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 12, g_vWireframeBox, 
                                   sizeof(D3DXVECTOR3) );

    // Setup states for drawing the quad
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSW,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

    // Draw the quad, with the volume texture
    m_pd3dDevice->SetTexture( 0, m_pVolumeTexture );
    m_pd3dDevice->SetVertexShader( D3DFVF_VOLUMEVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(VOLUMEVERTEX) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2);

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
		m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"VolumeTexture" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
		m_Font.End();
    }
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\xprviewer\textures.h ===
// Automatically generated by the bundler tool from textures.rdf

#define textures_NUM_RESOURCES 15UL

#define textures_Flame_OFFSET 0UL
#define textures_Forest_OFFSET 20UL
#define textures_greydirt_OFFSET 40UL
#define textures_lightoak_OFFSET 60UL
#define textures_ProcWood_OFFSET 80UL
#define textures_QuadVB_OFFSET 100UL
#define textures_Triangle_OFFSET 112UL
#define textures_FooIndex_OFFSET 124UL
#define textures_sdirt_OFFSET 136UL
#define textures_shground_OFFSET 156UL
#define textures_shrock_OFFSET 176UL
#define textures_temprock_OFFSET 196UL
#define textures_volslice_OFFSET 216UL
#define textures_waterbump_OFFSET 236UL
#define textures_undergrass_OFFSET 256UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\XRay\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\XRay\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ZSprite\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ZSprite\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ZSprite\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\XRay\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Crystal_OFFSET 0UL
#define resource_XRay1_OFFSET 20UL
#define resource_XRay2_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\XRay\xray.cpp ===
//-----------------------------------------------------------------------------
// File: XRay.cpp
//
// Desc: Example code showing how to an xray effect. This is basically a
//       spheremapping technique (see the SphereMap sample if you are new to
//       that technique) with alpha-blending and a carefully chosen spheremap.
//
//       In a real xray, more dense and/or thicker mass shows up more white, 
//       as less xrays are able to penetrate the mass and expose the film's
//       negative. The technique used by this sample is hardly "correct", but
//       it looks cool none-the-less. 
//
// Hist: 01.15.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>
#include <XBResource.h>
#include <xgraphics.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Crystal.bmp",  resource_Crystal_OFFSET },
    { "XRay1.bmp",    resource_XRay1_OFFSET },
    { "XRay2.bmp",    resource_XRay2_OFFSET },
    { NULL, 0 },
};


   

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Rotate\nobject" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Change\ntransparency" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Change\ntexture" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\nalpha" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle help" },
};

#define NUM_HELP_CALLOUTS 5




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;      // Packed resources for the app
    CXBFont            m_Font;             // Font class
    CXBHelp            m_Help;             // Help class
    BOOL               m_bDrawHelp;        // Whether to draw help

    // Geometry and textures
    CXBMesh*           m_pObject;
    LPDIRECT3DTEXTURE8 m_pSphereMapTexture;

    // Options
    DWORD              m_dwTextureSelection;
    BOOL               m_bAlphaEnabled;

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp          = FALSE;

    m_pObject            = new CXBMesh();
    m_pSphereMapTexture  = NULL;
    
    m_dwTextureSelection = 0L;
    m_bAlphaEnabled      = TRUE;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependent display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the spheremap texture
    m_pSphereMapTexture = m_xprResource.GetTexture( "XRay1.bmp" );

    // Load the object
    if( FAILED( m_pObject->Create( m_pd3dDevice, "Models\\Robot.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Misc render states
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,        0xffffffff );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,       D3DCULL_NONE );

    // Set up world matrix
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set up view matrix
    D3DXMATRIX  matView;
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 0.0f,-8.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set up proj matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 200.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Setup a base material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Select options
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
    {
        CHAR* strTextures[] = { "XRay1.bmp", "XRay2.bmp", "Crystal.bmp" };

        m_dwTextureSelection = (m_dwTextureSelection+1)%3;
        m_pSphereMapTexture = m_xprResource.GetTexture( strTextures[m_dwTextureSelection] );
    }

    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        m_bAlphaEnabled = !m_bAlphaEnabled;

    // Perform object rotation
    static D3DXMATRIX matWorld( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );
    D3DXMATRIX matRotate;
    FLOAT fXRotate = m_DefaultGamepad.fX1*m_fElapsedTime*D3DX_PI*0.5f;
    FLOAT fYRotate = m_DefaultGamepad.fY1*m_fElapsedTime*D3DX_PI*0.5f;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate, -fYRotate, 0.0f );
    D3DXMatrixMultiply( &matWorld, &matWorld, &matRotate );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff000000, 0xff0000ff );

    // Set some default state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,          0x00ffffff );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         TRUE );

    // Since xrays go through objects, it only looks convincing if we turn on
    // alpha-blending and render both sides of the object 
    if( m_bAlphaEnabled )
    {
        // Lighting is not needed, since we don't use the diffuse color
        m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,     FALSE );

        // Setup to render both sides of the object
        m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,     D3DCULL_NONE );

        // Turn on alpha blending
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,     D3DBLEND_SRCCOLOR );
        m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,    D3DBLEND_ONE );

        // Set the transparency
        DWORD a = (DWORD)((m_DefaultGamepad.fY2+1)*127.9f);
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0x01010101 * a );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TFACTOR );
    }

    // Setup the spheremap texture. Via the spheremapping texcoord generation
    // below, normals from the object are used to look up colors in this
    // spheremap. Choice of this spheremap, therefore, has the biggest effect
    // on the resulting look.
    m_pd3dDevice->SetTexture( 0, m_pSphereMapTexture );

    // Generate spheremap texture coords from the camera space normal. This has
    // two steps. First, tell D3D to use the vertex normal (in camera space) as
    // texture coordinates. Then, we setup a texture matrix to transform these
    // texcoords from (-1,+1) view space to (0,1) texture space. This way,
    // the normal can be used to look up a texel in the spheremap.
    D3DXMATRIX mat;
    mat._11 = 0.5f; mat._12 = 0.0f;
    mat._21 = 0.0f; mat._22 =-0.5f;
    mat._31 = 0.0f; mat._32 = 0.0f;
    mat._41 = 0.5f; mat._42 = 0.5f;
    m_pd3dDevice->SetTransform( D3DTS_TEXTURE0, &mat );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACENORMAL );

    // Finally, draw the object
    m_pObject->Render( m_pd3dDevice, XBMESH_NOTEXTURES|XBMESH_NOMATERIALS );

    // Restore render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,     TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_PASSTHRU );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"XRay" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        switch( m_dwTextureSelection )
        {
            case 0: m_Font.DrawText( 64, 75, 0xff00ffff, L"Using texture XRay1.bmp" ); break;
            case 1: m_Font.DrawText( 64, 75, 0xff00ffff, L"Using texture XRay2.bmp" ); break;
            case 2: m_Font.DrawText( 64, 75, 0xff00ffff, L"Using texture Crytstal.bmp" ); break;
        }

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ZSprite\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\xprviewer\XPRViewer.cpp ===
//-----------------------------------------------------------------------------
// File: XPRViewer.cpp
//
// Desc: Demonstrates how to load resources from an XPR (Xbox Packed Resource)
//       file.  
//
// Hist: 02.12.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Change texture\nsize" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Reload\nresources" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Cycle through\nresources" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Choose mipmap\nlevel" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS 5




#define MAX_NUM_RESOURCES 1024      // maximum this sample can handle

#define FMT_SWIZZLED   0x1
#define FMT_LINEAR     0x2
#define FMT_COMPRESSED 0x4


const struct TEXTUREFORMAT
{
    WCHAR* name;
    DWORD  id;
    DWORD  type;
} g_TextureFormats[] = 
{
    { L"D3DFMT_A8R8G8B8",        D3DFMT_A8R8G8B8,      FMT_SWIZZLED    },
    { L"D3DFMT_LIN_A8R8G8B8",    D3DFMT_LIN_A8R8G8B8,  FMT_LINEAR      },
    { L"D3DFMT_X8R8G8B8",        D3DFMT_X8R8G8B8,      FMT_SWIZZLED    },
    { L"D3DFMT_LIN_X8R8G8B8",    D3DFMT_LIN_X8R8G8B8,  FMT_LINEAR      },
    { L"D3DFMT_R5G6B5",          D3DFMT_R5G6B5,        FMT_SWIZZLED    },
    { L"D3DFMT_LIN_R5G6B5",      D3DFMT_LIN_R5G6B5,    FMT_LINEAR      },
    { L"D3DFMT_A1R5G5B5",        D3DFMT_A1R5G5B5,      FMT_SWIZZLED    },
    { L"D3DFMT_LIN_A1R5G5B5",    D3DFMT_LIN_A1R5G5B5,  FMT_LINEAR      },
    { L"D3DFMT_A4R4G4B4",        D3DFMT_A4R4G4B4,      FMT_SWIZZLED    },
    { L"D3DFMT_LIN_A4R4G4B4",    D3DFMT_LIN_A4R4G4B4,  FMT_LINEAR      },
    { L"D3DFMT_DXT1",            D3DFMT_DXT1,          FMT_COMPRESSED  },
    { L"D3DFMT_DXT2",            D3DFMT_DXT2,          FMT_COMPRESSED  },
    { L"D3DFMT_DXT4",            D3DFMT_DXT4,          FMT_COMPRESSED  },
    { L"",                       0,                    0               },
};


// Define our vertex format
struct CUSTOMVERTEX
{
    D3DXVECTOR3 p;          // Position
    D3DXVECTOR3 n;          // normal
    D3DCOLOR    diffuse;    // Diffuse color
    FLOAT       tu, tv;     // Texture coordinates
};
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE|D3DFVF_TEX1)



DWORD  g_ResourceCount = 0;     // count of loaded resources

// Macro to simplify reads from file
#define READFROMFILE( file, buff, size ) if( !ReadFile( file, buff, size, &cb, NULL ) ) { hr = E_FAIL; goto Done;}

DWORD exptbl[] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,0,0,0,0,0,0};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Member variables
    CXBHelp                 m_Help;                 // Help data
    BOOL                    m_bDrawHelp;            // Should we draw help info?
    CXBFont                 m_Font;                 // Font for rendering text

    LPDIRECT3DTEXTURE8      m_ppResources[MAX_NUM_RESOURCES]; // Array of pointers to resources
    DWORD                   m_dwTypes[MAX_NUM_RESOURCES]; // Array of resource types
    DWORD                   m_nCurrent;             // Currently displayed texture
    char                    m_strBundle[MAX_PATH];  // Name of the xpr bundle to load (w/out extension)

    LPDIRECT3DVERTEXBUFFER8 m_pQuadVB;              // Quad for displaying textures
    FLOAT                   m_fWidth;
    FLOAT                   m_fHeight;
    DWORD                   m_nMipLevel;            // which texture mipmap level to display

    HANDLE                  m_hfXPR;                // File handle for async i/o
    BYTE *                  m_pbHeaders;            // Header memory
    DWORD                   m_cbHeaders;            // Count of bytes of resource headers
    BYTE *                  m_pbData;               // Texture data memory
    DWORD                   m_cbData;               // Count of bytes of data
    OVERLAPPED              m_overlapped;           // OVERLAPPED structure for async I/O
    BOOL                    m_bLoading;             // Still doing async I/O?

    // Creates and sets up our vertex buffer
    HRESULT InitGeometry( FLOAT fWidth, FLOAT fHeight, FLOAT fMaxU, FLOAT fMaxV );

    // Loads the resources out of the specified bundle
    HRESULT LoadResourcesFromXPR( LPDIRECT3DDEVICE8 pDevice, LPSTR strFileBase );

    // Called when Async I/O is complete to register the resources
    HRESULT OnIOComplete();

public:
    CXBoxSample();
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
void __cdecl main()
{
    CXBoxSample xbApp;

    if( FAILED( xbApp.Create() ) )
        return;

    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Initialize member varaibles
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp     = FALSE;
    m_pQuadVB       = NULL;
    m_fWidth        = 1.0f;
    m_fHeight       = 1.0f;
    m_nCurrent      = 0;
    m_pbHeaders     = NULL;
    m_cbHeaders     = 0;
    m_pbData        = NULL;
    m_bLoading      = FALSE;
    m_nMipLevel     = -1;
    lstrcpyA( m_strBundle, "D:\\Media\\Textures\\textures.xpr" );
}




//-----------------------------------------------------------------------------
// Name: InitGeometry()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitGeometry( FLOAT fWidth, FLOAT fHeight, FLOAT fMaxU, FLOAT fMaxV )
{
    // Create and lock our vertex buffer
    if( NULL == m_pQuadVB )
    {
        if( FAILED( m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( CUSTOMVERTEX ), D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX, D3DPOOL_MANAGED, &m_pQuadVB ) ) )
            return E_FAIL;
    }
    
    // Set up a quad in the vertex buffer
    CUSTOMVERTEX* pVertices;
    if( FAILED( m_pQuadVB->Lock( 0, 0, (BYTE **)&pVertices, 0L ) ) )
        return E_FAIL;

    pVertices[0].p  = D3DXVECTOR3( -fWidth/2, -fHeight/2, 1.0f );
    pVertices[0].n  = D3DXVECTOR3(  0.0f, 0.0f, -1.0f );
    pVertices[0].diffuse = 0xFFFFFFFF;
    pVertices[0].tu = 0.0f; 
    pVertices[0].tv = fMaxV;

    pVertices[1].p  = D3DXVECTOR3( -fWidth/2, fHeight/2, 1.0f );
    pVertices[1].n  = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    pVertices[1].diffuse = 0xFFFFFFFF;
    pVertices[1].tu = 0.0f; 
    pVertices[1].tv = 0.0f;

    pVertices[2].p  = D3DXVECTOR3( fWidth/2, -fHeight/2, 1.0f );
    pVertices[2].n  = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    pVertices[2].diffuse = 0xFFFFFFFF;
    pVertices[2].tu = fMaxU; 
    pVertices[2].tv = fMaxV;

    pVertices[3].p  = D3DXVECTOR3( fWidth/2, fHeight/2, 1.0f );
    pVertices[3].n  = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    pVertices[3].diffuse = 0xFFFFFFFF;
    pVertices[3].tu = fMaxU; 
    pVertices[3].tv = 0.0f;

    m_pQuadVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Performs whatever set-up is needed, for example, loading textures,
//       creating vertex buffers, etc.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set up our vertex buffer
    if( FAILED( InitGeometry( m_fWidth, m_fHeight, 1.0f, 1.0f ) ) )
        return E_FAIL;

    // Set up our view, projection, and world matrices
    D3DXMATRIX matView;
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 1.0f );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, 1.0f, 1.0f, 10.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set up a light
    D3DLIGHT8 m_Light;

    ZeroMemory( &m_Light, sizeof( D3DLIGHT8 ) );
    m_Light.Type = D3DLIGHT_DIRECTIONAL;
    m_Light.Diffuse.r = 1.0f;
    m_Light.Diffuse.g = 1.0f;
    m_Light.Diffuse.b = 1.0f;
    m_Light.Diffuse.a = 1.0f;
    m_Light.Direction = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
    m_pd3dDevice->SetLight( 0, &m_Light );
    m_pd3dDevice->LightEnable( 0, TRUE );

    // Load our resources from the file
    if( FAILED( LoadResourcesFromXPR( m_pd3dDevice, m_strBundle ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Handles controller input each frame
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Check for IO completion
    if( m_bLoading && HasOverlappedIoCompleted( &m_overlapped ) )
        OnIOComplete();

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    if( !m_bLoading )
    {
        // Left thumbstick resizes quad
        m_fWidth  = max( 0.01f, min( 2.0f, m_fWidth  *= (0.01f*m_DefaultGamepad.fX1+1) ) );
        m_fHeight = max( 0.01f, min( 2.0f, m_fHeight *= (0.01f*m_DefaultGamepad.fY1+1) ) );

        // A button reloads the resources
        if( m_DefaultGamepad.bPressedAnalogButtons[0] )
        {
            if( FAILED( LoadResourcesFromXPR( m_pd3dDevice, m_strBundle ) ) )
                return E_FAIL;
            m_nCurrent  = 0;
            m_fWidth    = 1.0f;
            m_fHeight   = 1.0f;
            m_nMipLevel = -1;
        }

        // B button cycles between resources
        if( m_DefaultGamepad.bPressedAnalogButtons[1] )
        {
            m_nCurrent  = ( m_nCurrent + 1 ) % g_ResourceCount;
            m_fWidth    = 1.0f;
            m_fHeight   = 1.0f;
            m_nMipLevel = -1;
        }

        // DPAD moves between mipmap levels
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP)
            m_nMipLevel++;
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN)
        {
            if( m_nMipLevel != -1 )
                m_nMipLevel--;
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Performs the graphics operations to render the texture on screen
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    WCHAR strDescription[MAX_PATH];

    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    RenderGradientBackground( 0x0000ffff, 0x00ffffff );

    wcscpy(strDescription, L"");
    if( m_bLoading )
    {
        // If we're still reading from disk, display a loading message
        m_Font.DrawText( 150, 200, 0xffff0000, L"Loading resources from XPR..." );
    }
    else
    {
        DWORD dwFmt, *pRes, dwDim, dwU, dwV, dwP, dwLevels, dwCube;
        WCHAR *pTexType, strRes[256], strLevels[256];

        // Get info about resource and prepare description string
        switch( m_dwTypes[m_nCurrent] )
        {
            case D3DCOMMON_TYPE_TEXTURE:
                pRes  = (DWORD *)m_ppResources[m_nCurrent];
                dwFmt = (*(pRes+3) & D3DFORMAT_FORMAT_MASK) >> D3DFORMAT_FORMAT_SHIFT;
                for(UINT x=0; g_TextureFormats[x].id != 0; x++)
                    if(g_TextureFormats[x].id == dwFmt)
                        break;
                if(g_TextureFormats[x].id != 0)
                {
                    // get information about the texture
                    dwDim    = (*(pRes+3) & D3DFORMAT_DIMENSION_MASK) >> D3DFORMAT_DIMENSION_SHIFT;
                    dwLevels = (*(pRes+3) & D3DFORMAT_MIPMAP_MASK) >> D3DFORMAT_MIPMAP_SHIFT;
                    dwCube   = (*(pRes+3) & D3DFORMAT_CUBEMAP);
                    if(g_TextureFormats[x].type == FMT_LINEAR)
                    {
                        dwU = (*(pRes+4) & D3DSIZE_WIDTH_MASK)+1;
                        dwV = ((*(pRes+4) & D3DSIZE_HEIGHT_MASK) >> D3DSIZE_HEIGHT_SHIFT) + 1;
                    }
                    else
                    {
                        dwU = exptbl[(*(pRes+3) & D3DFORMAT_USIZE_MASK) >> D3DFORMAT_USIZE_SHIFT];
                        dwV = exptbl[(*(pRes+3) & D3DFORMAT_VSIZE_MASK) >> D3DFORMAT_VSIZE_SHIFT];
                        dwP = exptbl[(*(pRes+3) & D3DFORMAT_PSIZE_MASK) >> D3DFORMAT_PSIZE_SHIFT];
                    }

                    if(dwDim == 2)
                    {
                        swprintf( strRes, L"%dx%d", dwU, dwV );
                        pTexType = L"2D Texture";
                    }
                    else if(dwCube)
                    {
                        swprintf( strRes, L"%dx%d", dwU, dwV );
                        pTexType = L"Cubemap";
                    }
                    else
                    {
                        pTexType = L"3D Texture";
                        swprintf( strRes, L"%dx%dx%d", dwU, dwV, dwP );
                    }

                    if( dwLevels == 1 )
                        swprintf( strLevels, L"1 level");
                    else
                    {
                        if( m_nMipLevel == -1 )
                            swprintf( strLevels, L"%d levels", dwLevels );
                        else
                        {
                            if( m_nMipLevel >= dwLevels )
                                m_nMipLevel = dwLevels - 1; // constrain choice of miplevel to appropriate range
                            swprintf( strLevels, L"level %d of %d levels", m_nMipLevel, dwLevels );
                        }
                    }

                    swprintf( strDescription, L"Resource %d of %d is a %s\n%s %s %s\n", 
                                       m_nCurrent + 1, g_ResourceCount, pTexType, strRes, 
                                       g_TextureFormats[x].name, strLevels );
                }
                else
                {
                    swprintf( strDescription, L"Resource %d of %d is a Texture\n", 
                                       m_nCurrent + 1, g_ResourceCount );
                }
                break;

            case D3DCOMMON_TYPE_VERTEXBUFFER:
                swprintf( strDescription, L"Resource %d of %d is a VertexBuffer\n", 
                                   m_nCurrent + 1, g_ResourceCount);
                break;
            case D3DCOMMON_TYPE_INDEXBUFFER:
                swprintf( strDescription, L"Resource %d of %d is an Index Buffer\n",
                                   m_nCurrent + 1, g_ResourceCount );
        }

        // Draw quad
        if( m_dwTypes[m_nCurrent] == D3DCOMMON_TYPE_TEXTURE )
        {
            pRes  = (DWORD *)m_ppResources[m_nCurrent];
            dwFmt = (*(pRes+3) & D3DFORMAT_FORMAT_MASK) >> D3DFORMAT_FORMAT_SHIFT;
            for(UINT x=0; g_TextureFormats[x].id != 0; x++)
                if(g_TextureFormats[x].id == dwFmt)
                    break;
            if( g_TextureFormats[x].id != 0 )
            {
                // Set up quad to render
                if(g_TextureFormats[x].type == FMT_LINEAR)
                {
                    dwU = (*(pRes+4) & D3DSIZE_WIDTH_MASK)+1;
                    dwV = ((*(pRes+4) & D3DSIZE_HEIGHT_MASK) >> D3DSIZE_HEIGHT_SHIFT) + 1;
                    InitGeometry( m_fWidth, m_fHeight, (FLOAT)dwU, (FLOAT)dwV );
                }
                else
                {
                    InitGeometry( m_fWidth, m_fHeight, 1.0f, 1.0f );
                }
            }

            // Set up our render and texture stage states
            m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
            m_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    
            m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
            m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
            m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,    D3DBLEND_SRCALPHA );
            m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,   D3DBLEND_INVSRCALPHA );
            
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TEXTURE );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSW,  D3DTADDRESS_CLAMP );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
            if( m_nMipLevel == -1 )
            {
                // blend between miplevels for ordinary texture mapping
                m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
                m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAXMIPLEVEL, 0);  // use the most-detailed level as appropriate
                m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPMAPLODBIAS, 0);        
            }
            else
            {
                // draw just the desired miplevel
                m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
                m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
                m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_POINT );
                m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAXMIPLEVEL, m_nMipLevel);    // use just the desired miplevel
                m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPMAPLODBIAS, FtoDW(-100.f));    // bias choice to desired miplevel
            }
 
            // Select our texture and quad
            m_pd3dDevice->SetTexture( 0, m_ppResources[m_nCurrent] );
            m_pd3dDevice->SetStreamSource( 0, m_pQuadVB, sizeof( CUSTOMVERTEX ) );

            // Draw the quad
            m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

            // Unselect the texture
            m_pd3dDevice->SetTexture( 0, NULL );
        }
    }

    // Show title, frame rate, resource description, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"XPRViewer" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.DrawText(  64, 80, 0xff0000ff, strDescription );
       m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SizeOfResource()
// Desc: Determines the size, in bytes, of the D3DResource pointed to by 
//       pRes.
//-----------------------------------------------------------------------------
static DWORD SizeOfResource( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:
            return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE:
            return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:
            return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:
            return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:
            return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:
            return sizeof(D3DPalette);
        default:
            return 0;
    }
}




//-----------------------------------------------------------------------------
// Name: LoadResourcesFromXPR()
// Desc: Loads all the texture resources from the given XPR. ppResources should 
//       be large enough to hold all the LPDIRECT3DRESOURCE8 pointers.  
//       The read is performed asynchronously, so the data isn't available
//       until OnIOComplete().
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::LoadResourcesFromXPR( LPDIRECT3DDEVICE8 pDevice, LPSTR strFileName )
{
    HRESULT     hr = S_OK;
    XPR_HEADER  xprh;
    HANDLE      hfHeader = INVALID_HANDLE_VALUE;
    DWORD       cb;

    // Free up the previous allocation, if necessary
    if( m_pbHeaders )
    {
        delete[] m_pbHeaders;
        m_pbHeaders = NULL;
        m_cbHeaders = 0;
    }
    if( m_pbData )
    {
        D3D_FreeContiguousMemory( m_pbData );
        m_pbData = NULL;
        m_cbData = 0;
    }

    // Read out the headers first
    hfHeader = CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                           OPEN_EXISTING, 0, NULL );
    if( hfHeader == INVALID_HANDLE_VALUE )
    {
        hr = E_FAIL;
        goto Done;
    }

    // Verify the XPR magic header
    READFROMFILE( hfHeader, &xprh, sizeof( XPR_HEADER) );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        hr = E_INVALIDARG;
        goto Done;
    }

    // Allocate memory for the headers
    m_cbHeaders = xprh.dwHeaderSize - 3 * sizeof( DWORD );
    m_pbHeaders = new BYTE[m_cbHeaders];
    if( !m_pbHeaders )
    {
        hr = E_OUTOFMEMORY;
        goto Done;
    }

    // Read in the headers
    READFROMFILE( hfHeader, m_pbHeaders, m_cbHeaders );

    CloseHandle( hfHeader );

    // Now read the data
    // File is opened with overlapped i/o and no buffering
    m_hfXPR = CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                          OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, NULL );
    if( m_hfXPR == INVALID_HANDLE_VALUE )
    {
        hr = E_FAIL;
        goto Done;
    }

    // Allocate contiguous memory for the texture data
    m_cbData = xprh.dwTotalSize - xprh.dwHeaderSize;
    m_pbData = (BYTE *)D3D_AllocContiguousMemory( m_cbData, D3DTEXTURE_ALIGNMENT );
    if( !m_pbData )
    {
        hr = E_OUTOFMEMORY;
        goto Done;
    }

    // Set up our overlapped i/o struct
    ZeroMemory( &m_overlapped, sizeof( OVERLAPPED ) );
    m_overlapped.Offset = xprh.dwHeaderSize;

    // Start the read of the texture data
    if( !ReadFile( m_hfXPR, m_pbData, m_cbData, &cb, &m_overlapped ) )
    {
        if( GetLastError() == ERROR_IO_PENDING )
            m_bLoading = TRUE;
        else
        {
            // Error we weren't expecting
            hr = E_FAIL;
            goto Done;
        }
    }

Done:
    // Lots of cleanup to do
    if( INVALID_HANDLE_VALUE != hfHeader )
        CloseHandle( hfHeader );

    // If we had an error condition, we need to 
    // free memory and close the XPR file
    if( FAILED( hr ) )
    {
        m_bLoading = FALSE;
        if( INVALID_HANDLE_VALUE != m_hfXPR )
            CloseHandle( m_hfXPR );

        delete[] m_pbHeaders;
        if( m_pbData )
            D3D_FreeContiguousMemory( m_pbData );
    }

    return hr;
}




//-----------------------------------------------------------------------------
// Name: OnIOComplete()
// Desc: Called when async i/o is complete, so that we can copy the
//       texture data to video memory and register the resources.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::OnIOComplete()
{
    BYTE      * pbCurrent;
    LPDIRECT3DRESOURCE8 * ppResources = (LPDIRECT3DRESOURCE8 *)m_ppResources;

    // Loop over resources, calling Register()
    pbCurrent = m_pbHeaders;
    for( int i = 0; i < MAX_NUM_RESOURCES; i++ )
    {
        DWORD type = *((DWORD *)pbCurrent) & D3DCOMMON_TYPE_MASK;

        if((type != D3DCOMMON_TYPE_VERTEXBUFFER) &&
           (type != D3DCOMMON_TYPE_TEXTURE) &&
           (type != D3DCOMMON_TYPE_INDEXBUFFER))
            break;
        
        ppResources[i] = (LPDIRECT3DRESOURCE8)pbCurrent;
        m_dwTypes[i] = type;
        pbCurrent += SizeOfResource( ppResources[i] );

        // Index Buffers should not be Register()'d
        if( type != D3DCOMMON_TYPE_INDEXBUFFER )
            ppResources[i]->Register( m_pbData );
    }

    g_ResourceCount = i;

    // Done with async XPR load
    m_bLoading = FALSE;
    CloseHandle( m_hfXPR );
    m_hfXPR = INVALID_HANDLE_VALUE;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\XRay\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Crystal_OFFSET 0UL
#define resource_XRay1_OFFSET 20UL
#define resource_XRay2_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ZSprite\ZSprite.cpp ===
//-----------------------------------------------------------------------------
// File: ZSprite.cpp
//
// Desc: Demonstrates how to create and render a ZSprite.  The ZSprite is 
//       generated by rendering a model into 2 textures.  The first texture
//       contains the color data, and the second contains the depth information
//       It is then rendered with a pixel shader using the Dot_ZW texture 
//       address mode to recreate the z values.
//
// Hist: 2.28.01 - New for April XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>
#include <xgraphics.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Dump depth buffer" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move camera" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 4




//-----------------------------------------------------------------------------
// Externals and globals
//-----------------------------------------------------------------------------
#define ZTEX_WIDTH  1024
#define ZTEX_HEIGHT  512


struct CUSTOMVERTEX
{
    D3DXVECTOR4 p;
    FLOAT       tu, tv;       // Texture 0 - this is the actual texture
};

#define FVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)


struct PLANEVERTEX
{
    D3DXVECTOR3 p;
    D3DCOLOR    c;
};

#define FVF_PLANEVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)


// List of positions for our models
D3DXVECTOR3 g_vTeapotPositions[] = 
{
    D3DXVECTOR3( 1.0f, 0.0f,-2.0f ),
    D3DXVECTOR3(-1.0f, 0.0f, 0.0f ),
    D3DXVECTOR3(-2.0f, 0.0f,-1.5f ),
    D3DXVECTOR3( 3.0f, 0.0f, 2.0f ),
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont     m_Font;                 // Font for text display
    CXBHelp     m_Help;                 // Help object
    BOOL        m_bDrawHelp;            // Should we draw help?

    CXBMesh     m_Mesh;                 // Mesh for teapot model

    BOOL        m_bDrawPlane;           // Draw an intersection plane to show z
    D3DXVECTOR3 m_vViewAngle;           // View angle of camera

    DWORD       m_dwPixelShader;        // Pixel shader handle
    DWORD       m_dwVertexShader;       // Vertex shader handle

    LPDIRECT3DVERTEXBUFFER8 m_pZSpriteVB; // Vertex buffer for ZSprite quad
    LPDIRECT3DTEXTURE8 m_pImageTexture;   // Texture for image data
    LPDIRECT3DTEXTURE8 m_pZTexture;       // Texture for depth data
    LPDIRECT3DSURFACE8 m_pZSpriteRenderTarget;
    LPDIRECT3DSURFACE8 m_pZSpriteDepthBuffer;

    LPDIRECT3DVERTEXBUFFER8 m_pPlaneVB;   // Plane to show z values

    VOID    SetViewTransform();         // Sets the view transform
    HRESULT InitPixelShader();          // Initialize and create pixel shader
    HRESULT InitVertexShader();         // Initialize and create vertex shader
    HRESULT RenderToZTexture();         // Render a scene into the ZSprite
    HRESULT RenderZSprite();            // Renders the ZSprite on a quad
    HRESULT DumpDepthBuffer( const CHAR* strFileName ); // Dump depth buffer to TGA

public:
    HRESULT Initialize();       // Initialize the sample
    HRESULT Render();           // Render the scene
    HRESULT FrameMove();        // Perform per-frame updates

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp  = FALSE;
    m_bDrawPlane = TRUE;
}




//-----------------------------------------------------------------------------
// Name: InitPixelShader
// Desc: Sets up our hard-coded pixel shader
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitPixelShader()
{
    D3DPIXELSHADERDEF psd;

    ZeroMemory( &psd, sizeof( D3DPIXELSHADERDEF ) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 1, 0 );
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D,  // Real texture
                                           PS_TEXTUREMODES_PROJECT2D,  // ZW texture
                                           PS_TEXTUREMODES_DOTPRODUCT, // (s0, t0, r0).(z, w, 1)
                                           PS_TEXTUREMODES_DOT_ZW );   // (s1, t1, r1).(z, w, 1)
    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 1, 1 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0,
                                         0,
                                         PS_DOTMAPPING_HILO_1,
                                         PS_DOTMAPPING_HILO_1 );
    psd.PSCompareMode   = PS_COMPAREMODE( 
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    //--------------------------
    // Stage 0 
    //--------------------------

    // A=T0.rgb, B=V0, C=0, D=0 (so that AB.rgb = T0*V0 and CD = 0 )
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS(
        PS_REGISTER_T0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_V0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
    // A=T0.a, B=1, C=0, D=0 (so that AB.a = T0.a and CD = 0 )
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS(
        PS_REGISTER_T0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
    // R0.rgb = AB
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    
    // R0.a = AB
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    
    psd.PSConstant0[0]    = 0x00000000;
    psd.PSConstant1[0]    = 0x00000000;

    //--------------------------
    // Final combiner
    //--------------------------
    psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // E = 0, F = 0, G = 1. (From above, EF is not used. G is alpha and is set to R0.a.)
    psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        0 | 0 | 0 );
    psd.PSC0Mapping = 0x00000000;
    psd.PSC1Mapping = 0x00000000;

    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwPixelShader ) ) )
    {
        OUTPUT_DEBUG_STRING( "Couldn't create pixel shader.\n" );
        return E_FAIL;
    }

    return S_OK;
}





//-----------------------------------------------------------------------------
// Name: InitVertexShader
// Desc: Initializes and creates our vertex shader.  Also sets up vertex
//       shader constants that don't change:
//       * texture coordinates for stages 2 and 3
//       * diffuse color
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitVertexShader()
{
    // Setup the vertex declaration
    DWORD dwDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT4 ), // v0 = Position
        D3DVSD_REG( 7, D3DVSDT_FLOAT2 ), // v7 = Texcoords
        D3DVSD_END()
    };

    // Create the vertex shader
    XBUtil_CreateVertexShader( m_pd3dDevice, "shaders\\zsprite.xvu", dwDecl, &m_dwVertexShader );
    
    // Set vertex shader constants
    D3DXVECTOR3 v4( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 v5( 0.0f, 0.0f, 1.0f/FLOAT(D3DZ_MAX_D24S8) );
    D3DXVECTOR3 v6( 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetVertexShaderConstant( 4, &v4, 1 );
    m_pd3dDevice->SetVertexShaderConstant( 5, &v5, 1 );
    m_pd3dDevice->SetVertexShaderConstant( 6, &v6, 1 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load our geometry
    if( FAILED( m_Mesh.Create( m_pd3dDevice, "Models\\Teapot.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a quad for our ZSprite
    m_pd3dDevice->CreateVertexBuffer( 4 * sizeof(CUSTOMVERTEX), D3DUSAGE_WRITEONLY, 
                                      FVF_CUSTOMVERTEX, D3DPOOL_MANAGED, &m_pZSpriteVB );
    CUSTOMVERTEX* pVertices;
    m_pZSpriteVB->Lock( 0, 0, (BYTE **)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR4( -1.0f,  -1.0f, 0.5f, 1.0f ); 
    pVertices[0].tu = 0.0f; pVertices[0].tv = 1.0f;
    pVertices[1].p = D3DXVECTOR4( -1.0f,   1.0f, 0.5f, 1.0f ); 
    pVertices[1].tu = 0.0f; pVertices[1].tv = 0.0f;
    pVertices[2].p = D3DXVECTOR4(  1.0f,  -1.0f, 0.5f, 1.0f ); 
    pVertices[2].tu = 1.0f; pVertices[2].tv = 1.0f;
    pVertices[3].p = D3DXVECTOR4(  1.0f,   1.0f, 0.5f, 1.0f ); 
    pVertices[3].tu = 1.0f; pVertices[3].tv = 0.0f;
    m_pZSpriteVB->Unlock();

    // Create a quad for our intersecting plane
    m_pd3dDevice->CreateVertexBuffer( 4*sizeof(PLANEVERTEX), D3DUSAGE_WRITEONLY, 
                                      FVF_PLANEVERTEX, D3DPOOL_MANAGED, &m_pPlaneVB );
    PLANEVERTEX* pPV;
    m_pPlaneVB->Lock( 0, 0, (BYTE **)&pPV, 0 );
    pPV[0].p = D3DXVECTOR3( -5.0f,  -1.0f, 0.0f );  pPV[0].c = 0xFFFFFFFF;
    pPV[1].p = D3DXVECTOR3( -5.0f,   1.0f, 0.0f );  pPV[1].c = 0xFFFFFFFF;
    pPV[2].p = D3DXVECTOR3(  5.0f,  -1.0f, 0.0f );  pPV[2].c = 0xFFFFFFFF;
    pPV[3].p = D3DXVECTOR3(  5.0f,   1.0f, 0.0f );  pPV[3].c = 0xFFFFFFFF;
    m_pPlaneVB->Unlock();

    // Create a texture to render into
    if( FAILED( m_pd3dDevice->CreateTexture( ZTEX_WIDTH, ZTEX_HEIGHT, 1, 
                                             D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, 
                                             D3DPOOL_MANAGED, &m_pImageTexture ) ) )
        return E_FAIL;

    // Create our depth map
    if( FAILED( m_pd3dDevice->CreateTexture( ZTEX_WIDTH, ZTEX_HEIGHT, 1, 
                                             D3DUSAGE_DEPTHSTENCIL, D3DFMT_A8R8G8B8, 
                                             D3DPOOL_MANAGED, &m_pZTexture ) ) )
        return E_FAIL;

    // Get the surfaces to render into the above textures
    m_pImageTexture->GetSurfaceLevel( 0, &m_pZSpriteRenderTarget );
    m_pZTexture->GetSurfaceLevel( 0, &m_pZSpriteDepthBuffer );

    // Pretend our depth map is actually a Depth/Stencil surface
    m_pZSpriteDepthBuffer->Format &= ~D3DFORMAT_FORMAT_MASK;
    m_pZSpriteDepthBuffer->Format |= (D3DFMT_LIN_D24S8 << D3DFORMAT_FORMAT_SHIFT);

    // Set up our Shaders
    if( FAILED( InitVertexShader() ) )
        return E_FAIL;
    if( FAILED( InitPixelShader() ) )
        return E_FAIL;

    m_vViewAngle = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );

    // World transform is just identity
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set the view transform based on view angle
    SetViewTransform();

    // Projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, 4.0f/3.0f, 2.0f, 15.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Create a light for rendering to the texture and depth map
    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof( D3DLIGHT8 ) );
    light.Type = D3DLIGHT_DIRECTIONAL;
    light.Diffuse.r = light.Diffuse.g = light.Diffuse.b = light.Diffuse.a = 0.9f;
    light.Direction = D3DXVECTOR3( -0.5f, -1.0f, 1.0f );
    m_pd3dDevice->SetLight( 0, &light );

    if( FAILED( RenderToZTexture() ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToZTexture
// Desc: Renders some stuff for our Z Texture.  Actually renders the object
//       into a depth/stencil surface and a texture.  Texture becomes the image
//       and the depth/stencil surface will get converted to a Z texture
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderToZTexture()
{
    // Save old state
    D3DXMATRIX matWorldSave;
    m_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorldSave );

    // Render the scene into our depth and image surfaces
    m_pd3dDevice->SetRenderTarget( m_pZSpriteRenderTarget, m_pZSpriteDepthBuffer );
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );

    // Set up our render state
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );

    // Render each teapot
    for( DWORD i = 0; i < 4; i++ )
    {
        D3DXMATRIX matWorld;
        D3DXMatrixTranslation( &matWorld, g_vTeapotPositions[i].x, 
                                          g_vTeapotPositions[i].y, 
                                          g_vTeapotPositions[i].z );
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );
        m_Mesh.Render( m_pd3dDevice );
    }

    // Restore state
    m_pd3dDevice->SetRenderTarget( m_pBackBuffer, m_pDepthBuffer );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorldSave );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetViewTransform
// Desc: Sets the view transform based on the view angle
//-----------------------------------------------------------------------------
VOID CXBoxSample::SetViewTransform()
{
    D3DXMATRIX matView;
    D3DXMATRIX m;
    D3DXVECTOR3 vEyePos;
    D3DXVECTOR3 vCameraPos( 0.0f, 0.0f, -8.0f );
    D3DXVECTOR3 vLookAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f);

    // Create a rotation matrix for our view angle
    D3DXMatrixRotationYawPitchRoll(&m, m_vViewAngle.y, m_vViewAngle.x, m_vViewAngle.z);

    // Transform our camera position (on the Z axis)
    D3DXVec3TransformCoord(&vEyePos, &vCameraPos, &m);
    
    // Use that eye position and look at the origin
    D3DXMatrixLookAtLH(&matView, &vEyePos, &vLookAt, &vUp);

    m_pd3dDevice->SetTransform(D3DTS_VIEW, &matView);
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DXVECTOR3 vViewAngleOld = m_vViewAngle;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
        m_bDrawHelp = !m_bDrawHelp;

    // Dump the zbuffer surface to a .tga image file
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        DumpDepthBuffer( "d:\\ZBuffer.tga" );

    // Move the camera based off the gamepad
    m_vViewAngle.y -= m_DefaultGamepad.fX1*1.0f*m_fElapsedTime;
    if( m_vViewAngle.y > D3DX_PI*2 )
        m_vViewAngle.y -= D3DX_PI*2;
    if( m_vViewAngle.y < 0.0f)
        m_vViewAngle.y += D3DX_PI*2;

    m_vViewAngle.x += m_DefaultGamepad.fY1*1.0f*m_fElapsedTime;
    if( m_vViewAngle.x > 1.0f )
        m_vViewAngle.x = 1.0f;
    if( m_vViewAngle.x < -1.0f )
        m_vViewAngle.x = -1.0f;

    // If the view changed, re-render the scene into the zsprite
    if( vViewAngleOld != m_vViewAngle )
    {
        SetViewTransform();

        if( FAILED( RenderToZTexture() ) )
            return E_FAIL;
    }

    // Move the plane back and forth
    PLANEVERTEX* pPV;
    FLOAT fZ      = FLOAT( cosf( m_fAppTime ) ) * 3.0f;
    FLOAT fColor  = fZ / 6.0f + 0.5f;
    DWORD dwColor = DWORD(fColor * 255);
    m_pPlaneVB->Lock( 0, 0, (BYTE **)&pPV, 0 );
    pPV[0].p.z = fZ; pPV[0].c = D3DCOLOR_ARGB( 255, dwColor, dwColor, dwColor );
    pPV[1].p.z = fZ; pPV[1].c = D3DCOLOR_ARGB( 255, dwColor, dwColor, dwColor );
    pPV[2].p.z = fZ; pPV[2].c = D3DCOLOR_ARGB( 255, dwColor, dwColor, dwColor );
    pPV[3].p.z = fZ; pPV[3].c = D3DCOLOR_ARGB( 255, dwColor, dwColor, dwColor );
    m_pPlaneVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderZSprite
// Desc: Handles the rendering of the ZSprite
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderZSprite()
{
    // Set up our source & textures for the ZSprite
    // Note that which textures we specify for stages
    // 2 and 3 doesn't matter - but our texture coordinates
    // won't make it through to the pixel shader unless
    // there's SOMETHING specified.

    m_pd3dDevice->SetTexture( 0, m_pImageTexture );
    m_pd3dDevice->SetTexture( 1, m_pZTexture );
    m_pd3dDevice->SetTexture( 2, NULL );
    m_pd3dDevice->SetTexture( 3, m_pImageTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pZSpriteVB, sizeof( CUSTOMVERTEX ) );

    m_pd3dDevice->SetVertexShader( m_dwVertexShader );
    m_pd3dDevice->SetPixelShader( m_dwPixelShader );

    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );

    // Draw the ZSprite
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    m_pd3dDevice->SetPixelShader( NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Set our render state
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );

    RenderZSprite();
    
    if( m_bDrawPlane )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
        m_pd3dDevice->SetVertexShader( FVF_PLANEVERTEX );
        m_pd3dDevice->SetStreamSource( 0, m_pPlaneVB, sizeof( PLANEVERTEX ) );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"ZSprite" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DumpZSurface
// Desc: Grabs the depth/stencil surface, and dumps the depth values to a 
//       targa file.  Only the most significant 8 bits of depth are used, and
//       are replicated to the RGB channels.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DumpDepthBuffer( const CHAR* strFileName )
{
    // Get the surface description. Make sure it's linear D24S8
    D3DSURFACE_DESC desc;
    m_pDepthBuffer->GetDesc( &desc );
    if( desc.Format != D3DFMT_LIN_D24S8 )
    {
        OUTPUT_DEBUG_STRING( "Can only dump linear D24S8\n" );
        return E_NOTIMPL;
    }

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
        return E_FAIL;

    // Write the Targa header to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );

    // Lock the surface
    D3DLOCKED_RECT lock;
    m_pDepthBuffer->LockRect( &lock, 0, 0 );

    // Copy the entire depth buffer at once, so we don't have to 
    // read individual DWORDS, which would be very slow.
    DWORD* pBits = new DWORD[ desc.Width * desc.Height ];
    memcpy( pBits, lock.pBits, desc.Width * desc.Height * sizeof( DWORD ) );

    for( UINT j = 0; j < desc.Height; j++ )
    {
        for( UINT i = 0; i < desc.Width; i++ )
        {
            // Take the most significant byte of depth, and replicate it to 
            // the RGB channels.  As Z goes from 0.0 to 1.0, the color will
            // go from black to white
            DWORD dwVal = pBits[ j * desc.Width + i ] >> 24;

            // Grab the most significant BYTE and propagate to RGB
            pBits[ j * desc.Width + i ] = dwVal | ( dwVal << 8 ) | ( dwVal << 16 );
        }
    }

    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );
    delete[] pBits;

    // Cleanup and return
    m_pDepthBuffer->UnlockRect();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ZSprite\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\console.cpp ===
#include <xtl.h>
#include <stdio.h>
#include <XBFont.h>
#include <XBUtil.h>
#include "keyboard.h"
#include "commands.h"
#include "console.h"


VOID DrawFilledRect( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, DWORD dwFillColor, 
			         DWORD dwOutlineColor );


static VOID ClearBuffer( VOID );
static VOID Execute( VOID );
static VOID AddCurrentStringToBuffer( VOID );

// Internal functions to link to console
static VOID RebootFunction();
static VOID ClearFunction();
static VOID HelpFunction();

// Boolean to indicate whether the console is active (being displayed and taking input)
static BOOL	g_bConsoleActive = FALSE;

// Table of strings holding the previous 10 command lines, note that we can see
// only ten lines, which are displayed, previous command recall is not implemented and
// if it was we would have to implement two buffers, one for the command line as below
// and an additional screen buffer to hold the commands and output feedback
#define NUM_TEXTLINES	10
#define TEXTLINE_LENGTH	80

static WCHAR	strTextLine[ NUM_TEXTLINES ][ TEXTLINE_LENGTH ];
static INT		iTextLineInsertIndex = 0;

// Current text buffer
static WCHAR	strCurrentTextLine[ TEXTLINE_LENGTH ];
static INT		iCurrentCursorPosition;

// Font for console (uses smaller font than default)
static CXBFont* g_pFont = NULL;




//-----------------------------------------------------------------------------
// Name: InitConsole()
// Desc: Initialises console
//-----------------------------------------------------------------------------
VOID InitConsole( CXBFont* pFont )
{
	g_bConsoleActive = FALSE;
	g_pFont          = pFont;

	ClearBuffer();
	ClearCurrentTextLine();

	// Setup command structure for holding commands and functions to call,
	// using NULL just adds string completion for the console
	InitCommands();
	AddCommand( L"reboot",  RebootFunction );
	AddCommand( L"clear",   ClearFunction );
	AddCommand( L"help",    HelpFunction );
}




//-----------------------------------------------------------------------------
// Name: OpenConsole()
// Desc: Sets the console to be active and initialises the current text line
//-----------------------------------------------------------------------------
VOID OpenConsole()
{
	// if we are already open then just return, but display an warning message
	// in the debugger
	if( g_bConsoleActive == TRUE )
		return;

	// Open the keyboard device if it requires it, this allows us to share the
	// keyboard with other areas of the game
	if( FAILED( XBInput_InitDebugKeyboard() ) )
		return;

	// Set the console window to be active and clear the current text line
	g_bConsoleActive = TRUE;

	ClearCurrentTextLine();
}




//-----------------------------------------------------------------------------
// Name: CloseConsole()
// Desc: Sets the console to be inactive
//-----------------------------------------------------------------------------
VOID CloseConsole()
{
	// Remove any existing text from the input line
	ClearCurrentTextLine();

	g_bConsoleActive = FALSE;
}




//-----------------------------------------------------------------------------
// Name: ToggleConsole
// Desc: Switches between open and close
//-----------------------------------------------------------------------------
VOID ToggleConsole()
{
	if( ! IsConsoleActive() )
		OpenConsole();
	else
		CloseConsole();
}




//-----------------------------------------------------------------------------
// Name: IsConsoleActive()
// Desc: Returns whether the console is currently active or not
//-----------------------------------------------------------------------------
BOOL IsConsoleActive()
{
	return g_bConsoleActive;
}




//-----------------------------------------------------------------------------
// Name: ClearCurrentTextLine()
// Desc: Clear the text buffer and reset the current cursor position within the
//			string
//-----------------------------------------------------------------------------
VOID ClearCurrentTextLine()
{
	iCurrentCursorPosition = 0;

	ZeroMemory( strCurrentTextLine, sizeof(strCurrentTextLine) );
}




//-----------------------------------------------------------------------------
// Name: ClearConsole()
// Desc: Clear console buffer and current input string
//-----------------------------------------------------------------------------
VOID ClearConsole()
{
	ClearBuffer();
	ClearCurrentTextLine();
}




//-----------------------------------------------------------------------------
// Name: ProcessConsole()
// Desc: Get keypress and perform any necessary commands
//-----------------------------------------------------------------------------
VOID ProcessConsole()
{
	// handle input from keyboard
	CHAR cInputKey = XBInput_GetKeyboardInput();

	if( cInputKey != '\0' )
	{
		// First handle a reserved key, in this case either the ESC character to
		// close the console or the TAB key to attempt command line completion.
		// Then check for return, anything else must be an ascii value in this
		// sample, this could be expanded to handle all buttons
		switch( cInputKey )
		{
			case DELETE_KEY:
				if( iCurrentCursorPosition != 0 )
				{
					iCurrentCursorPosition--;
					strCurrentTextLine[ iCurrentCursorPosition ] = '\0';
				}
				break;

			case RETURN_KEY:
				Execute();
				break;

			case TAB_KEY:
				WCHAR *matchedName;
				// pass in whole of buffer string to find name match, if match is returned
				// then copy it into the current buffer
				matchedName = CompleteCommand( strCurrentTextLine );

				if( matchedName != NULL )
				{
					wcsncpy( strCurrentTextLine, matchedName, wcslen( matchedName ) );
					iCurrentCursorPosition = wcslen( strCurrentTextLine );
				}

				break;
			
			case ESC_KEY:
				CloseConsole();
				break;
			
			default:
				// Not really necessary to check value here, as we are using
				// the ASCII value returned by the keyboard, so it should be
				// some form of printable character
				if( iCurrentCursorPosition < TEXTLINE_LENGTH - 1 )
				{
					strCurrentTextLine[ iCurrentCursorPosition ] = cInputKey;
					iCurrentCursorPosition++;
				}
				break;
		}
	}
}




//-----------------------------------------------------------------------------
// Name: DrawConsole()
// Desc: Draws the console on top of the screen
//-----------------------------------------------------------------------------
VOID DrawConsole()
{
	if( !g_bConsoleActive )
		return;

	DrawFilledRect( 0, 0, 640, 241, 0x90000000, 0xffffff00 );

	// Now create a temporary buffer to hold the final output string for
	// current input, this is so we can add formatting around the input
	// text
	WCHAR	strTempDisplayBuffer[TEXTLINE_LENGTH+2];
	swprintf( strTempDisplayBuffer, L"> %s", strCurrentTextLine );
	g_pFont->DrawText( 50, 220, 0xffffff00, strTempDisplayBuffer );

	// Get the value for the index of next space for adding to the command
	// buffer, this will be used to display the command history on screen
	INT iCurrentLineIndex = iTextLineInsertIndex;

	for( INT i = 0; i < NUM_TEXTLINES; i++ )
	{
		g_pFont->DrawText( 40.0f, 20.0f + ( 20.0f * i ), 0xffffffff, strTextLine[ iCurrentLineIndex ] );
		iCurrentLineIndex = ( iCurrentLineIndex + 1 ) % NUM_TEXTLINES;
	}
}




//-----------------------------------------------------------------------------
// Name: ShutdownConsole()
// Desc: Tidies up console
//-----------------------------------------------------------------------------
VOID ShutdownConsole()
{
	RemoveAllCommands();

	g_bConsoleActive = FALSE;

	ClearBuffer();
	ClearCurrentTextLine();

	g_pFont = NULL;
}




//-----------------------------------------------------------------------------
// Name: Execute()
// Desc: Processes return key pressed, checks whether input is a command and
//			whether to execute the command, then adds command to the command
//			history buffer
//-----------------------------------------------------------------------------
VOID Execute()
{
	// Check that we have a string of some info first, if not skip next two
	// operations
	if( wcslen( strCurrentTextLine ) != 0 )
	{
		// First try to find command and execute that, because command may
		// effect console, if not command than just display text
		FindAndExecuteCommand( strCurrentTextLine );
	}

	// Then add current string to keyboard buffer
	AddCurrentStringToBuffer();
}




//-----------------------------------------------------------------------------
// Name: AddCurrentStringToBuffer()
// Desc: Copies last string input into the correct location in the command
//			history buffer
//-----------------------------------------------------------------------------
VOID AddCurrentStringToBuffer()
{
	// we just keep a track of the index, this saves us having to copy the whole buffer
	// around, but does mean we need to use extra logic to display on screen

	ZeroMemory( strTextLine[iTextLineInsertIndex], sizeof(strTextLine[iTextLineInsertIndex]) );

	wcsncpy( strTextLine[iTextLineInsertIndex], strCurrentTextLine, TEXTLINE_LENGTH );

	// move table pointer
	iTextLineInsertIndex = ( iTextLineInsertIndex + 1 ) % NUM_TEXTLINES;

	// clear string we are about to overwrite, then add current string
	ClearCurrentTextLine();
}




//-----------------------------------------------------------------------------
// Name: ClearBuffer()
// Desc: Resets all of the command history buffer
//-----------------------------------------------------------------------------
VOID ClearBuffer()
{
	for( int i = 0; i < NUM_TEXTLINES; i++ )
	{
		ZeroMemory( strTextLine[i], sizeof(strTextLine[i]) );
	}

	iTextLineInsertIndex = 0;
}




//-----------------------------------------------------------------------------
// Name: RebootFunction()
// Desc: Internal function to call from console
//-----------------------------------------------------------------------------
VOID RebootFunction()
{
	XLaunchNewImage( NULL, NULL );
}




//-----------------------------------------------------------------------------
// Name: ClearFunction()
// Desc: Internal function to call from console
//-----------------------------------------------------------------------------
VOID ClearFunction()
{
	ClearConsole();
}

//-----------------------------------------------------------------------------
// Name: HelpFunction()
// Desc: Internal function to call from console
//-----------------------------------------------------------------------------
VOID HelpFunction()
{
	// Then add current string to keyboard buffer
	AddCurrentStringToBuffer();


	wcscpy( strCurrentTextLine, L"   reboot - Reboots the system" );
	AddCurrentStringToBuffer();
	wcscpy( strCurrentTextLine, L"   clear  - Clears the console" );
	AddCurrentStringToBuffer();
	wcscpy( strCurrentTextLine, L"   help   - Displays list of commands" );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\commands.h ===
//-----------------------------------------------------------------------------
// File: Commands.h
//
// Desc: Functions to control a list of commands and functions assigned to the
//		 console
//
// Hist: 06.11.2001 - New
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef COMMANDS_H
#define COMMANDS_H

// Function pointer, used to hold function address to run when linked to a
// command
typedef void (*commandFunction)(void);




//-----------------------------------------------------------------------------
// Name: InitCommands()
// Desc: Just ensures command list is set correctly
//-----------------------------------------------------------------------------
VOID InitCommands();




//-----------------------------------------------------------------------------
// Name: AddCommand()
// Desc: Adds the command address and name into a list of commands, ensuring
//			that the command does not already exist in the list.
//-----------------------------------------------------------------------------
VOID AddCommand( WCHAR* strNewCommandName, commandFunction strNewFunctionName );

VOID RemoveAllCommands();




//-----------------------------------------------------------------------------
// Name: CompleteCommand()
// Desc: Called to see if we have a command in the list that matches the partial
//	name passed in
//-----------------------------------------------------------------------------
WCHAR* CompleteCommand( WCHAR* strPartialCommand );




//-----------------------------------------------------------------------------
// Name: FindAndExecuteCommand()
// Desc: Parses list of commands and executes function if available
//-----------------------------------------------------------------------------
VOID FindAndExecuteCommand( WCHAR* strCommandString );




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\dummy.cpp ===
#ifdef DEVKIT
#include "Keyboard.cpp"
#include "DebugKeyboard.cpp"
#include "Commands.cpp"
#include "Console.cpp"
#else
void __cdecl main()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\console.h ===
//-----------------------------------------------------------------------------
// File: console.h
//
// Desc: text console functions
//
// Hist: 31.05.2001 - New
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef CONSOLE_H
#define CONSOLE_H




//-----------------------------------------------------------------------------
// Name: InitConsole()
// Desc: Initialises console
//-----------------------------------------------------------------------------
VOID InitConsole( CXBFont *i_textFont );




//-----------------------------------------------------------------------------
// Name: ShutdownConsole()
// Desc: Tidies up console
//-----------------------------------------------------------------------------
VOID ShutdownConsole( VOID );




//-----------------------------------------------------------------------------
// Name: OpenConsole()
// Desc: Sets the console to be active and initialises the current text line
//-----------------------------------------------------------------------------
VOID OpenConsole( VOID );




//-----------------------------------------------------------------------------
// Name: CloseConsole()
// Desc: Sets the console to be inactive
//-----------------------------------------------------------------------------
VOID CloseConsole( VOID );




//-----------------------------------------------------------------------------
// Name: ToggleConsole
// Desc: Switches between open and close
//-----------------------------------------------------------------------------
VOID ToggleConsole( VOID );




//-----------------------------------------------------------------------------
// Name: ClearCurrentTextLine()
// Desc: Clear the text buffer and reset the current cursor position within the
//			string
//-----------------------------------------------------------------------------
VOID ClearCurrentTextLine( VOID );




//-----------------------------------------------------------------------------
// Name: ClearConsole()
// Desc: Clear console buffer
//-----------------------------------------------------------------------------
VOID ClearConsole( VOID );




//-----------------------------------------------------------------------------
// Name: IsConsoleActive()
// Desc: Returns whether the console is currently active or not
//-----------------------------------------------------------------------------
BOOL IsConsoleActive( VOID );




//-----------------------------------------------------------------------------
// Name: DrawConsole()
// Desc: Draws the console on top of the screen
//-----------------------------------------------------------------------------
VOID DrawConsole( VOID );




//-----------------------------------------------------------------------------
// Name: ProcessConsole()
// Desc: Get keypress and perform any necessary commands
//-----------------------------------------------------------------------------
VOID ProcessConsole( VOID );




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\DebugKeyboard.cpp ===
//-----------------------------------------------------------------------------
// File: DebugKeyboard.cpp
//
// Desc: This sample is a demonstration of using the debug keyboard.
//
// Hist: 06.11.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include <XBApp.h>
#include <XBInput.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBUtil.h>
#include <XBMesh.h>
#include "console.h"
#include "commands.h"
#include "keyboard.h"
#include "resource.h"


//-----------------------------------------------------------------------------
// Graphics helper function
//-----------------------------------------------------------------------------
VOID DrawFilledRect( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, DWORD dwFillColor, 
                     DWORD dwOutlineColor );



//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Wings.bmp",  resource_Wings_OFFSET },
    { "BiHull.bmp", resource_BiHull_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallout[] = 
{
    { XBHELP_START_BUTTON,  XBHELP_PLACEMENT_2, L"Pause" },
    { XBHELP_BACK_BUTTON,   XBHELP_PLACEMENT_2, L"Display help" },
};  

#define NUM_HELP_CALLOUTS 2




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Fonts
    CXBFont            m_Font;
    CXBFont            m_ConsoleFont;

    // Help system
    CXBHelp            m_Help;
    BOOL               m_bDrawHelp;

    // Plane model details
    CXBPackedResource  m_xprResource;
    CXBMesh*           m_pPlaneMesh;

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create fonts
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return E_FAIL;

    if( FAILED( m_ConsoleFont.Create( m_pd3dDevice, "SystemFont.xpr" ) ) )
        return E_FAIL;

    // Create help
    if( FAILED( m_Help.Create( g_pd3dDevice, "Gamepad.xpr" ) ) )
        return E_FAIL;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the airplanes
    m_pPlaneMesh = new CXBMesh;
    m_pPlaneMesh ->Create(g_pd3dDevice, "Models\\Airplane.xbg", &m_xprResource );

    // Initialize the debug keyboard
    if( FAILED( XBInput_InitDebugKeyboard() ) )
        return E_FAIL;

    // Initialize the console
    InitConsole( &m_ConsoleFont );

    // Set projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 0.1f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set view position
    D3DXMATRIX matView;
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 40.0f);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene. As this code only changes text, there is no real animation
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
        m_bDrawHelp = !m_bDrawHelp;

    if( IsConsoleActive() != TRUE )
    {
        if( XBInput_GetKeyboardInput() == ESC_KEY )
        {
            ToggleConsole();
        }
    }

    // Move plane
    FLOAT x =  20.0f * cosf(1.57f*m_fAppTime);
    FLOAT z = -20.0f * sinf(1.57f*m_fAppTime);
    FLOAT y =   4.0f;
    D3DXMATRIX matWorld, matTrans;
    D3DXMatrixRotationY( &matWorld, 1.57f*m_fAppTime );
    D3DXMatrixTranslation( &matTrans, x, y, z );
    D3DXMatrixMultiply( &matWorld, &matWorld, &matTrans );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Render the scene plane
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         D3DCOLOR_XRGB( 0x00, 0x50, 0x00), 1.0f, 0L );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pPlaneMesh->Render(0);

    // Display the console
    if( IsConsoleActive() == TRUE )
    {
        ProcessConsole();
        DrawConsole();
    }

    // Display help and application text
    if( m_bDrawHelp )
    {
        m_Help.Render( &m_Font, g_HelpCallout, NUM_HELP_CALLOUTS );
    }
    else
    {
        // Draw a rectangle and a semitrans poly to put the text in
        DrawFilledRect( 64, 248, 564, 398, 0x40000000, 0xff000000 );

        m_Font.Begin();
        m_Font.DrawText(  48, 36, 0xffffff00, L"DebugKeyboard" );
        m_Font.DrawText( 450, 36, 0xffffff00, m_strFrameRate );
        m_Font.DrawText(  66, 250, 0xffffff00, L"Press the ESC key on the Xbox debug keyboard to\n"
                                               L"open the console window. Console supports help,\n"
                                               L"clear, and reboot. Other text will just be displayed\n"
                                               L"in the console window." );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawFilledRect()
// Desc: Draws filled rectangle on screen
//-----------------------------------------------------------------------------
VOID DrawFilledRect( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, DWORD dwFillColor, 
                     DWORD dwOutlineColor )
{
    D3DXVECTOR4 v[4];
    v[0] = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );
    v[1] = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );
    v[2] = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );
    v[3] = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );
    
    // Set render states
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,   TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );

    // Draw rectangle inside
    g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwFillColor );
    g_pd3dDevice->DrawVerticesUP( D3DPT_QUADLIST, 4, v, sizeof(D3DXVECTOR4) );

    // Draw rectangle outline
    g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwOutlineColor );
    g_pd3dDevice->DrawVerticesUP( D3DPT_LINELOOP, 4, v, sizeof(D3DXVECTOR4) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\commands.cpp ===
//-----------------------------------------------------------------------------
// File: Commands.cpp
//
// Desc: Functions to control a list of commands and functions assigned to the
//		 console
//
// Hist: 06.11.2001 - New
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "commands.h"


// Linked list structure for holding command list
struct COMMANDS_STRUCT
{
	WCHAR*  		 strName;
	commandFunction	 fnCommand;
	COMMANDS_STRUCT* pNext;
};

static COMMANDS_STRUCT* g_commandFunctions;




//-----------------------------------------------------------------------------
// Name: InitCommands()
// Desc: Just ensures command list is set correctly
//-----------------------------------------------------------------------------
VOID InitCommands()
{
	g_commandFunctions = NULL;
}




//-----------------------------------------------------------------------------
// Name: AddCommand()
// Desc: Adds the command address and name into a list of commands, ensuring
//			that the command does not already exist in the list.
//-----------------------------------------------------------------------------
VOID AddCommand( WCHAR* strNewCommandName, commandFunction fnNewCommand )
{

	COMMANDS_STRUCT* newCommand;
	
	// Ensure that the command isn't previously defined
	for ( newCommand = g_commandFunctions; newCommand; newCommand = newCommand->pNext )
	{
		if( wcscmp( strNewCommandName, newCommand->strName ) == 0 )
		{
//			DebugMessageString( __FILE__, __LINE__, WARNING, "AddCommand() failed, command already exists" );
			return;
		}
	}

	// Have gone through all the command list without finding this command, so add it to the list
	// Note that so commands passed in have no function assigned
	newCommand = (COMMANDS_STRUCT*)malloc ( sizeof(COMMANDS_STRUCT) );
	if( newCommand == NULL )
	{
//			DebugMessageString( __FILE__, __LINE__, ERROR, "AddCommand() failed, command malloc returned NULL" );
			return;
	}
	newCommand->strName		= strNewCommandName;
	newCommand->fnCommand	= fnNewCommand;
	newCommand->pNext		= g_commandFunctions;
	g_commandFunctions = newCommand;
}




//-----------------------------------------------------------------------------
// Name: RemoveAllCommands()
// Desc: 
//-----------------------------------------------------------------------------
VOID RemoveAllCommands()
{
//	g_commandFunctions = NULL;
//	#pragma message(Reminder "Complete remove all commands !")
}




//-----------------------------------------------------------------------------
// Name: RemoveCommand()
// Desc: 
//-----------------------------------------------------------------------------
VOID RemoveCommand( char *i_szCommandName )
{
	// need to track for the special case of start and end of the list
//	g_commandFunctions = NULL;
//	#pragma message(Reminder "Complete remove command !")
}




//-----------------------------------------------------------------------------
// Name: CompleteCommand()
// Desc: Called to see if we have a command in the list that matches the partial
//	name passed in
//-----------------------------------------------------------------------------
WCHAR *CompleteCommand( WCHAR *i_partialCommand )
{
	COMMANDS_STRUCT* cmd;
	INT			     iPartialCommandLength;
	
	iPartialCommandLength = wcslen( i_partialCommand );
	
	if( iPartialCommandLength == 0 )
		return NULL;
		
	for( cmd = g_commandFunctions; cmd; cmd = cmd->pNext )
	{
		if( wcsncmp( i_partialCommand, cmd->strName, iPartialCommandLength ) == 0 )
			return cmd->strName;
	}

	return NULL;
}




//-----------------------------------------------------------------------------
// Name: FindAndExecuteCommand()
// Desc: Parses list of commands and executes function if available
//-----------------------------------------------------------------------------
VOID FindAndExecuteCommand( WCHAR* strCommand )
{

	COMMANDS_STRUCT* cmd;
	INT			     iCommandLength;
	
	iCommandLength = wcslen( strCommand );
	
	if( iCommandLength == 0 )
		return;
		
	for( cmd = g_commandFunctions; cmd; cmd = cmd->pNext )
	{
		if( wcsncmp( strCommand, cmd->strName, iCommandLength ) == 0 )
		{
			if( cmd->fnCommand != NULL )
				cmd->fnCommand ();
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Gamepad\Font16.h ===
// Automatically generated by the bundler tool from Font16.rdf

#define Font16_NUM_RESOURCES 2UL

#define Font16_Font_OFFSET 0UL
#define Font16_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Gamepad\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Gamepad\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\SystemFont.h ===
// Automatically generated by the bundler tool from SystemFont.rdf

#define SystemFont_NUM_RESOURCES 2UL

#define SystemFont_Font_OFFSET 0UL
#define SystemFont_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\keyboard.h ===
//-----------------------------------------------------------------------------
// File: Keyboard.h
//
// Desc: Handles debug keyboard.
//
// Hist: 06.11.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef KEYBOARD_H
#define KEYBOARD_H

// Keyboard command button values
#define DELETE_KEY  8
#define TAB_KEY     9
#define RETURN_KEY  10
#define ESC_KEY     27


//-----------------------------------------------------------------------------
// Name: XBInput_InitDebugKeyboard()
// Desc: Initialise Debug Keyboard for use
//-----------------------------------------------------------------------------
HRESULT XBInput_InitDebugKeyboard();


//-----------------------------------------------------------------------------
// Name: XBInput_GetKeyboardInput()
// Desc: Processes input from a debug keyboard
//-----------------------------------------------------------------------------
CHAR XBInput_GetKeyboardInput();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\obj\i386\SystemFont.h ===
// Automatically generated by the bundler tool from SystemFont.rdf

#define SystemFont_NUM_RESOURCES 2UL

#define SystemFont_Font_OFFSET 0UL
#define SystemFont_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Gamepad\obj\i386\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Wings_OFFSET 0UL
#define resource_BiHull_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\DebugKeyboard\keyboard.cpp ===
//-----------------------------------------------------------------------------
// File: Keyboard.cpp
//
// Desc: Handles debug keyboard.
//
// Hist: 06.11.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define DEBUG_KEYBOARD
#include <xtl.h>
#include <xkbd.h>
#include "keyboard.h"


static HANDLE g_hKeyboardDevice[4] = { 0 };

static BOOL                     g_bKeyboardInitialised  = FALSE;
static XINPUT_DEBUG_KEYSTROKE   g_keyboardStroke;




//-----------------------------------------------------------------------------
// Name: XBInput_InitDebugKeyboard()
// Desc: Initialise Debug Keyboard for use
//-----------------------------------------------------------------------------
HRESULT XBInput_InitDebugKeyboard()
{
    // Check that we are not already initialised and then initialise if necessary
    if( g_bKeyboardInitialised )
        return S_OK;

    XINPUT_DEBUG_KEYQUEUE_PARAMETERS keyboardSettings;
    keyboardSettings.dwFlags          = XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN|XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT;
    keyboardSettings.dwQueueSize      = 25;
    keyboardSettings.dwRepeatDelay    = 500;
    keyboardSettings.dwRepeatInterval = 50;

    if( ERROR_SUCCESS != XInputDebugInitKeyboardQueue( &keyboardSettings ) )
        return E_FAIL;

    g_bKeyboardInitialised = TRUE;

    // Now find the keyboard device, in this case we shall loop indefinitly, although
    // it would be better to monitor the time taken and to time out if necessary
    // in case the keyboard has been unplugged

    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_DEBUG_KEYBOARD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        if( dwDeviceMask & (1<<i) ) 
		{
			// Now open the device
			XINPUT_POLLING_PARAMETERS pollValues;
			pollValues.fAutoPoll       = TRUE;
			pollValues.fInterruptOut   = TRUE;
			pollValues.bInputInterval  = 32;  
			pollValues.bOutputInterval = 32;
			pollValues.ReservedMBZ1    = 0;
			pollValues.ReservedMBZ2    = 0;

			g_hKeyboardDevice[i] = XInputOpen( XDEVICE_TYPE_DEBUG_KEYBOARD, i, 
									           XDEVICE_NO_SLOT, &pollValues );
		}
	}
     
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBInput_GetKeyboardInput()
// Desc: Processes input from a debug keyboard
//-----------------------------------------------------------------------------
CHAR XBInput_GetKeyboardInput()
{
    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_DEBUG_KEYBOARD, &dwInsertions, &dwRemovals );

    // Loop through all ports
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        if( dwRemovals & (1<<i) )
        {
            XInputClose( g_hKeyboardDevice[i] );
            g_hKeyboardDevice[i] = NULL;
        }

        // Handle inserted devices
        if( dwInsertions & (1<<i) )
        {
			// Now open the device
			XINPUT_POLLING_PARAMETERS pollValues;
			pollValues.fAutoPoll       = TRUE;
			pollValues.fInterruptOut   = TRUE;
			pollValues.bInputInterval  = 32;  
			pollValues.bOutputInterval = 32;
			pollValues.ReservedMBZ1    = 0;
			pollValues.ReservedMBZ2    = 0;

            // TCR 1-14 Device Types
            g_hKeyboardDevice[i] = XInputOpen( XDEVICE_TYPE_DEBUG_KEYBOARD, i, 
                                               XDEVICE_NO_SLOT, &pollValues );
        }

        // If we have a valid device, poll it's state and track button changes
        if( g_hKeyboardDevice[i] )
        {
		    if( ERROR_SUCCESS == XInputDebugGetKeystroke( &g_keyboardStroke ) )
				return g_keyboardStroke.Ascii;
        }
    }

	return '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Gamepad\obj\i386\Font16.h ===
// Automatically generated by the bundler tool from Font16.rdf

#define Font16_NUM_RESOURCES 2UL

#define Font16_Font_OFFSET 0UL
#define Font16_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Gamepad\Gamepad.cpp ===
//-----------------------------------------------------------------------------
// File: Gamepad.cpp
//
// Desc: Tool to experiment with all things related to an Xbox gamepad
//       controller
//
// Hist: 04.06.01 - Created
//       10.03.01 - Ensure use of only one gamepad
//       10.03.01 - Added count to quantization page
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBMesh.h>
#include <XBUtil.h>
#include <XBResource.h>
#include <xgraphics.h>
#include "Resource.h"


// Subsets for within the gamepad mesh. This are specific to the gamepad mesh.
// For instance, subset 7 represents an internal XBMESH_SUBSET structure for
// rendering the geometry for the gamepad's x button.
#define CONTROL_LEFTTHUMBSTICK  0
#define CONTROL_RIGHTTHUMBSTICK 1
#define CONTROL_BODY            2
#define CONTROL_BACKBUTTON      3
#define CONTROL_STARTBUTTON     4
#define CONTROL_ABUTTON         5
#define CONTROL_BBUTTON         6
#define CONTROL_XBUTTON         7
#define CONTROL_YBUTTON         8
#define CONTROL_WHITEBUTTON     9
#define CONTROL_BLACKBUTTON    10
#define CONTROL_CORDSTUB       11
#define CONTROL_GASKETS        12
#define CONTROL_MEMCARDSLOT    13
#define CONTROL_LEFTTRIGGER    14
#define CONTROL_RIGHTTRIGGER   15
#define CONTROL_DPAD           16
#define CONTROL_JEWEL          17
#define NUM_CONTROLS           18


// Offsets for building matrices which are used to animate the gamepad controls.
D3DXVECTOR3 g_vLeftTriggerAxis    = D3DXVECTOR3( 1.0f, -0.13f, 0.0f );
D3DXVECTOR3 g_vLeftTriggerOffset  = D3DXVECTOR3( 0.0f, 12.0f, 38.0f );
D3DXVECTOR3 g_vRightTriggerAxis   = D3DXVECTOR3( 1.0f, 0.13f, 0.0f );
D3DXVECTOR3 g_vRightTriggerOffset = D3DXVECTOR3( 0.0f, 12.0f, 38.0f );
D3DXVECTOR3 g_vDPadOffset         = D3DXVECTOR3( -36.70f, -26.27f, 12.0f );
D3DXVECTOR3 g_vLeftStickOffset    = D3DXVECTOR3( -48.54f,   8.72f, 18.0f );
D3DXVECTOR3 g_vRightStickOffset   = D3DXVECTOR3(  36.70f, -26.27f, 18.0f );


// Structures for animating, highlighting, and textureing the gamepad controls.
BOOL               g_ControlActive[NUM_CONTROLS];
D3DXMATRIX         g_ControlMatrix[NUM_CONTROLS];
LPDIRECT3DTEXTURE8 g_ControlTexture[NUM_CONTROLS];


// Global world matrix, so the app can orient the gamepad
D3DXMATRIX g_matWorld( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );




//-----------------------------------------------------------------------------
// Name: class CGamepadMesh
// Desc: The gamepad mesh. This is overrided from the base class so that we can
//       provide a custom RenderCallback() function.
//-----------------------------------------------------------------------------
class CGamepadMesh : public CXBMesh
{
public:
    BOOL    RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset,
                            XBMESH_SUBSET* pSubset, DWORD dwFlags );
};




//-----------------------------------------------------------------------------
// Name: RenderCallback()
// Desc: Overrided from the base class so that we can animate and highlight
//       individual mesh subsets before rendering them.
//-----------------------------------------------------------------------------
BOOL CGamepadMesh::RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset,
                                   XBMESH_SUBSET* pSubset, DWORD dwFlags )
{
    // Set matrix
    D3DXMATRIX mat = g_matWorld;
    D3DXMatrixMultiply( &mat, &g_ControlMatrix[dwSubset], &mat );
    pd3dDevice->SetTransform( D3DTS_WORLD, &mat );

    // Set material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f, 1.0f );
    pd3dDevice->SetMaterial( &mtrl );

    // Set texture
    pd3dDevice->SetTexture( 0, g_ControlTexture[dwSubset] );

    return TRUE;
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Valid app states
    enum APPSTATE 
    { 
        APPSTATE_CONTROLTEST=0, 
        APPSTATE_VIBRATIONTEST,
        APPSTATE_DEADZONECALIBRATION,
        APPSTATE_BUTTONQUANTIZATION,
        APPSTATE_MEMORYUNITDETECTION,
        APPSTATE_MAX,
    };

    // Valid gamepad types
    enum GAMEPADTYPE
    { 
        GAMEPADTYPE_NONE=0, 
        GAMEPADTYPE_US, 
        GAMEPADTYPE_JAPAN,
    };

    // General application members
    APPSTATE           m_AppState;         // State of the app
    CXBPackedResource  m_xprResource;      // Packed resources for the app
    CXBFont            m_Font16;           // 16-point font class
    CXBFont            m_Font12;           // 12-point font class

    // Active gamepad
    DWORD              m_dwNumInsertedGamepads;
    XBGAMEPAD*         m_pGamepad;

    // Geometry
    CGamepadMesh       m_GamepadMesh;      // Geometry for the US gamepad
    CGamepadMesh       m_GamepadSMesh;     // Geometry for the Japan gamepad
    CGamepadMesh*      m_pGamepadMesh;     // Geometry for the active gamepad
    GAMEPADTYPE        m_GamepadType;      // Type of gamepad used

    // Options
    DWORD              m_dwTextureSelection;
    BOOL               m_bAlphaEnabled;

    // Vibration motor values
    FLOAT              m_fLeftMotorSpeed;
    FLOAT              m_fRightMotorSpeed;

    // Deadzone calibration page
    FLOAT              m_fDeadZone;

    // Control quantization page
    BYTE*              m_pQuantizedThumbStickValues;
    BYTE*              m_pQuantizedButtonValues;

    // Internal members
    VOID    ShowTexture( LPDIRECT3DTEXTURE8 pTexture );
    HRESULT DrawBox( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2,
                     DWORD dwFillColor, DWORD dwOutlineColor );
    HRESULT RenderInsertRemoveControllerPage();
    HRESULT RenderControlTestPage();
    HRESULT RenderVibrationTestPage();
    HRESULT RenderDeadZoneCalibrationPage();
    HRESULT RenderButtonQuantizationPage();

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Override base class variable to enable fullscreen-antialiasing
    m_d3dpp.MultiSampleType = D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR |
                              D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8;

    m_AppState              = APPSTATE_CONTROLTEST;
    m_dwNumInsertedGamepads = 0L;
    m_pGamepad              = &m_DefaultGamepad;
    m_GamepadType           = GAMEPADTYPE_NONE;
    m_pGamepadMesh          = NULL;
    m_dwTextureSelection    = 0L;
    m_bAlphaEnabled         = FALSE;
    m_fDeadZone             = 0.24f;  // Set default deadzone to 24%
    m_fLeftMotorSpeed       = 0.0f;
    m_fRightMotorSpeed      = 0.0f;

    // Quantized control values
    m_pQuantizedThumbStickValues = new BYTE[256];
    ZeroMemory( m_pQuantizedThumbStickValues, 256 );

    m_pQuantizedButtonValues = new BYTE[256];
    ZeroMemory( m_pQuantizedButtonValues, 256 );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependent display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the fonts
    if( FAILED( m_Font16.Create( m_pd3dDevice, "Font16.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    if( FAILED( m_Font12.Create( m_pd3dDevice, "Font12.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the gamepad objects
    if( FAILED( m_GamepadMesh.Create( m_pd3dDevice, "Models\\Gamepad.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_GamepadSMesh.Create( m_pd3dDevice, "Models\\GamepadS.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the control highlight states, matrices, and textures
    for( DWORD i=0; i< NUM_CONTROLS; i++ )
    {
        g_ControlActive[i] = FALSE;
        D3DXMatrixIdentity( &g_ControlMatrix[i] );
        g_ControlTexture[i] = NULL;
    }

    g_ControlTexture[CONTROL_BODY]            = m_xprResource.GetTexture( resource_MatteBlack_OFFSET );
    g_ControlTexture[CONTROL_GASKETS]         = m_xprResource.GetTexture( resource_MatteBlack_OFFSET );
    g_ControlTexture[CONTROL_LEFTTHUMBSTICK]  = m_xprResource.GetTexture( resource_MatteBlack_OFFSET );
    g_ControlTexture[CONTROL_RIGHTTHUMBSTICK] = m_xprResource.GetTexture( resource_MatteBlack_OFFSET );
    g_ControlTexture[CONTROL_JEWEL]           = m_xprResource.GetTexture( resource_GreenBezel_OFFSET );
    g_ControlTexture[CONTROL_CORDSTUB]        = m_xprResource.GetTexture( resource_Cord_OFFSET );

    g_ControlTexture[CONTROL_MEMCARDSLOT]  = m_xprResource.GetTexture( resource_ShinyBlack_OFFSET );
    g_ControlTexture[CONTROL_BACKBUTTON]   = m_xprResource.GetTexture( resource_ShinyBlack_OFFSET );
    g_ControlTexture[CONTROL_STARTBUTTON]  = m_xprResource.GetTexture( resource_ShinyBlack_OFFSET );
    g_ControlTexture[CONTROL_LEFTTRIGGER]  = m_xprResource.GetTexture( resource_ShinyBlack_OFFSET );
    g_ControlTexture[CONTROL_RIGHTTRIGGER] = m_xprResource.GetTexture( resource_ShinyBlack_OFFSET );
    g_ControlTexture[CONTROL_DPAD]         = m_xprResource.GetTexture( resource_ShinyBlack_OFFSET );
    g_ControlTexture[CONTROL_ABUTTON]      = m_xprResource.GetTexture( resource_GreenGlass_OFFSET );
    g_ControlTexture[CONTROL_BBUTTON]      = m_xprResource.GetTexture( resource_RedGlass_OFFSET );
    g_ControlTexture[CONTROL_XBUTTON]      = m_xprResource.GetTexture( resource_BlueGlass_OFFSET );
    g_ControlTexture[CONTROL_YBUTTON]      = m_xprResource.GetTexture( resource_YellowGlass_OFFSET );
    g_ControlTexture[CONTROL_WHITEBUTTON]  = m_xprResource.GetTexture( resource_WhiteGlass_OFFSET );
    g_ControlTexture[CONTROL_BLACKBUTTON]  = m_xprResource.GetTexture( resource_ShinyBlack_OFFSET );

    // Misc render states
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,        0xffffffff );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,       D3DCULL_NONE );

    // Set up world matrix
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set up view matrix
    D3DXMATRIX  matView;
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 0.0f,-250.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f,   0.0f );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f,   0.0f );
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set up proj matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 1000.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Setup a base material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Detect the number and type of gamepads that are inserted. By default,
    // use the US gamepad (aka "Xbox Controller"), unless any gamepad slot has
    // a Japan gamepad (aka "Xbox Controller S") plugged into it. For this
    // sample, we do this every frame just in case someone puts in a different
    // controller.
    m_dwNumInsertedGamepads = 0;
    m_GamepadType           = GAMEPADTYPE_NONE;
    for( DWORD i=0; i<4; i++ )
    {
        if( m_Gamepad[i].hDevice )
        {
            if( m_Gamepad[i].caps.SubType == XINPUT_DEVSUBTYPE_GC_GAMEPAD_ALT )
            {
                // Use the Japan controller
                m_pGamepad    = &m_Gamepad[i];
                m_GamepadType = GAMEPADTYPE_JAPAN;
                m_dwNumInsertedGamepads++;
            }
            else
            {
                // For all other controller types, use the US controller
                m_pGamepad    = &m_Gamepad[i];
                m_GamepadType = GAMEPADTYPE_US;
                m_dwNumInsertedGamepads++;
            }
        }
    }
    if( GAMEPADTYPE_US == m_GamepadType )
    {
        m_pGamepadMesh        = &m_GamepadMesh;
        g_vLeftTriggerAxis    = D3DXVECTOR3(  1.00f, -0.13f,  0.0f );
        g_vLeftTriggerOffset  = D3DXVECTOR3(  0.00f, 12.00f, 38.0f );
        g_vRightTriggerAxis   = D3DXVECTOR3(  1.00f,  0.13f,  0.0f );
        g_vRightTriggerOffset = D3DXVECTOR3(  0.00f, 12.00f, 38.0f );
        g_vDPadOffset         = D3DXVECTOR3(-36.70f,-26.27f, 12.0f );
        g_vLeftStickOffset    = D3DXVECTOR3(-48.54f,  8.72f, 18.0f );
        g_vRightStickOffset   = D3DXVECTOR3( 36.70f,-26.27f, 18.0f );
    }
    else if( GAMEPADTYPE_JAPAN == m_GamepadType )
    {
        m_pGamepadMesh        = &m_GamepadSMesh;
        g_vLeftTriggerAxis    = D3DXVECTOR3(  1.00f, -0.13f,  0.00f );
        g_vRightTriggerAxis   = D3DXVECTOR3(  1.00f,  0.13f,  0.00f );
        g_vLeftTriggerOffset  = D3DXVECTOR3(-41.40f, 60.86f,  8.43f );
        g_vRightTriggerOffset = D3DXVECTOR3( 41.40f, 60.86f,  8.43f );
        g_vDPadOffset         = D3DXVECTOR3(-22.01f, 21.02f,-11.31f );
        g_vLeftStickOffset    = D3DXVECTOR3(-42.01f, 45.60f, -7.70f );
        g_vRightStickOffset   = D3DXVECTOR3( 20.45f, 20.96f, -7.70f );
    }
    else 
        m_pGamepadMesh = NULL;

    // Move to next app state when user presses BACK and START together
    BOOL bStartAndBackButtonsPushed = FALSE;

    if( ( m_pGamepad->wButtons & XINPUT_GAMEPAD_START ) &&
        ( m_pGamepad->wPressedButtons & XINPUT_GAMEPAD_BACK ) )
        bStartAndBackButtonsPushed = TRUE;

    if( ( m_pGamepad->wButtons & XINPUT_GAMEPAD_BACK ) &&
        ( m_pGamepad->wPressedButtons & XINPUT_GAMEPAD_START ) )
        bStartAndBackButtonsPushed = TRUE;

    if( bStartAndBackButtonsPushed )
    {
        switch( m_AppState )
        {
            case APPSTATE_CONTROLTEST:         m_AppState = APPSTATE_VIBRATIONTEST; break;
            case APPSTATE_VIBRATIONTEST:       m_AppState = APPSTATE_DEADZONECALIBRATION; break;
            case APPSTATE_DEADZONECALIBRATION: m_AppState = APPSTATE_BUTTONQUANTIZATION; break;
            case APPSTATE_BUTTONQUANTIZATION:  m_AppState = APPSTATE_CONTROLTEST; break;
        }

        m_fLeftMotorSpeed    = 0.0f;
        m_fRightMotorSpeed   = 0.0f;
    }

    // Handle the control test page
    if( m_AppState == APPSTATE_CONTROLTEST )
    {
        // Select options
        if( m_pGamepad->wButtons & XINPUT_GAMEPAD_START )
        {
            if( m_pGamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
            {
                static dwTexture = 0;
                dwTexture = (dwTexture+1)%resource_NUM_RESOURCES;
                g_ControlTexture[CONTROL_BODY] = m_xprResource.GetTexture( 20L*dwTexture );
            }

            if( m_pGamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
            {
                static dwTexture = 0;
                dwTexture = (dwTexture+1)%resource_NUM_RESOURCES;
                g_ControlTexture[ CONTROL_LEFTTHUMBSTICK ]  = m_xprResource.GetTexture( 20L*dwTexture );
                g_ControlTexture[ CONTROL_RIGHTTHUMBSTICK ] = m_xprResource.GetTexture( 20L*dwTexture );
            }

            if( m_pGamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
                m_bAlphaEnabled = !m_bAlphaEnabled;
        }

        // Perform object rotation
        D3DXMATRIX matRotate;
        FLOAT fXRotate = m_pGamepad->fX1*m_fElapsedTime*D3DX_PI*0.5f;
        FLOAT fYRotate = m_pGamepad->fY1*m_fElapsedTime*D3DX_PI*0.5f;
        D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate, -fYRotate, 0.0f );
        D3DXMatrixMultiply( &g_matWorld, &g_matWorld, &matRotate );
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &g_matWorld );

        // Record which controls are active
        g_ControlActive[CONTROL_LEFTTHUMBSTICK]  = ( m_pGamepad->wButtons & XINPUT_GAMEPAD_LEFT_THUMB ||
                                                     m_pGamepad->fX1 || m_pGamepad->fY1 ) ? TRUE : FALSE;
        g_ControlActive[CONTROL_RIGHTTHUMBSTICK] = ( m_pGamepad->wButtons & XINPUT_GAMEPAD_RIGHT_THUMB ||
                                                     m_pGamepad->fX2 || m_pGamepad->fY2 ) ? TRUE : FALSE;
        g_ControlActive[CONTROL_BACKBUTTON]  = ( m_pGamepad->wButtons & XINPUT_GAMEPAD_BACK ) ? TRUE : FALSE;
        g_ControlActive[CONTROL_STARTBUTTON] = ( m_pGamepad->wButtons & XINPUT_GAMEPAD_START ) ? TRUE : FALSE;
        g_ControlActive[CONTROL_DPAD]        = ( m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_UP || 
                                                 m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_DOWN || 
                                                 m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_LEFT || 
                                                 m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ) ? TRUE : FALSE;
        g_ControlActive[CONTROL_ABUTTON]      = m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_A];
        g_ControlActive[CONTROL_BBUTTON]      = m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_B];
        g_ControlActive[CONTROL_XBUTTON]      = m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_X];
        g_ControlActive[CONTROL_YBUTTON]      = m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_Y];
        g_ControlActive[CONTROL_BLACKBUTTON]  = m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_BLACK];
        g_ControlActive[CONTROL_WHITEBUTTON]  = m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_WHITE];
        g_ControlActive[CONTROL_LEFTTRIGGER]  = m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER];
        g_ControlActive[CONTROL_RIGHTTRIGGER] = m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER];


        // Animate buttons
        {
            D3DXMatrixTranslation( &g_ControlMatrix[CONTROL_LEFTTHUMBSTICK],  0.0f, 0.0f, m_pGamepad->wButtons & XINPUT_GAMEPAD_LEFT_THUMB ? 1.0f : 0.0f );
            D3DXMatrixTranslation( &g_ControlMatrix[CONTROL_RIGHTTHUMBSTICK], 0.0f, 0.0f, m_pGamepad->wButtons & XINPUT_GAMEPAD_RIGHT_THUMB ? 1.0f : 0.0f );
            D3DXMatrixTranslation( &g_ControlMatrix[CONTROL_BACKBUTTON],     0.0f, 0.0f, m_pGamepad->wButtons & XINPUT_GAMEPAD_BACK  ? 1.5f : 0.0f );
            D3DXMatrixTranslation( &g_ControlMatrix[CONTROL_STARTBUTTON],    0.0f, 0.0f, m_pGamepad->wButtons & XINPUT_GAMEPAD_START ? 1.5f : 0.0f );
            D3DXMatrixTranslation( &g_ControlMatrix[CONTROL_ABUTTON],     0.0f, 0.0f, 2.0f * m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_A] / 255.0f );
            D3DXMatrixTranslation( &g_ControlMatrix[CONTROL_BBUTTON],     0.0f, 0.0f, 2.0f * m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_B] / 255.0f );
            D3DXMatrixTranslation( &g_ControlMatrix[CONTROL_XBUTTON],     0.0f, 0.0f, 2.0f * m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_X] / 255.0f );
            D3DXMatrixTranslation( &g_ControlMatrix[CONTROL_YBUTTON],     0.0f, 0.0f, 2.0f * m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_Y] / 255.0f );
            D3DXMatrixTranslation( &g_ControlMatrix[CONTROL_BLACKBUTTON], 0.0f, 0.0f, 2.0f * m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_BLACK] / 255.0f );
            D3DXMatrixTranslation( &g_ControlMatrix[CONTROL_WHITEBUTTON], 0.0f, 0.0f, 2.0f * m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_WHITE] / 255.0f );
        }

        // Animate left trigger
        { 
            D3DXMATRIX matTrans1, matRotate, matTrans2, matAll;
            D3DXMatrixTranslation( &matTrans1, -g_vLeftTriggerOffset.x, -g_vLeftTriggerOffset.y, -g_vLeftTriggerOffset.z );
            D3DXMatrixRotationAxis( &matRotate, &g_vLeftTriggerAxis, (D3DX_PI/6) * m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] / 255.0f );
            D3DXMatrixTranslation( &matTrans2, g_vLeftTriggerOffset.x, g_vLeftTriggerOffset.y, g_vLeftTriggerOffset.z );
            D3DXMatrixMultiply( &matAll, &matTrans1, &matRotate );
            D3DXMatrixMultiply( &matAll, &matAll, &matTrans2 );
            g_ControlMatrix[CONTROL_LEFTTRIGGER] = matAll;
        }

        // Animate right trigger
        { 
            D3DXMATRIX matTrans1, matRotate, matTrans2, matAll;
            D3DXMatrixTranslation( &matTrans1, -g_vRightTriggerOffset.x, -g_vRightTriggerOffset.y, -g_vRightTriggerOffset.z );
            D3DXMatrixRotationAxis( &matRotate, &g_vRightTriggerAxis, (D3DX_PI/6) * m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] / 255.0f );
            D3DXMatrixTranslation( &matTrans2, g_vRightTriggerOffset.x, g_vRightTriggerOffset.y, g_vRightTriggerOffset.z );
            D3DXMatrixMultiply( &matAll, &matTrans1, &matRotate );
            D3DXMatrixMultiply( &matAll, &matAll, &matTrans2 );
            g_ControlMatrix[CONTROL_RIGHTTRIGGER] = matAll;
        }

        // Animate DPAD
        { 
            D3DXVECTOR3 vAxis(0,0,0);

            if( m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_UP )    vAxis.x = +1.0f;
            if( m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_DOWN )  vAxis.x = -1.0f;
            if( m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_LEFT )  vAxis.y = +1.0f;
            if( m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ) vAxis.y = -1.0f;

            if( vAxis.x || vAxis.y )
            {
                D3DXMATRIX matTrans1, matRotate, matTrans2, matAll;
                D3DXMatrixTranslation( &matTrans1, -g_vDPadOffset.x, -g_vDPadOffset.y, -g_vDPadOffset.z );
                D3DXMatrixRotationAxis( &matRotate, &vAxis, D3DX_PI/20 );
                D3DXMatrixTranslation( &matTrans2, g_vDPadOffset.x, g_vDPadOffset.y, g_vDPadOffset.z );
                D3DXMatrixMultiply( &matAll, &matTrans1, &matRotate );
                D3DXMatrixMultiply( &matAll, &matAll, &matTrans2 );
                g_ControlMatrix[CONTROL_DPAD] = matAll;
            }
            else
                D3DXMatrixIdentity( &g_ControlMatrix[CONTROL_DPAD] );
        }

        // Animate left thumbstick
        { 
            D3DXVECTOR3 vAxis(0,0,0);

            vAxis.x = +m_pGamepad->fY1;
            vAxis.y = -m_pGamepad->fX1;

            FLOAT fStickTrans = m_pGamepad->wButtons & XINPUT_GAMEPAD_LEFT_THUMB ? 1.0f : 0.0f;

            if( vAxis.x || vAxis.y )
            {
                D3DXMATRIX matTrans1, matRotate, matTrans2, matAll;
                D3DXMatrixTranslation( &matTrans1, -g_vLeftStickOffset.x, -g_vLeftStickOffset.y, -g_vLeftStickOffset.z );
                D3DXMatrixRotationAxis( &matRotate, &vAxis, D3DXVec3Length( &vAxis)/3 );
                D3DXMatrixTranslation( &matTrans2, g_vLeftStickOffset.x, g_vLeftStickOffset.y, g_vLeftStickOffset.z+fStickTrans );
                D3DXMatrixMultiply( &matAll, &matTrans1, &matRotate );
                D3DXMatrixMultiply( &matAll, &matAll, &matTrans2 );
                g_ControlMatrix[CONTROL_LEFTTHUMBSTICK] = matAll;
            }
            else
                D3DXMatrixTranslation( &g_ControlMatrix[CONTROL_LEFTTHUMBSTICK], 0.0f, 0.0f, fStickTrans );
        }

        // Animate right thumbstick
        { 
            D3DXVECTOR3 vAxis(0,0,0);

            vAxis.x = +m_pGamepad->fY2;
            vAxis.y = -m_pGamepad->fX2;

            FLOAT fStickTrans = m_pGamepad->wButtons & XINPUT_GAMEPAD_RIGHT_THUMB ? 1.0f : 0.0f;

            if( vAxis.x || vAxis.y )
            {
                D3DXMATRIX matTrans1, matRotate, matTrans2, matAll;
                D3DXMatrixTranslation( &matTrans1, -g_vRightStickOffset.x, -g_vRightStickOffset.y, -g_vRightStickOffset.z );
                D3DXMatrixRotationAxis( &matRotate, &vAxis, D3DXVec3Length( &vAxis)/3 );
                D3DXMatrixTranslation( &matTrans2, g_vRightStickOffset.x, g_vRightStickOffset.y, g_vRightStickOffset.z+fStickTrans );
                D3DXMatrixMultiply( &matAll, &matTrans1, &matRotate );
                D3DXMatrixMultiply( &matAll, &matAll, &matTrans2 );
                g_ControlMatrix[CONTROL_RIGHTTHUMBSTICK] = matAll;
            }
            else
                D3DXMatrixTranslation( &g_ControlMatrix[CONTROL_RIGHTTHUMBSTICK], 0.0f, 0.0f, fStickTrans );
        }
    }

    // Handle the vibration test page
    if( m_AppState == APPSTATE_VIBRATIONTEST )
    {
        m_fLeftMotorSpeed  = m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] / 255.0f;
        m_fRightMotorSpeed = m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] / 255.0f;
    }

    // Handle the deadzone calibration page
    if( m_AppState == APPSTATE_DEADZONECALIBRATION )
    {
        // Adjust the deadzone
        if( m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_UP )
            m_fDeadZone += 1.0f/256.0f;
        if( m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_DOWN )
            m_fDeadZone -= 1.0f/256.0f;
        m_fDeadZone = min( 1.0f, max( 0.0f, m_fDeadZone ) );
    }

    // Handle the button quantization page
    if( m_AppState == APPSTATE_BUTTONQUANTIZATION )
    {
        // Reset the recorded values
        if( m_pGamepad->wButtons & XINPUT_GAMEPAD_START )
        {
            ZeroMemory( m_pQuantizedThumbStickValues, 256 );
            ZeroMemory( m_pQuantizedButtonValues, 256 );
        }

        // Record quantized thumbstick values
        m_pQuantizedThumbStickValues[ (32768 + m_pGamepad->sThumbLX) >> 8 ] |= 0x01;
        m_pQuantizedThumbStickValues[ (32768 + m_pGamepad->sThumbLY) >> 8 ] |= 0x02;
        m_pQuantizedThumbStickValues[ (32768 + m_pGamepad->sThumbRX) >> 8 ] |= 0x04;
        m_pQuantizedThumbStickValues[ (32768 + m_pGamepad->sThumbRY) >> 8 ] |= 0x08;

        // Record quantized button values
        m_pQuantizedButtonValues[ m_pGamepad->bAnalogButtons[0] ] |= 0x01;
        m_pQuantizedButtonValues[ m_pGamepad->bAnalogButtons[1] ] |= 0x02;
        m_pQuantizedButtonValues[ m_pGamepad->bAnalogButtons[2] ] |= 0x04;
        m_pQuantizedButtonValues[ m_pGamepad->bAnalogButtons[3] ] |= 0x08;
        m_pQuantizedButtonValues[ m_pGamepad->bAnalogButtons[4] ] |= 0x10;
        m_pQuantizedButtonValues[ m_pGamepad->bAnalogButtons[5] ] |= 0x20;
        m_pQuantizedButtonValues[ m_pGamepad->bAnalogButtons[6] ] |= 0x40;
        m_pQuantizedButtonValues[ m_pGamepad->bAnalogButtons[7] ] |= 0x80;
    }

    // Set the vibration motors
    for( DWORD i=0; i<4; i++ )
    {
        if( m_Gamepad[i].hDevice )
        {
            // Check to see if we are still transferring current motor value
            if( m_Gamepad[i].Feedback.Header.dwStatus != ERROR_IO_PENDING )
            {
                // We can alter the motor values
                m_Gamepad[i].Feedback.Rumble.wLeftMotorSpeed  = WORD( m_fLeftMotorSpeed  * 65535.0f );
                m_Gamepad[i].Feedback.Rumble.wRightMotorSpeed = WORD( m_fRightMotorSpeed * 65535.0f );
                XInputSetState( m_Gamepad[i].hDevice, &m_Gamepad[i].Feedback );
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawBox()
// Desc: Graphics helper function
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawBox( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2,
                              DWORD dwFillColor, DWORD dwOutlineColor )
{
    D3DXVECTOR4 v[4];
    v[0] = D3DXVECTOR4( x1-0.5f, y1-0.5f, 0, 0 );
    v[1] = D3DXVECTOR4( x2-0.5f, y1-0.5f, 0, 0 );
    v[2] = D3DXVECTOR4( x2-0.5f, y2-0.5f, 0, 0 );
    v[3] = D3DXVECTOR4( x1-0.5f, y2-0.5f, 0, 0 );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );

    // Render the box
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwFillColor );
    m_pd3dDevice->DrawVerticesUP( D3DPT_QUADLIST, 4, v, sizeof(v[0]) );

    // Render the lines
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwOutlineColor );
    m_pd3dDevice->DrawVerticesUP( D3DPT_LINELOOP, 4, v, sizeof(v[0]) );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderInsertRemoveControllerPage()
// Desc: Inform the user to please insert or remove a controller
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderInsertRemoveControllerPage()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Set some default state
    m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,          0x00ffffff );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         TRUE );

    // Draw header
    DrawBox( 64, 50, 576, 93, 0x40000000, 0xff000000 );
    m_Font16.DrawText(  69,  50, 0xffffffff, L"Xbox Controller Tool", XBFONT_LEFT );

    // Display a message requesting the user to insert a gamepad controller. Since
    // the Xbox input API take a second or so to detect a controller, let's delay
    // this message a tiny bit
    if( m_fAppTime > 2.0f )
    {
        DrawBox( 64, 103, 576, 430, 0x40000000, 0xff000000 );

        if( m_dwNumInsertedGamepads == 0 )
            m_Font16.DrawText( 320, 250, 0xffffffff, L"Please insert a gamepad controller", XBFONT_CENTER_X );
        else // if( m_dwNumInsertedGamepads > 1 )
            m_Font16.DrawText( 320, 250, 0xffffffff, L"Please remove all but one gamepad controllers", XBFONT_CENTER_X );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderControlTestPage()
// Desc: Renders the page for testing the controls
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderControlTestPage()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Set some default state
    m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,          0x00ffffff );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         TRUE );

    // Since xrays go through objects, it only looks convincing if we turn on
    // alpha-blending and render both sides of the object 
    if( m_bAlphaEnabled )
    {
        // Lighting is not needed, since we don't use the diffuse color
        m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,     FALSE );

        // Setup to render both sides of the object
        m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,     D3DCULL_NONE );

        // Turn on alpha blending
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,     D3DBLEND_SRCCOLOR );
        m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,    D3DBLEND_ONE );

        // Set the transparency
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0x80808080 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TFACTOR );
    }

    // Generate spheremap texture coords from the camera space normal. This has
    // two steps. First, tell D3D to use the vertex normal (in camera space) as
    // texture coordinates. Then, we setup a texture matrix to transform these
    // texcoords from (-1,+1) view space to (0,1) texture space. This way,
    // the normal can be used to look up a texel in the spheremap.
    D3DXMATRIX mat;
    mat._11 = 0.5f; mat._12 = 0.0f;
    mat._21 = 0.0f; mat._22 =-0.5f;
    mat._31 = 0.0f; mat._32 = 0.0f;
    mat._41 = 0.5f; mat._42 = 0.5f;
    m_pd3dDevice->SetTransform( D3DTS_TEXTURE0, &mat );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACENORMAL );

    // Finally, draw the object
    m_pGamepadMesh->Render( m_pd3dDevice, XBMESH_NOTEXTURES|XBMESH_NOMATERIALS );

    // Restore render states
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_PASSTHRU );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,     TRUE );

    // Draw back side to fill holes
    if( FALSE == m_bAlphaEnabled )
    {
        m_pd3dDevice->SetTexture( 0, NULL );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff000000 );
        m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW );
        m_pGamepadMesh->Render( m_pd3dDevice, XBMESH_NOTEXTURES|XBMESH_NOMATERIALS );
    }

    // Restore render states
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, FALSE );


    // Draw header
    DrawBox( 64, 50, 576, 93, 0x40000000, 0xff000000 );
    m_Font16.DrawText(  69,  50, 0xffffffff, L"Xbox Controller Tool", XBFONT_LEFT );
    m_Font16.DrawText( 571,  50, 0xffffffff, L"Control Test Page", XBFONT_RIGHT );
    m_Font12.DrawText( 571,  75, 0xff808080, L"Press START and BACK for next page", XBFONT_RIGHT );

    // Draw options
    m_Font12.Begin();


    WCHAR strBuffer[40];

    swprintf( strBuffer, L"LeftTrigger = %d", m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] );
    m_Font12.DrawText( 140,  95, m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] ? 0xffffff00: 0x80ffffff, strBuffer );
    
    swprintf( strBuffer, L"RightTrigger = %d", m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] );
    m_Font12.DrawText( 350,  95, m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] ? 0xffffff00: 0x80ffffff, strBuffer );

    swprintf( strBuffer, L"LeftStick.x = %d", m_pGamepad->sThumbLX );
    m_Font12.DrawText(  64, 116, m_pGamepad->fX1!=0.0f ? 0xffffff00: 0x80ffffff, strBuffer );
    swprintf( strBuffer, L"LeftStick.y = %d", m_pGamepad->sThumbLY );
    m_Font12.DrawText(  64, 134, m_pGamepad->fY1!=0.0f ? 0xffffff00: 0x80ffffff, strBuffer );
    swprintf( strBuffer, L"LeftThumb" );
    m_Font12.DrawText(  64, 152, m_pGamepad->wButtons & XINPUT_GAMEPAD_LEFT_THUMB ? 0xffffff00: 0x80ffffff, strBuffer );

    m_Font12.DrawText( 110, 362, m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_UP    ? 0xffffff00: 0x80ffffff, L"Up",    XBFONT_CENTER_X );
    m_Font12.DrawText(  85, 380, m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_LEFT  ? 0xffffff00: 0x80ffffff, L"Left",  XBFONT_CENTER_X );
    m_Font12.DrawText( 135, 380, m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ? 0xffffff00: 0x80ffffff, L"Right", XBFONT_CENTER_X );
    m_Font12.DrawText( 110, 398, m_pGamepad->wButtons & XINPUT_GAMEPAD_DPAD_DOWN  ? 0xffffff00: 0x80ffffff, L"Down",  XBFONT_CENTER_X );

    m_Font12.DrawText( 320, 380, g_ControlActive[CONTROL_BACKBUTTON] ? 0xffffff00: 0x80ffffff, L"Back", XBFONT_RIGHT );
    m_Font12.DrawText( 330, 380, g_ControlActive[CONTROL_STARTBUTTON] ? 0xffffff00: 0x80ffffff, L"Start", XBFONT_LEFT );
    
    swprintf( strBuffer, L"White = %d", m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_WHITE] );
    m_Font12.DrawText( 390, 116, g_ControlActive[CONTROL_WHITEBUTTON] ? 0xffffff00: 0x80ffffff, strBuffer );
    swprintf( strBuffer, L"Y = %d", m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_Y] );
    m_Font12.DrawText( 390, 134, g_ControlActive[CONTROL_YBUTTON] ? 0xffffff00: 0x80ffffff, strBuffer );
    swprintf( strBuffer, L"X = %d", m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_X] );
    m_Font12.DrawText( 390, 152, g_ControlActive[CONTROL_XBUTTON] ? 0xffffff00: 0x80ffffff, strBuffer );

    swprintf( strBuffer, L"Black = %d", m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_BLACK] );
    m_Font12.DrawText( 490, 116, g_ControlActive[CONTROL_BLACKBUTTON] ? 0xffffff00: 0x80ffffff, strBuffer );
    swprintf( strBuffer, L"B = %d", m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_B] );
    m_Font12.DrawText( 490, 134, g_ControlActive[CONTROL_BBUTTON] ? 0xffffff00: 0x80ffffff, strBuffer );
    swprintf( strBuffer, L"A = %d", m_pGamepad->bAnalogButtons[XINPUT_GAMEPAD_A] );
    m_Font12.DrawText( 490, 152, g_ControlActive[CONTROL_ABUTTON] ? 0xffffff00: 0x80ffffff, strBuffer );

    swprintf( strBuffer, L"RightStick.x = %d", m_pGamepad->sThumbRX );
    m_Font12.DrawText( 400, 362, m_pGamepad->fX2!=0.0f ? 0xffffff00: 0x80ffffff, strBuffer );
    swprintf( strBuffer, L"RightStick.y = %d", m_pGamepad->sThumbRY );
    m_Font12.DrawText( 400, 380, m_pGamepad->fY2!=0.0f ? 0xffffff00: 0x80ffffff, strBuffer );
    swprintf( strBuffer, L"RightThumb" );
    m_Font12.DrawText( 400, 398, m_pGamepad->wButtons & XINPUT_GAMEPAD_RIGHT_THUMB ? 0xffffff00: 0x80ffffff, strBuffer );

    m_Font12.End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderVibrationTestPage()
// Desc: Renders the page for testing the gamepad vibration motors.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderVibrationTestPage()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Draw header
    DrawBox( 64, 50, 576, 93, 0x40000000, 0xff000000 );
    m_Font16.DrawText(  69,  50, 0xffffffff, L"Xbox Controller Tool", XBFONT_LEFT );
    m_Font16.DrawText( 571,  50, 0xffffffff, L"Vibration Test Page", XBFONT_RIGHT );
    m_Font12.DrawText( 571,  75, 0xff808080, L"Press START and BACK for next page", XBFONT_RIGHT );

    // Draw instructions
    DrawBox( 376, 100, 576, 430, 0x40000000, 0xff000000 );
    m_Font12.DrawText( 381, 100, 0xff808080, L"Use the left and right\n"
                                             L"triggers to test the\n"
                                             L"vibration function of\n"
                                             L"gamepad motors.\n" );

    // Draw outside box
    DrawBox( 64, 100, 366, 430, 0x00000000, 0xff000000 );

    // Draw the analog gauges
    m_pd3dDevice->SetTexture( 0, m_xprResource.GetTexture( resource_AnalogGauge_OFFSET ) );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    struct VERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
    VERTEX v[4];
    v[0].p = D3DXVECTOR4( 215-100     - 0.5f, 120     - 0.5f, 0, 0 );  v[0].tu =   0; v[0].tv =   0;
    v[1].p = D3DXVECTOR4( 215-100+256 - 0.5f, 120     - 0.5f, 0, 0 );  v[1].tu = 256; v[1].tv =   0;
    v[2].p = D3DXVECTOR4( 215-100+256 - 0.5f, 120+128 - 0.5f, 0, 0 );  v[2].tu = 256; v[2].tv = 128;
    v[3].p = D3DXVECTOR4( 215-100     - 0.5f, 120+128 - 0.5f, 0, 0 );  v[3].tu =   0; v[3].tv = 128;
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, v, sizeof(v[0]) );
    v[0].p = D3DXVECTOR4( 215-100     - 0.5f, 260     - 0.5f, 0, 0 );  v[0].tu =   0; v[0].tv =   0;
    v[1].p = D3DXVECTOR4( 215-100+256 - 0.5f, 260     - 0.5f, 0, 0 );  v[1].tu = 256; v[1].tv =   0;
    v[2].p = D3DXVECTOR4( 215-100+256 - 0.5f, 260+128 - 0.5f, 0, 0 );  v[2].tu = 256; v[2].tv = 128;
    v[3].p = D3DXVECTOR4( 215-100     - 0.5f, 260+128 - 0.5f, 0, 0 );  v[3].tu =   0; v[3].tv = 128;
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, v, sizeof(v[0]) );

    // Draw the gauge needles
    FLOAT fLeftAngle  = 0.85f * (2*m_fLeftMotorSpeed-1);
    FLOAT fRightAngle = 0.85f * (2*m_fRightMotorSpeed-1);
    v[0].p.x = 215 + 92*sinf(fLeftAngle);   v[0].p.y = 120 + 111 - 92*cosf(fLeftAngle); 
    v[1].p.x = 215 + 48*sinf(fLeftAngle);   v[1].p.y = 120 + 111 - 48*cosf(fLeftAngle); 
    v[2].p.x = 215 + 92*sinf(fRightAngle);  v[2].p.y = 260 + 111 - 92*cosf(fRightAngle); 
    v[3].p.x = 215 + 48*sinf(fRightAngle);  v[3].p.y = 260 + 111 - 48*cosf(fRightAngle); 
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 2, v, sizeof(v[0]) );

    // Draw the motor text
    WCHAR strBuffer[80];
    swprintf( strBuffer, L"%d%%", (WORD)(100*m_fLeftMotorSpeed) );
    m_Font16.DrawText( 215+40, 120+100, 0xffffffff, L"Left Motor: ", XBFONT_RIGHT );
    m_Font16.DrawText( 215+40, 120+100, 0xffffff00, strBuffer, XBFONT_LEFT );

    swprintf( strBuffer, L"%d%%", (WORD)(100*m_fRightMotorSpeed) );
    m_Font16.DrawText( 215+40, 260+100, 0xffffffff, L"Right Motor: ", XBFONT_RIGHT );
    m_Font16.DrawText( 215+40, 260+100, 0xffffff00, strBuffer, XBFONT_LEFT );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderDeadZoneCalibrationPage()
// Desc: Renders the page for calibrating the thumbsticks' deadzone.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderDeadZoneCalibrationPage()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Draw header
    DrawBox( 64, 50, 576, 93, 0x40000000, 0xff000000 );
    m_Font16.DrawText(  69,  50, 0xffffffff, L"Xbox Controller Tool", XBFONT_LEFT );
    m_Font16.DrawText( 571,  50, 0xffffffff, L"Deadzone Calibration Page", XBFONT_RIGHT );
    m_Font12.DrawText( 571,  75, 0xff808080, L"Press START and BACK for next page", XBFONT_RIGHT );

    FLOAT fBoxCenterX = 204.0f;
    FLOAT fBoxCenterY = 240.0f;
    FLOAT fBoxRadius  = 140.0f;
    FLOAT fDeadZone   = m_fDeadZone * fBoxRadius;

    // Draw outside box
    DrawBox( fBoxCenterX - fBoxRadius, fBoxCenterY - fBoxRadius, 
             fBoxCenterX + fBoxRadius, fBoxCenterY + fBoxRadius, 
             0x00000000, 0xff000000 );

    // Draw inside box
    DrawBox( fBoxCenterX - fDeadZone, fBoxCenterY - fDeadZone, 
             fBoxCenterX + fDeadZone, fBoxCenterY + fDeadZone, 
             0x00000000, 0xffffffff );

    // Draw left thumb stick in red
    FLOAT fThumbLX = fBoxCenterX + fBoxRadius*(m_pGamepad->sThumbLX+0.5f)/32767.5f;
    FLOAT fThumbLY = fBoxCenterY - fBoxRadius*(m_pGamepad->sThumbLY+0.5f)/32767.5f;
    DrawBox( fThumbLX-1, fThumbLY-8, fThumbLX+1, fThumbLY+8, 0xffff0000, 0xffff0000 );
    DrawBox( fThumbLX-8, fThumbLY-1, fThumbLX+8, fThumbLY+1, 0xffff0000, 0xffff0000 );

    // Draw right thumb stick in green
    FLOAT fThumbRX = fBoxCenterX + fBoxRadius*(m_pGamepad->sThumbRX+0.5f)/32767.5f;
    FLOAT fThumbRY = fBoxCenterY - fBoxRadius*(m_pGamepad->sThumbRY+0.5f)/32767.5f;
    DrawBox( fThumbRX-1, fThumbRY-8, fThumbRX+1, fThumbRY+8, 0xff00ff00, 0xff00ff00 );
    DrawBox( fThumbRX-8, fThumbRY-1, fThumbRX+8, fThumbRY+1, 0xff00ff00, 0xff00ff00 );

    // Draw instructions
    DrawBox( 354, 100, 576, 380, 0x40000000, 0xff000000 );
    m_Font12.DrawText( 359, 100, 0xff808080, L"Move thumbsticks to test\n"
                                             L"sensitivty around the\n"
                                             L"the deadzone (defined by\n"
                                             L"the white box). Let them\n"
                                             L"snap back and notice how\n"
                                             L"the controls adapt over\n"
                                             L"time allowing for a smaller\n"
                                             L"deadzone.\n\n"
                                             L"Use DPad to control the\n"
                                             L"deadzone size.");

    WCHAR strBuffer[80];
    swprintf( strBuffer, L"Deadzone: %ld (%ld%%)", (LONG)(32768*m_fDeadZone), (LONG)(100*m_fDeadZone) );
    m_Font12.DrawText( 359, 360, 0xffffffff, strBuffer );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderButtonQuantizationPage()
// Desc: Renders the page for testing the quantization of the controls
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderButtonQuantizationPage()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Draw header
    DrawBox( 64, 50, 576, 93, 0x40000000, 0xff000000 );
    m_Font16.DrawText(  69,  50, 0xffffffff, L"Xbox Controller Tool", XBFONT_LEFT );
    m_Font16.DrawText( 571,  50, 0xffffffff, L"Control Quantization Page", XBFONT_RIGHT );
    m_Font12.DrawText( 571,  75, 0xff808080, L"Press START and BACK for next page", XBFONT_RIGHT );

    // Draw instructions
    DrawBox( 374, 100, 576, 400, 0x40000000, 0xff000000 );
    m_Font12.DrawText( 379, 100, 0xff808080, L"Analog controls have 8\n"
                                             L"bits of precision. Press\n"
                                             L"the analog buttons and\n"
                                             L"move the thumbsticks to\n"
                                             L"see what values are\n"
                                             L"quantized. Hit the START\n"
                                             L"button to reset the values.");

    // Draw outside box
    DrawBox( 64, 100, 364, 400, 0x00000000, 0xff000000 );

    // Colors for rendering the quantized values
    DWORD adwColors[8] =
    {
        0xff80ff80, // Light green
        0xffff8080, // Light red
        0xff8080ff, // Light blue
        0xffffff80, // Light yellow
        0xff000000, // Black
        0xffffffff, // White
        0xff000000, // Black
        0xff000000, // Black
    };

    // Count of unique quantized values for each of the 8 analog controls and 
    // the 4 thumbstick axes.
    DWORD adwQuantizationCount[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

    // Display quantized button values
    m_Font12.DrawText( 150, 100, 0xffffffff, L"Buttons", XBFONT_CENTER_X );

    for( DWORD x=0; x<8; x++ )
    {
        // Draw gray bar
        DrawBox( 20.0f*x+78.0f, 120.0f, 20.0f*x+82.0f, 376.0f, 0xff404040, 0xff404040 );

        for( DWORD y=0; y<256; y++ )
        {
            // Highlight recorded values
            if( m_pQuantizedButtonValues[y] & (1<<x) )
            {
                DrawBox( 20.0f*x+76.0f, 376.0f-y, 20.0f*x+84.0f, 376.0f-y, adwColors[x], adwColors[x] );
                adwQuantizationCount[x]++;
            }

            // Highlight the current value
            DrawBox( 20.0f*x+74.0f, 375.0f-m_pGamepad->bAnalogButtons[x], 
                     20.0f*x+86.0f, 377.0f-m_pGamepad->bAnalogButtons[x], 
                     adwColors[x], adwColors[x] );
        }

        // Draw label
        m_Font12.DrawText( 20.0f*x+80.0f, 376.0f, 0xffffffff, L"A\0B\0X\0Y\0B\0W\0L\0R\0"+2*x, XBFONT_CENTER_X );
    }

    // Display quantized thumbstick values
    m_Font12.DrawText( 305.0f, 100.0f, 0xffffffff, L"Thumbsticks", XBFONT_CENTER_X );

    for( x=0; x<4; x++ )
    {
        // Draw gray bar
        DrawBox( 30.0f*x+258.0f, 120.0f, 30.0f*x+262.0f, 376.0f, 0xff404040, 0xff404040 );

        for( DWORD y=0; y<256; y++ )
        {
            // Highlight recorded values
            if( m_pQuantizedThumbStickValues[y] & (1<<x) )
            {
                DrawBox( 30.0f*x+256.0f, 376.0f-y, 30.0f*x+264, 376.0f-y, 0xffffffff, 0xffffffff );
                adwQuantizationCount[8+x]++;
            }

            // Highlight the current value
            BYTE val = 0;
            if( x == 0 ) val = (32768 + m_pGamepad->sThumbLX) >> 8;
            if( x == 1 ) val = (32768 + m_pGamepad->sThumbLY) >> 8;
            if( x == 2 ) val = (32768 + m_pGamepad->sThumbRX) >> 8;
            if( x == 3 ) val = (32768 + m_pGamepad->sThumbRY) >> 8;
            DrawBox( 30.0f*x+254.0f, 375.0f-val, 30.0f*x+266.0f, 377.0f-val, 0xffff0000, 0xffff0000 );
        }

        // Draw label
        m_Font12.DrawText( 30.0f*x+260.0f, 376.0f, 0xffffffff, L"LX\0LY\0RX\0RY\0"+3*x, XBFONT_CENTER_X );
    }

    // Show the number of unique values each analog control has hit
    WCHAR strBuffer[80];
    m_Font12.DrawText( 379, 260, 0xff808080, L"Count of unique values:" );

    m_Font12.DrawText( 399, 280, 0xff808080, L"A\nB\nX\nY\nB\nW\n" );
    swprintf( strBuffer, L"%ld\n%ld\n%ld\n%ld\n%ld\n%ld\n",
                         adwQuantizationCount[0], adwQuantizationCount[1], 
                         adwQuantizationCount[2], adwQuantizationCount[3], 
                         adwQuantizationCount[4], adwQuantizationCount[5] );
    m_Font12.DrawText( 419, 280, 0xffffffff, strBuffer );

    m_Font12.DrawText( 485, 280, 0xff808080, L"LT\nRT\nLX\nLY\nRX\nRY\n" );
    swprintf( strBuffer, L"%ld\n%ld\n%ld\n%ld\n%ld\n%ld\n",
                         adwQuantizationCount[6], adwQuantizationCount[7], 
                         adwQuantizationCount[8], adwQuantizationCount[9], 
                         adwQuantizationCount[10], adwQuantizationCount[11] );
    m_Font12.DrawText( 515, 280, 0xffffffff, strBuffer );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    if( m_dwNumInsertedGamepads != 1 )
    {
        RenderInsertRemoveControllerPage();
    }
    else
    {
        switch( m_AppState )
        {
            case APPSTATE_CONTROLTEST:
                RenderControlTestPage();
                break;

            case APPSTATE_VIBRATIONTEST:
                RenderVibrationTestPage();
                break;
        
            case APPSTATE_DEADZONECALIBRATION:
                RenderDeadZoneCalibrationPage();
                break;
        
            case APPSTATE_BUTTONQUANTIZATION:
                RenderButtonQuantizationPage();
                break;
        }
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Rumble\Font16.h ===
// Automatically generated by the bundler tool from Font16.rdf

#define Font16_NUM_RESOURCES 2UL

#define Font16_Font_OFFSET 0UL
#define Font16_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Rumble\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Rumble\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Gamepad\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 20UL

#define resource_AnalogGauge_OFFSET 0UL
#define resource_MatteBlack_OFFSET 20UL
#define resource_ShinyBlack_OFFSET 40UL
#define resource_Cord_OFFSET 60UL
#define resource_Sample2_4_OFFSET 80UL
#define resource_Sample16_7_OFFSET 100UL
#define resource_Sample18_9_OFFSET 120UL
#define resource_Sample20_10_OFFSET 140UL
#define resource_Sample21_11_OFFSET 160UL
#define resource_Sample25_15_OFFSET 180UL
#define resource_Sample28_16_OFFSET 200UL
#define resource_Sample29_17_OFFSET 220UL
#define resource_Sample30_18_OFFSET 240UL
#define resource_Sample31_19_OFFSET 260UL
#define resource_GreenGlass_OFFSET 280UL
#define resource_WhiteGlass_OFFSET 300UL
#define resource_RedGlass_OFFSET 320UL
#define resource_BlueGlass_OFFSET 340UL
#define resource_YellowGlass_OFFSET 360UL
#define resource_GreenBezel_OFFSET 380UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Rumble\obj\i386\Font16.h ===
// Automatically generated by the bundler tool from Font16.rdf

#define Font16_NUM_RESOURCES 2UL

#define Font16_Font_OFFSET 0UL
#define Font16_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Rumble\obj\i386\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\AudioBenchmark\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Gamepad\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 20UL

#define resource_AnalogGauge_OFFSET 0UL
#define resource_MatteBlack_OFFSET 20UL
#define resource_ShinyBlack_OFFSET 40UL
#define resource_Cord_OFFSET 60UL
#define resource_Sample2_4_OFFSET 80UL
#define resource_Sample16_7_OFFSET 100UL
#define resource_Sample18_9_OFFSET 120UL
#define resource_Sample20_10_OFFSET 140UL
#define resource_Sample21_11_OFFSET 160UL
#define resource_Sample25_15_OFFSET 180UL
#define resource_Sample28_16_OFFSET 200UL
#define resource_Sample29_17_OFFSET 220UL
#define resource_Sample30_18_OFFSET 240UL
#define resource_Sample31_19_OFFSET 260UL
#define resource_GreenGlass_OFFSET 280UL
#define resource_WhiteGlass_OFFSET 300UL
#define resource_RedGlass_OFFSET 320UL
#define resource_BlueGlass_OFFSET 340UL
#define resource_YellowGlass_OFFSET 360UL
#define resource_GreenBezel_OFFSET 380UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\BeginEnd\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\AudioBenchmark\AudioBenchmark.cpp ===
//-----------------------------------------------------------------------------
// File: AudioBenchmark.cpp
//
// Desc: [TODO: Describe source file here]
//
// Hist: 8.2.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include "dsstdfx.h"
#include <vtuneapi.h>

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Run test" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle playback" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Reinitialize\nbuffers" },
};

#define NUM_HELP_CALLOUTS ( sizeof( g_HelpCallouts ) / sizeof( g_HelpCallouts[0] ) )

#define NUM_3D_BUFFERS 64
#define DSBCAPS DSBCAPS_CTRL3D

BOOL g_bTesting = FALSE;
#define BEFORETEST( xxTest ) \
    g_bTesting = TRUE; \
    LARGE_INTEGER liBefore, liAfter; \
    QueryPerformanceCounter( &liBefore ); \

#define AFTERTEST( xxTest ) \
    QueryPerformanceCounter( &liAfter ); \
    g_aTests[ xxTest ].fTime = ( liAfter.QuadPart - liBefore.QuadPart ) * m_fMSPerTick; \
    g_bTesting = FALSE; \

#define FLUSH_BEFORE_CALL 0
#if FLUSH_BEFORE_CALL
#define FLUSH_PIO() \
    while( *(volatile DWORD *)0xfe820010 < 0x80 );
#else
#define FLUSH_PIO()
#endif


#define RECORDTEST( xxTest ) g_aTests[ xxTest ].fTime = ( liAfter.QuadPart - liBefore.QuadPart ) * m_fMSPerTick;
#define DSoundInitHRTF() DirectSoundUseFullHRTF()

HRESULT CreateSineWaveBuffer( double dFrequency, LPDIRECTSOUNDBUFFER8 * ppBuffer );

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
    HRESULT DownloadEffectsImage(PCHAR pszScratchFile);  // downloads a default DSP image to the GP

    HRESULT SetCurrentPosition();
    HRESULT PlayAll();
    HRESULT StopAll();
    HRESULT InitializeBuffers();

    HRESULT PositionAllImmediate();
    HRESULT VelocityAllImmediate();
    HRESULT PositionListenerImmediate();
    HRESULT VelocityListenerImmediate();

    HRESULT PositionAll();
    HRESULT VelocityAll();
    HRESULT PositionListener();
    HRESULT VelocityListener();
    HRESULT Commit3D();

    HRESULT SetFrequency();
    HRESULT SetVolume();
    HRESULT SetPitch();
    HRESULT SetEG();
    HRESULT SetFilter();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    BOOL        m_bDrawHelp;

    LPDIRECTSOUND8  m_pDSound;
    LPDIRECTSOUNDBUFFER8 m_apBuffers[ NUM_3D_BUFFERS ];
    BOOL        m_bPlaying;
    DWORD       m_dwTest;

    D3DXVECTOR3 m_avPositions[ NUM_3D_BUFFERS ];
    D3DXVECTOR3 m_avVelocities[ NUM_3D_BUFFERS ];

    D3DXVECTOR3 m_vListenerPosition;
    D3DXVECTOR3 m_vListenerVelocity;

    FLOAT       m_fMSPerTick;
};

typedef enum {
    AB_SETCURRENTPOSITION,
    AB_PLAY,
    AB_STOP,
    AB_RELEASE,
    AB_POSITIONSOURCE,
    AB_VELOCITYSOURCE,
    AB_POSITIONLISTENER,
    AB_VELOCITYLISTENER,
    AB_POSITIONSOURCE_DEFERRED,
    AB_VELOCITYSOURCE_DEFERRED,
    AB_POSITIONLISTENER_DEFERRED,
    AB_VELOCITYLISTENER_DEFERRED,
    AB_COMMIT3D,
    AB_FREQUENCY,
    AB_VOLUME,
    AB_PITCH,
    AB_ENVELOPE,
    AB_SETFILTER,

    AB_MAX
} AB_TESTENUM;

typedef HRESULT (CXBoxSample::* TESTFUNCTION)();
typedef struct {
    WCHAR *         szDescription;
    FLOAT           fTime;
    TESTFUNCTION    pfn;
} AB_TEST;

static AB_TEST g_aTests[] =
{
    { L"SetCurrentPosition", 0.0f, CXBoxSample::SetCurrentPosition },               // AB_SETCURRENTPOSITION
    { L"Play", 0.0f, CXBoxSample::PlayAll },                                        // AB_PLAY
    { L"Stop", 0.0f, CXBoxSample::StopAll },                                        // AB_STOP
    { L"Release", 0.0f, CXBoxSample::InitializeBuffers },                           // AB_RELEASE
    { L"Position sources immediate", 0.0f, CXBoxSample::PositionAllImmediate },     // AB_POSITIONSOURCE
    { L"Velocity sources immediate", 0.0f, CXBoxSample::VelocityAllImmediate },     // AB_VELOCITYSOURCE
    { L"Position listener immediate", 0.0f, CXBoxSample::PositionListenerImmediate },   // AB_POSITIONLISTENER
    { L"Velocity listener immediate", 0.0f, CXBoxSample::VelocityListenerImmediate },   // AB_VELOCITYLISTENER
    { L"Position sources deferred", 0.0f, CXBoxSample::PositionAll },               // AB_POSITIONSOURCE_DEFERRED
    { L"Velocity sources deferred", 0.0f, CXBoxSample::VelocityAll },               // AB_POSITIONSOURCE_DEFERRED
    { L"Position listener deferred", 0.0f, CXBoxSample::PositionListener },         // AB_POSITIONSOURCE_DEFERRED
    { L"Velocity listener deferred", 0.0f, CXBoxSample::VelocityListener },         // AB_POSITIONSOURCE_DEFERRED
    { L"CommitDeferredSettings", 0.0f, CXBoxSample::Commit3D },                     // AB_COMMIT3D
    { L"Set frequency", 0.0f, CXBoxSample::SetFrequency },                          // AB_FREQUENCY
    { L"Set volume", 0.0f, CXBoxSample::SetVolume },                                // AB_VOLUME
    { L"Set pitch", 0.0f, CXBoxSample::SetPitch },                                  // AB_PITCH
    { L"Set amp envelope", 0.0f, CXBoxSample::SetEG },                              // AB_ENVELOPE
    { L"Set DLS2 fliter", 0.0f, CXBoxSample::SetFilter },                           // AB_SETFILTER
};
#define NUM_TESTS ( sizeof(g_aTests) / sizeof( g_aTests[0] ) )



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    memset( m_apBuffers, 0, sizeof( m_apBuffers ) );
    m_bDrawHelp = FALSE;
    m_dwTest = 0;
}



//-----------------------------------------------------------------------------
// Name: DownloadEffectsImage
// Desc: Downloads an effects image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadEffectsImage(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OUTPUT_DEBUG_STRING( "Failed to open the dsp image file.\n" );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OUTPUT_DEBUG_STRING( "\n Failed to open the dsp image file.\n" );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        if (SUCCEEDED(hr))
        {
            hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                                  dwSize,
                                                  &EffectLoc,
                                                  &pDesc );
        }
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    LARGE_INTEGER liFreq;
    QueryPerformanceFrequency( &liFreq );
    m_fMSPerTick = 1000.0f / liFreq.QuadPart;

    DirectSoundCreate( NULL, &m_pDSound, NULL );
    DSoundInitHRTF();
    //
    // download the standard DirectSound effecs image
    //
    if( FAILED( DownloadEffectsImage("d:\\media\\dsstdfx.bin") ) )
        return E_FAIL;


    InitializeBuffers();

    m_bPlaying = FALSE;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
#if 0
    if( m_bPlaying )
        StopAll();
    else
        PlayAll();
    m_bPlaying = !m_bPlaying;
#endif // 0
    
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Run test
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        (this->*g_aTests[m_dwTest].pfn)();
    }

    // Shortcut for toggling playback status
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        if( m_bPlaying )
            StopAll();
        else
            PlayAll();
    }

    // Shortcut to re-initialize buffers
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        InitializeBuffers();
    }

    // Test select
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
    {
        m_dwTest = (m_dwTest + NUM_TESTS - 1 ) % NUM_TESTS;
    }
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
    {
        m_dwTest = (m_dwTest + 1 ) % NUM_TESTS;
    }

    return S_OK;
}






//-----------------------------------------------------------------------------
// Name: CreateSineWaveBuffer
// Desc: Creates a DirectSound Buffer and fills it with a sine wave.  This
//       can be useful for DSP effects that are driven off an oscillator.
//       Note that non-integral frequencies will end up with a discontinuity
//       at the loop point.
//-----------------------------------------------------------------------------
HRESULT
CreateSineWaveBuffer( double dFrequency, LPDIRECTSOUNDBUFFER8 * ppBuffer )
{
    HRESULT hr = S_OK;
    LPDIRECTSOUNDBUFFER8 pBuffer = NULL;
    BYTE * pData = NULL;
    DWORD dwBytes = 0;
    double dArg = 0.0;
    double dSinVal = 0.0;
    BYTE bVal = 0;

    // Check arguments
    if( !ppBuffer || dFrequency < 0 )
        return E_INVALIDARG;

    *ppBuffer = NULL;

    //
    // Initialize a wave format structure
    //
    WAVEFORMATEX wfx;
    ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

    wfx.wFormatTag      = WAVE_FORMAT_PCM;      // PCM data
    wfx.nChannels       = 1;                    // Mono
    wfx.nSamplesPerSec  = 1000;                 // 1kHz
    wfx.nAvgBytesPerSec = 1000;                 // 1kHz * 1 bytes / sample
    wfx.nBlockAlign     = 1;                    // sample size in bytes
    wfx.wBitsPerSample  = 8;                    // 8 bit samples
    wfx.cbSize          = 0;                    // No extra data

    //
    // Intialize the buffer description
    DSBUFFERDESC dsbd;
    ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );

    dsbd.dwSize = sizeof( DSBUFFERDESC );
    dsbd.dwFlags = DSBCAPS;
    dsbd.dwBufferBytes = wfx.nAvgBytesPerSec;
    dsbd.lpwfxFormat = (WAVEFORMATEX *)&wfx;

    // Create the buffer
    hr = DirectSoundCreateBuffer( &dsbd, &pBuffer );
    if( FAILED( hr ) )
        return hr;

    // Get a pointer to buffer data to fill
    hr = pBuffer->Lock( 0, dsbd.dwBufferBytes, (VOID **)&pData, &dwBytes, NULL, NULL, 0 );
    if( FAILED( hr ) )
        return hr;

    // Now fill the buffer, 1 8-bit sample at a time
    for( DWORD i = 0; i < dwBytes; i++ )
    {
        // Convert sample offset to radians
        dArg = (double)i / wfx.nSamplesPerSec * D3DX_PI * 2;

        // Calculate the sin
        dSinVal = sin( dFrequency * dArg );

        // Scale to sample format
        bVal = BYTE( dSinVal * 127 );

        // Store the sample
        pData[i] = bVal;
    }

    // return the buffer
    *ppBuffer = pBuffer;

    return hr;
}


//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"AudioBenchmark" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        WCHAR sz[100];
        swprintf( sz, L"%d buffers (%splaying)", NUM_3D_BUFFERS, m_bPlaying ? L"" : L"NOT " );
        m_Font.DrawText(  64, 80, 0xffffffff, sz );
#if 0
        for( int n = 0; n < NUM_TESTS; n++ )
        {
            swprintf( sz, L"%s: %0.3fms", g_aTests[n].szDescription, g_aTests[n].fTime );
            m_Font.DrawText(  64, 110.0f + 30 * n, 0xffffffff, sz );
        }
#endif // 0
        swprintf( sz, L"Test %d: %s\nTime: %0.3fms", m_dwTest, g_aTests[m_dwTest].szDescription, g_aTests[m_dwTest].fTime );
        m_Font.DrawText( 64, 110, 0xffffffff, sz );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++[ Test routines ]++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++





//-----------------------------------------------------------------------------
// Name: SetCurrentPosition
// Desc: Resets position of all buffers.
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::SetCurrentPosition()
{
    BEFORETEST( AB_SETCURRENTPOSITION );
    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        FLUSH_PIO();
        m_apBuffers[n]->SetCurrentPosition(0);
    }
    AFTERTEST( AB_SETCURRENTPOSITION );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: PlayAll
// Desc: Plays all buffers.
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::PlayAll()
{
    BEFORETEST( AB_PLAY );
    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        FLUSH_PIO();
        m_apBuffers[n]->Play( 0, 0, DSBPLAY_LOOPING );
    }
    AFTERTEST( AB_PLAY );

    m_bPlaying = TRUE;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: StopAll
// Desc: Stops all buffers
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::StopAll()
{
    BEFORETEST( AB_STOP );
    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        FLUSH_PIO();
        m_apBuffers[n]->Stop();
    }
    AFTERTEST( AB_STOP );

    m_bPlaying = FALSE;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitializeBuffers
// Desc: Times release of buffers if non-NULL, and creates new ones.
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::InitializeBuffers()
{
    BEFORETEST( AB_RELEASE );
    for( int i = 0; i < NUM_3D_BUFFERS; i++ )
    {
        if( m_apBuffers[i] )
        {
            FLUSH_PIO();
            m_apBuffers[i]->Release();
        }
    }
    AFTERTEST( AB_RELEASE );

    for( int i = 0; i < NUM_3D_BUFFERS; i++ )
    {
        CreateSineWaveBuffer( 16000 / ( i + 1 ), &m_apBuffers[i] );
    }

    m_pDSound->SetPosition( 0.0f, 0.0f, 0.0f, DS3D_IMMEDIATE );
    m_pDSound->SetVelocity( 0.0f, 0.0f, 0.0f, DS3D_IMMEDIATE );

    m_bPlaying = FALSE;

    return S_OK;
}
    


//-----------------------------------------------------------------------------
// Name: PositionAllImmediate
// Desc: Positions all buffers with DS3D_IMMEDIATE
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::PositionAllImmediate()
{
    D3DXVECTOR3 v[NUM_3D_BUFFERS];

    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        v[n].x = FLOAT( sin( n ) );
        v[n].y = FLOAT( cos( n ) );
        v[n].z = FLOAT( sin( n ) * cos( n ) );
    }

    BEFORETEST( AB_POSITIONSOURCE );
    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        FLUSH_PIO();
        m_apBuffers[n]->SetPosition( v[n].x, v[n].y, v[n].z, DS3D_IMMEDIATE );
    }
    AFTERTEST( AB_POSITIONSOURCE );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: VelocityAllImmediate
// Desc: Sets velocity of all buffers with DS3D_IMMEDIATE
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::VelocityAllImmediate()
{
    D3DXVECTOR3 v[NUM_3D_BUFFERS];

    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        v[n].x = FLOAT( sin( n ) );
        v[n].y = FLOAT( cos( n ) );
        v[n].z = FLOAT( sin( n ) * cos( n ) );
    }

    BEFORETEST( AB_VELOCITYSOURCE );
    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        FLUSH_PIO();
        m_apBuffers[n]->SetVelocity( v[n].x, v[n].y, v[n].z, DS3D_IMMEDIATE );
    }
    AFTERTEST( AB_VELOCITYSOURCE );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: PositionListenerImmediate
// Desc: Positions the listener with DS3D_IMMEDIATE
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::PositionListenerImmediate()
{
    BEFORETEST( AB_POSITIONLISTENER );
    FLUSH_PIO();
    m_pDSound->SetPosition( 1.0f, 2.0f, 3.0f, DS3D_IMMEDIATE );
    AFTERTEST( AB_POSITIONLISTENER );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: VelocityListenerImmediate
// Desc: Sets the velocity of the listener with DS3D_IMMEDIATE
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::VelocityListenerImmediate()
{
    BEFORETEST( AB_VELOCITYLISTENER );
    FLUSH_PIO();
    m_pDSound->SetVelocity( 3.0f, 2.0f, 1.0f, DS3D_IMMEDIATE );
    AFTERTEST( AB_VELOCITYLISTENER );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: PositionAll
// Desc: Positions all the buffers with DS3D_DEFERRED
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::PositionAll()
{
    D3DXVECTOR3 v[NUM_3D_BUFFERS];

    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        v[n].x = FLOAT( sin( n ) );
        v[n].y = FLOAT( cos( n ) );
        v[n].z = FLOAT( sin( n ) * cos( n ) );
    }

    BEFORETEST( AB_POSITIONSOURCE_DEFERRED );
    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        FLUSH_PIO();
        m_apBuffers[n]->SetPosition( v[n].x, v[n].y, v[n].z, DS3D_DEFERRED );
    }
    AFTERTEST( AB_POSITIONSOURCE_DEFERRED );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: VelocityAll
// Desc: Sets the velocity of all buffers with DS3D_DEFERRED
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::VelocityAll()
{
    D3DXVECTOR3 v[NUM_3D_BUFFERS];

    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        v[n].x = FLOAT( sin( n ) );
        v[n].y = FLOAT( cos( n ) );
        v[n].z = FLOAT( sin( n ) * cos( n ) );
    }

    BEFORETEST( AB_VELOCITYSOURCE_DEFERRED );
    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        FLUSH_PIO();
        m_apBuffers[n]->SetVelocity( v[n].x, v[n].y, v[n].z, DS3D_DEFERRED );
    }
    AFTERTEST( AB_VELOCITYSOURCE_DEFERRED );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: PositionListener
// Desc: Positions the listener with DS3D_DEFERRED
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::PositionListener()
{
    BEFORETEST( AB_POSITIONLISTENER_DEFERRED );
    FLUSH_PIO();
    m_pDSound->SetPosition( 1.0f, 2.0f, 3.0f, DS3D_DEFERRED );
    AFTERTEST( AB_POSITIONLISTENER_DEFERRED );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: VelocityListener
// Desc: Set the velocity of the listener with DS3D_DEFERRED
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::VelocityListener()
{
    BEFORETEST( AB_VELOCITYLISTENER_DEFERRED );
    FLUSH_PIO();
    m_pDSound->SetVelocity( 3.0f, 2.0f, 1.0f, DS3D_DEFERRED );
    AFTERTEST( AB_VELOCITYLISTENER_DEFERRED );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Commit3D
// Desc: Commits deferred 3d calculations
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Commit3D()
{
    BEFORETEST( AB_COMMIT3D );
    FLUSH_PIO();
    m_pDSound->CommitDeferredSettings();
    AFTERTEST( AB_COMMIT3D );

    return S_OK;
}




HRESULT
CXBoxSample::SetFrequency()
{
    DWORD dw[NUM_3D_BUFFERS];

    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        dw[n] = DSBFREQUENCY_MIN + n * ( DSBFREQUENCY_MAX - DSBFREQUENCY_MIN ) / NUM_3D_BUFFERS;
    }

    BEFORETEST( AB_FREQUENCY );
    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        FLUSH_PIO();
        m_apBuffers[n]->SetFrequency( dw[n] );
    }
    AFTERTEST( AB_FREQUENCY );

    return S_OK;
}




HRESULT
CXBoxSample::SetVolume()
{
    LONG l[NUM_3D_BUFFERS];

    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        l[n] = DSBVOLUME_MIN + n * ( DSBVOLUME_MAX - DSBVOLUME_MIN ) / NUM_3D_BUFFERS;
    }

    BEFORETEST( AB_VOLUME );
    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        FLUSH_PIO();
        m_apBuffers[n]->SetVolume( l[n] );
    }
    AFTERTEST( AB_VOLUME );

    return S_OK;
}



HRESULT
CXBoxSample::SetPitch()
{
    LONG l[NUM_3D_BUFFERS];

    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        l[n] = DSBPITCH_MIN + n * ( DSBPITCH_MAX - DSBPITCH_MIN ) / NUM_3D_BUFFERS;
    }

    BEFORETEST( AB_PITCH );
    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        FLUSH_PIO();
        m_apBuffers[n]->SetPitch( l[n] );
    }
    AFTERTEST( AB_PITCH );

    return S_OK;
}


HRESULT
CXBoxSample::SetEG()
{
    DSENVELOPEDESC dsed[NUM_3D_BUFFERS];

    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        ZeroMemory( &dsed[n], sizeof( DSENVELOPEDESC ) );
        dsed[n].dwEG = DSEG_AMPLITUDE;
        dsed[n].dwSustain = n;
    }

    BEFORETEST( AB_ENVELOPE );
    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        FLUSH_PIO();
        m_apBuffers[n]->SetEG( &dsed[n] );
    }
    AFTERTEST( AB_ENVELOPE );

    return S_OK;
}


HRESULT
CXBoxSample::SetFilter()
{
    DSFILTERDESC dsfd[NUM_3D_BUFFERS];

    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        dsfd[n].dwMode = DSFILTER_MODE_DLS2;
        dsfd[n].adwCoefficients[0] = 0xF800;
        dsfd[n].adwCoefficients[1] = 0x8800;
        dsfd[n].adwCoefficients[2] = 0;
        dsfd[n].adwCoefficients[3] = 0;
        dsfd[n].dwQCoefficient = 0;
    }

    BEFORETEST( AB_SETFILTER );
    for( int n = 0; n < NUM_3D_BUFFERS; n++ )
    {
        FLUSH_PIO();
        m_apBuffers[n]->SetFilter( &dsfd[n] );
    }
    AFTERTEST( AB_SETFILTER );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\BeginEnd\BeginEnd.cpp ===
//-----------------------------------------------------------------------------
// File: BeginEnd.cpp
//
// Desc: [TODO: Describe source file here]
//
// Hist: 8.27.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
};

#define NUM_HELP_CALLOUTS 1

typedef struct {
    D3DXVECTOR3 p;
    D3DCOLOR c;
} CUSTOMVERTEX;
#define FVF_CUSTOMVERTEX ( D3DFVF_XYZ | D3DFVF_DIFFUSE )


typedef enum {
    LOCK_VB,
    NOLOCK_VB,
    DRAW_UP,
    BEGINEND,
    BEGINPUSH,

    MODE_MAX
} MODE;

WCHAR * g_szLabels[] = {
    L"Lock + Update VertexBuffer",
    L"Update VertexBuffer (No lock)",
    L"DrawPrimitiveUP",
    L"Begin/End + SetVertexData",
    L"BeginPush/EndPush",
};

#define AVERAGE_OVER 500

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    void UpdateVertexBuffer();
    void UpdateNoLock();
    void UpdateUserPrim();
    void SpewVertices();
    void BeginPushEndPush();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    BOOL        m_bDrawHelp;
    DWORD       m_dwVertices;
    MODE        m_Mode;

    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    CUSTOMVERTEX * m_pUP;
    FLOAT       m_fMSecsPerTick;
    FLOAT       m_fTime;

    DWORD       m_dwCount;
    FLOAT       m_fTimeSum;
    FLOAT       m_fAverage;

};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_dwCount = 0;
    m_fTimeSum = 0.0f;
    m_fAverage = 0.0f;
    IDirect3D8::SetPushBufferSize( 1024 * 1024 * 10, 1024 * 1024 * 1 );
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;    

    m_Mode = LOCK_VB;
    m_dwVertices = 10;

    m_pd3dDevice->CreateVertexBuffer( m_dwVertices * sizeof( CUSTOMVERTEX ), 0, 0, 0, &m_pVB );
    m_pUP = new CUSTOMVERTEX[ m_dwVertices ];

    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    D3DXMATRIX matView;  
    D3DXVECTOR3 vPos = D3DXVECTOR3( 0.0f, 0.0f, -5.0f );
    D3DXVECTOR3 vLookAt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMatrixLookAtLH( &matView, &vPos, &vLookAt, &vUp );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI / 4.0f, 4.0f / 3.0f, 1.0f, 1000.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    LARGE_INTEGER liFreq;
    QueryPerformanceFrequency( &liFreq );
    m_fMSecsPerTick = 1000.0f / liFreq.QuadPart;

    return S_OK;
}


void
CXBoxSample::UpdateVertexBuffer()
{
    CUSTOMVERTEX * pVerts;
    LARGE_INTEGER liBefore, liAfter;

    QueryPerformanceCounter( &liBefore );

    m_pVB->Lock( 0, 0, (BYTE **)&pVerts, 0 );
    for( DWORD i = 0; i < m_dwVertices; i++ )
    {
        pVerts[i].p.x = (float)cos( D3DX_PI * 2.0f * i / m_dwVertices );
        pVerts[i].p.y = (float)sin( D3DX_PI * 2.0f * i / m_dwVertices );
        pVerts[i].p.z = 1.0f;

        pVerts[i].c = 0xFFFF0000;
    }

    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof( CUSTOMVERTEX ) );
    m_pd3dDevice->DrawVertices( D3DPT_TRIANGLEFAN, 0, m_dwVertices );

    QueryPerformanceCounter( &liAfter );
    m_fTime = m_fMSecsPerTick * ( liAfter.QuadPart - liBefore.QuadPart );
}


void
CXBoxSample::UpdateNoLock()
{
    CUSTOMVERTEX * pVerts;
    LARGE_INTEGER liBefore, liAfter;

    m_pVB->Lock( 0, 0, (BYTE **)&pVerts, 0 );

    QueryPerformanceCounter( &liBefore );

    for( DWORD i = 0; i < m_dwVertices; i++ )
    {
        pVerts[i].p.x = (float)cos( D3DX_PI * 2.0f * i / m_dwVertices );
        pVerts[i].p.y = (float)sin( D3DX_PI * 2.0f * i / m_dwVertices );
        pVerts[i].p.z = 1.0f;

        pVerts[i].c = 0xFFFFFF00;
    }

    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof( CUSTOMVERTEX ) );
    m_pd3dDevice->DrawVertices( D3DPT_TRIANGLEFAN, 0, m_dwVertices );

    QueryPerformanceCounter( &liAfter );
    m_fTime = m_fMSecsPerTick * ( liAfter.QuadPart - liBefore.QuadPart );
}

void
CXBoxSample::UpdateUserPrim()
{
    LARGE_INTEGER liBefore, liAfter;

    QueryPerformanceCounter( &liBefore );

    for( DWORD i = 0; i < m_dwVertices; i++ )
    {
        m_pUP[i].p.x = (float)cos( D3DX_PI * 2.0f * i / m_dwVertices );
        m_pUP[i].p.y = (float)sin( D3DX_PI * 2.0f * i / m_dwVertices );
        m_pUP[i].p.z = 1.0f;

        m_pUP[i].c = 0xFF00FF00;
    }
    
    m_pd3dDevice->DrawVerticesUP( D3DPT_TRIANGLEFAN, m_dwVertices, m_pUP, sizeof( CUSTOMVERTEX ) );

    QueryPerformanceCounter( &liAfter );
    m_fTime = m_fMSecsPerTick * ( liAfter.QuadPart - liBefore.QuadPart );
}


void
CXBoxSample::SpewVertices()
{
    LARGE_INTEGER liBefore, liAfter;

    QueryPerformanceCounter( &liBefore );

    m_pd3dDevice->Begin( D3DPT_TRIANGLEFAN );

    for( DWORD i = 0; i < m_dwVertices; i++ )
    {
        m_pd3dDevice->SetVertexDataColor( D3DVSDE_DIFFUSE, 0xFF0000FF );
        m_pd3dDevice->SetVertexData4f( D3DVSDE_POSITION, (float)cos( D3DX_PI * 2.0f * i / m_dwVertices ), (float)sin( D3DX_PI * 2.0f * i / m_dwVertices ), 1.0f, 1.0f );
    }

    m_pd3dDevice->End();

    QueryPerformanceCounter( &liAfter );
    m_fTime = m_fMSecsPerTick * ( liAfter.QuadPart - liBefore.QuadPart );
}



void
CXBoxSample::BeginPushEndPush()
{
    DWORD dwBytes = m_dwVertices * ( 3 * sizeof( FLOAT ) + 1 * sizeof( DWORD ) );
    DWORD* pPush;
    LARGE_INTEGER liBefore, liAfter;

    QueryPerformanceCounter( &liBefore );

    m_pd3dDevice->BeginPush( ( dwBytes + 3 ) / sizeof( DWORD ) + 5, &pPush );
    pPush[ 0 ] = D3DPUSH_ENCODE( D3DPUSH_SET_BEGIN_END, 1 );
    pPush[ 1 ] = D3DPT_TRIANGLEFAN;
    pPush[ 2 ] = D3DPUSH_ENCODE( D3DPUSH_NOINCREMENT_FLAG | D3DPUSH_INLINE_ARRAY, ( dwBytes + 3 ) / sizeof( DWORD ) );
    pPush += 3;

    for( DWORD i = 0; i < m_dwVertices; i++, pPush += 4 )
    {
        register FLOAT f;
        
        ((float *)pPush)[ 0 ] = cos( D3DX_PI * 2.0f * i / m_dwVertices );
        ((float *)pPush)[ 1 ] = sin( D3DX_PI * 2.0f * i / m_dwVertices );
        ((float *)pPush)[ 2 ] = 1.0f;
        pPush[ 3 ] = 0xFFFF00FF;
    }

    pPush[ 0 ] = D3DPUSH_ENCODE( D3DPUSH_SET_BEGIN_END, 1 );
    pPush[ 1 ] = 0;
    pPush += 2;
    m_pd3dDevice->EndPush( pPush );

    QueryPerformanceCounter( &liAfter );
    m_fTime = m_fMSecsPerTick * ( liAfter.QuadPart - liBefore.QuadPart );
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        m_Mode = (MODE)(( m_Mode + 1 ) % MODE_MAX);
    }

    DWORD dwVerticesOld = m_dwVertices;

    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
    {
        m_dwVertices += 1;
    }
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
    {
        if( m_dwVertices > 3 )
            m_dwVertices -= 1;
        else
            m_dwVertices = 3;
    }
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
    {
        m_dwVertices += 100;
    }
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT )
    {
        if( m_dwVertices > 103 )
            m_dwVertices -= 100;
        else
            m_dwVertices = 3;
    }

    if( dwVerticesOld != m_dwVertices )
    {
        m_pVB->Release();
        m_pd3dDevice->CreateVertexBuffer( m_dwVertices * sizeof( CUSTOMVERTEX ), 0, 0, 0, &m_pVB );

        delete[] m_pUP;
        m_pUP = new CUSTOMVERTEX[ m_dwVertices ];
    }

    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_dwCount = 0;
        m_fTimeSum = 0.0f;
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    static bool bOtherStuff = TRUE;

    // Draw a gradient filled background
    if( bOtherStuff )
        RenderGradientBackground( 0xff404040, 0xff404080 );

    static bool bFirst = TRUE;

    if( bFirst || bOtherStuff )
    {
        bFirst = FALSE;

        m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
        m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
    }

    switch( m_Mode )
    {
    case LOCK_VB:
        UpdateVertexBuffer();
        break;
    case NOLOCK_VB:
        UpdateNoLock();
        break;
    case DRAW_UP:
        UpdateUserPrim();
        break;
    case BEGINEND:
        SpewVertices();
        break;
    case BEGINPUSH:
        BeginPushEndPush();
    }

    m_fTimeSum += m_fTime;
    m_dwCount++;
    

    if( bOtherStuff )
    {
        // Show title, frame rate, and help
        if( m_bDrawHelp )
            m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
        else
        {
            m_Font.Begin();
            m_Font.DrawText(  64, 50, 0xffffffff, L"BeginEnd" );
            m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        
            WCHAR sz[100];
            swprintf( sz, L"Mode: %s", g_szLabels[ m_Mode ] );
            m_Font.DrawText( 64, 80, 0xffffffff, sz );

            swprintf( sz, L"Vertices: %d", m_dwVertices );
            m_Font.DrawText( 64, 110, 0xffffffff, sz );

            swprintf( sz, L"Time: %0.4fms", m_fTime );
            m_Font.DrawText( 64, 340, 0xffffffff, sz );
            swprintf( sz, L"Avg: %0.4fms", m_fTimeSum / m_dwCount );
            m_Font.DrawText( 300, 340, 0xffffffff, sz );

            m_Font.End();
        }
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Input\Rumble\Rumble.cpp ===
//-----------------------------------------------------------------------------
// File: Rumble.cpp
//
// Desc: This sample is a demonstration of the rumble capabilities of the Xbox
//       controller.
//
// Hist: 05.30.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include <XBApp.h>
#include <XBInput.h>
#include <XBFont.h>
#include <XBUtil.h>




//-----------------------------------------------------------------------------
// Structures and Macros
//-----------------------------------------------------------------------------
struct SCREENVERTEX
{
    D3DXVECTOR4 pos;   // The transformed position for the vertex point.
    DWORD       color; // The vertex color. 
};
#define D3DFVF_SCREENVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)

enum State
{
   TEST,
   DEMO,
};

// Some colors
#define SEMITRANS_BLACK     0x40000000
#define COLOUR_BLACK        0xff000000
#define COLOUR_WHITE        0xffffffff
#define COLOUR_YELLOW       0xffffff00
#define COLOUR_RED          0xffff0000
#define COLOUR_DARK_RED     0xff500000
#define COLOUR_GREY         0xff404040
#define COLOUR_LIGHT_BLUE   0xff6060ff


#define NUM_SAMPLES 400
#define CHART_LEFT   ((640.0f-NUM_SAMPLES)/2)
#define CHART_RIGHT  (640.0f-CHART_LEFT)
#define CHART_TOP1     130.0f
#define CHART_BOTTOM1  270.0f
#define CHART_TOP2     290.0f
#define CHART_BOTTOM2  430.0f



//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Fonts
    CXBFont    m_Font16;
    CXBFont    m_Font12;

    // Current display states
    enum State m_eCurrentState;


    // Rumble variables
    FLOAT      m_fLeftMotorSpeed;
    FLOAT      m_fRightMotorSpeed;
    BOOL       m_bPlayWave;
    WORD       m_wLeftPattern;
    WORD       m_wRightPattern;
    INT        m_iRightMotor[NUM_SAMPLES];
    INT        m_iLeftMotor[NUM_SAMPLES];
    WORD       m_wCurrentPos;

    // Member variables
    VOID    DrawTest();
    VOID    DrawDemo();
    VOID    DrawChart();
    VOID    DrawMotorGraph();
    VOID    SetMotorGraph();
    VOID    DrawLine( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, 
                            DWORD dwColor );
    VOID    DrawRect( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, 
                            DWORD dwStartColor, DWORD dwEndColor );
    VOID    DrawRectOutline( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, 
                                   DWORD dwColor );
    INT     RandomNum( INT low, INT high );

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_eCurrentState  = TEST;

    m_fLeftMotorSpeed  = 0.0f;
    m_fRightMotorSpeed = 0.0f;
    m_bPlayWave        = FALSE;
    m_wCurrentPos      = 0;
    m_wLeftPattern     = 1;
    m_wRightPattern    = 1;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create fonts
    if( FAILED( m_Font16.Create( g_pd3dDevice, "Font16.xpr" ) ) )
        return E_FAIL;
    if( FAILED( m_Font12.Create( g_pd3dDevice, "Font12.xpr" ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        if( m_eCurrentState == TEST )
            m_eCurrentState = DEMO;
        else
            m_eCurrentState = TEST;

        m_fLeftMotorSpeed  = 0.0f;
        m_fRightMotorSpeed = 0.0f;
        m_bPlayWave        = FALSE;
        m_wCurrentPos      = 0;
        SetMotorGraph();
    }

    switch( m_eCurrentState )
    {
        case TEST:
            // Set rumble motors based on left and right trigger controls
            m_fLeftMotorSpeed  = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER]/255.0f;
            m_fRightMotorSpeed = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER]/255.0f;

            break;

        case DEMO:
            if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
            {
                m_bPlayWave = !m_bPlayWave;
                
                m_fLeftMotorSpeed  = 0.0f;
                m_fRightMotorSpeed = 0.0f;
                m_wCurrentPos      = 0;
            }

            if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
            {
                m_bPlayWave        = FALSE;
                m_fLeftMotorSpeed  = 0.0f;
                m_fRightMotorSpeed = 0.0f;
                m_wCurrentPos      = 0;
                if( ++m_wLeftPattern > 7 )
                    m_wLeftPattern = 1;

                SetMotorGraph();
            }

            if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
            {
                m_bPlayWave        = FALSE;
                m_fLeftMotorSpeed  = 0.0f;
                m_fRightMotorSpeed = 0.0f;
                m_wCurrentPos      = 0;
                if( ++m_wRightPattern > 7 )
                    m_wRightPattern = 1;

                SetMotorGraph();
            }

            if( m_bPlayWave )
            {
                m_fLeftMotorSpeed  = m_iLeftMotor[m_wCurrentPos]/100.0f;
                m_fRightMotorSpeed = m_iRightMotor[m_wCurrentPos]/100.0f;
                if( ++m_wCurrentPos >= NUM_SAMPLES )
                    m_wCurrentPos = 0;
            }

            break;
    }

    // Set the rumble motors.
    for( DWORD i=0; i<4; i++ )
    {
        if( m_Gamepad[i].hDevice )
        {
            // Check to see if we are still transferring current motor value
            if( m_Gamepad[i].Feedback.Header.dwStatus != ERROR_IO_PENDING )
            {
                // We can alter the motor values
                m_Gamepad[i].Feedback.Rumble.wLeftMotorSpeed  = WORD( m_fLeftMotorSpeed  * 65535.0f );
                m_Gamepad[i].Feedback.Rumble.wRightMotorSpeed = WORD( m_fRightMotorSpeed * 65535.0f );
                XInputSetState( m_Gamepad[i].hDevice, &m_Gamepad[i].Feedback );
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Depending on the app state, render the scene
    switch( m_eCurrentState )
    {
        case TEST:
            DrawTest();
            break;

        case DEMO:
            DrawDemo();
            break;
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawTest()
// Desc: Overall rendering of the test screen
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawTest()
{
    WCHAR strBuffer[20];

    // Draw a rectangle and a semitrans poly to put the text in
    DrawRect( 64, 50, 576, 112, SEMITRANS_BLACK, SEMITRANS_BLACK );
    DrawRectOutline( 64, 50, 576, 112, COLOUR_BLACK );

    // Draw the left motor value
    DrawRect( 220.0f-20.0f, 350.0f - 2*(WORD)(100*m_fLeftMotorSpeed), 
              220.0f+20.0f, 350.0f, COLOUR_RED, COLOUR_DARK_RED );
    DrawRectOutline( 220.0f-20.0f, 150.0f, 
                     220.0f+20.0f, 350.0f, COLOUR_YELLOW );

    // Draw the right motor value
    DrawRect( 420.0f-20.0f, 350.0f - 2*(WORD)(100*m_fRightMotorSpeed),
              420.0f+20.0f, 350.0f, COLOUR_RED, COLOUR_DARK_RED );
    DrawRectOutline( 420.0f-20.0f, 150.0f, 
                     420.0f+20.0f, 350.0f, COLOUR_YELLOW );

    // Draw the text labels
    m_Font16.DrawText(  69,  50, 0xffffff00, L"Rumble" );
    m_Font16.DrawText( 571,  50, 0xffffffff, L"Motor Test Page", XBFONT_RIGHT );
    m_Font12.DrawText(  69,  75, 0xffffffff, L"Use left and right triggers to alter the rumble motors' speeds.\n"
                                             L"Press START to go to the Waveform Playback Page." );
    swprintf( strBuffer, L"Left : %d%%", (WORD)(100*m_fLeftMotorSpeed) );
    m_Font16.DrawText( 220.0f, 360.0f, 0xffffff00, strBuffer, XBFONT_CENTER_X );
    swprintf( strBuffer, L"Right : %d%%", (WORD)(100*m_fRightMotorSpeed) );
    m_Font16.DrawText( 420.0f, 360.0f, 0xffffff00, strBuffer, XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: DrawDemo()
// Desc: Overall rendering of the demo screen
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawDemo()
{
    // Draw a rectangle and a semitrans poly to put the text in
    DrawRect( 64, 50, 576, 112, SEMITRANS_BLACK, SEMITRANS_BLACK );
    DrawRectOutline( 64, 50, 576, 112, COLOUR_BLACK );

    // Draw the text labels
    m_Font16.DrawText(  69,  50, 0xffffff00, L"Rumble" );
    m_Font16.DrawText( 571,  50, 0xffffff00, L"Waveform Playback Page", XBFONT_RIGHT );
    m_Font12.DrawText(  69,  75, 0xffffffff, L"Press X to start playback, and press A/B to select new waveforms.\n"
                                             L"Press START to go to the Motor Test Page." );

    DrawMotorGraph();
    DrawChart();
}




//-----------------------------------------------------------------------------
// Name: DrawMotorGraph()
// Desc: Displays the waveform and the playback position line
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawMotorGraph()
{
    for( int x = 0; x < NUM_SAMPLES; x++ )
    {
        DrawLine( CHART_LEFT + x*1.0f, CHART_BOTTOM1,
                  CHART_LEFT + x*1.0f, CHART_BOTTOM1 - 1.5f * m_iLeftMotor[x],
                  COLOUR_LIGHT_BLUE );

        DrawLine( CHART_LEFT + x*1.0f, CHART_BOTTOM2,
                  CHART_LEFT + x*1.0f, CHART_BOTTOM2 - 1.5f * m_iRightMotor[x],
                  COLOUR_LIGHT_BLUE);
    }

    // Playback line
    DrawLine( CHART_LEFT + m_wCurrentPos, CHART_TOP1, 
              CHART_LEFT + m_wCurrentPos, CHART_BOTTOM2, 
              D3DCOLOR_RGBA( 0xff, 0xff, 0x00, 0xff ) );
}




//-----------------------------------------------------------------------------
// Name: DrawMotorGraph()
// Desc: Displays text and static graphics for the test screen
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawChart()
{
    // Top and bottom chart
    DrawLine( CHART_LEFT-1, CHART_TOP1,    CHART_LEFT-1,  CHART_BOTTOM1, COLOUR_WHITE );
    DrawLine( CHART_LEFT-1, CHART_BOTTOM1, CHART_RIGHT+1, CHART_BOTTOM1, COLOUR_WHITE );
    DrawLine( CHART_LEFT-1, CHART_TOP2,    CHART_LEFT-1,  CHART_BOTTOM2, COLOUR_WHITE );
    DrawLine( CHART_LEFT-1, CHART_BOTTOM2, CHART_RIGHT+1, CHART_BOTTOM2, COLOUR_WHITE );

    m_Font16.DrawText( CHART_LEFT-5, CHART_TOP1,       0xffffff00, L"100%", XBFONT_RIGHT );
    m_Font16.DrawText( CHART_LEFT-5, CHART_BOTTOM1-25, 0xffffff00,   L"0%", XBFONT_RIGHT );
    m_Font16.DrawText( CHART_LEFT-5, CHART_TOP2,       0xffffff00, L"100%", XBFONT_RIGHT );
    m_Font16.DrawText( CHART_LEFT-5, CHART_BOTTOM2-25, 0xffffff00,   L"0%", XBFONT_RIGHT );
}




//-----------------------------------------------------------------------------
// Name: SetMotorGraph()
// Desc: Switches between MAX_PATTERNS types of waveform for the test screen
//-----------------------------------------------------------------------------
VOID CXBoxSample::SetMotorGraph()
{
    int   ax = 0;
    int   ay = 0;

    for( int x = 0; x < NUM_SAMPLES; x++ )
    {
        FLOAT radians   = (x)/(2*D3DX_PI);
        int   sinewave1 = (INT)(50*(sinf(0.5f*radians)+1));
        int   sinewave2 = (INT)(50*(sinf(0.7f*radians)+1));
        int   sinewave3 = (INT)(sinf(radians) * 50);

        switch( m_wLeftPattern )
        {
            case 1:
                m_iLeftMotor[x]  = ((4*x)%101);
                break;
            case 2:
                m_iLeftMotor[x]  = sinewave1;
                break;
            case 3:
                if( sinewave2 < 30 )
                    m_iLeftMotor[x]   = 0;
                else
                    m_iLeftMotor[x]   = 100;
                break;
            case 4:
                m_iLeftMotor[x] = x/5;
                break;
            case 5:
                m_iLeftMotor[x] = ( (rand() % ( 100 - 0 ) ) + 0 );
                break;
            case 6:
                m_iLeftMotor[x]  = 100-((4*x)%101);
                break;
            case 7:
                m_iLeftMotor[x] = 0;
                break;
        }
        switch( m_wRightPattern )
        {
            case 1:
                m_iRightMotor[x] = ((5*x)%101);
                break;
            case 2:
                m_iRightMotor[x] = sinewave1;
                break;
            case 3:
                if( sinewave2 < 30 )
                    m_iRightMotor[x]  = 0;
                else
                    m_iRightMotor[x]  = 80;
                break;
            case 4:
                m_iRightMotor[x] = x/5;
                break;
            case 5:
                m_iRightMotor[x] = ( (rand() % ( 100 - 0 ) ) + 0 );
                break;
            case 6:
                if( x < NUM_SAMPLES/2 )
                    m_iRightMotor[x] = 0;
                else
                    m_iRightMotor[x] = (ay++)/3;
                break;
            case 7:
                m_iRightMotor[x] = 0;
                break;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: RandomNum()
// Desc: 
//-----------------------------------------------------------------------------
INT CXBoxSample::RandomNum( INT low, INT high )
{
    return( (rand() % ( high - low ) ) + low );
}




//-----------------------------------------------------------------------------
// Name: DrawLine()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawLine( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, 
                            DWORD dwColor )
{
    SCREENVERTEX v[2];
    v[0].pos = D3DXVECTOR4( x1, y1, 0.5f, 1.0f );   v[0].color = dwColor;
    v[1].pos = D3DXVECTOR4( x2, y2, 0.5f, 1.0f );   v[1].color = dwColor;
    
    // Render the line
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

    m_pd3dDevice->SetVertexShader( D3DFVF_SCREENVERTEX) ;
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, v, sizeof(SCREENVERTEX) );
}




//-----------------------------------------------------------------------------
// Name: DrawRectOutline()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawRectOutline( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, 
                                   DWORD dwColor )
{
    DrawLine( x1, y1, x1, y2, dwColor );
    DrawLine( x1, y1, x2, y1, dwColor );
    DrawLine( x2, y1, x2, y2, dwColor );
    DrawLine( x1, y2, x2, y2, dwColor );
}




//-----------------------------------------------------------------------------
// Name: DrawRect()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawRect( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2, 
                            DWORD dwStartColor, DWORD dwEndColor )
{
    SCREENVERTEX v[4];
    v[0].pos = D3DXVECTOR4( x1-0.5f, y1-0.5f, 1.0f, 1.0f );  v[0].color = dwStartColor;
    v[1].pos = D3DXVECTOR4( x2-0.5f, y1-0.5f, 1.0f, 1.0f );  v[1].color = dwStartColor;
    v[2].pos = D3DXVECTOR4( x1-0.5f, y2-0.5f, 1.0f, 1.0f );  v[2].color = dwEndColor;
    v[3].pos = D3DXVECTOR4( x2-0.5f, y2-0.5f, 1.0f, 1.0f );  v[3].color = dwEndColor;
    
    // Render the rectangle
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

    m_pd3dDevice->SetVertexShader( D3DFVF_SCREENVERTEX );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(SCREENVERTEX) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\Face\face.h ===
//-----------------------------------------------------------------------------
// File: face.h
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __FACE_H
#define __FACE_H

#include "xobj.h"

// face animation class
class CFaceAni
{
public:
	char *name;
	DWORD m_dwNumFrames;			// # of frames 
	DWORD m_dwNumControls;			// # of control points
	D3DXVECTOR3 *m_vecOffsets;		// frame offsets
	float *m_fJawFrames;			// jaw animation info

	CFaceAni();
	~CFaceAni();

	DWORD LoadAni(char *anifname, char *jawfname);
	DWORD LoadJaw(char *fname);
};

// control weight structure
struct _cweights
{
	DWORD cidx;						// control index
	float weight;					// weight
};

struct _cwptrs
{
	struct _cweights *ptr;			// pointer into control weight array
	DWORD cnt;						// number of weights for this vertex
};

// eyelid weights
struct _seyewt
{
	DWORD flags;
	DWORD vidx;
	float weight;
};

// face class
class CFace
{
public:
	CXObject m_objFace;				// face object

	float m_fBlink;					// blink rotation
	CXObject m_objREye;				// right eye object
	D3DXMATRIX m_matREye;
	CXObject m_objLEye;				// left eye object
	D3DXMATRIX m_matLEye;
	LPDIRECT3DTEXTURE8 m_pEyeRef;	// eye reflection texture

	D3DXMATRIX m_matUTeeth;
	CXObject m_objUTeeth;			// upper teeth
	D3DXMATRIX m_matLTeeth;			// lower mouth position/orientation
	D3DXMATRIX m_matLTeethAni;		// lower mouth animation matrix
	CXObject m_objLTeeth;			// lower teeth

	D3DXVECTOR3 *m_vecVerts;			// vertices for deformation

	// weight info
	_cwptrs *m_pWPtrs;				// array of pointers into weights array
	_cweights *m_pWeights;			// list of all weights for every vertex
	DWORD m_dwNEyeWt;				// # of blink vertices
	_seyewt *m_EyeWt;				// eyelid blink weights

	// animations
	CFaceAni *m_Ani;				// current playing animation

	CFace();
	~CFace();

	HRESULT Load(char *fname, char *wfname);
	HRESULT LoadWeights(char *wfname);
	void PlayAni(char *name);
	void Deform(D3DXVECTOR3 *off);
	void Render();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\Face\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\Face\face.cpp ===
//-----------------------------------------------------------------------------
// File: face.cpp
//
// Desc: routines for loading and displaying facial animations
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <assert.h>
#include "xbapp.h"
#include "xpath.h"
#include "xparse.h"
#include "face.h"
#include "main.h"

void getmatrix(D3DMATRIX *m, int startidx);		// gets matrix info from text file

// stuff to get eye weights from .m file
// this is a callback function from CXModel->Read_M
int neyewts;
struct _seyewt *feyewts;
void mfunc(int cmd, int ip, float fp);


//-----------------------------------------------------------------------------
// Constructor and destructor
//-----------------------------------------------------------------------------
CFace::CFace()
{
	memset(this, 0, sizeof(CFace));
}

CFace::~CFace()
{
	delete m_EyeWt;
	delete m_vecVerts;
	m_pEyeRef->Release();
}

//-----------------------------------------------------------------------------
// Name: Load
// Desc: Main function to load facial animation using a command file. 
//       The format for the command file is:
//       modelfname imgfname                - model and image
//       weightfname                        - model control point weights
//       eyemodel eyeimage eye3x3 eyetrans  - eye model and image
//                                          - 3x3 orientation matrix
//                                          - eye translation
//       eyereflection                      - eye reflection image
//       upteeth ut3x3 uttrans              - upper teeth model, matrix, & translation
//       lowteeth lt3x3 lttrans             - lower teeth model, matrix, & translation
//-----------------------------------------------------------------------------
HRESULT CFace::Load(char *fname, char *wfname)
{
	FILE *fp;
	char buf[255];
	byte *bptr;
	CXModel *xm;
	D3DXMATRIX m;

	// open the command file
	fp = fopen(fname, "rt");
	if(!fp)
        return E_FAIL;
	
	// face mesh
	fgets(buf, 80, fp);
	Parse(buf, NULL);

	// init eyelid weight memory
	neyewts = 0;
	feyewts = new _seyewt[10000];
	memset(feyewts, 0, 10000*sizeof(_seyewt));

	// do the load
	m_objFace.m_Model = new CXModel;
	xm = m_objFace.m_Model;
	xm->Read_M(_FNA(tokens[0].str), tokens[1].str, FVF_XYZNORMTEX1, 0, mfunc);

	// copy the eyelid weight info
	m_EyeWt = new _seyewt[neyewts];
	memcpy(m_EyeWt, feyewts, neyewts*sizeof(struct _seyewt));
	m_dwNEyeWt = neyewts;
	delete feyewts;

	// get vertices for deformation
	m_vecVerts = new D3DXVECTOR3[xm->m_dwNumVertices];
	xm->LockVB(&bptr, 0L);
	FVF_GetVert(bptr, m_vecVerts, 0, xm->m_dwNumVertices, xm->m_dwFVF);
	xm->UnlockVB();

	// load control point weights
	fgets(buf, 255, fp);			
	Parse(buf, NULL);
	if(LoadWeights(_FNA(tokens[0].str))<0)
	{
		fclose(fp);
		return E_FAIL;
	}

	// right eye
	fgets(buf, 255, fp);			
	Parse(buf, NULL);

	// get the eye matrix and position the eye object
	getmatrix(&m_matREye, 2);
	D3DXMatrixRotationY(&m, D3DX_PI);
	D3DXMatrixMultiply(&m_matREye, &m, &m_matREye);
	m_objREye.m_Model = new CXModel;
	xm = m_objREye.m_Model;
	xm->Sphere(0.0142f, 16, 16, FVF_XYZNORMTEX1, tokens[1].str, 1.0f);

	// left eye
	fgets(buf, 255, fp);			
	Parse(buf, NULL);

	// get the eye matrix and position the eye object
	getmatrix(&m_matLEye, 2);
	D3DXMatrixRotationY(&m, D3DX_PI);
	D3DXMatrixMultiply(&m_matLEye, &m, &m_matLEye);
	m_objLEye.m_Model = new CXModel;
	xm = m_objLEye.m_Model;
	xm->Sphere(0.0142f, 16, 16, FVF_XYZNORMTEX1, tokens[1].str, 1.0f);

	// eye reflection map
	fgets(buf, 255, fp);			
	Parse(buf, NULL);
	XBUtil_CreateTexture(g_pd3dDevice, _FNA(tokens[0].str), &m_pEyeRef);

	// upper teeth
	fgets(buf, 255, fp);			
	Parse(buf, NULL);
	getmatrix(&m_matUTeeth, 1);
	m_objUTeeth.m_Model = new CXModel;
	xm = m_objUTeeth.m_Model;
	xm->Read_M(_FNA(tokens[0].str), NULL, FVF_XYZNORMDIFF, 0, NULL);

	// lower teeth
	fgets(buf, 255, fp);			
	Parse(buf, NULL);
	getmatrix(&m_matLTeeth, 1);
	m_objLTeeth.m_Model = new CXModel;
	xm = m_objLTeeth.m_Model;
	xm->Read_M(_FNA(tokens[0].str), NULL, FVF_XYZNORMDIFF, 0, NULL);

	// init lower jaw animation matrix
	D3DXMatrixIdentity(&m_matLTeethAni);

	fclose(fp);

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: LoadWeights
// Desc: Loads control point weights for animation data
//-----------------------------------------------------------------------------
#define MAX_WEIGHTS 100000
HRESULT CFace::LoadWeights(char *wfname)
{
	FILE *fp;
	DWORD vidx, nwt, wdiff;
	DWORD nt, i, j, nvert, wtidx, totnw;
	char buf[512];
	_cweights *wtp;

	fp = fopen(wfname, "rt");
	if(!fp)
        return XBAPPERR_MEDIANOTFOUND;

	// read nverts & verify that it matches face model nverts
	fgets(buf, 512, fp);
	nvert = atoi(buf);
	if((nvert+1)!=m_objFace.m_Model->m_dwNumVertices)
	{
		fclose(fp);
		return E_FAIL;
	}

	// allocate memory for weight pointers
	m_pWPtrs = new _cwptrs[m_objFace.m_Model->m_dwNumVertices];
	memset(m_pWPtrs, 0, m_objFace.m_Model->m_dwNumVertices*sizeof(_cwptrs));

	// allocate temp memory for weights
	wtp = new _cweights[MAX_WEIGHTS];
	wtidx = 0;
	totnw = 0;
	vidx = 1;

	// load the weights
	for(i=1; i<nvert; i++)
	{
		fgets(buf, 512, fp);

		nt = Parse(buf, NULL);
		nwt = atoi(tokens[0].str);			// get # of weights

		// set pointer
		m_pWPtrs[vidx].ptr = &wtp[wtidx];	// pointer
		m_pWPtrs[vidx].cnt = nwt;			// # weights

		// set vertex/weights
		for(j=0; j<nwt; j++)
		{
			fgets(buf, 512, fp);		// read control/weight
			Parse(buf, NULL);

			// add weights
			wtp[wtidx].cidx = atoi(tokens[0].str);
			wtp[wtidx].weight = (float)atof(tokens[1].str);
			wtidx++;
		}

		vidx++;							// bump vertex count
		totnw += nwt;					// count weights
	}

	fclose(fp);

	// allocate memory for the weights
	m_pWeights = new _cweights[totnw];
	memcpy(m_pWeights, wtp, totnw*sizeof(_cweights));

	// adjust pointers because we moved memory
	wdiff = m_pWeights - wtp;
	for(i=0; i<vidx; i++)
		m_pWPtrs[i].ptr += wdiff;

	delete wtp;
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: getmatrix
// Desc: Loads a 4x4 matrix with data from the tokens returned by
//       the parser. 
//-----------------------------------------------------------------------------
void getmatrix(D3DMATRIX *m, int idx)
{
	// orientation matrix
	m->_11 = (float)atof(tokens[idx].str);
	m->_12 = (float)atof(tokens[idx+1].str);
	m->_13 = (float)atof(tokens[idx+2].str);
	m->_14 = 0.0f;
	m->_21 = (float)atof(tokens[idx+3].str);
	m->_22 = (float)atof(tokens[idx+4].str);
	m->_23 = (float)atof(tokens[idx+5].str);
	m->_24 = 0.0f;
	m->_31 = (float)atof(tokens[idx+6].str);
	m->_32 = (float)atof(tokens[idx+7].str);
	m->_33 = (float)atof(tokens[idx+8].str);
	m->_34 = 0.0f;
	m->_41 = (float)atof(tokens[idx+9].str);
	m->_42 = (float)atof(tokens[idx+0xa].str);
	m->_43 = (float)atof(tokens[idx+0xb].str);
	m->_44 = 1.0f;
}

//-----------------------------------------------------------------------------
// Name: mfunc
// Desc: Callback invoked by CXModel::Read_M to fill the feyewts array 
//       with data from the m file.
//-----------------------------------------------------------------------------
void mfunc(int cmd, int ip, float fp)
{
	switch(cmd)
	{
		case MFP_EYEWT:								// got an eye weight
			feyewts[neyewts].flags = ip>>16;		// or in flags
			feyewts[neyewts].vidx = ip&0xffff;		// add it to our array
			feyewts[neyewts].weight = fp;
			neyewts++;
			break;
	}
}

//-----------------------------------------------------------------------------
// Name: Deform
// Desc: Uses the animation data to offset the vertices of the face
//       to perform the animation.
//-----------------------------------------------------------------------------
void CFace::Deform(D3DXVECTOR3 *ctrl)
{
	DWORD i, j;
	BYTE *bptr;
	FVFT_XYZNORMTEX1 *vbuf;
	D3DVECTOR *vert;
	D3DVECTOR off, pt;
	_cwptrs *cwpp;
	_cweights *cwp;
	_seyewt *ew;
	CXModel *xm;

	vert = m_vecVerts;					// original vertices
	xm = m_objFace.m_Model;				// face model
	assert(xm->m_dwFVF==FVF_XYZNORMTEX1);	// make sure we have right type of verts
	xm->LockVB(&bptr, 0);
	vbuf = (FVFT_XYZNORMTEX1 *)bptr;

	// calculate the new vertices
	cwpp = m_pWPtrs;
	for(i=0; i<xm->m_dwNumVertices; i++)
	{
		if(cwpp->cnt!=0)
		{
			off.x = 0.0f;
			off.y = 0.0f;
			off.z = 0.0f;

			cwp = cwpp->ptr;
			for(j=0; j<cwpp->cnt; j++)
			{
				off.x += cwp->weight*ctrl[cwp->cidx].x;
				off.y += cwp->weight*ctrl[cwp->cidx].y;
				off.z += cwp->weight*ctrl[cwp->cidx].z;
				cwp++;
			}

			vbuf[i].v.x = vert[i].x + off.x;
			vbuf[i].v.y = vert[i].y + off.y;
			vbuf[i].v.z = vert[i].z + off.z;
		}
		else
		{
			vbuf[i].v.x = vert[i].x;
			vbuf[i].v.y = vert[i].y;
			vbuf[i].v.z = vert[i].z;
		}

		cwpp++;
	}

	// include eye blinks
	D3DXMATRIX m;
	D3DXVECTOR3 vl, vr;

	// rotation axis for the eyelids
	vl.x = -0.948069f; vl.y = 0.026956f; vl.z = 0.316921f;
	vr.x = 0.962104f; vr.y = 0.030789f; vr.z = 0.270939f;

	ew = m_EyeWt;
	for(i=0; i<m_dwNEyeWt; i++)
	{
		off.x = vbuf[ew[i].vidx].v.x;
		off.y = vbuf[ew[i].vidx].v.y;
		off.z = vbuf[ew[i].vidx].v.z;

		if(ew[i].flags&0x0001)		// left eye
		{
			off.x -= m_matLEye._41;		// subtract out eye position
			off.y -= m_matLEye._42;
			off.z -= m_matLEye._43;

			D3DXMatrixRotationAxis(&m, &vl, -m_fBlink*ew[i].weight);
			D3DXVec3TransformCoord((D3DXVECTOR3 *)&pt, (D3DXVECTOR3 *)&off, &m);

			vbuf[ew[i].vidx].v.x = pt.x + m_matLEye._41;		// add eye position back in
			vbuf[ew[i].vidx].v.y = pt.y + m_matLEye._42;
			vbuf[ew[i].vidx].v.z = pt.z + m_matLEye._43;
		}
		else	// right eye
		{
			off.x -= m_matREye._41;
			off.y -= m_matREye._42;
			off.z -= m_matREye._43;

			D3DXMatrixRotationAxis(&m, &vr, m_fBlink*ew[i].weight);
			D3DXVec3TransformCoord((D3DXVECTOR3 *)&pt, (D3DXVECTOR3 *)&off, &m);

			vbuf[ew[i].vidx].v.x = pt.x + m_matREye._41;		// add eye position back in
			vbuf[ew[i].vidx].v.y = pt.y + m_matREye._42;
			vbuf[ew[i].vidx].v.z = pt.z + m_matREye._43;
		}
	}

	xm->UnlockVB();
}


//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the face.
//-----------------------------------------------------------------------------
void CFace::Render()
{
	D3DXMATRIX *m, m2;
	float *ja;
	static DWORD curframe = 0;
	static DWORD flag = 0;

	// animate the face

	// this is a kludge to have the face do something interesting.
	// normally you would build an animation system instead of just
	// playing a canned animation over and over. 
	Deform(m_Ani->m_vecOffsets + m_Ani->m_dwNumControls*curframe);
	curframe++;
	if(curframe==m_Ani->m_dwNumFrames)
		curframe = 0;

	// do jaw animation
	ja = m_Ani->m_fJawFrames;
	ja += curframe*12;

	m_matLTeethAni._11 = ja[0];
	m_matLTeethAni._12 = ja[1];
	m_matLTeethAni._13 = ja[2];
	m_matLTeethAni._21 = ja[3];
	m_matLTeethAni._22 = ja[4];
	m_matLTeethAni._23 = ja[5];
	m_matLTeethAni._31 = ja[6];
	m_matLTeethAni._32 = ja[7];
	m_matLTeethAni._33 = ja[8];
	m_matLTeethAni._41 = ja[9];
	m_matLTeethAni._42 = ja[10];
	m_matLTeethAni._43 = ja[11];
	m_matLTeethAni._44 = 1.0f;

	// enable specular lighting
	g_pd3dDevice->SetRenderState(D3DRS_SPECULARENABLE, TRUE);

	if(g_bLafActive)				// check for the lafortune shader
	{
		// set the vertex shader constants

		// transpose(world) c[0-3]
		D3DXMATRIX mat;
		m_objFace.CrunchMatrix();
		D3DXMatrixTranspose(&mat, &m_objFace.m_matOrientation);
		g_pd3dDevice->SetVertexShaderConstant(0, &mat, 4);		// world matrix

		// transpose((world*view)*proj) c[4-7]
		D3DXMATRIX wvmat, wvpmat;
		D3DXMatrixMultiply(&wvmat, &m_objFace.m_matOrientation, &g_mView);
		D3DXMatrixMultiply(&wvpmat, &wvmat, &g_mProj);		
		D3DXMatrixTranspose(&wvpmat, &wvpmat);
		g_pd3dDevice->SetVertexShaderConstant(4, &wvpmat, 4);	// transformation matrix

		// eye position c[8]
		g_pd3dDevice->SetVertexShaderConstant(8, &g_vEyePos, 4);

		// light position and color c[9-11]
		g_pd3dDevice->SetVertexShaderConstant(9, &g_Light0.Position, 1);
		g_pd3dDevice->SetVertexShaderConstant(10, &g_Light0.Diffuse, 1);
		g_pd3dDevice->SetVertexShaderConstant(11, &g_Light0.Specular, 1);

		// lafortune constants c[12-14]
		g_pd3dDevice->SetVertexShaderConstant(12, &g_vLafConst, 4);

		// do it
		m_objFace.m_Model->m_dwVShader = g_vsLafortune;
		m_objFace.m_Model->Render();
	}
	else							// use the fixed pipeline
	{
		// set texture stage state for the face
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_DISABLE);

		m_objFace.m_Model->m_dwVShader = m_objFace.m_Model->m_dwFVF;
		m_objFace.Render(0);

	}

	// draw the rest of the face
	m = &m_objFace.m_matOrientation;

	// disable specular
	g_pd3dDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);

	//
	// draw eyes
	//

	// calculate right eye matrix
	D3DXMatrixRotationYawPitchRoll(&m_objREye.m_matOrientation, m_objREye.m_vRotation.y, m_objREye.m_vRotation.x, m_objREye.m_vRotation.z);
	m_objLEye.m_matOrientation = m_objREye.m_matOrientation;
	D3DXMatrixMultiply(&m2, &m_matREye, m);
	D3DXMatrixMultiply(&m_objREye.m_matOrientation, &m_objREye.m_matOrientation, &m2);

	// calculate left eye matrix
	D3DXMatrixMultiply(&m2, &m_matLEye, m);
	D3DXMatrixMultiply(&m_objLEye.m_matOrientation, &m_objLEye.m_matOrientation, &m2);

	// set the texture stages for the eyes and reflections
	// stage 0 is just the eye texture
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

	// stage 1 adds in the eye reflection
    g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_ADD);
	g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);
	g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_TEXTURE);
    g_pd3dDevice->SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	g_pd3dDevice->SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR);
	g_pd3dDevice->SetTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);

	// stage 2 modulates with diffuse for lighting effect
    g_pd3dDevice->SetTextureStageState(2, D3DTSS_COLOROP, D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState(2, D3DTSS_COLORARG1, D3DTA_CURRENT);
	g_pd3dDevice->SetTextureStageState(2, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_pd3dDevice->SetTextureStageState(2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

	// set the stage 1 reflection texture
	// (stage 0 texture is set by the CXModel::Render function)
	g_pd3dDevice->SetTexture(1, m_pEyeRef); 

	// render the eyes using multitexturing
	m_objREye.Render(OBJ_NOMCALCS);
	m_objLEye.Render(OBJ_NOMCALCS);

	// reset the stage 1 texture
	g_pd3dDevice->SetTexture(1, NULL); 

	// disable additional texture stages
    g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
    g_pd3dDevice->SetTextureStageState(2, D3DTSS_COLOROP, D3DTOP_DISABLE);

	// disable reflection map
	g_pd3dDevice->SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_PASSTHRU);
	g_pd3dDevice->SetTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);

	//
	// draw the teeth
	//

	// teeth get diffuse only
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);

	m_objUTeeth.m_Model->m_pTexture = m_pEyeRef;

	// upper teeth	
	D3DXMatrixMultiply(&m_objUTeeth.m_matOrientation, &m_matUTeeth, m);
	m_objUTeeth.Render(OBJ_NOMCALCS);

	// lower teeth
	D3DXMatrixMultiply(&m2, &m_matLTeeth, &m_matLTeethAni);
	D3DXMatrixMultiply(&m_objLTeeth.m_matOrientation, &m2, m);
	m_objLTeeth.Render(OBJ_NOMCALCS);
}


//-----------------------------------------------------------------------------
// facial animation class
// holds the vertex offsets and jaw frames for an animation
//
// Constructor and destructor
//-----------------------------------------------------------------------------
CFaceAni::CFaceAni()
{
	memset(this, 0, sizeof(CFaceAni));
}

CFaceAni::~CFaceAni()
{
	if(m_vecOffsets)
		delete m_vecOffsets;
	if(m_fJawFrames)
		delete m_fJawFrames;
}

//-----------------------------------------------------------------------------
// Name: LoadAni
// Desc: Loads a facial animation data file generated using MSR facial
//       animation capture system.
//-----------------------------------------------------------------------------
DWORD CFaceAni::LoadAni(char *anifname, char *jawfname)
{
	FILE *fp;
	DWORD cnt;

	fp = fopen(anifname, "rb");
	if(!fp)
        return XBAPPERR_MEDIANOTFOUND;

	// read nframes and ncontrol points
	fread(&m_dwNumFrames, sizeof(DWORD), 1, fp);
	fread(&m_dwNumControls, sizeof(DWORD), 1, fp);

	// get memory
	m_vecOffsets = new D3DXVECTOR3[m_dwNumFrames*m_dwNumControls];

	cnt = fread(m_vecOffsets, sizeof(D3DXVECTOR3), m_dwNumFrames*m_dwNumControls, fp);
	assert(cnt==(m_dwNumFrames*m_dwNumControls));
	fclose(fp);

	if(jawfname)
		LoadJaw(jawfname);

	return 1;
}

//-----------------------------------------------------------------------------
// Name: LoadJaw
// Desc: Loads a jaw (mouth) animation data file generated using MSR facial
//       animation capture system.
//-----------------------------------------------------------------------------
DWORD CFaceAni::LoadJaw(char *jawfname)
{
	char buf[255];
	FILE *fp;
	DWORD i, nt, jidx, nframes;

	fp = fopen(jawfname, "rt");
	if(!fp)
        return XBAPPERR_MEDIANOTFOUND;

	// get nframes
	fgets(buf, 255, fp);
	Parse(buf, NULL);
	nframes = atoi(tokens[0].str);

	// verify that nframes matches animation
	if(nframes!=m_dwNumFrames)
	{
		fclose(fp);
		return -1;
	}

	// allocate memory for four sets of 3 floats * nframes
	m_fJawFrames = new float[nframes*12];
	jidx = 0;

	// load the data
	while(!feof(fp))
	{
		fgets(buf, 255, fp);
		if(feof(fp))
			break;

		nt = Parse(buf, NULL);
		
		for(i=2; i<14; i++)
			m_fJawFrames[jidx++] = (float)atof(tokens[i].str);
	}

	fclose(fp);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\Face\main.h ===
#ifndef __MAIN_H
#define __MAIN_H

extern D3DXVECTOR4 g_vEyePos;

extern D3DXMATRIX g_mProj;							
extern D3DXMATRIX g_mView;							

extern D3DLIGHT8 g_Light0;
extern D3DXVECTOR3 g_vLightPos;						

extern DWORD g_vsLafortune;
extern D3DXVECTOR4 g_vLafConst[4];
extern BOOL g_bLafActive;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\Face\xfpatch.h ===
//-----------------------------------------------------------------------------
// File: xfpatch.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __FUZZ_H
#define __FUZZ_H

#ifdef _XBOX
#include <xtl.h>
#else
#include <d3d8.h>
#endif
#include "xfvf.h"
#include "xfpmesh.h"

#define MAX_VLEVEL 16

extern D3DXMATRIX g_matProj;
extern D3DXMATRIX g_matView;
extern D3DXMATRIX g_matWorld;
extern DWORD g_dwFuzzVS;
extern D3DVECTOR g_LightPos;

extern float g_fOneInch;

// patch generation


// a fuzz is a single hair follicle, blade of grass, etc.
struct Fuzz
{
	D3DVECTOR dp;			// velocity
	D3DVECTOR ddp;			// acceleration
};

// a fuzz instance is a single instance of a fuzz
// located at x, z on the patch
// we create only a limited number of unique fuzzes
// and index the library with lidx.
struct FuzzInst
{
	float x, z;				// fuzz location
	int lidx;				// library index
};

// a fuzz patch is a volume that holds fuzzes.
// xsize and zsize are chosen by the user
// ysize is calculated using the height of the 
// tallest fuzz
class CXFPatch
{
public:
	DWORD m_dwSeed;			// patch seed
	
	float m_fXSize;			// patch size in world coords
	float m_fYSize;
	float m_fZSize;

	// fuzz library
	DWORD m_dwNumSegments;	// # of segments in highest LOD
	D3DVECTOR m_vFuzzColor;	// fuzz color

	D3DVECTOR m_vFVelC;		// fuzz velocity constant
	D3DVECTOR m_vFVelR;		// fuzz velocity random
	D3DVECTOR m_vFAccC;		// fuzz acceleration constant
	D3DVECTOR m_vFAccR;		// fuzz acceleration random

	DWORD m_dwNumFuzzLib;	// # of fuzz in the library
	Fuzz *m_pFuzzLib;		// fuzz library

	// fuzz instances
	DWORD m_dwNumFuzz;		// # of fuzz in this patch
	FuzzInst *m_pFuzz;

	// patch volume
	DWORD m_dwNumLayers;	// # of layers in the volume
	DWORD m_dwVolSize;		// width*depth
	DWORD m_dwVolXSize;		// width of volume texture
	DWORD m_dwVolZSize;		// depth of volume texture
	LPDIRECT3DTEXTURE8 m_pVolTexture[MAX_VLEVEL];	// volume texture

	// highest LOD texture
	LPDIRECT3DTEXTURE8 m_pTexture;

	CXFPatch();
	~CXFPatch();

	void InitFuzz(DWORD nfuzz, DWORD nfuzzlib);
	void GenVolume(DWORD nlayers, DWORD volxsize, DWORD volzsize);	
	void Splat(D3DVECTOR p, float falpha, D3DVECTOR fcolor);
	void RenderLines();
	void RenderGeometryTexture(CXFPatchMesh *pmesh);
	void Render(float lod, CXFPatchMesh *pmesh);
	void Save(char *fname, int flags);
	void Load(char *fname);

	void SetPatchSize(float x, float z)
	{
		m_fXSize = x;
		m_fZSize = z;
		InitFuzz(m_dwNumFuzz, m_dwNumFuzzLib);	// re-init the fuzz. automatically sets ysize
	};

	void SetFVel(float cx, float cy, float cz, float rx, float ry, float rz)
	{
		m_vFVelC.x = cx; m_vFVelC.y = cy; m_vFVelC.z = cz;
		m_vFVelR.x = rx; m_vFVelR.y = ry; m_vFVelR.z = rz;
	};

	void SetFAcc(float cx, float cy, float cz, float rx, float ry, float rz)
	{
		m_vFAccC.x = cx; m_vFAccC.y = cy; m_vFAccC.z = cz;
		m_vFAccR.x = rx; m_vFAccR.y = ry; m_vFAccR.z = rz;
	};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\Face\xfpmesh.h ===
//-----------------------------------------------------------------------------
// File: xfpmesh.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __PMESH_H
#define __PMESH_H

#ifdef _XBOX
#include <xtl.h>
#else
#include <d3d8.h>
#endif
#include "xobj.h"

class CXFPatch;
struct TriangleFind;
struct GeometryTexture;

class CXFPatchMesh
{
public:
	CXObject *m_Obj;						// the object we are attached to

	DWORD m_dwNumIndices;					// # of indices
	DWORD m_dwMaxIndices;					// max # of indices
	WORD *m_Indices;						// triangle indices
	float *m_UVs;							// texture samples

	BOOL m_bBuildFlag;						// set to rebuild object
	DWORD m_dwNumVertices;					// current # of vertices in pmesh
	WORD m_wMaxIndex;						// max vertex index in m_pIB
	IDirect3DVertexBuffer8 *m_pVB;			// vertex buffer
    IDirect3DTexture8 *m_pTexture;			// texture
	DWORD m_dwVShader;						// vertex shader

	// mapping info
	D3DVECTOR m_TextureCenter;				// volume texture center
	D3DVECTOR m_TextureSize;				// volume texture size
	DWORD m_dwMapping;						// mapping type (0=planar, 1=cyl, 2=sphere)
	DWORD m_dwAxis;							// mapping axis (0=z, 1=y, 2=x)

	// volume info
	char m_strFPatchName[32];				// name of fpatch used for this mesh

	CXFPatchMesh();
	~CXFPatchMesh();

	DWORD PickTriangle(CXObject *obj, POINT p, DWORD flag, D3DVIEWPORT8 *Viewport, 
						D3DXMATRIX *ProjMatrix, D3DXMATRIX *ViewMatrix, D3DXMATRIX *WorldMatrix);
	void BuildIndexBuffer();
	void Build(int firstflag);
	void Render();

	void Save(char *fname);
	void Load(char *fname);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh\Font.h ===
// Automatically generated by the bundler tool from font.rdf

#define font_NUM_RESOURCES 2UL

#define font_Font_OFFSET 0UL
#define font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\Face\main.cpp ===
//-----------------------------------------------------------------------------
// File: main.cpp
//
// Desc: This is the main file for the facial animation demo.
//       It illustrates using vertex shaders for Lafortune lighting
//       which is a BRDF lighting model, and for the hair found
//       on the goatee (which does normal expansion and directional
//       lighting).
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>

#include "xpath.h"
#include "face.h"
#include "xfpatch.h"
#include "xfpmesh.h"

#define PI 3.14159f
#define TWOPI (PI*2.0f)

// these variables are global because the face
// uses them
D3DXVECTOR4 g_vEyePos;							// eye position
D3DXMATRIX g_mProj;								// projection matrix
D3DXMATRIX g_mView;								// view matrix
D3DLIGHT8 g_Light0;								// d3d8 light

// lafortune shader
DWORD g_vsLafortune;							// lafortune shader
D3DXVECTOR4	g_vLafConst[4];						// lafortune constants
BOOL g_bLafActive=TRUE;							// lafortune active flag

// face stuff
CFace g_Face;
CFaceAni g_FaceAni;
BOOL g_dwLoadPhase = 0;
float g_fLOD = 0.9f;

// hair stuff
CXFPatch g_FPatch;
CXFPatchMesh g_FPatchMesh;
DWORD g_BushVS;

// help screen definitions
XBHELP_CALLOUT g_NormalHelpCallouts[] =
{
    { XBHELP_LEFTSTICK,   XBHELP_PLACEMENT_1, L"Rotate/Zoom the model" },
    { XBHELP_RIGHTSTICK,  XBHELP_PLACEMENT_1, L"Rotate the model\nand light source" },
    { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, L"Display\nhelp" },
    { XBHELP_A_BUTTON,    XBHELP_PLACEMENT_1, L"Blink" },
    { XBHELP_B_BUTTON,    XBHELP_PLACEMENT_1, L"Toggle Lafortune" },
};
#define MAX_NORMAL_HELP_CALLOUTS 5

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont m_Font;
    CXBHelp m_Help;
	BOOL m_bDrawHelp;

	D3DVECTOR m_vViewAngle;
	D3DXVECTOR3	m_vCameraPos;

	D3DXVECTOR3 m_vLightPos;
	float m_fLightAng;
	D3DMATERIAL8 m_Material;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
	HRESULT Cleanup();

    CXBoxSample();
};

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
void __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
	m_bDrawHelp = FALSE;
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create a font
    if(FAILED(hr = m_Font.Create(m_pd3dDevice, "Font.xpr")))
        return XBAPPERR_MEDIANOTFOUND;

	// initialize the help system
    m_Help.Create(m_pd3dDevice, "Gamepad.xpr");

    // Set projection transform
    D3DXMatrixPerspectiveFovLH(&g_mProj, D3DX_PI/4, 640.0f/480.0f, 0.005f, 2.0f);
    m_pd3dDevice->SetTransform(D3DTS_PROJECTION, &g_mProj);

	// create lafortune vertex shader
	DWORD vsdec[] = 
	{
		D3DVSD_STREAM(0),
		D3DVSD_REG(0, D3DVSDT_FLOAT3),		// vertex
		D3DVSD_REG(1, D3DVSDT_FLOAT3),		// normal
		D3DVSD_REG(2, D3DVSDT_FLOAT2),		// texture 0
		D3DVSD_END()
	};
	XBUtil_CreateVertexShader(m_pd3dDevice, _FNA("lafortn.xvu"), vsdec, &g_vsLafortune);
	if(!g_vsLafortune)
		OUTPUT_DEBUG_STRING( "Initialize : error loading lafortn.xvu\n" );

	// init lafortune constants
	g_vLafConst[0].x = -1.016939f;			// Cxy1
	g_vLafConst[0].y = -0.643533f;			// Cxy2
	g_vLafConst[0].z = -1.020153f;			// Cxy3
	g_vLafConst[0].w = 5.0f;				// w1
	g_vLafConst[1].x = -1.462488f;			// Cz1
	g_vLafConst[1].y = 0.410559f;			// Cz2
	g_vLafConst[1].z = 0.703913f;			// Cz3
	g_vLafConst[1].w = 5.0f;				// w2
	g_vLafConst[2].x = 3.699932f;			// n1
	g_vLafConst[2].y = 4.266495f;			// n2
	g_vLafConst[2].z = 63.919687f;			// n3
	g_vLafConst[2].w = 5.0f;				// w3
	g_vLafConst[3] = D3DXVECTOR4(0.0f, 0.0f, 0.0f, 0.0f);

	// load the hair vertex shader
	// uses the same declaration as the lafortune shader
	XBUtil_CreateVertexShader(m_pd3dDevice, _FNA("bush.xvu"), vsdec, &g_BushVS);
	if(!g_BushVS)
		OUTPUT_DEBUG_STRING( "Initialize : error loading bush.xvu\n" );

	// enable lighting
	m_pd3dDevice->SetRenderState(D3DRS_AMBIENT, 0x0);
	m_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);

	// initalize material
	memset(&m_Material, 0, sizeof(D3DMATERIAL8));
	m_Material.Diffuse.r = 1.0f;
	m_Material.Diffuse.g = 1.0f;
	m_Material.Diffuse.b = 1.0f;
	m_Material.Specular.r = 0.25f;
	m_Material.Specular.g = 0.25f;
	m_Material.Specular.b = 0.25f;
	m_Material.Power = 16.0f;
	m_pd3dDevice->SetMaterial(&m_Material);

	// init light position and color
	memset(&g_Light0, 0, sizeof(D3DLIGHT8));
	g_Light0.Type = D3DLIGHT_POINT;
	g_Light0.Position.x = -0.5f;
	g_Light0.Position.y = 0.0f;
	g_Light0.Position.z = -0.5f;
	g_Light0.Diffuse.r = 1.0f;
	g_Light0.Diffuse.g = 1.0f;
	g_Light0.Diffuse.b = 1.0f;
	g_Light0.Specular.r = 1.0f;
	g_Light0.Specular.g = 1.0f;
	g_Light0.Specular.b = 1.0f;
	g_Light0.Range = 1000.0f;
	g_Light0.Attenuation0 = 1.0f;
	g_pd3dDevice->LightEnable(0, TRUE);
	g_pd3dDevice->SetLight(0, &g_Light0);

	// init the rest of the stuff
	m_vCameraPos = D3DXVECTOR3(0.0f, 0.0f, 0.6f);
	m_vLightPos = D3DXVECTOR3(0.0f, 0.1f, -1.0f);
	m_fLightAng = PI;
	m_vViewAngle = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

	// set base path to point to our face data
	// all the _FNA commands use this
	XPath_SetBasePath(_T("d:\\media\\"));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Cleanup()
{
    m_Help.Destroy();
	m_Font.Destroy();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);
	D3DXVECTOR4 lpos;
	D3DXMATRIX m, m2;

	// move the camera around the head and always point
	// right at it
	m_vViewAngle.y -= m_DefaultGamepad.fX1*1.0f*m_fElapsedTime;
	if(m_vViewAngle.y>TWOPI)
		m_vViewAngle.y -= TWOPI;
	if(m_vViewAngle.y<0.0f)
		m_vViewAngle.y += TWOPI;

	m_vViewAngle.x += m_DefaultGamepad.fY2*1.0f*m_fElapsedTime;
	if(m_vViewAngle.x>1.0f)
		m_vViewAngle.x = 1.0f;
	if(m_vViewAngle.x<-1.0f)
		m_vViewAngle.x = -1.0f;

	m_vCameraPos.z -= m_DefaultGamepad.fY1*0.5f*m_fElapsedTime;
	if(m_vCameraPos.z<0.2f)
		m_vCameraPos.z = 0.2f;

	D3DXMatrixRotationYawPitchRoll(&m, m_vViewAngle.y, m_vViewAngle.x, m_vViewAngle.z);
	D3DXVec3Transform(&g_vEyePos, &m_vCameraPos, &m);
	D3DXMatrixLookAtLH(&m2, (D3DXVECTOR3 *)&g_vEyePos, (D3DXVECTOR3 *)&g_Face.m_objFace.m_vPosition, &up);
	D3DXMatrixTranslation(&m, 0.0f, -0.16f, 0.0f);
	D3DXMatrixMultiply(&g_mView, &m2, &m);
	m_pd3dDevice->SetTransform(D3DTS_VIEW, &g_mView);

	// move the light around the face
	m_fLightAng -= m_DefaultGamepad.fX2*1.0f*m_fElapsedTime;
	if(m_fLightAng>TWOPI)
		m_fLightAng -= TWOPI;
	if(m_fLightAng<0.0f)
		m_fLightAng += TWOPI;

	D3DXMatrixRotationY(&m, m_fLightAng);
	D3DXVec3Transform(&lpos, &m_vLightPos, &m);
	g_Light0.Position.x = lpos.x;
	g_Light0.Position.y = lpos.y;
	g_Light0.Position.z = lpos.z;
	m_pd3dDevice->SetLight(0, &g_Light0);

	// set light position for vertex shader
	g_LightPos = g_Light0.Position;

	// blink
	if(m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_A])
		g_Face.m_fBlink = 0.6f;
	else
		g_Face.m_fBlink = 0.0f;

	// toggle help
    if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK)
        m_bDrawHelp = !m_bDrawHelp;

	// toggle lafortune
	if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B])
		g_bLafActive = !g_bLafActive;

	// load the face in chunks so we dont wait several
	// seconds before the app starts up
	switch(g_dwLoadPhase)
	{
		case 0:
			g_dwLoadPhase++;
			break;

		case 1:
			// load the face
			g_Face.Load(_FNA("face1.txt"), NULL);
			g_FaceAni.LoadAni(_FNA("talklo.off"), _FNA("talklo.jaw"));
			g_Face.m_Ani = &g_FaceAni;
			g_dwLoadPhase++;
			break;

		case 2:
			// load hair stuff
			g_FPatchMesh.Load(_FNA("goatee.fpm"));
			g_FPatchMesh.m_Obj = &g_Face.m_objFace;
			g_FPatchMesh.Build(1);
			g_FPatch.Load(_FNA(g_FPatchMesh.m_strFPatchName));
			g_dwLoadPhase++;
			break;
	}

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	D3DXVECTOR4 f;

    // Clear the viewport
    m_pd3dDevice->Clear(0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0, 1.0f, 0L);

	// font code clobbers this state so we reset it here every frame
	m_pd3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
	m_pd3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
	m_pd3dDevice->SetTextureStageState(1, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
	m_pd3dDevice->SetTextureStageState(1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    m_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    m_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
    m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, TRUE);

	// render the face object
	if(g_dwLoadPhase>1)
		g_Face.Render();

	// build the patch mesh and render it
	if(g_dwLoadPhase>2)
	{
		g_FPatchMesh.m_bBuildFlag = 1;
		g_FPatchMesh.Build(0);
		g_matWorld = (D3DXMATRIX)g_Face.m_objFace.m_matOrientation;
		g_matView = g_mView;
		g_matProj = g_mProj;
		g_dwFuzzVS = g_BushVS;
		g_FPatch.Render(g_fLOD, &g_FPatchMesh);
	}

	// Begin text drawing
	m_Font.Begin();

	// show title
    m_Font.DrawText(64, 50, 0xffffffff, L"FACE");
    m_Font.DrawText(640-64, 50, 0xffffff00, m_strFrameRate, XBFONT_RIGHT);

	// show status
	if(g_dwLoadPhase==1)
		m_Font.DrawText(320, 50, 0xffffff00, L"LOADING FACE", XBFONT_CENTER_X);
	else if(g_dwLoadPhase==2)
		m_Font.DrawText(320, 50, 0xffffff00, L"GENERATING HAIR", XBFONT_CENTER_X);

	if(g_bLafActive)
	    m_Font.DrawText(64, 70, 0xff00ff00, L"LAFORTUNE ON");
	else
		m_Font.DrawText(64, 70, 0xffff0000, L"LAFORTUNE OFF");

	// End text drawing
	m_Font.End();

	if(m_bDrawHelp)
		m_Help.Render(&m_Font, g_NormalHelpCallouts, MAX_NORMAL_HELP_CALLOUTS);

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\Face\xfpatch.cpp ===
//-----------------------------------------------------------------------------
// File: xfpatch.cpp
//
// Desc: routines for generating and displaying a 'fuzz' patch.
//       which is a series of layers that give the appearance of
//       hair, fur, grass, or other fuzzy things.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#ifdef _XBOX
#include <xtl.h>
#include <xgraphics.h>
#else
#include <d3d8.h>
#endif
#include "xfpatch.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

#define irand(a) ((rand()*(a))>>15)
#define frand(a) ((float)rand()*(a)/32768.0f)

float g_fOneInch = 0.01f;

D3DXVECTOR4 *g_pVolume;					// used for generating volume
D3DXMATRIX g_matProj;					// current projection matrix
D3DXMATRIX g_matView;					// current view matrix
D3DXMATRIX g_matWorld;					// current world matrix
D3DXMATRIX g_matDisplay;				// current display matrix (View*World*Proj)
D3DVECTOR g_LightPos;					// current light position

DWORD g_dwFuzzVS;						// fuzz vertex shader

//-----------------------------------------------------------------------------
// Name: Constructor
// Desc: 
//-----------------------------------------------------------------------------
CXFPatch::CXFPatch()
{
	DWORD i;

	// init default patch
	m_fXSize = 0.1f;
	m_fZSize = 0.1f;

	// init default fuzzlib
	m_dwNumFuzzLib = 0;
	m_pFuzzLib = NULL;
	memset(&m_vFVelC, 0, 4*sizeof(D3DVECTOR));
	m_vFVelC.y = 1.0f;

	// init default fuzz
	m_dwNumSegments = 4;
	m_pFuzz = NULL;

	// init default volume
	m_dwNumLayers = 0;
	m_dwVolXSize = 0;
	m_dwVolZSize = 0;

	for(i=0; i<MAX_VLEVEL; i++)
		m_pVolTexture[i] = NULL;
	m_pTexture = NULL;

	InitFuzz(1, 1);
}

//-----------------------------------------------------------------------------
// Name: Destructor
// Desc: 
//-----------------------------------------------------------------------------
CXFPatch::~CXFPatch()
{
	DWORD i;
	
	if(m_pFuzzLib)
		delete m_pFuzzLib;
	if(m_pFuzz)
		delete m_pFuzz;

	for(i=0; i<m_dwNumLayers; i++)
		if(m_pVolTexture[i])
			m_pVolTexture[i]->Release();

	if(m_pTexture)
		m_pTexture->Release();	
}

//-----------------------------------------------------------------------------
// Name: InitFuzz
// Desc: Initializes the individual strands of fuzz in the patch.
//       Only a small number of individual fuzzes are generated
//       (determined by m_dwNumFuzzLib) because each one in the patch
//       does not need to be unique.
//-----------------------------------------------------------------------------
void CXFPatch::InitFuzz(DWORD nfuzz, DWORD nfuzzlib)
{
	DWORD i;
	float y;

	if(nfuzz<=0 || nfuzzlib<0)
		return;
		
	// handle memory allocation
	if(m_dwNumFuzz!=nfuzz)				// if nfuzz has changed
	{
		if(m_pFuzz)
			delete m_pFuzz;				// nuke existing
		m_pFuzz = new FuzzInst[nfuzz];	// and get new fuzz memory
	}

	if(m_dwNumFuzzLib!=nfuzzlib)
	{
		if(m_pFuzzLib)
			delete m_pFuzzLib;

		m_pFuzzLib = new Fuzz[nfuzzlib];
	}

	m_dwNumFuzz = nfuzz;
	m_dwNumFuzzLib = nfuzzlib;

	// generate the individual fuzzes in the library
	m_fYSize = 0.0f;
	srand(m_dwSeed);
	for(i=0; i<m_dwNumFuzzLib; i++)
	{
		m_pFuzzLib[i].dp.x = (m_vFVelC.x + m_vFVelR.x*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].dp.y = (m_vFVelC.y + m_vFVelR.y*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].dp.z = (m_vFVelC.z + m_vFVelR.z*(2*frand(1.0f)-1.0f))*g_fOneInch;

		m_pFuzzLib[i].ddp.x = (m_vFAccC.x + m_vFAccR.x*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].ddp.y = (m_vFAccC.y + m_vFAccR.y*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].ddp.z = (m_vFAccC.z + m_vFAccR.z*(2*frand(1.0f)-1.0f))*g_fOneInch;

		y = m_pFuzzLib[i].dp.y + 0.5f*m_pFuzzLib[i].ddp.y;
		if(y>m_fYSize)
			m_fYSize = y;
	}

 	// initialize the fuzz locations & pick a random fuzz from the library
	srand(m_dwSeed*54795);
	for(i=0; i<m_dwNumFuzz; i++)
	{
		m_pFuzz[i].x = (frand(1.0f)-0.5f)*m_fXSize;
		m_pFuzz[i].z = (frand(1.0f)-0.5f)*m_fZSize;
		m_pFuzz[i].lidx = irand(m_dwNumFuzzLib);
	}
}

//-----------------------------------------------------------------------------
// Name: GenVolume
// Desc: Generate the fuzz volume. This is done by 'growing' a fuzz 
//       through several layers of texture (determined by nlayers)
//       and 'splatting' it in to the relevant layer with the proper alpha.
//       This is done in two stages at present. The first stage builds
//       a floating point 'volume' of rgb and alpha. The next stage
//       puts the proper values into our texture layers.
//-----------------------------------------------------------------------------
void CXFPatch::GenVolume(DWORD nlayers, DWORD volxsize, DWORD volzsize)
{
	float x0, y0, z0;
	float dx, dy, dz;
	float ddx, ddy, ddz;
	float step, cp, scalex, scaley, scalez;
	DWORD b, i, j, lidx, *tex;
	DWORD x, y, z, idx, dwcolor;
	D3DXVECTOR4 *vlayer;
	D3DVECTOR v, color;
	D3DLOCKED_RECT lr;
	float nsplotch;
#ifdef _XBOX
	Swizzler *swiz;
#endif

	FVFT_XYZRHWTEX1 quad[4*sizeof(FVFT_XYZRHWTEX1)] =
	{
		{0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f},
		{(float)volxsize, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f},
		{0.0f, (float)volzsize, 1.0f, 1.0f, 0.0f, 1.0f},
		{(float)volxsize, (float)volzsize, 1.0f, 1.0f, 1.0f, 1.0f}
	};

	// make sure volume info is up to date
	if(m_dwVolXSize!=volxsize || m_dwVolZSize!=volzsize)
	{
		for(i=0; i<m_dwNumLayers; i++)
		{
			if(m_pVolTexture[i])
				m_pVolTexture[i]->Release();
			m_pVolTexture[i] = NULL;
		}
		
		if(m_pTexture)
			m_pTexture->Release();
		m_pTexture = NULL;
		m_dwNumLayers = 0;
	}

	m_dwVolXSize = volxsize;
	m_dwVolZSize = volzsize;
	m_dwVolSize = volxsize*volzsize;

	// create textures if necessary
	if(m_dwNumLayers!=nlayers)
	{
		for(i=0; i<nlayers; i++)
			if(!m_pVolTexture[i])
				g_pd3dDevice->CreateTexture(volxsize, volzsize, 0, 0, D3DFMT_A8R8G8B8, 0, &m_pVolTexture[i]);

		for(i=nlayers; i<m_dwNumLayers; i++)
		{
			m_pVolTexture[i]->Release();
			m_pVolTexture[i] = NULL;
		}

		// create lowest LOD texture
		g_pd3dDevice->CreateTexture(volxsize, volzsize, 0, 0, D3DFMT_A8R8G8B8, 0, &m_pTexture);
	}

	m_dwNumLayers = nlayers;

	// now splat into volume texture
	g_pVolume = new D3DXVECTOR4[m_dwNumLayers*m_dwVolSize];
	memset(g_pVolume, 0, m_dwNumLayers*m_dwVolSize*sizeof(D3DXVECTOR4));

	nsplotch = 200;
	step = 1.0f/nsplotch;
	color = m_vFuzzColor;
	scalex = (float)m_dwVolXSize/m_fXSize;
	scaley = (float)m_dwNumLayers/m_fYSize;
	scalez = (float)m_dwVolZSize/m_fZSize;

	for(i=0; i<m_dwNumFuzz; i++)
	{
		// get location and index from fuzz instances
		lidx = m_pFuzz[i].lidx;

		x0 = m_pFuzz[i].x;		// scale source location
		y0 = 0.0f;
		z0 = m_pFuzz[i].z;		// and offset

		// get params from fuzz lib
		dx = m_pFuzzLib[lidx].dp.x;
		dy = m_pFuzzLib[lidx].dp.y;
		dz = m_pFuzzLib[lidx].dp.z;
		ddx = m_pFuzzLib[lidx].ddp.x;
		ddy = m_pFuzzLib[lidx].ddp.y;
		ddz = m_pFuzzLib[lidx].ddp.z;

		cp = 0.0f;
		for(j=0; j<nsplotch; j++)
		{
			v.x = (x0 + cp*dx + 0.5f*cp*cp*ddx) * scalex + m_dwVolXSize/2.0f;
			v.y = (y0 + cp*dy + 0.5f*cp*cp*ddy) * scaley;
			v.z = (z0 + cp*dz + 0.5f*cp*cp*ddz) * scalez + m_dwVolZSize/2.0f;
			Splat(v, 1.0f-cp, color);					// splat into the texture
			cp += step;
		}
	}

#ifdef _XBOX
	swiz = new Swizzler(m_dwVolXSize, m_dwVolZSize, 0);
#endif

	// put the floating point volume into the textures
	for(y=0; y<m_dwNumLayers; y++)
	{
		m_pVolTexture[y]->LockRect(0, &lr, NULL, 0);	// lock this layer
		tex = (DWORD *)lr.pBits;						// get a pointer to its bits

		vlayer = &g_pVolume[y*m_dwVolSize];				// find ourselves in the fp volume
		idx = 0;

#ifdef _XBOX
		swiz->SetV(0);									// set swizzle v = 0
#endif
		for(z=0; z<m_dwVolZSize; z++)					// fill it
		{
#ifdef _XBOX
			swiz->SetU(0);								// set swizzle u = 0
#endif

			for(x=0; x<m_dwVolXSize; x++)
			{
				// convert to non-pre-multiplied alpha
				float w1 = 255.0f/vlayer[idx].w;

				b = (DWORD)(vlayer[idx].x*w1);
				if(b>255) b = 255;
				dwcolor = b<<16;

				b = (DWORD)(vlayer[idx].y*w1);
				if(b>255) b = 255;
				dwcolor |= b<<8;

				b = (DWORD)(vlayer[idx].z*w1);
				if(b>255) b = 255;
				dwcolor |= b;

				b = (DWORD)(vlayer[idx].w*255.0f);
				if(b>255) b = 255;
				dwcolor |= b<<24;

#ifdef _XBOX
				tex[swiz->Get2D()] = dwcolor;
				swiz->IncU();							// bump swizzle u
#else
				tex[idx] = dwcolor;
#endif
				idx++;
			}

#ifdef _XBOX
			swiz->IncV();								// bump swizzle v
#endif
		}

		m_pVolTexture[y]->UnlockRect(0);

		// have d3dx do all the mip filtering
		D3DXFilterTexture(m_pVolTexture[y], NULL, 0, D3DX_FILTER_BOX);
	}

	// now generate lowest lod texture by rendering 
	// the existing layers into it
	IDirect3DSurface8 *surf, *pBackBuffer, *pZBuffer;

	// get current back and z buffers
	g_pd3dDevice->GetRenderTarget(&pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&pZBuffer);

	// get destination surface & set as render target
	m_pTexture->GetSurfaceLevel(0, &surf);
	g_pd3dDevice->SetRenderTarget(surf, NULL);

	// set up for rendering
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_TEXTUREFACTOR, 0x00c0a070);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	g_pd3dDevice->SetVertexShader(FVF_XYZRHWTEX1);

	// render background color into the texture to clear it out
	g_pd3dDevice->SetTexture(0, NULL);
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, quad, sizeof(FVFT_XYZRHWTEX1));

	// set up for alpha blending
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	for(y=0; y<m_dwNumLayers; y++)
	{
		// render it
		g_pd3dDevice->SetTexture(0, m_pVolTexture[y]);
		g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, quad, sizeof(FVFT_XYZRHWTEX1));
	}

	// release destination surface
	surf->Release();

	// restore original render states
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderTarget(pBackBuffer, pZBuffer);
	pBackBuffer->Release();
	pZBuffer->Release();

	// have d3dx do all the mip filtering
	D3DXFilterTexture(m_pTexture, NULL, 0, D3DX_FILTER_BOX);

	delete g_pVolume;
}

//-----------------------------------------------------------------------------
// Name: Splat
// Desc: Splat a fuzz into the texture. This function attempts to take
//       a very small 'sphere' and splat it into our texture volume by
//       specifying an rgb color and alpha. 
//-----------------------------------------------------------------------------
void CXFPatch::Splat(D3DVECTOR p, float falpha, D3DVECTOR fcolor)
{
	D3DVECTOR pmin, pmax;
	float dx, dy, dz;
	float yscale;
	DWORD idx;
	int x0, x1, y0, y1, z0, z1;
	int x, y, z, xx, zz;
	float r2, e;
	float cx, cy, cz;
	D3DXVECTOR4 *vlayer;

	float fscale = ((float)m_dwVolXSize+(float)m_dwVolZSize)/1024.0f;
	yscale = 1.0f/m_dwNumLayers;

	// find region of pixels covered by point
	pmin.x = p.x - 2.0f*fscale;
	pmin.y = p.y - 2.0f*fscale;
	pmin.z = p.z - 2.0f*fscale;
	pmax.x = p.x + 2.0f*fscale;
	pmax.y = p.y + 2.0f*fscale;
	pmax.z = p.z + 2.0f*fscale;

	// make sure level in range
	if(pmax.y<0.0f || pmin.y>m_dwNumLayers)
		return;

	// find range of points that this splat touches
	x0 = (int)floor(pmin.x);
	y0 = (int)floor(pmin.y);
	z0 = (int)floor(pmin.z);
	x1 = (int)ceil(pmax.x);
	y1 = (int)ceil(pmax.y);
	z1 = (int)ceil(pmax.z);

	// splat into volume
	for(y=y0; y<y1; y++)
	{
		if(y<0)
			continue;
		if(y>=(int)m_dwNumLayers)
			continue;

		vlayer = &g_pVolume[y*m_dwVolSize];

		for(z=z0; z<z1; z++)
		{
			for(x=x0; x<=x1; x++)
			{
				dx = (float)x-p.x;
				dy = ((float)y-p.y); // *yscale;
				dz = (float)z-p.z;
				r2 = dx*dx + dy*dy + dz*dz;
				e = r2/(fscale*fscale);
				if(e>15.0)
					continue;

				// Wrap pixel coordinates
				xx = x & (m_dwVolXSize-1);
				zz = z & (m_dwVolZSize-1);

				// calc color contribution
				e = falpha * expf(-e);
				cx = fcolor.x*e;
				cy = fcolor.y*e;
				cz = fcolor.z*e;

				// add into volume
				idx = zz*m_dwVolXSize+xx;
				vlayer[idx].x += cx;
				vlayer[idx].y += cy;
				vlayer[idx].z += cz;
				vlayer[idx].w += e;
			}
		}
	}
}

//-----------------------------------------------------------------------------
// Desc: File routines for saving and loading patch files.
//       Saving is only relevant if used on a Windows platform.
//-----------------------------------------------------------------------------
struct _fphdr
{
	char sig[5];
	int flags;
};

void CXFPatch::Save(char *fname, int flags)
{
	FILE *fp;
	struct _fphdr hdr;

	fp = fopen(fname, "wb");

	// write file header
	strcpy(hdr.sig, "FUZ1");
	hdr.flags = flags;
	fwrite(&hdr, sizeof(struct _fphdr), 1, fp);

	// write fpatch data
	fwrite(&m_dwSeed, sizeof(DWORD), 1, fp);
	
	fwrite(&m_fXSize, sizeof(float), 1, fp);
	fwrite(&m_fYSize, sizeof(float), 1, fp);
	fwrite(&m_fZSize, sizeof(float), 1, fp);

	fwrite(&m_dwNumSegments, sizeof(DWORD), 1, fp);
	fwrite(&m_vFuzzColor, sizeof(D3DVECTOR), 1, fp);

	fwrite(&m_vFVelC, sizeof(D3DVECTOR), 1, fp);
	fwrite(&m_vFVelR, sizeof(D3DVECTOR), 1, fp);
	fwrite(&m_vFAccC, sizeof(D3DVECTOR), 1, fp);
	fwrite(&m_vFAccR, sizeof(D3DVECTOR), 1, fp);

	fwrite(&m_dwNumFuzzLib, sizeof(DWORD), 1, fp);
	fwrite(&m_dwNumFuzz, sizeof(DWORD), 1, fp);

	fwrite(&m_dwNumLayers, sizeof(DWORD), 1, fp);
	fwrite(&m_dwVolXSize, sizeof(DWORD), 1, fp);
	fwrite(&m_dwVolZSize, sizeof(DWORD), 1, fp);

	// write volume data if available and flag is set
	{
	}

	fclose(fp);
}

void CXFPatch::Load(char *fname)
{
	FILE *fp;
	struct _fphdr hdr;
	DWORD numfuzzlib, numfuzz;
	DWORD numlayers, volxsize, volzsize;

	fp = fopen(fname, "rb");
	if(!fp)
		return;

	// read file header
	fread(&hdr, sizeof(struct _fphdr), 1, fp);

	// verify signature
	if(strcmp(hdr.sig, "FUZ1"))
		return;

	// read patch data
	fread(&m_dwSeed, sizeof(DWORD), 1, fp);
	
	fread(&m_fXSize, sizeof(float), 1, fp);
	fread(&m_fYSize, sizeof(float), 1, fp);
	fread(&m_fZSize, sizeof(float), 1, fp);

	fread(&m_dwNumSegments, sizeof(DWORD), 1, fp);
	fread(&m_vFuzzColor, sizeof(D3DVECTOR), 1, fp);

	fread(&m_vFVelC, sizeof(D3DVECTOR), 1, fp);
	fread(&m_vFVelR, sizeof(D3DVECTOR), 1, fp);
	fread(&m_vFAccC, sizeof(D3DVECTOR), 1, fp);
	fread(&m_vFAccR, sizeof(D3DVECTOR), 1, fp);

	fread(&numfuzzlib, sizeof(DWORD), 1, fp);
	fread(&numfuzz, sizeof(DWORD), 1, fp);

	fread(&numlayers, sizeof(DWORD), 1, fp);
	fread(&volxsize, sizeof(DWORD), 1, fp);
	fread(&volzsize, sizeof(DWORD), 1, fp);

	// read volume data if available and flag is set
	{
	}

	fclose(fp);

	InitFuzz(numfuzz, numfuzzlib);
	GenVolume(numlayers, volxsize, volzsize);
}

//-----------------------------------------------------------------------------
// Name: RenderLines
// Desc: Draw the fuzz patch as a series of individual lines.
//-----------------------------------------------------------------------------
void CXFPatch::RenderLines()
{
	DWORD i, j, vidx, alpha, dalpha, lidx, color;
	FVFT_XYZDIFF *verts;
	float x0, y0, z0;
	float dx, dy, dz;
	float ddx, ddy, ddz;
	float step, cp;
	UINT startseg = 0;

	verts = new FVFT_XYZDIFF[m_dwNumFuzz*m_dwNumSegments*2];
	assert(verts!=NULL);

	g_pd3dDevice->SetTexture(0, NULL);
	g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);

	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);

	color = (DWORD)(m_vFuzzColor.x*255.0f)&0xff;
	color <<= 8;
	color |= (DWORD)(m_vFuzzColor.y*255.0f)&0xff;
	color <<= 8;
	color |= (DWORD)(m_vFuzzColor.z*255.0f)&0xff;

	step = 1.0f/(float)m_dwNumSegments;
	dalpha = 255/m_dwNumSegments;

	vidx = 0;
	for(i=0; i<m_dwNumFuzz; i++)
	{
		// get location and index from fuzz instances
		lidx = m_pFuzz[i].lidx;
		x0 = m_pFuzz[i].x;
		y0 = 0.0f;
		z0 = m_pFuzz[i].z;

		// get params from fuzz lib
		dx = m_pFuzzLib[lidx].dp.x;
		dy = m_pFuzzLib[lidx].dp.y;
		dz = m_pFuzzLib[lidx].dp.z;
		ddx = m_pFuzzLib[lidx].ddp.x;
		ddy = m_pFuzzLib[lidx].ddp.y;
		ddz = m_pFuzzLib[lidx].ddp.z;

		// build linelist
		alpha = 255-startseg*dalpha;
		cp = (float)startseg*step;

		for(j=startseg; j<m_dwNumSegments; j++)
		{
			verts[vidx].v.x = x0 + cp*dx + 0.5f*cp*cp*ddx;
			verts[vidx].v.y = y0 + cp*dy + 0.5f*cp*cp*ddy;
			verts[vidx].v.z = z0 + cp*dz + 0.5f*cp*cp*ddz;
			verts[vidx].diff = (alpha<<24) | color;
			vidx++;

			alpha -= dalpha;
			cp += step;

			verts[vidx].v.x = x0 + cp*dx + 0.5f*cp*cp*ddx;
			verts[vidx].v.y = y0 + cp*dy + 0.5f*cp*cp*ddy;
			verts[vidx].v.z = z0 + cp*dz + 0.5f*cp*cp*ddz;
			verts[vidx].diff = (alpha<<24) | color;
			vidx++;
		}
	}
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINELIST, vidx/2, verts, sizeof(FVFT_XYZDIFF));
	
	delete verts;
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Draw the fuzz patch as layers of texture
//       lod varies from 0 to 1 where 1 = highest LOD (most detail)
//       and 0 = lowest LOD (least detail)
//-----------------------------------------------------------------------------
void CXFPatch::Render(float lod, CXFPatchMesh *pmesh)
{
	D3DXVECTOR4 f;
	D3DXVECTOR3 v;
	DWORD i, lflag;
	D3DXMATRIX tmp;

	// if lod==1.0f render the individual fuzzes
	if(lod==1.0f)
	{
		RenderLines();
		return;
	}

	// color and alpha both come from our volume texture
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);


	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	g_pd3dDevice->GetRenderState(D3DRS_LIGHTING, &lflag);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR);

	// VERTEX SHADER SETUP

	// set display matrix
	D3DXMatrixMultiply(&tmp, (D3DXMATRIX *)&g_matWorld, &g_matView);
	D3DXMatrixMultiply(&g_matDisplay, &tmp, &g_matProj);
	D3DXMatrixTranspose(&g_matDisplay, &g_matDisplay);
	g_pd3dDevice->SetVertexShaderConstant(0, &g_matDisplay, 4);

	// world matrix	
	D3DXMatrixTranspose(&tmp, (D3DXMATRIX *)&g_matWorld);
	g_pd3dDevice->SetVertexShaderConstant(4, &tmp, 4);		// world matrix

	// normalize light vector & set VS constant
	D3DXVec3Normalize(&v, (D3DXVECTOR3 *)&g_LightPos);
	g_pd3dDevice->SetVertexShaderConstant(13, &v, 1);

	if(lod>0.25f)	// render m_dwNumLayers of textures using alpha blending
	{
		g_pd3dDevice->SetVertexShader(g_dwFuzzVS);
		g_pd3dDevice->SetStreamSource(0, pmesh->m_pVB, sizeof(FVFT_XYZNORMTEX1));

		for(i=0; i<m_dwNumLayers; i++)
		{
			f.x = (float)i*m_fYSize/(float)(m_dwNumLayers-1);
			f.w = 0.0f;
			g_pd3dDevice->SetVertexShaderConstant(12, &f, 1);
					
			g_pd3dDevice->SetTexture(0, m_pVolTexture[i]);
			g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, pmesh->m_dwNumIndices/3);
		}
	}
	else			// lowest LOD render
	{
		g_pd3dDevice->SetVertexShader(pmesh->m_dwVShader);
		g_pd3dDevice->SetStreamSource(0, pmesh->m_pVB, sizeof(FVFT_XYZNORMTEX1));

		f.x = (float)m_fYSize/(float)(m_dwNumLayers-1);
		f.w = 0.0f;
		g_pd3dDevice->SetVertexShaderConstant(12, &f, 1);

		g_pd3dDevice->SetTexture(0, m_pTexture);
		g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, pmesh->m_dwNumIndices/3);
	}

	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, lflag);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_MIPFILTER, D3DTEXF_NONE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\Face\xfpmesh.cpp ===
//-----------------------------------------------------------------------------
// File: xfpmesh.cpp
//
// Desc: Facilitates drawing of 'fuzz' patches (hair, fur, grass, etc.)
//       by allowing you to 'paint' on an existing mesh and use those
//       triangles for the fuzz.
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <assert.h>
#include "xfpmesh.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//-----------------------------------------------------------------------------
// Name: Constructor & Destructor
//-----------------------------------------------------------------------------
CXFPatchMesh::CXFPatchMesh()
{
	memset(this, 0, sizeof(CXFPatchMesh));

	m_dwVShader = FVF_XYZNORMTEX1;
}

CXFPatchMesh::~CXFPatchMesh()
{
	if(m_pVB)
		m_pVB->Release();
	if(m_Indices)
		delete m_Indices;
	if(m_UVs)
		delete m_UVs;
	if(m_pTexture)
		m_pTexture->Release();
}

//-----------------------------------------------------------------------------
// Name: LineEQ
// Desc: Determines a line equation to facilitate picking triangles
//-----------------------------------------------------------------------------
void LineEQ(D3DXVECTOR3 *p1, D3DXVECTOR3 *p2, float *a, float *b, float *c)
{
	*a = -(p1->y - p2->y);
	*b = p1->x - p2->x;
	*c = -(*a*p1->x + *b*p1->y);
}

//-----------------------------------------------------------------------------
// Name: PickTriangle
// Desc: Searches an objects model for a triangle that contains the point
//       specified in p (in screen space).
//
// Note: This routine would be used in a tool to pick which triangles
//       you want for this pmesh.
//-----------------------------------------------------------------------------
DWORD CXFPatchMesh::PickTriangle(CXObject *obj, POINT p, DWORD flag, D3DVIEWPORT8 *Viewport, D3DXMATRIX *matProj, D3DXMATRIX *matView, D3DXMATRIX *matWorld)
{
	BYTE *vptr, *iptr;
	DWORD i, j, ret;
	int dup;
	D3DVECTOR v1, v2, v3;
	D3DXVECTOR3 vp1, vp2, vp3;
	WORD i1, i2, i3, *tris;
	float a, b, c, d;

	obj->m_Model->LockVB(&vptr, 0);
	obj->m_Model->LockIB(&iptr, 0);
	tris = (WORD *)iptr;

	for(i=0; i<obj->m_Model->m_dwNumIndices/3; i++)
	{
		i1 = tris[i*3];
		i2 = tris[i*3+1];
		i3 = tris[i*3+2];

		FVF_GetVert(vptr, &v1, i1, 1, obj->m_Model->m_dwFVF);
		FVF_GetVert(vptr, &v2, i2, 1, obj->m_Model->m_dwFVF);
		FVF_GetVert(vptr, &v3, i3, 1, obj->m_Model->m_dwFVF);

		D3DXVec3Project(&vp1, (D3DXVECTOR3 *)&v1, Viewport, matProj, matView, matWorld);
		D3DXVec3Project(&vp2, (D3DXVECTOR3 *)&v2, Viewport, matProj, matView, matWorld);
		D3DXVec3Project(&vp3, (D3DXVECTOR3 *)&v3, Viewport, matProj, matView, matWorld);

		// check if point inside triangle
		LineEQ(&vp1, &vp2, &a, &b, &c);
		d = a*(float)p.x + b*(float)p.y + c;
		if(d>0)
			continue;
		LineEQ(&vp2, &vp3, &a, &b, &c);
		d = a*(float)p.x + b*(float)p.y + c;
		if(d>0)
			continue;
		LineEQ(&vp3, &vp1, &a, &b, &c);
		d = a*(float)p.x + b*(float)p.y + c;
		if(d>0)
			continue;

		// check for duplicate tri
		dup = -1;
		for(j=0; j<m_dwNumIndices/3; j++)
		{
			if((m_Indices[j*3]==i1) && (m_Indices[j*3+1]==i2) && (m_Indices[j*3+2]==i3))
			{
				dup = j;
				break;
			}
		}

		// flag==0, do add or delete
		// flag==1, do only add
		// flag==2, do only delete
		if((flag==0 || flag==1) && (dup==-1))			// do add
		{
			// make sure we have space
			if(m_dwNumIndices>=(m_dwMaxIndices-5))
			{
				// expand index space
				m_dwMaxIndices = m_dwNumIndices+300;

				// copy indices
				WORD *newindices = new WORD[m_dwMaxIndices];
				memcpy(newindices, m_Indices, m_dwNumIndices*sizeof(WORD));
				if(m_Indices)
					delete m_Indices;
				m_Indices = newindices;
	
				// copy texture samples
				float *newuvs = new float[m_dwMaxIndices*2];
				memcpy(newuvs, m_UVs, m_dwNumIndices*2*sizeof(float));
				if(m_UVs)
					delete m_UVs;
				m_UVs = newuvs;
			}

			// add triangle
			m_Indices[m_dwNumIndices++] = i1;
			m_Indices[m_dwNumIndices++] = i2;
			m_Indices[m_dwNumIndices++] = i3;

			ret = 1;
			m_bBuildFlag = TRUE;
			goto bail;
		}
		else if((flag==0 || flag==2) && (dup>=0))		// do delete
		{
			m_Indices[dup*3+2] = m_Indices[--m_dwNumIndices];
			m_Indices[dup*3+1] = m_Indices[--m_dwNumIndices];
			m_Indices[dup*3] = m_Indices[--m_dwNumIndices];

			ret = 2;
			m_bBuildFlag = TRUE;
			goto bail;
		}
	}

bail:
	obj->m_Model->UnlockVB();
	obj->m_Model->UnlockIB();

	return ret;											// return last op
}

//-----------------------------------------------------------------------------
// Name: File routines
// Desc: Routines to save and load patch mesh descriptions
//-----------------------------------------------------------------------------
struct _pmhdr
{
	char sig[4];
	char fpatchname[32];
	DWORD nidx;
	D3DVECTOR texcenter;
	D3DVECTOR texsize;
	DWORD mapping;
	DWORD axis;
};

void CXFPatchMesh::Save(char *fname)
{
	FILE *fp;
	struct _pmhdr hdr;

	fp = fopen(fname, "wb");
	if(!fp)
		return;

	strcpy(hdr.sig, "PMSH");
	strcpy(hdr.fpatchname, m_strFPatchName);

	hdr.nidx = m_dwNumIndices;

	hdr.texcenter = m_TextureCenter;
	hdr.texsize = m_TextureSize;
	hdr.mapping = m_dwMapping;
	hdr.axis = m_dwAxis;

	fwrite(&hdr, sizeof(struct _pmhdr), 1, fp);
	fwrite(m_Indices, sizeof(WORD), m_dwNumIndices, fp);
	fwrite(m_UVs, sizeof(float), m_dwNumIndices*2, fp);

	fclose(fp);
}

void CXFPatchMesh::Load(char *fname)
{
	FILE *fp;
	struct _pmhdr hdr;

	fp = fopen(fname, "rb");
	if(!fp)
		return;

	fread(&hdr, sizeof(struct _pmhdr), 1, fp);
	if(strncmp(hdr.sig, "PMSH", 4))
	{
		fclose(fp);
		return;
	}

	strcpy(m_strFPatchName, hdr.fpatchname);

	m_dwNumIndices = hdr.nidx;
	m_dwMaxIndices = hdr.nidx;

	m_TextureCenter = hdr.texcenter;
	m_TextureSize = hdr.texsize;
	m_dwMapping = hdr.mapping;
	m_dwAxis = hdr.axis;

	// allocate memory
	if(m_Indices)
		delete m_Indices;
	m_Indices = new WORD[m_dwNumIndices];

	if(m_UVs)
		delete m_UVs;
	m_UVs = new float[2*m_dwNumIndices];

	// read in the data
	fread(m_Indices, sizeof(WORD), m_dwNumIndices, fp);
	fread(m_UVs, sizeof(float), m_dwNumIndices*2, fp);
	fclose(fp);

	// build index buffer
	BuildIndexBuffer();

	m_bBuildFlag = TRUE;
}

//-----------------------------------------------------------------------------
// Name: BuildIndexBuffer
// Desc: Builds the pmesh index buffer for rendering
//-----------------------------------------------------------------------------
void CXFPatchMesh::BuildIndexBuffer()
{
/*
	WORD idx, *ibuf, *tbuf;
	WORD wMaxIndex;
	DWORD i;

	// scan indices to get max index
	wMaxIndex = 0;
	for(i=0; i<m_dwNumIndices; i++)
		if(m_Indices[i]>wMaxIndex)
			wMaxIndex = m_Indices[i];

	tbuf = new WORD[wMaxIndex];
	memset(tbuf, 0xffffffff, wMaxIndex*sizeof(WORD));

	g_pd3dDevice->CreateIndexBuffer(m_dwNumIndices*sizeof(WORD), 0, D3DFMT_INDEX16, 0, &m_pIB);
	m_pIB->Lock(0, m_dwNumIndices*sizeof(WORD), (BYTE **)&ibuf, 0);

	idx = 0;
	for(i=0; i<m_dwNumIndices; i++)
	{
		if(tbuf[m_Indices[i]]==0xffff)
		{
			tbuf[m_Indices[i]] = idx;
			ibuf[i] = idx++;
		}
		else
			ibuf[i] = tbuf[m_Indices[i]];
	}

	m_wMaxIndex = idx;			// keep track of biggest index
	m_pIB->Unlock();

	delete tbuf;
*/
}

//-----------------------------------------------------------------------------
// Name: Build
// Desc: Gets vertices and normals from the underlying object for our
//       patch mesh.
//-----------------------------------------------------------------------------
void CXFPatchMesh::Build(int firstflag)
{
	FVFT_XYZNORMTEX1 *vptr, *vptr2;
	DWORD i;

	if(!m_dwNumIndices || !m_bBuildFlag)
		return;

	// make sure we are using correct FVF type
	assert(m_Obj->m_Model->m_dwFVF==FVF_XYZNORMTEX1);

	// get memory for our vertices
	if(m_dwNumVertices<m_dwNumIndices)
	{
		if(m_pVB)
			m_pVB->Release();

		m_dwNumVertices = m_dwNumIndices;
		g_pd3dDevice->CreateVertexBuffer(m_dwNumVertices*sizeof(FVFT_XYZNORMTEX1), 0, FVF_XYZNORMTEX1, 0, &m_pVB);
	}

	// get the vertices and normals from our underlying model
	m_pVB->Lock(0, m_dwNumVertices*sizeof(FVFT_XYZNORMTEX1), (BYTE **)&vptr, 0);
	m_Obj->m_Model->LockVB((BYTE **)&vptr2, 0);
	for(i=0; i<m_dwNumIndices; i++)
	{
		vptr[i].v = vptr2[m_Indices[i]].v;
		vptr[i].norm = vptr2[m_Indices[i]].norm;
	}

	// if this is the first build, copy the UV's into the PMesh VB
	if(firstflag)
		for(i=0; i<m_dwNumIndices; i++)
		{
			vptr[i].tu = m_UVs[i<<1];
			vptr[i].tv = m_UVs[(i<<1)+1];
		}

	// unlock vertex buffers
	m_pVB->Unlock();
	m_Obj->m_Model->UnlockVB();

	m_bBuildFlag = FALSE;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Draw the patch mesh on its own. Used to see exactly which triangles
//       are selected. (Normally, another class would use the pmesh data only
//       to do its rendering)
//-----------------------------------------------------------------------------
void CXFPatchMesh::Render()
{
	if(!m_dwNumIndices)			// make sure we have stuff to draw
		return;

	g_pd3dDevice->SetTexture(0, m_pTexture);
	g_pd3dDevice->SetVertexShader(m_dwVShader);
	g_pd3dDevice->SetStreamSource(0, m_pVB, sizeof(FVFT_XYZNORMTEX1));
	g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, m_dwNumIndices/3);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh2\Font.h ===
// Automatically generated by the bundler tool from font.rdf

#define font_NUM_RESOURCES 2UL

#define font_Font_OFFSET 0UL
#define font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh\mdraw.cpp ===
//-----------------------------------------------------------------------------
// File: mdraw.cpp
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <XBApp.h>
#include <XBFont.h>
#include <XBResource.h>
#include <XBUtil.h>
#include "XBSkinnedMesh.h"


HRESULT CXBSkinnedMesh::DrawMeshContainer(SMeshContainer* pMeshContainer)
{
    UINT ipattr;
    HRESULT hr = S_OK;
    BONECOMBINATION* pBoneComb;

    if( pMeshContainer->m_pSkinMesh )
    {
        D3DCAPS8    caps;

        m_pd3dDevice->GetDeviceCaps(&caps);

        if( m_method != pMeshContainer->m_Method )
        {
            GenerateMesh(pMeshContainer);
        }

        if( m_method == SKIN_NONINDEXED )
        {
            m_pd3dDevice->SetRenderState(D3DRS_VERTEXBLEND, pMeshContainer->m_dwMaxFaceInfluenceCount - 1);
            pBoneComb = pMeshContainer->m_pBoneCombinations;
			
			for( ipattr = 0; ipattr < pMeshContainer->m_dwNumBoneCombinations; ipattr++ )
            {
                for( DWORD i = 0; i < pMeshContainer->m_dwMaxFaceInfluenceCount; i++ )
                {
                    DWORD matid = pBoneComb[ipattr].BoneId[i];
                    if( matid != UINT_MAX && (ipattr == 0 || matid != pBoneComb[ipattr - 1].BoneId[i]) )
                    {
                        m_pd3dDevice->SetTransform(D3DTS_WORLDMATRIX(i), pMeshContainer->m_pBoneMatrix[matid]);
                        m_pd3dDevice->MultiplyTransform(D3DTS_WORLDMATRIX(i), &pMeshContainer->m_pBoneOffsetMatrices[matid]);
                    }
                }

                if( ipattr == 0 || (pBoneComb[ipattr].AttribId != pBoneComb[ipattr - 1].AttribId) )
                {
                    m_pd3dDevice->SetMaterial(&(pMeshContainer->m_pMaterials[pBoneComb[ipattr].AttribId]));
                    m_pd3dDevice->SetTexture(0, pMeshContainer->m_pTextures[pBoneComb[ipattr].AttribId]);
                }

		        hr = pMeshContainer->m_pMesh->DrawSubset( ipattr );
                if(FAILED(hr))
                    return hr;
            }
            m_pd3dDevice->SetRenderState(D3DRS_VERTEXBLEND, 0);
		}
        else if( m_method == SKIN_INDEXED )
        {
/*
            if (caps.MaxVertexBlendMatrixIndex < pMeshContainer->m_pSkinMesh->GetNumBones())
            {
NOT ON XBOX
                m_pd3dDevice->SetRenderState(D3DRS_SOFTWAREVERTEXPROCESSING, TRUE);
            }
*/

            m_pd3dDevice->SetRenderState(D3DRS_VERTEXBLEND, pMeshContainer->m_dwMaxFaceInfluenceCount - 1);
/*
            if (pMeshContainer->m_dwMaxFaceInfluenceCount - 1)
			{
NOT ON XBOX
                m_pd3dDevice->SetRenderState(D3DRS_INDEXEDVERTEXBLENDENABLE, TRUE);
			}
*/
            pBoneComb = pMeshContainer->m_pBoneCombinations;

            for( ipattr = 0; ipattr < pMeshContainer->m_dwNumBoneCombinations; ipattr++ )
            {
                for( DWORD i = 0; i < 255/*paletteSize*/; i++ )
                {
                    DWORD matid = pBoneComb[ipattr].BoneId[i];
                    if( matid != UINT_MAX )
                    {
                        m_pd3dDevice->SetTransform(D3DTS_WORLDMATRIX(i), pMeshContainer->m_pBoneMatrix[matid]);
                        m_pd3dDevice->MultiplyTransform(D3DTS_WORLDMATRIX(i), &pMeshContainer->m_pBoneOffsetMatrices[matid]);
                    }
                }
                
                m_pd3dDevice->SetMaterial( &(pMeshContainer->m_pMaterials[pBoneComb[ipattr].AttribId]) );
                m_pd3dDevice->SetTexture( 0, pMeshContainer->m_pTextures[pBoneComb[ipattr].AttribId] );

                hr = pMeshContainer->m_pMesh->DrawSubset( ipattr );
                if(FAILED(hr))
                    return hr;
            }
/*
NOT ON XBOX
            m_pd3dDevice->SetRenderState(D3DRS_INDEXEDVERTEXBLENDENABLE, TRUE);
*/
            m_pd3dDevice->SetRenderState(D3DRS_VERTEXBLEND, 0);

        }
    }
    else
    {
        for( ipattr = 0; ipattr < pMeshContainer->m_dwNumBoneCombinations; ipattr++ )
        {
            m_pd3dDevice->SetMaterial(&(pMeshContainer->m_pMaterials[ipattr]));
            m_pd3dDevice->SetTexture(0, pMeshContainer->m_pTextures[ipattr]);
		    hr = pMeshContainer->m_pMesh->DrawSubset( ipattr );
            if(FAILED(hr))
                return hr;
        }
    }

    return S_OK;
}




HRESULT CXBSkinnedMesh::UpdateFrames( SFrame* pCurrentFrame, D3DXMATRIX &matCur )
{
    HRESULT hr;

    pCurrentFrame->m_matCombined = matCur;
    D3DXMatrixMultiply( &pCurrentFrame->m_matCombined, &pCurrentFrame->m_matRot, &matCur );
    D3DXMatrixMultiply( &pCurrentFrame->m_matCombined, &pCurrentFrame->m_matCombined, &pCurrentFrame->m_matTrans );
    
	for( SFrame* pChildFrame = pCurrentFrame->m_pChild; pChildFrame; pChildFrame = pChildFrame->m_pSibling )
    {
        hr = UpdateFrames( pChildFrame, pCurrentFrame->m_matCombined );
        if( FAILED(hr) )
            return hr;
    }
    return S_OK;
}




HRESULT CXBSkinnedMesh::DrawFrames( SFrame* pCurrentFrame, UINT& dwNumTriangles )
{
    HRESULT hr;

    if( pCurrentFrame->m_pMeshContainer )
    {
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &pCurrentFrame->m_matCombined );
    }

    SMeshContainer* pMeshContainer = pCurrentFrame->m_pMeshContainer;
    while( pMeshContainer )
    {
        hr = DrawMeshContainer( pMeshContainer );
        if( FAILED(hr) )
            return hr;

        dwNumTriangles += pMeshContainer->m_pMesh->GetNumFaces();

        pMeshContainer = pMeshContainer->m_pNext;
    }

    SFrame* pChildFrame = pCurrentFrame->m_pChild;
    while( pChildFrame )
    {
        hr = DrawFrames( pChildFrame, dwNumTriangles );
        if( FAILED(hr) )
            return hr;

        pChildFrame = pChildFrame->m_pSibling;
    }

    return S_OK;
}




void SFrame::SetTime( float fGlobalTime )
{
    UINT        iKey;
    UINT        dwp2;
    UINT        dwp3;
    D3DXMATRIX  matResult;
    D3DXMATRIX  matTemp;
    float       fTime1;
    float       fTime2;
    float       fLerpValue;
    D3DXVECTOR3 vScale;
    D3DXVECTOR3 vPos;
    D3DXQUATERNION quat;
    BOOL  bAnimate = false;
    float fTime;

    if( m_pMatrixKeys )
    {
        fTime = fmodf( fGlobalTime, (float)m_pMatrixKeys[m_dwNumMatrixKeys-1].dwTime );

        for( iKey = 0; iKey < m_dwNumMatrixKeys; iKey++ )
        {
            if( (float)m_pMatrixKeys[iKey].dwTime > fTime )
            {
                dwp3 = iKey;

                if( iKey > 0 )
                    dwp2= iKey - 1;
                else  // when iKey == 0, then dwp2 == 0
                    dwp2 = iKey;
                break;
            }
        }
        fTime1 = (float)m_pMatrixKeys[dwp2].dwTime;
        fTime2 = (float)m_pMatrixKeys[dwp3].dwTime;

        if( (fTime2 - fTime1) ==0 )
            fLerpValue = 0;
        else
            fLerpValue =  (fTime - fTime1)  / (fTime2 - fTime1);

        if( fLerpValue > 0.5f )
            iKey = dwp3;
        else
            iKey = dwp2;

        m_pframeToAnimate->m_matRot = m_pMatrixKeys[iKey].mat;
    }
    else
    {
        D3DXMatrixIdentity( &matResult );

        if( m_pScaleKeys )
        {
            dwp2 = dwp3 = 0;

            fTime = (float)fmod(fGlobalTime, m_pScaleKeys[m_dwNumScaleKeys-1].dwTime);

            for( iKey = 0 ;iKey < m_dwNumScaleKeys; iKey++ )
            {
                if( (float)m_pScaleKeys[iKey].dwTime > fTime )
                {
                    dwp3 = iKey;

                    if( iKey > 0 )
                        dwp2= iKey - 1;
                    else  // when iKey == 0, then dwp2 == 0
                        dwp2 = iKey;

                    break;
                }
            }
            fTime1 = (float)m_pScaleKeys[dwp2].dwTime;
            fTime2 = (float)m_pScaleKeys[dwp3].dwTime;

            if( (fTime2 - fTime1) ==0 )
                fLerpValue = 0;
            else
                fLerpValue =  (fTime - fTime1)  / (fTime2 - fTime1);

            D3DXVec3Lerp( &vScale, &m_pScaleKeys[dwp2].vScale,
                                   &m_pScaleKeys[dwp3].vScale, fLerpValue );

            D3DXMatrixScaling(&matTemp, vScale.x, vScale.y, vScale.z);

            D3DXMatrixMultiply(&matResult, &matResult, &matTemp);

            bAnimate = true;
        }

        // Check rotate keys
        if( m_pRotateKeys )
        {
            dwp2 = dwp3 = 0;

            fTime = (float)fmod(fGlobalTime, m_pRotateKeys[m_dwNumRotateKeys-1].dwTime);

            for( iKey = 0 ;iKey < m_dwNumRotateKeys ; iKey++ )
            {
                if( (float)m_pRotateKeys[iKey].dwTime > fTime )
                {
                    dwp3 = iKey;

                    if( iKey > 0 )
                        dwp2 = iKey - 1;
                    else  // when iKey == 0, then dwp2 == 0
                        dwp2 = iKey;
                    break;
                }
            }
            fTime1 = (float)m_pRotateKeys[dwp2].dwTime;
            fTime2 = (float)m_pRotateKeys[dwp3].dwTime;

            if( (fTime2 - fTime1) ==0 )
                fLerpValue = 0;
            else
                fLerpValue =  (fTime - fTime1)  / (fTime2 - fTime1);

            //s=0;
            D3DXQUATERNION q1,q2;
            q1.x = -m_pRotateKeys[dwp2].quatRotate.x;
            q1.y = -m_pRotateKeys[dwp2].quatRotate.y;
            q1.z = -m_pRotateKeys[dwp2].quatRotate.z;
            q1.w =  m_pRotateKeys[dwp2].quatRotate.w;

            q2.x = -m_pRotateKeys[dwp3].quatRotate.x;
            q2.y = -m_pRotateKeys[dwp3].quatRotate.y;
            q2.z = -m_pRotateKeys[dwp3].quatRotate.z;
            q2.w =  m_pRotateKeys[dwp3].quatRotate.w;

            D3DXQuaternionSlerp( &quat, &q1, &q2, fLerpValue );

            D3DXMatrixRotationQuaternion(&matTemp, &quat);

            D3DXMatrixMultiply(&matResult, &matResult, &matTemp);
            bAnimate = true;
        }

        if( m_pPositionKeys )
        {
            dwp2=dwp3=0;

            fTime = (float)fmod(fGlobalTime, m_pPositionKeys[m_dwNumRotateKeys-1].dwTime);

            for( iKey = 0 ;iKey < m_dwNumPositionKeys ; iKey++ )
            {
                if( (float)m_pPositionKeys[iKey].dwTime > fTime )
                {
                    dwp3 = iKey;

                    if( iKey > 0 )
                        dwp2 = iKey - 1;
                    else  // when iKey == 0, then dwp2 == 0
                        dwp2 = iKey;

                    break;
                }
            }
            fTime1 = (float)m_pPositionKeys[dwp2].dwTime;
            fTime2 = (float)m_pPositionKeys[dwp3].dwTime;

            if ((fTime2 - fTime1) ==0)
                fLerpValue = 0;
            else
                fLerpValue =  (fTime - fTime1)  / (fTime2 - fTime1);

            D3DXVec3Lerp( (D3DXVECTOR3*)&vPos, &m_pPositionKeys[dwp2].vPos,
                                               &m_pPositionKeys[dwp3].vPos, fLerpValue );

            D3DXMatrixTranslation( &matTemp, vPos.x, vPos.y, vPos.z );

            D3DXMatrixMultiply( &matResult, &matResult, &matTemp );
            bAnimate = true;
        }
        else
        {
            D3DXMatrixTranslation( &matTemp, m_pframeToAnimate->m_matRotOrig._41, 
				                             m_pframeToAnimate->m_matRotOrig._42, 
											 m_pframeToAnimate->m_matRotOrig._43 );

            D3DXMatrixMultiply( &matResult, &matResult, &matTemp );
        }

        if( bAnimate )
        {
            m_pframeToAnimate->m_matRot = matResult;
        }
    }
}




HRESULT CXBSkinnedMesh::Render()
{
	UINT   dwNumTriangles = 0;
	HRESULT hr;

	for( SDrawElement* pDrawElement = m_pdeHead; pDrawElement; pDrawElement = pDrawElement->m_pNext )
    {
        hr = DrawFrames( pDrawElement->m_pRootFrame, dwNumTriangles );
        if( FAILED(hr) )
            return hr;
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh\mload.cpp ===
//-----------------------------------------------------------------------------
// File: mload.cpp
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <XBApp.h>
#include <XBFont.h>
#include <XBResource.h>
#include <XBUtil.h>
#include "rmxfguid.h"
#include "rmxftmpl.h"
#include "XBSkinnedMesh.h"


CXBPackedResource* g_pResource = NULL;




CXBSkinnedMesh::CXBSkinnedMesh()
{
    m_pmcSelectedMesh = NULL;
    m_pframeSelected  = NULL;
    m_pdeHead         = NULL;
    m_pdeSelected     = NULL;
    m_dwFVF           = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE | D3DFVF_TEX1;
    m_method          = SKIN_NONINDEXED;
}



HRESULT CalculateSum( SFrame* pFrame, D3DXMATRIX* pmatCur, D3DXVECTOR3* pvCenter, 
                      UINT* pdwNumVertices )
{
    HRESULT         hr;
    PBYTE           pbPoints = NULL;
    UINT            cVerticesLocal = 0;
    PBYTE           pbCur;
    D3DXVECTOR3*    pvCur;
    D3DXVECTOR3     vTransformedCur;
    UINT            iPoint;
    UINT            cVertices;
    D3DXMATRIX      matLocal;
    
    D3DXMatrixMultiply( &matLocal, &pFrame->m_matRot, pmatCur );
    
    SMeshContainer* pmcCur = pFrame->m_pMeshContainer;
    while( pmcCur != NULL )
    {
        DWORD fvfsize = D3DXGetFVFVertexSize(pmcCur->m_pMesh->GetFVF());
        
        cVertices = pmcCur->m_pMesh->GetNumVertices();
        
        hr = pmcCur->m_pMesh->GetVertexBuffer()->Lock( 0, 0, (BYTE**)&pbPoints, 0 );
        if( FAILED(hr) )
			return hr;
        
        for( iPoint=0, pbCur = pbPoints; iPoint < cVertices; iPoint++, pbCur += fvfsize )
        {
            pvCur = (D3DXVECTOR3*)pbCur;
            
            if( (pvCur->x != 0.0) || (pvCur->y != 0.0) || (pvCur->z != 0.0) )
            {
                cVerticesLocal++;
                
                D3DXVec3TransformCoord(&vTransformedCur, pvCur, &matLocal);
                
                pvCenter->x += vTransformedCur.x;
                pvCenter->y += vTransformedCur.y;
                pvCenter->z += vTransformedCur.z;
            }
        }
        
        pmcCur->m_pMesh->GetVertexBuffer()->Unlock();
        pbPoints = NULL;
        
        pmcCur = pmcCur->m_pNext;
    }
    
    (*pdwNumVertices) += cVerticesLocal;
    
    SFrame* pCurrentFrame = pFrame->m_pChild;
    while( pCurrentFrame )
    {
        hr = CalculateSum( pCurrentFrame, &matLocal, pvCenter, pdwNumVertices );
        if( FAILED(hr) )
			return hr;
        
        pCurrentFrame = pCurrentFrame->m_pSibling;
    }
    
    return S_OK;
}




HRESULT CalculateRadius( SFrame* pFrame, D3DXMATRIX* pmatCur, D3DXVECTOR3* pvCenter, 
                         float* pfRadiusSq )
{
    HRESULT         hr = S_OK;
    PBYTE           pbPoints = NULL;
    PBYTE           pbCur;
    D3DXVECTOR3*    pvCur;
    D3DXVECTOR3     vDist;
    UINT            iPoint;
    UINT            dwNumVertices;
    float           fRadiusLocalSq;
    float           fDistSq;
    D3DXMATRIX      matLocal;
    
    D3DXMatrixMultiply( &matLocal, &pFrame->m_matRot, pmatCur );
    
    SMeshContainer* pmcCur = pFrame->m_pMeshContainer;
    fRadiusLocalSq = (*pfRadiusSq);
    while( pmcCur != NULL )
    {
        DWORD fvfsize = D3DXGetFVFVertexSize( pmcCur->m_pMesh->GetFVF() );
        
        dwNumVertices = pmcCur->m_pMesh->GetNumVertices();
        
        hr = pmcCur->m_pMesh->GetVertexBuffer()->Lock( 0, 0, (BYTE**)&pbPoints, 0 );
        if( FAILED(hr) )
			return hr;
        
        for( iPoint=0, pbCur = pbPoints; iPoint < dwNumVertices; iPoint++, pbCur += fvfsize )
        {
            pvCur = (D3DXVECTOR3*)pbCur;
            
            if ((pvCur->x == 0.0) && (pvCur->y == 0.0) && (pvCur->z == 0.0))
                continue;
            
            D3DXVec3TransformCoord( &vDist, pvCur, &matLocal );
            
            vDist -= (*pvCenter);
            
            fDistSq = D3DXVec3LengthSq( &vDist );
            
            if( fDistSq > fRadiusLocalSq )
                fRadiusLocalSq = fDistSq;
        }
        
        
        pmcCur->m_pMesh->GetVertexBuffer()->Unlock();
        pbPoints = NULL;
        
        pmcCur = pmcCur->m_pNext;
    }
    
    (*pfRadiusSq) = fRadiusLocalSq;
    
    SFrame* pCurrentFrame = pFrame->m_pChild;
    while( pCurrentFrame != NULL )
    {
        hr = CalculateRadius( pCurrentFrame, &matLocal, pvCenter, pfRadiusSq );
        if( FAILED(hr) )
            return hr;
        
        pCurrentFrame = pCurrentFrame->m_pSibling;
    }
    
    return S_OK;
}




HRESULT CalculateBoundingSphere( SDrawElement* pDrawElement )
{
    D3DXVECTOR3 vCenter(0,0,0);
    UINT        dwNumVertices = 0;
    float       fRadiusSq     = 0.0f;
    D3DXMATRIX  matCur;
    HRESULT     hr;
    
    D3DXMatrixIdentity( &matCur );
    hr = CalculateSum( pDrawElement->m_pRootFrame, &matCur, &vCenter, &dwNumVertices );
    if( FAILED(hr) )
	    return hr;
    
    if( dwNumVertices > 0 )
    {
        vCenter /= (float)dwNumVertices;
        
        D3DXMatrixIdentity( &matCur );
        hr = CalculateRadius( pDrawElement->m_pRootFrame, &matCur, &vCenter, &fRadiusSq );
        if( FAILED(hr) )
			return hr;
    }
    
    pDrawElement->m_fRadius = sqrtf( fRadiusSq );
    pDrawElement->m_vCenter = vCenter;
    return S_OK;
}




HRESULT CXBSkinnedMesh::FindBones( SFrame* pCurrentFrame, SDrawElement* pDrawElement )
{
    HRESULT hr;
    
    SMeshContainer* pMeshContainer = pCurrentFrame->m_pMeshContainer;
    while( pMeshContainer )
    {
        if( pMeshContainer->m_pSkinMesh )
        {
            char** pBoneName = pMeshContainer->m_pBoneNames;
            for( DWORD i = 0; i < pMeshContainer->m_pSkinMesh->GetNumBones(); i++ )
            {
                SFrame* pFrame = pDrawElement->FindFrame( pBoneName[i] );
                pMeshContainer->m_pBoneMatrix[i] = &pFrame->m_matCombined;
            }
        }
        pMeshContainer = pMeshContainer->m_pNext;
    }
    
    SFrame* pChildFrame = pCurrentFrame->m_pChild;
    while( pChildFrame )
    {
        hr = FindBones( pChildFrame, pDrawElement );
        if( FAILED(hr) )
            return hr;
        
        pChildFrame = pChildFrame->m_pSibling;
    }
    
    return S_OK;
}




HRESULT CXBSkinnedMesh::LoadMeshHierarchy( CHAR* strMesh, CXBPackedResource* pResource )
{
    SDrawElement*           pdeMesh    = NULL;
    HRESULT                 hr         = S_OK;
    LPDIRECTXFILE           pxofapi    = NULL;
    LPDIRECTXFILEENUMOBJECT pxofenum   = NULL;
    LPDIRECTXFILEDATA       pxofobjCur = NULL;
    int                     cchFileName;

	g_pResource = pResource;

    if( strMesh == NULL )
        return E_INVALIDARG;
    
    pdeMesh = new SDrawElement();
    
    delete pdeMesh->m_pRootFrame;
    pdeMesh->m_pframeAnimHead = NULL;
    
    pdeMesh->m_pRootFrame = new SFrame();
    if( pdeMesh->m_pRootFrame == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
        
    cchFileName = strlen( strMesh );
    if( cchFileName < 2 )
    {
        hr = E_FAIL;
        goto e_Exit;
    }
    
    hr = DirectXFileCreate( &pxofapi );
    if( FAILED(hr) )
        goto e_Exit;
    
    // Register templates for d3drm.
    hr = pxofapi->RegisterTemplates( (VOID*)D3DRM_XTEMPLATES, D3DRM_XTEMPLATE_BYTES );
    if( FAILED(hr) )
        goto e_Exit;
    
    // Create enum object.
    hr = pxofapi->CreateEnumObject( (VOID*)strMesh, DXFILELOAD_FROMFILE, &pxofenum );
    if( FAILED(hr) )
        goto e_Exit;
        
    // Enumerate top level objects.
    // Top level objects are always data object.
    while( SUCCEEDED( pxofenum->GetNextDataObject( &pxofobjCur ) ) )
    {
        hr = LoadFrames( pxofobjCur, pdeMesh, m_dwFVF, pdeMesh->m_pRootFrame );
        SAFE_RELEASE( pxofobjCur );
        
        if( FAILED(hr) )
            goto e_Exit;
    }
    
    hr = FindBones(pdeMesh->m_pRootFrame, pdeMesh);
    if( FAILED(hr) )
        goto e_Exit;
    
    delete []pdeMesh->m_strName;
    pdeMesh->m_strName = new char[cchFileName+1];
    if (pdeMesh->m_strName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    memcpy(pdeMesh->m_strName, strMesh, cchFileName+1);

    // delete the current mesh, now that the load has succeeded
    DeleteSelectedMesh();

    // link into the draw list
    pdeMesh->m_pNext = m_pdeHead;
    m_pdeHead = pdeMesh;
    
    m_pdeSelected = pdeMesh;
    m_pmcSelectedMesh = pdeMesh->m_pRootFrame->m_pMeshContainer;
    
    
    m_pframeSelected = pdeMesh->m_pRootFrame;
    
    hr = CalculateBoundingSphere(pdeMesh);
    if( FAILED(hr) )
        goto e_Exit;
    
    m_pdeSelected->m_fCurrentTime = 0.0f;
    m_pdeSelected->m_fMaxTime     = 200.0f;
    
    D3DXMatrixTranslation( &m_pdeSelected->m_pRootFrame->m_matRot,
                           -pdeMesh->m_vCenter.x, 
						   -pdeMesh->m_vCenter.y, 
						   -pdeMesh->m_vCenter.z );
    m_pdeSelected->m_pRootFrame->m_matRotOrig = m_pdeSelected->m_pRootFrame->m_matRot;
    
e_Exit:
    SAFE_RELEASE( pxofobjCur );
    SAFE_RELEASE( pxofenum );
    SAFE_RELEASE( pxofapi );
    
    if( FAILED(hr) )
        delete pdeMesh;
    
    return hr;
}




HRESULT CXBSkinnedMesh::LoadAnimation( LPDIRECTXFILEDATA pxofobjCur, SDrawElement* pDrawElement,
                                       DWORD dwFVF, SFrame* pParentFrame )
{
    SFrame*             pCurrentFrame;
    LPDIRECTXFILEDATA   pxofobjChild = NULL;
    LPDIRECTXFILEOBJECT pxofChild = NULL;
    LPDIRECTXFILEDATAREFERENCE pxofobjChildRef = NULL;
    const GUID*         type;
    DWORD   dwSize;
    PBYTE   pData;
    DWORD   dwKeyType;
    DWORD   dwNumKeys;
    DWORD   iKey;
    DWORD   cchName;
    char*   strFrameName;
    HRESULT hr = S_OK;
    
    pCurrentFrame = new SFrame();
    if( pCurrentFrame == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    pCurrentFrame->m_bAnimationFrame = true;
    
    pParentFrame->AddFrame( pCurrentFrame );
    pDrawElement->AddAnimationFrame( pCurrentFrame );
    
    // Enumerate child objects.
    // Child object can be data, data reference or binary.
    // Use QueryInterface() to find what type of object a child is.
    while( SUCCEEDED(pxofobjCur->GetNextObject( &pxofChild ) ) )
    {
        // Query the child for it's FileDataReference
        hr = pxofChild->QueryInterface( IID_IDirectXFileDataReference,
                                        (VOID**)&pxofobjChildRef );
        if (SUCCEEDED(hr))
        {
            hr = pxofobjChildRef->Resolve( &pxofobjChild );
            if( SUCCEEDED(hr) )
            {
                hr = pxofobjChild->GetType( &type );
                if( FAILED(hr) )
                    goto e_Exit;
                
                if( TID_D3DRMFrame == (*type) )
                {
                    if( pCurrentFrame->m_pframeToAnimate != NULL )
                    {
                        hr = E_INVALIDARG;
                        goto e_Exit;
                    }
                    
                    hr = pxofobjChild->GetName( NULL, &cchName );
                    if( FAILED(hr) )
                        goto e_Exit;
                    
                    if( cchName == 0 )
                    {
                        hr = E_INVALIDARG;
                        goto e_Exit;
                        
                    }
                    
                    strFrameName = (char*)_alloca( cchName );
                    if( strFrameName == NULL )
                    {
                        hr = E_OUTOFMEMORY;
                        goto e_Exit;
                    }
                    
                    hr = pxofobjChild->GetName( strFrameName, &cchName );
                    if( FAILED(hr) )
                        goto e_Exit;
                    
                    pCurrentFrame->m_pframeToAnimate = pDrawElement->FindFrame( strFrameName );
                    if( pCurrentFrame->m_pframeToAnimate == NULL )
                    {
                        hr = E_INVALIDARG;
                        goto e_Exit;
                    }
                }
                
                SAFE_RELEASE( pxofobjChild );
            }
            
            SAFE_RELEASE( pxofobjChildRef );
        }
        else
        {
            // Query the child for it's FileData
            hr = pxofChild->QueryInterface( IID_IDirectXFileData,
                                            (VOID**)&pxofobjChild );
            if( SUCCEEDED(hr) )
            {
                hr = pxofobjChild->GetType( &type );
                if( FAILED(hr) )
                    goto e_Exit;
                
                if( TID_D3DRMFrame == (*type) )
                {
                    hr = LoadFrames( pxofobjChild, pDrawElement, dwFVF, pCurrentFrame );
                    if( FAILED(hr) )
                        goto e_Exit;
                }
                else if( TID_D3DRMAnimationOptions == (*type) )
                {
                    //ParseAnimOptions(pChildData,pParentFrame);
                    //i=2;
                }
                else if( TID_D3DRMAnimationKey == (*type) )
                {
                    hr = pxofobjChild->GetData( NULL, &dwSize, (VOID**)&pData );
                    if( FAILED(hr) )
                        goto e_Exit;
                    
                    dwKeyType = ((DWORD*)pData)[0];
                    dwNumKeys = ((DWORD*)pData)[1];
                    
                    if( dwKeyType == 0 )
                    {
                        if( pCurrentFrame->m_pRotateKeys != NULL )
                        {
                            hr = E_INVALIDARG;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_pRotateKeys = new ROTATE_KEY[dwNumKeys];
                        if (pCurrentFrame->m_pRotateKeys == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_dwNumRotateKeys = dwNumKeys;
                        
						struct XFILE_ROTATEKEY
						{
							DWORD dwTime;
							DWORD dwFloats;	
							float w, x, y, z; // NOTE: x files quaternions are w x y z, 
							                  //       but D3DX quaternions are x y z w
						};

					    XFILE_ROTATEKEY* pFileRotateKey = (XFILE_ROTATEKEY*)(pData + (sizeof(DWORD) * 2));
                        for( iKey = 0;iKey < dwNumKeys; iKey++ )
                        {
                            pCurrentFrame->m_pRotateKeys[iKey].dwTime = pFileRotateKey->dwTime;
                            pCurrentFrame->m_pRotateKeys[iKey].quatRotate.x = pFileRotateKey->x;
                            pCurrentFrame->m_pRotateKeys[iKey].quatRotate.y = pFileRotateKey->y;
                            pCurrentFrame->m_pRotateKeys[iKey].quatRotate.z = pFileRotateKey->z;
                            pCurrentFrame->m_pRotateKeys[iKey].quatRotate.w = pFileRotateKey->w;
                            
                            pFileRotateKey += 1;
                        }
                    }
                    else if( dwKeyType == 1 )
                    {
                        if (pCurrentFrame->m_pScaleKeys != NULL)
                        {
                            hr = E_INVALIDARG;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_pScaleKeys = new SCALE_KEY[dwNumKeys];
                        if (pCurrentFrame->m_pScaleKeys == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_dwNumScaleKeys = dwNumKeys;
                        
						struct XFILE_SCALEKEY
						{
							DWORD	    dwTime;
							DWORD	    dwFloats;	
							D3DXVECTOR3	vScale;	
						};

					    XFILE_SCALEKEY* pFileScaleKey = (XFILE_SCALEKEY*)(pData + (sizeof(DWORD) * 2));
                        for( iKey = 0;iKey < dwNumKeys; iKey++ )
                        {
                            pCurrentFrame->m_pScaleKeys[iKey].dwTime = pFileScaleKey->dwTime;
                            pCurrentFrame->m_pScaleKeys[iKey].vScale = pFileScaleKey->vScale;
                            
                            pFileScaleKey += 1;
                        }
                    }
                    else if( dwKeyType == 2 )
                    {
                        if (pCurrentFrame->m_pPositionKeys != NULL)
                        {
                            hr = E_INVALIDARG;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_pPositionKeys = new POSITION_KEY[dwNumKeys];
                        if (pCurrentFrame->m_pPositionKeys == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_dwNumPositionKeys = dwNumKeys;
                        
						struct XFILE_POSITIONKEY
						{
							DWORD	    dwTime;
							DWORD	    dwFloats;	
							D3DXVECTOR3	vPos;	
						};

					    XFILE_POSITIONKEY* pFilePosKey = (XFILE_POSITIONKEY*)(pData + (sizeof(DWORD) * 2));
                        for( iKey = 0;iKey < dwNumKeys; iKey++ )
                        {
                            pCurrentFrame->m_pPositionKeys[iKey].dwTime = pFilePosKey->dwTime;
                            pCurrentFrame->m_pPositionKeys[iKey].vPos = pFilePosKey->vPos;
                            
                            pFilePosKey += 1;
                        }
                    }
                    else if( dwKeyType == 4 )
                    {
                        if( pCurrentFrame->m_pMatrixKeys != NULL )
                        {
                            hr = E_INVALIDARG;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_pMatrixKeys = new MATRIX_KEY[dwNumKeys];
                        if( pCurrentFrame->m_pMatrixKeys == NULL )
                        {
                            hr = E_OUTOFMEMORY;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_dwNumMatrixKeys = dwNumKeys;
                        
						struct XFILE_MATRIXKEY
						{
							DWORD	    dwTime;
							DWORD	    dwFloats;	
							FLOAT       mat[4][4];
						};
					    XFILE_MATRIXKEY* pFileMatrixKey = (XFILE_MATRIXKEY*)(pData + (sizeof(DWORD) * 2));

                        for( iKey = 0;iKey < dwNumKeys; iKey++ )
                        {
                            pCurrentFrame->m_pMatrixKeys[iKey].dwTime = pFileMatrixKey->dwTime;
                            memcpy( &pCurrentFrame->m_pMatrixKeys[iKey].mat, &pFileMatrixKey->mat, sizeof(D3DXMATRIX) );
                            pFileMatrixKey++;
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                        goto e_Exit;
                    }
                }
                
                SAFE_RELEASE(pxofobjChild);
            }
        }
        
        SAFE_RELEASE(pxofChild);
    }
    
e_Exit:
    SAFE_RELEASE(pxofobjChild);
    SAFE_RELEASE(pxofChild);
    SAFE_RELEASE(pxofobjChildRef);
    return hr;
}




HRESULT CXBSkinnedMesh::LoadAnimationSet( LPDIRECTXFILEDATA pxofobjCur, SDrawElement* pDrawElement,
                                          DWORD dwFVF, SFrame* pParentFrame )
{
    SFrame* pCurrentFrame;
    const GUID* type;
    HRESULT hr = S_OK;
    LPDIRECTXFILEDATA pxofobjChild = NULL;
    LPDIRECTXFILEOBJECT pxofChild = NULL;
    DWORD cchName;
    
    pCurrentFrame = new SFrame();
    if( pCurrentFrame == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    pCurrentFrame->m_bAnimationFrame = true;
    
    pParentFrame->AddFrame( pCurrentFrame );
    
    hr = pxofobjCur->GetName( NULL, &cchName );
    if( FAILED(hr) )
        goto e_Exit;
    
    if (cchName > 0)
    {
        pCurrentFrame->m_strName = new char[cchName];
        if( pCurrentFrame->m_strName == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
        
        hr = pxofobjCur->GetName( pCurrentFrame->m_strName, &cchName );
        if( FAILED(hr) )
            goto e_Exit;
    }
    
    // Enumerate child objects.
    // Child object can be data, data reference or binary.
    // Use QueryInterface() to find what type of object a child is.
    while( SUCCEEDED( pxofobjCur->GetNextObject( &pxofChild ) ) )
    {
        // Query the child for it's FileData
        hr = pxofChild->QueryInterface( IID_IDirectXFileData,
                                        (VOID**)&pxofobjChild );
        if (SUCCEEDED(hr))
        {
            hr = pxofobjChild->GetType( &type );
            if( FAILED(hr) )
                goto e_Exit;
            
            if( TID_D3DRMAnimation == (*type) )
            {
                hr = LoadAnimation( pxofobjChild, pDrawElement, dwFVF, pCurrentFrame );
                if( FAILED(hr) )
                    goto e_Exit;
            }
            
            SAFE_RELEASE( pxofobjChild );
        }
        
        SAFE_RELEASE( pxofChild );
    }
    
e_Exit:
    SAFE_RELEASE( pxofobjChild );
    SAFE_RELEASE( pxofChild );
    return hr;
}




HRESULT CXBSkinnedMesh::GenerateMesh( SMeshContainer* pMeshContainer )
{
    // ASSUMPTION:  pMeshContainer->m_rgiAdjacency contains the current adjacency

    HRESULT hr           = S_OK;
    DWORD   dwNumFaces   = pMeshContainer->m_pSkinMesh->GetNumFaces();
    DWORD*  pAdjacencyIn = new DWORD[pMeshContainer->m_pSkinMesh->GetNumFaces() * 3];

    if( pAdjacencyIn == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    
    memcpy( pAdjacencyIn, pMeshContainer->m_rgiAdjacency, dwNumFaces * 3 * sizeof(DWORD) );

    SAFE_RELEASE( pMeshContainer->m_pMesh );
    pMeshContainer->m_pMesh      = NULL;
    
    if( m_method == SKIN_NONINDEXED )
    {
        DWORD* rgiAdjacency = NULL;

        rgiAdjacency = new DWORD[dwNumFaces * 3];

        if( rgiAdjacency == NULL )
        {
            hr  = E_OUTOFMEMORY;
            goto e_ExitNONINDEXED;
        }

        hr = pMeshContainer->m_pSkinMesh->ConvertToOptimizedBlendedMesh( pAdjacencyIn, rgiAdjacency, 
                                                                         &pMeshContainer->m_dwNumBoneCombinations, 
																         &pMeshContainer->m_pBoneCombinations, 
																		 &pMeshContainer->m_pMesh );
        if( FAILED(hr) )
            goto e_ExitNONINDEXED;

        // Calculate the max face influence count
        if( (pMeshContainer->m_pMesh->GetFVF() & D3DFVF_POSITION_MASK) != D3DFVF_XYZ )
            pMeshContainer->m_dwMaxFaceInfluenceCount = 1 + ((pMeshContainer->m_pMesh->GetFVF() & D3DFVF_POSITION_MASK) - D3DFVF_XYZRHW) / 2;
        else
            pMeshContainer->m_dwMaxFaceInfluenceCount = 1;

e_ExitNONINDEXED:
        SAFE_DELETE_ARRAY( rgiAdjacency );

        if( FAILED(hr) )
            goto e_Exit;
    }
    else if( m_method == SKIN_INDEXED )
    {
        hr = pMeshContainer->m_pSkinMesh->ConvertToIndexedBlendedMesh( pAdjacencyIn, 255, 
			                                                           &pMeshContainer->m_dwNumBoneCombinations, 
																       &pMeshContainer->m_pBoneCombinations, 
																       &pMeshContainer->m_pMesh );
        if( FAILED(hr) )
            goto e_Exit;

        // Here we are talking of max vertex influence which we determine from 
        // the FVF of the returned mesh
        if( (pMeshContainer->m_pMesh->GetFVF() & D3DFVF_POSITION_MASK) != D3DFVF_XYZ )
        {
            pMeshContainer->m_dwMaxFaceInfluenceCount = ((pMeshContainer->m_pMesh->GetFVF() & D3DFVF_POSITION_MASK) - D3DFVF_XYZRHW) / 2;
        }
        else
        {
            pMeshContainer->m_dwMaxFaceInfluenceCount = 1;
        }
    }
    pMeshContainer->m_Method = m_method;

e_Exit:
    delete[] pAdjacencyIn;
    return hr;
}




HRESULT CXBSkinnedMesh::LoadMesh( LPDIRECTXFILEDATA pxofobjCur, DWORD dwFVF, 
							      SFrame* pParentFrame )
{
    SMeshContainer* pMeshContainer = NULL;
    DWORD   cchName;
    HRESULT hr;
    
    pMeshContainer = new SMeshContainer();
    if( pMeshContainer == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    
    hr = pxofobjCur->GetName( NULL, &cchName );
    if( FAILED(hr) )
        goto e_Exit;
    
    if( cchName > 0 )
    {
        pMeshContainer->m_strName = new char[cchName];
        if( pMeshContainer->m_strName == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
        
        hr = pxofobjCur->GetName( pMeshContainer->m_strName, &cchName );
        if( FAILED(hr) )
            goto e_Exit;
    }
    
    hr = XBoxLoadSkinMeshFromXof( pxofobjCur, m_pd3dDevice, g_pResource,
		                          &pMeshContainer->m_rgiAdjacency, 
		                          &pMeshContainer->m_dwNumMaterials, 
								  &pMeshContainer->m_pMaterials,
								  &pMeshContainer->m_pTextures,
						          &pMeshContainer->m_pBoneNames,
								  &pMeshContainer->m_pBoneOffsetMatrices,
								  &pMeshContainer->m_pSkinMesh );
    if( FAILED(hr) )
        goto e_Exit;
    
    // Process skinning data
    if( pMeshContainer->m_pSkinMesh->GetNumBones() )
    {
        pMeshContainer->m_pBoneMatrix = new D3DXMATRIX*[pMeshContainer->m_pSkinMesh->GetNumBones()];
        if( pMeshContainer->m_pBoneMatrix == NULL )
            goto e_Exit;

        hr = GenerateMesh( pMeshContainer );
        if( FAILED(hr) )
            goto e_Exit;
    }
    else
    {
        pMeshContainer->m_pSkinMesh->GetOriginalMesh(&(pMeshContainer->m_pMesh));
        pMeshContainer->m_pSkinMesh->Release();
        pMeshContainer->m_pSkinMesh = NULL;
        pMeshContainer->m_dwNumBoneCombinations    = pMeshContainer->m_dwNumMaterials;
    }
    
    // Add the mesh to the parent frame
    pParentFrame->AddMesh( pMeshContainer );
    pMeshContainer = NULL;
    
e_Exit:
    SAFE_DELETE( pMeshContainer );
    return hr;
}




HRESULT CXBSkinnedMesh::LoadFrames( LPDIRECTXFILEDATA pxofobjCur, SDrawElement* pDrawElement,
                                    DWORD dwFVF, SFrame* pParentFrame )
{
    HRESULT hr = S_OK;
    LPDIRECTXFILEDATA pxofobjChild = NULL;
    LPDIRECTXFILEOBJECT pxofChild = NULL;
    const GUID* type;
    DWORD cbSize;
    D3DXMATRIX* pmatNew;
    SFrame* pCurrentFrame;
    DWORD cchName;
    
    // Get the type of the object
    hr = pxofobjCur->GetType( &type );
    if( FAILED(hr) )
        goto e_Exit;
       
    if( *type == TID_D3DRMMesh )
    {
        hr = LoadMesh( pxofobjCur, dwFVF, pParentFrame );
        if( FAILED(hr) )
            goto e_Exit;
    }
    else if( *type == TID_D3DRMFrameTransformMatrix )
    {
        hr = pxofobjCur->GetData( NULL, &cbSize, (VOID**)&pmatNew );
        if( FAILED(hr) )
            goto e_Exit;
        
        // update the parents matrix with the new one
        pParentFrame->m_matRot     = (*pmatNew);
        pParentFrame->m_matRotOrig = (*pmatNew);
    }
    else if( *type == TID_D3DRMAnimationSet )
    {
        LoadAnimationSet( pxofobjCur, pDrawElement, dwFVF, pParentFrame );
    }
    else if( *type == TID_D3DRMAnimation )
    {
        LoadAnimation( pxofobjCur, pDrawElement, dwFVF, pParentFrame );
    }
    else if( *type == TID_D3DRMFrame )
    {
        pCurrentFrame = new SFrame();
        if( pCurrentFrame == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
        
        hr = pxofobjCur->GetName( NULL, &cchName );
        if( FAILED(hr) )
            goto e_Exit;
        
        if( cchName > 0 )
        {
            pCurrentFrame->m_strName = new char[cchName];
            if (pCurrentFrame->m_strName == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }
            
            hr = pxofobjCur->GetName( pCurrentFrame->m_strName, &cchName );
            if( FAILED(hr) )
                goto e_Exit;
        }
        
        pParentFrame->AddFrame( pCurrentFrame );
        
        // Enumerate child objects. Child objecta can be data, data reference
		// or binary. Use QueryInterface() to find what type it is.
        while( SUCCEEDED( pxofobjCur->GetNextObject( &pxofChild ) ) )
        {
            // Query the child for whether it is FileData
            hr = pxofChild->QueryInterface( IID_IDirectXFileData, (VOID**)&pxofobjChild );
            if( SUCCEEDED(hr) )
            {
                hr = LoadFrames( pxofobjChild, pDrawElement, dwFVF, pCurrentFrame );
                if( FAILED(hr) )
                    goto e_Exit;
                
                SAFE_RELEASE( pxofobjChild );
            }
            SAFE_RELEASE( pxofChild );
        }
    }
    
e_Exit:
    SAFE_RELEASE( pxofobjChild );
    SAFE_RELEASE( pxofChild );
    return hr;
}


         
                                      
HRESULT CXBSkinnedMesh::DeleteSelectedMesh()
{
    if( m_pdeSelected )
    {
        SDrawElement* pCurrent = m_pdeHead;
        SDrawElement* pPrev    = NULL;
        
		while( (pCurrent) && (pCurrent!=m_pdeSelected) )
        {
            pPrev    = pCurrent;
            pCurrent = pCurrent->m_pNext;
        }

        if( pPrev == NULL )
        {
            m_pdeHead = m_pdeHead->m_pNext;
        }
        else
        {
            pPrev->m_pNext = pCurrent->m_pNext;
        }

        m_pdeSelected->m_pNext = NULL;
        if( m_pdeHead == m_pdeSelected )
            m_pdeHead = NULL;
        delete m_pdeSelected;
        m_pdeSelected = NULL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh\Resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_TinySkin_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh\XboxMesh.cpp ===
//-----------------------------------------------------------------------------
// File: XBoxMesh.cpp
//
// Desc: 
//
// Copyright (C) Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <XBApp.h>
#include <XBFont.h>
#include <XBResource.h>
#include <XBUtil.h>
#include "XBoxMesh.h"


CXBoxMesh::CXBoxMesh()
{
	m_bInitialized = FALSE;

	m_dwFVF;
	m_pVB;
	m_pIB;
	m_dwNumVertices;
	m_dwNumIndices;
	m_dwVertexSize;
	m_AttribTable;
	m_dwAttribTableSize;
	m_pAttributeIds;
}




HRESULT CXBoxMesh::Initialize()
{
	if( m_bInitialized )
		return S_OK;
	
	m_bInitialized = TRUE;

	m_pD3DXMesh->GetVertexBuffer( &m_pVB );
	m_pD3DXMesh->GetIndexBuffer( &m_pIB );
	m_dwFVF         = m_pD3DXMesh->GetFVF();
	m_dwNumVertices = m_pD3DXMesh->GetNumVertices();
	m_dwNumIndices  = m_pD3DXMesh->GetNumFaces() * 3;
	m_dwVertexSize  = D3DXGetFVFVertexSize( m_dwFVF );

	m_pD3DXMesh->GetAttributeTable( NULL, &m_dwAttribTableSize );
	m_AttribTable = new D3DXATTRIBUTERANGE[max(1, m_dwAttribTableSize)];
	if( m_dwAttribTableSize > 0 )
		m_pD3DXMesh->GetAttributeTable( m_AttribTable, NULL );

	m_pD3DXMesh->LockAttributeBuffer( D3DLOCK_READONLY, &m_pAttributeIds );

	return S_OK;
}

	
	
	
HRESULT CXBoxMesh::DrawSubset( DWORD i )
{
	if( FALSE == m_bInitialized )
		Initialize();

    if( m_pVB == NULL )
		return S_OK;

    // If present in the table, then draw it
    if( i < m_dwAttribTableSize && m_AttribTable[i].FaceCount > 0 )
    {
		g_pd3dDevice->SetVertexShader( m_dwFVF);
		g_pd3dDevice->SetStreamSource( 0, m_pVB, m_dwVertexSize );
		g_pd3dDevice->SetIndices( m_pIB, 0 );
        g_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 
                                            m_AttribTable[i].VertexStart, m_AttribTable[i].VertexCount,
                                            m_AttribTable[i].FaceStart * 3, m_AttribTable[i].FaceCount );
    }

    return S_OK;
}




DWORD CXBoxMesh::Release()
{
	return S_OK;
}




CXBoxSkinMesh::CXBoxSkinMesh()
{
	m_bInitialized = FALSE;
}




HRESULT CXBoxSkinMesh::Initialize()
{
	if( m_bInitialized )
		return S_OK;
	
	m_dwNumIndices = m_pD3DXSkinMesh->GetNumFaces() * 3;
	m_dwNumBones   = m_pD3DXSkinMesh->GetNumBones();
	m_bInitialized = TRUE;

	return S_OK;
}




DWORD CXBoxSkinMesh::Release()
{
	return S_OK;
}




HRESULT CXBoxSkinMesh::GetOriginalMesh( CXBoxMesh** ppMesh )
{
	ID3DXMesh* pLocalMesh;
	HRESULT hr = m_pD3DXSkinMesh->GetOriginalMesh( &pLocalMesh );

	(*ppMesh) = new CXBoxMesh();
	(*ppMesh)->m_pD3DXMesh = pLocalMesh;
	(*ppMesh)->Initialize();

	return S_OK;
}





HRESULT CXBoxSkinMesh::ConvertToOptimizedBlendedMesh( DWORD* pAdjacencyIn, DWORD* pAdjacencyOut, 
                                                      DWORD* pdwNumBoneCombinations,
 										              BONECOMBINATION** ppBoneCombinations, 
							                          CXBoxMesh** ppMesh )
{
	ID3DXMesh* pLocalMesh;
	ID3DXBuffer* pBoneCombinationBuffer;

	HRESULT hr = m_pD3DXSkinMesh->ConvertToBlendedMesh( 0, pAdjacencyIn, pAdjacencyOut, 
                                                        pdwNumBoneCombinations, &pBoneCombinationBuffer, 
											            &pLocalMesh );

	// Extract bones combinations from buffer
	{
		BONECOMBINATION* pSrcBuffer = (BONECOMBINATION*)pBoneCombinationBuffer->GetBufferPointer();
		BONECOMBINATION* pDstBuffer = (BONECOMBINATION*)new BYTE[pBoneCombinationBuffer->GetBufferSize()];
		memcpy( pDstBuffer, pSrcBuffer, pBoneCombinationBuffer->GetBufferSize() );

		// Pointer fixup
		for( DWORD i=0; i<(*pdwNumBoneCombinations); i++ )
			pDstBuffer[i].BoneId = (DWORD*)( (long)pDstBuffer[i].BoneId + (long)pDstBuffer - (long)pSrcBuffer );
		
		(*ppBoneCombinations) = pDstBuffer;
		pBoneCombinationBuffer->Release();
	}
	
    // Vertex cache optimize the mesh
    ID3DXMesh* pLocalMeshOpt;
    hr = pLocalMesh->Optimize( D3DXMESHOPT_VERTEXCACHE, pAdjacencyOut,
			                   NULL, NULL, NULL, &pLocalMeshOpt );
    if( SUCCEEDED(hr) )
    {
		pLocalMesh->Release();
		pLocalMesh = pLocalMeshOpt;
    }

	(*ppMesh) = new CXBoxMesh();
	(*ppMesh)->m_pD3DXMesh = pLocalMesh;
	(*ppMesh)->Initialize();

	return S_OK;
}




HRESULT CXBoxSkinMesh::ConvertToIndexedBlendedMesh( DWORD* pAdjacencyIn, DWORD dwPaletteSize,
		                      DWORD* pdwNumBoneCombinations,
							  BONECOMBINATION** ppBoneCombinations, 
							  CXBoxMesh** ppMesh )
{
	ID3DXMesh*   pLocalMesh;
	ID3DXBuffer* pBoneCombinationBuffer;

	HRESULT hr = m_pD3DXSkinMesh->ConvertToIndexedBlendedMesh( D3DXMESH_SYSTEMMEM, pAdjacencyIn, dwPaletteSize,
		                                                       NULL, pdwNumBoneCombinations, 
													           &pBoneCombinationBuffer, 
													           &pLocalMesh );

	// Extract bones combinations from buffer
	{
		BONECOMBINATION* pSrcBuffer = (BONECOMBINATION*)pBoneCombinationBuffer->GetBufferPointer();
		BONECOMBINATION* pDstBuffer = (BONECOMBINATION*)new BYTE[pBoneCombinationBuffer->GetBufferSize()];
		memcpy( pDstBuffer, pSrcBuffer, pBoneCombinationBuffer->GetBufferSize() );

		// Pointer fixup
		for( DWORD i=0; i<(*pdwNumBoneCombinations); i++ )
			pDstBuffer[i].BoneId = (DWORD*)( (long)pDstBuffer[i].BoneId + (long)pDstBuffer - (long)pSrcBuffer );
		
		(*ppBoneCombinations) = pDstBuffer;
		pBoneCombinationBuffer->Release();
	}
	
	(*ppMesh) = new CXBoxMesh();
	(*ppMesh)->m_pD3DXMesh = pLocalMesh;
	(*ppMesh)->Initialize();

	return S_OK;
}




HRESULT XBoxLoadSkinMeshFromXof( LPDIRECTXFILEDATA pxofobjMesh, LPDIRECT3DDEVICE8 pd3dDevice, 
								 CXBPackedResource* pResource, DWORD** ppAdjacency,
                                 DWORD* pdwNumMaterials, 
                                 D3DMATERIAL8** ppMaterialArray, LPDIRECT3DTEXTURE8** ppTextureArray,
								 CHAR*** pppBoneNames, D3DXMATRIX** ppBoneTransforms,
								 CXBoxSkinMesh** ppMesh )
{
	ID3DXSkinMesh* pLocalSkinMesh;
	ID3DXBuffer*   pBoneNamesBuffer;
	ID3DXBuffer*   pBoneTransformsBuffer;
	ID3DXBuffer*   pAdjacencyBuffer;
	ID3DXBuffer*   pMaterialBuffer;

	HRESULT hr = D3DXLoadSkinMeshFromXof( pxofobjMesh, 0, pd3dDevice, &pAdjacencyBuffer,
                                          &pMaterialBuffer, pdwNumMaterials, &pBoneNamesBuffer, 
										  &pBoneTransformsBuffer, &pLocalSkinMesh );

	DWORD dwNumBones = pLocalSkinMesh->GetNumBones();

	// Extract adjacency array from buffer
	{
		DWORD* pSrcBuffer = (DWORD*)pAdjacencyBuffer->GetBufferPointer();
		DWORD* pDstBuffer = (DWORD*)new BYTE[pAdjacencyBuffer->GetBufferSize()];
		memcpy( pDstBuffer, pSrcBuffer, pAdjacencyBuffer->GetBufferSize() );

		(*ppAdjacency) = pDstBuffer;
		pAdjacencyBuffer->Release();
	}

	// Extract bones names from buffer
	{
		CHAR** pSrcBuffer = (CHAR**)pBoneNamesBuffer->GetBufferPointer();
		CHAR** pDstBuffer = (CHAR**)new BYTE[pBoneNamesBuffer->GetBufferSize()];
		memcpy( pDstBuffer, pSrcBuffer, pBoneNamesBuffer->GetBufferSize() );

		// Pointer fixup
		for( DWORD i=0; i<dwNumBones; i++ )
			pDstBuffer[i] = (CHAR*)( (long)pDstBuffer[i] + (long)pDstBuffer - (long)pSrcBuffer );
		
		(*pppBoneNames) = pDstBuffer;
		pBoneNamesBuffer->Release();
	}

	// Extract bones transforms from buffer
	{
		D3DXMATRIX* pSrcBuffer = (D3DXMATRIX*)pBoneTransformsBuffer->GetBufferPointer();
		D3DXMATRIX* pDstBuffer = (D3DXMATRIX*)new BYTE[pBoneTransformsBuffer->GetBufferSize()];
		memcpy( pDstBuffer, pSrcBuffer, pBoneTransformsBuffer->GetBufferSize() );
		
		(*ppBoneTransforms) = pDstBuffer;
		pBoneTransformsBuffer->Release();
	}

	// Extract textures
	{
		if( (*pdwNumMaterials) == 0 )
		{
			(*pdwNumMaterials) = 1;
			D3DMATERIAL8*       pMaterials = new D3DMATERIAL8[(*pdwNumMaterials)];
			LPDIRECT3DTEXTURE8* pTextures  = new LPDIRECT3DTEXTURE8[(*pdwNumMaterials)];

			ZeroMemory( &pMaterials[0], sizeof(D3DMATERIAL8) );
			pMaterials[0].Diffuse.r = 0.5f;
			pMaterials[0].Diffuse.g = 0.5f;
			pMaterials[0].Diffuse.b = 0.5f;
			pMaterials[0].Specular  = pMaterials[0].Diffuse;
			pTextures[0]            = NULL;

			(*ppMaterialArray) = pMaterials;
			(*ppTextureArray) = pTextures;
	    }
		else
		{
			D3DXMATERIAL* pSrcBuffer = (D3DXMATERIAL*)pMaterialBuffer->GetBufferPointer();
			
			D3DMATERIAL8*       pMaterials = new D3DMATERIAL8[(*pdwNumMaterials)];
			LPDIRECT3DTEXTURE8* pTextures  = new LPDIRECT3DTEXTURE8[(*pdwNumMaterials)];
			
			for( DWORD i=0; i<(*pdwNumMaterials); i++ )
			{
				memcpy( &pMaterials[i], &pSrcBuffer[i].MatD3D, sizeof(D3DMATERIAL8) );

				if( pResource && pSrcBuffer[i].pTextureFilename )
					pTextures[i] = pResource->GetTexture( pSrcBuffer[i].pTextureFilename );
				else
					pTextures[i] = NULL;
			}

			(*ppMaterialArray) = pMaterials;
			(*ppTextureArray) = pTextures;

			pMaterialBuffer->Release();
		}
	}

	(*ppMesh) = new CXBoxSkinMesh;
	(*ppMesh)->m_pD3DXSkinMesh = pLocalSkinMesh;
	(*ppMesh)->Initialize();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh2\Resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_TinySkin_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh\XBoxMesh.h ===
//-----------------------------------------------------------------------------
// File: XBoxMesh.h
//
// Desc: 
//
// Copyright (C) Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef XBOXMESH_H
#define XBOXMESH_H


struct BONECOMBINATION
{
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
    DWORD* BoneId;
};




class CXBoxMesh
{
	BOOL       m_bInitialized;
	DWORD      m_dwFVF;
	LPDIRECT3DVERTEXBUFFER8 m_pVB;
	LPDIRECT3DINDEXBUFFER8  m_pIB;
	DWORD      m_dwNumVertices;
	DWORD      m_dwNumIndices;
	DWORD      m_dwVertexSize;
	D3DXATTRIBUTERANGE* m_AttribTable;
	DWORD      m_dwAttribTableSize;
	DWORD*     m_pAttributeIds;

public:
	CXBoxMesh();
	HRESULT Initialize();
	ID3DXMesh* m_pD3DXMesh;

public:
	LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer() { return m_pVB; }
	LPDIRECT3DINDEXBUFFER8  GetIndexBuffer()  { return m_pIB; }
	DWORD    GetNumFaces()    { return m_dwNumIndices/3; }
	DWORD    GetNumVertices() { return m_dwNumVertices; }
	DWORD    GetFVF()         { return m_dwFVF; }

	HRESULT  DrawSubset( DWORD i );
	
	DWORD    Release();
};

struct CXBoxSkinMesh
{
	DWORD m_dwNumIndices;
	DWORD m_dwNumBones;

	BOOL  m_bInitialized;

public:
	CXBoxSkinMesh();
	HRESULT Initialize();
	ID3DXSkinMesh* m_pD3DXSkinMesh;
public:
	DWORD    GetNumFaces() { return m_dwNumIndices/3; }
	DWORD    GetNumBones() { return m_dwNumBones; }

	HRESULT  GetOriginalMesh( CXBoxMesh** ppMesh );
	HRESULT  ConvertToOptimizedBlendedMesh( DWORD* pAdjacencyIn, DWORD* pAdjacencyOut, 
                                            DWORD* pdwNumBoneCombinations, 
											BONECOMBINATION** ppBoneCombinations, 
								            CXBoxMesh** ppMesh );
	HRESULT  ConvertToIndexedBlendedMesh( DWORD* pAdjacencyIn, DWORD dwPaletteSize,
		                                  DWORD* pdwNumBoneCombinations, 
										  BONECOMBINATION** ppBoneCombinations, 
								          CXBoxMesh** ppMesh );
	DWORD    Release();
};


HRESULT XBoxLoadSkinMeshFromXof( LPDIRECTXFILEDATA pxofobjMesh, LPDIRECT3DDEVICE8 pd3dDevice, 
								 CXBPackedResource* pResource, DWORD** ppAdjacency,
								 DWORD* pdwNumMaterials,
                                 D3DMATERIAL8** ppMaterialArray, LPDIRECT3DTEXTURE8** ppTextureArray,
								 CHAR*** pppBoneNames, D3DXMATRIX** ppBoneTransforms,
								 CXBoxSkinMesh** ppMesh );


#endif // XBOXMESH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh\XBSkinnedMesh.h ===
//-----------------------------------------------------------------------------
// File: XBSkinnedMesh.h
//
// Desc: 
//
// Copyright (C) Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef XBSKINNEDMESH_H
#define XBSKINNEDMESH_H

#include "XBoxMesh.h"


enum SKINNING_METHOD
{
    SKIN_NONINDEXED,
    SKIN_INDEXED,
};


struct SMeshContainer
{
    CXBoxMesh*           m_pMesh;
    SMeshContainer*      m_pNext;
    char*                m_strName;

    D3DMATERIAL8*        m_pMaterials;
    LPDIRECT3DTEXTURE8*  m_pTextures;
    DWORD                m_dwNumBoneCombinations;
    DWORD                m_dwNumMaterials;

    // Skin info
    CXBoxSkinMesh*       m_pSkinMesh;
    D3DXMATRIX**         m_pBoneMatrix;
    CHAR**               m_pBoneNames;
	D3DXMATRIX*          m_pBoneOffsetMatrices;
    DWORD*               m_rgiAdjacency;
    DWORD                m_dwMaxFaceInfluenceCount;
    BONECOMBINATION*     m_pBoneCombinations;
    
	SKINNING_METHOD      m_Method;

	SMeshContainer()
	{
		m_pMesh          = NULL;
		m_pMaterials     = NULL;
		m_pTextures      = NULL;
		m_dwNumBoneCombinations         = 0;
		m_dwNumMaterials = 0;
		m_pNext          = NULL;
		m_strName        = NULL;
		m_pSkinMesh      = NULL;
		m_pBoneMatrix    = NULL;
		m_pBoneNames     = NULL;
		m_pBoneOffsetMatrices = NULL;
		m_rgiAdjacency   = NULL;
		m_dwMaxFaceInfluenceCount = 0;
		m_pBoneCombinations = NULL;
		m_Method         = SKIN_NONINDEXED;
	}

	~SMeshContainer()
	{
        SAFE_DELETE_ARRAY( m_pMaterials );
        SAFE_DELETE_ARRAY( m_pTextures );

		SAFE_RELEASE( m_pMesh );
        SAFE_RELEASE( m_pSkinMesh );
        SAFE_DELETE_ARRAY( m_pBoneNames );
        SAFE_DELETE_ARRAY( m_pBoneOffsetMatrices );
		SAFE_DELETE_ARRAY( m_pBoneCombinations );
		
        SAFE_DELETE_ARRAY( m_pBoneMatrix );
        SAFE_DELETE_ARRAY( m_strName );
        SAFE_DELETE_ARRAY( m_rgiAdjacency );
        SAFE_DELETE( m_pNext );
	}
};


// in memory versions
struct ROTATE_KEY
{
	DWORD			dwTime;
	D3DXQUATERNION	quatRotate;	
};


struct POSITION_KEY
{
	DWORD	    dwTime;
	D3DXVECTOR3	vPos;	
};


struct SCALE_KEY
{
	DWORD	    dwTime;
	D3DXVECTOR3	vScale;	
};


struct MATRIX_KEY
{
	DWORD	    dwTime;
	D3DXMATRIX	mat;	
};


struct SFrame
{
    SMeshContainer* m_pMeshContainer;
    D3DXMATRIX      m_matRot;
    D3DXMATRIX      m_matTrans;
    D3DXMATRIX      m_matRotOrig;
    D3DXMATRIX      m_matCombined;

    // animation information
    POSITION_KEY*   m_pPositionKeys;
    UINT            m_dwNumPositionKeys;
    ROTATE_KEY*     m_pRotateKeys;
    UINT            m_dwNumRotateKeys;
    SCALE_KEY*      m_pScaleKeys;
    UINT            m_dwNumScaleKeys;
    MATRIX_KEY*     m_pMatrixKeys;
    UINT            m_dwNumMatrixKeys;

    SFrame*         m_pframeAnimNext;
    SFrame*         m_pframeToAnimate;

    SFrame*         m_pSibling;
    SFrame*         m_pChild;

    bool            m_bAnimationFrame;
    char*           m_strName;

    SFrame()
	{
		m_pMeshContainer   = NULL;
		m_pPositionKeys    = NULL;
		m_dwNumPositionKeys = 0;
		m_pScaleKeys       = NULL;
		m_dwNumScaleKeys   = 0;
		m_pRotateKeys      = NULL;
		m_dwNumRotateKeys  = 0;
		m_pMatrixKeys      = NULL;
		m_dwNumMatrixKeys  = 0;
		m_pframeAnimNext   = NULL;
		m_pframeToAnimate  = NULL;
		m_pSibling         = NULL;
		m_pChild           = NULL;
		m_bAnimationFrame  = false;
		m_strName          = NULL;
        D3DXMatrixIdentity( &m_matRot );
        D3DXMatrixIdentity( &m_matRotOrig );
        D3DXMatrixIdentity( &m_matTrans );
    }

    ~SFrame()
    {
        delete[] m_strName;
        delete   m_pMeshContainer;        
        delete   m_pChild;
        delete   m_pSibling;

        delete[] m_pPositionKeys;
        delete[] m_pRotateKeys;
        delete[] m_pScaleKeys;
        delete[] m_pMatrixKeys;

        // Do NOT delete m_pframeAnimNext
        // Do NOT delete m_pframeToAnimate
    }

    void SetTime( float fTime );

    SFrame* FindFrame( char* strFrame )
    {
        SFrame* pFrame;

        if( m_strName && (strcmp(m_strName, strFrame)==0) )
            return this;

        if( m_pChild )
        {
            pFrame = m_pChild->FindFrame( strFrame );
            if( pFrame )
                return pFrame;
        }

        if( m_pSibling )
        {
            pFrame = m_pSibling->FindFrame( strFrame );
            if( pFrame )
                return pFrame;
        }

        return NULL;
    }

    void ResetMatrix()
    {
        m_matRot = m_matRotOrig;
        D3DXMatrixIdentity( &m_matTrans );

        if( m_pChild )
            m_pChild->ResetMatrix();

        if( m_pSibling )
            m_pSibling->ResetMatrix();
    }

    void AddFrame( SFrame* pFrame )
    {
        if( m_pChild == NULL )
        {
            m_pChild = pFrame;
        }
        else
        {
            pFrame->m_pSibling = m_pChild->m_pSibling;
            m_pChild->m_pSibling = pFrame;
        }
    }

    void AddMesh( SMeshContainer* pmc )
    {
        pmc->m_pNext = m_pMeshContainer;
        m_pMeshContainer = pmc;
    }
};


struct SDrawElement
{
    SFrame*       m_pRootFrame;

    D3DXVECTOR3   m_vCenter;
    float         m_fRadius;

	// Name of element for selection purposes
	char*         m_strName;

    // Animation list
    SFrame*       m_pframeAnimHead;

	// Next element in list
	SDrawElement* m_pNext;

    float         m_fCurrentTime;
    float         m_fMaxTime;

	SDrawElement()
	{
		m_vCenter        = D3DXVECTOR3(0.0f,0.0f,0.0f);
		m_fRadius        = 1.0f;
		m_strName        = NULL;
        m_pRootFrame     = NULL;
        m_pframeAnimHead = NULL;
		m_pNext          = NULL;
	}

	~SDrawElement()
	{
        delete   m_pRootFrame;
		delete   m_pNext;
        delete[] m_strName;

        // Do NOT delete m_pframeAnimHead;
	}

    void AddAnimationFrame( SFrame* pframeAnim )
    {
        pframeAnim->m_pframeAnimNext = m_pframeAnimHead;
        m_pframeAnimHead = pframeAnim;
    }

    SFrame* FindFrame( char* strName )
    {
        if( m_pRootFrame == NULL )
            return NULL;
        else
            return m_pRootFrame->FindFrame( strName );
    }
};




HRESULT CalculateBoundingSphere( SDrawElement* pDrawElement );



class CXBSkinnedMesh
{
public:
	LPDIRECT3DDEVICE8 m_pd3dDevice;

    SKINNING_METHOD m_method;
    DWORD           m_dwFVF;
	SMeshContainer* m_pmcSelectedMesh;
    SFrame*         m_pframeSelected;
    SDrawElement*   m_pdeSelected;
	SDrawElement*   m_pdeHead;

    HRESULT FindBones( SFrame* pCurrentFrame, SDrawElement* pDrawElement );
    HRESULT LoadMeshHierarchy( CHAR* strMesh, CXBPackedResource* pResource );
    HRESULT LoadAnimationSet( LPDIRECTXFILEDATA pxofobjCur, SDrawElement* pDrawElement,
                              DWORD dwFVF, SFrame* pParentFrame );
    HRESULT LoadAnimation( LPDIRECTXFILEDATA pxofobjCur, SDrawElement* pDrawElement,
                           DWORD dwFVF, SFrame* pParentFrame );
    HRESULT LoadFrames( LPDIRECTXFILEDATA pxofobjCur, SDrawElement* pDrawElement,
                        DWORD dwFVF, SFrame* pParentFrame );
    HRESULT LoadMesh( LPDIRECTXFILEDATA pxofobjCur,
                      DWORD dwFVF, SFrame* pParentFrame );
    HRESULT DeleteSelectedMesh();
    HRESULT DrawMeshContainer( SMeshContainer* pMeshContainer );
    HRESULT UpdateFrames( SFrame* pCurrentFrame, D3DXMATRIX &matCur );
    HRESULT GenerateMesh( SMeshContainer* pMeshContainer );
    HRESULT DrawFrames( SFrame* pCurrentFrame, UINT &dwNumTriangles );


	HRESULT Render();
	
	CXBSkinnedMesh();
};




#endif // XBSKINNEDMESH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh\skinnedmesh.cpp ===
//-----------------------------------------------------------------------------
// File: SkinnedMesh.cpp
//
// Desc: 
//
// Hist: 06.27.01 - New
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include "XBSkinnedMesh.h"
#include "Resource.h"


//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Tiny_Skin.bmp", resource_TinySkin_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource m_xprResource;        // Packed resources for the app
    CXBFont           m_Font;               // Font class

	CXBSkinnedMesh    m_SkinnedMesh;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_SkinnedMesh.LoadMeshHierarchy( "D:\\Media\\Models\\Tiny.x", &m_xprResource );

    D3DXMATRIX matView, matProj;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 0.0f, m_SkinnedMesh.m_pdeSelected->m_fRadius*2.8f ),
			                      &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ),
			                      &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
	D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f / 480.0f, 
			                    m_SkinnedMesh.m_pdeSelected->m_fRadius / 64, 
								m_SkinnedMesh.m_pdeSelected->m_fRadius * 200 );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
	m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(light) );
    light.Type       = D3DLIGHT_DIRECTIONAL;
    light.Direction = D3DXVECTOR3( 0.0f, 0.0f, -1.0f);
    light.Diffuse.r  = 1.00f;
    light.Diffuse.g  = 1.00f;
    light.Diffuse.b  = 1.00f;
    light.Ambient.r  = 0.25f;
    light.Ambient.g  = 0.25f;
    light.Ambient.b  = 0.25f;
    m_pd3dDevice->SetLight(0, &light );
    m_pd3dDevice->LightEnable(0, TRUE);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	for( SDrawElement* pDrawElement = m_SkinnedMesh.m_pdeHead; pDrawElement; pDrawElement = pDrawElement->m_pNext )
	{
		// Update the times
		pDrawElement->m_fCurrentTime += m_fElapsedTime * 4800;
		if( pDrawElement->m_fCurrentTime > 1.0e15f )
			pDrawElement->m_fCurrentTime = 0.0f;

		SFrame* pFrame = pDrawElement->m_pframeAnimHead;
		while( pFrame )
		{
			pFrame->SetTime( pDrawElement->m_fCurrentTime );
			pFrame = pFrame->m_pframeAnimNext;
		}

		// Set up viewing postion
		static FLOAT angle = -D3DX_PI/4;
		static FLOAT trans = -100.0f;
		D3DXMatrixRotationX( &pDrawElement->m_pRootFrame->m_matRot, angle );
		D3DXMatrixTranslation( &pDrawElement->m_pRootFrame->m_matTrans, 0.0f, trans, 0.0f );
    
		// Update the frames
		D3DXMATRIX matTrans, matCurrent;
		D3DXMatrixTranslation( &matTrans, -pDrawElement->m_vCenter.x, -pDrawElement->m_vCenter.y, -pDrawElement->m_vCenter.z );
		D3DXMatrixIdentity( &matCurrent );

		m_SkinnedMesh.UpdateFrames( pDrawElement->m_pRootFrame, matCurrent );
	}

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
		                 0xff0000ff, 1.0f, 0L );

    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,     TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_NORMALIZENORMALS, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_COLORVERTEX,      FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Draw the skinned mesh
    m_SkinnedMesh.Render();

    // Show frame rate
    m_Font.DrawText(  64, 50, 0xffffff00, L"SkinnedMesh" );
    m_Font.DrawText( 420, 50, 0xffffff00, m_strFrameRate );
  
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\TestArea\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh2\main.cpp ===
//-----------------------------------------------------------------------------
// File: SkinnedMesh.cpp
//
// Desc: 
//
// Hist: 06.27.01 - New
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include <XBMesh.h>




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont            m_Font;               // Font class

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: App_Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh2\mload.cpp ===
//-----------------------------------------------------------------------------
// File: mload.cpp
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <XBApp.h>
#include <XBFont.h>
#include <XBResource.h>
#include <XBUtil.h>
#include "rmxfguid.h"
#include "rmxftmpl.h"
#include "SkinnedMesh.h"


CXBPackedResource* g_pResource = NULL;



CSkinnedMesh::CSkinnedMesh()
{
    m_pmcSelectedMesh = NULL;
    m_pframeSelected  = NULL;
    m_pdeHead         = NULL;
    m_pdeSelected     = NULL;
    m_dwFVF           = D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_NORMAL | D3DFVF_TEX1;
    m_method          = SKIN_NONINDEXED;
}



HRESULT CalculateSum( SFrame* pFrame, D3DXMATRIX* pmatCur, D3DXVECTOR3* pvCenter, 
                      UINT* pdwNumVertices )
{
    HRESULT         hr;
    PBYTE           pbPoints = NULL;
    UINT            cVerticesLocal = 0;
    PBYTE           pbCur;
    D3DXVECTOR3*    pvCur;
    D3DXVECTOR3     vTransformedCur;
    UINT            iPoint;
    UINT            cVertices;
    D3DXMATRIX      matLocal;
    
    D3DXMatrixMultiply( &matLocal, &pFrame->m_matRot, pmatCur );
    
    SMeshContainer* pmcCur = pFrame->m_pMeshContainer;
    while( pmcCur != NULL )
    {
        DWORD fvfsize = D3DXGetFVFVertexSize(pmcCur->m_pMesh->GetFVF());
        
        cVertices = pmcCur->m_pMesh->GetNumVertices();
        
        hr = pmcCur->m_pMesh->LockVertexBuffer( 0, &pbPoints );
        if( FAILED(hr) )
			return hr;
        
        for( iPoint=0, pbCur = pbPoints; iPoint < cVertices; iPoint++, pbCur += fvfsize )
        {
            pvCur = (D3DXVECTOR3*)pbCur;
            
            if( (pvCur->x != 0.0) || (pvCur->y != 0.0) || (pvCur->z != 0.0) )
            {
                cVerticesLocal++;
                
                D3DXVec3TransformCoord(&vTransformedCur, pvCur, &matLocal);
                
                pvCenter->x += vTransformedCur.x;
                pvCenter->y += vTransformedCur.y;
                pvCenter->z += vTransformedCur.z;
            }
        }
        
        pmcCur->m_pMesh->UnlockVertexBuffer();
        pbPoints = NULL;
        
        pmcCur = pmcCur->m_pNext;
    }
    
    (*pdwNumVertices) += cVerticesLocal;
    
    SFrame* pCurrentFrame = pFrame->m_pChild;
    while( pCurrentFrame )
    {
        hr = CalculateSum( pCurrentFrame, &matLocal, pvCenter, pdwNumVertices );
        if( FAILED(hr) )
			return hr;
        
        pCurrentFrame = pCurrentFrame->m_pSibling;
    }
    
    return S_OK;
}




HRESULT CalculateRadius( SFrame* pFrame, D3DXMATRIX* pmatCur, D3DXVECTOR3* pvCenter, 
                         float* pfRadiusSq )
{
    HRESULT         hr = S_OK;
    PBYTE           pbPoints = NULL;
    PBYTE           pbCur;
    D3DXVECTOR3*    pvCur;
    D3DXVECTOR3     vDist;
    UINT            iPoint;
    UINT            dwNumVertices;
    float           fRadiusLocalSq;
    float           fDistSq;
    D3DXMATRIX      matLocal;
    
    D3DXMatrixMultiply( &matLocal, &pFrame->m_matRot, pmatCur );
    
    SMeshContainer* pmcCur = pFrame->m_pMeshContainer;
    fRadiusLocalSq = (*pfRadiusSq);
    while( pmcCur != NULL )
    {
        DWORD fvfsize = D3DXGetFVFVertexSize( pmcCur->m_pMesh->GetFVF() );
        
        dwNumVertices = pmcCur->m_pMesh->GetNumVertices();
        
        hr = pmcCur->m_pMesh->LockVertexBuffer( 0, &pbPoints );
        if( FAILED(hr) )
			return hr;
        
        for( iPoint=0, pbCur = pbPoints; iPoint < dwNumVertices; iPoint++, pbCur += fvfsize )
        {
            pvCur = (D3DXVECTOR3*)pbCur;
            
            if ((pvCur->x == 0.0) && (pvCur->y == 0.0) && (pvCur->z == 0.0))
                continue;
            
            D3DXVec3TransformCoord( &vDist, pvCur, &matLocal );
            
            vDist -= (*pvCenter);
            
            fDistSq = D3DXVec3LengthSq( &vDist );
            
            if( fDistSq > fRadiusLocalSq )
                fRadiusLocalSq = fDistSq;
        }
        
        
        pmcCur->m_pMesh->UnlockVertexBuffer();
        pbPoints = NULL;
        
        pmcCur = pmcCur->m_pNext;
    }
    
    (*pfRadiusSq) = fRadiusLocalSq;
    
    SFrame* pCurrentFrame = pFrame->m_pChild;
    while( pCurrentFrame != NULL )
    {
        hr = CalculateRadius( pCurrentFrame, &matLocal, pvCenter, pfRadiusSq );
        if( FAILED(hr) )
            return hr;
        
        pCurrentFrame = pCurrentFrame->m_pSibling;
    }
    
    return S_OK;
}




HRESULT CalculateBoundingSphere( SDrawElement* pDrawElement )
{
    D3DXVECTOR3 vCenter(0,0,0);
    UINT        dwNumVertices = 0;
    float       fRadiusSq     = 0.0f;
    D3DXMATRIX  matCur;
    HRESULT     hr;
    
    D3DXMatrixIdentity( &matCur );
    hr = CalculateSum( pDrawElement->m_pRootFrame, &matCur, &vCenter, &dwNumVertices );
    if( FAILED(hr) )
	    return hr;
    
    if( dwNumVertices > 0 )
    {
        vCenter /= (float)dwNumVertices;
        
        D3DXMatrixIdentity( &matCur );
        hr = CalculateRadius( pDrawElement->m_pRootFrame, &matCur, &vCenter, &fRadiusSq );
        if( FAILED(hr) )
			return hr;
    }
    
    pDrawElement->m_fRadius = sqrtf( fRadiusSq );
    pDrawElement->m_vCenter = vCenter;
    return S_OK;
}




HRESULT CSkinnedMesh::FindBones( SFrame* pCurrentFrame, SDrawElement* pDrawElement )
{
    HRESULT hr;
    
    SMeshContainer* pMeshContainer = pCurrentFrame->m_pMeshContainer;
    while( pMeshContainer )
    {
        if( pMeshContainer->m_pSkinMesh )
        {
            char** pBoneName = static_cast<char**>(pMeshContainer->m_pBoneNamesBuf->GetBufferPointer());
            for( DWORD i = 0; i < pMeshContainer->m_pSkinMesh->GetNumBones(); i++ )
            {
                SFrame* pFrame = pDrawElement->FindFrame(pBoneName[i]);
                pMeshContainer->m_pBoneMatrix[i] = &(pFrame->m_matCombined);
            }
        }
        pMeshContainer = pMeshContainer->m_pNext;
    }
    
    SFrame* pChildFrame = pCurrentFrame->m_pChild;
    while( pChildFrame )
    {
        hr = FindBones( pChildFrame, pDrawElement );
        if( FAILED(hr) )
            return hr;
        
        pChildFrame = pChildFrame->m_pSibling;
    }
    
    return S_OK;
}




HRESULT CSkinnedMesh::LoadMeshHierarchy( CHAR* strMesh, CXBPackedResource* pResource )
{
    SDrawElement*           pdeMesh    = NULL;
    HRESULT                 hr         = S_OK;
    LPDIRECTXFILE           pxofapi    = NULL;
    LPDIRECTXFILEENUMOBJECT pxofenum   = NULL;
    LPDIRECTXFILEDATA       pxofobjCur = NULL;
    DWORD                   dwOptions;
    int                     cchFileName;

	g_pResource = pResource;

    if( strMesh == NULL )
        return E_INVALIDARG;
    
    pdeMesh = new SDrawElement();
    
    delete pdeMesh->m_pRootFrame;
    pdeMesh->m_pframeAnimHead = NULL;
    
    pdeMesh->m_pRootFrame = new SFrame();
    if( pdeMesh->m_pRootFrame == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
        
    dwOptions = 0;
    
    cchFileName = strlen( strMesh );
    if( cchFileName < 2 )
    {
        hr = E_FAIL;
        goto e_Exit;
    }
    
    hr = DirectXFileCreate( &pxofapi );
    if( FAILED(hr) )
        goto e_Exit;
    
    // Register templates for d3drm.
    hr = pxofapi->RegisterTemplates( (VOID*)D3DRM_XTEMPLATES, D3DRM_XTEMPLATE_BYTES );
    if( FAILED(hr) )
        goto e_Exit;
    
    // Create enum object.
    hr = pxofapi->CreateEnumObject( (VOID*)strMesh, DXFILELOAD_FROMFILE, &pxofenum );
    if( FAILED(hr) )
        goto e_Exit;
        
    // Enumerate top level objects.
    // Top level objects are always data object.
    while( SUCCEEDED( pxofenum->GetNextDataObject( &pxofobjCur ) ) )
    {
        hr = LoadFrames( pxofobjCur, pdeMesh, dwOptions, m_dwFVF, pdeMesh->m_pRootFrame );
        SAFE_RELEASE( pxofobjCur );
        
        if( FAILED(hr) )
            goto e_Exit;
    }
    
    hr = FindBones(pdeMesh->m_pRootFrame, pdeMesh);
    if( FAILED(hr) )
        goto e_Exit;
    
    delete []pdeMesh->m_strName;
    pdeMesh->m_strName = new char[cchFileName+1];
    if (pdeMesh->m_strName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    memcpy(pdeMesh->m_strName, strMesh, cchFileName+1);

    // delete the current mesh, now that the load has succeeded
    DeleteSelectedMesh();

    // link into the draw list
    pdeMesh->m_pNext = m_pdeHead;
    m_pdeHead = pdeMesh;
    
    m_pdeSelected = pdeMesh;
    m_pmcSelectedMesh = pdeMesh->m_pRootFrame->m_pMeshContainer;
    
    
    m_pframeSelected = pdeMesh->m_pRootFrame;
    
    hr = CalculateBoundingSphere(pdeMesh);
    if( FAILED(hr) )
        goto e_Exit;
    
    m_pdeSelected->m_fCurrentTime = 0.0f;
    m_pdeSelected->m_fMaxTime     = 200.0f;
    
    D3DXMatrixTranslation( &m_pdeSelected->m_pRootFrame->m_matRot,
                           -pdeMesh->m_vCenter.x, 
						   -pdeMesh->m_vCenter.y, 
						   -pdeMesh->m_vCenter.z );
    m_pdeSelected->m_pRootFrame->m_matRotOrig = m_pdeSelected->m_pRootFrame->m_matRot;
    
e_Exit:
    SAFE_RELEASE( pxofobjCur );
    SAFE_RELEASE( pxofenum );
    SAFE_RELEASE( pxofapi );
    
    if( FAILED(hr) )
        delete pdeMesh;
    
    return hr;
}




HRESULT CSkinnedMesh::LoadAnimation( LPDIRECTXFILEDATA pxofobjCur, SDrawElement* pDrawElement,
                                     DWORD dwOptions, DWORD dwFVF, SFrame* pParentFrame )
{
    SRotateKeyXFile*    pFileRotateKey;
    SScaleKeyXFile*     pFileScaleKey;
    SPositionKeyXFile*  pFilePosKey;
    SMatrixKeyXFile*    pFileMatrixKey;
    SFrame*             pCurrentFrame;
    LPDIRECTXFILEDATA   pxofobjChild = NULL;
    LPDIRECTXFILEOBJECT pxofChild = NULL;
    LPDIRECTXFILEDATAREFERENCE pxofobjChildRef = NULL;
    const GUID*         type;
    DWORD   dwSize;
    PBYTE   pData;
    DWORD   dwKeyType;
    DWORD   dwNumKeys;
    DWORD   iKey;
    DWORD   cchName;
    char*   strFrameName;
    HRESULT hr = S_OK;
    
    pCurrentFrame = new SFrame();
    if( pCurrentFrame == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    pCurrentFrame->m_bAnimationFrame = true;
    
    pParentFrame->AddFrame( pCurrentFrame );
    pDrawElement->AddAnimationFrame( pCurrentFrame );
    
    // Enumerate child objects.
    // Child object can be data, data reference or binary.
    // Use QueryInterface() to find what type of object a child is.
    while( SUCCEEDED(pxofobjCur->GetNextObject( &pxofChild ) ) )
    {
        // Query the child for it's FileDataReference
        hr = pxofChild->QueryInterface( IID_IDirectXFileDataReference,
                                        (VOID**)&pxofobjChildRef );
        if (SUCCEEDED(hr))
        {
            hr = pxofobjChildRef->Resolve( &pxofobjChild );
            if( SUCCEEDED(hr) )
            {
                hr = pxofobjChild->GetType( &type );
                if( FAILED(hr) )
                    goto e_Exit;
                
                if( TID_D3DRMFrame == (*type) )
                {
                    if( pCurrentFrame->m_pframeToAnimate != NULL )
                    {
                        hr = E_INVALIDARG;
                        goto e_Exit;
                    }
                    
                    hr = pxofobjChild->GetName( NULL, &cchName );
                    if( FAILED(hr) )
                        goto e_Exit;
                    
                    if( cchName == 0 )
                    {
                        hr = E_INVALIDARG;
                        goto e_Exit;
                        
                    }
                    
                    strFrameName = (char*)_alloca( cchName );
                    if( strFrameName == NULL )
                    {
                        hr = E_OUTOFMEMORY;
                        goto e_Exit;
                    }
                    
                    hr = pxofobjChild->GetName( strFrameName, &cchName );
                    if( FAILED(hr) )
                        goto e_Exit;
                    
                    pCurrentFrame->m_pframeToAnimate = pDrawElement->FindFrame( strFrameName );
                    if( pCurrentFrame->m_pframeToAnimate == NULL )
                    {
                        hr = E_INVALIDARG;
                        goto e_Exit;
                    }
                }
                
                SAFE_RELEASE( pxofobjChild );
            }
            
            SAFE_RELEASE( pxofobjChildRef );
        }
        else
        {
            // Query the child for it's FileData
            hr = pxofChild->QueryInterface( IID_IDirectXFileData,
                                            (VOID**)&pxofobjChild );
            if( SUCCEEDED(hr) )
            {
                hr = pxofobjChild->GetType( &type );
                if( FAILED(hr) )
                    goto e_Exit;
                
                if( TID_D3DRMFrame == (*type) )
                {
                    hr = LoadFrames( pxofobjChild, pDrawElement, dwOptions, dwFVF, pCurrentFrame );
                    if( FAILED(hr) )
                        goto e_Exit;
                }
                else if( TID_D3DRMAnimationOptions == (*type) )
                {
                    //ParseAnimOptions(pChildData,pParentFrame);
                    //i=2;
                }
                else if( TID_D3DRMAnimationKey == (*type) )
                {
                    hr = pxofobjChild->GetData( NULL, &dwSize, (VOID**)&pData );
                    if( FAILED(hr) )
                        goto e_Exit;
                    
                    dwKeyType = ((DWORD*)pData)[0];
                    dwNumKeys = ((DWORD*)pData)[1];
                    
                    if( dwKeyType == 0 )
                    {
                        if( pCurrentFrame->m_pRotateKeys != NULL )
                        {
                            hr = E_INVALIDARG;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_pRotateKeys = new SRotateKey[dwNumKeys];
                        if (pCurrentFrame->m_pRotateKeys == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_dwNumRotateKeys = dwNumKeys;
                        //NOTE x files are w x y z and QUATERNIONS are x y z w
                        
                        pFileRotateKey =  (SRotateKeyXFile*)(pData + (sizeof(DWORD) * 2));
                        for( iKey = 0;iKey < dwNumKeys; iKey++ )
                        {
                            pCurrentFrame->m_pRotateKeys[iKey].dwTime = pFileRotateKey->dwTime;
                            pCurrentFrame->m_pRotateKeys[iKey].quatRotate.x = pFileRotateKey->x;
                            pCurrentFrame->m_pRotateKeys[iKey].quatRotate.y = pFileRotateKey->y;
                            pCurrentFrame->m_pRotateKeys[iKey].quatRotate.z = pFileRotateKey->z;
                            pCurrentFrame->m_pRotateKeys[iKey].quatRotate.w = pFileRotateKey->w;
                            
                            pFileRotateKey += 1;
                        }
                    }
                    else if( dwKeyType == 1 )
                    {
                        if (pCurrentFrame->m_pScaleKeys != NULL)
                        {
                            hr = E_INVALIDARG;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_pScaleKeys = new SScaleKey[dwNumKeys];
                        if (pCurrentFrame->m_pScaleKeys == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_dwNumScaleKeys = dwNumKeys;
                        
                        pFileScaleKey =  (SScaleKeyXFile*)(pData + (sizeof(DWORD) * 2));
                        for( iKey = 0;iKey < dwNumKeys; iKey++ )
                        {
                            pCurrentFrame->m_pScaleKeys[iKey].dwTime = pFileScaleKey->dwTime;
                            pCurrentFrame->m_pScaleKeys[iKey].vScale = pFileScaleKey->vScale;
                            
                            pFileScaleKey += 1;
                        }
                    }
                    else if( dwKeyType == 2 )
                    {
                        if (pCurrentFrame->m_pPositionKeys != NULL)
                        {
                            hr = E_INVALIDARG;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_pPositionKeys = new SPositionKey[dwNumKeys];
                        if (pCurrentFrame->m_pPositionKeys == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_dwNumPositionKeys = dwNumKeys;
                        
                        pFilePosKey =  (SPositionKeyXFile*)(pData + (sizeof(DWORD) * 2));
                        for( iKey = 0;iKey < dwNumKeys; iKey++ )
                        {
                            pCurrentFrame->m_pPositionKeys[iKey].dwTime = pFilePosKey->dwTime;
                            pCurrentFrame->m_pPositionKeys[iKey].vPos = pFilePosKey->vPos;
                            
                            pFilePosKey += 1;
                        }
                    }
                    else if( dwKeyType == 4 )
                    {
                        if( pCurrentFrame->m_pMatrixKeys != NULL )
                        {
                            hr = E_INVALIDARG;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_pMatrixKeys = new SMatrixKey[dwNumKeys];
                        if( pCurrentFrame->m_pMatrixKeys == NULL )
                        {
                            hr = E_OUTOFMEMORY;
                            goto e_Exit;
                        }
                        
                        pCurrentFrame->m_dwNumMatrixKeys = dwNumKeys;
                        
                        pFileMatrixKey = (SMatrixKeyXFile*)(pData + (sizeof(DWORD) * 2));
                        for( iKey = 0;iKey < dwNumKeys; iKey++ )
                        {
                            pCurrentFrame->m_pMatrixKeys[iKey].dwTime = pFileMatrixKey->dwTime;
                            memcpy( &pCurrentFrame->m_pMatrixKeys[iKey].mat, &pFileMatrixKey->mat, sizeof(D3DXMATRIX) );
                            pFileMatrixKey++;
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                        goto e_Exit;
                    }
                }
                
                SAFE_RELEASE(pxofobjChild);
            }
        }
        
        SAFE_RELEASE(pxofChild);
    }
    
e_Exit:
    SAFE_RELEASE(pxofobjChild);
    SAFE_RELEASE(pxofChild);
    SAFE_RELEASE(pxofobjChildRef);
    return hr;
}




HRESULT CSkinnedMesh::LoadAnimationSet( LPDIRECTXFILEDATA pxofobjCur, SDrawElement* pDrawElement,
                                        DWORD dwOptions, DWORD dwFVF, SFrame* pParentFrame )
{
    SFrame* pCurrentFrame;
    const GUID* type;
    HRESULT hr = S_OK;
    LPDIRECTXFILEDATA pxofobjChild = NULL;
    LPDIRECTXFILEOBJECT pxofChild = NULL;
    DWORD cchName;
    
    pCurrentFrame = new SFrame();
    if( pCurrentFrame == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    pCurrentFrame->m_bAnimationFrame = true;
    
    pParentFrame->AddFrame( pCurrentFrame );
    
    hr = pxofobjCur->GetName( NULL, &cchName );
    if( FAILED(hr) )
        goto e_Exit;
    
    if (cchName > 0)
    {
        pCurrentFrame->m_strName = new char[cchName];
        if( pCurrentFrame->m_strName == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
        
        hr = pxofobjCur->GetName( pCurrentFrame->m_strName, &cchName );
        if( FAILED(hr) )
            goto e_Exit;
    }
    
    // Enumerate child objects.
    // Child object can be data, data reference or binary.
    // Use QueryInterface() to find what type of object a child is.
    while( SUCCEEDED( pxofobjCur->GetNextObject( &pxofChild ) ) )
    {
        // Query the child for it's FileData
        hr = pxofChild->QueryInterface( IID_IDirectXFileData,
                                        (VOID**)&pxofobjChild );
        if (SUCCEEDED(hr))
        {
            hr = pxofobjChild->GetType( &type );
            if( FAILED(hr) )
                goto e_Exit;
            
            if( TID_D3DRMAnimation == (*type) )
            {
                hr = LoadAnimation( pxofobjChild, pDrawElement, dwOptions, dwFVF, pCurrentFrame );
                if( FAILED(hr) )
                    goto e_Exit;
            }
            
            SAFE_RELEASE( pxofobjChild );
        }
        
        SAFE_RELEASE( pxofChild );
    }
    
e_Exit:
    SAFE_RELEASE( pxofobjChild );
    SAFE_RELEASE( pxofChild );
    return hr;
}




HRESULT CSkinnedMesh::GenerateMesh( SMeshContainer* pMeshContainer )
{
    // ASSUMPTION:  pMeshContainer->m_rgiAdjacency contains the current adjacency

    HRESULT hr           = S_OK;
    DWORD   dwNumFaces   = pMeshContainer->m_pSkinMesh->GetNumFaces();
    DWORD*  pAdjacencyIn = new DWORD[pMeshContainer->m_pSkinMesh->GetNumFaces() * 3];

    if( pAdjacencyIn == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    
    memcpy( pAdjacencyIn, pMeshContainer->m_rgiAdjacency, dwNumFaces * 3 * sizeof(DWORD) );

    SAFE_RELEASE( pMeshContainer->m_pMesh );
    pMeshContainer->m_pMesh      = NULL;
    
    if( m_method == SKIN_NONINDEXED )
    {
        DWORD* rgiAdjacency = NULL;

        rgiAdjacency = new DWORD[dwNumFaces * 3];

        if( rgiAdjacency == NULL )
        {
            hr  = E_OUTOFMEMORY;
            goto e_ExitNONINDEXED;
        }

        hr = pMeshContainer->m_pSkinMesh->ConvertToBlendedMesh( 0, pAdjacencyIn, rgiAdjacency, 
                                                                &pMeshContainer->m_cpattr, 
																&pMeshContainer->m_pBoneCombinationBuf, 
																&pMeshContainer->m_pMesh );
        if( FAILED(hr) )
            goto e_ExitNONINDEXED;

        // Calculate the max face influence count
        if( (pMeshContainer->m_pMesh->GetFVF() & D3DFVF_POSITION_MASK) != D3DFVF_XYZ )
        {
            pMeshContainer->m_maxFaceInfl = 1 + ((pMeshContainer->m_pMesh->GetFVF() & D3DFVF_POSITION_MASK) - D3DFVF_XYZRHW) / 2;
        }
        else
        {
            pMeshContainer->m_maxFaceInfl = 1;
        }

        // Vertex cache optimize the mesh
        LPD3DXMESH pMeshOpt;
        hr = pMeshContainer->m_pMesh->Optimize( D3DXMESHOPT_VERTEXCACHE, rgiAdjacency,
			                                    NULL, NULL, NULL, &pMeshOpt );
        if( SUCCEEDED(hr) )
        {
			pMeshContainer->m_pMesh->Release();
			pMeshContainer->m_pMesh = pMeshOpt;
			pMeshOpt = NULL;
        }

        // Need to clone the mesh to be WRITEONLY since we will not now read back from it.
 		LPD3DXMESH pMeshVid;
		hr = pMeshContainer->m_pMesh->CloneMeshFVF( pMeshContainer->m_pMesh->GetOptions() | D3DXMESH_WRITEONLY, pMeshContainer->m_pMesh->GetFVF(),
										            m_pd3dDevice, &pMeshVid );
		if( SUCCEEDED(hr) )
		{
			pMeshContainer->m_pMesh->Release();
			pMeshContainer->m_pMesh = pMeshVid;
			pMeshVid = NULL;
		}

e_ExitNONINDEXED:
        SAFE_DELETE_ARRAY( rgiAdjacency );

        if( FAILED(hr) )
            goto e_Exit;
    }
    else if( m_method == SKIN_INDEXED )
    {
        hr = pMeshContainer->m_pSkinMesh->ConvertToIndexedBlendedMesh( D3DXMESH_SYSTEMMEM, pAdjacencyIn, 255, 
			                                                    NULL, &pMeshContainer->m_cpattr, 
																&pMeshContainer->m_pBoneCombinationBuf, 
																&pMeshContainer->m_pMesh );
        if( FAILED(hr) )
            goto e_Exit;

        // Here we are talking of max vertex influence which we determine from 
        // the FVF of the returned mesh
        if( (pMeshContainer->m_pMesh->GetFVF() & D3DFVF_POSITION_MASK) != D3DFVF_XYZ )
        {
            pMeshContainer->m_maxFaceInfl = ((pMeshContainer->m_pMesh->GetFVF() & D3DFVF_POSITION_MASK) - D3DFVF_XYZRHW) / 2;
        }
        else
        {
            pMeshContainer->m_maxFaceInfl = 1;
        }
    }
    pMeshContainer->m_Method = m_method;

e_Exit:
    delete[] pAdjacencyIn;
    return hr;
}




HRESULT CSkinnedMesh::LoadMesh( LPDIRECTXFILEDATA pxofobjCur, DWORD dwOptions, DWORD dwFVF, 
							    SFrame* pParentFrame )
{
    SMeshContainer* pMeshContainer = NULL;
    LPD3DXBUFFER    pbufMaterials  = NULL;
    LPD3DXBUFFER    pbufAdjacency  = NULL;
    DWORD   cchName;
    UINT    dwNumFaces;
    UINT    iMaterial;
    HRESULT hr = S_OK;
    
    pMeshContainer = new SMeshContainer();
    if( pMeshContainer == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    
    hr = pxofobjCur->GetName( NULL, &cchName );
    if( FAILED(hr) )
        goto e_Exit;
    
    if( cchName > 0 )
    {
        pMeshContainer->m_strName = new char[cchName];
        if( pMeshContainer->m_strName == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
        
        hr = pxofobjCur->GetName( pMeshContainer->m_strName, &cchName );
        if( FAILED(hr) )
            goto e_Exit;
    }
    
    hr = D3DXLoadSkinMeshFromXof( pxofobjCur, dwOptions, m_pd3dDevice, &pbufAdjacency, 
		                          &pbufMaterials, &pMeshContainer->m_dwNumMaterials, 
								  &pMeshContainer->m_pBoneNamesBuf, 
								  &pMeshContainer->m_pBoneOffsetBuf, 
								  &pMeshContainer->m_pSkinMesh );
    if( FAILED(hr) )
        goto e_Exit;
    
    dwNumFaces = pMeshContainer->m_pSkinMesh->GetNumFaces();

    // Process skinning data
    if( pMeshContainer->m_pSkinMesh->GetNumBones() )
    {
        pMeshContainer->m_pBoneMatrix = new D3DXMATRIX*[pMeshContainer->m_pSkinMesh->GetNumBones()];
        if( pMeshContainer->m_pBoneMatrix == NULL )
            goto e_Exit;
        pMeshContainer->m_pBoneOffsetMat = reinterpret_cast<D3DXMATRIX*>(pMeshContainer->m_pBoneOffsetBuf->GetBufferPointer());
        DWORD* pAdjacencyIn = static_cast<LPDWORD>(pbufAdjacency->GetBufferPointer());

        pMeshContainer->m_rgiAdjacency = new DWORD[dwNumFaces * 3];

        if( pMeshContainer->m_rgiAdjacency == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        memcpy( pMeshContainer->m_rgiAdjacency, pAdjacencyIn, dwNumFaces * 3 * sizeof(DWORD) );
        
        hr = GenerateMesh( pMeshContainer );
        if( FAILED(hr) )
            goto e_Exit;
    }
    else
    {
        pMeshContainer->m_pSkinMesh->GetOriginalMesh(&(pMeshContainer->m_pMesh));
        pMeshContainer->m_pSkinMesh->Release();
        pMeshContainer->m_pSkinMesh = NULL;
        pMeshContainer->m_cpattr    = pMeshContainer->m_dwNumMaterials;
    }
    
    if( (pbufMaterials == NULL) || (pMeshContainer->m_dwNumMaterials == 0) )
    {
        pMeshContainer->m_pMaterials = new D3DMATERIAL8[1];
        pMeshContainer->m_pTextures  = new LPDIRECT3DTEXTURE8[1];
        if( pMeshContainer->m_pMaterials == NULL || pMeshContainer->m_pTextures == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
        
        memset(pMeshContainer->m_pMaterials, 0, sizeof(D3DXMATERIAL));
        pMeshContainer->m_pMaterials[0].Diffuse.r = 0.5f;
        pMeshContainer->m_pMaterials[0].Diffuse.g = 0.5f;
        pMeshContainer->m_pMaterials[0].Diffuse.b = 0.5f;
        pMeshContainer->m_pMaterials[0].Specular  = pMeshContainer->m_pMaterials[0].Diffuse;
        pMeshContainer->m_pTextures[0]            = NULL;
    }
    else
    {
        pMeshContainer->m_pMaterials = new D3DMATERIAL8[pMeshContainer->m_dwNumMaterials];
        pMeshContainer->m_pTextures  = new LPDIRECT3DTEXTURE8[pMeshContainer->m_dwNumMaterials];
        if( pMeshContainer->m_pMaterials == NULL || pMeshContainer->m_pTextures == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
        
        LPD3DXMATERIAL pMaterials = (LPD3DXMATERIAL)pbufMaterials->GetBufferPointer();
        
        for( iMaterial = 0; iMaterial < pMeshContainer->m_dwNumMaterials; iMaterial++ )
        {
            pMeshContainer->m_pMaterials[iMaterial] = pMaterials[iMaterial].MatD3D;
            pMeshContainer->m_pTextures[iMaterial]  = NULL;

            if( g_pResource && pMaterials[iMaterial].pTextureFilename )
				pMeshContainer->m_pTextures[iMaterial] = g_pResource->GetTexture( pMaterials[iMaterial].pTextureFilename );
        }
    }
    
    // Add the mesh to the parent frame
    pParentFrame->AddMesh( pMeshContainer );
    pMeshContainer = NULL;
    
e_Exit:
    delete pMeshContainer;
    
    SAFE_RELEASE( pbufAdjacency );
    SAFE_RELEASE( pbufMaterials );

    return hr;
}




HRESULT CSkinnedMesh::LoadFrames( LPDIRECTXFILEDATA pxofobjCur, SDrawElement* pDrawElement,
                                  DWORD dwOptions, DWORD dwFVF, SFrame* pParentFrame )
{
    HRESULT hr = S_OK;
    LPDIRECTXFILEDATA pxofobjChild = NULL;
    LPDIRECTXFILEOBJECT pxofChild = NULL;
    const GUID* type;
    DWORD cbSize;
    D3DXMATRIX* pmatNew;
    SFrame* pCurrentFrame;
    DWORD cchName;
    
    // Get the type of the object
    hr = pxofobjCur->GetType(&type);
    if( FAILED(hr) )
        goto e_Exit;
       
    if (*type == TID_D3DRMMesh)
    {
        hr = LoadMesh( pxofobjCur, dwOptions, dwFVF, pParentFrame );
        if( FAILED(hr) )
            goto e_Exit;
    }
    else if (*type == TID_D3DRMFrameTransformMatrix)
    {
        hr = pxofobjCur->GetData( NULL, &cbSize, (VOID**)&pmatNew );
        if( FAILED(hr) )
            goto e_Exit;
        
        // update the parents matrix with the new one
        pParentFrame->m_matRot     = (*pmatNew);
        pParentFrame->m_matRotOrig = (*pmatNew);
    }
    else if( *type == TID_D3DRMAnimationSet )
    {
        LoadAnimationSet( pxofobjCur, pDrawElement, dwOptions, dwFVF, pParentFrame );
    }
    else if( *type == TID_D3DRMAnimation )
    {
        LoadAnimation( pxofobjCur, pDrawElement, dwOptions, dwFVF, pParentFrame );
    }
    else if( *type == TID_D3DRMFrame )
    {
        pCurrentFrame = new SFrame();
        if( pCurrentFrame == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
        
        hr = pxofobjCur->GetName( NULL, &cchName );
        if( FAILED(hr) )
            goto e_Exit;
        
        if (cchName > 0)
        {
            pCurrentFrame->m_strName = new char[cchName];
            if (pCurrentFrame->m_strName == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }
            
            hr = pxofobjCur->GetName( pCurrentFrame->m_strName, &cchName );
            if( FAILED(hr) )
                goto e_Exit;
        }
        
        pParentFrame->AddFrame( pCurrentFrame );
        
        // Enumerate child objects.
        // Child object can be data, data reference or binary.
        // Use QueryInterface() to find what type of object a child is.
        while( SUCCEEDED(pxofobjCur->GetNextObject( &pxofChild ) ) )
        {
            // Query the child for it's FileData
            hr = pxofChild->QueryInterface( IID_IDirectXFileData, (VOID**)&pxofobjChild );
            if( SUCCEEDED(hr) )
            {
                hr = LoadFrames( pxofobjChild, pDrawElement, dwOptions, dwFVF, pCurrentFrame );
                if( FAILED(hr) )
                    goto e_Exit;
                
                SAFE_RELEASE( pxofobjChild );
            }
            SAFE_RELEASE( pxofChild );
        }
    }
    
e_Exit:
    SAFE_RELEASE( pxofobjChild );
    SAFE_RELEASE( pxofChild );
    return hr;
}


         
                                      
HRESULT CSkinnedMesh::DeleteSelectedMesh()
{
    if( m_pdeSelected )
    {
        SDrawElement* pCurrent = m_pdeHead;
        SDrawElement* pPrev    = NULL;
        
		while( (pCurrent) && (pCurrent!=m_pdeSelected) )
        {
            pPrev    = pCurrent;
            pCurrent = pCurrent->m_pNext;
        }

        if( pPrev == NULL )
        {
            m_pdeHead = m_pdeHead->m_pNext;
        }
        else
        {
            pPrev->m_pNext = pCurrent->m_pNext;
        }

        m_pdeSelected->m_pNext = NULL;
        if( m_pdeHead == m_pdeSelected )
            m_pdeHead = NULL;
        delete m_pdeSelected;
        m_pdeSelected = NULL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\asyncwrite\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh2\skinnedmesh.cpp ===
//-----------------------------------------------------------------------------
// File: SkinnedMesh.cpp
//
// Desc: 
//
// Hist: 06.27.01 - New
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include "SkinnedMesh.h"
#include "Resource.h"


//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Tiny_Skin.bmp", resource_TinySkin_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource m_xprResource;        // Packed resources for the app
    CXBFont           m_Font;               // Font class

	CSkinnedMesh      m_SkinnedMesh;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_SkinnedMesh.LoadMeshHierarchy( "D:\\Media\\Models\\Tiny.x", &m_xprResource );

    D3DXMATRIX matView, matProj;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 0.0f, m_SkinnedMesh.m_pdeSelected->m_fRadius*2.8f ),
			                      &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ),
			                      &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
	D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f / 480.0f, 
			                    m_SkinnedMesh.m_pdeSelected->m_fRadius / 64, 
								m_SkinnedMesh.m_pdeSelected->m_fRadius * 200 );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
	m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(light) );
    light.Type       = D3DLIGHT_DIRECTIONAL;
    light.Direction = D3DXVECTOR3( 0.0f, 0.0f, -1.0f);
    light.Diffuse.r  = 1.00f;
    light.Diffuse.g  = 1.00f;
    light.Diffuse.b  = 1.00f;
    light.Ambient.r  = 0.25f;
    light.Ambient.g  = 0.25f;
    light.Ambient.b  = 0.25f;
    m_pd3dDevice->SetLight(0, &light );
    m_pd3dDevice->LightEnable(0, TRUE);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	for( SDrawElement* pDrawElement = m_SkinnedMesh.m_pdeHead; pDrawElement; pDrawElement = pDrawElement->m_pNext )
	{
		// Update the times
		pDrawElement->m_fCurrentTime += m_fElapsedTime * 4800;
		if( pDrawElement->m_fCurrentTime > 1.0e15f )
			pDrawElement->m_fCurrentTime = 0.0f;

		SFrame* pFrame = pDrawElement->m_pframeAnimHead;
		while( pFrame )
		{
			pFrame->SetTime( pDrawElement->m_fCurrentTime );
			pFrame = pFrame->m_pframeAnimNext;
		}

		// Set up viewing postion
		static FLOAT angle = -D3DX_PI/4;
		static FLOAT trans = -100.0f;
		D3DXMatrixRotationX( &pDrawElement->m_pRootFrame->m_matRot, angle );
		D3DXMatrixTranslation( &pDrawElement->m_pRootFrame->m_matTrans, 0.0f, trans, 0.0f );
    
		// Update the frames
		D3DXMATRIX matTrans, matCurrent;
		D3DXMatrixTranslation( &matTrans, -pDrawElement->m_vCenter.x, -pDrawElement->m_vCenter.y, -pDrawElement->m_vCenter.z );
		D3DXMatrixIdentity( &matCurrent );

		m_SkinnedMesh.UpdateFrames( pDrawElement->m_pRootFrame, matCurrent );
	}

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
		                 0xff0000ff, 1.0f, 0L );

    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,     TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_NORMALIZENORMALS, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_COLORVERTEX,      FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Draw the skinned mesh
    m_SkinnedMesh.Render();

    // Show frame rate
    m_Font.DrawText(  64, 50, 0xffffff00, L"SkinnedMesh" );
    m_Font.DrawText( 420, 50, 0xffffff00, m_strFrameRate );
  
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh2\mdraw.cpp ===
//-----------------------------------------------------------------------------
// File: mdraw.cpp
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <XBApp.h>
#include <XBFont.h>
#include <XBResource.h>
#include <XBUtil.h>
#include "SkinnedMesh.h"


HRESULT CSkinnedMesh::DrawMeshContainer(SMeshContainer* pMeshContainer)
{
    UINT ipattr;
    HRESULT hr = S_OK;
    LPD3DXBONECOMBINATION pBoneComb;

    if( pMeshContainer->m_pSkinMesh )
    {
        D3DCAPS8    caps;

        m_pd3dDevice->GetDeviceCaps(&caps);

        if( m_method != pMeshContainer->m_Method )
        {
            GenerateMesh(pMeshContainer);
        }

        if( m_method == SKIN_NONINDEXED )
        {
            m_pd3dDevice->SetRenderState(D3DRS_VERTEXBLEND, pMeshContainer->m_maxFaceInfl - 1);
            pBoneComb = reinterpret_cast<LPD3DXBONECOMBINATION>(pMeshContainer->m_pBoneCombinationBuf->GetBufferPointer());
            for( ipattr = 0; ipattr < pMeshContainer->m_cpattr; ipattr++ )
            {
                for( DWORD i = 0; i < pMeshContainer->m_maxFaceInfl; i++ )
                {
                    DWORD matid = pBoneComb[ipattr].BoneId[i];
                    if( matid != UINT_MAX && (ipattr == 0 || matid != pBoneComb[ipattr - 1].BoneId[i]) )
                    {
                        m_pd3dDevice->SetTransform(D3DTS_WORLDMATRIX(i), pMeshContainer->m_pBoneMatrix[matid]);
                        m_pd3dDevice->MultiplyTransform(D3DTS_WORLDMATRIX(i), &pMeshContainer->m_pBoneOffsetMat[matid]);
                    }
                }

                if( ipattr == 0 || (pBoneComb[ipattr].AttribId != pBoneComb[ipattr - 1].AttribId) )
                {
                    m_pd3dDevice->SetMaterial(&(pMeshContainer->m_pMaterials[pBoneComb[ipattr].AttribId]));
                    m_pd3dDevice->SetTexture(0, pMeshContainer->m_pTextures[pBoneComb[ipattr].AttribId]);
                }

		        hr = pMeshContainer->m_pMesh->DrawSubset( ipattr );
                if(FAILED(hr))
                    return hr;
            }
            m_pd3dDevice->SetRenderState(D3DRS_VERTEXBLEND, 0);
		}
        else if( m_method == SKIN_INDEXED )
        {
            if (caps.MaxVertexBlendMatrixIndex < pMeshContainer->m_pSkinMesh->GetNumBones())
            {
/*
NOT ON XBOX
                m_pd3dDevice->SetRenderState(D3DRS_SOFTWAREVERTEXPROCESSING, TRUE);
*/
            }

            m_pd3dDevice->SetRenderState(D3DRS_VERTEXBLEND, pMeshContainer->m_maxFaceInfl - 1);
            if (pMeshContainer->m_maxFaceInfl - 1)
			{
/*
NOT ON XBOX
                m_pd3dDevice->SetRenderState(D3DRS_INDEXEDVERTEXBLENDENABLE, TRUE);
*/
			}
            pBoneComb = reinterpret_cast<LPD3DXBONECOMBINATION>(pMeshContainer->m_pBoneCombinationBuf->GetBufferPointer());
            for( ipattr = 0; ipattr < pMeshContainer->m_cpattr; ipattr++ )
            {
                for( DWORD i = 0; i < 255/*paletteSize*/; i++ )
                {
                    DWORD matid = pBoneComb[ipattr].BoneId[i];
                    if( matid != UINT_MAX )
                    {
                        m_pd3dDevice->SetTransform(D3DTS_WORLDMATRIX(i), pMeshContainer->m_pBoneMatrix[matid]);
                        m_pd3dDevice->MultiplyTransform(D3DTS_WORLDMATRIX(i), &pMeshContainer->m_pBoneOffsetMat[matid]);
                    }
                }
                
                m_pd3dDevice->SetMaterial(&(pMeshContainer->m_pMaterials[pBoneComb[ipattr].AttribId]));
                m_pd3dDevice->SetTexture(0, pMeshContainer->m_pTextures[pBoneComb[ipattr].AttribId]);

                hr = pMeshContainer->m_pMesh->DrawSubset( ipattr );
                if(FAILED(hr))
                    return hr;
            }
/*
NOT ON XBOX
            m_pd3dDevice->SetRenderState(D3DRS_INDEXEDVERTEXBLENDENABLE, TRUE);
*/
            m_pd3dDevice->SetRenderState(D3DRS_VERTEXBLEND, 0);

            if (caps.MaxVertexBlendMatrixIndex < pMeshContainer->m_pSkinMesh->GetNumBones())
            {
/*
NOT ON XBOX
                m_pd3dDevice->SetRenderState(D3DRS_SOFTWAREVERTEXPROCESSING, FALSE);
*/
            }
        }
    }
    else
    {
        for( ipattr = 0; ipattr < pMeshContainer->m_cpattr; ipattr++ )
        {
            m_pd3dDevice->SetMaterial(&(pMeshContainer->m_pMaterials[ipattr]));
            m_pd3dDevice->SetTexture(0, pMeshContainer->m_pTextures[ipattr]);
		    hr = pMeshContainer->m_pMesh->DrawSubset( ipattr );
            if(FAILED(hr))
                return hr;
        }
    }

    return S_OK;
}




HRESULT CSkinnedMesh::UpdateFrames( SFrame* pCurrentFrame, D3DXMATRIX &matCur )
{
    HRESULT hr;

    pCurrentFrame->m_matCombined = matCur;
    D3DXMatrixMultiply( &pCurrentFrame->m_matCombined, &pCurrentFrame->m_matRot, &matCur );
    D3DXMatrixMultiply( &pCurrentFrame->m_matCombined, &pCurrentFrame->m_matCombined, &pCurrentFrame->m_matTrans );
    
	for( SFrame* pChildFrame = pCurrentFrame->m_pChild; pChildFrame; pChildFrame = pChildFrame->m_pSibling )
    {
        hr = UpdateFrames( pChildFrame, pCurrentFrame->m_matCombined );
        if( FAILED(hr) )
            return hr;
    }
    return S_OK;
}




HRESULT CSkinnedMesh::DrawFrames( SFrame* pCurrentFrame, UINT& dwNumTriangles )
{
    HRESULT hr;

    if( pCurrentFrame->m_pMeshContainer )
    {
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &pCurrentFrame->m_matCombined );
    }

    SMeshContainer* pMeshContainer = pCurrentFrame->m_pMeshContainer;
    while( pMeshContainer )
    {
        hr = DrawMeshContainer( pMeshContainer );
        if( FAILED(hr) )
            return hr;

        dwNumTriangles += pMeshContainer->m_pMesh->GetNumFaces();

        pMeshContainer = pMeshContainer->m_pNext;
    }

    SFrame* pChildFrame = pCurrentFrame->m_pChild;
    while( pChildFrame )
    {
        hr = DrawFrames( pChildFrame, dwNumTriangles );
        if( FAILED(hr) )
            return hr;

        pChildFrame = pChildFrame->m_pSibling;
    }

    return S_OK;
}




void SFrame::SetTime( float fGlobalTime )
{
    UINT        iKey;
    UINT        dwp2;
    UINT        dwp3;
    D3DXMATRIX  matResult;
    D3DXMATRIX  matTemp;
    float       fTime1;
    float       fTime2;
    float       fLerpValue;
    D3DXVECTOR3 vScale;
    D3DXVECTOR3 vPos;
    D3DXQUATERNION quat;
    BOOL  bAnimate = false;
    float fTime;

    if( m_pMatrixKeys )
    {
        fTime = fmodf( fGlobalTime, (float)m_pMatrixKeys[m_dwNumMatrixKeys-1].dwTime );

        for( iKey = 0; iKey < m_dwNumMatrixKeys; iKey++ )
        {
            if( (float)m_pMatrixKeys[iKey].dwTime > fTime )
            {
                dwp3 = iKey;

                if( iKey > 0 )
                    dwp2= iKey - 1;
                else  // when iKey == 0, then dwp2 == 0
                    dwp2 = iKey;
                break;
            }
        }
        fTime1 = (float)m_pMatrixKeys[dwp2].dwTime;
        fTime2 = (float)m_pMatrixKeys[dwp3].dwTime;

        if( (fTime2 - fTime1) ==0 )
            fLerpValue = 0;
        else
            fLerpValue =  (fTime - fTime1)  / (fTime2 - fTime1);

        if( fLerpValue > 0.5f )
            iKey = dwp3;
        else
            iKey = dwp2;

        m_pframeToAnimate->m_matRot = m_pMatrixKeys[iKey].mat;
    }
    else
    {
        D3DXMatrixIdentity( &matResult );

        if( m_pScaleKeys )
        {
            dwp2 = dwp3 = 0;

            fTime = (float)fmod(fGlobalTime, m_pScaleKeys[m_dwNumScaleKeys-1].dwTime);

            for( iKey = 0 ;iKey < m_dwNumScaleKeys; iKey++ )
            {
                if( (float)m_pScaleKeys[iKey].dwTime > fTime )
                {
                    dwp3 = iKey;

                    if( iKey > 0 )
                        dwp2= iKey - 1;
                    else  // when iKey == 0, then dwp2 == 0
                        dwp2 = iKey;

                    break;
                }
            }
            fTime1 = (float)m_pScaleKeys[dwp2].dwTime;
            fTime2 = (float)m_pScaleKeys[dwp3].dwTime;

            if( (fTime2 - fTime1) ==0 )
                fLerpValue = 0;
            else
                fLerpValue =  (fTime - fTime1)  / (fTime2 - fTime1);

            D3DXVec3Lerp( &vScale, &m_pScaleKeys[dwp2].vScale,
                                   &m_pScaleKeys[dwp3].vScale, fLerpValue );

            D3DXMatrixScaling(&matTemp, vScale.x, vScale.y, vScale.z);

            D3DXMatrixMultiply(&matResult, &matResult, &matTemp);

            bAnimate = true;
        }

        // Check rotate keys
        if( m_pRotateKeys )
        {
            dwp2 = dwp3 = 0;

            fTime = (float)fmod(fGlobalTime, m_pRotateKeys[m_dwNumRotateKeys-1].dwTime);

            for( iKey = 0 ;iKey < m_dwNumRotateKeys ; iKey++ )
            {
                if( (float)m_pRotateKeys[iKey].dwTime > fTime )
                {
                    dwp3 = iKey;

                    if( iKey > 0 )
                        dwp2 = iKey - 1;
                    else  // when iKey == 0, then dwp2 == 0
                        dwp2 = iKey;
                    break;
                }
            }
            fTime1 = (float)m_pRotateKeys[dwp2].dwTime;
            fTime2 = (float)m_pRotateKeys[dwp3].dwTime;

            if( (fTime2 - fTime1) ==0 )
                fLerpValue = 0;
            else
                fLerpValue =  (fTime - fTime1)  / (fTime2 - fTime1);

            //s=0;
            D3DXQUATERNION q1,q2;
            q1.x = -m_pRotateKeys[dwp2].quatRotate.x;
            q1.y = -m_pRotateKeys[dwp2].quatRotate.y;
            q1.z = -m_pRotateKeys[dwp2].quatRotate.z;
            q1.w =  m_pRotateKeys[dwp2].quatRotate.w;

            q2.x = -m_pRotateKeys[dwp3].quatRotate.x;
            q2.y = -m_pRotateKeys[dwp3].quatRotate.y;
            q2.z = -m_pRotateKeys[dwp3].quatRotate.z;
            q2.w =  m_pRotateKeys[dwp3].quatRotate.w;

            D3DXQuaternionSlerp( &quat, &q1, &q2, fLerpValue );

            D3DXMatrixRotationQuaternion(&matTemp, &quat);

            D3DXMatrixMultiply(&matResult, &matResult, &matTemp);
            bAnimate = true;
        }

        if( m_pPositionKeys )
        {
            dwp2=dwp3=0;

            fTime = (float)fmod(fGlobalTime, m_pPositionKeys[m_dwNumRotateKeys-1].dwTime);

            for( iKey = 0 ;iKey < m_dwNumPositionKeys ; iKey++ )
            {
                if( (float)m_pPositionKeys[iKey].dwTime > fTime )
                {
                    dwp3 = iKey;

                    if( iKey > 0 )
                        dwp2 = iKey - 1;
                    else  // when iKey == 0, then dwp2 == 0
                        dwp2 = iKey;

                    break;
                }
            }
            fTime1 = (float)m_pPositionKeys[dwp2].dwTime;
            fTime2 = (float)m_pPositionKeys[dwp3].dwTime;

            if ((fTime2 - fTime1) ==0)
                fLerpValue = 0;
            else
                fLerpValue =  (fTime - fTime1)  / (fTime2 - fTime1);

            D3DXVec3Lerp( (D3DXVECTOR3*)&vPos, &m_pPositionKeys[dwp2].vPos,
                                               &m_pPositionKeys[dwp3].vPos, fLerpValue );

            D3DXMatrixTranslation( &matTemp, vPos.x, vPos.y, vPos.z );

            D3DXMatrixMultiply( &matResult, &matResult, &matTemp );
            bAnimate = true;
        }
        else
        {
            D3DXMatrixTranslation( &matTemp, m_pframeToAnimate->m_matRotOrig._41, 
				                             m_pframeToAnimate->m_matRotOrig._42, 
											 m_pframeToAnimate->m_matRotOrig._43 );

            D3DXMatrixMultiply( &matResult, &matResult, &matTemp );
        }

        if( bAnimate )
        {
            m_pframeToAnimate->m_matRot = matResult;
        }
    }
}




HRESULT CSkinnedMesh::Render()
{
	UINT   dwNumTriangles = 0;
	HRESULT hr;

	for( SDrawElement* pDrawElement = m_pdeHead; pDrawElement; pDrawElement = pDrawElement->m_pNext )
    {
        hr = DrawFrames( pDrawElement->m_pRootFrame, dwNumTriangles );
        if( FAILED(hr) )
            return hr;
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\asyncwrite\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\asyncwrite\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\SkinnedMesh2\SkinnedMesh.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File: mview.h
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
//////////////////////////////////////////////////////////////////////////////
#pragma once
#ifndef MVIEW_H
#define MVIEW_H


enum SKINNING_METHOD
{
    SKIN_NONINDEXED,
    SKIN_INDEXED,
};


struct SMeshContainer
{
    ID3DXMesh*          m_pMesh;
    SMeshContainer*     m_pNext;
    char*               m_strName;

    D3DMATERIAL8*       m_pMaterials;
    LPDIRECT3DTEXTURE8* m_pTextures;
    DWORD               m_cpattr;
    DWORD               m_dwNumMaterials;
    DWORD               m_iAttrSplit;

    // Skin info
    LPD3DXSKINMESH      m_pSkinMesh;
    D3DXATTRIBUTERANGE* m_pAttrTable;
    D3DXMATRIX**        m_pBoneMatrix;
    LPD3DXBUFFER        m_pBoneNamesBuf;
    LPD3DXBUFFER        m_pBoneOffsetBuf;
    D3DXMATRIX*         m_pBoneOffsetMat;
    DWORD*              m_rgiAdjacency;
    DWORD               m_numBoneComb;
    DWORD               m_maxFaceInfl;
    LPD3DXBUFFER        m_pBoneCombinationBuf;
    SKINNING_METHOD     m_Method;

	SMeshContainer()
	{
		m_pMesh          = NULL;
		m_pMaterials     = NULL;
		m_pTextures      = NULL;
		m_cpattr         = 0;
		m_iAttrSplit     = 0;
		m_dwNumMaterials = 0;
		m_pNext          = NULL;
		m_strName        = NULL;
		m_pSkinMesh      = NULL;
		m_pAttrTable     = NULL;
		m_pBoneMatrix    = NULL;
		m_pBoneNamesBuf  = NULL;
		m_pBoneOffsetBuf = NULL;
		m_pBoneOffsetMat = NULL;
		m_rgiAdjacency   = NULL;
		m_numBoneComb    = 0;
		m_maxFaceInfl    = 0;
		m_pBoneCombinationBuf = NULL;
		m_Method         = SKIN_NONINDEXED;
	}

	~SMeshContainer()
	{
        SAFE_DELETE_ARRAY( m_pMaterials );
        SAFE_DELETE_ARRAY( m_pTextures );

		SAFE_RELEASE( m_pMesh );
        SAFE_RELEASE( m_pSkinMesh );
        SAFE_RELEASE( m_pBoneNamesBuf );
        SAFE_RELEASE( m_pBoneOffsetBuf );
        SAFE_RELEASE( m_pBoneCombinationBuf );

        SAFE_DELETE_ARRAY( m_pBoneMatrix );
        SAFE_DELETE_ARRAY( m_pAttrTable );
        SAFE_DELETE_ARRAY( m_strName );
        SAFE_DELETE_ARRAY( m_rgiAdjacency );
        SAFE_DELETE( m_pNext );
	}
};


// X File formation rotate key
struct SRotateKeyXFile
{
	DWORD		dwTime;
	DWORD		dwFloats;	
	float		w;
	float		x;
	float		y;
	float		z;
};


struct SScaleKeyXFile
{
	DWORD	    dwTime;
	DWORD	    dwFloats;	
	D3DXVECTOR3	vScale;	
};


struct SPositionKeyXFile
{
	DWORD	    dwTime;
	DWORD	    dwFloats;	
	D3DXVECTOR3	vPos;	
};


struct SMatrixKeyXFile
{
	DWORD	    dwTime;
	DWORD	    dwFloats;	
//	D3DXMATRIX	mat;	// Note: we cannot use D3DXMATRIX (which is typedef'ed
	                    //       as a 16-byte aligned XGMATRIX) since matrices
	                    //       read from the file are not 16-byte aligned.
	struct
	{
		FLOAT _11, _12, _13, _14;
		FLOAT _21, _22, _23, _24;
		FLOAT _31, _32, _33, _34;
		FLOAT _41, _42, _43, _44;
	} mat;
};


// in memory versions
struct SRotateKey
{
	DWORD			dwTime;
	D3DXQUATERNION	quatRotate;	
};


struct SPositionKey
{
	DWORD	    dwTime;
	D3DXVECTOR3	vPos;	
};


struct SScaleKey
{
	DWORD	    dwTime;
	D3DXVECTOR3	vScale;	
};


struct SMatrixKey
{
	DWORD	    dwTime;
	D3DXMATRIX	mat;	
};


struct SFrame
{
    SMeshContainer* m_pMeshContainer;
    D3DXMATRIX      m_matRot;
    D3DXMATRIX      m_matTrans;
    D3DXMATRIX      m_matRotOrig;
    D3DXMATRIX      m_matCombined;

    // animation information
    SPositionKey*   m_pPositionKeys;
    UINT            m_dwNumPositionKeys;
    SRotateKey*     m_pRotateKeys;
    UINT            m_dwNumRotateKeys;
    SScaleKey*      m_pScaleKeys;
    UINT            m_dwNumScaleKeys;
    SMatrixKey*     m_pMatrixKeys;
    UINT            m_dwNumMatrixKeys;

    SFrame*         m_pframeAnimNext;
    SFrame*         m_pframeToAnimate;

    SFrame*         m_pSibling;
    SFrame*         m_pChild;

    bool            m_bAnimationFrame;
    char*           m_strName;

    SFrame()
	{
		m_pMeshContainer   = NULL;
		m_pPositionKeys    = NULL;
		m_dwNumPositionKeys = 0;
		m_pScaleKeys       = NULL;
		m_dwNumScaleKeys   = 0;
		m_pRotateKeys      = NULL;
		m_dwNumRotateKeys  = 0;
		m_pMatrixKeys      = NULL;
		m_dwNumMatrixKeys  = 0;
		m_pframeAnimNext   = NULL;
		m_pframeToAnimate  = NULL;
		m_pSibling         = NULL;
		m_pChild           = NULL;
		m_bAnimationFrame  = false;
		m_strName          = NULL;
        D3DXMatrixIdentity( &m_matRot );
        D3DXMatrixIdentity( &m_matRotOrig );
        D3DXMatrixIdentity( &m_matTrans );
    }

    ~SFrame()
    {
        delete[] m_strName;
        delete   m_pMeshContainer;        
        delete   m_pChild;
        delete   m_pSibling;

        delete[] m_pPositionKeys;
        delete[] m_pRotateKeys;
        delete[] m_pScaleKeys;
        delete[] m_pMatrixKeys;

        // Do NOT delete m_pframeAnimNext
        // Do NOT delete m_pframeToAnimate
    }

    void SetTime( float fTime );

    SFrame* FindFrame( char* strFrame )
    {
        SFrame* pFrame;

        if( m_strName && (strcmp(m_strName, strFrame)==0) )
            return this;

        if( m_pChild )
        {
            pFrame = m_pChild->FindFrame( strFrame );
            if( pFrame )
                return pFrame;
        }

        if( m_pSibling )
        {
            pFrame = m_pSibling->FindFrame( strFrame );
            if( pFrame )
                return pFrame;
        }

        return NULL;
    }

    void ResetMatrix()
    {
        m_matRot = m_matRotOrig;
        D3DXMatrixIdentity( &m_matTrans );

        if( m_pChild )
            m_pChild->ResetMatrix();

        if( m_pSibling )
            m_pSibling->ResetMatrix();
    }

    void AddFrame( SFrame* pFrame )
    {
        if( m_pChild == NULL )
        {
            m_pChild = pFrame;
        }
        else
        {
            pFrame->m_pSibling = m_pChild->m_pSibling;
            m_pChild->m_pSibling = pFrame;
        }
    }

    void AddMesh( SMeshContainer* pmc )
    {
        pmc->m_pNext = m_pMeshContainer;
        m_pMeshContainer = pmc;
    }
};


struct SDrawElement
{
    SFrame*       m_pRootFrame;

    D3DXVECTOR3   m_vCenter;
    float         m_fRadius;

	// Name of element for selection purposes
	char*         m_strName;

    // Animation list
    SFrame*       m_pframeAnimHead;

	// Next element in list
	SDrawElement* m_pNext;

    float         m_fCurrentTime;
    float         m_fMaxTime;

	SDrawElement()
	{
		m_vCenter        = D3DXVECTOR3(0.0f,0.0f,0.0f);
		m_fRadius        = 1.0f;
		m_strName        = NULL;
        m_pRootFrame     = NULL;
        m_pframeAnimHead = NULL;
		m_pNext          = NULL;
	}

	~SDrawElement()
	{
        delete   m_pRootFrame;
		delete   m_pNext;
        delete[] m_strName;

        // Do NOT delete m_pframeAnimHead;
	}

    void AddAnimationFrame( SFrame* pframeAnim )
    {
        pframeAnim->m_pframeAnimNext = m_pframeAnimHead;
        m_pframeAnimHead = pframeAnim;
    }

    SFrame* FindFrame( char* strName )
    {
        if( m_pRootFrame == NULL )
            return NULL;
        else
            return m_pRootFrame->FindFrame( strName );
    }
};




HRESULT CalculateBoundingSphere( SDrawElement* pDrawElement );



class CSkinnedMesh
{
public:
	LPDIRECT3DDEVICE8 m_pd3dDevice;

    SKINNING_METHOD m_method;
    DWORD           m_dwFVF;
	SMeshContainer* m_pmcSelectedMesh;
    SFrame*         m_pframeSelected;
    SDrawElement*   m_pdeSelected;
	SDrawElement*   m_pdeHead;

    HRESULT FindBones( SFrame* pCurrentFrame, SDrawElement* pDrawElement );
    HRESULT LoadMeshHierarchy( CHAR* strMesh, CXBPackedResource* pResource );
    HRESULT LoadAnimationSet( LPDIRECTXFILEDATA pxofobjCur, SDrawElement* pDrawElement,
                              DWORD dwOptions, DWORD dwFVF, SFrame* pParentFrame );
    HRESULT LoadAnimation( LPDIRECTXFILEDATA pxofobjCur, SDrawElement* pDrawElement,
                           DWORD dwOptions, DWORD dwFVF, SFrame* pParentFrame );
    HRESULT LoadFrames( LPDIRECTXFILEDATA pxofobjCur, SDrawElement* pDrawElement,
                        DWORD dwOptions, DWORD dwFVF, SFrame* pParentFrame );
    HRESULT LoadMesh( LPDIRECTXFILEDATA pxofobjCur,
                      DWORD dwOptions, DWORD dwFVF, SFrame* pParentFrame );
    HRESULT DeleteSelectedMesh();
    HRESULT DrawMeshContainer( SMeshContainer* pMeshContainer );
    HRESULT UpdateFrames( SFrame* pCurrentFrame, D3DXMATRIX &matCur );
    HRESULT GenerateMesh( SMeshContainer* pMeshContainer );
    HRESULT DrawFrames( SFrame* pCurrentFrame, UINT &dwNumTriangles );


	HRESULT Render();
	
	CSkinnedMesh();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\asyncwrite\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\Internal\TestArea\TestArea.cpp ===
//-----------------------------------------------------------------------------
// File: TestArea.cpp
//
// Desc: Sample Creates a Rectangle showing TCR Safe Area as a white rectangle
//       black background.  Will also display the same area as a black
//       rectangle on a white background if the A key is held down.
//
// Hist: 8.29.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include <xfvf.h>

//-----------------------------------------------------------------------------
#define PIXELPERVIEWPORT	(1.f/320.f)
#define VIEWPORT15PERCENT	(640.f * 0.15f)
#define EDGE				(PIXELPERVIEWPORT * VIEWPORT15PERCENT * 0.5f)
#define TWOPIXEL			(PIXELPERVIEWPORT * 2.f)

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,  XBHELP_PLACEMENT_2, L"Display Black Rectangle" },
};

#define NUM_HELP_CALLOUTS 1


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
	DWORD			m_dBackgroundColor;
	DWORD			m_dLineColor;
	FVFT_XYZRHWDIFF	*m_pVertices;
	WORD			*m_pIndices;

public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    BOOL        m_bDrawHelp;
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
	m_dLineColor = 0xffffffff;
	m_dBackgroundColor = 0xff000000;

	m_pIndices = new WORD [16];
	for (DWORD i=0;i<16;i++)
		m_pIndices[i] = (WORD)i;

	m_pVertices = new FVFT_XYZRHWDIFF [16];

	//First Quad
	m_pVertices[0].v.x = -1.f + EDGE;
	m_pVertices[0].v.y = 1.f - EDGE;
	m_pVertices[0].v.z = 0.5f;
	m_pVertices[0].w = 0.5f;
	m_pVertices[0].diff = m_dLineColor;

	m_pVertices[1].v.x = 1.f - EDGE;
	m_pVertices[1].v.y = 1.f - EDGE;
	m_pVertices[1].v.z = 0.5f;
	m_pVertices[1].w = 0.5f;
	m_pVertices[1].diff = m_dLineColor;

	m_pVertices[2].v.x = 1.f - EDGE;
	m_pVertices[2].v.y = 1.f - EDGE - TWOPIXEL;
	m_pVertices[2].v.z = 0.5f;
	m_pVertices[2].w = 0.5f;
	m_pVertices[2].diff = m_dLineColor;

	m_pVertices[3].v.x = -1.f + EDGE;
	m_pVertices[3].v.y = 1.f - EDGE - TWOPIXEL;
	m_pVertices[3].v.z = 0.5f;
	m_pVertices[3].w = 0.5f;
	m_pVertices[3].diff = m_dLineColor;

	//Second Quad
	m_pVertices[4].v.x = 1.f - EDGE - TWOPIXEL;
	m_pVertices[4].v.y = 1.f - EDGE;
	m_pVertices[4].v.z = 0.5f;
	m_pVertices[4].w = 0.5f;
	m_pVertices[4].diff = m_dLineColor;

	m_pVertices[5].v.x = 1.f - EDGE;
	m_pVertices[5].v.y = 1.f - EDGE;
	m_pVertices[5].v.z = 0.5f;
	m_pVertices[5].w = 0.5f;
	m_pVertices[5].diff = m_dLineColor;

	m_pVertices[6].v.x = 1.f - EDGE;
	m_pVertices[6].v.y = -1.f + EDGE;
	m_pVertices[6].v.z = 0.5f;
	m_pVertices[6].w = 0.5f;
	m_pVertices[6].diff = m_dLineColor;

	m_pVertices[7].v.x = 1.f - EDGE - TWOPIXEL;
	m_pVertices[7].v.y = -1.f + EDGE;
	m_pVertices[7].v.z = 0.5f;
	m_pVertices[7].w = 0.5f;
	m_pVertices[7].diff = m_dLineColor;

	//Third Quad
	// Not sure why we need the extra pixel, but we do or it don't look right!
	m_pVertices[10].v.x = -1.f + EDGE;
	m_pVertices[10].v.y = -1.f + EDGE + TWOPIXEL + PIXELPERVIEWPORT;
	m_pVertices[10].v.z = 0.5f;
	m_pVertices[10].w = 0.5f;
	m_pVertices[10].diff = m_dLineColor;
				  
	m_pVertices[11].v.x = 1.f - EDGE;
	m_pVertices[11].v.y = -1.f + EDGE + TWOPIXEL + PIXELPERVIEWPORT; 
	m_pVertices[11].v.z = 0.5f;
	m_pVertices[11].w = 0.5f;
	m_pVertices[11].diff = m_dLineColor;

	m_pVertices[8].v.x = 1.f - EDGE;
	m_pVertices[8].v.y = -1.f + EDGE; 
	m_pVertices[8].v.z = 0.5f;
	m_pVertices[8].w = 0.5f;
	m_pVertices[8].diff = m_dLineColor;
				 
	m_pVertices[9].v.x = -1.f + EDGE;
	m_pVertices[9].v.y = -1.f + EDGE; 
	m_pVertices[9].v.z = 0.5f;
	m_pVertices[9].w = 0.5f;
	m_pVertices[9].diff = m_dLineColor;

	//Fourth Quad
	m_pVertices[12].v.x = -1.f + EDGE;
	m_pVertices[12].v.y = 1.f - EDGE;
	m_pVertices[12].v.z = 0.5f;
	m_pVertices[12].w = 0.5f;
	m_pVertices[12].diff = m_dLineColor;

	m_pVertices[13].v.x = -1.f + EDGE + TWOPIXEL;
	m_pVertices[13].v.y = 1.f - EDGE;
	m_pVertices[13].v.z = 0.5f;
	m_pVertices[13].w = 0.5f;
	m_pVertices[13].diff = m_dLineColor;

	m_pVertices[14].v.x = -1.f + EDGE + TWOPIXEL;
	m_pVertices[14].v.y = -1.f + EDGE;
	m_pVertices[14].v.z = 0.5f;
	m_pVertices[14].w = 0.5f;
	m_pVertices[14].diff = m_dLineColor;

	m_pVertices[15].v.x = -1.f + EDGE;
	m_pVertices[15].v.y = -1.f + EDGE;
	m_pVertices[15].v.z = 0.5f;
	m_pVertices[15].w = 0.5f;
	m_pVertices[15].diff = m_dLineColor;

    m_bDrawHelp = FALSE;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;    

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

	//Check if Button A is held down.  If so, change background clear to white
	// and lines to black.  Otherwise, draw background black, lines in white.
	if (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > XINPUT_GAMEPAD_MAX_CROSSTALK )
	{
		m_dBackgroundColor = 0xffffffff;
		m_dLineColor = 0xff000000;
	}
	else
	{
		m_dBackgroundColor = 0xff000000;
		m_dLineColor = 0xffffffff;
	}

	for (DWORD i=0;i<16;i++)
		m_pVertices[i].diff = m_dLineColor;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, m_dBackgroundColor, 1.0f, 0L );

    // Setup render state
	if (m_dBackgroundColor == 0xffffffff)
	{
		m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,     		TRUE );
		m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,			0xff000000);
	}
	else
	{
		m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,     		FALSE );
	}

    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, 		FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      		FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,	FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,	FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, 		FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE,	D3DCOLORWRITEENABLE_ALL );
	m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,			D3DCULL_NONE );

	//Render the Lines based on color setup by button press.
	m_pd3dDevice->DrawIndexedPrimitiveUP(D3DPT_QUADLIST,0,16,4,m_pIndices,D3DFMT_INDEX16,m_pVertices,20);

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\asyncwrite\asyncwrite.cpp ===
//-----------------------------------------------------------------------------
// File: AsyncWrite.cpp
//
// Desc: Illustrates asynchronous writing of files on the XBox.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <cassert>
#include "resource.h"





//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Wings.bmp", resource_Wings_OFFSET },
    { "BiHull.bmp", resource_BiHull_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// We write to a huge file to really test the asynchronous nature.
// Another good way to test asynchronous writes is writing to an MU. Change
// FILE_BYTES to 4MB, FILE_DRIVE to 'F' and mount 'F' using XMountMU()
const DWORD ONE_K = 1024;
const DWORD FILE_BYTES = ONE_K * ONE_K * 32;        // 32MB 
const DWORD BYTES_PER_CALL = ONE_K * ONE_K * 2;;    // Write in 2MB chunks
const BYTE  FILL_BYTE_BASE = 0xC0;                  // For verification
const CHAR  FILE_DRIVE = 'T';                       // persistent data region




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    enum Mode
    {
        NOTHING,
        WRITING,
        READING
    };

    CXBFont           m_Font;
    CXBHelp           m_Help;
    BOOL              m_bDrawHelp;
    Mode              m_Mode;
	HANDLE            m_hFile;
	DWORD             m_dwBytesRemaining;
	DWORD             m_dwFileOffset;
    CXBPackedResource m_xprResource;
	CXBMesh*          m_pPlaneMesh;
    BYTE*             m_pBuffer;
    OVERLAPPED        m_Overlapped;
    BYTE              m_byFill;

public:

    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();

    VOID AsyncWrite();
    VOID AsyncRead();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
: 
    CXBApplication(),
    m_Font        (),
    m_Help        (),
    m_bDrawHelp   ( FALSE ),
    m_Mode        ( NOTHING ),
	m_hFile       ( NULL ),
    m_xprResource (),
	m_pPlaneMesh  ( NULL ),
    m_pBuffer     ( NULL ),
    m_Overlapped  (),
    m_byFill      ( FILL_BYTE_BASE )
{
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the help system
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 0.1f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

	// Set view position
    D3DXMATRIX matView;
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 40.0f);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

	// initialize the airplanes
	m_pPlaneMesh = new CXBMesh;
	m_pPlaneMesh->Create( g_pd3dDevice, "models\\airplane.xbg", &m_xprResource );

    // Initialize the data to be written
    m_pBuffer = new BYTE [ BYTES_PER_CALL ];
    assert( m_pBuffer != NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	// move plane
	static FLOAT fRot = 0.0f;
	fRot += 1.57f * m_fElapsedTime;

    D3DXMATRIX matWorld;
	D3DXMatrixRotationY( &matWorld, fRot );
	FLOAT x = 20.0f * (FLOAT)cos(fRot);
	FLOAT z = -20.0f * (FLOAT)sin(fRot);

	D3DXMATRIX m;
	D3DXMatrixTranslation( &m, x, 0.0f, z );
	D3DXMatrixMultiply( &matWorld, &matWorld, &m );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Activate file write
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
    {
        if( m_Mode == NOTHING )
        {
            CHAR strFile[] = "x:\\testfile.tmp";
            strFile[0] = FILE_DRIVE;

            // Prepare the file for asynchronous writing.
            // Also prepare the file for asynchronous reading for the
            // verification pass.
            // Requires both the OVERLAPPED and NO_BUFFERING flags.
            m_Mode = WRITING;
            m_hFile = CreateFile( strFile, GENERIC_WRITE | GENERIC_READ,
                                  0, NULL, CREATE_ALWAYS,
                                  FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 
                                  NULL );
            assert( m_hFile != INVALID_HANDLE_VALUE );

            // Start writing from the beginning
            m_Overlapped.Offset = 0;
            m_Overlapped.OffsetHigh = 0;
            m_byFill = FILL_BYTE_BASE;

            // Prepare the notification event. This event is signalled when
            // each write is complete.
            m_Overlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
            assert( m_Overlapped.hEvent != NULL );

            // In order for asynchronous writes to be successful, the file
            // cannot grow during the WriteFile() operation. We set the file
            // to its full size before beginning to write. The file size
            // must be an integer multiple of the sector size
            CHAR strDrive[4] = "x:\\";
            strDrive[0] = FILE_DRIVE;
            assert( FILE_BYTES % XGetDiskSectorSize( strDrive ) == 0 );

            DWORD dwPos = SetFilePointer( m_hFile, FILE_BYTES, NULL, FILE_BEGIN );
            assert( dwPos == FILE_BYTES );
            (VOID)dwPos;
            BOOL bSuccess = SetEndOfFile( m_hFile );
            assert( bSuccess );
            (VOID)bSuccess;

#ifdef _DEBUG
            // Fill buffer to a known value for verification
            FillMemory( m_pBuffer, BYTES_PER_CALL, m_byFill );
#endif

            // Start the write. We expect that WriteFile() will initiate 
            // the write but won't finish it during the call.
            BOOL bComplete = WriteFile( m_hFile, m_pBuffer, BYTES_PER_CALL, 
                                        NULL, &m_Overlapped );
            assert( !bComplete );
            (VOID)bComplete;
            assert( GetLastError() == ERROR_IO_PENDING );
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x400000, 1.0f, 0L );

    // Restore state that text clobbers
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );

	m_pPlaneMesh->Render(0);

    switch( m_Mode )
    {
        case NOTHING:                       break;
        case WRITING:   AsyncWrite();       break;
        case READING:   AsyncRead();        break;
        default:        assert( FALSE );    break;
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
    {
        const DWORD NUM_HELP_CALLOUTS = 2;
        XBHELP_CALLOUT HelpCallouts[] =
        {
            { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, L"Display\nhelp" },
            { XBHELP_A_BUTTON, XBHELP_PLACEMENT_1, L"Begin file write" },
        };
        m_Help.Render( &m_Font, HelpCallouts, NUM_HELP_CALLOUTS );
    }
    else
    {
		m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"AsyncWrite" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        if( m_Mode == WRITING || m_Mode == READING )
		{
			WCHAR s[80];
			swprintf( s, L"File %s: %luK/%luK",
                      m_Mode == WRITING ? L"write" : L"verify",
                      m_Overlapped.Offset / ONE_K,
                      FILE_BYTES / ONE_K );
			m_Font.DrawText( 64, 70, 0xffffff00, s );
		}
		else
			m_Font.DrawText( 64, 70, 0xffffff00, L"Press A Button to write file" );

		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: AsyncWrite()
// Desc: Called while the async write is in progress. If the write is still
//       underway, simply returns. If the write has completed, sets up the
//       next write. If the file has been completely written, sets up the
//       verification pass.
//-----------------------------------------------------------------------------
VOID CXBoxSample::AsyncWrite()
{
    assert( m_hFile != INVALID_HANDLE_VALUE );

    // See if the previous write is complete
    DWORD dwBytesTransferred;
    BOOL bIsWriteDone = GetOverlappedResult( m_hFile, &m_Overlapped, 
                                             &dwBytesTransferred, FALSE );

    // If the write isn't complete, keep rendering
    if( !bIsWriteDone )
    {
        assert( GetLastError() == ERROR_IO_INCOMPLETE );
        return;
    }

    // If we get here, the write is complete.
    // Note that m_Overlapped.hEvent has also been reset to non-signalled by
    // GetOverlappedResult(), so we don't have to reset it.
    m_Overlapped.Offset += dwBytesTransferred;

    // Asynchronous writes require that the buffer address is DWORD aligned,
    // the offset is an integer multiple of the sector size, and the
    // number of bytes is an integer multiple of the sector size.
    CHAR strDrive[4] = "x:\\";
    strDrive[0] = FILE_DRIVE;
    assert( DWORD(m_pBuffer) % sizeof(DWORD) == 0 );
    assert( m_Overlapped.Offset % XGetDiskSectorSize( strDrive ) == 0 );
    assert( BYTES_PER_CALL % XGetDiskSectorSize( strDrive ) == 0 );

    // If we've written the entire file, begin the verification pass
    if( m_Overlapped.Offset >= FILE_BYTES )
    {
        // Return to the beginning of the file
        DWORD dwPos = SetFilePointer( m_hFile, 0, NULL, FILE_BEGIN );
        assert( dwPos == 0 );
        (VOID)dwPos;
        
        // Start reading from the beginning
        m_byFill = FILL_BYTE_BASE;
        m_Mode = READING;
        m_Overlapped.Offset = 0;

        // Start the read. We expect that ReadFile() will initiate 
        // the read but won't finish it during the call.
        BOOL bComplete = ReadFile( m_hFile, m_pBuffer, BYTES_PER_CALL,
                                   NULL, &m_Overlapped );
        assert( !bComplete );
        (VOID)bComplete;
        assert( GetLastError() == ERROR_IO_PENDING );
    }
    else
    {
#ifdef _DEBUG
        // Modify the buffer slightly
        ++m_byFill;
        FillMemory( m_pBuffer, BYTES_PER_CALL, m_byFill );
#endif

        // We still have more data to write. Start another asynchronous
        // write to the file.
        BOOL bComplete = WriteFile( m_hFile, m_pBuffer, BYTES_PER_CALL, 
                                    NULL, &m_Overlapped );
        assert( bComplete ||
              ( !bComplete && GetLastError() == ERROR_IO_PENDING ) );
        (VOID)bComplete;
    }
}




//-----------------------------------------------------------------------------
// Name: AsyncRead()
// Desc: Called while the async read is in progress. If the read is still
//       underway, simply returns. If the read has completed, sets up the
//       next read. If the file has been completely read, closes the file.
//-----------------------------------------------------------------------------
VOID CXBoxSample::AsyncRead()
{
    assert( m_hFile != INVALID_HANDLE_VALUE );

    // See if the previous read is complete
    DWORD dwBytesTransferred;
    BOOL bIsReadDone = GetOverlappedResult( m_hFile, &m_Overlapped, 
                                            &dwBytesTransferred, FALSE );

    // If the read isn't complete, keep rendering
    if( !bIsReadDone )
    {
        assert( GetLastError() == ERROR_IO_INCOMPLETE );
        return;
    }

    // If we get here, the read is complete.
    // Note that m_Overlapped.hEvent has also been reset to non-signalled by
    // GetOverlappedResult(), so we don't have to reset it.
    m_Overlapped.Offset += dwBytesTransferred;

    // Verify the buffer
    for( DWORD i = 0; i < BYTES_PER_CALL; ++i )
    {
        assert( m_pBuffer[i] == m_byFill );
    }
    ++m_byFill;

    // Asynchronous reads require that the buffer address is DWORD aligned,
    // the offset is an integer multiple of the sector size, and the
    // number of bytes is an integer multiple of the sector size.
    CHAR strDrive[4] = "x:\\";
    strDrive[0] = FILE_DRIVE;
    assert( DWORD(m_pBuffer) % sizeof(DWORD) == 0 );
    assert( m_Overlapped.Offset % XGetDiskSectorSize( strDrive ) == 0 );
    assert( BYTES_PER_CALL % XGetDiskSectorSize( strDrive ) == 0 );

    // If we've read the entire file, we're done
    if( m_Overlapped.Offset >= FILE_BYTES )
    {
        // Clear the event
        BOOL bSuccess = CloseHandle( m_Overlapped.hEvent );
        assert( bSuccess );
        m_Overlapped.hEvent = NULL;

        // Close the file
        bSuccess = CloseHandle( m_hFile );
        assert( bSuccess );
        m_hFile = NULL;

        // All done
        m_Mode = NOTHING;
    }
    else
    {
        // We still have more data to read. Start another asynchronous
        // read from the file.
        BOOL bComplete = ReadFile( m_hFile, m_pBuffer, BYTES_PER_CALL, 
                                   NULL, &m_Overlapped );
        assert( bComplete ||
              ( !bComplete && GetLastError() == ERROR_IO_PENDING ) );
        (VOID)bComplete;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\asyncwrite\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\asyncwrite\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Wings_OFFSET 0UL
#define resource_BiHull_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugChannel\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\asyncwrite\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Wings_OFFSET 0UL
#define resource_BiHull_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugChannel\dummy.cpp ===
#ifdef DEVKIT
#include "DebugChannel.cpp"
#include "DebugCmd.cpp"
#else
void __cdecl main()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugChannel\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugChannel\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugChannel\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugChannel\debugchannel.cpp ===
// File: DebugChannel.cpp
//
// Desc: Sample to demonstrate how to communicate with a development
//       system over the debug channel.  This sample contains an
//       External Command Processor which will communicate with
//       the Xbox Remote Debug Console sample.
//
// Hist: 02.05.01 - Initial creation for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <xgraphics.h>
#include "DebugCmd.h"

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Flame1.bmp",       resource_Flame1_OFFSET },
    { "forestground.bmp", resource_ForestGround_OFFSET },
    { "grydirt1.bmp",     resource_GryDirt1_OFFSET },
    { "Waterbumps.bmp",   resource_WaterBumps_OFFSET },
    { NULL, 0 },
};




// Define our vertex format
typedef struct _CUSTOMVERTEX
{
    D3DXVECTOR3 p;          // Position
    D3DXVECTOR3 n;          // normal
    D3DCOLOR    diffuse;    // Diffuse color
    FLOAT       tu, tv;     // Texture coordinates
} CUSTOMVERTEX;
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE|D3DFVF_TEX1)

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Display framerate\nto console" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Display texture\nto console" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 4

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBPackedResource       m_xprResource;          // Packed resources for the app
    CXBFont                 m_Font;                 // Font class
    CXBHelp                 m_Help;                 // Help class
    BOOL                    m_bDrawHelp;            // Whether to draw help

    LPDIRECT3DVERTEXBUFFER8 m_pQuad;                // Quad to display
    float                   m_fRadians;             // Radians of rotation

    LPDIRECT3DTEXTURE8      m_ptTex;                // Texture for quad
    BOOL                    m_bForward;             // TRUE if we should spin CW
    float                   m_fRPS;                 // Rotation speed in radians per second
    char                    m_szTexFile[MAX_PATH];  // Filename of texture
    D3DLIGHT8               m_Light;                // Light

    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};

//-----------------------------------------------------------------------------
// Variable declaration block:
// These are the variables exposed to the "set" command. Don't forget to update
// g_nVars to reflect the number of entries
//-----------------------------------------------------------------------------
CXBoxSample g_xbApp;
const DCCMDVARDEF g_rgDCCMDVars[] = 
{
    { "bForward", &g_xbApp.m_bForward, SDOS_bool, NULL },
    { "red", &g_xbApp.m_Light.Diffuse.r, SDOS_R4, RCmdLightChange },
    { "green", &g_xbApp.m_Light.Diffuse.g, SDOS_R4, RCmdLightChange },
    { "blue", &g_xbApp.m_Light.Diffuse.b, SDOS_R4, RCmdLightChange },
};
const UINT g_nVars = 4;


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
void __cdecl main()
{
    // Note: We defined g_xbApp as a global to give access to debug channel
    if( FAILED( g_xbApp.Create() ) )
        return;

    g_xbApp.Run();

}

//-----------------------------------------------------------------------------
// Name: CXBoxSample() (constructor)
// Desc: Constructor for Application class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bForward = TRUE;
    m_pQuad = NULL;
    m_ptTex = NULL;
    m_szTexFile[0] = 0;
    m_fRadians = 0.0f;
    m_fRPS = 0.0f;
    m_bDrawHelp = FALSE;
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Performs whatever initialization is necessary
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    CUSTOMVERTEX * pVertices = NULL;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the help system
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create and set up our vertex buffer for the quad
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( CUSTOMVERTEX ),
                                                  D3DUSAGE_WRITEONLY,
                                                  D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED,
                                                  &m_pQuad ) ) )
        return E_FAIL;

    if( FAILED( m_pQuad->Lock( 0, 0, (BYTE **)&pVertices, 0 ) ) )
        return E_FAIL;

    pVertices[0].diffuse = 0xFFFFFFFF;
    pVertices[0].n = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    pVertices[0].p = D3DXVECTOR3( -0.5f, -0.5f, 1.0f );
    pVertices[0].tu = 0.0f; pVertices[0].tv = 1.0f;

    pVertices[1].diffuse = 0xFFFFFFFF;
    pVertices[1].n = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    pVertices[1].p = D3DXVECTOR3( -0.5f, 0.5f, 1.0f );
    pVertices[1].tu = 0.0f; pVertices[1].tv = 0.0f;

    pVertices[2].diffuse = 0xFFFFFFFF;
    pVertices[2].n = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    pVertices[2].p = D3DXVECTOR3( 0.5f, -0.5f, 1.0f );
    pVertices[2].tu = 1.0f; pVertices[2].tv = 1.0f;

    pVertices[3].diffuse = 0xFFFFFFFF;
    pVertices[3].n = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    pVertices[3].p = D3DXVECTOR3( 0.5f, 0.5f, 1.0f );
    pVertices[3].tu = 1.0f; pVertices[3].tv = 0.0f;

    // Set up our view & projection matrices
    D3DXMATRIX matView;
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 1.0f );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, 1.0f, 1.0f, 10.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set up our light
    ZeroMemory( &m_Light, sizeof( D3DLIGHT8 ) );
    m_Light.Type = D3DLIGHT_DIRECTIONAL;
    m_Light.Diffuse.r = 1.0f;
    m_Light.Diffuse.g = 1.0f;
    m_Light.Diffuse.b = 1.0f;
    m_Light.Diffuse.a = 1.0f;
    m_Light.Direction = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
    m_pd3dDevice->SetLight( 0, &m_Light );
    m_pd3dDevice->LightEnable( 0, TRUE );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Performs all per-frame calculations to update the application state
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    D3DXMATRIX matWorld;

    m_fRadians = (float)fmod( m_fRadians + ( m_fRPS * m_fElapsedAppTime * ( m_bForward ? -1.0f : 1.0f ) ), D3DX_PI * 2 );

    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixRotationZ( &matWorld, m_fRadians );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Handle requests for debug output
    if( m_DefaultGamepad.bPressedAnalogButtons[0] )
    {
        DCCMDPrintf("Framerate is %0.02f fps\n", m_fFPS);
    }
    if( m_DefaultGamepad.bPressedAnalogButtons[1]  )
    {
        DCCMDPrintf("Current texture is %s\n", m_szTexFile );
    }

    // Process any pending commands from the debug channel
    DCHandleCmds();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0x00000000, 1.0f, 0L );

    // Set rendering state
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,    TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,   D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,    0xFFFFFFFF );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,   TRUE );

    // Set our texture stages up
    m_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    m_pd3dDevice->SetTexture( 0, m_ptTex );
    if( m_ptTex )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TEXTURE );
    }
    else
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
    }

    // Draw the quad
    m_pd3dDevice->SetStreamSource( 0, m_pQuad, sizeof( CUSTOMVERTEX ) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
    {
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    }
    else
    {
        m_Font.DrawText(  64, 50, 0xffffffff, L"DebugChannel" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: RCmdTexture
// Desc: Sets the new texture to be used
//-----------------------------------------------------------------------------
void RCmdTexture(int argc, char *argv[])
{
    // Check our arguments
    if( argc < 2 )
    {
        DCCMDPrintf("Need to specify a filename\n");
        return;
    }

    // Release the old texture
    if( g_xbApp.m_ptTex )
        g_xbApp.m_ptTex->Release();

    // Try to grab the new texture
    lstrcpyA( g_xbApp.m_szTexFile, argv[1] );

    g_xbApp.m_ptTex = g_xbApp.m_xprResource.GetTexture( g_xbApp.m_szTexFile );
    if( NULL == g_xbApp.m_ptTex )
    {
        DCCMDPrintf("Couldn't find %s", g_xbApp.m_szTexFile );
        return;
    }
}

//-----------------------------------------------------------------------------
// Name: RCmdSpin
// Desc: Sets the new spin velocity, limited to 2pi in either direction
//-----------------------------------------------------------------------------
void RCmdSpin(int argc, char *argv[])
{
    float fVel;

    // Check our arguments
    if( argc < 2 )
    {
        DCCMDPrintf("Need to specify a velocity\n");
        return;
    }

    fVel = (float)atof( argv[1] );

    if( fabs( fVel ) > D3DX_PI * 2 )
    {
        DCCMDPrintf("Velocity should be betweeen +/- 2 * pi\n");
        return;
    }

    // Set our state
    g_xbApp.m_fRPS = (float)fabs( fVel );
    g_xbApp.m_bForward = ( fVel > 0 );
}

//-----------------------------------------------------------------------------
// Name: RCmdLightChange
// Desc: Called after changing one of our lighting values, so that we can
//       reset the light
//-----------------------------------------------------------------------------
void RCmdLightChange( void * pvAddr )
{
    g_pd3dDevice->SetLight( 0, &g_xbApp.m_Light );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugChannel\DebugCmd.cpp ===
//-----------------------------------------------------------------------------
// File: DebugCmd.CPP
//
// Desc: 
//      Helps an application expose functionality through the debug channel
//  to a debug console running on a remote machine.
//      Commands are sent through the debug channel to the debug monitor on
//  the Xbox machine.  The Xbox machine routes it to the command processor,
//  which is linked into the application (this happens on a separate thread
//  from the application's).  When the application polls for commands to be
//  run (usually once per frame), it can then pick up the command to execute
//  and do the appropriate processing.
//
// Hist: 02.05.01 - Initial creation for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xbdm.h>
#include <stdio.h>

#include "DebugCmd.h"

// our critical section
bool g_fcsInited = false;
CRITICAL_SECTION g_cs;

// command prefix
static const char g_szCmd[] = "XCMD";

// processorproc buffer
static char g_szRemoteBuf[CCH_MAXCMDLEN];

const DCCMDDEF g_rgDCCmds[] =                   // List of app-defined commands
{
    {"help",      RCmdHelp,      " [CMD]: List commands / usage"},
    {"set",       RCmdSet,       " var [=] <val>: set a variable"},
    // Add additional application defined commands here:
    {"texture",   RCmdTexture,   " <filename>: Sets the texture to be used"},
    {"spin",      RCmdSpin,      " <rad/s>: Sets spin velocity in radians per second"},
};


//=========================================================================
// Name: RCmdHelp
// Desc: Builtin command - help
//          Iterates over the list of builtin and application-provided 
//          commands and displays a help string for each one
//=========================================================================
void RCmdHelp(int argc, char *argv[])
{
    int iCmd;

    for(iCmd = 0; iCmd < sizeof(g_rgDCCmds) / sizeof(g_rgDCCmds[0]); iCmd++)
    {
        DCCMDPrintf("%s\t%s\n",
            g_rgDCCmds[iCmd].szCmd,
            g_rgDCCmds[iCmd].szCmdHelp);
    }
}

//=========================================================================
// Name: RCmdSet
// Desc: Builtin command - set
//          Can set or display values of any variables exposed by the 
//          application to the debug console
//=========================================================================
void RCmdSet(int argc, char *argv[])
{
    UINT nIndex;

    if(argc == 1)
    {
        // if we aren't passed any arguments, then just list all the variables and
        // what their current values are.
        for(nIndex = 0; nIndex < g_nVars; nIndex++)
        {
            switch(g_rgDCCMDVars[nIndex].ddt)
            {
            case SDOS_bool:
                DCCMDPrintf("%s\t= %d\n", g_rgDCCMDVars[nIndex].lpstr,
                    *(bool *)g_rgDCCMDVars[nIndex].lpvAddr);
                break;
            case SDOS_I4:
                DCCMDPrintf("%s\t= %d\n", g_rgDCCMDVars[nIndex].lpstr,
                    *(INT *)g_rgDCCMDVars[nIndex].lpvAddr);
                break;
            case SDOS_I2:
                DCCMDPrintf("%s\t= %d\n", g_rgDCCMDVars[nIndex].lpstr,
                    *(WORD *)g_rgDCCMDVars[nIndex].lpvAddr);
                break;
            case SDOS_R4:
                DCCMDPrintf("%s\t= %0.1f\n", g_rgDCCMDVars[nIndex].lpstr,
                    *(float *)g_rgDCCMDVars[nIndex].lpvAddr);
                break;
            }
        }
    }
    else
    {
        // if the user did a set "foo = 2" move arg3 to arg2
        if(argv[2][0] == '=')
            argv[2] = argv[3];

        // Find the entry for this variable, if we can
        for(nIndex = 0; nIndex < g_nVars; nIndex++)
        {
            if(!lstrcmpiA(argv[1], g_rgDCCMDVars[nIndex].lpstr))
            {
                char *endptr;
                DWORD dwVal = (argv[2][0] == '0' && argv[2][1] == 'x') ?
                    strtoul(argv[2], &endptr, 16) : atoi(argv[2]);

                // Set the appropriate type of data
                LPVOID lpvAddr = g_rgDCCMDVars[nIndex].lpvAddr;
                switch(g_rgDCCMDVars[nIndex].ddt)
                {
                case SDOS_bool:
                    *(bool *)lpvAddr = !!dwVal;
                    DCCMDPrintf("set %s = %d\n", argv[1], *(bool *)lpvAddr);
                    break;
                case SDOS_I4:
                    *(INT *)lpvAddr = dwVal;
                    DCCMDPrintf("set %s = %d\n", argv[1], *(INT *)lpvAddr);
                    break;
                case SDOS_I2:
                    *(WORD *)lpvAddr = (WORD)dwVal;
                    DCCMDPrintf("set %s = %d\n", argv[1], *(WORD *)lpvAddr);
                    break;
                case SDOS_R4:
                    *(float *)lpvAddr = (float)atof(argv[2]);
                    DCCMDPrintf("set %s = %0.1f\n", argv[1], *(float *)lpvAddr);
                    break;
                }

                // call the notif func if there was one
                if(g_rgDCCMDVars[nIndex].pfnNotifFunc)
                    g_rgDCCMDVars[nIndex].pfnNotifFunc(lpvAddr);

                return;
            }
        }

        DCCMDPrintf("variable '%s' not found\n", argv[1]);
    }
}

//=========================================================================
// Name: CmdToArgv
// Dsec: Parse szCmd into argv and return # of args. (modifies szCmd)
//=========================================================================
int CmdToArgv(char *szCmd, char *szArg[], int maxargs)
{
    int argc = 0;
    int argcT = 0;
    char *szNil = szCmd + lstrlenA(szCmd);

    while(argcT < maxargs)
    {
        // eat whitespace
        while(*szCmd && (*szCmd == ' '))
            szCmd++;

        if(!*szCmd)
        {
            szArg[argcT++] = (char *)szNil;
        }
        else
        {
            // find the end of this arg
            char chEnd = (*szCmd == '"' || *szCmd == '\'') ? *szCmd++ : ' ';
            char *szArgEnd = szCmd;
            while(*szArgEnd && (*szArgEnd != chEnd))
                szArgEnd++;

            // record this bad boy
            szArg[argcT++] = szCmd;
            argc = argcT;

            // move szArg to the next argument (or not)
            szCmd = *szArgEnd ? szArgEnd + 1 : szArgEnd;
            *szArgEnd = 0;
        }
    }

    return argc;
}


//
// Temporary replacement for CRT string funcs, since
// we can't call CRT functions on the debug monitor
// thread right now.
//

//=========================================================================
// Name: dbgstrlen
// Desc: Returns length of sz
//=========================================================================
int dbgstrlen( LPCSTR sz )
{
    LPCSTR szEnd = sz;
    int len = 0;

    while( *szEnd )
        szEnd++;

    return szEnd - sz;
}

//=========================================================================
// Name: dbglc
// Desc: Returns lowercase of char
//=========================================================================
inline char dbglc( char ch )
{
    if( ch >= 'A' && ch <= 'Z' )
        return ch - ( 'A' - 'a' );
    else
        return ch;
}

//=========================================================================
// Name: dbgstrcmpn
// Desc: String compare.  Returns TRUE if strings are equal up to n 
//       chars or end of string
//=========================================================================
BOOL dbgstrcmpn( LPCSTR sz1, LPCSTR sz2, int n )
{
    while( ( dbglc( *sz1 ) == dbglc( *sz2 ) ) && *sz1 && n > 0 )
    {
        --n;
        ++sz1;
        ++sz2;
    }

    return( n == 0 || dbglc( *sz1 ) == dbglc( *sz2 ) );
}

//=========================================================================
// Name: dbgstrcpy
// Desc: Copies szSrc to szDest and terminates szDest
//=========================================================================
void dbgstrcpy( LPSTR szDest, LPCSTR szSrc )
{
    while( ( *szDest++ = *szSrc++ ) != 0 )
        ;
}
    
//=========================================================================
// Name: DCCmdPRocessorProc
// Desc: Cmd notification proc
//
//  This is what is called by the Xbox debug monitor to have us process
//  a command.  What we'll actually attempt to do is tell it to make calls
//  to us on a separate thread, so that we can just block until we're 
//  able to process a command.
//=========================================================================
HRESULT __stdcall DCCmdProcessorProc(LPCSTR szCommand, LPSTR szResp,
    DWORD cchResp, PDM_CMDCONT pdmcc)
{

    // skip over prefix
    LPCSTR szCmd = szCommand + lstrlenA(g_szCmd) + 1;
    BOOL   fKnownCommand = FALSE;

    // check if this is the initial connect signal
    if(dbgstrcmpn(szCmd, "__connect__", 11))
    {
        // if so, respond that we're connected
        lstrcpynA(szResp, "Connected.", cchResp);
        return XBDM_NOERR;
    }

    // check to see if the cmd exists
    for(int iCmd = 0; iCmd < sizeof(g_rgDCCmds) / sizeof(g_rgDCCmds[0]); iCmd++)
    {
        if(dbgstrcmpn(g_rgDCCmds[iCmd].szCmd, szCmd, dbgstrlen(g_rgDCCmds[iCmd].szCmd)))
        {
            // If we find the string, copy it into the command buffer
            // to be examined by the polling function
            fKnownCommand = TRUE;
            break;
        }
    }

    if( fKnownCommand )
    {
        // g_szRemoteBuf needs to be protected by the critical section
        EnterCriticalSection(&g_cs);
        if( g_szRemoteBuf[0] )
        {
            // This means the application has probably stopped polling for debug commands
            dbgstrcpy( szResp, "Cannot execute - previous command still pending" );
        }
        else
        {
            dbgstrcpy( g_szRemoteBuf, szCmd );
        }
        LeaveCriticalSection(&g_cs);
    }
    else
    {
        dbgstrcpy( szResp, "unknown command" );
    }

    return XBDM_NOERR;
}

//=========================================================================
// Name: DCHandleCmds
// Desc: Poll routine called by Xbox app
//
//  The application should call this function periodically, usually every
//  frame.  This will check to see if there is a command waiting to be
//  executed, and if so, execute it.
//=========================================================================
BOOL DCHandleCmds()
{
    static BOOL fRegistered = false;
    char *      szArgv[10];
    int         argc;
    char        szLocalBuf[CCH_MAXCMDLEN]; // local copy of command

    // Initialize ourselves when we're first called.
    if(!fRegistered)
    {
        // init our critical section
        if(!g_fcsInited)
        {
            InitializeCriticalSection(&g_cs);
            g_fcsInited = true;
        }

        // register our command handler with the debug monitor
        HRESULT hr = DmRegisterCommandProcessor(g_szCmd, DCCmdProcessorProc);
        if(FAILED(hr))
            return false;

        fRegistered = true;
    }

    // If there's nothing waiting, return.
    if( !g_szRemoteBuf[0] )
    {
        return false;
    }

    // 
    // Grab a copy of the command to free up
    // the crtical section
    //
    EnterCriticalSection(&g_cs);

    lstrcpyA( szLocalBuf, g_szRemoteBuf );
    g_szRemoteBuf[0] = 0;

    LeaveCriticalSection(&g_cs);

    // Now process the command
    argc = CmdToArgv(szLocalBuf, szArgv, 10);

    // Find the entry in our command list
    for(int iCmd = 0; iCmd < sizeof(g_rgDCCmds) / sizeof(g_rgDCCmds[0]); iCmd++)
    {
        if(!lstrcmpiA(g_rgDCCmds[iCmd].szCmd, szArgv[0]))
        {
            g_rgDCCmds[iCmd].pfnHandler(argc, szArgv);
            break;
        }
    }

    return true;
}

//=========================================================================
// Name: DCCMDPrintf 
// Desc: Asynchronous printf routine that sends the string to the 
//          Remote Xbox Command Client
//=========================================================================
BOOL DCCMDPrintf(LPCSTR szFmt, ...)
{
    char szBuf[CCH_MAXCMDLEN];
    int cch;
    va_list arglist;

    // copy prefix into into buffer
    for(int ich = 0; ich < sizeof(g_szCmd); ich++)
        szBuf[ich] = g_szCmd[ich];
    szBuf[ich - 1] = '!';

    // format arguments
    va_start(arglist, szFmt);
    cch = _vsnprintf(&szBuf[ich], CCH_MAXCMDLEN - ich, szFmt, arglist);
    va_end(arglist);

    // send it out
    DmSendNotificationString(szBuf);
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugChannel\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugChannel\DebugCmd.h ===
//-----------------------------------------------------------------------------
// File: DebugCmd.H
//
// Desc: Remote Xbox command header
//
// This header file should be included into your application.  It provides 
// function and type definitions.  You will also need to modify the following
// variables:
//
// g_rgDCCmds - This is the list of commands your application provides.  Note
//  that "help" and "set" are provided automatically and can not be overriden.
//  This is currently defined in DebugCmd.cpp
// g_rgDCCMDVars - This is a list of variables that your application exposes.
//  They can be examined and modified by the builtin "set" command.
//  This should be defined in your application source, after including DebugCmd.h
//
// Hist: 02.05.01 - Initial creation for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _DEBUGCMD_H
#define _DEBUGCMD_H

/////////////////////////////////////////////////////////////////////////////
// Commands
/////////////////////////////////////////////////////////////////////////////

void RCmdHelp(int argc, char *argv[]);          // Help command
void RCmdSet(int argc, char *argv[]);           // Set command
// Add prototypes for your app-defined commands here
void RCmdTexture(int argc, char *argv[]);       // Sets the texture
void RCmdSpin(int argc, char *argv[]);          // Sets the spin velocity
void RCmdLightChange( void * );                 // Notified on light changes

#define CCH_MAXCMDLEN       256
typedef void (*RCMDSHANDLER)(int argc, char *argv[]);

// Command definition structure
typedef struct _DCCMDDEF
{
    LPSTR           szCmd;                      // Name of command
    RCMDSHANDLER    pfnHandler;                 // Handler function
    LPSTR           szCmdHelp;                  // Description of command
} DCCMDDEF;

extern const DCCMDDEF g_rgDCCmds[];             // List of app-defined commands


/////////////////////////////////////////////////////////////////////////////
// Variables
/////////////////////////////////////////////////////////////////////////////

enum DCCMDDATATYPES { SDOS_bool, SDOS_I2, SDOS_I4, SDOS_R4 };
typedef void (*DCCMDSETNOTIF)(LPVOID lpvAddr);

// Variable definition structure
typedef struct _DCCMDVARDEF
{
    LPCSTR          lpstr;                      // Name of variable
    LPVOID          lpvAddr;                    // Address of variable
    DCCMDDATATYPES  ddt;                        // Data type of variable
    DCCMDSETNOTIF   pfnNotifFunc;               // Function to call upon change
} DCCMDVARDEF;

// These should get defined in your application cpp file:
extern const DCCMDVARDEF g_rgDCCMDVars[];       // List of application variables
extern const UINT        g_nVars;               // Number of application vars


/////////////////////////////////////////////////////////////////////////////
// Misc
/////////////////////////////////////////////////////////////////////////////

//
// handle any remote commands that have been sent - this
// should be called periodically by the application
//
BOOL DCHandleCmds();

//
// asynchronous printf - this is used to send
// responses back to the debug console
//
BOOL DCCMDPrintf(LPCSTR szFmt, ...);

#endif // _DEBUGCMD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugChannel\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 4UL

#define resource_Flame1_OFFSET 0UL
#define resource_ForestGround_OFFSET 20UL
#define resource_GryDirt1_OFFSET 40UL
#define resource_WaterBumps_OFFSET 60UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugChannel\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 4UL

#define resource_Flame1_OFFSET 0UL
#define resource_ForestGround_OFFSET 20UL
#define resource_GryDirt1_OFFSET 40UL
#define resource_WaterBumps_OFFSET 60UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugConsole\DebugConsole.h ===
//-----------------------------------------------------------------------------
// File: DebugConsole.h
//
// Desc: Remote Xbox Debug Console header
//
// Hist: 1.24.01 - New for March release
//      11.29.01 - Fixed possible hang when disconnecting 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <winsock2.h>
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>

#include <stdio.h>
#include <malloc.h>

#include <richedit.h>
#include <assert.h>

#include <xboxdbg.h>

#include "resource.h"

#define CMD_PREFIX      "XCMD"

#define NUM_STRINGS 50
#define MAX_STRING_LEN 512
typedef struct 
{
    CRITICAL_SECTION CriticalSection;   // Critical section
    DWORD            dwNumMessages;     // # of messages

    // Array of strings
    COLORREF         aColors[NUM_STRINGS];  // Text color
    CHAR             astrMessages[NUM_STRINGS][MAX_STRING_LEN];
} PrintQueue;

struct DebugConsole
{
    HWND hDlgMain;      // main hwnd
    HWND hwndCb;        // combobox hwnd
    HWND hwndCbEdit;    // combobox edit hwnd
    HWND hwndOut;       // output window

    int ichCaretTab;    // current caret location for tab completion
    int ichTabStart;    // current tab command

    BOOL fConnected;    // Connected to Xbox?
    BOOL fECPConnected; // Connected to ECP in application?
    BOOL fDebugMonitor; // Display debug output?

    PDMN_SESSION   pdmnSession;     // Debug Monitor Session
    PDM_CONNECTION pdmConnection;   // Debug Monitor Connection

    WNDPROC wndprocLB;
};

// global environment
extern DebugConsole       g_DCEnv;
extern PrintQueue         g_PrintQueue;

// prototypes
LRESULT CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK SubclassedLBProc(HWND hDlg, UINT msg,
    WPARAM wParam, LPARAM lParam);

void DisplayError(const char *szApiName, HRESULT hr);

int RtfPrintf(COLORREF rgb, LPCTSTR lpFmt, ...);

int CmdToArgv(char *szCmd, char *szArg[], int maxargs);

#define C_MAXARGVELEMS      10
#define MAX_CMDLEN          256

//
// Command handler prototypes
//
bool RCmdHelp(int argc, char *argv[]);
bool RCmdCls(int argc, char *argv[]);
bool RCmdConnect(int argc, char *argv[]);
bool RCmdDisconnect(int argc, char *argv[]);
bool RCmdQuit(int argc, char *argv[]);
bool RCmdSendFile(int argc, char *argv[]);
bool RCmdGetFile(int argc, char *argv[]);

typedef bool (*RCMDHANDLER)(int argc, char *argv[]);

void EnqueueStringForPrinting( COLORREF rgb, LPCTSTR lpFmt, ... );
void ProcessEnqueuedStrings();

#define DCCMDTAG(_cmd, _cmdhelp, _handler) { _cmd, _cmdhelp, _handler }
static const struct DCCMDS
{
    LPCTSTR     szCmd;
    RCMDHANDLER pfnHandler;
    LPCTSTR     szCmdHelp;
} rgDCCmds[] =
{
    // These are local commands
    DCCMDTAG( "help",               RCmdHelp,       " [CMD]: List commands / usage" ),
    DCCMDTAG( "cls",                RCmdCls,        ": clear the screen" ),
    DCCMDTAG( "connect",            RCmdConnect,    " [server] [portno]: connect to server @ portno" ),
    DCCMDTAG( "disconnect",         RCmdDisconnect, ": Terminate Debug Console session" ),
    DCCMDTAG( "quit",               RCmdQuit,       ": hasta luego" ),
    
    // These are routed through DmSendFile/ReceiveFile to handle file I/O
    DCCMDTAG( "sendfile",           RCmdSendFile,   " <localfile> <remotefile>: Sends a file to Xbox" ),
    DCCMDTAG( "getfile",            RCmdGetFile,    " <remotefile> <localfile>: Gets a file from Xbox" ),

    // These are all sent directly through to the debug monitor and their output will be displayed
    DCCMDTAG( "break",              NULL,           " addr=<address> | \n'Write'/'Read'/'Execute'=<address> size=<DataSize>\n['clear']: Sets/Clears a breakpoint" ),
    DCCMDTAG( "bye",                NULL,           " : Closes connection" ),
    DCCMDTAG( "continue",           NULL,           " thread=<threadid>: resumes execution of a thread which has been stopped" ),
    DCCMDTAG( "delete",             NULL,           " name=<remotefile>: Deletes a file on the Xbox" ),
    DCCMDTAG( "dirlist",            NULL,           " name=<remotedir>: Lists the items in the directory" ),
    DCCMDTAG( "getcontext",         NULL,           " thread=<threadid> 'Control' | 'Int' | 'FP' | 'Full':  Gets the context of the thread" ),
    DCCMDTAG( "getfileattributes",  NULL,           " name=<remotefile>: Gets attributes of a file" ),
    DCCMDTAG( "getmem",             NULL,           " addr=<address> length=<len> Reads memory from the Xbox" ),
    DCCMDTAG( "go",                 NULL,           " : Resumes suspended title threads" ),
    DCCMDTAG( "halt",               NULL,           " thread=<threadid> Breaks a thread" ),
    DCCMDTAG( "isstopped",          NULL,           " thread=<threadid>: Determines if a thread is stopped and why" ),
    DCCMDTAG( "mkdir",              NULL,           " name=<remotedir>: Creates a new directory on the Xbox" ),
    DCCMDTAG( "modlong",            NULL,           " name=<module>: Lists the long name of the module" ),
    DCCMDTAG( "modsections",        NULL,           " name=<module>: Lists the sections in the module" ),
    DCCMDTAG( "modules",            NULL,           " : Lists currently loaded modules" ),
    DCCMDTAG( "reboot",             NULL,           " [warm] [wait]: Reboots the xbox" ),
    DCCMDTAG( "rename",             NULL,           " name=<remotefile> newname=<newname>: Renames a file on the Xbox" ),
    DCCMDTAG( "resume",             NULL,           " thread=<threadid>: Resumes thread execution" ),
    DCCMDTAG( "setcontext",         NULL,           " thread=<threadid> Sets the context of the thread." ),
    DCCMDTAG( "setfileattributes",  NULL,           " <remotefile> <attrs>: Sets attributes of a file" ),
    DCCMDTAG( "setmem",             NULL,           " addr=<address> data=<rawdata>: Sets memory on the Xbox" ),
    DCCMDTAG( "stop",               NULL,           " : Stops the process" ),
    DCCMDTAG( "suspend",            NULL,           " thread=<threadid> Suspends the thread" ),
    DCCMDTAG( "systime",            NULL,           " : gets the system time of the xbox" ),
    DCCMDTAG( "threadinfo",         NULL,           " thread=<threadid>: Gets thread info" ),
    DCCMDTAG( "threads",            NULL,           " : gets the thread list" ),
    DCCMDTAG( "title",              NULL,           " dir=<remotedir> name=<remotexbe> [cmdline=<cmdline>]: Sets title to run" ),
    DCCMDTAG( "xbeinfo",            NULL,           " name=<remotexbe | 'running'>: Gets info on an xbe" ),

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugConsole\commands.cpp ===
//-----------------------------------------------------------------------------
// File: commands.cpp
//
// Desc: Remote Xbox Debug Console
//
// Hist: 1.24.01 - New for March release
//      11.29.01 - Fixed possible hang when disconnecting 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "DebugConsole.h"
#include "xboxdbg.h"


//-----------------------------------------------------------------------------
// Name: ExtNotifyFunc
// Desc: Notifier function registered via DmRegisterNotificationProcessor 
//          below.  This is called to return output from the remote ECP
//-----------------------------------------------------------------------------
DWORD __stdcall ExtNotifyFunc(LPCSTR szNotification)
{
    EnqueueStringForPrinting(RGB(0, 0, 255), "%s\n", szNotification);
    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: HandleDebugString
// Desc: Prints debug output to the output window, if desired
//-----------------------------------------------------------------------------
DWORD __stdcall HandleDebugString( ULONG dwNotification, DWORD dwParam )
{
    if( g_DCEnv.fDebugMonitor )
    {
        PDMN_DEBUGSTR p = (PDMN_DEBUGSTR)dwParam;

        // The string may not be null-terminated, so
        // make a terminated copy for printing
        CHAR * pszTemp = new CHAR[ p->Length + 1 ];
        memcpy( pszTemp, p->String, p->Length * sizeof( CHAR ) );
        pszTemp[ p->Length ] = 0;
        EnqueueStringForPrinting(RGB(0xA0, 0xA0, 0xA0), "Dbg: %s\n", p->String );

        delete[] pszTemp;
    }

    return 0;
}

//-----------------------------------------------------------------------------
// Name: RCmdHelp
// Desc: Handles the "help" command.  If no args, prints a list of builtin
//          and remote commands (remote only if connected).  If a command
//          is specified, prints detailed help for that command
//-----------------------------------------------------------------------------
bool RCmdHelp(int argc, char *argv[])
{
    int nCmds = sizeof(rgDCCmds) / sizeof(rgDCCmds[0]);

    if(!argv[1][0])
    {
        // No arguments - print out our list of commands, 
        // 3 per line
        for(int iCmd = 0; iCmd < nCmds; iCmd += 3)
        {
            RtfPrintf(CLR_INVALID, "%s\t%s\t%s\n",
                rgDCCmds[iCmd].szCmd,
                (iCmd + 1) < nCmds ? rgDCCmds[iCmd + 1].szCmd : "",
                (iCmd + 2) < nCmds ? rgDCCmds[iCmd + 2].szCmd : "");
        }

        if(g_DCEnv.fConnected && g_DCEnv.fECPConnected)
        {
            RtfPrintf(CLR_INVALID, "Remote Commands:\n");
            return false;   // Pass the command to ECP
        }
    }
    else
    {
        int cch = lstrlen(argv[1]);

        // Print help description for all matches
        for(int iCmd = 0; iCmd < nCmds; iCmd++)
        {
            if(!_strnicmp(rgDCCmds[iCmd].szCmd, argv[1], cch) && rgDCCmds[iCmd].szCmdHelp)
            {
                RtfPrintf(CLR_INVALID, "%s%s\n", rgDCCmds[iCmd].szCmd, rgDCCmds[iCmd].szCmdHelp);
            }
        }
    }
    return true;
 
}

//-----------------------------------------------------------------------------
// Name: RCmdCls
// Desc: Handles the CLS command by clearing the output window
//-----------------------------------------------------------------------------
bool RCmdCls(int argc, char *argv[])
{
    SetWindowText(g_DCEnv.hwndOut, "");
    return true;
}

//-----------------------------------------------------------------------------
// Name: RCmdConnect:
// Desc: Handles the connect command by first opening a connection to the
//          debug monitor on the Xbox and opening a notification session.  
//          Then we set notification handlers for debug output and our ECP.
//          Finally, we send a special __connect__ command to our ECP to
//          let him initialize himself, if an ECP-enabled app is running.
//-----------------------------------------------------------------------------
bool RCmdConnect(int argc, char *argv[])
{
    HRESULT hr;

    // Set the xbox machine name to connect to, if specified
    if(argc && argv[1][0])
    {
        hr = DmSetXboxName(argv[1]);
        if(FAILED(hr))
            DisplayError("DmSetXboxName", hr);
    }

    // Open our connection
    hr = DmOpenConnection(&g_DCEnv.pdmConnection);
    if( FAILED( hr ) )
    {
        DisplayError("DmOpenConnection", hr );
        return true;
    }

    g_DCEnv.fConnected = true;

    // Make sure we'll be able to receive notifications
    hr = DmOpenNotificationSession( 0, &g_DCEnv.pdmnSession );
    if( FAILED( hr ) )
    {
        DisplayError("DmOpenNotificationSession", hr);
        return true;
    }
    hr = DmNotify(g_DCEnv.pdmnSession, DM_DEBUGSTR, HandleDebugString);
    if( FAILED( hr ) )
    {
        DisplayError("DmNotify", hr);
        return true;
    }
    g_DCEnv.fDebugMonitor = FALSE;

    hr = DmRegisterNotificationProcessor(g_DCEnv.pdmnSession, CMD_PREFIX, ExtNotifyFunc);
    if( FAILED( hr ) )
    {
        DisplayError("DmRegisterNotificationProcessor", hr);
        return true;
    }

    // send initial connect command to ECP so it knows we're here
    {
        DWORD cchResp = MAX_PATH;
        char szResp[MAX_PATH];

        hr = DmSendCommand(g_DCEnv.pdmConnection, CMD_PREFIX "!__connect__", szResp, &cchResp);
        if(FAILED(hr))
        {
            RtfPrintf(RGB(255, 0, 0), "Couldn't connect to Application - standard debug commands only\n");
        }
        else {
            g_DCEnv.fECPConnected = TRUE;
            if(cchResp)
                RtfPrintf(RGB(0, 0, 255), "%s\n", szResp);
        }
    }

    return true;
}

//-----------------------------------------------------------------------------
// Name: RCmdDisconnect
// Desc: Handles the disconnect command by
//          1) Shut down our notifications
//          2) Close the notification session
//          3) Close the connection
//-----------------------------------------------------------------------------
bool RCmdDisconnect(int argc, char *argv[])
{
    if(g_DCEnv.fConnected)
    {
        RtfPrintf(CLR_INVALID, "Closing connection\n");
        DmNotify(g_DCEnv.pdmnSession, DM_NONE, NULL);
        DmCloseNotificationSession( g_DCEnv.pdmnSession );
        DmCloseConnection(g_DCEnv.pdmConnection);
        g_DCEnv.fConnected = g_DCEnv.fECPConnected = false;
    }

    return true;
}

//-----------------------------------------------------------------------------
// Name: RCmdQuit
// Desc: Handles the quit command by posting a WM_CLOSE message to our window
//-----------------------------------------------------------------------------
bool RCmdQuit(int argc, char *argv[])
{
    PostMessage(g_DCEnv.hDlgMain, WM_CLOSE, 0, 0);
    return true;
}

//-----------------------------------------------------------------------------
// Name: RCmdSendFile
// Desc: Handles the sendfile command by sending the arguments along to
//          DmSendFile
//-----------------------------------------------------------------------------
bool RCmdSendFile(int argc, char *argv[])
{
    if( argc != 3 )
    {
        return true;
    }

    return !FAILED( DmSendFile( argv[1], argv[2] ) );
}

//-----------------------------------------------------------------------------
// Name: RCmdGetFile
// Desc: Handles the getfile command by sending the arguments along to
//      DmReceiveFile
//-----------------------------------------------------------------------------
bool RCmdGetFile(int argc, char *argv[])
{
    if( argc != 3 )
    {
        return true;
    }

    return !FAILED( DmReceiveFile( argv[2], argv[1] ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugConsole\DebugConsole.cpp ===
//-----------------------------------------------------------------------------
// File: DebugConsole.cpp
//
// Desc: Remote Xbox Debug Console
//
// Hist: 1.24.01 - New for March release
//      11.29.01 - Fixed possible hang when disconnecting 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "DebugConsole.h"
#include "xboxdbg.h"

// global environment
DebugConsole g_DCEnv;
PrintQueue   g_PrintQueue;
static const char szAppName[] = "DebugConsole";
PDMN_SESSION g_dmnSession;


//-----------------------------------------------------------------------------
// Name: InitMainDlg
// Desc: Performs some initialization, caching hwnds, etc.
//-----------------------------------------------------------------------------
void InitMainDlg()
{
    // remember some useful hwnds
    g_DCEnv.hwndOut = GetDlgItem(g_DCEnv.hDlgMain, IDC_RICHEDITCON);
    g_DCEnv.hwndCb = GetDlgItem(g_DCEnv.hDlgMain, IDC_RICHEDITCMD);
    g_DCEnv.hwndCbEdit = GetWindow(g_DCEnv.hwndCb, GW_CHILD);

    // subclass our dropdown listbox to handle return key
    g_DCEnv.wndprocLB = SubclassWindow(g_DCEnv.hwndCbEdit, SubclassedLBProc);

    ShowWindow(g_DCEnv.hDlgMain, SW_SHOWNORMAL);

    // get our render window handle
    g_DCEnv.hwndOut = GetDlgItem(g_DCEnv.hDlgMain, IDC_RICHEDITCON);
    g_DCEnv.hwndCb = GetDlgItem(g_DCEnv.hDlgMain, IDC_RICHEDITCMD);

    // change the font type to courier
    CHARFORMAT cf;

    cf.cbSize = sizeof(CHARFORMAT);
    SendMessage(g_DCEnv.hwndOut, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
    
    cf.dwMask &= ~CFM_COLOR;
    lstrcpy(cf.szFaceName, "courier");
    SendMessage(g_DCEnv.hwndOut, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
}

//-----------------------------------------------------------------------------
// Name: WinMain
// Desc: Entry point for program
//-----------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst,
    LPSTR lpszCmdLine, int nCmdShow)
{
    HACCEL      hAccel;
    MSG         msg = {0};
    WNDCLASS    wndclass;

    // Set up our print queue
    InitializeCriticalSection( &g_PrintQueue.CriticalSection );
    g_PrintQueue.dwNumMessages = 0;

    InitCommonControls();
    // Needed for rich edit controls
    HMODULE hRichEdit = LoadLibrary("Riched32.dll");
    assert(hRichEdit);

    //
    // Set up our window class
    //
    wndclass.style         = 0;
    wndclass.lpfnWndProc   = DlgProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = DLGWINDOWEXTRA;
    wndclass.hInstance     = hInst;
    wndclass.hIcon         = LoadIcon(hInst, szAppName);
    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = GetStockBrush(LTGRAY_BRUSH);
    wndclass.lpszMenuName  = MAKEINTRESOURCE(MENU_DebugConsole);
    wndclass.lpszClassName = szAppName;

    RegisterClass(&wndclass);

    // create our main dialog
    if(!(g_DCEnv.hDlgMain = CreateDialog(hInst, szAppName, 0, NULL)))
    {
        char sz[255];

        FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, GetLastError(), 0, sz, 255, NULL );
        MessageBeep(0);
        goto err;
    }

    // Init RTF controls, etc.
    InitMainDlg();

    hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_MAIN_ACCEL));

    while(GetMessage(&msg, NULL, 0, 0))
    {
        if(!TranslateAccelerator(g_DCEnv.hDlgMain, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

err:
    FreeLibrary( hRichEdit );
    return msg.wParam;
}



//-----------------------------------------------------------------------------
// Name: EnqueueStringForPrinting
// Desc: Formats the string and adds it to the print queue
//-----------------------------------------------------------------------------
void EnqueueStringForPrinting( COLORREF rgb, LPCTSTR lpFmt, ... )
{
    assert( g_PrintQueue.dwNumMessages <= NUM_STRINGS );

    // Enter critical section so we don't try to process the list
    EnterCriticalSection( &g_PrintQueue.CriticalSection );

    // If the queue is full, that means the main thread is probably blocked
    // and we'll have to drop this message.  Either allocate more space,
    // or make sure windows messages get processed more frequently on the
    // main thread.
    if( g_PrintQueue.dwNumMessages == NUM_STRINGS )
    {
        LeaveCriticalSection( &g_PrintQueue.CriticalSection );
        return;
    }

    // Print the message into the next slot
    va_list arglist;
    va_start( arglist, lpFmt );
    _vsnprintf( g_PrintQueue.astrMessages[ g_PrintQueue.dwNumMessages ],
                MAX_STRING_LEN,
                lpFmt,
                arglist );
    va_end( arglist );
    g_PrintQueue.aColors[ g_PrintQueue.dwNumMessages++ ] = rgb;

    // Ensure we've got a message posted to process the print queue
    if( g_PrintQueue.dwNumMessages == 1 )
        PostMessage( g_DCEnv.hDlgMain, WM_USER, 0, 0 );

    // Done - now the main thread can safely process the list
    LeaveCriticalSection( &g_PrintQueue.CriticalSection );


}

    

//-----------------------------------------------------------------------------
// Name: ProcessEnqueuedStrings
// Desc: Processes the list of enqueued strings to be printed (put there by
//       our notification handlers)
//-----------------------------------------------------------------------------
void ProcessEnqueuedStrings()
{
    // Enter critical section so we don't try to add anything while
    // we're processing
    EnterCriticalSection( &g_PrintQueue.CriticalSection );

    for( DWORD i = 0; i < g_PrintQueue.dwNumMessages; i++ )
    {
        RtfPrintf( g_PrintQueue.aColors[i], "%s", g_PrintQueue.astrMessages[i] );
    }

    g_PrintQueue.dwNumMessages = 0;

    // Done - now we can safely add to the list
    LeaveCriticalSection( &g_PrintQueue.CriticalSection );
}



//-----------------------------------------------------------------------------
// Name: RtfPrintf
// Desc: Writes out a string directly to the console window
//-----------------------------------------------------------------------------
int RtfPrintf( COLORREF rgb, LPCTSTR lpFmt, ...)
{
    int cch;
    char szT[512];
    va_list arglist;
    CHARRANGE cr = { -1, -2 };

    if(rgb != CLR_INVALID)
    {
        // set whatever colors, etc. they want
        CHARFORMAT cf = {0};

        cf.cbSize = sizeof(cf);
        cf.dwMask = CFM_COLOR;
        cf.dwEffects = 0;
        cf.crTextColor = rgb;

        SendDlgItemMessage(g_DCEnv.hDlgMain, IDC_RICHEDITCON, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
    }

    // Get our string to print
    va_start( arglist, lpFmt );
    cch = _vsnprintf(szT, sizeof(szT), lpFmt, arglist);
    va_end( arglist );

    // move the selection to the end
    SendDlgItemMessage(g_DCEnv.hDlgMain, IDC_RICHEDITCON, EM_EXSETSEL, 0, (LPARAM)&cr);

    // add the text and scroll it into view
    SendDlgItemMessage(g_DCEnv.hDlgMain, IDC_RICHEDITCON, EM_REPLACESEL, 0, (LONG)(LPSTR)szT);
    SendDlgItemMessage(g_DCEnv.hDlgMain, IDC_RICHEDITCON, EM_SCROLLCARET, 0, 0L);

    return cch;
}


//-----------------------------------------------------------------------------
// Name: RCmdHandle
// Desc: Command parser and dispatcher
//-----------------------------------------------------------------------------
bool RCmdHandle(char *szCmd)
{
    TCHAR szCmdBak[MAX_PATH];
    char *argv[C_MAXARGVELEMS];
    BOOL fBuiltinCommand = FALSE;

    // Make a copy of the original command string
    lstrcpy(szCmdBak, szCmd);

    int argc = CmdToArgv(szCmd, argv, C_MAXARGVELEMS);

    // Nothing but whitespace?
    if(!argv[0][0])
        return true;

    // See if we already have this entry in the command history
    int iIndex = ComboBox_FindStringExact(g_DCEnv.hwndCb, -1, szCmdBak);
    if(iIndex != CB_ERR)
    {
        ComboBox_DeleteString(g_DCEnv.hwndCb, iIndex);
    }
    ComboBox_InsertItemData(g_DCEnv.hwndCb, 0, szCmdBak);

    // limit the # of history items
    if((iIndex = ComboBox_GetCount(g_DCEnv.hwndCb)) > 25)
        ComboBox_DeleteString(g_DCEnv.hwndCb, iIndex - 1);

    // see if the command is recognized
    for(int iCmd = 0; iCmd < sizeof(rgDCCmds) / sizeof(rgDCCmds[0]); iCmd++)
    {
        if(!lstrcmpi(rgDCCmds[iCmd].szCmd, argv[0]))
        {
            // echo command to the window
            RtfPrintf(CLR_INVALID, "%s\n", szCmdBak);

            // If handler was null, that means send it through raw to the XBox
            if( !rgDCCmds[iCmd].pfnHandler )
            {
                fBuiltinCommand = TRUE;
                break;
            }

            // If we called a handler, and it returns false, 
            // then we should send the command remotely as
            // well, otherwise we're done
            if(!rgDCCmds[iCmd].pfnHandler(argc, argv))
                break;

            return true;
        }
    }

    // ok, try to send the command over the wire
    if(g_DCEnv.fConnected)
    {
        char    szRemoteCmd[MAX_PATH + 10];
        char    szResp[MAX_PATH];
        DWORD   cchResp = MAX_PATH;
        HRESULT hr;

        if( !fBuiltinCommand )
        {
            // 
            // App-defined commands need a command
            // prefix to get routed properly
            //
            lstrcpy(szRemoteCmd, CMD_PREFIX "!");
            lstrcat(szRemoteCmd, szCmdBak);

            // echo remote command
            RtfPrintf(CLR_INVALID, "%s\n", szRemoteCmd);
        }
        else
            lstrcpy(szRemoteCmd, szCmdBak);

        // Send the command to the Xbox
        hr = DmSendCommand(g_DCEnv.pdmConnection, szRemoteCmd, szResp, &cchResp);

        if(FAILED(hr))
            DisplayError("DmSendCommand", hr);
        else
        {
            // There are different success codes.  If your app defines
            // a command which needs or returns binary data, You will
            // need to take appropriate action here.
            switch( hr )
            {
            case XBDM_NOERR:
                if(cchResp)
                    RtfPrintf(RGB(0, 0, 255), "%s\n", szResp);
                break;
            case XBDM_MULTIRESPONSE:
                // Multi-line response - loop, looking for end of response
                for( ; ; )
                {
                    DWORD cchResp = sizeof(szResp);

                    hr = DmReceiveSocketLine( g_DCEnv.pdmConnection, szResp, &cchResp );
                    if( FAILED(hr) || szResp[0] == '.' )
                        break;
                    RtfPrintf(RGB( 0, 0, 255), "%s\n", szResp);
                }
                break;
            case XBDM_BINRESPONSE:
                RtfPrintf( RGB( 255, 0, 0 ), "Binary response - can't handle\n");
                break;
            case XBDM_READYFORBIN:
                RtfPrintf( RGB( 0, 0, 255 ), "Waiting for binary data\n");
                break;
            default:
                RtfPrintf( RGB( 255, 0, 0 ), "Unknown success code (%s).\n", szResp );
                break;
            }
        }
    }
    return true;
}

//-----------------------------------------------------------------------------
// Name: HandleWmKeyDown
// Desc: Handle a WmKeyDown in our RTF cmd window
//-----------------------------------------------------------------------------
bool HandleWmKeyDown(WPARAM wParam)
{
    bool fhandled = false;

    switch(wParam)
    {
    case VK_RETURN:
        // User hit return in the combo box
        if(ComboBox_GetDroppedState(g_DCEnv.hwndCb))
        {
            ComboBox_ShowDropdown(g_DCEnv.hwndCb, FALSE);
        }
        else
        {
            PostMessage(g_DCEnv.hDlgMain, WM_APP, 0, 0);
            fhandled = true;
        }
        break;
    }

    return fhandled;
}

//-----------------------------------------------------------------------------
// Name: SubclassedLBProc
// Desc: Our subclassed listbox proc
//-----------------------------------------------------------------------------
LRESULT CALLBACK SubclassedLBProc(HWND hDlg, UINT msg,
    WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
    case WM_KEYDOWN:
        if(HandleWmKeyDown(wParam))
            return 1;
        break;
    case WM_CHAR:
        if(wParam == VK_RETURN)
            return 1;
        break;
    }

    return CallWindowProc(g_DCEnv.wndprocLB, hDlg, msg, wParam, lParam);
}

//-----------------------------------------------------------------------------
// Name: HandleWmSize
// Desc: Handles a WM_SIZE message by resizing all our child windows to 
//          match the main window
//-----------------------------------------------------------------------------
void HandleWmSize(HWND hDlg, UINT state, int cx, int cy)
{
    if(!cx || !cy)
    {
        RECT rcClient;

        GetClientRect(hDlg, &rcClient);
        cx = rcClient.right;
        cy = rcClient.bottom;
    }

    // If we're big enough, position our child windows
    if(g_DCEnv.hwndCb && cx > 64 && cy > 64)
    {
        RECT rcCmd;

        //
        // Fit the combo box into our window
        //
        GetWindowRect(g_DCEnv.hwndCb, &rcCmd);
        ScreenToClient(hDlg, (LPPOINT)&rcCmd);
        ScreenToClient(hDlg, (LPPOINT)&rcCmd + 1);

        int x = rcCmd.left;
        int dx = cx - 4 - x;
        int dy = rcCmd.bottom - rcCmd.top;
        int y = cy - 4 - dy;

        SetWindowPos(g_DCEnv.hwndCb, NULL, x, y,
            dx, dy, SWP_NOZORDER);

        //
        // Position the "Cmd" label
        //
        RECT rcStaticCmd;
        HWND hStaticCmd = GetDlgItem(g_DCEnv.hDlgMain, IDC_Cmd);

        GetWindowRect(hStaticCmd, &rcStaticCmd);
        ScreenToClient(hDlg, (LPPOINT)&rcStaticCmd);
        ScreenToClient(hDlg, (LPPOINT)&rcStaticCmd + 1);
        SetWindowPos(hStaticCmd, NULL, 4,
            y + (dy - (rcStaticCmd.bottom - rcStaticCmd.top)) / 2 - 1,
            0, 0, SWP_NOSIZE | SWP_NOZORDER);

        RECT rcOut;

        //
        // Position the output window
        //
        GetWindowRect(g_DCEnv.hwndOut, &rcOut);
        ScreenToClient(hDlg, (LPPOINT)&rcOut);

        int dwWidth = cx - rcOut.left - 4;
        int dwHeight = y - rcOut.top - 4;

        SetWindowPos(g_DCEnv.hwndOut, NULL, 0, 0,
            dwWidth, dwHeight, SWP_NOMOVE | SWP_NOZORDER);
    }
}

//-----------------------------------------------------------------------------
// Name: DlgProc
// Desc: Our main dialog proc
//-----------------------------------------------------------------------------
LRESULT CALLBACK DlgProc(HWND hDlg, UINT message,
    WPARAM wParam, LPARAM lParam)
{
    HWND hwndMsg = (HWND)(UINT)lParam;
    WORD wID     = LOWORD(wParam);
    WORD wCode   = HIWORD(wParam);

    switch(message)
    {
    case WM_APP:
    {
        // Take the string from the command window and process it
        char szCmd[MAX_PATH + 3]; // extra room for \r\n
        ComboBox_GetText(g_DCEnv.hwndCb, szCmd, MAX_PATH);

        RCmdHandle(szCmd);

        ComboBox_SetText(g_DCEnv.hwndCb, "");
        break;
    }

    case WM_USER:
        ProcessEnqueuedStrings();
        break;

    case WM_SIZE:
        HANDLE_WM_SIZE(hDlg, wParam, lParam, HandleWmSize);
        break;

    case WM_SYSCOMMAND:
        if(wID == SC_CLOSE)
        {
            PostMessage(hDlg, WM_CLOSE, 0, 0);
            return 0;
        }
        break;

    case WM_CLOSE:
        // Must disconnect boefore closing
        RCmdDisconnect(0, NULL);
        DeleteCriticalSection( &g_PrintQueue.CriticalSection );

        DestroyWindow(hDlg);
        break;

    case WM_DESTROY:
        SubclassWindow(g_DCEnv.hwndCb, g_DCEnv.wndprocLB);
        PostQuitMessage(0);
        return 0;

    case WM_INITMENU:
        // Set up our menus
        CheckMenuItem(  (HMENU)wParam, IDM_DEBUGMONITOR, MF_BYCOMMAND | (g_DCEnv.fDebugMonitor ? MF_CHECKED : MF_UNCHECKED ) );
        EnableMenuItem( (HMENU)wParam, IDM_DEBUGMONITOR, MF_BYCOMMAND | (g_DCEnv.fConnected ? MF_ENABLED : MF_GRAYED ) );
        CheckMenuItem(  (HMENU)wParam, IDM_CONNECTTOBOX, MF_BYCOMMAND | (g_DCEnv.fConnected ? MF_CHECKED : MF_UNCHECKED ) );
        return 0;

    case WM_COMMAND:
        switch(wID)
        {
        case IDM_DEBUGMONITOR:
            g_DCEnv.fDebugMonitor = ! g_DCEnv.fDebugMonitor;
            return 0;

        case IDM_CONNECTTOBOX:
            if( g_DCEnv.fConnected )
            {
                RCmdDisconnect(0, NULL);
            }
            else
            {
                RCmdConnect( 0, NULL );
            }
            return 0;

        case IDM_Exit:
            PostMessage(hDlg, WM_CLOSE, 0, 0);
            return 0;
        }
        break;
    }

    return DefDlgProc(hDlg, message, wParam, lParam);
}

//-----------------------------------------------------------------------------
// Name: DisplayError
// Desc: Display friendly error by translating the hr to a message
//-----------------------------------------------------------------------------
void DisplayError(const char *szApiName, HRESULT hr)
{
    char szErr[100];
    if( !FAILED( DmTranslateError(hr, szErr, 100) ) )
    {
        if(szErr)
            RtfPrintf(RGB(255, 0, 0), "%s failed: '%s'\n", szApiName, szErr);
        else
            RtfPrintf(RGB(255, 0, 0), "%s failed: 0x%08lx\n", szApiName, hr);
    }
}

//-----------------------------------------------------------------------------
// Name: CmdToArgv
// Desc: Parse szCmd into argv and return # of args. (modifies szCmd)
//-----------------------------------------------------------------------------
int CmdToArgv(char *szCmd, char *szArg[], int maxargs)
{
    int argc = 0;
    int argcT = 0;
    char *szNil = szCmd + lstrlen(szCmd);

    while(argcT < maxargs)
    {
        // eat whitespace
        while(*szCmd && (*szCmd == ' '))
            szCmd++;

        if(!*szCmd)
        {
            szArg[argcT++] = szNil;
        }
        else
        {
            // find the end of this arg
            char chEnd = (*szCmd == '"' || *szCmd == '\'') ? *szCmd++ : ' ';
            char *szArgEnd = szCmd;
            while(*szArgEnd && (*szArgEnd != chEnd))
                szArgEnd++;

            // record this argument
            szArg[argcT++] = szCmd;
            argc = argcT;

            // move szArg to the next argument (or not, if we hit the end)
            szCmd = *szArgEnd ? szArgEnd + 1 : szArgEnd;
            *szArgEnd = 0;
        }
    }

    return argc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DebugConsole\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DebugConsole.rc
//
#define IDS_STRING1                     1
#define MENU_DebugConsole               100
#define IDC_RICHEDITCMD                 1000
#define IDC_RICHEDITCON                 1001
#define IDR_MAIN_ACCEL                  3000
#define IDM_Exit                        40001
#define IDM_CONNECT                     40002
#define IDM_DEBUGMONITOR                40004
#define IDM_CONNECTTOBOX                40006
#define IDC_STATIC                      -1
#define IDC_Cmd                         -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40007
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\ChildFrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__712C53CD_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
#define AFX_CHILDFRM_H__712C53CD_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CChildFrame : public CMDIChildWnd
{
    DECLARE_DYNCREATE(CChildFrame)
public:
    CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildFrame)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, const RECT& rect = rectDefault, CMDIFrameWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
    virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CChildFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
    //{{AFX_MSG(CChildFrame)
    afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__712C53CD_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\ChildFrm.Cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "dxtex.h"
#include "dxtexdoc.h"
#include "dxtexview.h"

#include "ChildFrm.h"

#ifndef WM_IDLEUPDATECMDUI
    #define WM_IDLEUPDATECMDUI  0x0363  // wParam == bDisableIfNoHandler
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CChildFrame)
    ON_MESSAGE(WM_IDLEUPDATECMDUI, OnIdleUpdateCmdUI)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CMDIChildWnd::PreCreateWindow(cs) )
        return FALSE;

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
    CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
    CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers

BOOL CChildFrame::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CMDIFrameWnd* pParentWnd, CCreateContext* pContext)
{
    if (!CMDIChildWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, pContext))
        return FALSE;

    return TRUE;
}



// Handle WM_IDLEUPDATECMDUI to update modified indicator if necessary.
LRESULT CChildFrame::OnIdleUpdateCmdUI(WPARAM wParam, LPARAM)
{
    // Only update the title if the doc or view state has changed.
    // Otherwise, the title bar will flicker.
    CDxtexDoc* pDoc = (CDxtexDoc*)GetActiveDocument();
    CDxtexView* pView = (CDxtexView*)GetActiveView();
    if (pView->TitleModsChanged() || pDoc->TitleModsChanged())
    {
        // This will force MFC to call CChildFrame::OnUpdateTitleFrame:
        m_nIdleFlags |= idleTitle;
        pView->ClearTitleModsChanged();
        pDoc->ClearTitleModsChanged();
    }

    // Do the default thing
    CMDIChildWnd::OnIdleUpdateCmdUI();
    return 0L;
}


void CChildFrame::OnUpdateFrameTitle(BOOL bAddToTitle)
{
    CMDIChildWnd::OnUpdateFrameTitle(bAddToTitle);
    CDxtexView* pView = (CDxtexView*)GetActiveView();
    {
        CString title;
        GetWindowText(title);
        title += " " + pView->GetStrTitleMods();
        SetWindowText(title);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\Dialogs.Cpp ===
// Dialogs.cpp : implementation file
//

#include "stdafx.h"
#include "dxtex.h"
#include "dialogs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewTextureDlg dialog


CNewTextureDlg::CNewTextureDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CNewTextureDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CNewTextureDlg)
    m_iTexType = 0;
    m_dwWidth = 256;
    m_dwHeight = 256;
    m_dwDepth = 8;
    m_iFmt = 0;
    m_strFmtDesc = _T("");
    m_numMips = 1;
    m_bXbox = 1;
    //}}AFX_DATA_INIT
}


void CNewTextureDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewTextureDlg)
    DDX_Radio(pDX, IDC_TEXTURE, m_iTexType);
    DDX_Text(pDX, IDC_WIDTH, m_dwWidth);
    DDV_MinMaxInt(pDX, m_dwWidth, 1, 1024);
    DDX_Text(pDX, IDC_HEIGHT, m_dwHeight);
    DDV_MinMaxInt(pDX, m_dwHeight, 1, 1024);
    DDX_Text(pDX, IDC_DEPTH, m_dwDepth);
    DDV_MinMaxInt(pDX, m_dwDepth, 2, 1024);
    DDX_Radio(pDX, IDC_A8R8G8B8, m_iFmt);
    DDX_Text(pDX, IDC_FMTDESC, m_strFmtDesc);
    DDX_Text(pDX, IDC_MIPCOUNT, m_numMips);
    DDV_MinMaxInt(pDX, m_numMips, 1, 20);
    DDX_Check(pDX, IDC_Xbox, m_bXbox);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewTextureDlg, CDialog)
    //{{AFX_MSG_MAP(CNewTextureDlg)
    ON_BN_CLICKED(IDC_TEXTURE, OnChangeTextureType)
    ON_BN_CLICKED(IDC_A8R8G8B8, OnChangeFormat)
    ON_BN_CLICKED(IDC_VOLUMETEXTURE, OnChangeTextureType)
    ON_BN_CLICKED(IDC_CUBEMAP, OnChangeTextureType)
    ON_BN_CLICKED(IDC_A4R4G4B4, OnChangeFormat)
    ON_BN_CLICKED(IDC_A1R5G5B5, OnChangeFormat)
    ON_BN_CLICKED(IDC_R5G6B5, OnChangeFormat)
    ON_BN_CLICKED(IDC_R8G8B8, OnChangeFormat)
    ON_BN_CLICKED(IDC_DXT1, OnChangeFormat)
    ON_BN_CLICKED(IDC_DXT2, OnChangeFormat)
    ON_BN_CLICKED(IDC_DXT3, OnChangeFormat)
    ON_BN_CLICKED(IDC_DXT4, OnChangeFormat)
    ON_BN_CLICKED(IDC_DXT5, OnChangeFormat)
    ON_BN_CLICKED(IDC_Xbox, OnChangeFormat)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewTextureDlg message handlers

BOOL CNewTextureDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    OnChangeTextureType();
    OnChangeFormat();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CNewTextureDlg::OnChangeTextureType()
{
    UpdateData(TRUE);

    if (m_iTexType == 2)
    {
        // Volume Tex
        GetDlgItem(IDC_VOLUMEDEPTHLABEL)->EnableWindow(TRUE);
        GetDlgItem(IDC_DEPTH)->EnableWindow(TRUE);

        GetDlgItem(IDC_DXT1)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT2)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT3)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT4)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT5)->EnableWindow(FALSE);

        if (m_iFmt > 4)
            m_iFmt = 0;
        m_bXbox = FALSE;
        GetDlgItem(IDC_Xbox)->EnableWindow(FALSE);
    }
    else
    {
        // Normal or Cube Tex
        GetDlgItem(IDC_VOLUMEDEPTHLABEL)->EnableWindow(FALSE);
        GetDlgItem(IDC_DEPTH)->EnableWindow(FALSE);

        GetDlgItem(IDC_DXT1)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT2)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT3)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT4)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT5)->EnableWindow(TRUE);
        GetDlgItem(IDC_Xbox)->EnableWindow(TRUE);
    }
    UpdateData(FALSE);
    OnChangeFormat();
}



void CNewTextureDlg::OnChangeFormat()
{
    UpdateData(TRUE);

    if( m_bXbox )
    {
        // Xbox doesn't support DXT3 or DXT5
        if( m_iFmt == 7 || m_iFmt == 9 )
            m_iFmt -= 1;

        GetDlgItem(IDC_DXT1)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT2)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT3)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT4)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT5)->EnableWindow(FALSE);
    }
    else
    {
        GetDlgItem(IDC_DXT1)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT2)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT3)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT4)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT5)->EnableWindow(TRUE);
    }

    switch (m_iFmt)
    {
    case 0:
        m_fmt = D3DFMT_A8R8G8B8;
        m_strFmtDesc.LoadString(IDS_FMTDESC_A8R8G8B8);
        break;
    case 1:
        m_fmt = D3DFMT_A1R5G5B5;
        m_strFmtDesc.LoadString(IDS_FMTDESC_A1R5G5B5);
        break;
    case 2:
        m_fmt = D3DFMT_A4R4G4B4;
        m_strFmtDesc.LoadString(IDS_FMTDESC_A4R4G4B4);
        break;
    case 3:
        m_fmt = D3DFMT_R8G8B8;
        m_strFmtDesc.LoadString(IDS_FMTDESC_R8G8B8);
        break;
    case 4:
        m_fmt = D3DFMT_R5G6B5;
        m_strFmtDesc.LoadString(IDS_FMTDESC_R5G6B5);
        break;
    case 5:
        m_fmt = D3DFMT_DXT1;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT1);
        break;
    case 6:
        m_fmt = D3DFMT_DXT2;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT2);
        break;
    case 7:
        m_fmt = D3DFMT_DXT3;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT3);
        break;
    case 8:
        m_fmt = D3DFMT_DXT4;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT4);
        break;
    case 9:
        m_fmt = D3DFMT_DXT5;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT5);
        break;
    }
    UpdateData(FALSE);
}

void CNewTextureDlg::OnOK()
{
    UpdateData(TRUE);

    // TODO: Need to do lots of validation of width/height/depth/mipcount here

    if (m_iTexType != 2)
        m_dwDepth = 0;

    switch (m_iFmt)
    {
    case 0:  m_fmt = D3DFMT_A8R8G8B8;   break;
    case 1:  m_fmt = D3DFMT_A1R5G5B5;   break;
    case 2:  m_fmt = D3DFMT_A4R4G4B4;   break;
    case 3:  m_fmt = D3DFMT_R8G8B8;     break;
    case 4:  m_fmt = D3DFMT_R5G6B5;     break;
    case 5:  m_fmt = D3DFMT_DXT1;       break;
    case 6:  m_fmt = D3DFMT_DXT2;       break;
    case 7:  m_fmt = D3DFMT_DXT3;       break;
    case 8:  m_fmt = D3DFMT_DXT4;       break;
    case 9:  m_fmt = D3DFMT_DXT5;       break;
    }

    CDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////////
// CCubeMapDlg dialog


CCubeMapDlg::CCubeMapDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CCubeMapDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CCubeMapDlg)
    m_iFace = 0;
    //}}AFX_DATA_INIT
}


void CCubeMapDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCubeMapDlg)
    DDX_Radio(pDX, IDC_POSX, m_iFace);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCubeMapDlg, CDialog)
    //{{AFX_MSG_MAP(CCubeMapDlg)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CVolumeMapDlg dialog


CVolumeMapDlg::CVolumeMapDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CVolumeMapDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CVolumeMapDlg)
    m_powLayers = 0;
    //}}AFX_DATA_INIT
}


void CVolumeMapDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CVolumeMapDlg)
    DDX_Radio(pDX, IDC_RADIO2, m_powLayers);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVolumeMapDlg, CDialog)
    //{{AFX_MSG_MAP(CVolumeMapDlg)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVolumeMapDlg message handlers


/////////////////////////////////////////////////////////////////////////////
// CChangeFmtDlg dialog


CChangeFmtDlg::CChangeFmtDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CChangeFmtDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CChangeFmtDlg)
    m_iFmt = -1;
    m_strFmtDesc = _T("");
    //}}AFX_DATA_INIT
}


void CChangeFmtDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CChangeFmtDlg)
    DDX_Radio(pDX, IDC_A8R8G8B8, m_iFmt);
    DDX_Text(pDX, IDC_FMTDESC, m_strFmtDesc);
    DDX_Check(pDX, IDC_Xbox, m_bXbox);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChangeFmtDlg, CDialog)
    //{{AFX_MSG_MAP(CChangeFmtDlg)
    ON_BN_CLICKED(IDC_A1R5G5B5, OnChangeFmt)
    ON_BN_CLICKED(IDC_A4R4G4B4, OnChangeFmt)
    ON_BN_CLICKED(IDC_A8R8G8B8, OnChangeFmt)
    ON_BN_CLICKED(IDC_DXT1, OnChangeFmt)
    ON_BN_CLICKED(IDC_DXT2, OnChangeFmt)
    ON_BN_CLICKED(IDC_DXT3, OnChangeFmt)
    ON_BN_CLICKED(IDC_DXT4, OnChangeFmt)
    ON_BN_CLICKED(IDC_DXT5, OnChangeFmt)
    ON_BN_CLICKED(IDC_R5G6B5, OnChangeFmt)
    ON_BN_CLICKED(IDC_R8G8B8, OnChangeFmt)
    ON_BN_CLICKED(IDC_Xbox, OnChangeFmt)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangeFmtDlg message handlers

BOOL CChangeFmtDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    if (m_bVolume)
    {
        GetDlgItem(IDC_DXT1)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT2)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT3)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT4)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT5)->EnableWindow(FALSE);
        GetDlgItem(IDC_Xbox)->EnableWindow(FALSE);
        m_bXbox = FALSE;
    }
    else if( m_bXbox )
    {
        GetDlgItem(IDC_DXT3)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT5)->EnableWindow(FALSE);
    }

    switch (m_fmt)
    {
    case D3DFMT_A8R8G8B8:
        m_iFmt = 0;
        break;
    case D3DFMT_A1R5G5B5:
        m_iFmt = 1;
        break;
    case D3DFMT_A4R4G4B4:
        m_iFmt = 2;
        break;
    case D3DFMT_R8G8B8:
        m_iFmt = 3;
        break;
    case D3DFMT_R5G6B5:
        m_iFmt = 4;
        break;
    case D3DFMT_DXT1:
        m_iFmt = 5;
        break;
    case D3DFMT_DXT2:
        m_iFmt = 6;
        break;
    case D3DFMT_DXT3:
        m_iFmt = 7;
        break;
    case D3DFMT_DXT4:
        m_iFmt = 8;
        break;
    case D3DFMT_DXT5:
        m_iFmt = 9;
        break;
    }

    UpdateFmtDesc();

    UpdateData(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CChangeFmtDlg::OnChangeFmt()
{
    UpdateData(TRUE);

    if( m_bXbox )
    {
        // Xbox doesn't support DXT3 or DXT5
        if( m_iFmt == 7 || m_iFmt == 9 )
            m_iFmt -= 1;

        GetDlgItem(IDC_DXT1)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT2)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT3)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT4)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT5)->EnableWindow(FALSE);
    }
    else
    {
        GetDlgItem(IDC_DXT1)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT2)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT3)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT4)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT5)->EnableWindow(TRUE);
    }

    UpdateFmtDesc();
}

void CChangeFmtDlg::UpdateFmtDesc()
{
    switch (m_iFmt)
    {
    case 0:
        m_fmt = D3DFMT_A8R8G8B8;
        m_strFmtDesc.LoadString(IDS_FMTDESC_A8R8G8B8);
        break;
    case 1:
        m_fmt = D3DFMT_A1R5G5B5;
        m_strFmtDesc.LoadString(IDS_FMTDESC_A1R5G5B5);
        break;
    case 2:
        m_fmt = D3DFMT_A4R4G4B4;
        m_strFmtDesc.LoadString(IDS_FMTDESC_A4R4G4B4);
        break;
    case 3:
        m_fmt = D3DFMT_R8G8B8;
        m_strFmtDesc.LoadString(IDS_FMTDESC_R8G8B8);
        break;
    case 4:
        m_fmt = D3DFMT_R5G6B5;
        m_strFmtDesc.LoadString(IDS_FMTDESC_R5G6B5);
        break;
    case 5:
        m_fmt = D3DFMT_DXT1;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT1);
        break;
    case 6:
        m_fmt = D3DFMT_DXT2;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT2);
        break;
    case 7:
        m_fmt = D3DFMT_DXT3;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT3);
        break;
    case 8:
        m_fmt = D3DFMT_DXT4;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT4);
        break;
    case 9:
        m_fmt = D3DFMT_DXT5;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT5);
        break;
    }
    UpdateData(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\DDS.h ===
// dds.h
//
// This header defines constants and structures that are useful when parsing
// DDS files.  DDS files were originally designed to use several structures
// and constants that are native to DirectDraw and are defined in ddraw.h,
// such as DDSURFACEDESC2 and DDSCAPS2.  This file defines similar
// (compatible) constants and structures so that one can use DDS files
// without needing to include ddraw.h.

#ifndef _DDS_H_
#define _DDS_H_

struct DDS_PIXELFORMAT
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwFourCC;
    DWORD dwRGBBitCount;
    DWORD dwRBitMask;
    DWORD dwGBitMask;
    DWORD dwBBitMask;
    DWORD dwABitMask;
};

#define DDS_FOURCC 0x00000004  // DDPF_FOURCC
#define DDS_RGB    0x00000040  // DDPF_RGB
#define DDS_RGBA   0x00000041  // DDPF_RGB | DDPF_ALPHAPIXELS

//
// The Xbox has different values for these constants
#define D3DFMT_DXT1_X       0x0000000C
#define D3DFMT_DXT2_X       0x0000000E
#define D3DFMT_DXT4_X       0x0000000F

const DDS_PIXELFORMAT DDSPF_DXT1 =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D', 'X', 'T', '1'), 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT2 =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D', 'X', 'T', '2'), 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT3 =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D', 'X', 'T', '3'), 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT4 =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D', 'X', 'T', '4'), 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT5 =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D', 'X', 'T', '5'), 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT1_X =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, D3DFMT_DXT1_X, 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT2_X =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, D3DFMT_DXT2_X, 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT4_X =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, D3DFMT_DXT4_X, 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_A8R8G8B8 =
    { sizeof(DDS_PIXELFORMAT), DDS_RGBA, 0, 32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000 };

const DDS_PIXELFORMAT DDSPF_A1R5G5B5 =
    { sizeof(DDS_PIXELFORMAT), DDS_RGBA, 0, 16, 0x00007c00, 0x000003e0, 0x0000001f, 0x00008000 };

const DDS_PIXELFORMAT DDSPF_A4R4G4B4 =
    { sizeof(DDS_PIXELFORMAT), DDS_RGBA, 0, 16, 0x0000f000, 0x000000f0, 0x0000000f, 0x0000f000 };

const DDS_PIXELFORMAT DDSPF_R8G8B8 =
    { sizeof(DDS_PIXELFORMAT), DDS_RGB, 0, 24, 0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000 };

const DDS_PIXELFORMAT DDSPF_R5G6B5 =
    { sizeof(DDS_PIXELFORMAT), DDS_RGB, 0, 16, 0x0000f800, 0x000007e0, 0x0000001f, 0x00000000 };

#define DDS_HEADER_FLAGS_TEXTURE    0x00001007  // DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT
#define DDS_HEADER_FLAGS_MIPMAP     0x00020000  // DDSD_MIPMAPCOUNT
#define DDS_HEADER_FLAGS_VOLUME     0x00800000  // DDSD_DEPTH
#define DDS_HEADER_FLAGS_PITCH      0x00000008  // DDSD_PITCH
#define DDS_HEADER_FLAGS_LINEARSIZE 0x00080000  // DDSD_LINEARSIZE

#define DDS_SURFACE_FLAGS_TEXTURE 0x00001000 // DDSCAPS_TEXTURE
#define DDS_SURFACE_FLAGS_MIPMAP  0x00400008 // DDSCAPS_COMPLEX | DDSCAPS_MIPMAP
#define DDS_SURFACE_FLAGS_CUBEMAP 0x00000008 // DDSCAPS_COMPLEX

#define DDS_CUBEMAP_POSITIVEX 0x00000600 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX
#define DDS_CUBEMAP_NEGATIVEX 0x00000a00 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX
#define DDS_CUBEMAP_POSITIVEY 0x00001200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY
#define DDS_CUBEMAP_NEGATIVEY 0x00002200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY
#define DDS_CUBEMAP_POSITIVEZ 0x00004200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ
#define DDS_CUBEMAP_NEGATIVEZ 0x00008200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ

#define DDS_CUBEMAP_ALLFACES ( DDS_CUBEMAP_POSITIVEX | DDS_CUBEMAP_NEGATIVEX |\
                               DDS_CUBEMAP_POSITIVEY | DDS_CUBEMAP_NEGATIVEY |\
                               DDS_CUBEMAP_POSITIVEZ | DDS_CUBEMAP_NEGATIVEZ )

#define DDS_FLAGS_VOLUME 0x00200000 // DDSCAPS2_VOLUME


struct DDS_HEADER
{
    DWORD dwSize;
    DWORD dwHeaderFlags;
    DWORD dwHeight;
    DWORD dwWidth;
    DWORD dwPitchOrLinearSize;
    DWORD dwDepth; // only if DDS_HEADER_FLAGS_VOLUME is set in dwHeaderFlags
    DWORD dwMipMapCount;
    DWORD dwReserved1[11];
    DDS_PIXELFORMAT ddspf;
    DWORD dwSurfaceFlags;
    DWORD dwCubemapFlags;
    DWORD dwReserved2[3];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\DXTex.Cpp ===
// dxtex.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "dxtex.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "dxtexDoc.h"
#include "dxtexView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CDxtexDocManager::DoPromptFileName - overridden to allow importing of
// BMPs as well as DDSs into CDxtexDocs.
BOOL CDxtexDocManager::DoPromptFileName(CString& fileName, UINT nIDSTitle,
            DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate)
{
    CFileDialog dlgFile(bOpenFileDialog);

    CString title;
    VERIFY(title.LoadString(nIDSTitle));

    dlgFile.m_ofn.Flags |= lFlags;

    CString strFilter;
    CString strDefault;

    if (bOpenFileDialog)
    {
        strFilter += "Image Files (*.dds, *.bmp, *.tga)";
        strFilter += (TCHAR)'\0';   // next string please
        strFilter += _T("*.dds;*.bmp;*.tga");
        strFilter += (TCHAR)'\0';   // last string
        dlgFile.m_ofn.nMaxCustFilter++;
    }
    else
    {
        strFilter += "Image Files (*.dds)";
        strFilter += (TCHAR)'\0';   // next string please
        strFilter += _T("*.dds");
        strFilter += (TCHAR)'\0';   // last string
        dlgFile.m_ofn.nMaxCustFilter++;
    }

    // append the "*.*" all files filter
    CString allFilter;
    VERIFY(allFilter.LoadString(AFX_IDS_ALLFILTER));
    strFilter += allFilter;
    strFilter += (TCHAR)'\0';   // next string please
    strFilter += _T("*.*");
    strFilter += (TCHAR)'\0';   // last string
    dlgFile.m_ofn.nMaxCustFilter++;

    dlgFile.m_ofn.lpstrFilter = strFilter;
    dlgFile.m_ofn.lpstrTitle = title;
    dlgFile.m_ofn.lpstrFile = fileName.GetBuffer(_MAX_PATH);

    INT_PTR nResult = dlgFile.DoModal();
    fileName.ReleaseBuffer();
    return nResult == IDOK;
};


/////////////////////////////////////////////////////////////////////////////
// CDxTxCommandLineInfo

CDxtexCommandLineInfo::CDxtexCommandLineInfo(VOID)
{
    m_fmt = D3DFMT_UNKNOWN;
    m_bAlphaComing = FALSE;
    m_bMipMap = FALSE;
}


void CDxtexCommandLineInfo::ParseParam(const TCHAR* pszParam,BOOL bFlag,BOOL bLast)
{
    if (lstrcmpiA(pszParam, "DXT1") == 0)
    {
        m_fmt = D3DFMT_DXT1;
    }
    else if (lstrcmpiA(pszParam, "DXT2") == 0)
    {
        m_fmt = D3DFMT_DXT2;
    }
    else if (lstrcmpiA(pszParam, "DXT3") == 0)
    {
        m_fmt = D3DFMT_DXT3;
    }
    else if (lstrcmpiA(pszParam, "DXT4") == 0)
    {
        m_fmt = D3DFMT_DXT4;
    }
    else if (lstrcmpiA(pszParam, "DXT5") == 0)
    {
        m_fmt = D3DFMT_DXT5;
    }
    else if (bFlag && tolower(pszParam[0]) == 'a')
    {
        m_bAlphaComing = TRUE;
    }
    else if (!bFlag && m_bAlphaComing)
    {
        m_strFileNameAlpha = pszParam;
        m_bAlphaComing = FALSE;
    }
    else if (bFlag && tolower(pszParam[0]) == 'm')
    {
        m_bMipMap = TRUE;
    }
    else if (!bFlag && !m_strFileName.IsEmpty())
    {
        m_strFileNameSave = pszParam;
    }

    CCommandLineInfo::ParseParam(pszParam, bFlag, bLast);
}



/////////////////////////////////////////////////////////////////////////////
// CDxtexApp

BEGIN_MESSAGE_MAP(CDxtexApp, CWinApp)
    //{{AFX_MSG_MAP(CDxtexApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDxtexApp construction

CDxtexApp::CDxtexApp()
{
    // Place all significant initialization in InitInstance
    m_pd3d = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CDxtexApp destruction

CDxtexApp::~CDxtexApp()
{
    ReleasePpo(&m_pd3ddev);
    ReleasePpo(&m_pd3d);
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDxtexApp object

CDxtexApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDxtexApp initialization

BOOL CDxtexApp::InitInstance()
{
    // Change the registry key under which our settings are stored.
    SetRegistryKey(_T("Microsoft"));

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    m_pDocManager = new CDxtexDocManager;

    CMultiDocTemplate* pDocTemplate;
    pDocTemplate = new CMultiDocTemplate(
        IDR_DXTXTYPE,
        RUNTIME_CLASS(CDxtexDoc),
        RUNTIME_CLASS(CChildFrame), // custom MDI child frame
        RUNTIME_CLASS(CDxtexView));
    AddDocTemplate(pDocTemplate);

    // create main MDI Frame window
    CMainFrame* pMainFrame = new CMainFrame;
    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
        return FALSE;
    m_pMainWnd = pMainFrame;

    // Initialize DirectDraw
    m_pd3d = Direct3DCreate8(D3D_SDK_VERSION);
    if (m_pd3d == NULL)
    {
        AfxMessageBox(ID_ERROR_D3DCREATEFAILED, MB_OK, 0);
        return FALSE;
    }

    HRESULT hr;
    D3DDISPLAYMODE dispMode;
    D3DPRESENT_PARAMETERS presentParams;
    D3DDEVTYPE devType;

    m_pd3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &dispMode);

    ZeroMemory(&presentParams, sizeof(presentParams));
    presentParams.Windowed = TRUE;
    presentParams.SwapEffect = D3DSWAPEFFECT_COPY_VSYNC;
    presentParams.BackBufferWidth = 8;
    presentParams.BackBufferHeight = 8;
    presentParams.BackBufferFormat = dispMode.Format;

    devType = D3DDEVTYPE_REF;

    hr = m_pd3d->CreateDevice(D3DADAPTER_DEFAULT, devType, m_pMainWnd->GetSafeHwnd(),
        D3DCREATE_SOFTWARE_VERTEXPROCESSING, &presentParams, &m_pd3ddev);
    if (FAILED(hr))
    {
        AfxMessageBox(ID_ERROR_CANTCREATEDEVICE);
        return FALSE;
    }

    // Parse command line for standard shell commands, DDE, file open
    CDxtexCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);
    // Prevent automatic "New" at startup:
    if (cmdInfo.m_nShellCommand == CCommandLineInfo::FileNew)
        cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing;

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // See if we loaded a document
    POSITION posTemp = GetFirstDocTemplatePosition();
    CDxtexDoc* pdoc = NULL;
    POSITION pos = pDocTemplate->GetFirstDocPosition();
    if (pos != NULL)
        pdoc = (CDxtexDoc*)pDocTemplate->GetNextDoc(pos);

    if (!cmdInfo.m_strFileNameAlpha.IsEmpty())
    {
        if (pdoc != NULL)
        {
            pdoc->LoadAlphaBmp(cmdInfo.m_strFileNameAlpha);
        }
    }
    if (cmdInfo.m_bMipMap)
    {
        if (pdoc != NULL)
        {
            pdoc->GenerateMipMaps();
        }
    }
    if (cmdInfo.m_fmt != 0)
    {
        if (pdoc != NULL)
        {
            pdoc->Compress(cmdInfo.m_fmt, TRUE);
        }
    }
    if (!cmdInfo.m_strFileNameSave.IsEmpty())
    {
        if (pdoc != NULL)
        {
            pdoc->OnSaveDocument(cmdInfo.m_strFileNameSave);
        }
        return FALSE; // Prevent UI from coming up
    }

    // The main window has been initialized, so show and update it.
    pMainFrame->ShowWindow(m_nCmdShow);
    pMainFrame->UpdateWindow();

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    CString m_strVersion;
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    TCHAR szFile[MAX_PATH];
    CString strVersion;
    UINT cb;
    DWORD dwHandle;
    BYTE FileVersionBuffer[1024];
    VS_FIXEDFILEINFO* pVersion = NULL;

    GetModuleFileName(NULL, szFile, MAX_PATH);

    cb = GetFileVersionInfoSize(szFile, &dwHandle/*ignored*/);
    if (cb > 0)
    {
        if (cb > sizeof(FileVersionBuffer))
            cb = sizeof(FileVersionBuffer);

        if (GetFileVersionInfo(szFile, 0, cb, &FileVersionBuffer))
        {
            pVersion = NULL;
            if (VerQueryValue(&FileVersionBuffer, "\\", (VOID**)&pVersion, &cb)
                && pVersion != NULL)
            {
                strVersion.Format("Version %d.%02d.%02d.%04d",
                    HIWORD(pVersion->dwFileVersionMS),
                    LOWORD(pVersion->dwFileVersionMS),
                    HIWORD(pVersion->dwFileVersionLS),
                    LOWORD(pVersion->dwFileVersionLS));
            }
        }
    }

    //{{AFX_DATA_INIT(CAboutDlg)
    m_strVersion = strVersion;
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    DDX_Text(pDX, IDC_VERSION, m_strVersion);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CDxtexApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\DXTexdoc.Cpp ===
// dxtexDoc.cpp : implementation of the CDxtexDoc class
//

#include "stdafx.h"
#include "dxtex.h"
#include "dxtexDoc.h"
#include "dialogs.h"
#include "dds.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDxtexDoc

IMPLEMENT_DYNCREATE(CDxtexDoc, CDocument)

BEGIN_MESSAGE_MAP(CDxtexDoc, CDocument)
    //{{AFX_MSG_MAP(CDxtexDoc)
    ON_COMMAND(ID_FILE_OPENALPHA, OnFileOpenAlpha)
    ON_COMMAND(ID_FORMAT_GENERATEMIPMAPS, OnGenerateMipMaps)
    ON_COMMAND(ID_FORMAT_CHANGESURFACEFMT, OnFormatChangeSurfaceFmt)
    ON_COMMAND(ID_FORMAT_CHANGECUBEMAPFACES, OnFormatChangeCubeMapFaces)
    ON_COMMAND(ID_FORMAT_MAKEINTOVOLUMEMAP, OnFormatMakeIntoVolumeMap)
    ON_UPDATE_COMMAND_UI(ID_FILE_OPENALPHA, OnUpdateFileOpenAlpha)
    ON_UPDATE_COMMAND_UI(ID_FORMAT_GENERATEMIPMAPS, OnUpdateFormatGenerateMipmaps)
    ON_UPDATE_COMMAND_UI(ID_FORMAT_CHANGECUBEMAPFACES, OnUpdateFormatChangeCubeMapFaces)
    ON_UPDATE_COMMAND_UI(ID_FORMAT_MAKEINTOVOLUMEMAP, OnUpdateFormatMakeIntoVolumeMap)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDxtexDoc diagnostics

#ifdef _DEBUG
void CDxtexDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CDxtexDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDxtexDoc construction/destruction

CDxtexDoc::CDxtexDoc()
{
    m_ptexOrig = NULL;
    m_ptexNew = NULL;
    m_dwWidth = 0;
    m_dwHeight = 0;
    m_dwDepth = 0;
    m_numMips = 0;
    m_dwCubeMapFlags = 0;
    m_bTitleModsChanged = FALSE;
    m_bXbox = FALSE;
}


CDxtexDoc::~CDxtexDoc()
{
    ReleasePpo(&m_ptexOrig);
    ReleasePpo(&m_ptexNew);
}


BOOL CDxtexDoc::OnNewDocument()
{
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();

    if (!CDocument::OnNewDocument())
        return FALSE;

    CNewTextureDlg dlg;

    if (IDCANCEL == dlg.DoModal())
        return FALSE;

    m_dwWidth = dlg.m_dwWidth;
    m_dwHeight = dlg.m_dwHeight;
    m_numMips = dlg.m_numMips;
    m_bXbox = dlg.m_bXbox;

    if (dlg.m_iTexType == 0)
    {
        LPDIRECT3DTEXTURE8 pmiptex;
        hr = pd3ddev->CreateTexture(m_dwWidth, m_dwHeight, m_numMips,
            0, dlg.m_fmt, D3DPOOL_MANAGED, &pmiptex);
        if (FAILED(hr))
        {
            AfxMessageBox(ID_ERROR_CANTCREATETEXTURE);
            return FALSE;
        }
        m_ptexOrig = pmiptex;

    }
    else if (dlg.m_iTexType == 1)
    {
        // Cube Map
        LPDIRECT3DCUBETEXTURE8 pcubetex;
        m_dwCubeMapFlags = DDS_CUBEMAP_ALLFACES;
        hr = pd3ddev->CreateCubeTexture(m_dwWidth, m_numMips,
            0, dlg.m_fmt, D3DPOOL_MANAGED, &pcubetex);
        if (FAILED(hr))
        {
            AfxMessageBox(ID_ERROR_CANTCREATETEXTURE);
            return FALSE;
        }
        m_ptexOrig = pcubetex;
    }
    else
    {
        LPDIRECT3DVOLUMETEXTURE8 pvoltex;
        m_dwDepth = dlg.m_dwDepth;
        hr = pd3ddev->CreateVolumeTexture(m_dwWidth, m_dwHeight, m_dwDepth, m_numMips,
            0, dlg.m_fmt, D3DPOOL_SYSTEMMEM, &pvoltex);
        if (FAILED(hr))
        {
            AfxMessageBox(ID_ERROR_CANTCREATETEXTURE);
            return FALSE;
        }
        m_ptexOrig = pvoltex;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CDxtexDoc serialization

void CDxtexDoc::Serialize(CArchive& ar)
{
    HRESULT     hr;

    if (ar.IsStoring())
    {
        LPDIRECT3DBASETEXTURE8 ptex;
        ptex = (m_ptexNew == NULL ? m_ptexOrig : m_ptexNew);
        SaveDDS( ptex, ar );
    }
    else
    {
        CFile     * pFile = ar.GetFile();
        CString     str = pFile->GetFilePath();
        TCHAR     * pszExt = strrchr(str, '.');

        if( lstrcmpi( pszExt, ".bmp" ) == 0 || lstrcmpi( pszExt, ".tga" ) == 0 )
        {
            if (FAILED(hr = LoadBmp(str)))
                AfxThrowArchiveException(CArchiveException::generic);
        }
        else if( lstrcmpi( pszExt, ".dds" ) == 0 )
        {
            ReleasePpo(&m_ptexOrig);
            ReleasePpo(&m_ptexNew);
            if (FAILED(hr = LoadDDS(&m_ptexOrig, ar)))
                AfxThrowArchiveException(CArchiveException::badIndex); // invalid file format
        }
        else
        {
            AfxThrowArchiveException(CArchiveException::badIndex); // invalid file format
        }
    }
}

HRESULT CDxtexDoc::SaveDDS(LPDIRECT3DBASETEXTURE8 ptex, CArchive& ar)
{
    HRESULT hr;
    DDS_HEADER ddsh;
    DWORD dwMagic;
    D3DFORMAT fmt;
    DWORD dwSize;
    DWORD dwPitch = 0;
    D3DLOCKED_RECT lr;
    D3DLOCKED_BOX lb;
    LPDIRECT3DTEXTURE8 pmiptex = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetex = NULL;
    LPDIRECT3DVOLUMETEXTURE8 pvoltex = NULL;

    if (IsVolumeMap())
        pvoltex = (LPDIRECT3DVOLUMETEXTURE8)ptex;
    else if (!IsCubeMap())
        pmiptex = (LPDIRECT3DTEXTURE8)ptex;
    else
        pcubetex = (LPDIRECT3DCUBETEXTURE8)ptex;

    dwMagic = MAKEFOURCC('D','D','S',' ');
    ar.Write(&dwMagic, sizeof(dwMagic));

    // Fill in the DDS header structure
    ZeroMemory(&ddsh, sizeof(ddsh));
    ddsh.dwSize = sizeof(ddsh);
    ddsh.dwHeaderFlags = DDS_HEADER_FLAGS_TEXTURE;
    ddsh.dwWidth = m_dwWidth;
    ddsh.dwHeight = m_dwHeight;
    ddsh.dwSurfaceFlags = DDS_SURFACE_FLAGS_TEXTURE;
    if (m_numMips > 1)
    {
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_MIPMAP;
        ddsh.dwSurfaceFlags |= DDS_SURFACE_FLAGS_MIPMAP;
        ddsh.dwMipMapCount = m_numMips;
    }
    if (pvoltex != NULL)
    {
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_VOLUME;
        // Note: "dwCubemapFlags" is mostly for cubemap flags,
        // but in this case is also used to indicate a volume texture
        ddsh.dwCubemapFlags |= DDS_FLAGS_VOLUME;
        ddsh.dwDepth = m_dwDepth;
    }

    // In DX7, you could (optionally) use and save a subset of
    // cubemap faces.  In DX8, you must use and save all faces of a cubemap.
    if (IsCubeMap())
    {
        ddsh.dwSurfaceFlags |= DDS_SURFACE_FLAGS_CUBEMAP;
        ddsh.dwCubemapFlags = DDS_CUBEMAP_ALLFACES;
    }

    // Determine dwPitch and dwSize for the texture
    if (pvoltex != NULL)
    {
        D3DVOLUME_DESC vd;
        pvoltex->GetLevelDesc(0, &vd);
        fmt = vd.Format;
        dwSize = vd.Size;
        if (SUCCEEDED(pvoltex->LockBox(0, &lb, NULL, D3DLOCK_READONLY)))
        {
            dwPitch = lb.RowPitch;
            pvoltex->UnlockBox(0);
        }
    }
    else if (pmiptex != NULL)
    {
        D3DSURFACE_DESC sd;
        pmiptex->GetLevelDesc(0, &sd);
        fmt = sd.Format;
        dwSize = sd.Size;
        if (SUCCEEDED(pmiptex->LockRect(0, &lr, NULL, D3DLOCK_READONLY)))
        {
            dwPitch = lr.Pitch;
            pmiptex->UnlockRect(0);
        }
    }
    else
    {
        D3DSURFACE_DESC sd;
        pcubetex->GetLevelDesc(0, &sd);
        fmt = sd.Format;
        dwSize = sd.Size;
        if (SUCCEEDED(pcubetex->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0,
            &lr, NULL, D3DLOCK_READONLY)))
        {
            dwPitch = lr.Pitch;
            pcubetex->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);
        }
    }

    // Note that although this code stores the pitch or linear size
    // of the surface in the DDS file (for consistency with DX7), it
    // is better to use the pitch or linear size of the surface
    // created when loading the DDS file into a texture than to use
    // the file values.  The pitch of a created surface, especially,
    // can be different from the pitch stored in the DDS file.
    switch (fmt)
    {
    case D3DFMT_DXT1:
        if( IsXbox() )
            ddsh.ddspf = DDSPF_DXT1_X;
        else
            ddsh.ddspf = DDSPF_DXT1;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_LINEARSIZE;
        ddsh.dwPitchOrLinearSize = dwSize;
        break;
    case D3DFMT_DXT2:
        if( IsXbox() )
            ddsh.ddspf = DDSPF_DXT2_X;
        else
            ddsh.ddspf = DDSPF_DXT2;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_LINEARSIZE;
        ddsh.dwPitchOrLinearSize = dwSize;
        break;
    case D3DFMT_DXT3:
        ddsh.ddspf = DDSPF_DXT3;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_LINEARSIZE;
        ddsh.dwPitchOrLinearSize = dwSize;
        break;
    case D3DFMT_DXT4:
        if( IsXbox() )
            ddsh.ddspf = DDSPF_DXT4_X;
        else
            ddsh.ddspf = DDSPF_DXT4;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_LINEARSIZE;
        ddsh.dwPitchOrLinearSize = dwSize;
        break;
    case D3DFMT_DXT5:
        ddsh.ddspf = DDSPF_DXT5;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_LINEARSIZE;
        ddsh.dwPitchOrLinearSize = dwSize;
        break;
    case D3DFMT_A8R8G8B8:
        ddsh.ddspf = DDSPF_A8R8G8B8;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_PITCH;
        ddsh.dwPitchOrLinearSize = dwPitch;
        break;
    case D3DFMT_A1R5G5B5:
        ddsh.ddspf = DDSPF_A1R5G5B5;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_PITCH;
        ddsh.dwPitchOrLinearSize = dwPitch;
        break;
    case D3DFMT_A4R4G4B4:
        ddsh.ddspf = DDSPF_A4R4G4B4;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_PITCH;
        ddsh.dwPitchOrLinearSize = dwPitch;
        break;
    case D3DFMT_R8G8B8:
        ddsh.ddspf = DDSPF_R8G8B8;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_PITCH;
        ddsh.dwPitchOrLinearSize = dwPitch;
        break;
    case D3DFMT_R5G6B5:
        ddsh.ddspf = DDSPF_R5G6B5;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_PITCH;
        ddsh.dwPitchOrLinearSize = dwPitch;
        break;
    default:
        return E_FAIL;
    }

    ar.Write(&ddsh, sizeof(ddsh));

    if (pvoltex != NULL)
    {
        if (FAILED(hr = SaveAllVolumeSurfaces(pvoltex, ar)))
            return hr;
    }
    else if (pmiptex != NULL)
    {
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_FORCE_DWORD, ar)))
            return hr;
    }
    else
    {
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_POSITIVE_X, ar)))
            return hr;
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_NEGATIVE_X, ar)))
            return hr;
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_POSITIVE_Y, ar)))
            return hr;
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_NEGATIVE_Y, ar)))
            return hr;
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_POSITIVE_Z, ar)))
            return hr;
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_NEGATIVE_Z, ar)))
            return hr;
    }

    return S_OK;
}


HRESULT CDxtexDoc::SaveAllMipSurfaces(LPDIRECT3DBASETEXTURE8 ptex, D3DCUBEMAP_FACES FaceType, CArchive& ar)
{
    HRESULT hr;
    LPDIRECT3DSURFACE8 psurf;
    D3DSURFACE_DESC sd;
    UINT iLevel;
    D3DLOCKED_RECT lr;
    LPDIRECT3DTEXTURE8 pmiptex = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetex = NULL;

    if (FaceType == D3DCUBEMAP_FACE_FORCE_DWORD)
        pmiptex = (LPDIRECT3DTEXTURE8)ptex;
    else
        pcubetex = (LPDIRECT3DCUBETEXTURE8)ptex;

    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        if (pmiptex != NULL)
            hr = pmiptex->GetSurfaceLevel(iLevel, &psurf);
        else
            hr = pcubetex->GetCubeMapSurface(FaceType, iLevel, &psurf);
        if (FAILED(hr))
            return hr;
        psurf->GetDesc(&sd);
        if (pmiptex != NULL)
            hr = pmiptex->LockRect(iLevel, &lr, NULL, 0);
        else
            hr = pcubetex->LockRect(FaceType, iLevel, &lr, NULL, 0);
        if (FAILED(hr))
            return hr;
        if (sd.Format == D3DFMT_DXT1 ||
            sd.Format == D3DFMT_DXT2 ||
            sd.Format == D3DFMT_DXT3 ||
            sd.Format == D3DFMT_DXT4 ||
            sd.Format == D3DFMT_DXT5)
        {
            ar.Write(lr.pBits, sd.Size);
        }
        else
        {
            DWORD yp;
            BYTE* pbDest = (BYTE*)lr.pBits;
            LONG dataBytesPerRow = 0;
            if (sd.Format == D3DFMT_A8R8G8B8)
                dataBytesPerRow = 4 * sd.Width;
            else if (sd.Format == D3DFMT_R8G8B8)
                dataBytesPerRow = 3 * sd.Width;
            else
                dataBytesPerRow = 2 * sd.Width;
            for (yp = 0; yp < sd.Height; yp++)
            {
                ar.Write(pbDest, dataBytesPerRow);
                pbDest += lr.Pitch;
            }
        }
        if (pmiptex != NULL)
            hr = pmiptex->UnlockRect(iLevel);
        else
            hr = pcubetex->UnlockRect(FaceType, iLevel);
    }

    return S_OK;
}


HRESULT CDxtexDoc::SaveAllVolumeSurfaces(LPDIRECT3DVOLUMETEXTURE8 pvoltex, CArchive& ar)
{
    HRESULT hr;
    D3DVOLUME_DESC vd;
    D3DBOX box;
    D3DLOCKED_BOX lb;
    UINT iLevel;
    UINT numBytesPerRow;
    BYTE* pbSlice;
    BYTE* pbRow;
    UINT zp;
    UINT yp;

    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        pvoltex->GetLevelDesc(iLevel, &vd);
        box.Left = 0;
        box.Right = vd.Width;
        box.Top = 0;
        box.Bottom = vd.Height;
        box.Front = 0;
        box.Back = vd.Depth;
        hr = pvoltex->LockBox(iLevel, &lb, &box, 0);
        if (FAILED(hr))
            return hr;
        switch(vd.Format)
        {
        case D3DFMT_A8R8G8B8:
            numBytesPerRow = 4 * vd.Width;
            break;
        case D3DFMT_R8G8B8:
            numBytesPerRow = 3 * vd.Width;
            break;
        case D3DFMT_A1R5G5B5:
        case D3DFMT_A4R4G4B4:
        case D3DFMT_R5G6B5:
            numBytesPerRow = 2 * vd.Width;
            break;
        default:
            return E_FAIL;
        }
        pbSlice = (BYTE*)lb.pBits;
        for (zp = 0; zp < vd.Depth; zp++)
        {
            pbRow = pbSlice;
            for (yp = 0; yp < vd.Height; yp++)
            {
                ar.Write(pbRow, numBytesPerRow);
                pbRow += lb.RowPitch;
            }
            pbSlice += lb.SlicePitch;
        }

        pvoltex->UnlockBox(iLevel);
    }

    return S_OK;
}


HRESULT CDxtexDoc::LoadDDS(LPDIRECT3DBASETEXTURE8* pptex, CArchive& ar)
{

    HRESULT hr;
    DWORD dwMagic;
    DDS_HEADER ddsh;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DTEXTURE8 pmiptex = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetex = NULL;
    LPDIRECT3DVOLUMETEXTURE8 pvoltex = NULL;

    *pptex = NULL;

    ar.Read(&dwMagic, sizeof(dwMagic));
    if (dwMagic != MAKEFOURCC('D','D','S',' '))
        return E_FAIL;
    ar.Read(&ddsh, sizeof(ddsh));
    if (ddsh.dwSize != sizeof(ddsh))
        return E_FAIL;
    m_dwWidth = ddsh.dwWidth;
    m_dwHeight = ddsh.dwHeight;
    m_numMips = ddsh.dwMipMapCount;
    if (m_numMips == 0)
        m_numMips = 1;
    m_dwCubeMapFlags = (ddsh.dwCubemapFlags & DDS_CUBEMAP_ALLFACES);
    if (ddsh.dwHeaderFlags & DDS_HEADER_FLAGS_VOLUME)
        m_dwDepth = ddsh.dwDepth;
    else
        m_dwDepth = 0;

    D3DFORMAT fmt;
    if (!IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT1)
        fmt = D3DFMT_DXT1;
    else if (!IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT2)
        fmt = D3DFMT_DXT2;
    else if (!IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT3)
        fmt = D3DFMT_DXT3;
    else if (!IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT4)
        fmt = D3DFMT_DXT4;
    else if (!IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT5)
        fmt = D3DFMT_DXT5;
    else if( !IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT1_X)
    {   fmt = D3DFMT_DXT1; m_bXbox = TRUE; }
    else if( !IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT2_X)
    {   fmt = D3DFMT_DXT2; m_bXbox = TRUE; }
    else if( !IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT4_X)
    {   fmt = D3DFMT_DXT4; m_bXbox = TRUE; }
    else if (ddsh.ddspf.dwFlags == DDS_RGBA && ddsh.ddspf.dwRGBBitCount == 32 && ddsh.ddspf.dwABitMask == 0xff000000)
        fmt = D3DFMT_A8R8G8B8;
    else if (ddsh.ddspf.dwFlags == DDS_RGB  && ddsh.ddspf.dwRGBBitCount == 24)
        fmt = D3DFMT_R8G8B8;
    else if (ddsh.ddspf.dwFlags == DDS_RGB  && ddsh.ddspf.dwRGBBitCount == 16 && ddsh.ddspf.dwGBitMask == 0x000007e0)
        fmt = D3DFMT_R5G6B5;
    else if (ddsh.ddspf.dwFlags == DDS_RGBA && ddsh.ddspf.dwRGBBitCount == 16 && ddsh.ddspf.dwABitMask == 0x00008000)
        fmt = D3DFMT_A1R5G5B5;
    else if (ddsh.ddspf.dwFlags == DDS_RGBA && ddsh.ddspf.dwRGBBitCount == 16 && ddsh.ddspf.dwABitMask == 0x0000f000)
        fmt = D3DFMT_A4R4G4B4;
    else
        return E_FAIL; // unknown fmt

    if (IsVolumeMap())
    {
        if (FAILED(hr = pd3ddev->CreateVolumeTexture(m_dwWidth, m_dwHeight, m_dwDepth, m_numMips,
            0, fmt, D3DPOOL_SYSTEMMEM, &pvoltex)))
        {
            return hr;
        }

        if (FAILED(hr = LoadAllVolumeSurfaces(pvoltex, ar)))
            return hr;

        *pptex = pvoltex;
    }
    else if (IsCubeMap())
    {
        if (FAILED(hr = pd3ddev->CreateCubeTexture(m_dwWidth, m_numMips,
             0, fmt, D3DPOOL_MANAGED, &pcubetex)))
        {
            return hr;
        }

        // Cubemaps created with the DX7 version of DxTex may skip some
        // cube faces.  ddsh.dwCubeMapFlags indicates which faces are
        // present.  If you only care about loading post-DX7 cubemaps, you
        // don't have to check these flags -- just load each face in sequence.

        // REVIEW: zero out surfaces of missing faces?

        if (m_dwCubeMapFlags & DDS_CUBEMAP_POSITIVEX)
        {
            if (FAILED(hr = LoadAllMipSurfaces(pcubetex, D3DCUBEMAP_FACE_POSITIVE_X, ar)))
                return hr;
        }

        if (m_dwCubeMapFlags & DDS_CUBEMAP_NEGATIVEX)
        {
            if (FAILED(hr = LoadAllMipSurfaces(pcubetex, D3DCUBEMAP_FACE_NEGATIVE_X, ar)))
                return hr;
        }

        if (m_dwCubeMapFlags & DDS_CUBEMAP_POSITIVEY)
        {
            if (FAILED(hr = LoadAllMipSurfaces(pcubetex, D3DCUBEMAP_FACE_POSITIVE_Y, ar)))
                return hr;
        }

        if (m_dwCubeMapFlags & DDS_CUBEMAP_NEGATIVEY)
        {
            if (FAILED(hr = LoadAllMipSurfaces(pcubetex, D3DCUBEMAP_FACE_NEGATIVE_Y, ar)))
                return hr;
        }

        if (m_dwCubeMapFlags & DDS_CUBEMAP_POSITIVEZ)
        {
            if (FAILED(hr = LoadAllMipSurfaces(pcubetex, D3DCUBEMAP_FACE_POSITIVE_Z, ar)))
                return hr;
        }

        if (m_dwCubeMapFlags & DDS_CUBEMAP_NEGATIVEZ)
        {
            if (FAILED(hr = LoadAllMipSurfaces(pcubetex, D3DCUBEMAP_FACE_NEGATIVE_Z, ar)))
                return hr;
        }

        *pptex = pcubetex;
    }
    else
    {
        if (FAILED(hr = pd3ddev->CreateTexture(m_dwWidth, m_dwHeight, m_numMips,
             0, fmt, D3DPOOL_MANAGED, &pmiptex)))
        {
            return hr;
        }

        if (FAILED(hr = LoadAllMipSurfaces(pmiptex, D3DCUBEMAP_FACE_FORCE_DWORD, ar)))
            return hr;

        *pptex = pmiptex;
    }

    return S_OK;
}


HRESULT CDxtexDoc::LoadAllMipSurfaces(LPDIRECT3DBASETEXTURE8 ptex, D3DCUBEMAP_FACES FaceType, CArchive& ar)
{
    HRESULT hr;
    LPDIRECT3DSURFACE8 psurf;
    D3DSURFACE_DESC sd;
    UINT iLevel;
    D3DLOCKED_RECT lr;
    LPDIRECT3DTEXTURE8 pmiptex = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetex = NULL;
    DWORD dwBytesPerRow;

    if (FaceType == D3DCUBEMAP_FACE_FORCE_DWORD)
        pmiptex = (LPDIRECT3DTEXTURE8)ptex;
    else
        pcubetex = (LPDIRECT3DCUBETEXTURE8)ptex;

    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        if (pmiptex != NULL)
            hr = pmiptex->GetSurfaceLevel(iLevel, &psurf);
        else
            hr = pcubetex->GetCubeMapSurface(FaceType, iLevel, &psurf);
        if (FAILED(hr))
            return hr;
        psurf->GetDesc(&sd);
        switch (sd.Format)
        {
        case D3DFMT_DXT1:
        case D3DFMT_DXT2:
        case D3DFMT_DXT3:
        case D3DFMT_DXT4:
        case D3DFMT_DXT5:
            dwBytesPerRow = 0; // magic value indicates texture's memory is contiguous
            break;
        case D3DFMT_A8R8G8B8:
            dwBytesPerRow = 4 * sd.Width;
            break;
        case D3DFMT_R8G8B8:
            dwBytesPerRow = 3 * sd.Width;
            break;
        case D3DFMT_A1R5G5B5:
        case D3DFMT_A4R4G4B4:
        case D3DFMT_R5G6B5:
            dwBytesPerRow = 2 * sd.Width;
            break;
        default:
            return E_FAIL;
        }

        if (pmiptex != NULL)
            hr = pmiptex->LockRect(iLevel, &lr, NULL, 0);
        else
            hr = pcubetex->LockRect(FaceType, iLevel, &lr, NULL, 0);
        if (FAILED(hr))
            return hr;
        if (dwBytesPerRow == 0)
        {
            ar.Read(lr.pBits, sd.Size);
        }
        else
        {
            DWORD yp;
            BYTE* pbDest = (BYTE*)lr.pBits;
            for (yp = 0; yp < sd.Height; yp++)
            {
                ar.Read(pbDest, dwBytesPerRow);
                pbDest += lr.Pitch;
            }
        }

        if (pmiptex != NULL)
            hr = pmiptex->UnlockRect(iLevel);
        else
            hr = pcubetex->UnlockRect(FaceType, iLevel);
        ReleasePpo(&psurf);
    }

    return S_OK;
}


HRESULT CDxtexDoc::LoadAllVolumeSurfaces(LPDIRECT3DVOLUMETEXTURE8 pvoltex, CArchive& ar)
{
    HRESULT hr;
    D3DVOLUME_DESC vd;
    D3DBOX box;
    D3DLOCKED_BOX lb;
    UINT iLevel;
    UINT numBytesPerRow;
    BYTE* pbSlice;
    BYTE* pbRow;
    UINT zp;
    UINT yp;

    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        pvoltex->GetLevelDesc(iLevel, &vd);
        box.Left = 0;
        box.Right = vd.Width;
        box.Top = 0;
        box.Bottom = vd.Height;
        box.Front = 0;
        box.Back = vd.Depth;
        hr = pvoltex->LockBox(iLevel, &lb, &box, 0);
        if (FAILED(hr))
            return hr;
        switch(vd.Format)
        {
        case D3DFMT_A8R8G8B8:
            numBytesPerRow = 4 * vd.Width;
            break;
        default:
            return E_FAIL;
        }
        pbSlice = (BYTE*)lb.pBits;
        for (zp = 0; zp < vd.Depth; zp++)
        {
            pbRow = pbSlice;
            for (yp = 0; yp < vd.Height; yp++)
            {
                ar.Read(pbRow, numBytesPerRow);
                pbRow += lb.RowPitch;
            }
            pbSlice += lb.SlicePitch;
        }

        pvoltex->UnlockBox(iLevel);
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDxtexDoc commands

HRESULT CDxtexDoc::LoadBmp(CString& strPath)
{
    HRESULT hr;

    LPDIRECT3DDEVICE8 pd3ddev;
    LPDIRECT3DTEXTURE8 ptex;

    pd3ddev = PDxtexApp()->Pd3ddev();
    hr = D3DXCreateTextureFromFileEx(pd3ddev, strPath, D3DX_DEFAULT,
        D3DX_DEFAULT, 1, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED,
        D3DX_FILTER_POINT, D3DX_FILTER_POINT, 0, NULL, NULL, &ptex);
    if (FAILED(hr))
        return hr;

    // Look for "foo_a.bmp" for alpha channel
    int i = strPath.ReverseFind('.');
    strPath = strPath.Left(i) + "_a.bmp";
    CFileStatus status;
    if (CFile::GetStatus(strPath, status))
    {
        LPDIRECT3DSURFACE8 psurf;

        hr = ptex->GetSurfaceLevel(0, &psurf);
        if (FAILED(hr))
            return hr;

        hr = LoadAlphaIntoSurface(strPath, psurf);
        ReleasePpo(&psurf);
        if (FAILED(hr))
            return hr;
    }

    // Ensure that source image dimensions are power of 2
    D3DSURFACE_DESC sd;
    ptex->GetLevelDesc(0, &sd);
    m_dwWidth = sd.Width;
    m_dwHeight = sd.Height;

    LONG lwTempW;
    LONG lwTempH;
    lwTempW = sd.Width;
    lwTempH = sd.Height;
    while ((lwTempW & 1) == 0)
        lwTempW = lwTempW >> 1;
    while ((lwTempH & 1) == 0)
        lwTempH = lwTempH >> 1;
    if (lwTempW != 1 || lwTempH != 1)
    {
        AfxMessageBox(ID_ERROR_NOTPOW2);
        ReleasePpo(&ptex);
        return E_FAIL;
    }

    m_numMips = 1;

    ReleasePpo(&m_ptexOrig);
    m_ptexOrig = ptex;

    m_strTitle.Empty();
    m_strPathName.Empty();
    SetModifiedFlag(TRUE);

    return S_OK;
}


HRESULT CDxtexDoc::LoadAlphaBmp(CString& strPath)
{
    HRESULT hr;
    LPDIRECT3DTEXTURE8 pmiptex;
    LPDIRECT3DSURFACE8 psurf;

    if (IsCubeMap())
        return E_FAIL;

    pmiptex = (LPDIRECT3DTEXTURE8)m_ptexOrig;
    hr = pmiptex->GetSurfaceLevel(0, &psurf);
    if (FAILED(hr))
        return hr;

    hr = LoadAlphaIntoSurface(strPath, psurf);
    ReleasePpo(&psurf);
    if (FAILED(hr))
        return hr;

    UpdateAllViews(NULL, 1); // tell CView to pick up new surface pointers
    return S_OK;
}


HRESULT CDxtexDoc::Compress(D3DFORMAT fmtTo, BOOL bSwitchView)
{
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DTEXTURE8 pmiptex;
    LPDIRECT3DCUBETEXTURE8 pcubetex;
    LPDIRECT3DVOLUMETEXTURE8 pvoltex;
    D3DFORMAT fmtFrom;
    LPDIRECT3DTEXTURE8 pmiptexNew;
    LPDIRECT3DCUBETEXTURE8 pcubetexNew;
    LPDIRECT3DVOLUMETEXTURE8 pvoltexNew;

    if (IsVolumeMap())
    {
        if (fmtTo == D3DFMT_DXT1 ||
            fmtTo == D3DFMT_DXT2 ||
            fmtTo == D3DFMT_DXT3 ||
            fmtTo == D3DFMT_DXT4 ||
            fmtTo == D3DFMT_DXT5)
        {
            return E_FAIL;
        }
        pvoltex = (LPDIRECT3DVOLUMETEXTURE8)m_ptexOrig;
        D3DVOLUME_DESC vd;
        pvoltex->GetLevelDesc(0, &vd);
        fmtFrom = vd.Format;
    }
    else if (IsCubeMap())
    {
        pcubetex = (LPDIRECT3DCUBETEXTURE8)m_ptexOrig;
        D3DSURFACE_DESC sd;
        pcubetex->GetLevelDesc(0, &sd);
        fmtFrom = sd.Format;
    }
    else
    {
        pmiptex = (LPDIRECT3DTEXTURE8)m_ptexOrig;
        D3DSURFACE_DESC sd;
        pmiptex->GetLevelDesc(0, &sd);
        fmtFrom = sd.Format;
    }

    if (fmtFrom == D3DFMT_DXT2 || fmtFrom == D3DFMT_DXT4)
    {
        if (fmtTo == D3DFMT_DXT1)
        {
            AfxMessageBox(ID_ERROR_PREMULTTODXT1);
        }
        else if (fmtTo != D3DFMT_DXT2 && fmtTo != D3DFMT_DXT4)
        {
            AfxMessageBox(ID_ERROR_PREMULTALPHA);
            return S_OK;
        }
    }

    if (IsVolumeMap())
    {
        hr = pd3ddev->CreateVolumeTexture(m_dwWidth, m_dwHeight, m_dwDepth, m_numMips,
            0, fmtTo, D3DPOOL_SYSTEMMEM, &pvoltexNew);
        if (FAILED(hr))
            return hr;
        ReleasePpo(&m_ptexNew);
        m_ptexNew = pvoltexNew;
        if (FAILED(BltAllLevels(D3DCUBEMAP_FACE_FORCE_DWORD, m_ptexOrig, m_ptexNew)))
            return hr;
    }
    else if (IsCubeMap())
    {
        hr = pd3ddev->CreateCubeTexture(m_dwWidth, m_numMips,
             0, fmtTo, D3DPOOL_MANAGED, &pcubetexNew);
        if (FAILED(hr))
            return hr;
        ReleasePpo(&m_ptexNew);
        m_ptexNew = pcubetexNew;
        if (FAILED(hr = BltAllLevels(D3DCUBEMAP_FACE_NEGATIVE_X, m_ptexOrig, m_ptexNew)))
            return hr;
        if (FAILED(hr = BltAllLevels(D3DCUBEMAP_FACE_POSITIVE_X, m_ptexOrig, m_ptexNew)))
            return hr;
        if (FAILED(hr = BltAllLevels(D3DCUBEMAP_FACE_NEGATIVE_Y, m_ptexOrig, m_ptexNew)))
            return hr;
        if (FAILED(hr = BltAllLevels(D3DCUBEMAP_FACE_POSITIVE_Y, m_ptexOrig, m_ptexNew)))
            return hr;
        if (FAILED(hr = BltAllLevels(D3DCUBEMAP_FACE_NEGATIVE_Z, m_ptexOrig, m_ptexNew)))
            return hr;
        if (FAILED(hr = BltAllLevels(D3DCUBEMAP_FACE_POSITIVE_Z, m_ptexOrig, m_ptexNew)))
            return hr;
    }
    else
    {
        hr = pd3ddev->CreateTexture(m_dwWidth, m_dwHeight, m_numMips,
             0, fmtTo, D3DPOOL_MANAGED, &pmiptexNew);
        if (FAILED(hr))
            return hr;
        ReleasePpo(&m_ptexNew);
        m_ptexNew = pmiptexNew;
        if (FAILED(BltAllLevels(D3DCUBEMAP_FACE_FORCE_DWORD, m_ptexOrig, m_ptexNew)))
            return hr;
    }

    SetModifiedFlag();
    m_bTitleModsChanged = TRUE; // force title bar update
    if (bSwitchView)
        AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_VIEW_COMPRESSED, 0);

    return S_OK;
}


void CDxtexDoc::OnGenerateMipMaps()
{
    GenerateMipMaps();
}


void CDxtexDoc::GenerateMipMaps()
{
    LONG lwTempH;
    LONG lwTempW;
    LONG lwPowsW;
    LONG lwPowsH;
    LPDIRECT3DTEXTURE8 pddsNew = NULL;
    D3DFORMAT fmt;
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DTEXTURE8 pmiptex = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetex = NULL;
    LPDIRECT3DVOLUMETEXTURE8 pvoltex = NULL;
    LPDIRECT3DTEXTURE8 pmiptexNew = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetexNew = NULL;
    LPDIRECT3DVOLUMETEXTURE8 pvoltexNew = NULL;
    LPDIRECT3DSURFACE8 psurfSrc;
    LPDIRECT3DSURFACE8 psurfDest;
    LPDIRECT3DVOLUME8 pvolSrc;
    LPDIRECT3DVOLUME8 pvolDest;

    if (IsVolumeMap())
        pvoltex = (LPDIRECT3DVOLUMETEXTURE8)m_ptexOrig;
    else if (IsCubeMap())
        pcubetex = (LPDIRECT3DCUBETEXTURE8)m_ptexOrig;
    else
        pmiptex = (LPDIRECT3DTEXTURE8)m_ptexOrig;

    if (pvoltex != NULL)
    {
        D3DVOLUME_DESC vd;
        pvoltex->GetLevelDesc(0, &vd);
        fmt = vd.Format;
    }
    else if (pcubetex != NULL)
    {
        D3DSURFACE_DESC sd;
        pcubetex->GetLevelDesc(0, &sd);
        fmt = sd.Format;
    }
    else
    {
        D3DSURFACE_DESC sd;
        pmiptex->GetLevelDesc(0, &sd);
        fmt = sd.Format;
    }

    // Ensure that source image is power of 2
    lwTempW = m_dwWidth;
    lwTempH = m_dwHeight;
    lwPowsW = 1;
    lwPowsH = 1;
    while ((lwTempW & 1) == 0)
    {
        lwPowsW++;
        lwTempW = lwTempW >> 1;
    }
    while ((lwTempH & 1) == 0)
    {
        lwPowsH++;
        lwTempH = lwTempH >> 1;
    }
    if (lwTempW != 1 || lwTempH != 1)
    {
        AfxMessageBox(ID_ERROR_NOTPOW2);
        return;
    }
    m_numMips = lwPowsW > lwPowsH ? lwPowsW : lwPowsH;

    // Create destination mipmap surface - same format as source
    if (pvoltex != NULL)
    {
        if (FAILED(hr = pd3ddev->CreateVolumeTexture(m_dwWidth, m_dwHeight, m_dwDepth,
            m_numMips, 0, fmt, D3DPOOL_SYSTEMMEM, &pvoltexNew)))
        {
            goto LFail;
        }
        hr = pvoltex->GetVolumeLevel(0, &pvolSrc);
        hr = pvoltexNew->GetVolumeLevel(0, &pvolDest);
        hr = D3DXLoadVolumeFromVolume(pvolDest, NULL, NULL, pvolSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
        ReleasePpo(&pvolSrc);
        ReleasePpo(&pvolDest);
        hr = D3DXFilterVolumeTexture(pvoltexNew, NULL, 0, D3DX_FILTER_TRIANGLE);
    }
    else if (pmiptex != NULL)
    {
        if (FAILED(hr = pd3ddev->CreateTexture(m_dwWidth, m_dwHeight, m_numMips,
             0, fmt, D3DPOOL_MANAGED, &pmiptexNew)))
        {
            goto LFail;
        }
        hr = pmiptex->GetSurfaceLevel(0, &psurfSrc);
        hr = pmiptexNew->GetSurfaceLevel(0, &psurfDest);
        hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = D3DXFilterTexture(pmiptexNew, NULL, 0, D3DX_FILTER_TRIANGLE);
    }
    else
    {
        if (FAILED(hr = pd3ddev->CreateCubeTexture(m_dwWidth, m_numMips,
             0, fmt, D3DPOOL_MANAGED, &pcubetexNew)))
        {
            goto LFail;
        }
        hr = pcubetex->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_X, 0, &psurfSrc);
        hr = pcubetexNew->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_X, 0, &psurfDest);
        hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = pcubetex->GetCubeMapSurface(D3DCUBEMAP_FACE_NEGATIVE_X, 0, &psurfSrc);
        hr = pcubetexNew->GetCubeMapSurface(D3DCUBEMAP_FACE_NEGATIVE_X, 0, &psurfDest);
        hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = pcubetex->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_Y, 0, &psurfSrc);
        hr = pcubetexNew->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_Y, 0, &psurfDest);
        hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = pcubetex->GetCubeMapSurface(D3DCUBEMAP_FACE_NEGATIVE_Y, 0, &psurfSrc);
        hr = pcubetexNew->GetCubeMapSurface(D3DCUBEMAP_FACE_NEGATIVE_Y, 0, &psurfDest);
        hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = pcubetex->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_Z, 0, &psurfSrc);
        hr = pcubetexNew->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_Z, 0, &psurfDest);
        hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = pcubetex->GetCubeMapSurface(D3DCUBEMAP_FACE_NEGATIVE_Z, 0, &psurfSrc);
        hr = pcubetexNew->GetCubeMapSurface(D3DCUBEMAP_FACE_NEGATIVE_Z, 0, &psurfDest);
        hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = D3DXFilterCubeTexture(pcubetexNew, NULL, 0, D3DX_FILTER_TRIANGLE);
    }

    ReleasePpo(&m_ptexOrig);
    if (pvoltexNew != NULL)
        m_ptexOrig = pvoltexNew;
    else if (pcubetexNew != NULL)
        m_ptexOrig = pcubetexNew;
    else
        m_ptexOrig = pmiptexNew;

    if (m_ptexNew != NULL)
    {
        // Rather than filtering down the (probably-compressed) m_ptexNew
        // top level, compress each mip level from the (probably-uncompressed)
        // m_ptexOrig levels.
        if (pvoltexNew != NULL)
        {
            D3DVOLUME_DESC vd;
            ((LPDIRECT3DVOLUMETEXTURE8)m_ptexNew)->GetLevelDesc(0, &vd);
            fmt = vd.Format;
        }
        else if (pcubetexNew != NULL)
        {
            D3DSURFACE_DESC sd;
            ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetLevelDesc(0, &sd);
            fmt = sd.Format;
        }
        else
        {
            D3DSURFACE_DESC sd;
            ((LPDIRECT3DCUBETEXTURE8)m_ptexNew)->GetLevelDesc(0, &sd);
            fmt = sd.Format;
        }
        Compress(fmt, FALSE);
    }

    m_bTitleModsChanged = TRUE; // Generate title bar update
    UpdateAllViews(NULL, 1); // tell CView to pick up new surface pointers
    SetModifiedFlag();
    return;

LFail:
    ReleasePpo(&pddsNew);
}


void CDxtexDoc::SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU)
{
    CDocument::SetPathName(lpszPathName, bAddToMRU);

    TCHAR* pszLeaf = strrchr(lpszPathName, '\\') + 1;
    TCHAR* pszExtension = strrchr(lpszPathName, '.');
    if (lstrcmpi(pszExtension, ".dds") != 0)
    {
        lstrcpy(pszExtension, "");
        SetModifiedFlag(TRUE);
        SetTitle(pszLeaf);
        m_strPathName.Empty();
    }
}

DWORD CDxtexDoc::NumMips(VOID)
{
    return m_numMips;
}


void CDxtexDoc::OnFileOpenAlpha()
{
    HRESULT hr;
    CString fileName;
    LPDIRECT3DTEXTURE8 pmiptex;

    if (IsCubeMap() || IsVolumeMap())
        return;
    pmiptex = (LPDIRECT3DTEXTURE8)m_ptexOrig;

    // Premultiplied-alpha files don't support this feature:
    D3DSURFACE_DESC sd;
    pmiptex->GetLevelDesc(0, &sd);
    if (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4)
    {
        AfxMessageBox(ID_ERROR_PREMULTALPHA);
        return;
    }

    if (!PromptForBmp(&fileName))
        return;

    LPDIRECT3DSURFACE8 psurf;
    if (FAILED(hr = pmiptex->GetSurfaceLevel(0, &psurf)))
        return;

    if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurf)))
        return;
    if (m_numMips > 1)
        OnGenerateMipMaps();
    else if (m_ptexNew != NULL)
    {
        ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetLevelDesc(0, &sd);
        Compress(sd.Format, FALSE);
    }
    UpdateAllViews(NULL, 1);
}


HRESULT CDxtexDoc::LoadAlphaIntoSurface(CString& strPath, LPDIRECT3DSURFACE8 psurf)
{
    HRESULT hr;
    D3DSURFACE_DESC sd;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DTEXTURE8 ptexAlpha;
    LPDIRECT3DSURFACE8 psurfAlpha;
    LPDIRECT3DSURFACE8 psurfTarget;

    psurf->GetDesc(&sd);

    // Load the alpha BMP into psurfAlpha, a new A8R8G8B8 surface
    hr = D3DXCreateTextureFromFileEx(pd3ddev, strPath, sd.Width, sd.Height, 1, 0,
        D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, D3DX_FILTER_TRIANGLE,
        D3DX_FILTER_TRIANGLE, 0, NULL, NULL, &ptexAlpha);
    hr = ptexAlpha->GetSurfaceLevel(0, &psurfAlpha);

    // Copy the target surface into an A8R8G8B8 surface
    hr = pd3ddev->CreateImageSurface(sd.Width, sd.Height, D3DFMT_A8R8G8B8, &psurfTarget);
    hr = D3DXLoadSurfaceFromSurface(psurfTarget, NULL, NULL, psurf, NULL, NULL,
        D3DX_FILTER_TRIANGLE, 0);

    // Fill in the alpha channels of psurfTarget based on the blue channel of psurfAlpha
    D3DLOCKED_RECT lrSrc;
    D3DLOCKED_RECT lrDest;

    hr = psurfAlpha->LockRect(&lrSrc, NULL, D3DLOCK_READONLY);
    hr = psurfTarget->LockRect(&lrDest, NULL, 0);

    DWORD xp;
    DWORD yp;
    DWORD* pdwRowSrc = (DWORD*)lrSrc.pBits;
    DWORD* pdwRowDest = (DWORD*)lrDest.pBits;
    DWORD* pdwSrc;
    DWORD* pdwDest;
    DWORD dwAlpha;
    LONG dataBytesPerRow = 4 * sd.Width;

    for (yp = 0; yp < sd.Height; yp++)
    {
        pdwSrc = pdwRowSrc;
        pdwDest = pdwRowDest;
        for (xp = 0; xp < sd.Width; xp++)
        {
            dwAlpha = *pdwSrc << 24;
            *pdwDest &= 0x00ffffff;
            *pdwDest |= dwAlpha;

            pdwSrc++;
            pdwDest++;
        }
        pdwRowSrc += lrSrc.Pitch / 4;
        pdwRowDest += lrDest.Pitch / 4;
    }

    psurfAlpha->UnlockRect();
    psurfTarget->UnlockRect();

    // Copy psurfTarget back into real surface
    hr = D3DXLoadSurfaceFromSurface(psurf, NULL, NULL, psurfTarget, NULL, NULL,
        D3DX_FILTER_TRIANGLE, 0);

    // Release allocated interfaces
    ReleasePpo(&psurfTarget);
    ReleasePpo(&psurfAlpha);
    ReleasePpo(&ptexAlpha);

    return S_OK;
}


BOOL CDxtexDoc::PromptForBmp(CString* pstrPath)
{
    CFileDialog dlgFile(TRUE);

    CString title;
    VERIFY(title.LoadString(AFX_IDS_OPENFILE));

    CString strFilter;
    CString strDefault;

    strFilter += "Bitmap Files (*.bmp, *.tga)";
    strFilter += (TCHAR)'\0';   // next string please
    strFilter += _T("*.bmp;*.tga");
    strFilter += (TCHAR)'\0';   // last string
    dlgFile.m_ofn.nMaxCustFilter++;

    // append the "*.*" all files filter
    CString allFilter;
    VERIFY(allFilter.LoadString(AFX_IDS_ALLFILTER));
    strFilter += allFilter;
    strFilter += (TCHAR)'\0';   // next string please
    strFilter += _T("*.*");
    strFilter += (TCHAR)'\0';   // last string
    dlgFile.m_ofn.nMaxCustFilter++;

    dlgFile.m_ofn.lpstrFilter = strFilter;
    dlgFile.m_ofn.lpstrTitle = title;
    dlgFile.m_ofn.lpstrFile = pstrPath->GetBuffer(_MAX_PATH);

    INT_PTR nResult = dlgFile.DoModal();
    pstrPath->ReleaseBuffer();
    if (nResult != IDOK)
        return FALSE;
    return TRUE;
}


void CDxtexDoc::OpenSubsurface(D3DCUBEMAP_FACES FaceType, LONG lwMip, LONG lwSlice)
{
    HRESULT hr;
    CString fileName;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DTEXTURE8 ptex = NULL;
    LPDIRECT3DSURFACE8 psurfOrig = NULL;
    LPDIRECT3DSURFACE8 psurfNew = NULL;

    if (!PromptForBmp(&fileName))
        return;

    if (IsVolumeMap())
    {
        hr = D3DXCreateTextureFromFile(pd3ddev, fileName, &ptex);
        hr = ptex->GetSurfaceLevel(0, &psurfOrig);
    }
    else if (IsCubeMap())
    {
        hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexOrig)->GetCubeMapSurface(FaceType, lwMip, &psurfOrig);
        if (m_ptexNew != NULL)
            hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexNew)->GetCubeMapSurface(FaceType, lwMip, &psurfNew);
        hr = D3DXLoadSurfaceFromFile(psurfOrig, NULL, NULL, fileName, NULL, D3DX_FILTER_TRIANGLE, 0, NULL);
    }
    else
    {
        hr = ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetSurfaceLevel(lwMip, &psurfOrig);
        if (m_ptexNew != NULL)
            hr = ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetSurfaceLevel(lwMip, &psurfNew);
        hr = D3DXLoadSurfaceFromFile(psurfOrig, NULL, NULL, fileName, NULL, D3DX_FILTER_TRIANGLE, 0, NULL);
    }

    // Look for "foo_a.bmp" for alpha channel
    int i = fileName.ReverseFind('.');
    fileName = fileName.Left(i) + "_a.bmp";
    CFileStatus status;
    if (CFile::GetStatus(fileName, status))
    {
        if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurfOrig)))
            return;
    }

    if (IsVolumeMap())
    {
        LPDIRECT3DVOLUME8 pvol;
        hr = ((LPDIRECT3DVOLUMETEXTURE8)m_ptexOrig)->GetVolumeLevel(lwMip, &pvol);
        hr = LoadVolumeSliceFromSurface(pvol, lwSlice, psurfOrig);
        ReleasePpo(&pvol);
        if (m_ptexNew)
        {
            hr = ((LPDIRECT3DVOLUMETEXTURE8)m_ptexNew)->GetVolumeLevel(lwMip, &pvol);
            hr = LoadVolumeSliceFromSurface(pvol, lwSlice, psurfOrig);
            ReleasePpo(&pvol);
        }
    }
    else if (psurfNew != NULL)
    {
        hr = D3DXLoadSurfaceFromSurface(psurfNew, NULL, NULL, psurfOrig, NULL, NULL, D3DX_FILTER_TRIANGLE, 0);
    }

    ReleasePpo(&psurfOrig);
    ReleasePpo(&psurfNew);
    ReleasePpo(&ptex);

    SetModifiedFlag(TRUE);
    UpdateAllViews(NULL, 1);
}


void CDxtexDoc::OpenAlphaSubsurface(D3DCUBEMAP_FACES FaceType, LONG lwMip, LONG lwSlice)
{
    HRESULT hr;
    CString fileName;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DTEXTURE8 ptexOrig = NULL;
    LPDIRECT3DTEXTURE8 ptexNew = NULL;
    LPDIRECT3DSURFACE8 psurfOrig = NULL;
    LPDIRECT3DSURFACE8 psurfNew = NULL;
    LPDIRECT3DVOLUME8 pvolOrig = NULL;
    LPDIRECT3DVOLUME8 pvolNew = NULL;
    D3DSURFACE_DESC sd;
    DWORD dwWidth = m_dwWidth;
    DWORD dwHeight = m_dwHeight;

    if (IsVolumeMap())
    {
        for (int i = 0; i < lwMip; i++)
        {
            dwWidth /= 2;
            dwHeight /= 2;
        }
        hr = pd3ddev->CreateTexture(dwWidth, dwHeight, 1,
             0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &ptexOrig);
        hr = ptexOrig->GetSurfaceLevel(0, &psurfOrig);
        hr = ((LPDIRECT3DVOLUMETEXTURE8)m_ptexOrig)->GetVolumeLevel(lwMip, &pvolOrig);
        hr = LoadSurfaceFromVolumeSlice(pvolOrig, lwSlice, psurfOrig);
        if (m_ptexNew != NULL)
        {
            hr = pd3ddev->CreateTexture(dwWidth, dwHeight, 1,
                 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &ptexNew);
            hr = ptexNew->GetSurfaceLevel(0, &psurfOrig);
            hr = ((LPDIRECT3DVOLUMETEXTURE8)m_ptexOrig)->GetVolumeLevel(lwMip, &pvolNew);
            hr = LoadSurfaceFromVolumeSlice(pvolNew, lwSlice, psurfOrig);
        }
    }
    else if (IsCubeMap())
    {
        hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexOrig)->GetCubeMapSurface(FaceType, lwMip, &psurfOrig);
        ((LPDIRECT3DCUBETEXTURE8)m_ptexOrig)->GetLevelDesc(lwMip, &sd);
        if (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4)
        {
            AfxMessageBox(ID_ERROR_PREMULTALPHA);
            return;
        }
        if (m_ptexNew != NULL)
        {
            hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexNew)->GetCubeMapSurface(FaceType, lwMip, &psurfNew);
            ((LPDIRECT3DCUBETEXTURE8)m_ptexNew)->GetLevelDesc(lwMip, &sd);
            if (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4)
            {
                AfxMessageBox(ID_ERROR_PREMULTALPHA);
                return;
            }
        }
    }
    else
    {
        hr = ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetSurfaceLevel(lwMip, &psurfOrig);
        ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetLevelDesc(lwMip, &sd);
        if (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4)
        {
            AfxMessageBox(ID_ERROR_PREMULTALPHA);
            return;
        }
        if (m_ptexNew != NULL)
        {
            hr = ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetSurfaceLevel(lwMip, &psurfNew);
            ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetLevelDesc(lwMip, &sd);
            if (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4)
            {
                AfxMessageBox(ID_ERROR_PREMULTALPHA);
                return;
            }
        }
    }

    if (!PromptForBmp(&fileName))
        return;

    if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurfOrig)))
        return;

    if (psurfNew != NULL)
    {
        if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurfNew)))
            return;
    }

    if (pvolOrig != NULL)
    {
        hr = LoadVolumeSliceFromSurface(pvolOrig, lwSlice, psurfOrig);
    }
    if (pvolNew != NULL)
    {
        hr = LoadVolumeSliceFromSurface(pvolNew, lwSlice, psurfNew);
    }

    ReleasePpo(&psurfOrig);
    ReleasePpo(&psurfNew);
    ReleasePpo(&ptexOrig);
    ReleasePpo(&ptexNew);
    ReleasePpo(&pvolOrig);
    ReleasePpo(&pvolNew);

    SetModifiedFlag(TRUE);
    UpdateAllViews(NULL, 1);
}


void CDxtexDoc::OnFormatChangeCubeMapFaces()
{
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    D3DSURFACE_DESC sd;
    LPDIRECT3DCUBETEXTURE8 ptexCube;
    DWORD iLevel;
    LPDIRECT3DSURFACE8 psurfSrc;
    LPDIRECT3DSURFACE8 psurfDest;

    CCubeMapDlg cubeMapDlg;
    if (IDCANCEL == cubeMapDlg.DoModal())
        return;

    // Change m_ptexOrig into a cubemap
    ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetLevelDesc(0, &sd);
    hr = D3DXCreateCubeTexture(pd3ddev, m_dwWidth, m_numMips, 0, sd.Format, D3DPOOL_MANAGED, &ptexCube);
    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        hr = ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetSurfaceLevel(iLevel, &psurfSrc);
        hr = ptexCube->GetCubeMapSurface((D3DCUBEMAP_FACES)cubeMapDlg.m_iFace, iLevel, &psurfDest);
        hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL,
            psurfSrc, NULL, NULL, D3DX_FILTER_TRIANGLE, 0);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
    }
    ReleasePpo(&m_ptexOrig);
    m_ptexOrig = ptexCube;

    // Change m_ptexNew into a cubemap too
    if (m_ptexNew != NULL)
    {
        ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetLevelDesc(0, &sd);
        hr = D3DXCreateCubeTexture(pd3ddev, m_dwWidth, m_numMips, 0, sd.Format, D3DPOOL_MANAGED, &ptexCube);
        for (iLevel = 0; iLevel < m_numMips; iLevel++)
        {
            hr = ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetSurfaceLevel(iLevel, &psurfSrc);
            hr = ptexCube->GetCubeMapSurface((D3DCUBEMAP_FACES)cubeMapDlg.m_iFace, iLevel, &psurfDest);
            hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL,
                psurfSrc, NULL, NULL, D3DX_FILTER_TRIANGLE, 0);
            ReleasePpo(&psurfSrc);
            ReleasePpo(&psurfDest);
        }
        ReleasePpo(&m_ptexNew);
        m_ptexNew = ptexCube;
    }
    m_dwCubeMapFlags = DDS_CUBEMAP_ALLFACES;
    SetModifiedFlag();
    UpdateAllViews(NULL, 1); // tell CView to pick up new surface pointers
}


void CDxtexDoc::OnFormatMakeIntoVolumeMap()
{
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    D3DSURFACE_DESC sd;
    LPDIRECT3DVOLUMETEXTURE8 ptexVolume;
    DWORD iLevel;
    LPDIRECT3DSURFACE8 psurfSrc;
    LPDIRECT3DVOLUME8 pvolumeDest;
    UINT numLayers;

    CVolumeMapDlg volumeMapDlg;
    if (IDCANCEL == volumeMapDlg.DoModal())
        return;

    numLayers = (1 << volumeMapDlg.m_powLayers) * 2;

    // Change m_ptexOrig into a volumemap
    ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetLevelDesc(0, &sd);
    hr = pd3ddev->CreateVolumeTexture(m_dwWidth, m_dwHeight, numLayers,
        m_numMips, 0, sd.Format, D3DPOOL_SYSTEMMEM, &ptexVolume);
    if (FAILED(hr))
        return;
    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        hr = ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetSurfaceLevel(iLevel, &psurfSrc);
        hr = ptexVolume->GetVolumeLevel(iLevel, &pvolumeDest);
        hr = LoadVolumeSliceFromSurface(pvolumeDest, 0, psurfSrc);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&pvolumeDest);
    }
    ReleasePpo(&m_ptexOrig);
    m_ptexOrig = ptexVolume;

    // Change m_ptexNew into a volumemap too
    if (m_ptexNew != NULL)
    {
        ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetLevelDesc(0, &sd);
        hr = pd3ddev->CreateVolumeTexture(m_dwWidth, m_dwHeight, numLayers,
            m_numMips, 0, sd.Format, D3DPOOL_SYSTEMMEM, &ptexVolume);
        if (FAILED(hr))
            return;
        for (iLevel = 0; iLevel < m_numMips; iLevel++)
        {
            hr = ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetSurfaceLevel(iLevel, &psurfSrc);
            hr = ptexVolume->GetVolumeLevel(iLevel, &pvolumeDest);
            hr = LoadVolumeSliceFromSurface(pvolumeDest, 0, psurfSrc);
            ReleasePpo(&psurfSrc);
            ReleasePpo(&pvolumeDest);
        }
        ReleasePpo(&m_ptexNew);
        m_ptexNew = ptexVolume;
    }
    m_dwDepth = numLayers;
    SetModifiedFlag();
    UpdateAllViews(NULL, 1); // tell CView to pick up new surface pointers
}


HRESULT CDxtexDoc::LoadVolumeSliceFromSurface(LPDIRECT3DVOLUME8 pVolume, UINT iSlice, LPDIRECT3DSURFACE8 psurf)
{
    HRESULT hr;
    D3DSURFACE_DESC sd;
    D3DVOLUME_DESC vd;
    D3DLOCKED_RECT lr;
    D3DBOX boxSrc;
    D3DBOX boxDest;

    psurf->GetDesc(&sd);
    pVolume->GetDesc(&vd);

    boxSrc.Left = 0;
    boxSrc.Right = sd.Width;
    boxSrc.Top = 0;
    boxSrc.Bottom = sd.Height;
    boxSrc.Front = 0;
    boxSrc.Back = 1;

    boxDest.Left = 0;
    boxDest.Right = vd.Width;
    boxDest.Top = 0;
    boxDest.Bottom = vd.Height;
    boxDest.Front = iSlice;
    boxDest.Back = iSlice + 1;

    hr = psurf->LockRect(&lr, NULL, 0);
    if (FAILED(hr))
        return hr;

    hr = D3DXLoadVolumeFromMemory(pVolume, NULL, &boxDest, lr.pBits, sd.Format, lr.Pitch,
        0, NULL, &boxSrc, D3DX_FILTER_TRIANGLE, 0);

    psurf->UnlockRect();

    return hr;
}


HRESULT CDxtexDoc::LoadSurfaceFromVolumeSlice(LPDIRECT3DVOLUME8 pVolume, UINT iSlice, LPDIRECT3DSURFACE8 psurf)
{
    HRESULT hr;
    D3DVOLUME_DESC vd;
    D3DLOCKED_BOX lb;
    D3DBOX box;
    RECT rc;

    pVolume->GetDesc(&vd);

    box.Left = 0;
    box.Right = vd.Width;
    box.Top = 0;
    box.Bottom = vd.Height;
    box.Front = iSlice;
    box.Back = iSlice + 1;

    rc.left = 0;
    rc.right = vd.Width;
    rc.top = 0;
    rc.bottom = vd.Height;

    hr = pVolume->LockBox(&lb, &box, 0);
    if (FAILED(hr))
        return hr;

    hr = D3DXLoadSurfaceFromMemory(psurf, NULL, NULL, lb.pBits, vd.Format, lb.RowPitch,
        NULL, &rc, D3DX_FILTER_TRIANGLE, 0);

    pVolume->UnlockBox();

    return hr;
}


HRESULT CDxtexDoc::BltAllLevels(D3DCUBEMAP_FACES FaceType,
    LPDIRECT3DBASETEXTURE8 ptexSrc, LPDIRECT3DBASETEXTURE8 ptexDest)
{
    HRESULT hr;
    LPDIRECT3DTEXTURE8 pmiptexSrc;
    LPDIRECT3DTEXTURE8 pmiptexDest;
    LPDIRECT3DCUBETEXTURE8 pcubetexSrc;
    LPDIRECT3DCUBETEXTURE8 pcubetexDest;
    LPDIRECT3DVOLUMETEXTURE8 pvoltexSrc;
    LPDIRECT3DVOLUMETEXTURE8 pvoltexDest;
    LPDIRECT3DSURFACE8 psurfSrc;
    LPDIRECT3DSURFACE8 psurfDest;
    LPDIRECT3DVOLUME8 pvolSrc;
    LPDIRECT3DVOLUME8 pvolDest;
    DWORD iLevel;

    if (IsVolumeMap())
    {
        pvoltexSrc = (LPDIRECT3DVOLUMETEXTURE8)ptexSrc;
        pvoltexDest = (LPDIRECT3DVOLUMETEXTURE8)ptexDest;
    }
    else if (IsCubeMap())
    {
        pcubetexSrc = (LPDIRECT3DCUBETEXTURE8)ptexSrc;
        pcubetexDest = (LPDIRECT3DCUBETEXTURE8)ptexDest;
    }
    else
    {
        pmiptexSrc = (LPDIRECT3DTEXTURE8)ptexSrc;
        pmiptexDest = (LPDIRECT3DTEXTURE8)ptexDest;
    }

    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        if (IsVolumeMap())
        {
            hr = pvoltexSrc->GetVolumeLevel(iLevel, &pvolSrc);
            hr = pvoltexDest->GetVolumeLevel(iLevel, &pvolDest);
            hr = D3DXLoadVolumeFromVolume(pvolDest, NULL, NULL,
                pvolSrc, NULL, NULL, D3DX_FILTER_TRIANGLE, 0);
        }
        else if (IsCubeMap())
        {
            hr = pcubetexSrc->GetCubeMapSurface(FaceType, iLevel, &psurfSrc);
            hr = pcubetexDest->GetCubeMapSurface(FaceType, iLevel, &psurfDest);
            hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL,
                psurfSrc, NULL, NULL, D3DX_FILTER_TRIANGLE, 0);
        }
        else
        {
            hr = pmiptexSrc->GetSurfaceLevel(iLevel, &psurfSrc);
            hr = pmiptexDest->GetSurfaceLevel(iLevel, &psurfDest);
            hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL,
                psurfSrc, NULL, NULL, D3DX_FILTER_TRIANGLE, 0);
        }
    }

    return S_OK;
}


void CDxtexDoc::OpenCubeFace(D3DCUBEMAP_FACES FaceType)
{
    HRESULT hr;
    CString fileName;
    LPDIRECT3DSURFACE8 psurfOrig = NULL;
    LPDIRECT3DSURFACE8 psurfNew = NULL;

    if (!IsCubeMap())
        return;

    hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexOrig)->GetCubeMapSurface(FaceType, 0, &psurfOrig);
    if (m_ptexNew != NULL)
        hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexNew)->GetCubeMapSurface(FaceType, 0, &psurfNew);

    if (!PromptForBmp(&fileName))
        return;

    hr = D3DXLoadSurfaceFromFile(psurfOrig, NULL, NULL, fileName, NULL, D3DX_FILTER_TRIANGLE, 0, NULL);

    // Look for "foo_a.bmp" for alpha channel
    int i = fileName.ReverseFind('.');
    fileName = fileName.Left(i) + "_a.bmp";
    CFileStatus status;
    if (CFile::GetStatus(fileName, status))
    {
        if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurfOrig)))
            return;
    }

    if (m_numMips > 1)
    {
        hr = D3DXFilterCubeTexture((LPDIRECT3DCUBETEXTURE8)m_ptexOrig, NULL, 0, D3DX_FILTER_TRIANGLE);
    }


    if (psurfNew != NULL)
    {
        hr = D3DXLoadSurfaceFromSurface(psurfNew, NULL, NULL, psurfOrig, NULL, NULL, D3DX_FILTER_TRIANGLE, 0);

        if (m_numMips > 1)
        {
            hr = D3DXFilterCubeTexture((LPDIRECT3DCUBETEXTURE8)m_ptexNew, NULL, 0, D3DX_FILTER_TRIANGLE);
        }
    }

    ReleasePpo(&psurfOrig);
    ReleasePpo(&psurfNew);

    SetModifiedFlag(TRUE);
    UpdateAllViews(NULL, 1);
}


void CDxtexDoc::OpenAlphaCubeFace(D3DCUBEMAP_FACES FaceType)
{
    HRESULT hr;
    CString fileName;
    LPDIRECT3DSURFACE8 psurfOrig = NULL;
    LPDIRECT3DSURFACE8 psurfNew = NULL;
    D3DSURFACE_DESC sd;

    if (!IsCubeMap())
        return;

    hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexOrig)->GetCubeMapSurface(FaceType, 0, &psurfOrig);
    ((LPDIRECT3DCUBETEXTURE8)m_ptexOrig)->GetLevelDesc(0, &sd);
    if (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4)
    {
        AfxMessageBox(ID_ERROR_PREMULTALPHA);
        return;
    }
    if (m_ptexNew != NULL)
    {
        hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexNew)->GetCubeMapSurface(FaceType, 0, &psurfNew);
    }

    if (!PromptForBmp(&fileName))
        return;

    if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurfOrig)))
        return;

    if (psurfNew != NULL)
    {
        if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurfNew)))
            return;
    }

    if (m_numMips > 1)
    {
        hr = D3DXFilterCubeTexture((LPDIRECT3DCUBETEXTURE8)m_ptexOrig, NULL, 0, D3DX_FILTER_TRIANGLE);
    }


    if (psurfNew != NULL)
    {
        hr = D3DXLoadSurfaceFromSurface(psurfNew, NULL, NULL, psurfOrig, NULL, NULL, D3DX_FILTER_TRIANGLE, 0);

        if (m_numMips > 1)
        {
            hr = D3DXFilterCubeTexture((LPDIRECT3DCUBETEXTURE8)m_ptexNew, NULL, 0, D3DX_FILTER_TRIANGLE);
        }
    }

    ReleasePpo(&psurfOrig);
    ReleasePpo(&psurfNew);

    SetModifiedFlag(TRUE);
    UpdateAllViews(NULL, 1);
}


DWORD CDxtexDoc::DwDepthAt(LONG lwMip)
{
    DWORD dwDepth = m_dwDepth;
    while (lwMip > 0 && dwDepth > 1)
    {
        dwDepth /= 2;
        lwMip--;
    }
    return dwDepth;
}


void CDxtexDoc::OnFormatChangeSurfaceFmt()
{
    CChangeFmtDlg changeFmtDlg;
    LPDIRECT3DBASETEXTURE8 ptex;

    ptex = (m_ptexNew == NULL ? m_ptexOrig : m_ptexNew);

    if (IsVolumeMap())
    {
        D3DVOLUME_DESC vd;
        ((LPDIRECT3DVOLUMETEXTURE8)ptex)->GetLevelDesc(0, &vd);
        changeFmtDlg.m_fmt = vd.Format;
    }
    else if (IsCubeMap())
    {
        D3DSURFACE_DESC sd;
        ((LPDIRECT3DCUBETEXTURE8)ptex)->GetLevelDesc(0, &sd);
        changeFmtDlg.m_fmt = sd.Format;
    }
    else
    {
        D3DSURFACE_DESC sd;
        ((LPDIRECT3DTEXTURE8)ptex)->GetLevelDesc(0, &sd);
        changeFmtDlg.m_fmt = sd.Format;
    }

    changeFmtDlg.m_bVolume = IsVolumeMap();
    changeFmtDlg.m_bXbox = IsXbox();

    if (IDCANCEL == changeFmtDlg.DoModal())
        return;

    m_bXbox = changeFmtDlg.m_bXbox;

    Compress(changeFmtDlg.m_fmt, TRUE);
}


void CDxtexDoc::OnUpdateFileOpenAlpha(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(!IsCubeMap() && !IsVolumeMap());
}


void CDxtexDoc::OnUpdateFormatGenerateMipmaps(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_numMips <= 1);
}


void CDxtexDoc::OnUpdateFormatChangeCubeMapFaces(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(!IsCubeMap() && !IsVolumeMap());
}


void CDxtexDoc::OnUpdateFormatMakeIntoVolumeMap(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(!IsCubeMap() && !IsVolumeMap());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\Dialogs.h ===
// Dialogs.h : header file
//
#if !defined(AFX_DIALOGS_H__14A2C924_FB41_4BB7_92E4_DBA7CAF1FA06__INCLUDED_)
#define AFX_DIALOGS_H__14A2C924_FB41_4BB7_92E4_DBA7CAF1FA06__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CNewTextureDlg dialog

class CNewTextureDlg : public CDialog
{
// Construction
public:
    CNewTextureDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CNewTextureDlg)
    enum { IDD = IDD_NEWTEXTURE };
    int     m_iTexType;
    int     m_dwWidth;
    int     m_dwHeight;
    int     m_dwDepth;
    int     m_iFmt;
    int     m_bXbox;
    CString m_strFmtDesc;
    int     m_numMips;
    D3DFORMAT m_fmt;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CNewTextureDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CNewTextureDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeTextureType();
    afx_msg void OnChangeFormat();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CCubeMapDlg dialog

class CCubeMapDlg : public CDialog
{
// Construction
public:
    CCubeMapDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CCubeMapDlg)
    enum { IDD = IDD_CUBEMAP };
    INT     m_iFace;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCubeMapDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CCubeMapDlg)
        // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CVolumeMapDlg dialog

class CVolumeMapDlg : public CDialog
{
// Construction
public:
    CVolumeMapDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CVolumeMapDlg)
    enum { IDD = IDD_VOLUMEMAP };
    int     m_powLayers;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CVolumeMapDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CVolumeMapDlg)
        // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CChangeFmtDlg dialog

class CChangeFmtDlg : public CDialog
{
// Construction
public:
    CChangeFmtDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CChangeFmtDlg)
    enum { IDD = IDD_CHANGEFORMAT };
    int     m_iFmt;
    CString m_strFmtDesc;
    int m_bXbox;
    //}}AFX_DATA
    BOOL m_bVolume;
    D3DFORMAT m_fmt;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChangeFmtDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CChangeFmtDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeFmt();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    void UpdateFmtDesc();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIALOGS_H__14A2C924_FB41_4BB7_92E4_DBA7CAF1FA06__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\DXTex.h ===
// dxtex.h : main header file for the DXTEX application
//

#if !defined(AFX_DXTX_H__712C53C7_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
#define AFX_DXTX_H__712C53C7_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

#ifndef ReleasePpo
    #define ReleasePpo(ppo) \
        if (*(ppo) != NULL) \
        { \
            (*(ppo))->Release(); \
            *(ppo) = NULL; \
        } \
        else (VOID)0
#endif

/////////////////////////////////////////////////////////////////////////////
// CDxtexDocManager:
// I override this class to customize DoPromptFileName to allow importing of
// BMPs as well as DDSs into CDxtexDocs.
//
class CDxtexDocManager : public CDocManager
{
public:
    virtual BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
            DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);
};

/////////////////////////////////////////////////////////////////////////////
// CDxtexCommandLineInfo:
// I override this class to handle custom command-line options
//
class CDxtexCommandLineInfo : public CCommandLineInfo
{
public:
    CString m_strFileNameAlpha;
    CString m_strFileNameSave;
    D3DFORMAT m_fmt;
    BOOL m_bAlphaComing;
    BOOL m_bMipMap;

    CDxtexCommandLineInfo::CDxtexCommandLineInfo(VOID);
    virtual void ParseParam(const TCHAR* pszParam, BOOL bFlag, BOOL bLast);

};

/////////////////////////////////////////////////////////////////////////////
// CDxtexApp:
// See dxtex.cpp for the implementation of this class
//

class CDxtexApp : public CWinApp
{
public:
    CDxtexApp();
    virtual ~CDxtexApp();
    LPDIRECT3D8 Pd3d(VOID) { return m_pd3d; }
    LPDIRECT3DDEVICE8 Pd3ddev(VOID) { return m_pd3ddev; }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDxtexApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation
    //{{AFX_MSG(CDxtexApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    LPDIRECT3D8 m_pd3d;
    LPDIRECT3DDEVICE8 m_pd3ddev;
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DXTX_H__712C53C7_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\DXTexview.Cpp ===
// dxtexView.cpp : implementation of the CDxtexView class
//

#include "stdafx.h"
#include "dxtex.h"
#include "dxtexDoc.h"
#include "dxtexView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Our custom vertex type
struct CUSTOMVERTEX
{
    FLOAT x, y, z;
    FLOAT rhw;
    DWORD color;
    FLOAT tu, tv;   // The texture coordinates
};

#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1)


IMPLEMENT_DYNCREATE(CDxtexView, CScrollView)

BEGIN_MESSAGE_MAP(CDxtexView, CScrollView)
    //{{AFX_MSG_MAP(CDxtexView)
    ON_WM_LBUTTONUP()
    ON_COMMAND(ID_FILE_OPENSUBSURFACE, OnFileOpenSubsurface)
    ON_COMMAND(ID_FILE_OPENALPHASUBSURFACE, OnFileOpenAlphaSubsurface)
    ON_COMMAND(ID_FILE_OPENFACE, OnFileOpenFace)
    ON_COMMAND(ID_FILE_OPENALPHAFACE, OnFileOpenAlphaFace)
    ON_COMMAND(ID_VIEW_ORIGINAL, OnViewOriginal)
    ON_COMMAND(ID_VIEW_COMPRESSED, OnViewCompressed)
    ON_COMMAND(ID_VIEW_SMALLERMIPLEVEL, OnViewSmallerMipLevel)
    ON_COMMAND(ID_VIEW_LARGERMIPLEVEL, OnViewLargerMipLevel)
    ON_COMMAND(ID_VIEW_ALPHACHANNEL, OnViewAlphaChannel)
    ON_COMMAND(ID_VIEW_ZOOMIN, OnViewZoomIn)
    ON_COMMAND(ID_VIEW_ZOOMOUT, OnViewZoomOut)
    ON_COMMAND(ID_VIEW_CHANGEBACKGROUNDCOLOR, OnViewChangeBackgroundColor)
    ON_COMMAND(ID_VIEW_NEGX, OnViewNegX)
    ON_COMMAND(ID_VIEW_POSX, OnViewPosX)
    ON_COMMAND(ID_VIEW_NEGY, OnViewNegY)
    ON_COMMAND(ID_VIEW_POSY, OnViewPosY)
    ON_COMMAND(ID_VIEW_NEGZ, OnViewNegZ)
    ON_COMMAND(ID_VIEW_POSZ, OnViewPosZ)
    ON_COMMAND(ID_VIEW_HIGHERVOLUMESLICE, OnViewHigherVolumeSlice)
    ON_COMMAND(ID_VIEW_LOWERVOLUMESLICE, OnViewLowerVolumeSlice)
    ON_UPDATE_COMMAND_UI(ID_FILE_OPENSUBSURFACE, OnUpdateFileOpenSubsurface)
    ON_UPDATE_COMMAND_UI(ID_FILE_OPENALPHASUBSURFACE, OnUpdateFileOpenAlphaSubsurface)
    ON_UPDATE_COMMAND_UI(ID_FILE_OPENFACE, OnUpdateFileOpenFace)
    ON_UPDATE_COMMAND_UI(ID_FILE_OPENALPHAFACE, OnUpdateFileOpenAlphaFace)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ORIGINAL, OnUpdateViewOriginal)
    ON_UPDATE_COMMAND_UI(ID_VIEW_COMPRESSED, OnUpdateViewCompressed)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ALPHACHANNEL, OnUpdateViewAlphaChannel)
    ON_UPDATE_COMMAND_UI(ID_VIEW_LARGERMIPLEVEL, OnUpdateViewLargerMipLevel)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SMALLERMIPLEVEL, OnUpdateViewSmallerMipLevel)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ZOOMIN, OnUpdateViewZoomIn)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ZOOMOUT, OnUpdateViewZoomOut)
    ON_UPDATE_COMMAND_UI(ID_VIEW_NEGX, OnUpdateViewNegX)
    ON_UPDATE_COMMAND_UI(ID_VIEW_POSX, OnUpdateViewPosX)
    ON_UPDATE_COMMAND_UI(ID_VIEW_NEGY, OnUpdateViewNegY)
    ON_UPDATE_COMMAND_UI(ID_VIEW_POSY, OnUpdateViewPosY)
    ON_UPDATE_COMMAND_UI(ID_VIEW_NEGZ, OnUpdateViewNegZ)
    ON_UPDATE_COMMAND_UI(ID_VIEW_POSZ, OnUpdateViewPosZ)
    ON_UPDATE_COMMAND_UI(ID_VIEW_HIGHERVOLUMESLICE, OnUpdateViewHigherVolumeSlice)
    ON_UPDATE_COMMAND_UI(ID_VIEW_LOWERVOLUMESLICE, OnUpdateViewLowerVolumeSlice)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CDxtexView::CDxtexView()
{
    m_ptexCur = NULL;
    m_pSwapChain = NULL;
    m_lwMipCur = 0;
    m_CubeFaceCur = D3DCUBEMAP_FACE_FORCE_DWORD;
    m_lwSliceCur = -1;
    m_fZoom = 1.0f;
    m_bViewOrig = TRUE;
    m_bViewAlpha = FALSE;

    m_pVB = NULL;
    m_ptexCur = NULL;
    m_pSwapChain = NULL;
}


CDxtexView::~CDxtexView()
{
    ReleasePpo(&m_pVB);
    ReleasePpo(&m_ptexCur);
    ReleasePpo(&m_pSwapChain);
}


// Note: repaints don't require re-rendering, just recopy from back buffer to view's DC
void CDxtexView::OnDraw(CDC* pDC)
{
    CDxtexDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    HRESULT hr;
    CRect rcSrc;
    CRect rcDest;

    rcSrc = m_rcSrc;
    rcDest = m_rcDest;

    rcDest.OffsetRect(pDC->GetViewportOrg());

    // REVIEW: only update dirty region?
    if (m_pSwapChain != NULL)
        hr = m_pSwapChain->Present(&rcSrc, &rcDest, GetSafeHwnd(), NULL);
}


#ifdef _DEBUG
void CDxtexView::AssertValid() const
{
    CScrollView::AssertValid();
}


void CDxtexView::Dump(CDumpContext& dc) const
{
    CScrollView::Dump(dc);
}


CDxtexDoc* CDxtexView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CDxtexDoc)));
    return (CDxtexDoc*)m_pDocument;
}
#endif //_DEBUG


void CDxtexView::OnLButtonUp(UINT nFlags, CPoint point)
{
    // Button click means toggle compressed / uncompressed view
    if (m_bViewOrig)
        OnViewCompressed();
    else
        OnViewOriginal();

    CScrollView::OnLButtonUp(nFlags, point);
}


void CDxtexView::OnInitialUpdate()
{
#ifdef _WIN64
    SetClassLongPtr(GetSafeHwnd(), GCLP_HBRBACKGROUND, (LONG_PTR)CreateSolidBrush(RGB(100, 100, 120)));
#else
    SetClassLong(GetSafeHwnd(), GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(100, 100, 120)));
#endif

    if (GetDocument()->IsCubeMap())
        m_CubeFaceCur = D3DCUBEMAP_FACE_POSITIVE_X;
    else
        m_CubeFaceCur = D3DCUBEMAP_FACE_FORCE_DWORD;
    if (GetDocument()->IsVolumeMap())
        m_lwSliceCur = 0;
    BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    UpdateDevice();
    CreateVertexBuffer();
    RenderScene();

    SetScrollSizes(MM_TEXT, CSize(m_rcDest.Width(), m_rcDest.Height()));
    ResizeParentToFit();

    CScrollView::OnInitialUpdate();

    m_bTitleModsChanged = TRUE; // force title bar update
}


VOID CDxtexView::GetImageInfo(CString& strInfo)
{
    LPDIRECT3DBASETEXTURE8 ptex;
    D3DSURFACE_DESC sd;
    D3DVOLUME_DESC vd;
    D3DFORMAT fmt;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwDepth;
    CString strFormat;
    TCHAR sz[100];
    DWORD dwBytes = 0;
    UINT iLevel;

    if (m_bViewOrig)
        ptex = GetDocument()->PtexOrig();
    else
        ptex = GetDocument()->PtexNew();

    if (GetDocument()->IsVolumeMap())
    {
        ((LPDIRECT3DVOLUMETEXTURE8)ptex)->GetLevelDesc(0, &vd);
        fmt = vd.Format;
        dwWidth = vd.Width;
        dwHeight = vd.Height;
        dwDepth = vd.Depth;
    }
    else if (!GetDocument()->IsCubeMap())
    {
        ((LPDIRECT3DTEXTURE8)ptex)->GetLevelDesc(0, &sd);
        fmt = sd.Format;
        dwWidth = sd.Width;
        dwHeight = sd.Height;
        dwDepth = 0;
    }
    else
    {
        ((LPDIRECT3DCUBETEXTURE8)ptex)->GetLevelDesc(0, &sd);
        fmt = sd.Format;
        dwWidth = sd.Width;
        dwHeight = sd.Height;
        dwDepth = 0;
    }

    strFormat = FormatName(fmt);

    // Count bytes in main surface chain
    if (GetDocument()->IsVolumeMap())
    {
        for (iLevel = 0; iLevel < GetDocument()->NumMips(); iLevel++)
        {
            ((LPDIRECT3DVOLUMETEXTURE8)ptex)->GetLevelDesc(iLevel, &vd);
            dwBytes += vd.Size;
        }
    }
    else if (!GetDocument()->IsCubeMap())
    {
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_FORCE_DWORD, ptex);
    }
    else
    {
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_POSITIVE_X, ptex);
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_NEGATIVE_X, ptex);
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_POSITIVE_Y, ptex);
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_NEGATIVE_Y, ptex);
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_POSITIVE_Z, ptex);
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_NEGATIVE_Z, ptex);
    }

    if (dwDepth == 0)
        wsprintf(sz, "%d x %d, %s, %d bytes", dwWidth, dwHeight, strFormat, dwBytes);
    else
        wsprintf(sz, "%d x %d x %d, %s, %d bytes", dwWidth, dwHeight, dwDepth, strFormat, dwBytes);
    strInfo = sz;
}


DWORD CDxtexView::NumBytesInSurfaces(D3DCUBEMAP_FACES FaceType, LPDIRECT3DBASETEXTURE8 ptex)
{
    DWORD dwBytes = 0;
    LPDIRECT3DTEXTURE8 pmiptex = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetex = NULL;
    D3DSURFACE_DESC sd;
    DWORD iLevel;

    if (FaceType == D3DCUBEMAP_FACE_FORCE_DWORD)
        pmiptex = (LPDIRECT3DTEXTURE8)ptex;
    else
        pcubetex = (LPDIRECT3DCUBETEXTURE8)ptex;

    for (iLevel = 0; iLevel < GetDocument()->NumMips(); iLevel++)
    {
        if (pmiptex != NULL)
            pmiptex->GetLevelDesc(iLevel, &sd);
        else
            pcubetex->GetLevelDesc(iLevel, &sd);
        dwBytes += sd.Size;
    }

    return dwBytes;
}


HRESULT CDxtexView::UpdateDevice(VOID)
{
    HRESULT hr;
    LPDIRECT3D8 pd3d = PDxtexApp()->Pd3d();
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    D3DDISPLAYMODE dispMode;
    D3DPRESENT_PARAMETERS presentParams;

    pd3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &dispMode);

    ReleasePpo(&m_pSwapChain);
    ZeroMemory(&presentParams, sizeof(presentParams));
    presentParams.Windowed = TRUE;
    presentParams.SwapEffect = D3DSWAPEFFECT_COPY_VSYNC;
    presentParams.BackBufferWidth = m_rcSrc.Width();
    presentParams.BackBufferHeight = m_rcSrc.Height();
    presentParams.BackBufferFormat = dispMode.Format;

    if (FAILED(hr = pd3ddev->CreateAdditionalSwapChain(&presentParams, &m_pSwapChain)))
        return hr;

    COLORREF crBkgd;
    crBkgd = PDxtexApp()->GetProfileInt("Settings", "Background Color", RGB(0, 255, 255));
    m_dwClearColor = D3DCOLOR_RGBA(GetRValue(crBkgd), GetGValue(crBkgd), GetBValue(crBkgd), 255);

    return S_OK;
}


HRESULT CDxtexView::CreateVertexBuffer(VOID)
{
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();

    // Create the the vertex buffer
    if( FAILED( pd3ddev->CreateVertexBuffer( 6 * sizeof(CUSTOMVERTEX),
        0 /* Usage */, D3DFVF_CUSTOMVERTEX,
        D3DPOOL_DEFAULT, &m_pVB ) ) )
    {
        return E_FAIL;
    }

    return S_OK;
}


HRESULT CDxtexView::RenderScene(VOID)
{
    CWaitCursor waitCursor;
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();

    LPDIRECT3DSURFACE8 psurf;

    if (m_pSwapChain == NULL)
        return E_FAIL;

    // Vertices for our quad
    CUSTOMVERTEX vertexArray[] =
    {
        // x, y, z, rhw, color, tu, tv
        {                 0.0f - 0.5f,                  0.0f - 0.5f, 0.5f, 1.0f, 0xffffffff, 0.0f, 0.0f, },
        { (FLOAT)m_rcSrc.right - 0.5f,                  0.0f - 0.5f, 0.5f, 1.0f, 0xffffffff, 1.0f, 0.0f, },
        { (FLOAT)m_rcSrc.right - 0.5f, (FLOAT)m_rcSrc.bottom - 0.5f, 0.5f, 1.0f, 0xffffffff, 1.0f, 1.0f, },

        { (FLOAT)m_rcSrc.right - 0.5f, (FLOAT)m_rcSrc.bottom - 0.5f, 0.5f, 1.0f, 0xffffffff, 1.0f, 1.0f, },
        {                 0.0f - 0.5f, (FLOAT)m_rcSrc.bottom - 0.5f, 0.5f, 1.0f, 0xffffffff, 0.0f, 1.0f, },
        {                 0.0f - 0.5f,                  0.0f - 0.5f, 0.5f, 1.0f, 0xffffffff, 0.0f, 0.0f, },
    };

    // Copy the global vertex data into the vertex buffer
    VOID* pVertices;
    if( FAILED( m_pVB->Lock( 0, sizeof(vertexArray), (BYTE**)&pVertices, 0 ) ) )
        return E_FAIL;
    memcpy( pVertices, vertexArray, sizeof(vertexArray) );
    m_pVB->Unlock();

    hr = m_pSwapChain->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &psurf);

    hr = pd3ddev->SetRenderTarget(psurf, NULL);

    ReleasePpo(&psurf);

    hr = pd3ddev->Clear(0, NULL, D3DCLEAR_TARGET, m_dwClearColor, 0.0f, 0);

    hr = pd3ddev->BeginScene();

    // If the texture uses premultiplied alpha, the source blend should be D3DBLEND_ONE
    // since RGB is already at the level we want.  With nonpremultiplied alpha, the
    // source blend should be D3DBLEND_SRCALPHA.
    D3DSURFACE_DESC sd;
    m_ptexCur->GetLevelDesc(0, &sd);
    if (!m_bViewAlpha && (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4))
    {
        if (FAILED(hr = pd3ddev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE)))
            return hr;
    }
    else
    {
        if (FAILED(hr = pd3ddev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA)))
            return hr;
    }
    hr = pd3ddev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    hr = pd3ddev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

    pd3ddev->SetTexture(0, m_ptexCur);
    pd3ddev->SetStreamSource( 0, m_pVB, sizeof(CUSTOMVERTEX) );
    pd3ddev->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    pd3ddev->DrawPrimitive( D3DPT_TRIANGLELIST, 0, 2 );
    pd3ddev->SetTexture(0, NULL);

    hr = pd3ddev->EndScene();

    return S_OK;
}


void CDxtexView::OnViewOriginal()
{
    if (GetDocument()->PtexOrig() == NULL)
        return;
    BuildViewSurface(TRUE, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    RenderScene();
    m_bTitleModsChanged = TRUE; // force title bar update
    InvalidateRect(&m_rcDest, FALSE); // force redraw of this view
}


void CDxtexView::OnViewCompressed()
{
    if (GetDocument()->PtexNew() == NULL)
        return;
    BuildViewSurface(FALSE, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    RenderScene();
    m_bTitleModsChanged = TRUE; // force title bar update
    InvalidateRect(&m_rcDest, FALSE); // force redraw of this view
}


void CDxtexView::OnUpdateViewOriginal(CCmdUI* pCmdUI)
{
    if (GetDocument()->PtexOrig() == NULL)
    {
        pCmdUI->Enable(FALSE);
        pCmdUI->SetCheck(0);
    }
    else
    {
        pCmdUI->Enable(TRUE);
        pCmdUI->SetCheck(m_bViewOrig);
    }
}


void CDxtexView::OnUpdateViewCompressed(CCmdUI* pCmdUI)
{
    if (GetDocument()->PtexNew() == NULL)
    {
        pCmdUI->Enable(FALSE);
        pCmdUI->SetCheck(0);
    }
    else
    {
        pCmdUI->Enable(TRUE);
        pCmdUI->SetCheck(!m_bViewOrig);
    }
}


void CDxtexView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
    m_bTitleModsChanged = TRUE; // force title bar update
    if (lHint == 1)
    {
        BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
        RenderScene();
    }
    else if (lHint == 2)
    {
        UpdateDevice();
        RenderScene();
    }
    else if (lHint == 3)
    {
        RenderScene();
    }

    CScrollView::OnUpdate(pSender, lHint, pHint);
}


void CDxtexView::OnViewSmallerMipLevel()
{
    m_lwMipCur++;
    if (m_lwSliceCur > 0)
        m_lwSliceCur /= 2;
    BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    UpdateDevice();
    RenderScene();
    m_bTitleModsChanged = TRUE; // force title bar update
    SetScrollSizes(MM_TEXT, CSize(m_rcDest.Width(), m_rcDest.Height()));
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnViewLargerMipLevel()
{
    m_lwMipCur--;
    if (m_lwSliceCur > 0)
        m_lwSliceCur *= 2;
    BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    UpdateDevice();
    RenderScene();
    m_bTitleModsChanged = TRUE; // force title bar update
    SetScrollSizes(MM_TEXT, CSize(m_rcDest.Width(), m_rcDest.Height()));
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnViewAlphaChannel(VOID)
{
    BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, !m_bViewAlpha);
    RenderScene();
    Invalidate(); // force redraw of this view
    m_bTitleModsChanged = TRUE; // force title bar update
}


void CDxtexView::OnUpdateViewAlphaChannel(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_bViewAlpha);
}


void CDxtexView::OnUpdateViewLargerMipLevel(CCmdUI* pCmdUI)
{
    if (m_lwMipCur > 0)
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);
}


void CDxtexView::OnUpdateViewSmallerMipLevel(CCmdUI* pCmdUI)
{
    if (m_lwMipCur < (LONG)GetDocument()->NumMips() - 1)
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);
}


void CDxtexView::OnViewZoomIn()
{
    if (m_fZoom < 8.0f)
        m_fZoom *= 2.0f;
    m_rcDest.right = (LONG)(m_rcSrc.right * m_fZoom);
    m_rcDest.bottom = (LONG)(m_rcSrc.bottom * m_fZoom);
    SetScrollSizes(MM_TEXT, CSize(m_rcDest.Width(), m_rcDest.Height()));
    m_bTitleModsChanged = TRUE; // force title bar update
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnViewZoomOut()
{
    if (m_fZoom > 0.125f)
        m_fZoom /= 2.0f;
    m_rcDest.right = (LONG)(m_rcSrc.right * m_fZoom);
    m_rcDest.bottom = (LONG)(m_rcSrc.bottom * m_fZoom);
    SetScrollSizes(MM_TEXT, CSize(m_rcDest.Width(), m_rcDest.Height()));
    m_bTitleModsChanged = TRUE; // force title bar update
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewZoomIn(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_fZoom < 8.0f);
}


void CDxtexView::OnUpdateViewZoomOut(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_fZoom > 0.125f);
}


CString CDxtexView::GetStrTitleMods(VOID)
{
    CString strTitleMods;
    strTitleMods = "(";

    // Append alpha, if in alpha mode
    if (m_bViewAlpha)
            strTitleMods += "Alpha, ";

    // Show format
    LPDIRECT3DBASETEXTURE8 ptex;
    CString strFormat;
    D3DFORMAT fmt;

    if (m_bViewOrig)
        ptex = GetDocument()->PtexOrig();
    else
        ptex = GetDocument()->PtexNew();

    if (GetDocument()->IsVolumeMap())
    {
        D3DVOLUME_DESC vd;
        ((LPDIRECT3DVOLUMETEXTURE8)ptex)->GetLevelDesc(0, &vd);
        fmt = vd.Format;
    }
    else if (!GetDocument()->IsCubeMap())
    {
        D3DSURFACE_DESC sd;
        ((LPDIRECT3DTEXTURE8)ptex)->GetLevelDesc(0, &sd);
        fmt = sd.Format;
    }
    else
    {
        D3DSURFACE_DESC sd;
        ((LPDIRECT3DCUBETEXTURE8)ptex)->GetLevelDesc(0, &sd);
        fmt = sd.Format;
    }

    strTitleMods += FormatName(fmt);
    strTitleMods += TEXT(", ");

    // Append cube map info, if a cube map
    switch (m_CubeFaceCur)
    {
    case D3DCUBEMAP_FACE_NEGATIVE_X:
        strTitleMods += "Negative X, ";
        break;
    case D3DCUBEMAP_FACE_POSITIVE_X:
        strTitleMods += "Positive X, ";
        break;
    case D3DCUBEMAP_FACE_NEGATIVE_Y:
        strTitleMods += "Negative Y, ";
        break;
    case D3DCUBEMAP_FACE_POSITIVE_Y:
        strTitleMods += "Positive Y, ";
        break;
    case D3DCUBEMAP_FACE_NEGATIVE_Z:
        strTitleMods += "Negative Z, ";
        break;
    case D3DCUBEMAP_FACE_POSITIVE_Z:
        strTitleMods += "Positive Z, ";
        break;
    }

    if (m_lwSliceCur >= 0)
    {
        CString strSlice;
        strSlice.Format("Slice %d of %d, ", m_lwSliceCur + 1, GetDocument()->DwDepthAt(m_lwMipCur));
        strTitleMods += strSlice;
    }

    // Append mip info, if multiple mip levels
    DWORD dwNumMips = GetDocument()->NumMips();
    if (dwNumMips > 1)
    {
        CString strMipInfo;
        strMipInfo.Format("Mip %d of %d, ", m_lwMipCur + 1, dwNumMips);
        strTitleMods += strMipInfo;
    }

    if( GetDocument()->IsXbox() )
        strTitleMods += "[Xbox] ";

    // Append view magnification
    CString strView;
    strView.Format("%d", (LONG)(100 * m_fZoom));
    strTitleMods += strView + "%";

    strTitleMods += ")";

    return strTitleMods;
}


CString CDxtexView::FormatName(D3DFORMAT fmt)
{
    CString str;
    switch (fmt)
    {
    case D3DFMT_A8R8G8B8:
        str = TEXT("A8R8G8B8");
        break;
    case D3DFMT_A1R5G5B5:
        str = TEXT("A1R5G5B5");
        break;
    case D3DFMT_A4R4G4B4:
        str = TEXT("A4R4G4B4");
        break;
    case D3DFMT_R8G8B8:
        str = TEXT("R8G8B8");
        break;
    case D3DFMT_R5G6B5:
        str = TEXT("R5G6B5");
        break;
    case D3DFMT_DXT1:
        str = TEXT("DXT1");
        break;
    case D3DFMT_DXT2:
        str = TEXT("DXT2");
        break;
    case D3DFMT_DXT3:
        str = TEXT("DXT3");
        break;
    case D3DFMT_DXT4:
        str = TEXT("DXT4");
        break;
    case D3DFMT_DXT5:
        str = TEXT("DXT5");
        break;
    default:
        str = TEXT("unknown fmt");
        break;
    }
    return str;
}

void CDxtexView::OnViewChangeBackgroundColor()
{
    CHOOSECOLOR cc;
    COLORREF crArray[16];

    ZeroMemory(&cc, sizeof(cc));
    cc.lStructSize = sizeof(cc);
    cc.hwndOwner = GetSafeHwnd();
    cc.rgbResult = PDxtexApp()->GetProfileInt("Settings", "Background Color", RGB(0, 255, 255));
    cc.lpCustColors = crArray;
    cc.Flags = CC_RGBINIT | CC_ANYCOLOR | CC_FULLOPEN;

    if (ChooseColor(&cc))
    {
        PDxtexApp()->WriteProfileInt("Settings", "Background Color", cc.rgbResult);

        // Update all views of all documents of our one doc template
        POSITION posTemp = PDxtexApp()->GetFirstDocTemplatePosition();
        CDocTemplate* pDocTemplate = PDxtexApp()->GetNextDocTemplate(posTemp);
        CDocument* pdoc;
        POSITION pos = pDocTemplate->GetFirstDocPosition();
        while (pos != NULL)
        {
            pdoc = pDocTemplate->GetNextDoc(pos);
            pdoc->UpdateAllViews(NULL, 2);
        }
    }
}


void CDxtexView::OnFileOpenSubsurface()
{
    GetDocument()->OpenSubsurface(m_CubeFaceCur, m_lwMipCur, m_lwSliceCur);
}


void CDxtexView::OnUpdateFileOpenSubsurface(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(TRUE);
}


void CDxtexView::OnFileOpenAlphaSubsurface()
{
    GetDocument()->OpenAlphaSubsurface(m_CubeFaceCur, m_lwMipCur, m_lwSliceCur);
}


void CDxtexView::OnUpdateFileOpenAlphaSubsurface(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(TRUE);
}


HRESULT CDxtexView::BuildViewSurface(BOOL bOrig, D3DCUBEMAP_FACES FaceType, LONG lwSlice, LONG lwMip, BOOL bViewAlpha)
{
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DBASETEXTURE8 ptex;
    BOOL bIsCubeMap = GetDocument()->IsCubeMap();
    BOOL bIsVolumeMap = GetDocument()->IsVolumeMap();
    D3DSURFACE_DESC sd;
    D3DVOLUME_DESC vd;

    ReleasePpo(&m_ptexCur);

    if (bIsVolumeMap && lwSlice == -1)
        lwSlice = 0;

    if (bIsCubeMap && FaceType == D3DCUBEMAP_FACE_FORCE_DWORD)
        FaceType = D3DCUBEMAP_FACE_POSITIVE_X;

    m_bViewOrig = bOrig;
    m_bViewAlpha = bViewAlpha;
    m_lwSliceCur = lwSlice;
    m_lwMipCur = lwMip;
    m_CubeFaceCur = FaceType;

    if (bOrig)
        ptex = GetDocument()->PtexOrig();
    else
        ptex = GetDocument()->PtexNew();

    if (bIsVolumeMap)
    {
        ((LPDIRECT3DVOLUMETEXTURE8)ptex)->GetLevelDesc(m_lwMipCur, &vd);
        sd.Width = vd.Width;
        sd.Height = vd.Height;
    }
    else if (!bIsCubeMap)
    {
        ((LPDIRECT3DTEXTURE8)ptex)->GetLevelDesc(m_lwMipCur, &sd);
    }
    else
    {
        ((LPDIRECT3DCUBETEXTURE8)ptex)->GetLevelDesc(m_lwMipCur, &sd);
    }

    hr = pd3ddev->CreateTexture(sd.Width, sd.Height, 1,
         0 /* Usage */, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &m_ptexCur);
    if (FAILED(hr))
        return hr;

    m_rcSrc.SetRect(0, 0, sd.Width, sd.Height);
    m_rcDest.SetRect(0, 0, (INT)(sd.Width * m_fZoom), (INT)(sd.Height * m_fZoom));

    LPDIRECT3DSURFACE8 psurfSrc = NULL;
    LPDIRECT3DSURFACE8 psurfDest = NULL;

    hr = m_ptexCur->GetSurfaceLevel(0, &psurfDest);

    if (bIsVolumeMap)
    {
        LPDIRECT3DVOLUME8 pvolSrc;
        hr = ((LPDIRECT3DVOLUMETEXTURE8)ptex)->GetVolumeLevel(m_lwMipCur, &pvolSrc);
        hr = LoadSurfaceFromVolumeSlice(pvolSrc, m_lwSliceCur, psurfDest);
        ReleasePpo(&pvolSrc);
    }
    else if (!bIsCubeMap)
    {
        hr = ((LPDIRECT3DTEXTURE8)ptex)->GetSurfaceLevel(m_lwMipCur, &psurfSrc);
        hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
    }
    else
    {
        hr = ((LPDIRECT3DCUBETEXTURE8)ptex)->GetCubeMapSurface(FaceType, m_lwMipCur, &psurfSrc);
        hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
    }


    if (bViewAlpha)
    {
        // Move alpha channels into RGB (and set alpha to 0xff)
        D3DLOCKED_RECT lr;

        hr = psurfDest->LockRect(&lr, NULL, 0);

        DWORD xp;
        DWORD yp;
        DWORD* pdwRow = (DWORD*)lr.pBits;
        DWORD* pdw;
        DWORD dwAlpha;
        LONG dataBytesPerRow = 4 * sd.Width;

        for (yp = 0; yp < sd.Height; yp++)
        {
            pdw = pdwRow;
            for (xp = 0; xp < sd.Width; xp++)
            {
                dwAlpha = *pdw >> 24;
                *pdw = 0xff000000 | (dwAlpha << 16) | (dwAlpha << 8) | (dwAlpha);
                pdw++;
            }
            pdwRow += lr.Pitch / 4;
        }
        psurfDest->UnlockRect();
    }

    ReleasePpo(&psurfSrc);
    ReleasePpo(&psurfDest);

    return S_OK;
}


HRESULT CDxtexView::LoadSurfaceFromVolumeSlice(LPDIRECT3DVOLUME8 pVolume, UINT iSlice, LPDIRECT3DSURFACE8 psurf)
{
    HRESULT hr;
    D3DVOLUME_DESC vd;
    D3DLOCKED_BOX lb;
    D3DBOX box;
    RECT rc;

    pVolume->GetDesc(&vd);

    box.Left = 0;
    box.Right = vd.Width;
    box.Top = 0;
    box.Bottom = vd.Height;
    box.Front = iSlice;
    box.Back = iSlice + 1;

    rc.left = 0;
    rc.right = vd.Width;
    rc.top = 0;
    rc.bottom = vd.Height;

    hr = pVolume->LockBox(&lb, &box, 0);
    if (FAILED(hr))
        return hr;

    hr = D3DXLoadSurfaceFromMemory(psurf, NULL, NULL, lb.pBits, vd.Format, lb.RowPitch,
        NULL, &rc, D3DX_FILTER_TRIANGLE, 0);

    pVolume->UnlockBox();

    return hr;
}


void CDxtexView::OnViewNegX()
{
    BuildViewSurface(m_bViewOrig, D3DCUBEMAP_FACE_NEGATIVE_X, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    m_bTitleModsChanged = TRUE; // force title bar update
    RenderScene();
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewNegX(CCmdUI* pCmdUI)
{
    BOOL bEnable = GetDocument()->IsCubeMap();
    pCmdUI->Enable(bEnable);
    pCmdUI->SetCheck(m_CubeFaceCur == D3DCUBEMAP_FACE_NEGATIVE_X);
}


void CDxtexView::OnViewPosX()
{
    BuildViewSurface(m_bViewOrig, D3DCUBEMAP_FACE_POSITIVE_X, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    m_bTitleModsChanged = TRUE; // force title bar update
    RenderScene();
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewPosX(CCmdUI* pCmdUI)
{
    BOOL bEnable = GetDocument()->IsCubeMap();
    pCmdUI->Enable(bEnable);
    pCmdUI->SetCheck(m_CubeFaceCur == D3DCUBEMAP_FACE_POSITIVE_X);
}


void CDxtexView::OnViewNegY()
{
    BuildViewSurface(m_bViewOrig, D3DCUBEMAP_FACE_NEGATIVE_Y, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    m_bTitleModsChanged = TRUE; // force title bar update
    RenderScene();
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewNegY(CCmdUI* pCmdUI)
{
    BOOL bEnable = GetDocument()->IsCubeMap();
    pCmdUI->Enable(bEnable);
    pCmdUI->SetCheck(m_CubeFaceCur == D3DCUBEMAP_FACE_NEGATIVE_Y);
}


void CDxtexView::OnViewPosY()
{
    BuildViewSurface(m_bViewOrig, D3DCUBEMAP_FACE_POSITIVE_Y, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    m_bTitleModsChanged = TRUE; // force title bar update
    RenderScene();
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewPosY(CCmdUI* pCmdUI)
{
    BOOL bEnable = GetDocument()->IsCubeMap();
    pCmdUI->Enable(bEnable);
    pCmdUI->SetCheck(m_CubeFaceCur == D3DCUBEMAP_FACE_POSITIVE_Y);
}


void CDxtexView::OnViewNegZ()
{
    BuildViewSurface(m_bViewOrig, D3DCUBEMAP_FACE_NEGATIVE_Z, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    m_bTitleModsChanged = TRUE; // force title bar update
    RenderScene();
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewNegZ(CCmdUI* pCmdUI)
{
    BOOL bEnable = GetDocument()->IsCubeMap();
    pCmdUI->Enable(bEnable);
    pCmdUI->SetCheck(m_CubeFaceCur == D3DCUBEMAP_FACE_NEGATIVE_Z);
}


void CDxtexView::OnViewPosZ()
{
    BuildViewSurface(m_bViewOrig, D3DCUBEMAP_FACE_POSITIVE_Z, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    m_bTitleModsChanged = TRUE; // force title bar update
    RenderScene();
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewPosZ(CCmdUI* pCmdUI)
{
    BOOL bEnable = GetDocument()->IsCubeMap();
    pCmdUI->Enable(bEnable);
    pCmdUI->SetCheck(m_CubeFaceCur == D3DCUBEMAP_FACE_POSITIVE_Z);
}

void CDxtexView::OnFileOpenFace()
{
    GetDocument()->OpenCubeFace(m_CubeFaceCur);
}

void CDxtexView::OnUpdateFileOpenFace(CCmdUI* pCmdUI)
{
    BOOL bEnable = (m_CubeFaceCur != D3DCUBEMAP_FACE_FORCE_DWORD);
    pCmdUI->Enable(bEnable);
}

void CDxtexView::OnFileOpenAlphaFace()
{
    GetDocument()->OpenAlphaCubeFace(m_CubeFaceCur);
}

void CDxtexView::OnUpdateFileOpenAlphaFace(CCmdUI* pCmdUI)
{
    BOOL bEnable = (m_CubeFaceCur != D3DCUBEMAP_FACE_FORCE_DWORD);
    pCmdUI->Enable(bEnable);
}

void CDxtexView::OnViewHigherVolumeSlice()
{
    m_lwSliceCur++;
    BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    UpdateDevice();
    RenderScene();
    m_bTitleModsChanged = TRUE; // force title bar update
    Invalidate(); // force redraw of this view
}

void CDxtexView::OnUpdateViewHigherVolumeSlice(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(GetDocument()->IsVolumeMap() && m_lwSliceCur < (LONG)GetDocument()->DwDepthAt(m_lwMipCur) - 1);
}

void CDxtexView::OnViewLowerVolumeSlice()
{
    m_lwSliceCur--;
    BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    UpdateDevice();
    RenderScene();
    m_bTitleModsChanged = TRUE; // force title bar update
    Invalidate(); // force redraw of this view
}

void CDxtexView::OnUpdateViewLowerVolumeSlice(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(GetDocument()->IsVolumeMap() && m_lwSliceCur > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\DXTexview.h ===
// dxtexView.h : interface of the CDxtexView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_DXTXVIEW_H__712C53D1_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
#define AFX_DXTXVIEW_H__712C53D1_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CDxtexView : public CScrollView
{
protected: // create from serialization only
    CDxtexView();
    DECLARE_DYNCREATE(CDxtexView)
    CDxtexDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDxtexView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual void OnInitialUpdate();
    protected:
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CDxtexView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    BOOL TitleModsChanged(VOID) { return m_bTitleModsChanged; }
    VOID ClearTitleModsChanged(VOID) { m_bTitleModsChanged = FALSE; }
    CString GetStrTitleMods(VOID);
    VOID GetImageInfo(CString& strInfo);

// Generated message map functions
protected:
    //{{AFX_MSG(CDxtexView)
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnFileOpenSubsurface();
    afx_msg void OnFileOpenAlphaSubsurface();
    afx_msg void OnFileOpenFace();
    afx_msg void OnFileOpenAlphaFace();
    afx_msg void OnViewOriginal();
    afx_msg void OnViewCompressed();
    afx_msg void OnViewAlphaChannel();
    afx_msg void OnViewLargerMipLevel();
    afx_msg void OnViewSmallerMipLevel();
    afx_msg void OnViewZoomIn();
    afx_msg void OnViewZoomOut();
    afx_msg void OnViewChangeBackgroundColor();
    afx_msg void OnViewNegX();
    afx_msg void OnViewPosX();
    afx_msg void OnViewNegY();
    afx_msg void OnViewPosY();
    afx_msg void OnViewNegZ();
    afx_msg void OnViewPosZ();
    afx_msg void OnViewHigherVolumeSlice();
    afx_msg void OnViewLowerVolumeSlice();
    afx_msg void OnUpdateFileOpenSubsurface(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFileOpenAlphaSubsurface(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFileOpenFace(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFileOpenAlphaFace(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewOriginal(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewCompressed(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewAlphaChannel(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewLargerMipLevel(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewSmallerMipLevel(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewZoomIn(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewZoomOut(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewNegX(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewPosX(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewNegY(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewPosY(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewNegZ(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewPosZ(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewHigherVolumeSlice(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewLowerVolumeSlice(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    HRESULT UpdateDevice(VOID);
    HRESULT RenderScene(VOID);
    CDxtexApp* PDxtexApp(VOID) { return (CDxtexApp*)AfxGetApp(); }
    HRESULT BuildViewSurface(BOOL bOrig, D3DCUBEMAP_FACES FaceType, LONG lwSlice, LONG lwMip, BOOL bViewAlpha);
    HRESULT LoadSurfaceFromVolumeSlice(LPDIRECT3DVOLUME8 pVolume, UINT iSlice, LPDIRECT3DSURFACE8 psurf);

    DWORD NumBytesInSurfaces(D3DCUBEMAP_FACES FaceType, LPDIRECT3DBASETEXTURE8 ptex);
    HRESULT CreateVertexBuffer(VOID);
    CString FormatName(D3DFORMAT fmt);

    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    LPDIRECT3DTEXTURE8 m_ptexCur; // Currently-viewed texture surface
    LPDIRECT3DSWAPCHAIN8 m_pSwapChain;
    CRect m_rcSrc; // Size of m_pddsCur and m_pddsBack
    CRect m_rcDest; // m_rcDest scaled by m_fZoom
    FLOAT m_fZoom; // Zoom factor
    BOOL m_bViewOrig; // View "original" vs. "new" surface
    BOOL m_bViewAlpha; // View alpha channel alone vs. normal image
    BOOL m_bTitleModsChanged; // Whether title bar text modifiers need to be updated
    LONG m_lwMipCur; // Currently-viewed mip.  0 = top, 1 = next one down, etc.
    D3DCUBEMAP_FACES m_CubeFaceCur; // D3DCUBEMAP_FACE_FORCE_DWORD = no cube map, or D3DCUBEMAP_FACE_POSITIVE_X, etc.
    LONG m_lwSliceCur; // For volume maps
    DWORD m_dwClearColor; // Background color that will show through where alpha is non-opaque
};

#ifndef _DEBUG  // debug version in dxtexView.cpp
inline CDxtexDoc* CDxtexView::GetDocument()
   { return (CDxtexDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DXTXVIEW_H__712C53D1_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\DXTexdoc.h ===
// dxtexDoc.h : interface of the CDxtexDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_DXTXDOC_H__712C53CF_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
#define AFX_DXtxDOC_H__712C53CF_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CDxtexDoc : public CDocument
{
protected: // create from serialization only
    CDxtexDoc();
    DECLARE_DYNCREATE(CDxtexDoc)

public:
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDxtexDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
    //}}AFX_VIRTUAL

// Implementation
public:
    HRESULT LoadAlphaBmp(CString& strPath);
    VOID GenerateMipMaps(VOID);
    HRESULT Compress(D3DFORMAT fmt, BOOL bSwitchView);
    DWORD NumMips(VOID);
    LPDIRECT3DBASETEXTURE8 PtexOrig(VOID) { return m_ptexOrig; }
    LPDIRECT3DBASETEXTURE8 PtexNew(VOID) { return m_ptexNew; }
    DWORD DwWidth(VOID) { return m_dwWidth; }
    DWORD DwHeight(VOID) { return m_dwHeight; }
    DWORD DwDepth(VOID) { return m_dwDepth; }
    DWORD DwDepthAt(LONG lwMip);
    BOOL TitleModsChanged(VOID) { return m_bTitleModsChanged; }
    VOID ClearTitleModsChanged(VOID) { m_bTitleModsChanged = FALSE; }
    virtual ~CDxtexDoc();
    void OpenSubsurface(D3DCUBEMAP_FACES FaceType, LONG lwMip, LONG lwSlice);
    void OpenAlphaSubsurface(D3DCUBEMAP_FACES FaceType, LONG lwMip, LONG lwSlice);
    void OpenCubeFace(D3DCUBEMAP_FACES FaceType);
    void OpenAlphaCubeFace(D3DCUBEMAP_FACES FaceType);
    BOOL IsCubeMap(VOID) { return (m_dwCubeMapFlags > 0); }
    BOOL IsVolumeMap(VOID) { return (m_dwDepth > 0); }
    BOOL IsXbox(VOID) { return (m_bXbox); }
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
    //{{AFX_MSG(CDxtexDoc)
    afx_msg void OnFileOpenAlpha();
    afx_msg void OnGenerateMipMaps();
    afx_msg void OnFormatDxt1();
    afx_msg void OnFormatDxt2();
    afx_msg void OnFormatDxt3();
    afx_msg void OnFormatDxt4();
    afx_msg void OnFormatDxt5();
    afx_msg void OnFormatChangeCubeMapFaces();
    afx_msg void OnUpdateFileOpenAlpha(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFormatGenerateMipmaps(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFormatChangeCubeMapFaces(CCmdUI* pCmdUI);
    afx_msg void OnFormatMakeIntoVolumeMap();
    afx_msg void OnUpdateFormatMakeIntoVolumeMap(CCmdUI* pCmdUI);
    afx_msg void OnFormatChangeSurfaceFmt();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    LPDIRECT3DBASETEXTURE8 m_ptexOrig;
    LPDIRECT3DBASETEXTURE8 m_ptexNew;
    DWORD m_dwWidth;
    DWORD m_dwHeight;
    DWORD m_dwDepth; // For volume textures
    DWORD m_numMips;
    DWORD m_dwCubeMapFlags;
    BOOL m_bTitleModsChanged;
    BOOL m_bXbox;

    HRESULT LoadBmp(CString& strPath);
    CDxtexApp* PDxtexApp(VOID) { return (CDxtexApp*)AfxGetApp(); }
    HRESULT LoadAlphaIntoSurface(CString& strPath, LPDIRECT3DSURFACE8 psurf);
    HRESULT LoadVolumeSliceFromSurface(LPDIRECT3DVOLUME8 pVolume, UINT iSlice, LPDIRECT3DSURFACE8 pSurf);
    HRESULT LoadSurfaceFromVolumeSlice(LPDIRECT3DVOLUME8 pVolume, UINT iSlice, LPDIRECT3DSURFACE8 psurf);
    HRESULT BltAllLevels(D3DCUBEMAP_FACES FaceType, LPDIRECT3DBASETEXTURE8 ptexSrc,
        LPDIRECT3DBASETEXTURE8 ptexDest);
    BOOL PromptForBmp(CString* pstrPath);
    HRESULT SaveDDS(LPDIRECT3DBASETEXTURE8 ptex, CArchive& ar);
    HRESULT SaveAllMipSurfaces(LPDIRECT3DBASETEXTURE8 ptex, D3DCUBEMAP_FACES FaceType, CArchive& ar);
    HRESULT SaveAllVolumeSurfaces(LPDIRECT3DVOLUMETEXTURE8 pvoltex, CArchive& ar);
    HRESULT LoadDDS(LPDIRECT3DBASETEXTURE8* pptex, CArchive& ar);
    HRESULT LoadAllMipSurfaces(LPDIRECT3DBASETEXTURE8 ptex, D3DCUBEMAP_FACES FaceType, CArchive& ar);
    HRESULT LoadAllVolumeSurfaces(LPDIRECT3DVOLUMETEXTURE8 pvoltex, CArchive& ar);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DXTXDOC_H__712C53CF_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\MainFrm.Cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "dxtex.h"
#include "MainFrm.h"
#include "DxtexDoc.h"
#include "DxtexView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
    ON_UPDATE_COMMAND_UI(ID_INDICATOR_IMAGEINFO, OnUpdateImageInfo)
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_IMAGEINFO,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

// Note: I changed the default toolbar creation code so we can still compile with VC5:
//  if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
//      | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
//      !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    m_wndStatusBar.SetPaneInfo(1, ID_INDICATOR_IMAGEINFO, SBPS_NORMAL, 220);

    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
void CMainFrame::OnUpdateImageInfo(CCmdUI *pCmdUI)
{
    CString strInfo;

    // Get the active MDI child window.
    CMDIChildWnd *pChild = (CMDIChildWnd *)GetActiveFrame();

    if (pChild != NULL && pChild != (CMDIChildWnd *)this)
    {
        // Get the active view attached to the active MDI child window.
        CDxtexView* pView = (CDxtexView*)pChild->GetActiveView();
        pView->GetImageInfo(strInfo);
        pCmdUI->Enable();
        pCmdUI->SetText(strInfo);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\FPConv\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\MainFrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__712C53CB_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
#define AFX_MAINFRM_H__712C53CB_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CMDIFrameWnd
{
    DECLARE_DYNAMIC(CMainFrame)
public:
    CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnUpdateImageInfo(CCmdUI *pCmdUI);
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__712C53CB_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\StdAfx.Cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  dxtx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dxtex.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_DXTXTYPE                    129
#define IDD_CUBEMAP                     131
#define IDD_VOLUMEMAP                   132
#define IDD_CHANGEFORMAT                133
#define IDD_NEWTEXTURE                  134
#define IDC_VERSION                     1000
#define IDC_POSX                        1001
#define IDC_NEGX                        1002
#define IDC_POSY                        1003
#define IDC_NEGY                        1004
#define IDC_POSZ                        1005
#define IDC_NEGZ                        1006
#define IDC_RADIO2                      1010
#define IDC_DXT1                        1010
#define IDC_RADIO4                      1011
#define IDC_DXT2                        1011
#define IDC_RADIO8                      1012
#define IDC_DXT3                        1012
#define IDC_RADIO16                     1013
#define IDC_DXT4                        1013
#define IDC_RADIO32                     1014
#define IDC_DXT5                        1014
#define IDC_RADIO64                     1015
#define IDC_A8R8G8B8                    1015
#define IDC_RADIO128                    1016
#define IDC_A1R5G5B5                    1016
#define IDC_RADIO256                    1017
#define IDC_RADIO512                    1018
#define IDC_RADIO1024                   1019
#define IDC_A4R4G4B4                    1022
#define IDC_R8G8B8                      1023
#define IDC_R5G6B5                      1024
#define IDC_FMTDESC                     1025
#define IDC_TEXTURE                     1026
#define IDC_CUBEMAP                     1027
#define IDC_VOLUMETEXTURE               1028
#define IDC_WIDTH                       1029
#define IDC_HEIGHT                      1030
#define IDC_DEPTH                       1031
#define IDC_MIPCOUNT                    1032
#define IDC_VOLUMEDEPTHLABEL            1033
#define IDC_Xbox                        1039
#define ID_FORMAT_GENERATEMIPMAPS       32774
#define ID_FORMAT_CHANGEIMAGEFORMAT     32775
#define ID_FORMAT_DXT1                  32779
#define ID_VIEW_ORIGINAL                32780
#define ID_VIEW_COMPRESSED              32781
#define ID_VIEW_SMALLERMIPLEVEL         32782
#define ID_VIEW_LARGERMIPLEVEL          32783
#define ID_VIEW_ALPHACHANNEL            32784
#define ID_VIEW_ZOOMIN                  32785
#define ID_VIEW_ZOOMOUT                 32786
#define ID_FORMAT_DXT2                  32787
#define ID_FORMAT_DXT3                  32788
#define ID_FORMAT_DXT4                  32789
#define ID_FORMAT_DXT5                  32790
#define ID_VIEW_CHANGEBACKGROUNDCOLOR   32791
#define ID_FILE_OPENALPHA               32792
#define ID_FILE_OPENSUBSURFACE          32794
#define ID_FILE_OPENALPHASUBSURFACE     32795
#define ID_FORMAT_CHANGECUBEMAPFACES    32796
#define ID_VIEW_POSX                    32797
#define ID_VIEW_NEGX                    32798
#define ID_VIEW_POSY                    32799
#define ID_VIEW_NEGY                    32800
#define ID_VIEW_POSZ                    32801
#define ID_VIEW_NEGZ                    32802
#define ID_FILE_OPENFACE                32803
#define ID_FILE_OPENALPHAFACE           32804
#define ID_FORMAT_MAKEINTOVOLUMEMAP     32806
#define ID_VIEW_HIGHERVOLUMESLICE       32807
#define ID_VIEW_LOWERVOLUMESLICE        32808
#define ID_FORMAT_CHANGESURFACEFMT      32811
#define ID_INDICATOR_IMAGEINFO          61216
#define ID_ERROR_ODDDIMENSIONS          61217
#define ID_ERROR_NOTPOW2                61218
#define ID_ERROR_WRONGDIMENSIONS        61219
#define ID_ERROR_GENERATEALPHAFAILED    61220
#define ID_ERROR_PREMULTALPHA           61221
#define ID_ERROR_PREMULTTODXT1          61222
#define ID_ERROR_CANTCREATEDEVICE       61223
#define IDS_FMTDESC_A8R8G8B8            61224
#define IDS_FMTDESC_A1R5G5B5            61225
#define IDS_FMTDESC_A4R4G4B4            61226
#define IDS_FMTDESC_R8G8B8              61227
#define IDS_FMTDESC_R5G6B5              61228
#define IDS_FMTDESC_DXT1                61229
#define IDS_FMTDESC_DXT2                61230
#define IDS_FMTDESC_DXT3                61231
#define IDS_FMTDESC_DXT4                61232
#define IDS_FMTDESC_DXT5                61233
#define ID_ERROR_CANTCREATETEXTURE      61239
#define ID_ERROR_D3DCREATEFAILED        61240

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32812
#define _APS_NEXT_CONTROL_VALUE         1044
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\PerformanceCounters\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\PerformanceCounters\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\PerformanceCounters\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\PerformanceCounters\dummy.cpp ===
#ifdef DEVKIT
#include "performancecounters.cpp"
#else
void __cdecl main()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\DXTex\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__712C53C9_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
#define AFX_STDAFX_H__712C53C9_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <winver.h>
#include <basetsd.h>
#include <d3d8.h>
#include <d3dx8.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.



#endif // !defined(AFX_STDAFX_H__712C53C9_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\FPConv\FPConv.cpp ===
//-----------------------------------------------------------------------------
// File: FPConv.cpp
//
// Desc: Code to time floating point conversion routines
//
// Hist: 4.23.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include <stdlib.h>

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
};

#define NUM_HELP_CALLOUTS 1

#define NUM_ENTRIES 100000L

typedef FLOAT (*CONVERSIONPROC)(FLOAT * pf, LONG * pl, LONG n);

typedef struct
{
    WCHAR * szDescription;
    CONVERSIONPROC pfn;
} CONV;

FLOAT TimeFToL( FLOAT * pf, LONG * pl, LONG n );
FLOAT TimeSSE1( FLOAT * pf, LONG * pl, LONG n );
FLOAT TimeSSE2( FLOAT * pf, LONG * pl, LONG n );
FLOAT Timefistp1( FLOAT * pf, LONG * pl, LONG n );
FLOAT Timefistp2( FLOAT * pf, LONG * pl, LONG n );
FLOAT TimeNothing( FLOAT * pf, LONG * pl, LONG n );
CONV g_ac[] = 
{
    { L"ftol()",            TimeFToL },
    { L"cvttss2si",         TimeSSE1 },
    { L"fstp; cvttss2si",   TimeSSE2 },
    { L"fistp result",      Timefistp1 },
    { L"fistp esp",         Timefistp2 },
    { L"Nothing",           TimeNothing },
};
#define NUM_METHODS 6

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    // Data to process
    FLOAT *     m_pfFloats;
    LONG *      m_plLongs;

    // Timing 
    LARGE_INTEGER m_liFreq;
    FLOAT       m_fTimes[NUM_METHODS];

    BOOL        m_bDrawHelp;
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;    

    m_pfFloats = new FLOAT[ NUM_ENTRIES ];
    m_plLongs  = new LONG[ NUM_ENTRIES ];
    QueryPerformanceFrequency( &m_liFreq );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    for( int i = 0; i < NUM_METHODS; i++ )
    {
        for( int j = 0; j < NUM_ENTRIES; j++ )
        {
            m_pfFloats[ j ] = float(rand()) / float(RAND_MAX);
        }
        ZeroMemory( m_plLongs, NUM_ENTRIES * sizeof( LONG ) );

        m_fTimes[ i ] = g_ac[ i ].pfn( m_pfFloats, m_plLongs, NUM_ENTRIES );
        // m_fTimes[ i ] = i;
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR sz[100];
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"FPConv" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        swprintf( sz, L"%d entries", NUM_ENTRIES );
        m_Font.DrawText( 64, 75, 0xffffff00, sz );

        for( int i = 0; i < NUM_METHODS; i++ )
        {
            swprintf( sz, L"%s: %0.8f", g_ac[ i ].szDescription, m_fTimes[ i ] );
            m_Font.DrawText( 64, FLOAT(75 + ( i + 1 ) * 25), 0xffffffff, sz );
        }

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}

#define BEGIN_TIMING(XX) \
int i = n - 1;\
LARGE_INTEGER liFreq, liBegin, liEnd;\
QueryPerformanceFrequency( &liFreq );\
QueryPerformanceCounter( &liBegin );\
for( ; i >= 0; i-- ) \
{


#define END_TIMING(XX) \
} \
QueryPerformanceCounter( &liEnd );\
return float( liEnd.QuadPart - liBegin.QuadPart ) / float(liFreq.QuadPart);

__forceinline LONG FTOL( FLOAT f )
{
    return (LONG)f;
}

FLOAT TimeFToL( FLOAT * pf, LONG * pl, LONG n )
{
    BEGIN_TIMING(FTOL);
    pl[i] = FTOL( pf[i] );
    END_TIMING(FTOL);
}

__forceinline LONG sse1( FLOAT f )
{
    _asm cvttss2si eax, f
}

FLOAT TimeSSE1( FLOAT * pf, LONG * pl, LONG n )
{
    BEGIN_TIMING(SSE1);
    pl[i] = sse1( pf[i] );
    END_TIMING(SSE1);
}

__forceinline LONG sse2( FLOAT f )
{
    _asm {
        cvttss2si eax, f;
    }
}

FLOAT TimeSSE2( FLOAT * pf, LONG * pl, LONG n )
{
    BEGIN_TIMING(SSE2);
    pl[i] = sse2( pf[i] );
    END_TIMING(SSE2);
}

__forceinline LONG fistp1( FLOAT f )
{
    _asm {
        fld f
        fwait
        sub esp, 8;
        fistp [esp];
        mov eax, [esp];
        mov edx, [esp+4];
        add esp, 8;
    }
}

FLOAT Timefistp1( FLOAT * pf, LONG * pl, LONG n )
{
    WORD oldcw, newcw;

    _asm {
        fstcw   [oldcw];
        fwait;
        mov     ax, [oldcw]             ; round mode saved
        or      ah, 0ch                 ; set chop rounding mode
        mov     [newcw], ax             ; back to memory
        fldcw   [newcw]                 ; reset rounding
    }

    BEGIN_TIMING(FISTP1);
    pl[i] = fistp1( pf[i] );
    END_TIMING(FISTP1);
    _asm {
        fldcw [oldcw];
    }
}

__forceinline LONG fistp2( FLOAT f )
{
    DWORD result[2];

    _asm
    {
        fld f
        wait;
        fistp qword ptr [result];
    }

    return result[0];
}

FLOAT Timefistp2( FLOAT * pf, LONG * pl, LONG n )
{
    WORD oldcw, newcw;

    _asm {
        fstcw   [oldcw];
        fwait;
        mov     ax, [oldcw]             ; round mode saved
        or      ah, 0ch                 ; set chop rounding mode
        mov     [newcw], ax             ; back to memory
        fldcw   [newcw]                 ; reset rounding
    }

    BEGIN_TIMING(FISTP1);
    pl[i] = fistp2( pf[i] );
    END_TIMING(FISTP1);
    _asm {
        fldcw [oldcw];
    }
}

FLOAT TimeNothing( FLOAT * pf, LONG * pl, LONG n )
{
    BEGIN_TIMING(NOTHING);
    _asm nop
    END_TIMING(NOTHING);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\PerformanceCounters\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\PerformanceCounters\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\sectionload\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\sectionload\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\sectionload\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\sectionload\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Wings_OFFSET 0UL
#define resource_BiHull_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\sectionload\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\sectionload\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\sectionload\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Wings_OFFSET 0UL
#define resource_BiHull_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Auth\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Auth\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\sectionload\sectionload.cpp ===
//-----------------------------------------------------------------------------
// File: SectionLoad.cpp
//
// Desc: Illustrates loading and unloading of sections.
//
// Note: This was a somewhat difficult sample to write. Especially because
//       samples are by definition very small bits of code meant only to 
//       illustrate one particular part of the system.
//
//       Section loading and unloading is something that will be used
//       primarily in large projects where memory restrictions prevent you
//       from having all code and data loaded simultaneously. Furthermore,
//       flagging a section as NOPRELOAD only works if that section cannot
//       be squeezed into a preloaded section. Thus, when I tried to write
//       a couple of small routines that were loaded and unloaded, they were
//       squeezed in to the end of a preloaded section and the code would
//       always execute (as they were always in memory).
//
//       As a result, this sample shows that section loading and unloading
//       work properly by doing the following: If the data section is 
//       loaded, write access to the data area will work just fine and
//       the sample shows the time of the last successful access.
//       If the data section is not loaded, accessing the data area will 
//       generate an exception.
//
//       This is not the best behaviour for a sample, I know. But it was
//       the only way to verify that unloaded sections did not work. Note
//       that you should only run this in DEBUG mode so you can see what
//       is going on!
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>

#include "resource.h"

//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Wings.bmp", resource_Wings_OFFSET },
    { "BiHull.bmp", resource_BiHull_OFFSET },
    { NULL, 0 },
};

//-----------------------------------------------------------------------------
// Help screen definitions
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] =
{
    { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, L"Display\nhelp" },
    { XBHELP_A_BUTTON, XBHELP_PLACEMENT_1, L"Toggle DataSeg\nLoaded" },
    { XBHELP_B_BUTTON, XBHELP_PLACEMENT_1, L"Attempt DataSeg\nAccess" },
};
#define NUM_HELP_CALLOUTS 3


//-----------------------------------------------------------------------------
// put some data in another section
// note that uninitialize sections will always be flagged as preload
//-----------------------------------------------------------------------------
#define BUFSIZE (32*1024)
#pragma data_seg("dataseg1")
BYTE g_Seg1Data[BUFSIZE] = {0};
BYTE g_Seg1Data1[BUFSIZE] = {0};
BYTE g_Seg1Data2[BUFSIZE] = {0};
#pragma data_seg()


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont m_Font;
    CXBHelp m_Help;
    BOOL m_bDrawHelp;

    CXBPackedResource  m_xprResource;
	CXBMesh *m_pPlaneMesh;

	BOOL m_bDataSegLoaded;
	float m_fDataSegAccessTime;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
	// initialize our stuff
    m_bDrawHelp  = FALSE;

	m_bDataSegLoaded = FALSE;
	m_fDataSegAccessTime = 0.0f;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    D3DXMATRIX matProj, matView;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the help system
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set projection transform
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 0.1f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

	// Set view position
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 60.0f);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

	// initialize the airplanes
	m_pPlaneMesh = new CXBMesh;
	m_pPlaneMesh ->Create(g_pd3dDevice, "models\\airplane.xbg", &m_xprResource );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	D3DXMATRIX matWorld, m;
	static float fYRot = 0.0f;
	float x, z;
	VOID *loc;
	DWORD i, d;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;
	if(m_bDrawHelp)
		return S_OK;

    // Toggle dataseg load
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A])
	{
		// if not loaded, do the load
		if(!m_bDataSegLoaded)
		{
			loc = XLoadSection("dataseg1");
			if(loc!=NULL)
				m_bDataSegLoaded = TRUE;
		}
		else // otherwise, free it up
		{
			XFreeSection("dataseg1");
			m_bDataSegLoaded = FALSE;
		}
	}

	// attempt dataseg read
	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B])
	{
		for(i=0; i<BUFSIZE; i++)
		{
			d = g_Seg1Data[i];
			d = g_Seg1Data1[i];
			d = g_Seg1Data2[i];
		}

		m_fDataSegAccessTime = m_fTime;
	}


	// move plane
	fYRot += 1.57f*m_fElapsedTime;
	D3DXMatrixRotationY(&matWorld, fYRot);
	x = 20.0f * (float)cos(fYRot);
	z = -20.0f * (float)sin(fYRot);
	D3DXMatrixTranslation(&m, x, 0.0f, z);
	D3DXMatrixMultiply(&matWorld, &matWorld, &m);
    g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x00400000, 1.0f, 0L );

    // Restore state that text clobbers
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );

	m_pPlaneMesh->Render(0);

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
		m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"SectionLoad" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.DrawText( 64, 70, 0xffffff00, L"Press A to toggle DataSeg loaded" );
        m_Font.DrawText( 64, 90, 0xffffff00, L"Press B to access DataSeg" );

		if(m_bDataSegLoaded)
	        m_Font.DrawText( 64, 110, 0xff00ff00, L"DataSeg Loaded" );
		else
	        m_Font.DrawText( 64, 110, 0xffff0000, L"DataSeg NOT Loaded" );

		if(m_fDataSegAccessTime!=0.0f)
		{
			WCHAR s[80];
			swprintf(s, L"Last successful DataSeg access time: %3.2f, %3.2f", m_fDataSegAccessTime, m_fTime);
			m_Font.DrawText( 64, 130, 0xffffff00, s);
		}

		m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\misc\PerformanceCounters\PerformanceCounters.cpp ===
//-----------------------------------------------------------------------------
// File: PerformanceCounters.cpp
//
// Desc: Demonstrates how to create and query Xbox performance counters
//
// Hist: 3.20.01 - New for April XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include <xbdm.h>


//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Next counter" },
};

#define NUM_HELP_CALLOUTS 2




const CHAR* g_strPerSec   = "Second";
const CHAR* g_strPerMSec  = "Millisecond";
const CHAR* g_strPerFrame = "Frame";
const CHAR* g_strPerTick  = "Tick";

LARGE_INTEGER g_liXButtonPresses = {0};
LARGE_INTEGER g_liYButtonValue   = {0};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Font and help
    CXBFont           m_Font;
    CXBHelp           m_Help;

    BOOL              m_bDrawHelp;

    DM_COUNTDATA      m_dmCounterData;   // Counter data
    DM_COUNTINFO      m_dmCounterInfo;   // Info on current counter
    PDM_WALK_COUNTERS m_pdmWalkCounters; // For walking counters
    HANDLE            m_hCounter;        // Handle to current counter
    HRESULT           m_hrQuery;         // HRESULT of query

    const CHAR* UnitFromEnum( DWORD dwType );

    // Function for synchronous app-defined counter
    static HRESULT __stdcall GetXButtonPresses( PLARGE_INTEGER pli, PLARGE_INTEGER pli2 );

public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}


//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp       = FALSE;
    m_pdmWalkCounters = NULL;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the help system
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Enable GPU Performance counters so we can read them.
    DmEnableGPUCounter( TRUE );

    // Set us up for the first performance counter
    if( DmWalkPerformanceCounters( &m_pdmWalkCounters, &m_dmCounterInfo ) != XBDM_NOERR )
        return E_FAIL;
    if( FAILED( DmOpenPerformanceCounter( m_dmCounterInfo.Name, &m_hCounter ) ) )
        return E_FAIL;
    ZeroMemory( &m_dmCounterData, sizeof(DM_COUNTDATA) );
    
    DmRegisterPerformanceCounter( "X Button",
                                  DMCOUNT_EVENT | DMCOUNT_FREQ100MS | DMCOUNT_SYNC,
                                  GetXButtonPresses );
    DmRegisterPerformanceCounter( "Y Button",
                                  DMCOUNT_VALUE | DMCOUNT_ASYNC64,
                                  &g_liYButtonValue );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Handle X button
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
        ++g_liXButtonPresses.QuadPart;

    // Handle Y button
    g_liYButtonValue.QuadPart = m_DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_Y ];

    // Handle A button
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        if( DmWalkPerformanceCounters( &m_pdmWalkCounters, &m_dmCounterInfo ) == XBDM_ENDOFLIST )
        {
            // If we hit the end, restart from the beginning
            m_pdmWalkCounters = NULL;
            DmWalkPerformanceCounters( &m_pdmWalkCounters, &m_dmCounterInfo );
        }

        if( FAILED( DmOpenPerformanceCounter( m_dmCounterInfo.Name, &m_hCounter ) ) )
            return E_FAIL;
        ZeroMemory( &m_dmCounterData, sizeof( DM_COUNTDATA ) );
    }

    // Set up our query type
    DWORD dwQuery = m_dmCounterInfo.Type & DMCOUNT_COUNTTYPE;
    if( dwQuery == DMCOUNT_EVENT )
    {
        dwQuery |= ( m_dmCounterInfo.Type & DMCOUNT_COUNTSUBTYPE ) | DMCOUNT_PERSEC;
    }
    else if( dwQuery == DMCOUNT_VALUE )
    {
        dwQuery |= 0;
    }
    else if( dwQuery == DMCOUNT_PRATIO )
    {
        dwQuery |= 0;
    }

    m_hrQuery = DmQueryPerformanceCounterHandle( m_hCounter, dwQuery, &m_dmCounterData );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    WCHAR strTemp[512];

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();

        m_Font.DrawText(  64,  50, 0xffffffff, L"PerformanceCounters" );
        m_Font.DrawText( 450,  50, 0xffffff00, m_strFrameRate );
        
        m_Font.DrawText(  64, 100, 0xffffffff, L"Event counter:" );
        swprintf( strTemp,   L"\"%S\"", m_dmCounterInfo.Name );
        m_Font.DrawText( 100, 125, 0xffffff00, strTemp );

        // Build up a string to display, based on the 
        // counter type
        if( FAILED( m_hrQuery ) )
        {
            m_Font.DrawText(  64, 175, 0xffffffff, L"Query failed with:" );
            swprintf( strTemp, L"HRESULT 0x%x", m_hrQuery );
            m_Font.DrawText( 100, 200, 0xffffff00, strTemp );
        }
        else
        {
            switch( m_dmCounterInfo.Type & DMCOUNT_COUNTTYPE )
            {
                case DMCOUNT_EVENT:
                    if( m_dmCounterData.CountType & DMCOUNT_COUNTSUBTYPE )
                    {
                        m_Font.DrawText(  64, 175, 0xffffffff, L"Count:" );
                        swprintf( strTemp, L"%0.2f per %S", (float)m_dmCounterData.CountValue.QuadPart / (float)m_dmCounterData.RateValue.QuadPart,
                                           UnitFromEnum( m_dmCounterData.CountType ) );
                        m_Font.DrawText( 100, 200, 0xffffff00, strTemp );
                    }
                    else
                    {
                        m_Font.DrawText(  64, 175, 0xffffffff, L"Count:" );
                        swprintf( strTemp, L"%I64d", m_dmCounterData.CountValue.QuadPart );
                        m_Font.DrawText( 100, 200, 0xffffff00, strTemp );
                    }
                    break;

                case DMCOUNT_VALUE:
                    m_Font.DrawText(  64, 175, 0xffffffff, L"Value:" );
                    swprintf( strTemp, L"%I64d", m_dmCounterData.CountValue.QuadPart );
                    m_Font.DrawText( 100, 200, 0xffffff00, strTemp );
                    break;
            
                case DMCOUNT_PRATIO:
                    m_Font.DrawText(  64, 175, 0xffffffff, L"Ratio:" );
                    swprintf( strTemp, L"%0.2f%%", (float)m_dmCounterData.CountValue.LowPart / (float)m_dmCounterData.RateValue.LowPart * 100.0f );
                    m_Font.DrawText( 100, 200, 0xffffff00, strTemp );
                    break;

                default:
                    m_Font.DrawText(  64, 175, 0xffffffff, L"Could not query counter" );
                    break;
            }
        }

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: UnitFromEnum()
// Desc: Returns a string representing the unit in the counter type
//-----------------------------------------------------------------------------
const CHAR* CXBoxSample::UnitFromEnum( DWORD dwType )
{
    switch( dwType & DMCOUNT_COUNTSUBTYPE )
    {
        case DMCOUNT_PERSEC:
            return g_strPerSec;
        
        case DMCOUNT_PERMSEC:
            return g_strPerMSec;
        
        case DMCOUNT_PERFRAME:
            return g_strPerFrame;

        case DMCOUNT_PERTICK:
            return g_strPerTick;
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: GetXButtonPresses
// Desc: Returns the number of times the X Button has been pressed
//-----------------------------------------------------------------------------
HRESULT __stdcall CXBoxSample::GetXButtonPresses( LARGE_INTEGER* pli, 
                                                  LARGE_INTEGER* pli2 )
{
    (*pli) = g_liXButtonPresses;
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Auth\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Auth\Common.h ===
//-----------------------------------------------------------------------------
// File: Common.h
//
// Desc: Auth global header
//
// Hist: 10.12.01 - New for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef AUTH_COMMON_H
#define AUTH_COMMON_H

#include "xtl.h"
#include "xonline.h"
#include <vector>




//-----------------------------------------------------------------------------
// Typedefs
//-----------------------------------------------------------------------------
typedef std::vector< XONLINE_SERVICE_INFO > ServiceInfoList;




#endif // AUTH_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Auth\Auth.cpp ===
//-----------------------------------------------------------------------------
// File: Auth.cpp
//
// Desc: Shows Xbox online authentication protocols.
//       Includes account creation, PIN entry, validation and logon.
//
// Hist: 08.08.01 - New for Aug M1 release 
//       10.12.01 - Updated for Nov release
//       01.21.02 - Updated for Feb release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Auth.h"
#include "XBMemUnit.h"
#include "XBVoice.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
: 
CXBApplication(),
m_UI( m_strFrameRate )
{
    m_State       = STATE_SELECT_ACCOUNT;
    m_NextState   = STATE_SELECT_ACCOUNT;
    m_dwCurrItem  = 0;
    m_dwCurrUser  = 0;
    m_dwUserIndex = 0;
    
    // Add whatever services are appropriate for your title, but no
    // more. Each service requires additional authentication time
    // and network traffic.
    m_pServices[0] = XONLINE_MATCHMAKING_SERVICE;
    m_pServices[1] = XONLINE_BILLING_OFFERING_SERVICE;
    
    *m_strUser = 0;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Initialize game UI
    if( FAILED( m_UI.Initialize() ) )
        return E_FAIL;
    
    // Initialize the network stack
    if( FAILED( XBNet_OnlineInit( 0 ) ) )
        return E_FAIL;
    
    // Get information on all accounts for this Xbox
    if( FAILED( XBOnline_GetUserList( m_UserList ) ) )
        return E_FAIL;
    
    // If no accounts, then player needs to create an account.
    // For development purposes, accounts are created using the OnlineSetup
    // tool in the XDK Launcher. For retail Xbox consoles, accounts are
    // created in the Xbox Dashboard.
    if( m_UserList.size() == 0 )
        m_State = STATE_CREATE_ACCOUNT;
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    if( !m_NetLink.IsActive() )
    {
        m_UI.SetErrorStr( L"This Xbox has lost its online connection" );
        m_State = STATE_ERROR;
        m_NextState = STATE_SELECT_ACCOUNT;
    }
    
    Event ev = GetEvent();
    
    switch( m_State )
    {
    case STATE_CREATE_ACCOUNT:  UpdateStateCreateAccount( ev ); break;
    case STATE_SELECT_ACCOUNT:  UpdateStateSelectAccount( ev ); break;
    case STATE_GET_PIN:         UpdateStateGetPin( ev );        break;
    case STATE_LOGGING_ON:      UpdateStateLoggingOn( ev );     break;
    case STATE_SUCCESS:         UpdateStateSuccess( ev );       break;
    case STATE_ERROR:           UpdateStateError( ev );         break;
    default:                    assert( FALSE );                break;
    }
    
    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
        0x000A0A6A, 1.0f, 0L );
    
    switch( m_State )
    {
    case STATE_CREATE_ACCOUNT:
        m_UI.RenderCreateAccount( TRUE );
        break;
    case STATE_SELECT_ACCOUNT:
        m_UI.RenderSelectAccount( m_dwCurrItem, m_UserList );
        break;
    case STATE_GET_PIN:
        m_UI.RenderGetPin( m_PinEntry, m_strUser );
        break;
    case STATE_LOGGING_ON:
        m_UI.RenderLoggingOn();
        break;
    case STATE_SUCCESS:
        m_UI.RenderSuccess( m_ServiceInfoList );
        break;
    case STATE_ERROR:
        m_UI.RenderError();
        break;
    default:
        assert( FALSE );
        break;
    }
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetEvent()
// Desc: Return the state of the controller
//-----------------------------------------------------------------------------
CXBoxSample::Event CXBoxSample::GetEvent() const
{
    // "A" or "Start"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] ||
        m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        return EV_BUTTON_A;
    }
    
    // "B"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
        return EV_BUTTON_B;
    
    // "Back"
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        return EV_BUTTON_BACK;
    
    // Movement
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
        return EV_UP;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        return EV_DOWN;
    
    return EV_NULL;
}




//-----------------------------------------------------------------------------
// Name: UpdateStateCreateAccount()
// Desc: Allow player to launch account creation tool
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateCreateAccount( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        
        // Return to Dashboard. Retail Dashboard will include
        // online account creation. Development XDK Launcher
        // includes the Xbox Online Setup Tool for creating accounts.
        LD_LAUNCH_DASHBOARD ld;
        ZeroMemory( &ld, sizeof(ld) );
        ld.dwReason = XLD_LAUNCH_DASHBOARD_MAIN_MENU;
        XLaunchNewImage( NULL, PLAUNCH_DATA( &ld ) );
        break;
    default:
        // If any MUs are inserted, update the user list
        // and go to account selection if there are any accounts
        DWORD dwInsertions;
        DWORD dwRemovals;
        if( CXBMemUnit::GetMemUnitChanges( dwInsertions, dwRemovals ) )
        {
            m_UserList.clear();
            XBOnline_GetUserList( m_UserList );
            if( !m_UserList.empty() )
                m_State = STATE_SELECT_ACCOUNT;
        }
        break;
       
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateSelectAccount()
// Desc: Allow player to choose account
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSelectAccount( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        {
            // Save current account information
            m_dwCurrUser = m_dwCurrItem;
            
            // Make WCHAR copy of user name
            XBUtil_GetWide( m_UserList[ m_dwCurrUser ].name, m_strUser, 
                XONLINE_NAME_SIZE );
            
            // If this user doesn't required PIN entry, begin authentication
            DWORD dwPinReq = m_UserList[ m_dwCurrUser ].dwUserOptions & 
                XONLINE_USER_OPTION_REQUIRE_PIN;
            if( !dwPinReq )
            {
                m_State = STATE_LOGGING_ON;
                BeginLogin();
                break;
            }
            
            // Begin PIN input
            m_State = STATE_GET_PIN;
            HRESULT hr = m_PinEntry.BeginInput( m_DefaultGamepad );
            assert( SUCCEEDED(hr) );
            (VOID)hr; // avoid compiler warning
            break;
        }
        
    case EV_UP:
        // Move to previous user account; allow wrap to bottom
        if( m_dwCurrItem == 0 )
            m_dwCurrItem = m_UserList.size() - 1;
        else
            --m_dwCurrItem;
        break;
        
    case EV_DOWN:
        // Move to next user account; allow wrap to top
        if( m_dwCurrItem == m_UserList.size() - 1 )
            m_dwCurrItem = 0;
        else
            ++m_dwCurrItem;
        break;
        
    default:
        // If any MUs are inserted/removed, need to update the
        // user account list
        DWORD dwInsertions;
        DWORD dwRemovals;
        if( CXBMemUnit::GetMemUnitChanges( dwInsertions, dwRemovals ) )
        {
            m_UserList.clear();
            XBOnline_GetUserList( m_UserList );
            if( m_UserList.empty() )
                m_State = STATE_CREATE_ACCOUNT;
            else
                m_dwCurrItem = 0;
        }
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateGetPin()
// Desc: Allow player to enter PIN number
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateGetPin( Event )
{
    HRESULT hr = m_PinEntry.DecodeInput( m_DefaultGamepad );
    switch( hr )
    {
    case E_ABORT:
        // B or BACK
        m_State = STATE_SELECT_ACCOUNT;
        break;
    case S_OK:
        if( m_PinEntry.IsPinComplete() )
        {
            // Validate PIN
            assert( m_dwCurrUser < m_UserList.size() );
            BYTE* pin = m_UserList[ m_dwCurrUser ].pin;
            if( m_PinEntry.IsPinValid( pin ) )
            {
                m_PinEntry.EndInput();
                
                // PIN is valid; initiate login
                m_State = STATE_LOGGING_ON;
                BeginLogin();
            }
            else
            {
                // The default PIN codes for users created by the Xbox 
                // Online Setup Tool are always "right, down, right, Y"
                m_UI.SetErrorStr( L"That was not the correct pass code" );
                m_State = STATE_ERROR;
                m_NextState = STATE_GET_PIN;
                hr = m_PinEntry.BeginInput( m_DefaultGamepad );
                assert( SUCCEEDED(hr) );
            }
        }
        break;
    default:
        m_UI.SetErrorStr( L"PIN entry failure" );
        m_State = STATE_ERROR;
        m_NextState = STATE_GET_PIN;
        hr = m_PinEntry.BeginInput( m_DefaultGamepad );
        assert( SUCCEEDED(hr) );
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateLoggingOn()
// Desc: Authentication is underway
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateLoggingOn( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        {
            // Close the task (this cancels the logon process)
            m_hOnlineTask.Close();
            
            // Return to list of user accounts
            m_State = STATE_SELECT_ACCOUNT;
            return;
        }
    }
    
    HRESULT hr = m_hOnlineTask.Continue();
    
    if ( hr != XONLINETASK_S_RUNNING )
    {
        if ( hr != XONLINE_S_LOGON_CONNECTION_ESTABLISHED  )
        {
            m_hOnlineTask.Close();
            m_UI.SetErrorStr( L"Login Failed. Try again." );
            m_State = STATE_ERROR;
            m_NextState = STATE_SELECT_ACCOUNT;
            return;
        }
        
        BOOL bSuccess = TRUE;
        BOOL bServiceErr = FALSE;
        HRESULT hrService = S_OK;
        DWORD i = 0;
        
		// Next, check if the user was actually logged on
		PXONLINE_USER pLoggedOnUsers = XOnlineGetLogonUsers();
		
		assert( pLoggedOnUsers );
		
		hr = pLoggedOnUsers[ m_dwCurrUser ].hr;
		
		if( FAILED( hr ) )
		{
            m_hOnlineTask.Close();
			m_UI.SetErrorStr( L"User Logon Failed (0x%x)",	hr );
            m_State = STATE_ERROR;
            m_NextState = STATE_SELECT_ACCOUNT;
            return;
		}


        // Check for service errors
        for( i = 0; i < NUM_SERVICES; ++i )
        {
            if( FAILED( hrService = XOnlineGetServiceInfo(m_pServices[i],NULL) ) )
            {
                bSuccess = FALSE;
                bServiceErr = TRUE;
                break;
            }
        }
        
        // If no errors, login was successful
        m_State = bSuccess ? STATE_SUCCESS : STATE_ERROR;
        
        if( !bSuccess )
        {
            if( bServiceErr )
            {
                m_UI.SetErrorStr( L"Login failed.\n\n"
                    L"Error %x logging into service %d",
                    hrService, m_pServices[i] );
            }
            else
            {
                m_UI.SetErrorStr( L"Login failed.\n\n"
                    L"Error %x returned by "
                    L"XOnlineTaskContinue", hr );
            }
            m_State = STATE_ERROR;
            m_NextState = STATE_SELECT_ACCOUNT;
            m_hOnlineTask.Close();
        }
        else
        {
            m_ServiceInfoList.clear();
            for( i = 0; i < NUM_SERVICES; ++i )
            {
                // Stored service information for UI
                XONLINE_SERVICE_INFO serviceInfo;
                XOnlineGetServiceInfo( m_pServices[i], &serviceInfo );
                m_ServiceInfoList.push_back( serviceInfo );
            }
            
            // Notify the world of our state change
            DWORD dwState = XONLINE_FRIENDSTATE_FLAG_ONLINE;
            if( XBVoice_HasDevice() )
                dwState |= XONLINE_FRIENDSTATE_FLAG_VOICE;
            SetPlayerState( dwState );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateSuccess()
// Desc: Authentication is successful
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSuccess( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        // A or START returns to begin
        m_State = STATE_SELECT_ACCOUNT;
        m_hOnlineTask.Close();
        return;
    }
    
    HRESULT hr = m_hOnlineTask.Continue();
    
    if( FAILED( hr ) )
    {
        m_hOnlineTask.Close();
        m_UI.SetErrorStr( L"Connection was lost. Must relogin" );
        m_State = STATE_ERROR;
        m_NextState = STATE_SELECT_ACCOUNT;
    }
    
}




//-----------------------------------------------------------------------------
// Name: UpdateStateError()
// Desc: An error occurred
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateError( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        // A or START exits
        m_State = m_NextState;
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: BeginLogin()
// Desc: Initiate the authentication process
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginLogin()
{
    assert( m_hOnlineTask == NULL );
    
    // Select a reasonable controller for the current player by choosing
    // the first controller found. Game code should do this much more
    // precisely. See below for details.
    for( m_dwUserIndex = 0; m_dwUserIndex < XGetPortCount(); ++m_dwUserIndex )
    {
        if( m_Gamepad[m_dwUserIndex].hDevice )
            break;
    }
    if( m_dwUserIndex >= XGetPortCount() )
        m_dwUserIndex = 0;
    
    // XOnlineLogon() allows a list of up to 4 players (1 per controller)
    // to login in a single call. This sample shows how to authenticate
    // a single user. The list must be a one-to-one match of controller 
    // to player in order for the online system to recognize which player
    // is using which controller.
    XONLINE_USER pUserList[ XGetPortCount() ] = { 0 };
    CopyMemory( &pUserList[ m_dwUserIndex ], &m_UserList[ m_dwCurrUser ],
        sizeof( XONLINE_USER ) );
    
    // Initiate the login process. XOnlineTaskContinue() is used to poll
    // the status of the login.
    HRESULT hr = XOnlineLogon( pUserList, m_pServices, NUM_SERVICES, 
        NULL, &m_hOnlineTask );
    
    if( FAILED(hr) )
    {
        m_hOnlineTask.Close();
        m_UI.SetErrorStr( L"Login failed to start.\n\n"
            L"Error %x returned by XOnlineLogon", hr );
        m_State = STATE_ERROR;
        m_NextState = STATE_SELECT_ACCOUNT;
    }
}




//-----------------------------------------------------------------------------
// Name: SetPlayerState()
// Desc: Broadcast current player state for the world
//-----------------------------------------------------------------------------
VOID CXBoxSample::SetPlayerState( DWORD dwState )
{
    BOOL bSuccess = XOnlineNotificationSetState( m_dwUserIndex, dwState,
        XNKID(), 0, NULL );
    assert( bSuccess );
    (VOID)bSuccess; // avoid compiler warning
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Auth\Auth.h ===
//-----------------------------------------------------------------------------
// File: Auth.h
//
// Desc: Shows Xbox online authentication protocols.
//       Includes account creation, PIN entry, validation and logon.
//
// Hist: 08.08.01 - New for Aug M1 release 
//       10.12.01 - Updated for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef AUTH_H
#define AUTH_H

#include "Common.h"
#include "UserInterface.h"
#include "XBApp.h"
#include "XBNet.h"
#include "XBOnlineTask.h"




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// Number of services to authenticate
const DWORD NUM_SERVICES = 2;




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    enum State
    {
        STATE_CREATE_ACCOUNT,   // Create user account
        STATE_SELECT_ACCOUNT,   // Select user account
        STATE_GET_PIN,          // Enter user PIN
        STATE_LOGGING_ON,       // Perform authentication
        STATE_SUCCESS,          // Successful authentication
        STATE_ERROR,            // Error
    };

    enum Event
    {
        EV_BUTTON_A,
        EV_BUTTON_B,
        EV_BUTTON_BACK,
        EV_UP,
        EV_DOWN,
        EV_NULL
    };

    UserInterface       m_UI;                // UI object
    State               m_State;             // current state
    State               m_NextState;         // return to this state
    DWORD               m_dwCurrItem;        // current selected menu item
    XBUserList          m_UserList;          // list of available accounts
    DWORD               m_dwCurrUser;        // index of curr user in m_UserList
    DWORD               m_dwUserIndex;       // which controller
    WCHAR               m_strUser[ XONLINE_USERNAME_SIZE ]; // Current user
    CXBNetLink          m_NetLink;                   // Network link checking
    CXBPinEntry         m_PinEntry;                  // PIN entry object
    DWORD               m_pServices[ NUM_SERVICES ]; // List of desired services
    ServiceInfoList     m_ServiceInfoList;           // List of service info
    CXBOnlineTask       m_hOnlineTask;               // Online task

public:

    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();

    CXBoxSample();

private:

    Event GetEvent() const;

    VOID UpdateStateCreateAccount( Event );
    VOID UpdateStateSelectAccount( Event );
    VOID UpdateStateGetPin( Event );
    VOID UpdateStateLoggingOn( Event );
    VOID UpdateStateSuccess( Event );
    VOID UpdateStateError( Event );

    VOID BeginLogin();
    VOID SetPlayerState( DWORD );

};




#endif // AUTH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Auth\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Auth\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\basicdplay\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Auth\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Auth\UserInterface.h ===
//-----------------------------------------------------------------------------
// File: UserInterface.h
//
// Desc: Auth rendering functions
//
// Hist: 10.12.01 - New for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef AUTH_UI_H
#define AUTH_UI_H

#include "Common.h"
#include "XBOnline.h"




//-----------------------------------------------------------------------------
// Name: class UserInterface
// Desc: Main UI class for Auth sample
//-----------------------------------------------------------------------------
class UserInterface
{
    CXBOnlineUI m_UI;

    static const D3DCOLOR COLOR_NORMAL = CXBOnlineUI::COLOR_NORMAL;

public:

    explicit UserInterface( WCHAR* );

    HRESULT Initialize();

    // Accessors
    VOID __cdecl SetErrorStr( const WCHAR*, ... );

    // UI functions
    VOID RenderCreateAccount( BOOL bHasMachineAccount ) const;
    VOID RenderSelectAccount( DWORD, const XBUserList& ) const;
    VOID RenderGetPin( const CXBPinEntry&, const WCHAR* ) const;
    VOID RenderLoggingOn() const;
    VOID RenderSuccess( const ServiceInfoList& ) const;
    VOID RenderError() const;

private:

    // Disabled
    UserInterface();
    UserInterface( const UserInterface& );

};

#endif // CONTENTDOWNLOAD_UI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Auth\UserInterface.cpp ===
//-----------------------------------------------------------------------------
// File: UserInterface.cpp
//
// Desc: Auth rendering functions
//
// Hist: 10.12.01 - New for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "UserInterface.h"
#include "Resource.h"
#include "XBSockAddr.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Name: UserInterface()
// Desc: Constructor
//-----------------------------------------------------------------------------
UserInterface::UserInterface( WCHAR* strFrameRate )
:   
    m_UI( strFrameRate, L"Auth" )
{
}




//-----------------------------------------------------------------------------
// Name: SetErrorStr()
// Desc: Set error string
//-----------------------------------------------------------------------------
VOID __cdecl UserInterface::SetErrorStr( const WCHAR* strFormat, ... )
{
    va_list pArgList;
    va_start( pArgList, strFormat );

    m_UI.SetErrorStr( strFormat, pArgList );

    va_end( pArgList );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT UserInterface::Initialize()
{
    return m_UI.Initialize( Resource_NUM_RESOURCES, Resource_MenuSelect_OFFSET );
}




//-----------------------------------------------------------------------------
// Name: RenderCreateAccount()
// Desc: Allow player to launch account creation tool
//-----------------------------------------------------------------------------
VOID UserInterface::RenderCreateAccount( BOOL bHasMachineAccount ) const
{
    m_UI.RenderCreateAccount( bHasMachineAccount );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectAccount()
// Desc: Display list of accounts
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSelectAccount( DWORD dwCurrItem, 
                                         const XBUserList& UserList ) const
{
    m_UI.RenderSelectAccount( dwCurrItem, UserList );
}




//-----------------------------------------------------------------------------
// Name: RenderGetPin()
// Desc: Display PIN entry screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderGetPin( const CXBPinEntry& PinEntry, 
                                  const WCHAR* strUser ) const
{
    m_UI.RenderGetPin( PinEntry, strUser );
}




//-----------------------------------------------------------------------------
// Name: RenderLoggingOn()
// Desc: Display "logging on" animation
//-----------------------------------------------------------------------------
VOID UserInterface::RenderLoggingOn() const
{
    m_UI.RenderLoggingOn();
}




//-----------------------------------------------------------------------------
// Name: RenderSuccess()
// Desc: Successful authentication
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSuccess( const ServiceInfoList& InfoList ) const
{
    m_UI.RenderHeader();

    m_UI.DrawText( 320, 160, COLOR_NORMAL, L"Successfully logged into "
                   L"services at:", XBFONT_CENTER_X );

    FLOAT fYtop = 220.0f;
    FLOAT fYdelta = 30.0f;

    // Display information about services
    DWORD j = 0;
    for( ServiceInfoList::const_iterator i = InfoList.begin(); 
         i != InfoList.end(); ++i, ++j )
    {
        XONLINE_SERVICE_INFO serviceInfo = *i;
        CXBSockAddr sa( serviceInfo.serviceIP.s_addr, serviceInfo.wServicePort );

        WCHAR strServiceInfo[32];
        sa.GetStr( strServiceInfo );

        m_UI.DrawText( 320, fYtop + (fYdelta * j ), COLOR_NORMAL,
                       strServiceInfo, XBFONT_CENTER_X );
    }

    m_UI.DrawText( 320, fYtop + (fYdelta * (j + 1) ), COLOR_NORMAL, 
                   L"Press A to logoff", 
                   XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderError()
// Desc: Display error message
//-----------------------------------------------------------------------------
VOID UserInterface::RenderError() const
{
    m_UI.RenderError();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Auth\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\chatroom\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\chatroom\ChatRoom.cpp ===
//-----------------------------------------------------------------------------
// File: ChatRoom.cpp
//
// Desc: Extends the WinsockPeer sample to
//       create a simple chat room with Xbox communicators
//       Note that headphones only receive data sent over the network.
//       Meaning, players on the same box will not hear each other through
//       the communicators.  This avoids any weird echoing effects.
//
// Hist: 08.11.01 - New for August M1 Online XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "ChatRoom.h"

const WORD  BROADCAST_PORT    = 10983;  // could be any port
const WORD  DIRECT_PORT       = 10984;  // any port other than BROADCAST_PORT

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
: 
    CXBApplication(),
    m_xprResource (),
    m_ptMenuSel   ( NULL ),
    m_hLogFile    ( INVALID_HANDLE_VALUE ),
    m_Font        (),
    m_Help        (),
    m_State       ( STATE_MENU ),
    m_LastState   ( STATE_MENU ),
    m_CurrItem    ( 0 ),
    m_GameNames   (),
    m_Games       (),
    m_Players     (),
    m_strError    (),
    m_strStatus   (),
    m_LinkStatusTimer     ( FALSE ),
    m_GameSearchTimer     ( FALSE ),
    m_GameJoinTimer       ( FALSE ),
    m_HeartbeatTimer      ( FALSE ),
    m_bIsOnline           ( FALSE ),
    m_bXnetStarted        ( FALSE ),
    m_bIsHost             ( FALSE ),
    m_bIsSessionRegistered( FALSE ),
    m_bHaveLocalAddress   ( FALSE ),
    m_xnHostKeyID         (),
    m_xnHostKeyExchange   (),
    m_xnTitleAddress      (),
    m_inHostAddr          (),
    m_BroadSock           (),
    m_DirectSock          (),
    m_strGameName         (),
    m_strPlayerName       (),
    m_strHostName         (),
    m_Nonce               (),
	m_pVoiceUnits		  (NULL)
{
    srand( GetTickCount() ); // for generating game/player names

    Init();
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the help system
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load our textures
    if( FAILED( m_xprResource.Create( g_pd3dDevice, "Resource.xpr", 
                                      Resource_NUM_RESOURCES ) ) )
    {
        OUTPUT_DEBUG_STRING( "Failed to load textures\n" );
        return XBAPPERR_MEDIANOTFOUND;
    }

    // Set up texture ptrs
    m_ptMenuSel = m_xprResource.GetTexture( Resource_MenuSelect_OFFSET );

    // Set projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 0.1f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

	// Set view position
    D3DXMATRIX matView;
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 40.0f);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // TCR 2-16 Lost Link
    // Check network status periodically
    if( !m_LinkStatusTimer.IsRunning() ||
        m_LinkStatusTimer.GetElapsedSeconds() > CHECK_LINK_STATUS )
    {
        m_LinkStatusTimer.StartZero();
        DWORD dwStatus = XNetGetEthernetLinkStatus();
        m_bIsOnline = ( dwStatus & XNET_ETHERNET_LINK_ACTIVE ) != 0;
    }

    Event ev = GetEvent();

    switch( m_State )
    {
        case STATE_MENU:            FrameMoveMenu( ev );        break;
        case STATE_GAME:            FrameMoveGame( ev );        break;
        case STATE_HELP:            FrameMoveHelp( ev );        break;
        case STATE_SELECT_NAME:     FrameMoveSelectName( ev );  break;
        case STATE_START_NEW_GAME:  FrameMoveStartGame( ev );   break;
        case STATE_GAME_SEARCH:     FrameMoveGameSearch( ev );  break;
        case STATE_SELECT_GAME:     FrameMoveSelectGame( ev );  break;
        case STATE_REQUEST_JOIN:    FrameMoveRequestJoin( ev ); break;
        case STATE_ERROR:           FrameMoveError( ev );       break;
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x000A0A6A, 1.0f, 0L );

    switch( m_State )
    {
        case STATE_MENU:            RenderMenu();        break;
        case STATE_GAME:            RenderGame();        break;
        case STATE_HELP:            RenderHelp();        break;
        case STATE_SELECT_NAME:     RenderSelectName();  break;
        case STATE_START_NEW_GAME:  RenderStartGame();   break;
        case STATE_GAME_SEARCH:     RenderGameSearch();  break;
        case STATE_SELECT_GAME:     RenderSelectGame();  break;
        case STATE_REQUEST_JOIN:    RenderRequestJoin(); break;
        case STATE_ERROR:           RenderError();       break;
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetEvent()
// Desc: Return the state of the controller
//-----------------------------------------------------------------------------
CXBoxSample::Event CXBoxSample::GetEvent()
{
    // "A" or "Start"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] ||
        m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        return EV_BUTTON_A;
    }

    // "B"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
        return EV_BUTTON_B;

    // "Back"
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        return EV_BUTTON_BACK;

    // Movement
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
        return EV_UP;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        return EV_DOWN;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT )
        return EV_LEFT;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
        return EV_RIGHT;

    return EV_NULL;
}




//-----------------------------------------------------------------------------
// Name: FrameMoveMenu()
// Desc: Animate menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveMenu( Event ev )
{
    switch( ev )
    {
        case EV_BUTTON_A:

            // Prepare networking
            switch( InitXNet() )
            {
                case Success:
                    break;
                case NotConnected:
                    m_State = STATE_ERROR;
                    lstrcpynW( m_strError, L"This Xbox is not connected to\n"
                                           L"a hub or another Xbox",
                                           MAX_ERROR_STR );
                    return;
                case InitFailed:
                    m_State = STATE_ERROR;
                    lstrcpynW( m_strError, L"Failure initializing network\n"
                                           L"connections", 
                                           MAX_ERROR_STR );
                    return;
                default: assert( FALSE ); break;
            }

            switch( m_CurrItem )
            {
                case MAIN_MENU_START_GAME:
                {    
                    assert( !m_bIsSessionRegistered );

                    // Create the session key ID and exchange key
                    INT iKeyCreated = XNetCreateKey( &m_xnHostKeyID, 
                                                     &m_xnHostKeyExchange );

                    // Register the session
                    INT iKeyRegistered = XNetRegisterKey( &m_xnHostKeyID, 
                                                          &m_xnHostKeyExchange );
                    if( iKeyCreated != NO_ERROR || iKeyRegistered != NO_ERROR )
                    {
                        m_State = STATE_ERROR;
                        lstrcpynW( m_strError, L"Unable to start game session",
                                   MAX_ERROR_STR );

                        if( iKeyCreated != NO_ERROR )
                            LogXNetError( "XNetCreateKey", iKeyCreated );
                        if( iKeyRegistered != NO_ERROR )
                            LogXNetError( "XNetRegisterKey", iKeyRegistered );

                        break;
                    }

                    m_bIsSessionRegistered = TRUE;

                    // We're the host
                    m_bIsHost = TRUE;

                    // TCR 3-58 Naming of Game Sessions
                    // Build a list of potential game names
                    assert( m_GameNames.empty() );
                    for( DWORD i = 0; i < MAX_GAME_NAMES; ++i )
                    {
                        WCHAR strGameName[ MAX_GAME_NAME ];
                        GenRandom( strGameName, MAX_GAME_NAME );
                        m_GameNames.push_back( strGameName );
                    }

                    // Start at the top of the list
                    m_CurrItem = 0;

                    m_State = STATE_SELECT_NAME;
                    break;
                }
                case MAIN_MENU_JOIN_GAME:

                    // Begin searching for games on the network
                    SendFindGame();
                    m_GameSearchTimer.StartZero();
                    m_State = STATE_GAME_SEARCH;

                    break;
            }
            break;

        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = MAIN_MENU_MAX - 1;
            else
                --m_CurrItem;
            break;
        case EV_DOWN:
            if( m_CurrItem == MAIN_MENU_MAX - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;
        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveGame()
// Desc: Animate game
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveGame( Event ev )
{
    if( !m_bIsOnline )
    {
        // TCR 2-16 Lost Link
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"This Xbox has lost its System Link connection",
                               MAX_ERROR_STR );
        return;
    }

    // Handle net messages
    if( ProcessBroadcastMessage() )
        return;
    if( ProcessDirectMessage() )
        return;

    // Send keep-alives
    if( m_HeartbeatTimer.GetElapsedSeconds() > PLAYER_HEARTBEAT )
    {
        Heartbeat();
        m_HeartbeatTimer.StartZero();
    }

    // Handle other players dropping
    if( ProcessPlayerDropouts() )
        return;

    switch( ev )
    {
        case EV_BUTTON_A:
            switch( m_CurrItem )
            {
                case GAME_MENU_WAVE:
                    Wave();
                    break;
				case GAME_MENU_VOICE:
                    Voice();
                    break;
                case GAME_MENU_LEAVE_GAME:
                    Init();
                    break;
            }
            break;
        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = GAME_MENU_MAX - 1;
            else
                --m_CurrItem;
            break;
        case EV_DOWN:
            if( m_CurrItem == GAME_MENU_MAX - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;
        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveHelp()
// Desc: Animate help
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveHelp( Event ev )
{
    // Handle net messages
    if( ProcessBroadcastMessage() )
        return;
    if( ProcessDirectMessage() )
        return;

    if( ev != EV_NULL )
        m_State = m_LastState;
}




//-----------------------------------------------------------------------------
// Name: FrameMoveSelectName()
// Desc: Animate game name selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveSelectName( Event ev )
{
    // TCR 3-58 Naming of Game Sessions

    // Allow the player to cancel out of game name selection
    if( ev == EV_BUTTON_B || !m_bIsOnline )
    {
        Init();
        return;
    }

    switch( ev )
    {
        case EV_BUTTON_A:

            // Use the selected namne
            lstrcpyW( m_strGameName, m_GameNames[ m_CurrItem ].c_str() );

            // Destroy the name list; we don't need it anymore
            m_GameNames.clear();

            // Set the default game item to "wave"
            m_CurrItem = 0;

            // Display when game begins
            lstrcpynW( m_strStatus, L"Game started", MAX_STATUS_STR );

            // If we have the local address, begin the game.
            // Otherwise, acquire the local address.
            if( m_bHaveLocalAddress )
            {
                m_State = STATE_GAME;
                m_HeartbeatTimer.StartZero();
            }
            else
                m_State = STATE_START_NEW_GAME;
            break;

        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = m_GameNames.size() - 1;
            else
                --m_CurrItem;
            break;

        case EV_DOWN:
            if( m_CurrItem == m_GameNames.size() - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;

        case EV_BUTTON_B:
            Init();
            break;

        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveStartGame()
// Desc: Animate start game
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveStartGame( Event ev )
{
    // Allow the player to cancel out of game startup
    if( ev == EV_BUTTON_B || !m_bIsOnline )
    {
        Init();
        return;
    }

    // Asynchronous local address acquisition
    DWORD dwStatus = XNetGetTitleXnAddr( &m_xnTitleAddress );
    assert( dwStatus != XNET_GET_XNADDR_NONE );

    // If we've retrieved the local address, we're done
    m_bHaveLocalAddress = ( dwStatus != XNET_GET_XNADDR_PENDING );

    // When startup is complete, enter the game
    if( m_bHaveLocalAddress )
    {   
        m_HeartbeatTimer.StartZero();
        m_State = STATE_GAME;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveGameSearch()
// Desc: Animate game search
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveGameSearch( Event ev )
{
    // Allow the player to cancel out of game search
    if( ev == EV_BUTTON_B || !m_bIsOnline )
    {
        Init();
        return;
    }

    // See if any games have replied
    if( ProcessBroadcastMessage() )
        return;

    // We search for up to GAME_SEARCH_TIME seconds. If the game 
    // search is complete, display the list of available games. If no games
    // were found, display an error message
    if( m_GameSearchTimer.GetElapsedSeconds() > GAME_SEARCH_TIME )
    {
        m_GameSearchTimer.Stop();
        if( m_Games.empty() )
        {
            m_State = STATE_ERROR;
            lstrcpynW( m_strError, L"No games available", MAX_ERROR_STR );
        }
        else if( m_Games.size() == 1 )
        {
            // TCR 3-57 Default Choices for System Link Play
            // One game; join automatically
            InitiateJoin( 0 );
        }
        else // at least two games
        {
            // at least two games; allow player selection
            m_State = STATE_SELECT_GAME;
            m_CurrItem = 0;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveSelectGame()
// Desc: Animate game selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveSelectGame( Event ev )
{
    if( !m_bIsOnline )
    {
        // TCR 2-16 Lost Link
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"This Xbox has lost its System Link connection",
                               MAX_ERROR_STR );
        return;
    }

    switch( ev )
    {
        case EV_BUTTON_A:
            InitiateJoin( m_CurrItem );
            break;

        case EV_UP:
            if( m_CurrItem == 0 )
                m_CurrItem = m_Games.size() - 1;
            else
                --m_CurrItem;
            break;

        case EV_DOWN:
            if( m_CurrItem == m_Games.size() - 1 )
                m_CurrItem = 0;
            else
                ++m_CurrItem;
            break;

        case EV_BUTTON_B:
            Init();
            break;

        case EV_BUTTON_BACK:
            m_LastState = m_State;
            m_State = STATE_HELP;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveRequestJoin()
// Desc: Animate join request
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveRequestJoin( Event ev )
{
    // Allow the player to cancel out of join request
    if( ev == EV_BUTTON_B || !m_bIsOnline )
    {
        Init();
        return;
    }

    // See if the game has replied
    ProcessDirectMessage();

    // We wait for up to GAME_JOIN_TIME seconds. If the game didn't
    // respond, display an error message
    if( m_GameJoinTimer.GetElapsedSeconds() > GAME_JOIN_TIME )
    {
        m_GameJoinTimer.Stop();
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"Game did not respond", MAX_ERROR_STR );
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMoveError()
// Desc: Animate error message
//-----------------------------------------------------------------------------
VOID CXBoxSample::FrameMoveError( Event ev )
{
    // Handle net messages
    if( ProcessBroadcastMessage() )
        return;
    if( ProcessDirectMessage() )
        return;

    // Any button exits
    if( ev != EV_NULL )
        Init();
}





//-----------------------------------------------------------------------------
// Name: RenderMenu()
// Desc: Display menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderMenu()
{
    RenderHeader();

    const WCHAR* const strMenu[] =
    {
        L"Start New Game",
        L"Join Existing Game",
    };

    FLOAT fYtop = 200.0f;
    FLOAT fYdelta = 50.0f;

    // TCR 3-44 System Link Play Menu Option
    for( DWORD i = 0; i < MAIN_MENU_MAX; ++i )
    {
        DWORD dwColor = ( m_CurrItem == i && m_bIsOnline ) ? COLOR_HIGHLIGHT : 
                                                             COLOR_NORMAL;
        m_Font.DrawText( 260, fYtop + (fYdelta * i), dwColor, strMenu[i] );
    }

    // Show selected item with little triangle
    if( m_bIsOnline )
        RenderMenuSelector( 220.0f, fYtop + (fYdelta * m_CurrItem ) );

    m_Font.DrawText( 320, 400, COLOR_NORMAL, m_bIsOnline ? 
                     L"System Link Connected" :
                     L"System Link NOT Connected", XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderGame()
// Desc: Display game
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderGame()
{
    RenderHeader();

    // Game name and player name
    WCHAR strGameInfo[ 32 + MAX_GAME_NAME + MAX_PLAYER_NAME ];
    wsprintfW( strGameInfo, L"Game name: %.*s\nYour name: %.*s", 
               MAX_GAME_NAME, m_strGameName, MAX_PLAYER_NAME, m_strPlayerName );
    m_Font.DrawText( 220, 110, COLOR_GREEN, strGameInfo );

    // Number of players and current status
    wsprintfW( strGameInfo, L"Players in game: %lu", m_Players.size() + 1 );
    m_Font.DrawText( 220, 158, COLOR_GREEN, strGameInfo );
    m_Font.DrawText( 220, 184, COLOR_GREEN, m_strStatus );

    // Game options menu
    const WCHAR* const strMenu[] =
    {
        L"Wave To Other Players",
		L"Voice",
        L"Leave Game",
    };

    FLOAT fYtop = 240.0f;
    FLOAT fYdelta = 50.0f;

    // Show menu
    for( DWORD i = 0; i < GAME_MENU_MAX; ++i )
    {
        DWORD dwColor = ( m_CurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_Font.DrawText( 260, fYtop + (fYdelta * i), dwColor, strMenu[i] );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 220.0f, fYtop + (fYdelta * m_CurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderHelp()
// Desc: Display help
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderHelp()
{
    XBHELP_CALLOUT HelpCallouts[] =
    {
        { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, L"Display\nhelp" },
        { XBHELP_A_BUTTON, XBHELP_PLACEMENT_1, L"Select menu\nitem" },
        { XBHELP_B_BUTTON, XBHELP_PLACEMENT_1, L"Cancel" },
        { XBHELP_DPAD, XBHELP_PLACEMENT_1, L"Menu navigation" },
    };
    m_Help.Render( &m_Font, HelpCallouts, 4 );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectName()
// Desc: Display game name selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderSelectName()
{
    assert( !m_GameNames.empty() );

    RenderHeader();

    m_Font.DrawText( 320, 110, 0xffffffff, L"Select a game name\n\n"
                                           L"Press B to cancel", 
                     XBFONT_CENTER_X );

    FLOAT fYtop = 220.0f;
    FLOAT fYdelta = 30.0f;

    // Show list of game names
    for( DWORD i = 0; i < m_GameNames.size(); ++i )
    {
        DWORD dwColor = ( m_CurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_Font.DrawText( 280, fYtop + (fYdelta * i), dwColor, 
                         m_GameNames[i].c_str() );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 240.0f, fYtop + (fYdelta * m_CurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderStartGame()
// Desc: Display game startup sequence
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderStartGame()
{
    RenderHeader();
    m_Font.DrawText( 320, 240, 0xffffffff, L"Starting Game\n\n"
                                           L"Press B to cancel",
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: RenderGameSearch()
// Desc: Display game search sequence
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderGameSearch()
{
    RenderHeader();
    m_Font.DrawText( 320, 240, 0xffffffff, L"Searching For Active Games\n\n"
                                           L"Press B to cancel",
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectGame()
// Desc: Display list of available games
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderSelectGame()
{
    assert( !m_Games.empty() );

    RenderHeader();

    m_Font.DrawText( 320, 110, 0xffffffff, L"Select game to join\n\n"
                                           L"Press B to cancel", 
                     XBFONT_CENTER_X );

    FLOAT fYtop = 220.0f;
    FLOAT fYdelta = 50.0f;

    // Show list of games
    for( DWORD i = 0; i < m_Games.size(); ++i )
    {
        DWORD dwColor = ( m_CurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        WCHAR strGameInfo[ 64 + MAX_GAME_NAME + MAX_PLAYER_NAME ];
        wsprintfW( strGameInfo, L"\"%.*s\" hosted by \"%.*s\"; players: %d",
                   MAX_GAME_NAME, m_Games[i].strGameName,
                   MAX_PLAYER_NAME, m_Games[i].strHostName,
                   INT(m_Games[i].byNumPlayers) );

        // Denote full games
        if( m_Games[i].byNumPlayers == MAX_PLAYERS )
            lstrcatW( strGameInfo, L" (full)" );

        m_Font.DrawText( 140, fYtop + (fYdelta * i), dwColor, strGameInfo );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 100.0f, fYtop + (fYdelta * m_CurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderRequestJoin()
// Desc: Display join request sequence
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderRequestJoin()
{
    RenderHeader();
    m_Font.DrawText( 320, 240, 0xffffffff, L"Joining game", 
                     XBFONT_CENTER_X | XBFONT_CENTER_Y );
}




//-----------------------------------------------------------------------------
// Name: RenderError()
// Desc: Display error message
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderError()
{
    RenderHeader();
    m_Font.DrawText( 320, 200, 0xffffffff, m_strError, XBFONT_CENTER_X );
    m_Font.DrawText( 320, 260, 0xffffffff, L"Press A to continue", 
                     XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderHeader()
// Desc: Display standard text
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderHeader()
{
    WCHAR strName[32];
    lstrcpyW( strName, L"ChatRoom" );
    if( m_bIsHost )
        lstrcatW( strName, L" (host)" );

    m_Font.DrawText(  64, 50, 0xffffffff, strName );
    m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
}




//-----------------------------------------------------------------------------
// Name: RenderMenuSelector()
// Desc: Display menu selector
//-----------------------------------------------------------------------------
VOID CXBoxSample::RenderMenuSelector( FLOAT fLeft, FLOAT fTop )
{
    D3DXVECTOR4 rc( fLeft, fTop, fLeft + 20.0f, fTop + 20.0f );

    // Show selected item
    struct TILEVERTEX
    {
        D3DXVECTOR4 p;
        D3DXVECTOR2 t;
    };
    TILEVERTEX* pVertices;

    LPDIRECT3DVERTEXBUFFER8 pvbTemp;
    g_pd3dDevice->CreateVertexBuffer( 4 * sizeof( TILEVERTEX ), 
                                      D3DUSAGE_WRITEONLY, 
                                      D3DFVF_XYZRHW | D3DFVF_TEX1, 
                                      D3DPOOL_MANAGED, &pvbTemp );

    // Create a quad for us to render our texture on
    pvbTemp->Lock( 0, 0, (BYTE **)&pVertices, 0L );
    pVertices[0].p = D3DXVECTOR4( rc.x - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[0].t = D3DXVECTOR2( 0.0f, 1.0f ); // Bottom Left
    pVertices[1].p = D3DXVECTOR4( rc.x - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[1].t = D3DXVECTOR2( 0.0f, 0.0f ); // Top    Left
    pVertices[2].p = D3DXVECTOR4( rc.z - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[2].t = D3DXVECTOR2( 1.0f, 1.0f ); // Bottom Right
    pVertices[3].p = D3DXVECTOR4( rc.z - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[3].t = D3DXVECTOR2( 1.0f, 0.0f ); // Top    Right
    pvbTemp->Unlock();

    // Set up our state
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetStreamSource( 0, pvbTemp, sizeof( TILEVERTEX ) );

    // Render the quad with our texture
    g_pd3dDevice->SetTexture( 0, m_ptMenuSel );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    g_pd3dDevice->SetTexture( 0, NULL );
    pvbTemp->Release();
}




//-----------------------------------------------------------------------------
// Name: InitiateJoin()
// Desc: Send a join request to the specified game
//-----------------------------------------------------------------------------
VOID CXBoxSample::InitiateJoin( DWORD iCurrGame )
{
    // Determine which game the player wants to join
    GameInfo gameInfo = m_Games[ iCurrGame ];

    // Establish a session with the host game
    INT iResult = XNetRegisterKey( &gameInfo.xnHostKeyID, 
                                   &gameInfo.xnHostKey );
    assert( iResult == NO_ERROR );
    if( iResult == NO_ERROR )
    {
        assert( m_bIsSessionRegistered == FALSE );
        m_bIsSessionRegistered = TRUE;

        // Save the key ID because we need to unregister it
        // Note that we don't need the key itself once it's been registered.
        CopyMemory( &m_xnHostKeyID, &gameInfo.xnHostKeyID, sizeof( XNKID ) );

        // Save the game and player name of the host
        lstrcpynW( m_strGameName, gameInfo.strGameName, MAX_GAME_NAME );
        lstrcpynW( m_strHostName, gameInfo.strHostName, MAX_PLAYER_NAME );

        // Convert the XNADDR of the host to the INADDR we'll use to
        // join the game
        iResult = XNetXnAddrToInAddr( &gameInfo.xnHostAddr,
                                      &m_xnHostKeyID, &m_inHostAddr );
        assert( iResult == NO_ERROR );

        // Request join approval from the game and await a response
        SendJoinGame( CXBSockAddr( m_inHostAddr, DIRECT_PORT ) );
        m_GameJoinTimer.StartZero();
        m_State = STATE_REQUEST_JOIN;
    }
    else
    {
        m_State = STATE_ERROR;
        lstrcpynW( m_strError, L"Unable to establish session with game",
                   MAX_ERROR_STR );
        LogXNetError( "XNetRegisterKey", iResult );
    }

    // Don't need the game list anymore
    DestroyGameList();
}




//-----------------------------------------------------------------------------
// Name: Wave()
// Desc: Wave to other players in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::Wave()
{
    // Indicate that you waved
    lstrcpynW( m_strStatus, L"You waved", MAX_STATUS_STR );

	if(NULL != m_pVoiceUnits)
	{
		delete m_pVoiceUnits;
		m_pVoiceUnits =  NULL;
	}

    // Send a "wave" message to each of the other players in the game
    for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
        SendWave( CXBSockAddr( i->inAddr, DIRECT_PORT ) );

}

//-----------------------------------------------------------------------------
// Name: Voice()
// Desc: Send voice to other players in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::Voice()
{
    // Indicate that you sent voice
    lstrcpynW( m_strStatus, L"Voice chat enabled!", MAX_STATUS_STR );


	// Initialize the headset
	if(NULL == m_pVoiceUnits)
	{
		m_pVoiceUnits = new CVoiceUnits;
		
    m_pVoiceUnits->Initialize(m_Players);

		//
        // Playback scenario with no players involved
        //
	//	m_pVoiceUnits->Initialize(CXBSockAddr( INADDR_ANY, VOICE_PORT ));
	}

}



//-----------------------------------------------------------------------------
// Name: Heartbeat()
// Desc: Send heartbeat to players in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::Heartbeat()
{
    // Send a "heartbeat" message to each of the other players in the game
    // to let them know we're alive
    for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
        SendHeartbeat( CXBSockAddr( i->inAddr, DIRECT_PORT ) );
}




//-----------------------------------------------------------------------------
// Name: Init()
// Desc: Teardown any active games and player lists and return to main menu
//       Unregisters any active sessions.
//-----------------------------------------------------------------------------
VOID CXBoxSample::Init()
{
    // Don't clear m_bXnetStarted. We don't need to reinitialize Xnet once
    // it's been started.

    // Don't clear m_bHaveLocalAddress or m_xnTitleAddress. We don't need to 
    // reacquire the address once we have it.

    m_State     = STATE_MENU;
    m_LastState = STATE_MENU;
    m_CurrItem  = 0;

    m_GameNames.clear();
    DestroyGameList();
    DestroyPlayerList();

    *m_strError = 0;
    *m_strStatus = 0;

    m_LinkStatusTimer.Stop();
    m_GameSearchTimer.Stop();
    m_GameJoinTimer.Stop();
    m_HeartbeatTimer.Stop();

    m_bIsHost = FALSE;

	//Turn off headsets
	if(NULL != m_pVoiceUnits)
	{
		delete m_pVoiceUnits;
		m_pVoiceUnits =  NULL;
	}	


    // Unregister the game session key
    if( m_bIsSessionRegistered )
    {
        INT iResult = XNetUnregisterKey( &m_xnHostKeyID );
        assert( iResult == NO_ERROR );
        (VOID)iResult;
        m_bIsSessionRegistered = FALSE;
    }

    // Obliterate old keys and XNADDR
    ZeroMemory( &m_xnHostKeyID,       sizeof( XNKID ) );
    ZeroMemory( &m_xnHostKeyExchange, sizeof( XNKEY ) );
    m_inHostAddr.s_addr = 0;

    // Close down the sockets
    m_BroadSock.Close();
    m_DirectSock.Close();

    *m_strGameName   = 0;
    *m_strPlayerName = 0;
    *m_strHostName   = 0;

    ZeroMemory( &m_Nonce, sizeof(m_Nonce) );

    // Generate random player name
    // A real Xbox game would get this information from the player
    GenRandom( m_strPlayerName, MAX_PLAYER_NAME );

}




//-----------------------------------------------------------------------------
// Name: InitXNet()
// Desc: Initialize the network stack. Returns FALSE if Xbox is not connected.
//-----------------------------------------------------------------------------
CXBoxSample::InitStatus CXBoxSample::InitXNet()
{
    if( !m_bIsOnline )
        return NotConnected;

    // Only need to initialize network stack one time
    if( !m_bXnetStarted )
    {
        // Initialize network stack
        INT iResult = XNetStartup( NULL );
        if( iResult != NO_ERROR )
        {
            LogXNetError( "XNetStartup", iResult );
            return InitFailed;
        }

        // Standard WinSock startup
        WSADATA WsaData;
        iResult = WSAStartup( MAKEWORD(2,2), &WsaData );
        if( iResult != NO_ERROR )
        {
            LogXNetError( "WSAStartup", iResult );
            return InitFailed;
        }

        m_bXnetStarted = TRUE;
    }

    // The broadcast socket is a non-blocking socket on port BROADCAST_PORT.
    // All broadcast messages are automatically always encrypted.
    BOOL bSuccess = m_BroadSock.Open( CXBSocket::Type_UDP );
    if( !bSuccess )
    {
        LogXNetError( "Broadcast socket open", WSAGetLastError() );
        return InitFailed;
    }

    CXBSockAddr broadAddr( INADDR_ANY, BROADCAST_PORT );
    INT iResult = m_BroadSock.Bind( broadAddr.GetPtr() );
    assert( iResult != SOCKET_ERROR );
    DWORD dwNonBlocking = 1;
    iResult = m_BroadSock.IoCtlSocket( FIONBIO, &dwNonBlocking );
    assert( iResult != SOCKET_ERROR );
    BOOL bBroadcast = TRUE;
    iResult = m_BroadSock.SetSockOpt( SOL_SOCKET, SO_BROADCAST,
                                      &bBroadcast, sizeof(bBroadcast) );
    assert( iResult != SOCKET_ERROR );

    // The direct socket is a non-blocking socket on port DIRECT_PORT.
    // Sockets are encrypted by default, but can have encryption disabled
    // as an optimization for non-secure messaging
    bSuccess = m_DirectSock.Open( CXBSocket::Type_UDP );
    if( !bSuccess )
    {
        LogXNetError( "Direct socket open", WSAGetLastError() );
        return InitFailed;
    }

    CXBSockAddr directAddr( INADDR_ANY, DIRECT_PORT );
    iResult = m_DirectSock.Bind( directAddr.GetPtr() );
    assert( iResult != SOCKET_ERROR );
    iResult = m_DirectSock.IoCtlSocket( FIONBIO, &dwNonBlocking );
    assert( iResult != SOCKET_ERROR );

    // Note that this sample does not call either WSACleanup() or 
    // XNetCleanup(). These functions should be called by your game to
    // free system resources when the player is no longer online but
    // is still playing the game (e.g. switched to single-player mode).

    return Success;
}




//-----------------------------------------------------------------------------
// Name: SendFindGame()
// Desc: Broadcast a MSG_FIND_GAME from our client to any available host
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendFindGame()
{
    assert( !m_bIsHost );
    Message msgFindGame( MSG_FIND_GAME );
    MsgFindGame& msg = msgFindGame.GetFindGame();

    // Generate a nonce (random bytes). When a potential host responds with
    // information about a game, he must respond via a broadcast message
    // since a secure session hasn't been established. The broadcast message
    // will contain the same nonce so we can verify that message is really
    // for us. If we receive a broadcast "found game" message with a different
    // nonce, we ignore it, because it was broadcast to a different client
    // than us.
    INT iResult = XNetRandom( (BYTE*)(&msg.nonce), sizeof(msg.nonce) );
    assert( iResult == NO_ERROR );
    (VOID)iResult;

    // Save the nonce for comparison later
    CopyMemory( &m_Nonce, &msg.nonce, sizeof(msg.nonce) );

    CXBSockAddr saBroad( INADDR_BROADCAST, BROADCAST_PORT );
    INT nBytes = m_BroadSock.SendTo( &msgFindGame, msgFindGame.GetSize(),
                                     saBroad.GetPtr() );
    assert( nBytes == msgFindGame.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendGameFound()
// Desc: Broadcast a MSG_GAME_FOUND from our host to the world
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendGameFound( const Nonce& nonceClient )
{
    assert( m_bIsHost );
    Message msgGameFound( MSG_GAME_FOUND );
    MsgGameFound& msg = msgGameFound.GetGameFound();

    // Resend the nonce that we received from the client so he can verify
    // that this message is really for him
    CopyMemory( &msg.nonce, &nonceClient, sizeof(nonceClient) );

    // Send information about the session that we're hosting
    CopyMemory( &msg.xnHostKeyID, &m_xnHostKeyID,       sizeof(XNKID) );
    CopyMemory( &msg.xnHostKey,   &m_xnHostKeyExchange, sizeof(XNKEY) );
    CopyMemory( &msg.xnHostAddr,  &m_xnTitleAddress,    sizeof(XNADDR) );

    // Send the current information about the game
    msg.byNumPlayers = BYTE( m_Players.size() + 1 );
    lstrcpynW( msg.strGameName, m_strGameName, MAX_GAME_NAME );
    lstrcpynW( msg.strHostName, m_strPlayerName, MAX_PLAYER_NAME );

    // We don't have the XNADDR of the requesting client, so we
    // can't send this message directly back. Instead, we broadcast the
    // message to everybody on the net. The requesting client can
    // check the nonce to verify that the response is really for them.
    // Broadcast messages are automatically encrypted.

    CXBSockAddr saBroad( INADDR_BROADCAST, BROADCAST_PORT );
    INT nBytes = m_BroadSock.SendTo( &msgGameFound, msgGameFound.GetSize(),
                                     saBroad.GetPtr() );
    assert( nBytes == msgGameFound.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendJoinGame()
// Desc: Issue a MSG_JOIN_GAME from our client to the game host
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendJoinGame( const CXBSockAddr& saGameHost )
{
    assert( !m_bIsHost );
    Message msgJoinGame( MSG_JOIN_GAME );
    MsgJoinGame& msg = msgJoinGame.GetJoinGame();

    // Include our player name
    lstrcpynW( msg.strPlayerName, m_strPlayerName, MAX_PLAYER_NAME );

    // We can send this message directly to the host
    INT nBytes = m_DirectSock.SendTo( &msgJoinGame, msgJoinGame.GetSize(),
                                      saGameHost.GetPtr() );
    assert( nBytes == msgJoinGame.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendJoinApproved()
// Desc: Issue a MSG_JOIN_APPROVED from our host to the requesting client.
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendJoinApproved( const CXBSockAddr& saClient )
{
    assert( m_bIsHost );
    Message msgJoinApproved( MSG_JOIN_APPROVED );
    MsgJoinApproved& msg = msgJoinApproved.GetJoinApproved();

    // The host is us
    lstrcpynW( msg.strHostName, m_strPlayerName, MAX_PLAYER_NAME );

    // Send the list of all the current players to the new player.
    // We don't send the host player info, since the new player 
    // already has all of the information it needs about the host player.
    msg.byNumPlayers = BYTE( m_Players.size() );
    BYTE j = 0;
    for( PlayerList::const_iterator i = m_Players.begin(); 
         i != m_Players.end(); ++i, ++j )
    {
        PlayerInfo playerInfo = *i;
        CopyMemory( &msg.PlayerList[j].xnAddr, &playerInfo.xnAddr, 
                    sizeof( XNADDR ) );
        lstrcpynW( msg.PlayerList[j].strPlayerName, 
                   playerInfo.strPlayerName, MAX_PLAYER_NAME );
    }

    // We can send this message directly back to the requesting client
    INT nBytes = m_DirectSock.SendTo( &msgJoinApproved, msgJoinApproved.GetSize(),
                                      saClient.GetPtr() );
    assert( nBytes == msgJoinApproved.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendJoinDenied()
// Desc: Issue a MSG_JOIN_DENIED from our host to the requesting client
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendJoinDenied( const CXBSockAddr& saClient )
{
    assert( m_bIsHost );
    Message msgJoinDenied( MSG_JOIN_DENIED );

    // We can send this message directly back to the requesting client
    INT nBytes = m_DirectSock.SendTo( &msgJoinDenied, msgJoinDenied.GetSize(),
                                      saClient.GetPtr() );
    assert( nBytes == msgJoinDenied.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendPlayerJoined()
// Desc: Issue a MSG_PLAYER_JOINED from our host to a player in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendPlayerJoined( const Player& player, const CXBSockAddr& saPlayer )
{
    assert( m_bIsHost );
    Message msgPlayerJoined( MSG_PLAYER_JOINED );
    MsgPlayerJoined& msg = msgPlayerJoined.GetPlayerJoined();

    // The payload is the information about the player who just joined
    CopyMemory( &msg.player, &player, sizeof(player) );

    // We send this message directly to the player
    INT nBytes = m_DirectSock.SendTo( &msgPlayerJoined, msgPlayerJoined.GetSize(),
                                      saPlayer.GetPtr() );
    assert( nBytes == msgPlayerJoined.GetSize() );
    (VOID)nBytes;
}




//-----------------------------------------------------------------------------
// Name: SendWave()
// Desc: Issue a MSG_WAVE from ourself (either a host or player) to another
//       player
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendWave( const CXBSockAddr& saPlayer )
{
    Message msgWave( MSG_WAVE );
    INT nBytes = m_DirectSock.SendTo( &msgWave, msgWave.GetSize(), 
                                      saPlayer.GetPtr() );
    assert( nBytes == msgWave.GetSize() );
    (VOID)nBytes;
}


//-----------------------------------------------------------------------------
// Name: SendHeartbeat()
// Desc: Issue a MSG_HEARTBEAT from ourself (either a host or player) to
//       another player
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendHeartbeat( const CXBSockAddr& saPlayer )
{
    Message msgHeartbeat( MSG_HEARTBEAT );

    // No need to encrypt this message, since it contains no information that
    // requires security. For optimization purposes, we turn off encryption
    // for this data.
    BOOL bEncrypt = FALSE;
    INT iResult = m_DirectSock.SetSockOpt( SOL_SOCKET, SO_ENCRYPT, 
                                           &bEncrypt, sizeof(bEncrypt) );
    assert( iResult != SOCKET_ERROR );
    (VOID)iResult;

    // Send the unencrypted heartbeat
    INT nBytes = m_DirectSock.SendTo( &msgHeartbeat, msgHeartbeat.GetSize(),
                                      saPlayer.GetPtr() );
    assert( nBytes == msgHeartbeat.GetSize() );
    (VOID)nBytes;

    // Restore encryption on the socket for other messages
    bEncrypt = TRUE;
    iResult = m_DirectSock.SetSockOpt( SOL_SOCKET, SO_ENCRYPT,
                                       &bEncrypt, sizeof(bEncrypt) );
    assert( iResult != SOCKET_ERROR );
}




//-----------------------------------------------------------------------------
// Name: ProcessBroadcastMessage()
// Desc: Checks to see if any broadcast messages are waiting on the broadcast
//       socket. If a message is waiting, it is routed and processed.
//       If no messages are waiting, the function returns immediately.
//       Returns TRUE if a message was processed.
//-----------------------------------------------------------------------------
BOOL CXBoxSample::ProcessBroadcastMessage()
{
    if( !m_BroadSock.IsOpen() )
        return FALSE;

    // See if a network broadcast message is waiting for us
    Message msg;
    INT iResult = m_BroadSock.Recv( &msg, msg.GetMaxSize() );

    // If message waiting, process it
    if( iResult != SOCKET_ERROR && iResult > 0 )
    {
        assert( iResult == msg.GetSize() );
        ProcessMessage( msg );
        return TRUE;
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessDirectMessage()
// Desc: Checks to see if any direct messages are waiting on the direct socket.
//       If a message is waiting, it is routed and processed.
//       If no messages are waiting, the function returns immediately.
//       Returns TRUE if a message was processed.
//-----------------------------------------------------------------------------
BOOL CXBoxSample::ProcessDirectMessage()
{
    if( !m_DirectSock.IsOpen() )
        return FALSE;

    // See if a network message is waiting for us
    Message msg;
    SOCKADDR_IN saFromIn;
    INT iResult = m_DirectSock.RecvFrom( &msg, msg.GetMaxSize(), &saFromIn );
    CXBSockAddr saFrom( saFromIn );

    // If message waiting, process it
    if( iResult != SOCKET_ERROR && iResult > 0 )
    {
        assert( iResult == msg.GetSize() );
        ProcessMessage( msg, saFrom );
        return TRUE;
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessMessage()
// Desc: Routes broadcast messages
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessMessage( Message& msg )
{
    // Process the message
    switch( msg.GetId() )
    {
        // From client to host; processed by host
        case MSG_FIND_GAME:  ProcessFindGame( msg.GetFindGame() );   break;

        // From host to client: processed by client
        case MSG_GAME_FOUND: ProcessGameFound( msg.GetGameFound() ); break;

        // Any other message on this port is invalid and we ignore it
        default: assert( FALSE ); break;
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessMessage()
// Desc: Routes any direct messages
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessMessage( Message& msg, const CXBSockAddr& saFrom )
{
    // Process the message
    switch( msg.GetId() )
    {
        // From client to host; processed by host
        case MSG_JOIN_GAME:     ProcessJoinGame( msg.GetJoinGame(), saFrom ); break;

        // From host to client: processed by client
        case MSG_JOIN_APPROVED: ProcessJoinApproved( msg.GetJoinApproved(), saFrom ); break;
        case MSG_JOIN_DENIED:   ProcessJoinDenied( saFrom ); break;
        case MSG_PLAYER_JOINED: ProcessPlayerJoined( msg.GetPlayerJoined(), saFrom ); break;

        // From player to player: processed by client player
        case MSG_WAVE:          ProcessWave( saFrom ); break;
        case MSG_HEARTBEAT:     ProcessHeartbeat( saFrom ); break;

        // Any other message on this port is invalid and we ignore it
        default: assert( FALSE ); break;
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessFindGame()
// Desc: Process the find game message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessFindGame( const MsgFindGame& findGame )
{
    // If we're not hosting a game, we don't care about receiving "find game"
    // messages. Only hosts respond to "find game" messages
    if( !m_bIsHost )
        return;

    // We're hosting a game
    // Respond with the game information
    SendGameFound( findGame.nonce );
}




//-----------------------------------------------------------------------------
// Name: ProcessGameFound()
// Desc: Process the game found message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessGameFound( const MsgGameFound& gameFound )
{
    // If we're hosting, we don't care about receiving "game found" messages.
    // Only potential clients care about "game found" messages.
    if( m_bIsHost )
        return;

    // If we didn't send the corresponding "find game" message, we don't
    // care about this particular "game found" message
    if( memcmp( &gameFound.nonce, &m_Nonce, NONCE_BYTES ) != 0 )
        return;

    // We found a game!
    // Add it to our list of potential games
    GameInfo gameInfo;
    CopyMemory( &gameInfo.xnHostKeyID, &gameFound.xnHostKeyID, sizeof( XNKID ) );
    CopyMemory( &gameInfo.xnHostKey,   &gameFound.xnHostKey,   sizeof( XNKEY ) );
    CopyMemory( &gameInfo.xnHostAddr,  &gameFound.xnHostAddr,  sizeof( XNADDR ) );
    gameInfo.byNumPlayers = gameFound.byNumPlayers;
    lstrcpynW( gameInfo.strGameName, gameFound.strGameName, MAX_GAME_NAME );
    lstrcpynW( gameInfo.strHostName, gameFound.strHostName, MAX_PLAYER_NAME );

    m_Games.push_back( gameInfo );
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinGame()
// Desc: Process the join game message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessJoinGame( const MsgJoinGame& joinGame,
                                   const CXBSockAddr& saFrom )
{
    // Only hosts should receive "join game" messages
    assert( m_bIsHost );

    // If for some reason we receive a "join game" message and we're not a
    // host, ignore it. Only hosts respond to "join game" messages
    if( !m_bIsHost )
        return;

    // We're hosting

    // A session exists between us (the host) and the client. We can now
    // convert the incoming IP address (saFrom) into a valid XNADDR.
    XNADDR xnAddrClient;
    INT iResult = XNetInAddrToXnAddr( saFrom.GetInAddr(), &xnAddrClient, 
                                      &m_xnHostKeyID );
    if( iResult == SOCKET_ERROR )
    {
        // If the client INADDR can't be converted to an XNADDR, then
        // this client does not have a valid session established, and
        // we ignore the message.
        LogXNetError( "XNetInAddrToXnAddr", iResult );
        assert( FALSE );
        return;
    }

    // A player may join if we haven't reached the player limit.
    // In a real game, you would need to "lock" the game during a join
    // or track the number of joins in progress so that if multiple
    // players were attempting to join at the same time, they wouldn't
    // all be granted access and then exceed the player maximum.
    if( m_Players.size() + 1 < MAX_PLAYERS )
    {
        SendJoinApproved( saFrom );

        // Notify the other players about the new guy
        Player player;
        CopyMemory( &player.xnAddr, &xnAddrClient, sizeof( XNADDR ) );
        lstrcpynW( player.strPlayerName, joinGame.strPlayerName, MAX_PLAYER_NAME );
        for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
            SendPlayerJoined( player, CXBSockAddr( i->inAddr, DIRECT_PORT ) );

        // Add this new player to our player list
        PlayerInfo playerInfo;
        CopyMemory( &playerInfo.xnAddr, &xnAddrClient, sizeof( XNADDR ) );
        playerInfo.inAddr = saFrom.GetInAddr();
        lstrcpynW( playerInfo.strPlayerName, joinGame.strPlayerName, 
                   MAX_PLAYER_NAME );
        playerInfo.dwLastHeartbeat = GetTickCount();

        m_Players.push_back( playerInfo );

        // Update status
        wsprintfW( m_strStatus, L"%.*s has joined the game", 
                   MAX_PLAYER_NAME, player.strPlayerName );
    }
    else
    {
        SendJoinDenied( saFrom );
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinApproved()
// Desc: Process the join approved message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessJoinApproved( const MsgJoinApproved& joinApproved, 
                                       const CXBSockAddr& saFrom )
{
    // Only clients should receive "join approved" messages
    assert( !m_bIsHost );

    // If for some reason we receive a "join approved" message and we're hosting
    // a game, ignore the message. Only clients handle this message
    if( m_bIsHost )
        return;

    // Add the host to the list of players (always at position 0 )
    PlayerInfo hostInfo;

    // Client doesn't need the XNADDR of the host, so we just leave it zero.
    // This data member is only used by hosts.
    ZeroMemory( &hostInfo.xnAddr, sizeof( XNADDR ) );
    hostInfo.inAddr = saFrom.GetInAddr();
    lstrcpynW( hostInfo.strPlayerName, joinApproved.strHostName, MAX_PLAYER_NAME );
    hostInfo.dwLastHeartbeat = GetTickCount();

    assert( m_Players.empty() );
    m_Players.push_back( hostInfo );

    // Build the list of the other players
    for( BYTE i = 0; i < joinApproved.byNumPlayers; ++i )
    {
        PlayerInfo playerInfo;

        // Convert the XNADDR of the player to the INADDR we'll use to wave
        // to the player
        INT iResult = XNetXnAddrToInAddr( &joinApproved.PlayerList[ i ].xnAddr,
                                          &m_xnHostKeyID, &playerInfo.inAddr );
        if( iResult == SOCKET_ERROR )
        {
            // If the client XNADDR can't be converted to an INADDR, then
            // the client does not have a valid session established, and
            // we ignore that client.
            assert( FALSE );
            LogXNetError( "XNetXnAddrToInAddr", iResult );
            continue;
        }

        // Client doesn't need the XNADDR of the host anymore, 
        // so we just leave it zero. This data member is only used by hosts.
        ZeroMemory( &playerInfo.xnAddr, sizeof( XNADDR ) );

        // Save the player name
        lstrcpynW( playerInfo.strPlayerName, 
                   joinApproved.PlayerList[ i ].strPlayerName, MAX_PLAYER_NAME );

        // Last heartbeat
        playerInfo.dwLastHeartbeat = GetTickCount();

        m_Players.push_back( playerInfo );
    }

    // Enter into the game UI
    m_State = STATE_GAME;

    // Set the default game item to "wave"
    m_CurrItem = 0;

    lstrcpynW( m_strStatus, L"You have joined the game", MAX_STATUS_STR );
    m_HeartbeatTimer.StartZero();
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinDenied()
// Desc: Process the join denied message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessJoinDenied( const CXBSockAddr& )
{
    // Only clients should receive "join denied" messages
    assert( !m_bIsHost );

    // If for some reason we receive a "join denied" message and we're hosting
    // a game, ignore the message. Only clients handle this message
    if( m_bIsHost )
        return;

    // Only clients who are not currently playing should receive this message
    assert( m_State != STATE_GAME );

    // If for some reason we receive a "join denied" message and we're
    // already playing a game, ignore the message.
    if( m_State == STATE_GAME )
        return;

    // The game we wanted to join is full. Display error
    m_State = STATE_ERROR;
    lstrcpynW( m_strError, L"The game is full.\nChoose another game.",
               MAX_ERROR_STR );
}




//-----------------------------------------------------------------------------
// Name: ProcessPlayerJoined()
// Desc: Process the player joined message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessPlayerJoined( const MsgPlayerJoined& playerJoined, 
                                       const CXBSockAddr& saFrom )
{
    // saFrom is the address of the host that sent this message, but we
    // we already have his address, so throw it away
    (VOID)saFrom;

    const Player& player = playerJoined.player;
    PlayerInfo playerInfo;

    // Convert the XNADDR of the player to the INADDR we'll use to wave
    // to the player
    INT iResult = XNetXnAddrToInAddr( &player.xnAddr, &m_xnHostKeyID,
                                      &playerInfo.inAddr );
    if( iResult == SOCKET_ERROR )
    {
        // If the client XNADDR can't be converted to an INADDR, then
        // this client does not have a valid session established, and
        // we ignore the message.
        LogXNetError( "XNetXnAddrToInAddr", iResult );
        assert( FALSE );
        return;
    }

    // Client doesn't need the XNADDR of the host anymore, 
    // so we just leave it zero. This data member is only used by hosts.
    ZeroMemory( &playerInfo.xnAddr, sizeof( XNADDR ) );

    // Save the player name
    lstrcpynW( playerInfo.strPlayerName, player.strPlayerName, MAX_PLAYER_NAME );

    // Last heartbeat
    playerInfo.dwLastHeartbeat = GetTickCount();

    // Add the new player to our list
    m_Players.push_back( playerInfo );

    // Update status
    wsprintfW( m_strStatus, L"%.*s has joined the game", 
               MAX_PLAYER_NAME, player.strPlayerName );
}




//-----------------------------------------------------------------------------
// Name: ProcessWave()
// Desc: Process the wave message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessWave( const CXBSockAddr& saFrom )
{
    MatchInAddr matchInAddr( saFrom );

    // Find out who waved by matching the INADDR
    PlayerList::iterator i = std::find_if( m_Players.begin(), m_Players.end(), 
                                           matchInAddr );

    // We expect that we know about the player
    assert( i != m_Players.end() );

    // Update status
    if( i != m_Players.end() )
    {
        wsprintfW( m_strStatus, L"%.*s waved", 
                   MAX_PLAYER_NAME, i->strPlayerName );
    }
}


//-----------------------------------------------------------------------------
// Name: ProcessHeartbeat()
// Desc: Process the heartbeat message
//-----------------------------------------------------------------------------
VOID CXBoxSample::ProcessHeartbeat( const CXBSockAddr& saFrom )
{
    MatchInAddr matchInAddr( saFrom );

    // Find out who sent a heartbeat by matching the INADDR
    PlayerList::iterator i = std::find_if( m_Players.begin(), m_Players.end(), 
                                           matchInAddr );

    // We expect that we know about the player
    assert( i != m_Players.end() );

    // Update that player's heartbeat time
    if( i != m_Players.end() )
        i->dwLastHeartbeat = GetTickCount();
}




//-----------------------------------------------------------------------------
// Name: ProcessPlayersDropouts()
// Desc: Process players and determine if anybody has left the game
//-----------------------------------------------------------------------------
BOOL CXBoxSample::ProcessPlayerDropouts()
{
    DWORD dwTickCount = GetTickCount();
    for( PlayerList::iterator i = m_Players.begin(); i != m_Players.end(); ++i )
    {
        PlayerInfo playerInfo = *i;
        DWORD dwElapsed = dwTickCount - playerInfo.dwLastHeartbeat;
        if( dwElapsed > PLAYER_TIMEOUT )
        {
            // This player hasn't sent a heartbeat message in a long time.
            // Assume they left the game.

            wsprintfW( m_strStatus, L"%.*s left the game", 
                       MAX_PLAYER_NAME, playerInfo.strPlayerName );

            // Delete the player from the list
            m_Players.erase( i );

			//
            // Delete Voice units if you chated ... TBD more elaborate: compare if you were talking with this specific one, etc...
            //
			if(NULL != m_pVoiceUnits)
			{
				delete m_pVoiceUnits;
				m_pVoiceUnits =  NULL;
			}	
            return TRUE;
        }
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: DestroyGameList()
// Desc: Clear the list of games
//-----------------------------------------------------------------------------
VOID CXBoxSample::DestroyGameList()
{
    // Physically clear the list of games to obliterate the key and XNADDR info
    // from prying eyes. This particular method works because m_Games 
    // is a vector; if m_Games is not a vector each game must be 
    // cleared individually
    if( !m_Games.empty() )
    {
        GameInfo* pGameList = &m_Games[0];
        ZeroMemory( pGameList, m_Games.size() * sizeof( GameInfo ) );

        // Destroy the list of games
        m_Games.clear();
    }
}




//-----------------------------------------------------------------------------
// Name: DestroyPlayerList()
// Desc: Clear the list of players
//-----------------------------------------------------------------------------
VOID CXBoxSample::DestroyPlayerList()
{
    // Physically clear the list of players to obliterate the XNADDR info
    // from prying eyes. This particular method works because m_Players
    // is a vector; if m_Players is not a vector each player must be 
    // cleared individually
    if( !m_Players.empty() )
    {
        PlayerInfo* pPlayerList = &m_Players[0];
        ZeroMemory( pPlayerList, m_Players.size() * sizeof( PlayerInfo ) );

        // Destroy the list of players
        m_Players.clear();
    }
}




//-----------------------------------------------------------------------------
// Name: GenRandom()
// Desc: Generate a random name
//-----------------------------------------------------------------------------
VOID CXBoxSample::GenRandom( WCHAR* strName, DWORD dwSize ) // static
{
    // Name consists of two to five parts.
    //
    // 1) consonant or consonant group (e.g. th, qu, st) [optional]
    // 2) vowel or vowel group (e.g. ea, ee, au)
    // 3) consonant or consonant group
    // 4) vowel or vowel group [optional]
    // 5) consonant or consonant group [optional]

    WCHAR strRandom[ 128 ];
    strRandom[ 0 ] = 0;
    if( ( rand() % 2 == 0 ) )
        AppendConsonant( strRandom, TRUE );
    AppendVowel( strRandom );
    AppendConsonant( strRandom, FALSE );
    if( ( rand() % 2 == 0 ) )
    {
        AppendVowel( strRandom );
        if( ( rand() % 2 == 0 ) )
            AppendConsonant( strRandom, FALSE );
    }

    *strRandom = towupper( *strRandom );
    lstrcpynW( strName, strRandom, dwSize );
}




//-----------------------------------------------------------------------------
// Name: GetRandVowel()
// Desc: Get a random vowel
//-----------------------------------------------------------------------------
WCHAR CXBoxSample::GetRandVowel() // static
{
    for(;;)
    {
        WCHAR c = WCHAR( L'a' + ( rand() % 26 ) );
        if( wcschr( L"aeiou", c ) != NULL )
            return c;
    }
}




//-----------------------------------------------------------------------------
// Name: GetRandConsonant()
// Desc: Get a random consonant
//-----------------------------------------------------------------------------
WCHAR CXBoxSample::GetRandConsonant() // static
{
    for(;;)
    {
        WCHAR c = WCHAR( L'a' + ( rand() % 26 ) );
        if( wcschr( L"aeiou", c ) == NULL )
            return c;
    }
}




//-----------------------------------------------------------------------------
// Name: AppendConsonant()
// Desc: Append consonant or consonant group to string
//-----------------------------------------------------------------------------
VOID CXBoxSample::AppendConsonant( WCHAR* strRandom, BOOL bLeading ) // static
{
    if( ( rand() % 2 == 0 ) )
    {
        WCHAR strChar[ 2 ] = { GetRandConsonant(), 0 };
        lstrcatW( strRandom, strChar );
    }
    else
    {
        WCHAR* strLeadConGroup[32] = 
        {
            L"bl", L"br", L"cl", L"cr", L"dr", L"fl", L"fr", L"gh", L"gl", L"gn", 
            L"gr", L"kl", L"kn", L"kr", L"ph", L"pl", L"pr", L"ps", L"qu", L"sc", 
            L"sk", L"sl", L"sn", L"sp", L"st", L"sw", L"th", L"tr", L"vh", L"vl", 
            L"wh", L"zh"
        };
        WCHAR* strTrailConGroup[32] = 
        {
            L"rt", L"ng", L"bs", L"cs", L"ds", L"gs", L"hs", L"sh", L"ss", L"ks",
            L"ms", L"ns", L"ps", L"rs", L"ts", L"gh", L"ph", L"sk", L"st", L"tt",
            L"nd", L"nk", L"nt", L"nx", L"pp", L"rd", L"rg", L"rk", L"rn", L"rv",
            L"th", L"ys"
        };
        if( bLeading )
            lstrcatW( strRandom, strLeadConGroup[ rand() % 32 ] );
        else
            lstrcatW( strRandom, strTrailConGroup[ rand() % 32 ] );
    }
}




//-----------------------------------------------------------------------------
// Name: AppendVowel()
// Desc: Append vowel or vowel group to string
//-----------------------------------------------------------------------------
VOID CXBoxSample::AppendVowel( WCHAR* strRandom ) // static
{
    if( ( rand() % 2 == 0 ) )
    {
        WCHAR strChar[ 2 ] = { GetRandVowel(), 0 };
        lstrcatW( strRandom, strChar );
    }
    else
    {
        WCHAR* strVowelGroup[10] =
        {
            L"ai", L"au", L"ay", L"ea", L"ee", L"ie", L"oa", L"oi", L"oo", L"ou"
        };
        lstrcatW( strRandom, strVowelGroup[ rand() % 10 ] );
    }
}




//-----------------------------------------------------------------------------
// Name: LogXNetError()
// Desc: Log errors to the hard drive. When testing xnets.lib, there's no
//       debugging channel, so it's useful to log failures to the hard drive.
//-----------------------------------------------------------------------------
VOID CXBoxSample::LogXNetError( const CHAR* strError, INT iError ) const
{

    // Make sure that we're not logging anything in the final release
#ifndef FINAL_BUILD

    if( m_hLogFile == INVALID_HANDLE_VALUE )
    {
        m_hLogFile = CreateFile( "U:\\XNetError.log", GENERIC_WRITE, 0, NULL,
                                 CREATE_ALWAYS, 0, NULL );
        if( m_hLogFile == INVALID_HANDLE_VALUE )
            return;
    }

    // Write out the error message
    CHAR strBuffer[256];
    wsprintfA( strBuffer, "%s error: %d\r\n", strError, iError );
    DWORD dwWritten;
    WriteFile( m_hLogFile, strBuffer, lstrlenA( strBuffer ), &dwWritten, NULL );

    // Make sure the message makes it to the disk
    FlushFileBuffers( m_hLogFile );

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\chatroom\Player.h ===
#ifndef _PLAYER_H_
#define _PLAYER_H_

const DWORD MAX_PLAYER_NAME   = 12;     // Includes null

//-----------------------------------------------------------------------------
// Name: class PlayerInfo
// Desc: Player information used by players to store list of other players
//       in the game
//-----------------------------------------------------------------------------
struct PlayerInfo
{
    XNADDR  xnAddr;                           // XNet address
    IN_ADDR inAddr;                           // Xbox IP (not a "real" IP)
    WCHAR   strPlayerName[ MAX_PLAYER_NAME ]; // player name
    DWORD   dwLastHeartbeat;                  // last heartbeat, in our clocks
};

//-----------------------------------------------------------------------------
// Local Player struct used by some messages
//-----------------------------------------------------------------------------
struct Player
{
    XNADDR xnAddr;                           // player's XNet address
    WCHAR  strPlayerName[ MAX_PLAYER_NAME ]; // player's name
};

typedef std::vector< PlayerInfo >   PlayerList;

#endif // _PLAYER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\basicdplay\basicdplay.cpp ===
//-----------------------------------------------------------------------------
// File: basicdplay.cpp
//
// Desc: illustrates the absolute basics of how to get a dplay session going
//
// Note: In order for this to run correctly, the LOCALIP define must be
//       set to the IP address of the XBOX running this sample.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <dplay8.h>
#include <assert.h>

GUID g_guidApp = {0x88e835d, 0x9179, 0x485f, { 0x83, 0x43, 0x90, 0x1d, 0x32, 0x7c, 0xe7, 0x94 }};

LPDIRECTPLAY8PEER g_pHostDP;					// DirectPlay peer object for host
LPDIRECTPLAY8PEER g_pClientDP;					// DirectPlay peer object for client
LPDIRECTPLAY8ADDRESS g_pDeviceAddress;			// client device address
LPDIRECTPLAY8ADDRESS g_pHostAddress;			// client host address

BOOL g_bClientConnected = FALSE;				// connected flag

#define LOCALIP L"157.56.11.134"
#define HOSTPORT 2350							// port to host game on


//-----------------------------------------------------------------------------
// DPlay message handlers for the host and client
//-----------------------------------------------------------------------------
HRESULT WINAPI HostDPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg)
{
	switch(dwMsgType)
	{
        case DPN_MSGID_CONNECT_COMPLETE:
			OUTPUT_DEBUG_STRING( "host: connect complete\n" );
			break;

        case DPN_MSGID_CREATE_PLAYER:
			OUTPUT_DEBUG_STRING( "host: create player\n" );
			break;

        case DPN_MSGID_DESTROY_PLAYER:
			OUTPUT_DEBUG_STRING( "host: destroy player\n" );
			break;

        case DPN_MSGID_RECEIVE:
			OUTPUT_DEBUG_STRING( "host: receive\n" );
			break;
	}

	return S_OK;
}

HRESULT WINAPI ClientDPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg)
{
	switch(dwMsgType)
	{
        case DPN_MSGID_CONNECT_COMPLETE:
			OUTPUT_DEBUG_STRING( "client: connect complete\n" );
			g_bClientConnected = TRUE;
			break;

        case DPN_MSGID_CREATE_PLAYER:
			OUTPUT_DEBUG_STRING( "client: create player\n" );
			break;

        case DPN_MSGID_DESTROY_PLAYER:
			OUTPUT_DEBUG_STRING( "client: destroy player\n" );
			break;

        case DPN_MSGID_RECEIVE:
			OUTPUT_DEBUG_STRING( "client: receive\n" );
			break;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DPDoWork()
// Desc: Does DPlay processing until there is no work to be done
//-----------------------------------------------------------------------------
HRESULT DPDoWork(LPDIRECTPLAY8PEER pDP)
{
	HRESULT hr;
	DWORD time;

	time = GetTickCount();

	do
		hr = pDP->DoWork(0);
	while((GetTickCount()-time)<20);

	return hr;
}


//-----------------------------------------------------------------------------
// Name: DPInit()
// Desc: Performs essential DPlay initialization
//-----------------------------------------------------------------------------
HRESULT DPInit()
{
	HRESULT hr;
	int err;

    OUTPUT_DEBUG_STRING( "dplay: initializing\n" );

	// initialize Xnet
	err = XnetInitialize(NULL, TRUE);
	assert(err==NO_ERROR);

	// initialize DPlay
	hr = DPlayInitialize(200000);
	assert(SUCCEEDED(hr));

	// create DPlay Peer object for host and client
    hr = DirectPlay8Create(IID_IDirectPlay8Peer, (void **)&g_pHostDP, NULL);
	assert(SUCCEEDED(hr));
    hr = DirectPlay8Create(IID_IDirectPlay8Peer, (void **)&g_pClientDP, NULL);
	assert(SUCCEEDED(hr));

    // Init IDirectPlay8Peer for host and client
    hr = g_pHostDP->Initialize(NULL, HostDPMsgHandler, 0);
	assert(SUCCEEDED(hr));
    hr = g_pClientDP->Initialize(NULL, ClientDPMsgHandler, 0);
	assert(SUCCEEDED(hr));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DPHost()
// Desc: Hosts a game
//-----------------------------------------------------------------------------
HRESULT DPHost()
{
	HRESULT hr;
    DPN_PLAYER_INFO dpPlayerInfo;
    DPN_APPLICATION_DESC dnAppDesc;
	DWORD dwPort = HOSTPORT;
    DPNHANDLE hAsync;
	LPDIRECTPLAY8ADDRESS pDeviceAddress;

    OUTPUT_DEBUG_STRING( "dplay: hosting\n" );

	// set up player info for ourself as we create the game
    ZeroMemory(&dpPlayerInfo, sizeof(DPN_PLAYER_INFO));
    dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
    dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
    dpPlayerInfo.pwszName = L"Host";

	// set peer info. this is sent to all other machines via
	// the CREATE_PLAYER message
    hr = g_pHostDP->SetPeerInfo(&dpPlayerInfo, NULL, &hAsync, 0);
	assert(SUCCEEDED(hr));

    // Setup the application description
    ZeroMemory(&dnAppDesc, sizeof(DPN_APPLICATION_DESC));
    dnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = g_guidApp;
    dnAppDesc.dwMaxPlayers = 2;
    dnAppDesc.dwFlags = 0;

	// set the name of the game
    dnAppDesc.pwszSessionName = L"Basic DPlay";

	// create device address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **)&pDeviceAddress, NULL);
	assert(SUCCEEDED(hr));

    // Host a game on g_pDeviceAddress as described by dnAppDesc
	pDeviceAddress->AddComponent(DPNA_KEY_PORT, (void *)&dwPort, sizeof(dwPort), DPNA_DATATYPE_DWORD);
	assert(SUCCEEDED(hr));

	// make the call to host
    hr = g_pHostDP->Host(&dnAppDesc, &pDeviceAddress, 1, NULL, NULL, NULL, 0);
	assert(SUCCEEDED(hr));

	// release the device address
	pDeviceAddress->Release();

	return hr;
}

//-----------------------------------------------------------------------------
// Name: DPConnect()
// Desc: Connects to the hosted game
//-----------------------------------------------------------------------------
HRESULT DPConnect()
{
	HRESULT hr;
    DPNHANDLE hAsync;
	DPN_APPLICATION_DESC dnAppDesc;

    OUTPUT_DEBUG_STRING( "dplay: connecting\n" );

	// Set player info
	DPN_PLAYER_INFO dpPlayerInfo;
	ZeroMemory(&dpPlayerInfo, sizeof(DPN_PLAYER_INFO));
	dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
	dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
	dpPlayerInfo.pwszName = L"Client";

	// set the peer info for the client
	hr = g_pClientDP->SetPeerInfo(&dpPlayerInfo, NULL, &hAsync, 0);
	assert(SUCCEEDED(hr));

    // Setup the application description
    ZeroMemory(&dnAppDesc, sizeof(DPN_APPLICATION_DESC));
    dnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = g_guidApp;

	// create device address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **)&g_pDeviceAddress, NULL);
	assert(SUCCEEDED(hr));

	// create host address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **)&g_pHostAddress, NULL);
	assert(SUCCEEDED(hr));

	// build address to find the host
    g_pHostAddress->BuildAddress(LOCALIP, HOSTPORT);

	// connect to the game
	hr = g_pClientDP->Connect( 
				&dnAppDesc,						// the application description
				g_pHostAddress,					// address of the host of the session
				g_pDeviceAddress,				// address of the local device
				NULL, NULL,						// DPN_SECURITY_DESC, DPN_SECURITY_CREDENTIALS
				NULL, 0,						// user data, user data size
				NULL,							// player context,
				NULL, &hAsync,					// async context, async handle,
				0);								// flags

	assert(hr==E_PENDING || SUCCEEDED(hr));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DPSendMessage()
// Desc: Sends a message to all players in the game
//-----------------------------------------------------------------------------
HRESULT DPSendMessage(LPDIRECTPLAY8PEER pDP)
{
	HRESULT hr;
	DPN_BUFFER_DESC bufferDesc;
	DPNHANDLE hAsync;
	DWORD dwMsg;

	dwMsg = 11;
	bufferDesc.dwBufferSize = sizeof(DWORD);
	bufferDesc.pBufferData = (BYTE *)&dwMsg;

	hr = pDP->SendTo(DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1, 
			0, NULL, &hAsync, DPNSEND_NOLOOPBACK );
	assert(SUCCEEDED(hr));

    return hr;
}

//-----------------------------------------------------------------------------
// Name: DPDisconnect()
// Desc: Disconnects the client from the session
//-----------------------------------------------------------------------------
HRESULT	DPDisconnect()
{
	HRESULT hr;

    OUTPUT_DEBUG_STRING( "client: disconnecting\n" );

	hr = g_pClientDP->Close(0);
	assert(SUCCEEDED(hr));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DPTerminate()
// Desc: Terminates the session by the host
//-----------------------------------------------------------------------------
HRESULT DPTerminate()
{
	HRESULT hr;

    OUTPUT_DEBUG_STRING( "host: terminating session\n" );

	hr = g_pHostDP->TerminateSession(NULL, 0, 0);
	assert(SUCCEEDED(hr));

	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: main()
// Desc: everyone knows what main does...
//-----------------------------------------------------------------------------
void __cdecl main()
{
	// init dplay
	DPInit();

	// host a game
	DPHost();
	DPDoWork(g_pHostDP);

	// connect to hosted game
	DPConnect();

	// wait for connect to complete
	while(!g_bClientConnected)
		DPDoWork(g_pClientDP);

	// send a message from the client to the host
	DPSendMessage(g_pClientDP);
	DPDoWork(g_pClientDP);

	// send a message from the host to the client
	DPSendMessage(g_pHostDP);
	DPDoWork(g_pHostDP);

	// disconnect the client from the game
	DPDisconnect();

	// have the host terminate the session
	DPTerminate();

	// wait here a sec...
	_asm int 3;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\chatroom\ChatRoom.h ===
#pragma warning( disable: 4786 )
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBStopWatch.h>
#include <XBSocket.h>
#include <XBSockAddr.h>
#include <cassert>
#include <vector>
#include <algorithm>
#include "Resource.h"
#include "Voice.h"
#include "Player.h"




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD COLOR_HIGHLIGHT   = 0xffffff00; // Yellow
const DWORD COLOR_GREEN       = 0xff00ff00;
const DWORD COLOR_NORMAL      = 0xffffffff;
const DWORD MAX_ERROR_STR     = 64;
const DWORD MAX_STATUS_STR    = 128;
const DWORD MAX_GAME_NAMES    = 6;      // Number of game names to choose from
const DWORD NONCE_BYTES       = 8;      // Larger means less chance of random matches
const DWORD MAX_GAME_NAME     = 12;     // Includes null
const DWORD PLAYER_TIMEOUT    = 2000;   // 2 seconds
const FLOAT CHECK_LINK_STATUS = 0.5f;   // Check status twice/sec
const FLOAT PLAYER_HEARTBEAT  = 0.3f;   // ~3 times per second
const FLOAT GAME_JOIN_TIME    = 2.0f;   // 2 seconds


// TCR 3-46 Maximum Number of Connected Xboxes
const DWORD MAX_PLAYERS = 4;            // Max players (may not exceed 16)

// TCR 3-59 Session Discovery Time
const FLOAT GAME_SEARCH_TIME = 2.0f;   // 2 seconds (may not exceed 3)



//-----------------------------------------------------------------------------
// Name: class GameInfo
// Desc: Game information used by clients to store available games
//-----------------------------------------------------------------------------
struct GameInfo
{
    XNKID  xnHostKeyID;                    // host key ID
    XNKEY  xnHostKey;                      // host key
    XNADDR xnHostAddr;                     // host XNet address
    BYTE   byNumPlayers;                   // number of players in game
    WCHAR  strGameName[ MAX_GAME_NAME ];   // name of the game
    WCHAR  strHostName[ MAX_PLAYER_NAME ]; // name of the host player
};




//-----------------------------------------------------------------------------
// Name: class MatchInAddr
// Desc: Predicate functor used to match on IN_ADDRs in player lists
//-----------------------------------------------------------------------------
struct MatchInAddr
{
    IN_ADDR ia;
    explicit MatchInAddr( const CXBSockAddr& sa ) : ia( sa.GetInAddr() ) { }
    bool operator()( const PlayerInfo& playerInfo )
    {
        return playerInfo.inAddr.s_addr == ia.s_addr;
    }
};




//-----------------------------------------------------------------------------
// Message IDs
//
// A "host" is the player who started the game.
// A "client" is a potential player. A client is not currently playing a game.
// A "player" is anyone playing a game.
//-----------------------------------------------------------------------------
enum
{                       // From     To      Type        Expected response
                        //-----------------------------------------------------
    MSG_FIND_GAME,      // client   host    broadcast   MSG_GAME_FOUND
    MSG_GAME_FOUND,     // host     client  broadcast   <none>
    MSG_JOIN_GAME,      // client   host    direct      MSG_JOIN_APPROVED/DENIED
    MSG_JOIN_APPROVED,  // host     client  direct      <none>
    MSG_JOIN_DENIED,    // host     client  direct      <none>
    MSG_PLAYER_JOINED,  // host     player  direct      <none>
    MSG_WAVE,           // player   player  direct      <none>
    MSG_HEARTBEAT       // player   player  direct      <none>
	
};




//-----------------------------------------------------------------------------
// Message payloads
//-----------------------------------------------------------------------------
// Pack to minimize network traffic
#pragma pack( push )
#pragma pack( 1 )

//-----------------------------------------------------------------------------
// Local Nonce struct used by some messages
//-----------------------------------------------------------------------------
struct Nonce
{
    // Used for client verification. The larger the number of NONCE_BYTES,
    // the less likely there is to be an accidental match between client & host
    BYTE byRandom[ NONCE_BYTES ]; 
};

//-----------------------------------------------------------------------------
// Broadcast by a client looking for available games
//-----------------------------------------------------------------------------
struct MsgFindGame
{
    Nonce nonce;    // Generated by client; used to verify host response
};

//-----------------------------------------------------------------------------
// Broadcast by a host in response to a MSG_FIND_GAME
//-----------------------------------------------------------------------------
struct MsgGameFound
{
    Nonce  nonce;                          // used for client verification
    XNKID  xnHostKeyID;                    // host key ID
    XNKEY  xnHostKey;                      // host key
    XNADDR xnHostAddr;                     // host XNet address
    BYTE   byNumPlayers;                   // number of players in game
    WCHAR  strGameName[ MAX_GAME_NAME ];   // game name
    WCHAR  strHostName[ MAX_PLAYER_NAME ]; // game host player name
};

//-----------------------------------------------------------------------------
// Sent from a client to a host to join a game
//-----------------------------------------------------------------------------
struct MsgJoinGame
{
    WCHAR  strPlayerName[ MAX_PLAYER_NAME ];  // player who wants to join
};

//-----------------------------------------------------------------------------
// Sent from a host to a client in response to a MSG_JOIN_GAME
//-----------------------------------------------------------------------------
struct MsgJoinApproved
{
    WCHAR  strHostName[ MAX_PLAYER_NAME ]; // host name
    BYTE   byNumPlayers;                   // Players in the game (not incl host)
    Player PlayerList[ MAX_PLAYERS ];      // List of players (not incl host)
};

//-----------------------------------------------------------------------------
// Sent from a host to other players to notify them that a new player has joined
//-----------------------------------------------------------------------------
struct MsgPlayerJoined
{
    Player player; // The latest player to join the game
};


#pragma pack( pop )




//-----------------------------------------------------------------------------
// Name: class Message
// Desc: Message object sent between players and hosts
//-----------------------------------------------------------------------------
class Message
{
    BYTE m_byMessageId;

    union
    {
        MsgFindGame     m_FindGame;
        MsgGameFound    m_GameFound;
        MsgJoinGame     m_JoinGame;
        MsgJoinApproved m_JoinApproved;
        MsgPlayerJoined m_PlayerJoined;
    };

public:

    explicit Message( BYTE byMessageId = 0 ) : m_byMessageId( byMessageId ) {}
    ~Message() {}

    BYTE GetId() const      { return m_byMessageId; }
    INT  GetMaxSize() const { return sizeof(*this); }

    MsgFindGame&     GetFindGame()     { return m_FindGame;     }
    MsgGameFound&    GetGameFound()    { return m_GameFound;    }
    MsgJoinGame&     GetJoinGame()     { return m_JoinGame;     }
    MsgJoinApproved& GetJoinApproved() { return m_JoinApproved; }
    MsgPlayerJoined& GetPlayerJoined() { return m_PlayerJoined; }

    INT GetSize() const
    { 
        switch( m_byMessageId )
        {
            case MSG_FIND_GAME:     return sizeof(BYTE) + sizeof(MsgFindGame);
            case MSG_GAME_FOUND:    return sizeof(BYTE) + sizeof(MsgGameFound);
            case MSG_JOIN_GAME:     return sizeof(BYTE) + sizeof(MsgJoinGame);
            case MSG_JOIN_APPROVED: return sizeof(BYTE) + sizeof(MsgJoinApproved);
            case MSG_JOIN_DENIED:   return sizeof(BYTE);
            case MSG_PLAYER_JOINED: return sizeof(BYTE) + sizeof(MsgPlayerJoined);
            case MSG_WAVE:          return sizeof(BYTE);
            case MSG_HEARTBEAT:     return sizeof(BYTE);
            default: assert( FALSE ); return 0;
        }
    }

private:

    // Disabled
    Message( const Message& );
    Message& operator=( const Message& );

};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    enum State
    {
        STATE_MENU,             // Main menu
        STATE_GAME,             // Game menu
        STATE_HELP,             // Help screen
        STATE_SELECT_NAME,      // Select game name screen
        STATE_START_NEW_GAME,   // Starting new game
        STATE_GAME_SEARCH,      // Searching for game
        STATE_SELECT_GAME,      // Game selection menu
        STATE_REQUEST_JOIN,     // Joining game
        STATE_ERROR             // Error screen
    };

    enum Event
    {
        EV_BUTTON_A,
        EV_BUTTON_B,
        EV_BUTTON_BACK,
        EV_UP,
        EV_DOWN,
        EV_LEFT,
        EV_RIGHT,
        EV_DISCONNECT,
        EV_NULL
    };

    enum
    {
        // Main menu
        MAIN_MENU_START_GAME = 0,
        MAIN_MENU_JOIN_GAME  = 1,
        MAIN_MENU_MAX,

        // Game menu
        GAME_MENU_WAVE       = 0,
		GAME_MENU_VOICE      = 1,
        GAME_MENU_LEAVE_GAME = 2,
        GAME_MENU_MAX
    };

    enum InitStatus
    {
        Success,
        NotConnected,
        InitFailed
    };

    typedef std::vector< std::wstring > NameList;
    typedef std::vector< GameInfo >     GameList;

	CXBPackedResource   m_xprResource;   // app resources
    LPDIRECT3DTEXTURE8  m_ptMenuSel;     // menu selection image
    mutable HANDLE      m_hLogFile;      // Log file
    CXBFont      m_Font;                 // game font
    CXBHelp      m_Help;                 // help screen
    State        m_State;                // game state
    State        m_LastState;            // last state
    DWORD        m_CurrItem;             // current menu item
    NameList     m_GameNames;            // list of potential game names
    GameList     m_Games;                // list of available games
    PlayerList   m_Players;              // list of current players (not incl self)
    WCHAR        m_strError[ MAX_ERROR_STR ];   // error message
    WCHAR        m_strStatus[ MAX_STATUS_STR ]; // status
    CXBStopWatch m_LinkStatusTimer;      // wait to check link status
    CXBStopWatch m_GameSearchTimer;      // wait for game search to complete
    CXBStopWatch m_GameJoinTimer;        // wait for game join to complete
    CXBStopWatch m_HeartbeatTimer;       // keep-alive timer
    BOOL         m_bIsOnline;            // TRUE if link status good
    BOOL         m_bXnetStarted;         // TRUE if networking initialized
    BOOL         m_bIsHost;              // TRUE if we're hosting the game
    BOOL         m_bIsSessionRegistered; // TRUE if session key registered
    BOOL         m_bHaveLocalAddress;    // TRUE if local address acquired
    XNKID        m_xnHostKeyID;          // Host key ID
    XNKEY        m_xnHostKeyExchange;    // Host key exchange key
    XNADDR       m_xnTitleAddress;       // The XNet address of this machine/game
    IN_ADDR      m_inHostAddr;           // The "IP" address of the the host
    CXBSocket       m_BroadSock;            // Broadcast socket for broadcast msgs
    CXBSocket       m_DirectSock;           // Direct socket for direct msgs
    WCHAR        m_strGameName[ MAX_GAME_NAME ];     // Game name
    WCHAR        m_strPlayerName[ MAX_PLAYER_NAME ]; // This player name
    WCHAR        m_strHostName[ MAX_PLAYER_NAME ];   // Host player name
    Nonce        m_Nonce;                            // Client identifier


	CVoiceUnits*  m_pVoiceUnits; // The headset 

public:

    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();

    CXBoxSample();

private:

    Event GetEvent();

    VOID FrameMoveMenu( Event );
    VOID FrameMoveGame( Event );
    VOID FrameMoveHelp( Event );
    VOID FrameMoveSelectName( Event );
    VOID FrameMoveStartGame( Event );
    VOID FrameMoveGameSearch( Event );
    VOID FrameMoveSelectGame( Event );
    VOID FrameMoveRequestJoin( Event );
    VOID FrameMoveError( Event );

    VOID RenderMenu();
    VOID RenderGame();
    VOID RenderHelp();
    VOID RenderSelectName();
    VOID RenderStartGame();
    VOID RenderGameSearch();
    VOID RenderSelectGame();
    VOID RenderRequestJoin();
    VOID RenderError();
    VOID RenderHeader();
    VOID RenderMenuSelector( FLOAT, FLOAT );

    VOID InitiateJoin( DWORD );
    VOID Wave();
	VOID Voice();
    VOID Heartbeat();

    VOID Init();

    // Initialization
    InitStatus InitXNet();

    // Send messages
    VOID SendFindGame();
    VOID SendGameFound( const Nonce& );
    VOID SendJoinGame( const CXBSockAddr& );
    VOID SendJoinApproved( const CXBSockAddr& );
    VOID SendJoinDenied( const CXBSockAddr& );
    VOID SendPlayerJoined( const Player&, const CXBSockAddr& );
    VOID SendWave( const CXBSockAddr& );
    VOID SendHeartbeat( const CXBSockAddr& );
	

    // Receive messages
    BOOL ProcessBroadcastMessage();
    BOOL ProcessDirectMessage();
    VOID ProcessMessage( Message& );
    VOID ProcessMessage( Message&, const CXBSockAddr& );

    // Process incoming messages
    VOID ProcessFindGame( const MsgFindGame& );
    VOID ProcessGameFound( const MsgGameFound& );
    VOID ProcessJoinGame( const MsgJoinGame&, const CXBSockAddr& );
    VOID ProcessJoinApproved( const MsgJoinApproved&, const CXBSockAddr& );
    VOID ProcessJoinDenied( const CXBSockAddr& );
    VOID ProcessPlayerJoined( const MsgPlayerJoined&, const CXBSockAddr& );
    VOID ProcessWave( const CXBSockAddr& );
    VOID ProcessHeartbeat( const CXBSockAddr& );

    // Handle keep-alive
    BOOL ProcessPlayerDropouts();

    // Utility
    VOID DestroyGameList();
    VOID DestroyPlayerList();
    static VOID GenRandom( WCHAR*, DWORD );
    static WCHAR GetRandVowel();
    static WCHAR GetRandConsonant();
    static VOID AppendConsonant( WCHAR*, BOOL );
    static VOID AppendVowel( WCHAR* );

    VOID LogXNetError( const CHAR*, INT ) const;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\chatroom\Voice.cpp ===
#include "Voice.h"

#define DSOUND_INCLUDE_XHAWK

#define MIN(A, B)   (((A) < (B)) ? (A) : (B))


//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////

CVoiceUnit::CVoiceUnit():
        m_pMicrophone(NULL),
        m_pHeadphone(NULL),
        m_dwPortNumber(0),
        m_hMicrophoneWorkEvent(NULL),
        m_hHeadphoneWorkEvent(NULL),
        m_pBeginMicrophoneQueuedBuffers(NULL),
        m_pBeginHeadphoneQueuedBuffers(NULL),
/*#ifdef _DEBUG
		m_hFileRawPCMData(NULL) ,
		m_hFileCompressed(NULL) ,
		m_hFileDecompressed(NULL) , 
#endif*/
        m_fPreBuffering(FALSE),
        m_dwPreBufferRegions(0)
        {}

void CVoiceUnit::Cleanup()
{
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
        m_pMicrophone = NULL;
    }    

    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
        m_pHeadphone = NULL;
    }

    
    if (m_hMicrophoneWorkEvent) 
    {
        CloseHandle(m_hMicrophoneWorkEvent);
        m_hMicrophoneWorkEvent = NULL;
    }

    if (m_hHeadphoneWorkEvent) 
    {
        CloseHandle(m_hHeadphoneWorkEvent);
        m_hHeadphoneWorkEvent = NULL;
    }

    if( NULL != m_pBeginMicrophoneQueuedBuffers )
    {
		DeleteQueue(m_pBeginMicrophoneQueuedBuffers);
		m_pBeginMicrophoneQueuedBuffers = NULL;

    }

    if( NULL != m_pBeginHeadphoneQueuedBuffers )
    {
		DeleteQueue(m_pBeginHeadphoneQueuedBuffers);
        m_pBeginHeadphoneQueuedBuffers = NULL;
    }

/*#ifdef _DEBUG
	CloseFile(m_hFileRawPCMData);
	CloseFile(m_hFileCompressed);
	CloseFile(m_hFileDecompressed);
#endif*/
}

void CVoiceUnit::DeleteQueue(MEDIA_PACKET_LIST *pQueue)
{
	assert(pQueue->pNext != pQueue);

	MEDIA_PACKET_LIST *pTmpBuff = pQueue;

	pQueue = pQueue->pNext;
	pTmpBuff->pNext = NULL; //Break queue

	while(NULL != pQueue)
	{
		pTmpBuff = pQueue->pNext;
		delete pQueue;
		pQueue = pTmpBuff;
	}
}

CVoiceUnit::~CVoiceUnit()
{
    Cleanup();
}

void CVoiceUnit::CreateQueue(MEDIA_PACKET_LIST **pQueue , WORD wSize , DWORD dwStatus)
{
    MEDIA_PACKET_LIST *pTmp = NULL;
	MEDIA_PACKET_LIST *pHead = NULL;
	
    
	//
    // Create linked-list
    //
	for( int i = 0 ; i <  wSize ; i++ )
    {
		if( pTmp )
        {
			pTmp->pNext = new MEDIA_PACKET_LIST(dwStatus);
			pTmp = pTmp->pNext;
		}
		else
		{
			pTmp = new MEDIA_PACKET_LIST(dwStatus);
			pHead = pTmp;
		}
		if( NULL == pTmp )
		{
			break;
		}
    }

	if(NULL == pTmp)
	{
		//
        // Something went wrong, release allocated memory
        //
		pTmp = pHead;

		while(NULL != pTmp)
		{
			pHead = pTmp->pNext;
			delete pTmp;
			pTmp = pHead;
		}
		*pQueue = NULL;
	}
	else
	{
		//
        // Close queue
        //
		pTmp->pNext = pHead;
		*pQueue = pHead;
	}
	
}

void CVoiceUnit::Init(DWORD dwPortNumber)
{
	m_dwPortNumber = dwPortNumber;
}

void CVoiceUnit::Process()
{
    DWORD dwReason;
	HRESULT hr;

    if( NULL == m_hMicrophoneWorkEvent )
    {
        return; // No hawk inserted
    }

    for( ;; )
    {
		dwReason = WaitForSingleObject( m_hMicrophoneWorkEvent, 16);

		switch (dwReason)
		{
		case WAIT_OBJECT_0://Microphone
			hr = OnMicrophoneReadComplete();
			if(FAILED(hr))
			{
				DebugPrint("Failure OnMicrophoneReadComplete = %d\n" , hr);
				return;
			}
			else
			{
				PlayToHeadphone();	
			}
			break;
		default: //Timeout
			return;
		}
    
    }
}

void CVoiceUnit::AddSockAddr(const IN_ADDR &addrPlayer)
{
}

HRESULT CVoiceUnit::Inserted()
{
    HRESULT         hr;
    WAVEFORMATEX    wfxFormat;
    
    DebugPrint("CVoiceUnit::Inserted()...Hawk Inserted\n");

    //
    // The headset initialization
    //
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = VOICE_SAMPLING_RATE;
    wfxFormat.nAvgBytesPerSec = 2 * VOICE_SAMPLING_RATE;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.cbSize = 0;

    //
    //  Create a microphone and a headphone
    //
    DebugPrint("CVoiceUnit::Inserted()...Creating microphone...\n");
    hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, m_dwPortNumber , XVOICE_TOTAL_REGIONS,
                                 &wfxFormat, &m_pMicrophone);

    if( FAILED( hr ) )
    {
        DebugPrint("CVoiceUnit::Inserted()...Microphone failed with %x", hr);
        return hr;
    }

    DebugPrint("CVoiceUnit::Inserted()...Creating headphone...\n");
    hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, m_dwPortNumber , XVOICE_TOTAL_REGIONS,
                                 &wfxFormat, &m_pHeadphone);

    if( FAILED( hr ) )
    {
        DebugPrint("CVoiceUnit::Inserted()...Headphone failed with %x", hr);
        m_pMicrophone->Release();
        m_pMicrophone = NULL;
        return hr;
    }

    //
    // Other member initializing...
    //
    m_hMicrophoneWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hHeadphoneWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    
    m_fPreBuffering = TRUE;
    m_dwPreBufferRegions = 0;

/*#ifdef _DEBUG
	//
    // Log File for the converted signal 16kHz->8kHz
    //
	OpenFile("D:\\RawPCMData.log" , &m_hFileRawPCMData);
	
	//
    // Log File for the compressed signal
    //
	OpenFile("D:\\Compressed.log" , &m_hFileCompressed);

	//
    // Log File for the decompressed signal
    //
	OpenFile("D:\\Decompressed.log" , &m_hFileDecompressed);
#endif*/
    //
    // Create the buffers for microphone
    //
	CreateQueue(&m_pBeginMicrophoneQueuedBuffers , XVOICE_TOTAL_REGIONS , (DWORD)XMEDIAPACKET_STATUS_PENDING);
    if( NULL ==  m_pBeginMicrophoneQueuedBuffers)
    {
        DebugPrint("CVoiceUnit::Inserted()...Not enough memory for buffers!\n");
        hr = E_OUTOFMEMORY;
        return hr;
    }

    //
    // Create the buffers for headphone
    //
    CreateQueue(&m_pBeginHeadphoneQueuedBuffers , XVOICE_TOTAL_REGIONS , XMEDIAPACKET_STATUS_SUCCESS);
    if( NULL ==  m_pBeginHeadphoneQueuedBuffers)
    {
        DebugPrint("CVoiceUnit::Inserted()...Not enough memory for buffers!\n");
        hr = E_OUTOFMEMORY;
        return hr;
    }

    //
    // Feed the microphone with buffers; we enqueue all the buffers to the microphone which is going to fill 
	// them with data gradually
    //
	MEDIA_PACKET_LIST *pTmpMBuff = m_pBeginMicrophoneQueuedBuffers;
    
    for( int i = 0 ; i < XVOICE_TOTAL_REGIONS ; i++ )
    {
		
        QueueMicrophoneBuffer(pTmpMBuff);
		pTmpMBuff = pTmpMBuff->pNext;
    }

	//
    // We don't enqueue buffers to the headphone yet; this is going to be done when buffers from the microphone
	// start to arrive
    //

    return S_OK;
}

void CVoiceUnit::Removed()
{
    CVoiceUnit::Cleanup();
}

void CVoiceUnit::QueueMicrophoneBuffer(MEDIA_PACKET_LIST *pMediaPacketListEntry)
{
    XMEDIAPACKET *pMediaPacket = &(pMediaPacketListEntry->MediaPacket);

    //
    //  Setup the pointers to our status and completed size pointers
    //

    pMediaPacket->pdwCompletedSize = &(pMediaPacketListEntry->dwCompletedSize);
    pMediaPacket->pdwStatus = &(pMediaPacketListEntry->dwStatus);

    //
    //  Initialize the event 
    //

    pMediaPacket->hCompletionEvent = m_hMicrophoneWorkEvent;

    //
    //  Submit the buffer
    //
    VERIFY_SUCCESS(m_pMicrophone->Process(NULL, pMediaPacket));


}

void CVoiceUnit::QueueHeadphoneBuffer(MEDIA_PACKET_LIST *pMediaPacketListEntry)
{
    XMEDIAPACKET *pMediaPacket = &(pMediaPacketListEntry->MediaPacket);

    //
    //  Setup the pointers to our status and completed size pointers
    //

    pMediaPacket->pdwCompletedSize = &(pMediaPacketListEntry->dwCompletedSize);
    pMediaPacket->pdwStatus = &(pMediaPacketListEntry->dwStatus);

    //
    //  Initialize the event
    //
    pMediaPacket->hCompletionEvent = m_hHeadphoneWorkEvent;

    //
    //  Submit the buffer
    //
    VERIFY_SUCCESS(m_pHeadphone->Process(pMediaPacket, NULL));

}

void CVoiceUnit::SendPacketToRenderer()
{
	memcpy((m_pBeginHeadphoneQueuedBuffers->MediaPacket).pvBuffer ,
		   (m_pBeginMicrophoneQueuedBuffers->MediaPacket).pvBuffer , 
            XVOICE_BUFFER_REGION_SIZE);
	m_pBeginHeadphoneQueuedBuffers->dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
}

BOOL CVoiceUnit::IsPacketPreparedForRender()
{
	return (XMEDIAPACKET_STATUS_PENDING == m_pBeginHeadphoneQueuedBuffers->dwStatus);
}

HRESULT CVoiceUnit::OnMicrophoneReadComplete()
{
/*#ifdef _DEBUG
	static OVERLAPPED overlapped;
#endif*/
	
	HRESULT hr;
    
    //
    // One microphone buffer is filled with data
    //
	if(XMEDIAPACKET_STATUS_PENDING != m_pBeginMicrophoneQueuedBuffers->dwStatus)
    {
        if( SUCCEEDED( m_pBeginMicrophoneQueuedBuffers->dwStatus ) )
        {
/*#ifdef _DEBUG
			WriteToLogFile(m_hFileRawPCMData , (BYTE*)(m_pBeginMicrophoneQueuedBuffers->MediaPacket).pvBuffer ,
				       XVOICE_BUFFER_REGION_SIZE , &overlapped);
#endif*/
            //
            // Send the packet to the headphone
            //
			SendPacketToRenderer();
            
        }

		if( XMEDIAPACKET_STATUS_FAILURE == m_pBeginMicrophoneQueuedBuffers->dwStatus )
        {
			hr = E_FAIL;
            return hr;
        }
		else
		{
			//
			// Requeue the packet
			//  
			m_pBeginMicrophoneQueuedBuffers->dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
			QueueMicrophoneBuffer(m_pBeginMicrophoneQueuedBuffers);
			m_pBeginMicrophoneQueuedBuffers = m_pBeginMicrophoneQueuedBuffers->pNext;
		}

    }
   
    return S_OK;

}

HRESULT CVoiceUnit::PlayToHeadphone()
{
    if(IsPacketPreparedForRender())
	{
		QueueHeadphoneBuffer(m_pBeginHeadphoneQueuedBuffers);
	}

    //
    // Requeue the packet
    //  
    m_pBeginHeadphoneQueuedBuffers = m_pBeginHeadphoneQueuedBuffers->pNext;

	return (S_OK);
}

/*#ifdef _DEBUG

void CVoiceUnit::OpenFile(const char *szFileName, HANDLE *phFile)
{
	*phFile = CreateFile(szFileName,
					  GENERIC_WRITE,                // open for writing 
					  0,                            // do not share 
					  NULL,                         // no security 
					  CREATE_ALWAYS,                // overwrite existing 
					  FILE_ATTRIBUTE_NORMAL |       // normal file 
					  FILE_FLAG_OVERLAPPED,         // asynchronous I/O 
					  NULL);                        // no attr. template 

	if (*phFile == INVALID_HANDLE_VALUE) 
	{ 
		DWORD dwErr = GetLastError();
		DebugPrint("Error: %d.\n" , dwErr);  // process error 
	} 
}

void CVoiceUnit::CloseFile(HANDLE hFile)
{
	if( NULL != hFile )
    {
		// Make sure the message makes it to the disk
		FlushFileBuffers( hFile );
		CloseHandle(hFile); 
    }
}

void CVoiceUnit::WriteToLogFile(HANDLE hFile, BYTE *pbBuffer, DWORD dwSize , LPOVERLAPPED lpOverlapped)
{
static DWORD dwBytesWritten = 0;

	WriteFile( hFile,				      // handle to output file
			   pbBuffer,                      // data buffer
			   dwSize,                // number of bytes to write
			   &dwBytesWritten ,
			   lpOverlapped);

	lpOverlapped->Offset += dwBytesWritten;
}
#endif*/

//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CCompressedVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////
CCompressedVoiceUnit::CCompressedVoiceUnit() : 
                        CVoiceUnit() , 
                        m_pEncoder(NULL) , 
                        m_pDecoder(NULL) ,
                        m_hEncodeWorkEvent(NULL),
                        m_hDecodeWorkEvent(NULL),
					    m_bInPlaceCodec(FALSE)
{
	for( int i = 0 ; i < VOICE_DEVICES_COUNT ; i++ )
    {
		m_CodecMediaBuffer[i].pvBuffer = NULL;
    }
}

void CCompressedVoiceUnit::Cleanup()
{
    if(m_pEncoder)
    {
        m_pEncoder->Release();
        m_pEncoder = NULL;
    }
    if(m_pDecoder)
    {
        m_pDecoder->Release();
        m_pDecoder = NULL;
    }

	for( int i = 0 ; i < VOICE_DEVICES_COUNT ; i++ )
    {
		if( NULL != m_CodecMediaBuffer[i].pvBuffer )
		{
			delete [] m_CodecMediaBuffer[i].pvBuffer;
			m_CodecMediaBuffer[i].pvBuffer = NULL;
		}
	}
    if (m_hEncodeWorkEvent) 
    {
        CloseHandle(m_hEncodeWorkEvent);
        m_hEncodeWorkEvent = NULL;
    }

    if (m_hDecodeWorkEvent) 
    {
        CloseHandle(m_hDecodeWorkEvent);
        m_hDecodeWorkEvent = NULL;
    }

}

CCompressedVoiceUnit::~CCompressedVoiceUnit()
{
    Cleanup();
}

void CCompressedVoiceUnit::Removed()
{
    CCompressedVoiceUnit::Cleanup();

    CVoiceUnit::Removed();
}

HRESULT CCompressedVoiceUnit::Inserted()
{
    HRESULT hr;
    XMEDIAINFO      xMediaInfo;

    WAVEFORMATEX wfxFormat;
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = VOICE_SAMPLING_RATE;
    wfxFormat.nAvgBytesPerSec = 2 * VOICE_SAMPLING_RATE;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.cbSize = 0;
    
    hr = CVoiceUnit::Inserted();

    if( FAILED( hr ) )
    {
        DebugPrint("CCompressedVoiceUnit::Inserted()...Base class Inserted() failed!\n");
        return hr;
    }

    DebugPrint("Creating voice encoder...\n");

    hr = XVoiceEncoderCreateMediaObject( FALSE, // manual mode
                                         WAVE_FORMAT_VOXWARE_SC06,
                                         &wfxFormat,
                                         20, // voice activation threshold
                                         &m_pEncoder );

    if( FAILED( hr ) )
    {
        DebugPrint("CCompressedVoiceUnit::Inserted()...Voice encoder failed with %x", hr);
        return hr;
    }

    DebugPrint(("Creating voice decoder...\n"));

    hr = XVoiceDecoderCreateMediaObject( 0, // zero latency
                                         WAVE_FORMAT_VOXWARE_SC06,
                                         &wfxFormat,
                                         &m_pDecoder );
    if( FAILED( hr ) )
    {
        DebugPrint("CCompressedVoiceUnit::Inserted()...Voice decoder failed with %x", hr);
        m_pEncoder->Release();
        m_pEncoder = NULL;
        return hr;
    }

                
    //
    // If the codec XMOs are in place don't pass a DST temp buffer...
    //

    m_pEncoder->GetInfo( &xMediaInfo );

    if (xMediaInfo.dwFlags & XMO_STREAMF_IN_PLACE) 
    {
        DebugPrint("CCompressedVoiceUnit::Inserted()...Encoder %x is in place\n", m_pEncoder);
		m_bInPlaceCodec = TRUE;

    } 
    else 
    {
		for( int i = 0 ; i < VOICE_DEVICES_COUNT ; i++ )
		{
			memset(&(m_CodecMediaBuffer[i]), 0, sizeof(XMEDIAPACKET));

			m_CodecMediaBuffer[i].dwMaxSize = XVOICE_CODEC_BUFFER_SIZE;
			m_CodecMediaBuffer[i].pvBuffer = new BYTE[XVOICE_CODEC_BUFFER_SIZE];
			assert(m_CodecMediaBuffer[i].pvBuffer);

		}
        DebugPrint("CCompressedVoiceUnit::Inserted()...Codec xmos are not in place, using temp buffer\n");
    }

    m_hEncodeWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hDecodeWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    return S_OK;
}

HRESULT CCompressedVoiceUnit::OnMicrophoneReadComplete()
{
	BOOL bVoiceDetected = TRUE;

/*#ifdef _DEBUG
	static OVERLAPPED overlapped;
#endif*/


	HRESULT hr;
    
	//
	// One microphone buffer is filled with data
	//
	if(XMEDIAPACKET_STATUS_PENDING != m_pBeginMicrophoneQueuedBuffers->dwStatus)
	{
		if( SUCCEEDED( m_pBeginMicrophoneQueuedBuffers->dwStatus ) )
		{
/*#ifdef _DEBUG
			WriteToLogFile(m_hFileRawPCMData , (BYTE*)(m_pBeginMicrophoneQueuedBuffers->MediaPacket).pvBuffer ,
						   XVOICE_BUFFER_REGION_SIZE , &overlapped);
#endif*/

			//
			// 1. Compress media buffer
			//
			CompressMediaBuffer(&m_pBeginMicrophoneQueuedBuffers->MediaPacket ,
					            &m_CodecMediaBuffer[MICROPHONE] , &bVoiceDetected);
			memset((m_pBeginMicrophoneQueuedBuffers->MediaPacket).pvBuffer , 0 , XVOICE_BUFFER_REGION_SIZE); 


			if(bVoiceDetected)
			{
				//
				// 2. Prepare the packet for the output device (headphone)
				//
				SendPacketToRenderer();
			}
										
		}

		if( XMEDIAPACKET_STATUS_FAILURE == m_pBeginMicrophoneQueuedBuffers->dwStatus )
        {
			hr = E_FAIL;
            return hr;
        }
		else
		{
			//
			// Requeue the packet
			//  
			m_pBeginMicrophoneQueuedBuffers->dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
			QueueMicrophoneBuffer(m_pBeginMicrophoneQueuedBuffers);
			m_pBeginMicrophoneQueuedBuffers = m_pBeginMicrophoneQueuedBuffers->pNext;
		}
	}

    return S_OK;
}

HRESULT CCompressedVoiceUnit::PlayToHeadphone()
{

	if(IsPacketPreparedForRender())    
	{
		//
		// 1. Decompress media buffer
		//
		DecompressMediaBuffer(&m_CodecMediaBuffer[HEADPHONE] , &m_pBeginHeadphoneQueuedBuffers->MediaPacket);

		//
		// 2. Send it to the headphone
		//
       	QueueHeadphoneBuffer(m_pBeginHeadphoneQueuedBuffers);
	}

    //
    // Requeue the packet
    //  
    m_pBeginHeadphoneQueuedBuffers = m_pBeginHeadphoneQueuedBuffers->pNext;

	return (S_OK);
}

HRESULT CCompressedVoiceUnit::CompressMediaBuffer(XMEDIAPACKET *pSrc, XMEDIAPACKET *pDst , BOOL *pvbVoiceDetected)
{
    HRESULT hr;
    DWORD dwSizeSrc = 0; 
    DWORD dwSizeDst = 0; 

/*#ifdef _DEBUG
	static OVERLAPPED overlapped;
#endif*/

    memset(pDst->pvBuffer, 0 , XVOICE_CODEC_BUFFER_SIZE);

    pDst->pdwCompletedSize = &dwSizeDst;
    pDst->hCompletionEvent = m_hEncodeWorkEvent;

    if( m_bInPlaceCodec )
    {
		//
		// Call encoding xmo
		//
		memcpy(pDst->pvBuffer , pSrc->pvBuffer , pSrc->dwMaxSize);
		hr = m_pEncoder->Process(NULL , pDst);

    }
	else
	{
	    //
	    // Call encoding xmo
		//
		pSrc->pdwCompletedSize = &dwSizeSrc;
		hr = m_pEncoder->Process( pSrc , pDst);
	}

    assert(!FAILED(hr));
    
    WaitForSingleObject(m_hEncodeWorkEvent , INFINITE);

/*#ifdef _DEBUG
	WriteToLogFile(m_hFileCompressed , (BYTE*)pDst->pvBuffer , dwSizeDst , &overlapped);
#endif*/

    if( dwSizeDst == sizeof(VOICE_ENCODER_HEADER) )
    {
		*pvbVoiceDetected = FALSE;
    }
	else
	{
		*pvbVoiceDetected = TRUE;
	}
    return( hr );
}

HRESULT CCompressedVoiceUnit::DecompressMediaBuffer(XMEDIAPACKET *pSrc, XMEDIAPACKET *pDst)
{
    HRESULT hr;
    DWORD dwSizeSrc = 0; 
    DWORD dwSizeDst = 0; 

/*#ifdef _DEBUG
	static OVERLAPPED overlapped;
#endif*/
    
    memset(pDst->pvBuffer , 0 , pDst->dwMaxSize);


    pDst->pdwCompletedSize = &dwSizeDst;
    pDst->hCompletionEvent = m_hDecodeWorkEvent;

    if( m_bInPlaceCodec )
    {
		//
		// Call decoding xmo
		//
		memcpy(pDst->pvBuffer , pSrc->pvBuffer , pSrc->dwMaxSize);
		hr = m_pDecoder->Process(NULL , pDst);

    }
	else
	{
	    //
	    // Call decoding xmo
		//
		pSrc->pdwCompletedSize = &dwSizeSrc;
		hr = m_pDecoder->Process( pSrc , pDst);
	}
    
    assert(!FAILED(hr));

    WaitForSingleObject(m_hDecodeWorkEvent , INFINITE);

/*#ifdef _DEBUG
	WriteToLogFile(m_hFileDecompressed , (BYTE*)pDst->pvBuffer , dwSizeDst , &overlapped);
#endif*/

    return( hr );
}

void CCompressedVoiceUnit::SendPacketToRenderer()
{
	m_pBeginHeadphoneQueuedBuffers->dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
	memcpy(m_CodecMediaBuffer[HEADPHONE].pvBuffer , m_CodecMediaBuffer[MICROPHONE].pvBuffer , XVOICE_CODEC_BUFFER_SIZE);
	memset(m_CodecMediaBuffer[MICROPHONE].pvBuffer , 0 , XVOICE_CODEC_BUFFER_SIZE);
}

BOOL CCompressedVoiceUnit::IsPacketPreparedForRender()
{
	return(XMEDIAPACKET_STATUS_PENDING == m_pBeginHeadphoneQueuedBuffers->dwStatus);
}

//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CNetVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////
CNetVoiceUnit::CNetVoiceUnit() : CCompressedVoiceUnit() ,
                                 m_VoiceSock(INVALID_SOCKET),
                                 m_vSockAddrDests(),
                                 m_pVoiceQueuingXMO(NULL),
                                 m_fSubmixPacket(FALSE),
                                 m_LastNetReceiveTimeStamp(0)
{
    ZeroMemory(&m_saLastNetReceiveSockAddr, sizeof(SOCKADDR_IN));
}

void CNetVoiceUnit::Cleanup()
{
    if( INVALID_SOCKET != m_VoiceSock )
    {
        closesocket( m_VoiceSock );
        m_VoiceSock = INVALID_SOCKET;
    }

    if( NULL != m_pVoiceQueuingXMO )
    {
        m_pVoiceQueuingXMO->Release();
        m_pVoiceQueuingXMO = NULL;
    }
}

CNetVoiceUnit::~CNetVoiceUnit()
{
    Cleanup();
}

void CNetVoiceUnit::AddSockAddr(const IN_ADDR &addrPlayer)
{
  SOCKADDR_IN SockAddrDest;
	SockAddrDest.sin_family = AF_INET;
  SockAddrDest.sin_addr = addrPlayer;
  SockAddrDest.sin_port = htons(VOICE_PORT);
  m_vSockAddrDests.push_back(SockAddrDest);
}

void CNetVoiceUnit::Removed()
{
    CNetVoiceUnit::Cleanup();

    CCompressedVoiceUnit::Removed();
}


HRESULT CNetVoiceUnit::Inserted()
{
    HRESULT hr;
    
	//
    // Base class initialization
    //
    hr = CCompressedVoiceUnit::Inserted();

    if( FAILED( hr ) )
    {
        DebugPrint("CNetVoiceUnit::Inserted()...Base class Inserted() failed!\n");
        return hr;
    }

	//
    // Network stuff initialization
    //
    m_VoiceSock = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if( INVALID_SOCKET ==  m_VoiceSock )
    {
        hr = WSAGetLastError();
        DebugPrint("CNetVoiceUnit::Inserted()...Voice socket open; error = %x\n", hr);
        return hr;
    }

    SOCKADDR_IN voiceAddr;
	voiceAddr.sin_family = AF_INET;
	voiceAddr.sin_addr.s_addr = /*htonl(*/INADDR_ANY;
	voiceAddr.sin_port = htons( VOICE_PORT );
    int iResult = bind( m_VoiceSock, (const sockaddr*)(&voiceAddr), sizeof( SOCKADDR_IN ) );
    if(iResult == SOCKET_ERROR)
    {
       hr = WSAGetLastError();
       DebugPrint( "CNetVoiceUnit::Inserted()...Voice socket open; error = %x\n", hr);
       return hr;
    }

	DWORD dwNonBlocking = 1;
	iResult = ioctlsocket(m_VoiceSock , FIONBIO, &dwNonBlocking );
	if(iResult == SOCKET_ERROR)
	{
       hr = WSAGetLastError();
       DebugPrint( "CNetVoiceUnit::Inserted()...Voice socket open; error = %x\n", hr);
       return hr;
	}

	//
    // Voice queuing initialization - use defaults
    //
    QueueXMOConfig config;
    
	memset(&config , 0 , sizeof(config));
	config.cbSize = sizeof(config);
    
	hr = XQueueCreateMediaObject(&config , &m_pVoiceQueuingXMO);
	
	if( FAILED( hr ) )
    {
		DebugPrint("CNetVoiceUnit::Inserted()...Voice queuing initialization failed; error = %x\n", hr);
        return hr;
    }

	//
    // Output is requested from the queuing XMO only if m_IntervalForOutput time has elapsed
	//
	m_IntervalForOutput = config.wMsOfDataPerPacket / 2;
	m_LastOutputTimeStamp = GetTickCount();

    return S_OK;
}


HRESULT CNetVoiceUnit::PlayToHeadphone()
{
    HRESULT hr = E_FAIL; // S_OK = Means decompression OK


    if(IsPacketPreparedForRender())    
    {
        //
        // 1. Call the queuing system with the codec buffer as input
        //
        hr = m_pVoiceQueuingXMO->Process(&m_CodecMediaBuffer[HEADPHONE] , &m_pBeginHeadphoneQueuedBuffers->MediaPacket);

    }
    else
    {
        //
        // 1. Call for output only if the interval elapsed
        //
        if(GetTickCount() - m_LastOutputTimeStamp >= m_IntervalForOutput)
        {
            hr = m_pVoiceQueuingXMO->Process(NULL , &m_pBeginHeadphoneQueuedBuffers->MediaPacket);
        }
    }

#ifdef SUBMIX_VOICES
    if(GetTickCount() - m_LastOutputTimeStamp >= m_IntervalForOutput)
    {
        QueueHeadphoneBuffer(NULL);
        m_LastOutputTimeStamp = GetTickCount();
    }
#endif
    
    if(SUCCEEDED(hr))
    {
        QueueHeadphoneBuffer(m_pBeginHeadphoneQueuedBuffers);
        m_LastOutputTimeStamp = GetTickCount();
    }

    //
    // Requeue the packet
    //  
    m_pBeginHeadphoneQueuedBuffers = m_pBeginHeadphoneQueuedBuffers->pNext;

    return (S_OK);
}


void CNetVoiceUnit::SendPacketToRenderer()
{
	SendVoicePacket( &m_CodecMediaBuffer[MICROPHONE] );
}

BOOL CNetVoiceUnit::IsPacketPreparedForRender()
{
	return RecvVoicePacket(&m_CodecMediaBuffer[HEADPHONE]);
}

void CNetVoiceUnit::SendVoicePacket( XMEDIAPACKET *pMediaPacket )
{
	int nBytes = 0, nListSize = m_vSockAddrDests.size();
  
  for(int i = 0; i < nListSize; ++i)
  {
    nBytes = sendto(m_VoiceSock , (const char*)pMediaPacket->pvBuffer, XVOICE_CODEC_BUFFER_SIZE,
                    0, (const sockaddr*)(&(m_vSockAddrDests[i])), sizeof(SOCKADDR_IN));
  }

	DebugPrint("Sent: %d bytes\n" , nBytes);
  assert(nBytes == XVOICE_CODEC_BUFFER_SIZE);
}

BOOL CNetVoiceUnit::RecvVoicePacket( XMEDIAPACKET *pMediaPacket )
{

    // See if a voice message is waiting for us
    SOCKADDR_IN saFromIn;
    int iSize = sizeof( SOCKADDR_IN );
    memset(pMediaPacket->pvBuffer , 0 , XVOICE_CODEC_BUFFER_SIZE);
    int iResult = recvfrom( m_VoiceSock , (char*)pMediaPacket->pvBuffer, XVOICE_CODEC_BUFFER_SIZE, 
                            0, (sockaddr*)(&saFromIn), &iSize );
    DWORD dwTimeStamp = GetTickCount();
    

    // If message waiting, process it
    if( iResult != SOCKET_ERROR && iResult > 0 )
    {
        DebugPrint("Recv: %d bytes\n", iResult);

        // If the two sockaddrs are different, then they may need to be submixed..
        if(memcmp(&m_saLastNetReceiveSockAddr, &saFromIn, sizeof(SOCKADDR_IN)) && (dwTimeStamp - m_LastNetReceiveTimeStamp) < SUBMIX_THRESHOLD_TIME)
        {
            m_fSubmixPacket = TRUE;
        }
        else
        {
            m_fSubmixPacket = FALSE;
        }

        m_LastNetReceiveTimeStamp = dwTimeStamp;
        memcpy(&m_saLastNetReceiveSockAddr, &saFromIn, sizeof(SOCKADDR_IN));
        return TRUE;
    }

	DebugPrint("Recv Error: %d \n" , WSAGetLastError());
    return FALSE;
}

void CNetVoiceUnit::SubmixMediaPackets(PVOID pSrc, PVOID pDest, DWORD dwBytes, DWORD dwAmpFactor)
{
    DWORD dwSamples = dwBytes / 2;
    short* pSampSrc = (short*)pSrc;
    short* pSampDest = (short*)pDest;

    while(dwSamples--)
    {
        int sample = int(*pSampSrc++) * int(dwAmpFactor) / 0xffff;
        int mixedSample = sample + *pSampDest;

        if(mixedSample > 32767)
        {
            mixedSample = 32767;
        }
        else if(mixedSample < -32768)
        {
            mixedSample = -32768;
        }

        *pSampDest++ = short(mixedSample);
    }
}


void CNetVoiceUnit::QueueHeadphoneBuffer(MEDIA_PACKET_LIST *pMediaPacketListEntry)
{
#ifdef SUBMIX_VOICES
    static XMEDIAPACKET mpMixedPacket = {0};

    if(!pMediaPacketListEntry)
    {
        // Check if m_MixedPacket has valid data
        // If so, push it out to the headphone
        // and return
        if(mpMixedPacket.dwMaxSize && mpMixedPacket.pvBuffer)
        {
            VERIFY_SUCCESS(m_pHeadphone->Process(&mpMixedPacket, NULL));
            free(mpMixedPacket.pvBuffer);
            ZeroMemory(&mpMixedPacket, sizeof(XMEDIAPACKET));
            DebugPrint("Flushed headphone buffer\n");
        }

        return;
    }

    // Update the status and completed size pointers
    mpMixedPacket.pdwCompletedSize = &(pMediaPacketListEntry->dwCompletedSize);
    mpMixedPacket.pdwStatus = &(pMediaPacketListEntry->dwStatus);
    mpMixedPacket.hCompletionEvent = m_hHeadphoneWorkEvent;

    if(!m_fSubmixPacket)
    {
        XMEDIAPACKET *pMediaPacket = &(pMediaPacketListEntry->MediaPacket);

        // Push out mpMixedPacket before saving this
        QueueHeadphoneBuffer(NULL);

        mpMixedPacket.pvBuffer = realloc(mpMixedPacket.pvBuffer, pMediaPacket->dwMaxSize);
        mpMixedPacket.dwMaxSize = pMediaPacket->dwMaxSize;
        memcpy(mpMixedPacket.pvBuffer, pMediaPacket->pvBuffer, pMediaPacket->dwMaxSize);
    }
    else
    {
        // Mix the incoming packet with the old packet
        // If new one is larger, extend the old packet, and
        // zero out the extended portion before mixing.
        // After extending, just mix up to the min of the two sizes
        // TODO: Place limit on number of packets mixed together?
        // Should be proportional to size of packets / number of players...
        XMEDIAPACKET *pOldPacket = &(mpMixedPacket), *pNewPacket = &(pMediaPacketListEntry->MediaPacket);

        if(pNewPacket->dwMaxSize > pOldPacket->dwMaxSize)
        {
            pOldPacket->pvBuffer = realloc(pOldPacket->pvBuffer, pNewPacket->dwMaxSize);
            ZeroMemory((BYTE *)(pOldPacket->pvBuffer) + pOldPacket->dwMaxSize, pNewPacket->dwMaxSize - pOldPacket->dwMaxSize);
            pOldPacket->dwMaxSize = pNewPacket->dwMaxSize;
        }

        SubmixMediaPackets(pNewPacket->pvBuffer, pOldPacket->pvBuffer, MIN(pNewPacket->dwMaxSize, pOldPacket->dwMaxSize), 0xffff);
    }
#else
    XMEDIAPACKET *pMediaPacket = &(pMediaPacketListEntry->MediaPacket);

    //
    //  Setup the pointers to our status and completed size pointers
    //

    pMediaPacket->pdwCompletedSize = &(pMediaPacketListEntry->dwCompletedSize);
    pMediaPacket->pdwStatus = &(pMediaPacketListEntry->dwStatus);

    //
    //  Initialize the event
    //
    pMediaPacket->hCompletionEvent = m_hHeadphoneWorkEvent;

    //
    //  Submit the buffer
    //
    VERIFY_SUCCESS(m_pHeadphone->Process(pMediaPacket, NULL));
#endif
}


//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CVoiceUnits that tracks multiple hawk units
//
//////////////////////////////////////////////////////////////////////////////

CVoiceUnits::CVoiceUnits()
{   
    for(int i=0; i<HAWKS_COUNT; i++)
    {
        m_VoiceUnits[i].Init( i );
    }        

    m_hThread = NULL;

    m_hDeleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    m_hMutex = NULL;
    m_dwThreadId = 0;

}

CVoiceUnits::~CVoiceUnits()
{
    //
    // set the delete event
    //

    if (m_hDeleteEvent) 
    {
        SetEvent(m_hDeleteEvent);
    }
 
    //
    // wait on thread exiting..
    //

    if (m_hThread) 
    {
        WaitForSingleObject(m_hThread,INFINITE);
    }

    assert(m_dwThreadId == 0);

    if (m_hMutex) 
    {
        CloseHandle(m_hMutex);
    }
 
    if (m_hDeleteEvent) 
    {
        CloseHandle(m_hDeleteEvent);
    }

    if (m_hThread) 
    {
        CloseHandle(m_hThread);
    }

}


DWORD WINAPI VoiceThreadProc(
    LPVOID pParameter
    )
{
    CVoiceUnits *pThis = (CVoiceUnits *) pParameter;
    pThis->ThreadProc();

    return 0;
}

void CVoiceUnits::ThreadProc()
{
    int i;
    HRESULT hr =S_OK;


    DebugPrint("CVoiceUnits::ThreadProc()...Built on %s at %s\n", __DATE__, __TIME__);

    //
    // Verify the initial state of the voice devices
    //
    hr = CheckInitialState();

    if( SUCCEEDED( hr ) )
    {
        //
        //  Now loop forever
        //
        for( ;; )
        {
            //
            // Start the processing for each of the hawks(give every one of them a chance to work...)
            //
            for( i = 0 ; i < HAWKS_COUNT ; i++ )
            {
                m_VoiceUnits[i].Process();
            }
        
            //
            //  Wait until something happens, or 16 ms, whichever is first
            //
            DWORD dwReason = WaitForSingleObject(m_hDeleteEvent, 16);

            if (WAIT_OBJECT_0 == dwReason) 
            {

                //
                // The thread needs to be deleted
                //
                DebugPrint("CVoiceUnits::ThreadProc()... Leaving thread\n");
                break;

            }

            //
            //  Always check for hot-plugs
            //
            hr = CheckForHotPlugs();
            if( FAILED( hr ) )
            {
                break;
            }

        } //end of infinite loop

    }
    

    m_dwThreadId = 0;
    ExitThread(0);

}


HRESULT CVoiceUnits::Initialize(PlayerList& playerlist)
{

    HRESULT hr = S_OK;
    
    //
    // initialize synchronization object
    //

    m_hMutex = CreateMutex(NULL, FALSE, NULL);

    if (m_hMutex == NULL) 
    {
        DebugPrint("CVoiceUnits::Initialize()... Thread creation failed..");
        hr = E_FAIL;
        return hr;
    }

    for(int i=0; i < HAWKS_COUNT; i++)
    {
        for(PlayerList::iterator j = playerlist.begin(); j != playerlist.end(); ++j)
        {
            m_VoiceUnits[i].AddSockAddr( CXBSockAddr(j->inAddr, VOICE_PORT).GetInAddr() );
        }
    }        

    //
    // we are initialized ok. Now create the thread 
    //
    m_hThread = CreateThread(NULL,
                             0,
                             VoiceThreadProc,
                             this,
                             0,
                             &m_dwThreadId);

    if (m_hThread == NULL) 
    {
        DebugPrint("CVoiceUnits::Initialize()... Thread creation failed..");
        hr = E_FAIL;
        return hr;
    }

    return( hr );
        
}

HRESULT CVoiceUnits::CheckInitialState()
{
    DWORD dwConnectedMicrophones;
    DWORD dwConnectedHeadphones;
    
    HRESULT hr = S_OK;
    
    //
    //  Get the initial connected state of the devices
    //

    dwConnectedMicrophones = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    dwConnectedHeadphones = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
    if( dwConnectedMicrophones != dwConnectedHeadphones)
    {
        DebugPrint("CVoiceUnits::CheckInitialState()...dwConnectedMicrophones != dwConnectedHeadphone\n");
        hr = E_FAIL;
        return hr;
    }

    if((0 == dwConnectedMicrophones) || (0 == dwConnectedHeadphones))
    {
        DebugPrint("CVoiceUnits::CheckInitialState()... No hawk found!\n");
        hr = E_FAIL;
        return hr;
    }

    for(int i = 0 ; i < HAWKS_COUNT ; i++ )
    {
        if(dwConnectedMicrophones&(1<<i))
        {
            if(!SUCCEEDED(m_VoiceUnits[i].Inserted()))
            {
                DebugPrint("CVoiceUnits::CheckInitialState()...Voice unit initialization failed!\n");
                hr = E_FAIL;
                return hr;
            }
            else
            {
                DebugPrint("CVoiceUnits::CheckInitialState()...Voice unit %d initialized\n" , i);
            }
        }
    }
    
    return( hr );
}

HRESULT CVoiceUnits::CheckForHotPlugs()
{
    DWORD dwMicrophoneInsertions, dwHeadphoneInsertions;
    DWORD dwMicrophoneRemovals, dwHeadphoneRemovals;

    HRESULT hr;
    
    if(XGetDeviceChanges(XDEVICE_TYPE_VOICE_MICROPHONE, &dwMicrophoneInsertions, &dwMicrophoneRemovals))
    {
        if(!XGetDeviceChanges(XDEVICE_TYPE_VOICE_HEADPHONE, &dwHeadphoneInsertions, &dwHeadphoneRemovals))
        {
            DebugPrint("CVoiceUnits::CheckForHotPlugs()...GetDeviceChanges does not match\n");
            hr = E_FAIL;
            return hr;
        }

        if( (dwMicrophoneInsertions != dwHeadphoneInsertions) ||
            (dwMicrophoneRemovals != dwHeadphoneRemovals))
        {
            DebugPrint("CVoiceUnits::CheckForHotPlugs()...GetDeviceChanges does not match, different\n");
            hr = E_FAIL;
            return hr;
        }

        //
        //  Loop over all the ports
        //
        for(int i = 0 ; i < HAWKS_COUNT ; i++ )
        {
            //
            //  Handle Removal, if there is one.
            //

            if(dwMicrophoneRemovals&(1<<i))
            {
                m_VoiceUnits[i].Removed();
            }

            //
            //  Handle Insertion, if there is one.
            //
			
            if(dwMicrophoneInsertions&(1<<i))
            {
                m_VoiceUnits[i].Inserted();
            }
        } //end of loop over ports

    }  //end of check for getting device changes
     
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\ChangeTitleId.cpp ===
// Do *not* ship this code to external developers!
// Microsoft Confidential and private

// Dirty way to get and change title ID

// This code can be useful for testing online access

struct CT // First portion of certification struct
{
    ULONG a;
    ULONG b;
    ULONG dwTitleID;
};
typedef CT* PCT;

struct HDR // First portion of XBE header
{
    ULONG a;
    UCHAR b[256];
    ULONG c;
    ULONG d;
    ULONG e;
    ULONG f;
    ULONG g;
    PCT   ct;
};

// Location of XBE header
#define XeImageHeader() ((struct HDR*)0x00010000)

// Dirty way to change title ID
// XeImageHeader()->ct->dwTitleID = dwTitleID;

// Dirty way to get title ID
// DWORD dwTitleID = XeImageHeader()->ct->dwTitleID;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\chatroom\Voice.h ===
#ifndef VOICE_H_INCLUDED
#define VOICE_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <XBSocket.h>
#include <XBSockAddr.h>
#include <cassert>
#include <stdio.h>
#include <vector>
#include "xvoice.h"
#include "Player.h"

const WORD  VOICE_PORT        = 10985;  // any port other than the first two

const int VOICE_SAMPLING_RATE = 8000;
const int CODEC_SAMPLING_RATE = 8000;

const int XVOICE_BYTES_PER_MS = (((ULONG)( VOICE_SAMPLING_RATE / 1000.0 )) * 2 );

const int XVOICE_BUFFER_REGION_TIME = 40; // initially 80, but changed in order to fit a network packet 
const int XVOICE_BUFFER_REGION_SIZE = ( XVOICE_BYTES_PER_MS * XVOICE_BUFFER_REGION_TIME );
const int XVOICE_PREBUFFER_REGIONS = 20;
const int XVOICE_TOTAL_REGIONS = ( XVOICE_PREBUFFER_REGIONS + 2 );
const int XVOICE_BUFFER_SIZE = ( XVOICE_BUFFER_REGION_SIZE * XVOICE_TOTAL_REGIONS );

const int HAWKS_COUNT = 4;
const int VOICE_DEVICES_COUNT = 2; //Microphone & Headphone
const int MICROPHONE = 0;
const int HEADPHONE = 1;


const int MAX_VOICE_TRANSFER_SIZE = XVOICE_BUFFER_REGION_SIZE + sizeof(VOICE_ENCODER_HEADER);
const int XVOICE_CODEC_BUFFER_SIZE = XVOICE_BUFFER_REGION_SIZE / 4 + sizeof(VOICE_ENCODER_HEADER);

const DWORD SUBMIX_THRESHOLD_TIME = 100;


//////////////////////////////////////////////////////////////////////////////
// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}
//////////////////////////////////////////////////////////////////////////////

struct MEDIA_PACKET_LIST
{
	MEDIA_PACKET_LIST	*pNext;
	XMEDIAPACKET		MediaPacket;
	DWORD				dwStatus;
	DWORD				dwCompletedSize;

	MEDIA_PACKET_LIST(DWORD dwStatusIn) : pNext(NULL) , dwStatus(dwStatusIn) , dwCompletedSize(0)
	{
		MediaPacket.dwMaxSize = XVOICE_BUFFER_REGION_SIZE;
		MediaPacket.pvBuffer = new BYTE[XVOICE_BUFFER_REGION_SIZE];
		memset(MediaPacket.pvBuffer , 0 , XVOICE_BUFFER_REGION_SIZE);
		MediaPacket.pdwCompletedSize = NULL;
		MediaPacket.pdwStatus = NULL;
		MediaPacket.prtTimestamp = NULL;
		MediaPacket.hCompletionEvent = NULL;
	}
	~MEDIA_PACKET_LIST()
	{
		if( NULL !=  MediaPacket.pvBuffer)
        {
			delete [] MediaPacket.pvBuffer;
        }
	}
};

//
// CVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////
class CVoiceUnit
{
public:
	virtual HRESULT PlayToHeadphone();
	virtual HRESULT OnMicrophoneReadComplete();
	
	virtual void AddSockAddr(const IN_ADDR &addrPlayer);

	virtual HRESULT Inserted();
	virtual void Removed();
	virtual void Process();
	virtual void Init(DWORD dwPortNumber);

	virtual void SendPacketToRenderer();
	virtual BOOL IsPacketPreparedForRender();

    CVoiceUnit(); 
    virtual ~CVoiceUnit();


protected:
	void CreateQueue(MEDIA_PACKET_LIST **pQueue , WORD wSize , DWORD dwStatus);
	void DeleteQueue(MEDIA_PACKET_LIST *pQueue);
/*#ifdef _DEBUG
	void WriteToLogFile(HANDLE hFile , BYTE *pbBuffer , DWORD dwSize , LPOVERLAPPED lpOverlapped);
	void CloseFile(HANDLE hFile);
	void OpenFile(const char* szFileName , HANDLE *phFile);
#endif*/
	virtual void QueueMicrophoneBuffer(MEDIA_PACKET_LIST *pMediaPacketListEntry);
	virtual void QueueHeadphoneBuffer(MEDIA_PACKET_LIST *pMediaPacketListEntry);

    //
    // XMO objects created on call to Inserted()
    //
    XMediaObject *m_pMicrophone;
    XMediaObject *m_pHeadphone;

	//
    // Stuff given to us at init
    //
    DWORD m_dwPortNumber; // Port number for headset 


	//
    // The 2 queues for the buffers that are sent to the microphone/headphone
    //
	MEDIA_PACKET_LIST *m_pBeginMicrophoneQueuedBuffers;
	MEDIA_PACKET_LIST *m_pBeginHeadphoneQueuedBuffers;


 	//
    // Events for completion on microphone/headphone work
    //
	HANDLE m_hMicrophoneWorkEvent; 
	HANDLE m_hHeadphoneWorkEvent; 

	virtual void Cleanup();

/*#ifdef _DEBUG
	//
    // Diagnosis stuff
    //
	HANDLE m_hFileRawPCMData;
	HANDLE m_hFileCompressed;
	HANDLE m_hFileDecompressed;
#endif*/

	//
    //  Status
    //
    BOOL   m_fPreBuffering;
    DWORD  m_dwPreBufferRegions;

};

//
// CCompressedVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////
class CCompressedVoiceUnit : public CVoiceUnit
{
public:
	HRESULT PlayToHeadphone();
	HRESULT OnMicrophoneReadComplete();
	
	HRESULT Inserted();
	void Removed();

    CCompressedVoiceUnit(); 
    ~CCompressedVoiceUnit();

protected:
	//
    // Specific codec stuff functions
    //
	HRESULT CompressMediaBuffer(XMEDIAPACKET *pSrc, XMEDIAPACKET *pDst , BOOL *pvbVoiceDetected );
	HRESULT DecompressMediaBuffer(XMEDIAPACKET *pSrc, XMEDIAPACKET *pDst);

    void SendPacketToRenderer();
	BOOL IsPacketPreparedForRender();

protected:
    //
    // XMO objects created on call to Inserted()
    //
    XMediaObject *m_pEncoder;
    XMediaObject *m_pDecoder;
	XMEDIAPACKET m_CodecMediaBuffer[VOICE_DEVICES_COUNT];

 	//
    // Events for completion on encode/decode work
    //
	HANDLE m_hEncodeWorkEvent; 
	HANDLE m_hDecodeWorkEvent; 

	//
	// Flag for correct use of the codec
	//
	BOOL   m_bInPlaceCodec;     


	void Cleanup();
};

//
// CNetVoiceUnit
//
//////////////////////////////////////////////////////////////////////////////
class CNetVoiceUnit : public CCompressedVoiceUnit
{
public:
    CNetVoiceUnit(); 
    ~CNetVoiceUnit();

    HRESULT Inserted();
    void Removed();

    //
    // Uses the voice queuing system
    //
    HRESULT PlayToHeadphone();

    void AddSockAddr(const IN_ADDR &addrPlayer);
    void SendVoicePacket( XMEDIAPACKET *pMediaPacket );
    BOOL RecvVoicePacket( XMEDIAPACKET *pMediaPacket );

    void SendPacketToRenderer();
    BOOL IsPacketPreparedForRender();

    void QueueHeadphoneBuffer(MEDIA_PACKET_LIST *pMediaPacketListEntry);
    void SubmixMediaPackets(PVOID pSrc, PVOID pDest, DWORD dwBytes, DWORD dwAmpFactor);

protected:
	void Cleanup();

	//
    // Network data
    //
	SOCKET		m_VoiceSock;

  typedef std::vector< SOCKADDR_IN > SockAddrList;
  SockAddrList  m_vSockAddrDests;

	//
    // Voice queuing XMO
    //
	XMediaObject *m_pVoiceQueuingXMO;

	//
    // Interval for output
    //
	DWORD       m_IntervalForOutput;
	DWORD       m_LastOutputTimeStamp;
  DWORD       m_LastNetReceiveTimeStamp;
  SOCKADDR_IN m_saLastNetReceiveSockAddr;
  BOOL        m_fSubmixPacket;
};

//
// CVoiceUnits
//
//////////////////////////////////////////////////////////////////////////////
class CVoiceUnits
{
    public:
        CVoiceUnits();
        ~CVoiceUnits();
        void ThreadProc();
	    friend DWORD WINAPI VoiceThreadProc( LPVOID lpParameter );
		HRESULT Initialize(PlayerList& playerlist);


    private:
	    HRESULT CheckForHotPlugs();
	    HRESULT CheckInitialState();
        CNetVoiceUnit m_VoiceUnits[HAWKS_COUNT];

        HANDLE m_hDeleteEvent; 
		HANDLE m_hThread;
		DWORD m_dwThreadId;
		HANDLE m_hMutex;

};


#endif  // VOICE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\Common.h ===
//-----------------------------------------------------------------------------
// File: Common.h
//
// Desc: ContentDownload global header
//
// Hist: 09.07.01 - New for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef CONTENTDOWNLOAD_COMMON_H
#define CONTENTDOWNLOAD_COMMON_H

#include "xtl.h"
#include "xonline.h"
#include <string>
#include <vector>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
enum
{
    // Confirm menu
    CONFIRM_YES = 0,
    CONFIRM_NO,
    CONFIRM_MAX
};




//-----------------------------------------------------------------------------
// Name: class ContentInfo
// Desc: Content information from the online catalog; simplifies access to
//       XONLINECATALOG data.
//-----------------------------------------------------------------------------
class ContentInfo
{
    DWORD                     m_dwPackageSize;
    DWORD                     m_dwInstallSize;
    DWORD                     m_dwRating;
    DWORD                     m_dwOfferingType;
    DWORD                     m_dwBitFlags;   
    FILETIME                  m_ftCreationDate;
    XONLINEOFFERING_ID        m_ID;
    std::basic_string< BYTE > m_Data;       // Title-specific data

public:

    ContentInfo()
    :   
        m_dwPackageSize ( 0 ),
        m_dwInstallSize ( 0 ),
        m_dwRating( 0 ),
        m_dwOfferingType( 0 ),
        m_dwBitFlags( 0 ),
        m_ftCreationDate( FILETIME() ),
        m_ID            ( XONLINEOFFERING_ID(0) ),
        m_Data          ()
    {
    }

    explicit ContentInfo( const XONLINEOFFERING_INFO& xOnInfo )
    :   
        m_dwPackageSize ( xOnInfo.cbPackageSize ),
        m_dwInstallSize ( xOnInfo.cbInstallSize ),
        m_dwOfferingType( xOnInfo.dwOfferingType ),
        m_dwBitFlags    ( xOnInfo.dwBitFlags ),
        m_dwRating      ( xOnInfo.dwRating ),
        m_ftCreationDate( xOnInfo.ftActivationDate ),
        m_ID            ( xOnInfo.OfferingId ),
        m_Data          ( xOnInfo.pbTitleSpecificData,
                          xOnInfo.cbTitleSpecificData )
    {
    }

    DWORD GetPackageSize() const     { return m_dwPackageSize; }
    DWORD GetInstallSize() const     { return m_dwInstallSize; }
    DWORD GetOfferingType() const    { return m_dwOfferingType; }
    DWORD GetBitFlags() const        { return m_dwBitFlags; }
    DWORD GetRating() const          { return m_dwRating; }
    FILETIME GetCreationDate() const { return m_ftCreationDate; }
    XONLINEOFFERING_ID GetId() const { return m_ID; }

};




//-----------------------------------------------------------------------------
// Typedefs
//-----------------------------------------------------------------------------
typedef std::vector< ContentInfo > ContentList;




#endif // CONTENTDOWNLOAD_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Friends\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\ContentDownload.cpp ===
//-----------------------------------------------------------------------------
// File: ContentDownload.cpp
//
// Desc: Shows Xbox online content enumeration, download, installation
//       and removal.
//
// Hist: 08.08.01 - New for Aug M1 release
//       09.04.01 - Updated for Nov release; UI moved to UserInterface module
//       01.21.02 - Updated for Feb release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "ContentDownload.h"
#include "XBStorageDevice.h"
#include "XBMemUnit.h"
#include "XBVoice.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_CONTENT_RESULTS   = 5;    // Don't request more than this number
const DWORD MAX_CONTENT_DISPLAYED = 5;    // Number to show on screen




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
:
CXBApplication(),
m_UI( m_strFrameRate )
{
    m_State             = STATE_SELECT_DEVICE;
    m_NextState         = STATE_SELECT_DEVICE;
    m_dwCurrItem        = 0;
    m_dwTopItem         = 0;
    m_dwCurrUser        = 0;
    m_dwUserIndex       = 0;
    m_EnumDevice        = XONLINEOFFERING_ENUM_DEVICE_DVD;
    m_bIsLoggedOn       = FALSE;
    m_dwCurrContent     = 0;
    m_pEnumBuffer       = NULL;
    m_fPercentComplete  = 0.0f;
    m_dwBlocksInstalled = 0;
    m_dwBlocksTotal     = 0;
    
    m_EnumParams.dwOfferingType = 0xffffffff; // All offering types
    m_EnumParams.dwBitFilter = 0xffffffff;    // All offers
    m_EnumParams.dwMaxResults = MAX_CONTENT_RESULTS; 
    m_EnumParams.dwDescriptionIndex = 0;
    
    *m_strUser = 0;
    m_pServices[0] = XONLINE_BILLING_OFFERING_SERVICE;
    
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Initialize game UI
    if( FAILED( m_UI.Initialize() ) )
        return E_FAIL;
    
    // Initialize the network stack
    if( FAILED( XBNet_OnlineInit( 0 ) ) )
        return E_FAIL;
    
    // Get information on all accounts for this Xbox
    if( FAILED( XBOnline_GetUserList( m_UserList ) ) )
        return E_FAIL;
    
    // If no accounts, then player needs to create an account.
    // For development purposes, accounts are created using the OnlineSetup
    // tool in the XDK Launcher. For retail Xbox consoles, accounts are
    // created in the Xbox Dashboard.
    if( m_UserList.size() == 0 )
        m_State = STATE_CREATE_ACCOUNT;
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Check the physical connection
    if( !m_NetLink.IsActive() )
    {
        m_UI.SetErrorStr( L"This Xbox has lost its online connection" );
        m_hOnlineTask.Close();
        Reset( TRUE );
    }
    
    // Maintain our connection once we've logged on
    if( m_bIsLoggedOn )
    {
        HRESULT hr = m_hOnlineTask.Continue();    
        if( FAILED( hr ) )
        {
            m_UI.SetErrorStr( L"Connection was lost (error 0x%x). Must relogin", hr );
            m_hOnlineTask.Close();
            Reset( TRUE );
        }
    }
    
    Event ev = GetEvent();
    
    switch( m_State )
    {
    case STATE_CREATE_ACCOUNT:  UpdateStateCreateAccount( ev );   break;
    case STATE_SELECT_ACCOUNT:  UpdateStateSelectAccount( ev );   break;
    case STATE_GET_PIN:         UpdateStateGetPin( ev );          break;
    case STATE_LOGGING_ON:      UpdateStateLoggingOn( ev );       break;
    case STATE_SELECT_DEVICE:   UpdateStateSelectDevice( ev );    break;
    case STATE_ENUM_CONTENT:    UpdateStateEnumContent( ev );     break;
    case STATE_SELECT_CONTENT:  UpdateStateSelectContent( ev );   break;
    case STATE_CONTENT_INFO:    UpdateStateContentInfo( ev );     break;
    case STATE_INSTALL_CONTENT: UpdateStateInstallContent( ev );  break;
    case STATE_VERIFY_CONTENT:  UpdateStateVerifyContent( ev );   break;
    case STATE_CONFIRM_REMOVE:  UpdateStateConfirmRemove( ev );   break;
    case STATE_REMOVE_CONTENT:  UpdateStateRemoveContent( ev );   break;
    case STATE_ERROR:           UpdateStateError( ev );           break;
    default:                    assert( FALSE );                  break;
    }
    
    return S_OK;
}





//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
        0x000A0A6A, 1.0f, 0L );
    
    switch( m_State )
    {
    case STATE_CREATE_ACCOUNT:
        m_UI.RenderCreateAccount( TRUE );
        break;
    case STATE_SELECT_ACCOUNT:
        m_UI.RenderSelectAccount( m_dwCurrItem, m_UserList );
        break;
    case STATE_GET_PIN:
        m_UI.RenderGetPin( m_PinEntry, m_strUser );
        break;
    case STATE_LOGGING_ON:
        m_UI.RenderLoggingOn();
        break;
    case STATE_SELECT_DEVICE:
        m_UI.RenderSelectDevice( m_dwCurrItem );
        break;
    case STATE_ENUM_CONTENT:
        m_UI.RenderEnumContent();
        break;
    case STATE_SELECT_CONTENT:
        m_UI.RenderSelectContent( m_EnumDevice, m_ContentList, 
            m_dwCurrItem, m_dwTopItem );
        break;
    case STATE_CONTENT_INFO:
        {
            assert( m_dwCurrItem < m_ContentList.size() );
            const ContentInfo& contentInfo = m_ContentList[ m_dwCurrItem ];
            m_UI.RenderContentInfo( m_EnumDevice, contentInfo );
            break;
        }
    case STATE_INSTALL_CONTENT:
        m_UI.RenderInstallContent( m_fPercentComplete, 
            m_dwBlocksInstalled, m_dwBlocksTotal );
        break;
    case STATE_VERIFY_CONTENT:
        m_UI.RenderVerifyContent();
        break;
    case STATE_CONFIRM_REMOVE: 
        { 
            assert( m_dwCurrContent < m_ContentList.size() );
            const ContentInfo& contentInfo = m_ContentList[ m_dwCurrContent ];
            m_UI.RenderConfirmRemove( contentInfo, m_dwCurrItem );
            break;
        }
    case STATE_REMOVE_CONTENT:
        m_UI.RenderRemoveContent();
        break;
    case STATE_ERROR:
        m_UI.RenderError();
        break;
    default:
        assert( FALSE );
        break;
    }
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetEvent()
// Desc: Return the state of the controller
//-----------------------------------------------------------------------------
CXBoxSample::Event CXBoxSample::GetEvent() const
{
    // "A" or "Start"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] ||
        m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        return EV_BUTTON_A;
    }
    
    // "B"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
        return EV_BUTTON_B;
    
    // "X"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
        return EV_BUTTON_X;
    
    // "Y"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
        return EV_BUTTON_Y;
    
    // "Back"
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        return EV_BUTTON_BACK;
    
    // Movement
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
        return EV_UP;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        return EV_DOWN;
    
    return EV_NULL;
}




//-----------------------------------------------------------------------------
// Name: UpdateStateCreateAccount()
// Desc: Allow player to launch account creation tool
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateCreateAccount( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        
        // Return to Dashboard. Retail Dashboard will include
        // online account creation. Development XDK Launcher
        // includes the Xbox Online Setup Tool for creating accounts.
        LD_LAUNCH_DASHBOARD ld;
        ZeroMemory( &ld, sizeof(ld) );
        ld.dwReason = XLD_LAUNCH_DASHBOARD_MAIN_MENU;
        XLaunchNewImage( NULL, PLAUNCH_DATA( &ld ) );
        break;
    default:
        // If any MUs are inserted, update the user list
        // and go to account selection if there are any accounts
        DWORD dwInsertions;
        DWORD dwRemovals;
        if( CXBMemUnit::GetMemUnitChanges( dwInsertions, dwRemovals ) )
        {
            m_UserList.clear();
            XBOnline_GetUserList( m_UserList );
            if( !m_UserList.empty() )
                m_State = STATE_SELECT_ACCOUNT;
        }
        break;
        
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateSelectAccount()
// Desc: Allow player to choose account
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSelectAccount( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        m_State = STATE_SELECT_DEVICE;
        m_dwCurrItem = 0;
        return;
    case EV_BUTTON_A:
        {
            // Save current account information
            m_dwCurrUser = m_dwCurrItem;
            
            // Make WCHAR copy of user name
            XBUtil_GetWide( m_UserList[ m_dwCurrUser ].name, m_strUser, 
                XONLINE_NAME_SIZE );
            
            // If this user doesn't required PIN entry, begin authentication
            DWORD dwPinReq = m_UserList[ m_dwCurrUser ].dwUserOptions & 
                XONLINE_USER_OPTION_REQUIRE_PIN;
            if( !dwPinReq )
            {
                m_State = STATE_LOGGING_ON;
                BeginLogin();
                break;
            }
            
            // Begin PIN input
            m_State = STATE_GET_PIN;
            HRESULT hr = m_PinEntry.BeginInput( m_DefaultGamepad );
            assert( SUCCEEDED(hr) );
            (VOID)hr; // avoid compiler warning
            break;
        }
        
    case EV_UP:
        // Move to previous user account; allow wrap to bottom
        if( m_dwCurrItem == 0 )
            m_dwCurrItem = m_UserList.size() - 1;
        else
            --m_dwCurrItem;
        break;
        
    case EV_DOWN:
        // Move to next user account; allow wrap to top
        if( m_dwCurrItem == m_UserList.size() - 1 )
            m_dwCurrItem = 0;
        else
            ++m_dwCurrItem;
        break;
        
    default:
        // If any MUs are inserted/removed, need to update the
        // user account list
        DWORD dwInsertions;
        DWORD dwRemovals;
        if( CXBMemUnit::GetMemUnitChanges( dwInsertions, dwRemovals ) )
        {
            m_UserList.clear();
            XBOnline_GetUserList( m_UserList );
            if( m_UserList.empty() )
                m_State = STATE_CREATE_ACCOUNT;
            else
                m_dwCurrItem = 0;
        }
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateGetPin()
// Desc: Allow player to enter PIN number
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateGetPin( Event )
{
    HRESULT hr = m_PinEntry.DecodeInput( m_DefaultGamepad );
    switch( hr )
    {
    case E_ABORT:
        // B or BACK
        m_State = STATE_SELECT_ACCOUNT;
        break;
    case S_OK:
        if( m_PinEntry.IsPinComplete() )
        {
            // Validate PIN
            assert( m_dwCurrUser < m_UserList.size() );
            BYTE* pin = m_UserList[ m_dwCurrUser ].pin;
            if( m_PinEntry.IsPinValid( pin ) )
            {
                m_PinEntry.EndInput();
                
                // PIN is valid; initiate login
                m_State = STATE_LOGGING_ON;
                BeginLogin();
            }
            else
            {
                // The default PIN codes for users created by the Xbox 
                // Online Setup Tool are always "right, down, right, Y"
                m_UI.SetErrorStr( L"That was not the correct pass code" );
                m_State = STATE_ERROR;
                m_NextState = STATE_GET_PIN;
                hr = m_PinEntry.BeginInput( m_DefaultGamepad );
                assert( SUCCEEDED(hr) );
            }
        }
        break;
    default:
        m_UI.SetErrorStr( L"PIN entry failure" );
        m_State = STATE_ERROR;
        m_NextState = STATE_GET_PIN;
        hr = m_PinEntry.BeginInput( m_DefaultGamepad );
        assert( SUCCEEDED(hr) );
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateLoggingOn()
// Desc: Spin during authentication
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateLoggingOn( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        {
            // Cancel the task
            m_hOnlineTask.Close();
            
            // Return to list of devices
            m_State = STATE_SELECT_DEVICE;
            m_bIsLoggedOn = FALSE;
            m_dwCurrItem = 0;
            
            return;
        }
    }
    
    HRESULT hr = m_hOnlineTask.Continue();
    if( FAILED( hr ) )
    {
        m_UI.SetErrorStr( L"Login failure (error 0x%x). Try again.", hr );
        m_hOnlineTask.Close();
        Reset( TRUE );
        return;
    }
    
    // Check login status; partial results indicate that login itself
    // has completed.
    if( hr == XONLINE_S_LOGON_CONNECTION_ESTABLISHED )
    {
        BOOL bSuccess = TRUE;
        HRESULT hrService = S_OK;
        
        // Check for general errors
        if( FAILED(hr) )
        {
            m_UI.SetErrorStr( L"Login failed with error 0x%x", hr );
            bSuccess = FALSE;
        }
        else
        {
            // Next, check if the user was actually logged on
            PXONLINE_USER pLoggedOnUsers = XOnlineGetLogonUsers();
            
            assert( pLoggedOnUsers );
            
            hr = pLoggedOnUsers[ m_dwCurrUser ].hr;
            
            if( FAILED( hr ) )
            {
                m_UI.SetErrorStr( L"User Login failed (Error 0x%x)",
                    hr );
                bSuccess = FALSE;
            }
            else
            {
                // Check for service errors            // Check for service errors
                for( DWORD i = 0; i < NUM_SERVICES; ++i )
                {
                    if( FAILED( hrService = XOnlineGetServiceInfo( 
                        m_pServices[i],NULL ) ) )
                    {
                        m_UI.SetErrorStr( L"Login failed.\n\n"
                            L"Error 0x%x logging into service %d",
                            hrService, m_pServices[i] );
                        bSuccess    = FALSE;
                        break;
                    }
                }
            }
        }
        
        if( bSuccess )
        {
            // We're now on the system
            m_bIsLoggedOn = TRUE;
            
            // Notify the world
            DWORD dwState = XONLINE_FRIENDSTATE_FLAG_ONLINE |
                XONLINE_FRIENDSTATE_FLAG_PLAYING;
            if( XBVoice_HasDevice() )
                dwState |= XONLINE_FRIENDSTATE_FLAG_VOICE;
            SetPlayerState( dwState );
            
            // Begin enumerating content on the selected device
            m_State = STATE_ENUM_CONTENT;
            BeginEnum();
        }
        else
        {
            m_hOnlineTask.Close();
            Reset( TRUE );
        }
    }
}



//-----------------------------------------------------------------------------
// Name: UpdateStateSelectDevice()
// Desc: Handle enum device selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSelectDevice( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        /// Begin enumerating content for the selected device
        m_EnumDevice = XONLINEOFFERING_ENUM_DEVICE( m_dwCurrItem );
        assert( m_EnumDevice < XONLINEOFFERING_ENUM_DEVICE_MAX );
        
        // TODO; this release doesn't yet support DVD enumeration
        if( m_EnumDevice == XONLINEOFFERING_ENUM_DEVICE_DVD )
        {
            m_UI.SetErrorStr( L"DVD enum not supported in this release." );
            Reset( TRUE );
            return;
        }
        
        // If the device is online, need to select account and login
        if( m_EnumDevice == XONLINEOFFERING_ENUM_DEVICE_ONLINE )
        {
            if( m_bIsLoggedOn )
            {
                m_State = STATE_ENUM_CONTENT;
                BeginEnum();
            }
            else
            {
                m_State = STATE_SELECT_ACCOUNT;
            }
            m_dwCurrItem = 0;
        }
        else
        {
            m_State = STATE_ENUM_CONTENT;
            BeginEnum();
        }
        
        break;
        
    case EV_UP:
        if( m_dwCurrItem == 0 )
            m_dwCurrItem = XONLINEOFFERING_ENUM_DEVICE_MAX - 1;
        else
            --m_dwCurrItem;
        break;
        
    case EV_DOWN:
        if( m_dwCurrItem == XONLINEOFFERING_ENUM_DEVICE_MAX - 1 )
            m_dwCurrItem = 0;
        else
            ++m_dwCurrItem;
        break;
    }
}



//-----------------------------------------------------------------------------
// Name: UpdateStateEnumContent()
// Desc: Spin in content enumeration
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateEnumContent( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        
        delete [] m_pEnumBuffer;
        m_pEnumBuffer = NULL;
        
        // Cancel the task
        // Return to list of devices
        m_hContentTask.Close();
        m_State = STATE_SELECT_DEVICE;
        m_dwCurrItem = 0;
        return;
    }
    
    HRESULT hr = m_hContentTask.Continue();
    if( hr != XONLINETASK_S_RUNNING )
    {
        // Handle pump errors
        if( FAILED(hr) )
        {
            delete [] m_pEnumBuffer;
            m_pEnumBuffer = NULL;
            m_UI.SetErrorStr( L"Enumeration failed with error 0x%x", hr );
            Reset( TRUE );
            return;
        }
        
        // Extract the results
        PXONLINEOFFERING_INFO* ppInfo;
        DWORD dwItems;
        BOOL bPartial;
        
        hr = XOnlineOfferingEnumerateGetResults( m_hContentTask,
            &ppInfo, &dwItems, &bPartial );
        
        // Handle errors
        if( FAILED(hr) )
        {
            m_UI.SetErrorStr( L"Enumeration failed with error 0x%x", hr  );
            Reset( TRUE );
            return;
        }
        
        // Save the results
        for( DWORD i = 0; i < dwItems; ++i )
            m_ContentList.push_back( ContentInfo( *ppInfo[i] ) );
        
        // If enumeration is not complete, continue enumerating
        if( bPartial )
        {
            // Enumeration is not complete, keep pumping for more results
            return;
        }
        
        // Enumeration is complete
        delete [] m_pEnumBuffer;
        m_pEnumBuffer = NULL;
        m_hContentTask.Close();
        m_State = STATE_SELECT_CONTENT;
        m_dwCurrItem = 0;
        m_dwTopItem = 0;
    }
}



//-----------------------------------------------------------------------------
// Name: UpdateStateSelectContent()
// Desc: Handle content selection
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSelectContent( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        
        // If no items, return to device list
        if( m_ContentList.empty() )
        {
            Reset( FALSE );
            return;
        }
        
        // Display content detail
        m_dwCurrContent = m_dwCurrItem;
        m_State = STATE_CONTENT_INFO;
        break;
        
    case EV_BUTTON_X:
        
        if( !m_ContentList.empty() && 
            m_EnumDevice == XONLINEOFFERING_ENUM_DEVICE_HD )
        {
            // Remove content
            m_dwCurrContent = m_dwCurrItem;
            m_State = STATE_CONFIRM_REMOVE;
            m_dwCurrItem = CONFIRM_NO;
        }
        break;
        
    case EV_BUTTON_Y:
        
        if( !m_ContentList.empty() && 
            m_EnumDevice != XONLINEOFFERING_ENUM_DEVICE_HD )
        {
            // Install content
            m_dwCurrContent = m_dwCurrItem;
            m_State = STATE_INSTALL_CONTENT;
            BeginInstall();
        }
        break;
        
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        // Return to device menu
        Reset( FALSE );
        break;
        
    case EV_UP:
        if( m_ContentList.empty() )
            break;
        
        // If we're at the top of the displayed list, shift the display
        if( m_dwCurrItem == m_dwTopItem )
        {
            if( m_dwTopItem > 0 )
                --m_dwTopItem;
        }
        
        // Move to the previous item
        if( m_dwCurrItem > 0 )
            --m_dwCurrItem;
        
        break;
        
    case EV_DOWN:
        if( m_ContentList.empty() )
            break;
        
        // If we're at the bottom of the displayed list, shift the display
        if( m_dwCurrItem == m_dwTopItem + MAX_CONTENT_DISPLAYED - 1 )
        {
            if( m_dwTopItem + MAX_CONTENT_DISPLAYED < m_ContentList.size() )
                ++m_dwTopItem;
        }
        
        // Move to next item
        if( m_dwCurrItem < m_ContentList.size() - 1 )
            ++m_dwCurrItem;
        
        break;
    }
}



//-----------------------------------------------------------------------------
// Name: UpdateStateContentInfo()
// Desc: Handle content detail
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateContentInfo( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_X:
        if( m_EnumDevice == XONLINEOFFERING_ENUM_DEVICE_HD )
        {
            // Remove content
            m_State = STATE_CONFIRM_REMOVE;
            m_dwCurrItem = CONFIRM_NO;
        }
        break;
        
    case EV_BUTTON_Y:
        if( m_EnumDevice != XONLINEOFFERING_ENUM_DEVICE_HD )
        {
            // Install content
            m_State = STATE_INSTALL_CONTENT;
            BeginInstall();
        }
        break;
        
    case EV_BUTTON_A:
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        // Return to content list
        m_State = STATE_SELECT_CONTENT;
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateInstallContent()
// Desc: Spin during download/installation
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateInstallContent( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        
        // If a player expressly cancels an installation, it's up to the title
        // to handle content removal. However, if the installation
        // is aborted because of network failure or other reasons, it can
        // be resumed without requiring a full download. This is handled
        // automatically.
        
        m_hContentTask.Close();
        m_State = STATE_CONFIRM_REMOVE; // STATE_REMOVE_CONTENT;
        //BeginRemove();
        
        return;
    }
    
    // Determine the download progress
    DWORD dwPercent;
    ULONGLONG qwBytesInstalled;
    ULONGLONG qwBytesTotal;
    
    HRESULT hr = XOnlineContentInstallGetProgress( m_hContentTask,
        &dwPercent, &qwBytesInstalled, &qwBytesTotal);
    m_fPercentComplete = FLOAT(dwPercent) / 100.0f;
    
    // Convert bytes to blocks
    const ULONGLONG qwBlockSize = ULONGLONG( CXBStorageDevice::GetBlockSize() );
    m_dwBlocksInstalled = DWORD( ( qwBytesInstalled + (qwBlockSize-1) ) / 
        qwBlockSize );
    m_dwBlocksTotal = DWORD( ( qwBytesTotal + (qwBlockSize-1) ) / 
        qwBlockSize );
    
    hr = m_hContentTask.Continue();
    if( hr != XONLINETASK_S_RUNNING )
    {
        // Installation complete
        m_hContentTask.Close();
        
        // Handle errors
        if( FAILED(hr) )
        {
            m_UI.SetErrorStr( L"Installation failed with error 0x%x", hr  );
            m_State = STATE_ERROR;
            m_NextState = STATE_SELECT_CONTENT;
            return;
        }
        
        // Move to the verification phase
        BeginVerify();
        m_State = STATE_VERIFY_CONTENT;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateVerifyContent()
// Desc: Spin during content verification phase
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateVerifyContent( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        
        m_hContentTask.Close();
        m_State = STATE_SELECT_CONTENT;
        return;
    }
    
    HRESULT hr = m_hContentTask.Continue();
    if( hr != XONLINETASK_S_RUNNING)
    {
        // Verification complete
        m_hContentTask.Close();
        
        // Handle errors
        if( FAILED(hr) )
        {
            m_UI.SetErrorStr( L"Verification failed with error 0x%x", hr );
            m_State = STATE_ERROR;
            m_NextState = STATE_SELECT_CONTENT;
            return;
        }
        
        // Success!
        m_UI.SetErrorStr( L"Content installed" );
        Reset( TRUE );
    }
}



//-----------------------------------------------------------------------------
// Name: UpdateStateConfirmRemove()
// Desc: Confirm content removal
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateConfirmRemove( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        if( m_dwCurrItem == 0 ) // "Yes"
        {
            m_State = STATE_REMOVE_CONTENT;
            BeginRemove();
        }
        else // "No"
        {
            m_State = STATE_SELECT_CONTENT;
            m_dwCurrItem = 0;
            m_dwTopItem = 0;
        }
        break;
        
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        m_State = STATE_SELECT_CONTENT;
        m_dwCurrItem = 0;
        m_dwTopItem = 0;
        break;
        
    case EV_UP:
        if( m_dwCurrItem == 0 )
            m_dwCurrItem = CONFIRM_MAX - 1;
        else
            --m_dwCurrItem;
        break;
        
    case EV_DOWN:
        if( m_dwCurrItem == CONFIRM_MAX - 1 )
            m_dwCurrItem = 0;
        else
            ++m_dwCurrItem;
        break;
    }
}



//-----------------------------------------------------------------------------
// Name: UpdateStateRemoveContent()
// Desc: Spin during content removal
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateRemoveContent( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        
        // XOnlineTaskClose() will not cancel the removal process,
        // because content files would be "stranded," so cancelling is 
        // specifically not allowed during this phase.
        //
        // Removal is generally very fast, unless there are hundreds of
        // files to remove, so developers are encouraged to use packages
        // with a small number of files.
        break;
    }
    
    HRESULT hr = m_hContentTask.Continue();
    
    if( hr != XONLINETASK_S_RUNNING )
    {
        // Removal complete
        m_hContentTask.Close();
        
        // Handle errors
        if( FAILED(hr) )
        {
            m_UI.SetErrorStr( L"Remove failed with error 0x%x", hr );
            m_State = STATE_ERROR;
            m_NextState = STATE_SELECT_CONTENT;
            return;
        }
        
        // Success! Return to front end.
        Reset( FALSE );
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateError()
// Desc: An error occurred
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateError( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        m_State = m_NextState;
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: BeginLogin()
// Desc: Initiate the authentication process
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginLogin()
{
    // If we're already logged on, go directly to content enumeration
    if( m_bIsLoggedOn )
    {
        // Begin enumerating content on the selected device
        m_State = STATE_ENUM_CONTENT;
        BeginEnum();
        return;
    }
    
    // Select a reasonable controller for the current player by choosing
    // the first controller found. Game code should do this much more
    // precisely. See below for details.
    for( m_dwUserIndex = 0; m_dwUserIndex < XGetPortCount(); ++m_dwUserIndex )
    {
        if( m_Gamepad[m_dwUserIndex].hDevice )
            break;
    }
    if( m_dwUserIndex >= XGetPortCount() )
        m_dwUserIndex = 0;
    
    // XOnlineLogon() allows a list of up to 4 players (1 per controller)
    // to login in a single call. This sample shows how to authenticate
    // a single user. The list must be a one-to-one match of controller 
    // to player in order for the online system to recognize which player
    // is using which controller.
    XONLINE_USER pUserList[ XGetPortCount() ] = { 0 };
    CopyMemory( &pUserList[ m_dwUserIndex ], &m_UserList[ m_dwCurrUser ],
        sizeof( XONLINE_USER ) );
    
    // Initiate the login process. XOnlineTaskContinue() is used to poll
    // the status of the login.
    HRESULT hr = XOnlineLogon( pUserList, m_pServices, NUM_SERVICES, 
        NULL, &m_hOnlineTask );
    
    if( FAILED(hr) )
    {
        m_hOnlineTask.Close();
        m_UI.SetErrorStr( L"Login failed to start. Error 0x%x", hr );
        Reset( TRUE );
    }
}




//-----------------------------------------------------------------------------
// Name: BeginEnum()
// Desc: Initiate the enumeration process
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginEnum()
{
    // Clear the existing list
    m_ContentList.clear();
    
    // Determine the buffer size required for enumeration
    DWORD dwBufferSize = XOnlineOfferingEnumerateMaxSize( &m_EnumParams, 0 ); 
    
    // Allocate the enumeration buffer
    assert( m_pEnumBuffer == NULL );
    m_pEnumBuffer = new BYTE [ dwBufferSize ];
    
    // Look for content created after this date. This is an optional parameter.
    // If NULL is passed, all items are enumerated.
    SYSTEMTIME SysTime = { 0 };
    SysTime.wYear = 2001;
    SysTime.wMonth = 1;
    SysTime.wDay = 1;
    BOOL bSuccess = SystemTimeToFileTime( &SysTime, &(m_EnumParams.ftActiveAfter) );
    assert( bSuccess );
    (VOID)bSuccess;
    
    // Initiate the enumeration on the selected device, using the
    // credentials of the user on the current controller
    HRESULT hr = XOnlineOfferingEnumerate( m_EnumDevice, 
        m_dwUserIndex, &m_EnumParams, 
        m_pEnumBuffer, dwBufferSize,
        NULL, &m_hContentTask );
    
    if( FAILED(hr) )
    {
        EndEnum();
        m_UI.SetErrorStr( L"Enumeration failed to start. Error 0x%x", hr );
        Reset( TRUE );
    }
}




//-----------------------------------------------------------------------------
// Name: BeginInstall()
// Desc: Initiate the download and installation process
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginInstall()
{
    // Clear progress bar
    m_fPercentComplete  = 0.0f;
    m_dwBlocksInstalled = 0;
    m_dwBlocksTotal     = 0;
    
    // Get the ID of the selected content
    assert( m_dwCurrContent < m_ContentList.size() );
    XONLINEOFFERING_ID id = m_ContentList[ m_dwCurrContent ].GetId();
    
    // Initiate the installation of the selected content
    HRESULT hr = XOnlineContentInstall( id, NULL, &m_hContentTask );
    
    if( FAILED(hr) )
    {
        m_hContentTask.Close();
        m_UI.SetErrorStr( L"Installation failed to start. Error 0x%x", hr );
        m_State = STATE_ERROR;
        m_NextState = STATE_SELECT_CONTENT;
    }
}




//-----------------------------------------------------------------------------
// Name: BeginVerify()
// Desc: Initiate the verification phase
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginVerify()
{
    // Get the ID of the selected content
    assert( m_dwCurrContent < m_ContentList.size() );
    XONLINEOFFERING_ID id = m_ContentList[ m_dwCurrContent ].GetId();
    
    // The verification buffer must be a minimum of two sectors in size.
    // If the buffer is not provided by the title, it will be automatically
    // created
    DWORD dwBufferSize = XGetDiskSectorSize( "U:\\" ) * 2;
    
    // Initiate the verification of the selected content
    HRESULT hr = XOnlineContentVerify( id, NULL, &dwBufferSize,
        NULL, &m_hContentTask );
    
    if( FAILED(hr) )
    {
        m_hContentTask.Close();
        m_UI.SetErrorStr( L"Verification failed to start. Error 0x%x", hr );
        m_State = STATE_ERROR;
        m_NextState = STATE_SELECT_CONTENT;
    }
}




//-----------------------------------------------------------------------------
// Name: BeginRemove()
// Desc: Initiate the removal process
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginRemove()
{
    // Get the ID of the selected content
    assert( m_dwCurrContent < m_ContentList.size() );
    XONLINEOFFERING_ID id = m_ContentList[ m_dwCurrContent ].GetId();
    
    // Initiate the removal of the selected content
    HRESULT hr = XOnlineContentRemove( id, NULL, &m_hContentTask );
    
    if( FAILED(hr) )
    {
        m_hContentTask.Close();
        m_UI.SetErrorStr( L"Removal failed to start. Error 0x%x", hr );
        m_State = STATE_ERROR;
        m_NextState = STATE_SELECT_CONTENT;
    }
}




//-----------------------------------------------------------------------------
// Name: EndEnum()
// Desc: Finish enum task
//-----------------------------------------------------------------------------
VOID CXBoxSample::EndEnum()
{
    m_hContentTask.Close();
    delete [] m_pEnumBuffer;
    m_pEnumBuffer = NULL;
}




//-----------------------------------------------------------------------------
// Name: SetPlayerState()
// Desc: Broadcast current player state for the world
//-----------------------------------------------------------------------------
VOID CXBoxSample::SetPlayerState( DWORD dwState )
{
    BOOL bSuccess = XOnlineNotificationSetState( m_dwUserIndex, dwState,
        XNKID(), 0, NULL );
    assert( bSuccess );
    (VOID)bSuccess; // avoid compiler warning
}




//-----------------------------------------------------------------------------
// Name: Reset()
// Desc: Prepare to restart the application at the front menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::Reset( BOOL bIsError )
{
    m_hContentTask.Close();
    if( bIsError )
    {
        m_State = STATE_ERROR;
        m_NextState = STATE_SELECT_DEVICE;
    }
    else
    {
        m_State = STATE_SELECT_DEVICE;
    }
    
    m_dwCurrItem = 0;
    m_dwTopItem  = 0;
    m_dwCurrContent = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Friends\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\UserInterface.cpp ===
//-----------------------------------------------------------------------------
// File: UserInterface.cpp
//
// Desc: ContentDownload rendering functions
//
// Hist: 09.04.01 - Updated for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "UserInterface.h"
#include "Resource.h"
#include "XBApp.h"
#include "XBConfig.h"
#include "XBStorageDevice.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_CONTENT_DISPLAYED = 5;    // Number to show on screen

const D3DCOLOR COLOR_PROGRESS  = 0xff00ff00; // Green
const D3DCOLOR COLOR_BARBORDER = 0xff000000; // Black

const DWORD FVF_BARVERTEX = D3DFVF_XYZRHW;




//-----------------------------------------------------------------------------
// Name: UserInterface()
// Desc: Constructor
//-----------------------------------------------------------------------------
UserInterface::UserInterface( WCHAR* strFrameRate )
:
m_UI( strFrameRate, L"ContentDownload" )
{
}




//-----------------------------------------------------------------------------
// Name: SetErrorStr()
// Desc: Set error string
//-----------------------------------------------------------------------------
VOID __cdecl UserInterface::SetErrorStr( const WCHAR* strFormat, ... )
{
    va_list pArgList;
    va_start( pArgList, strFormat );
    
    m_UI.SetErrorStr( strFormat, pArgList );
    
    va_end( pArgList );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT UserInterface::Initialize()
{
    return m_UI.Initialize( Resource_NUM_RESOURCES, Resource_MenuSelect_OFFSET );
}




//-----------------------------------------------------------------------------
// Name: RenderCreateAccount()
// Desc: Allow player to launch account creation tool
//-----------------------------------------------------------------------------
VOID UserInterface::RenderCreateAccount( BOOL bHasMachineAccount ) const
{
    m_UI.RenderCreateAccount( bHasMachineAccount );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectAccount()
// Desc: Display list of accounts
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSelectAccount( DWORD dwCurrItem, 
                                        const XBUserList& UserList ) const
{
    m_UI.RenderSelectAccount( dwCurrItem, UserList );
}




//-----------------------------------------------------------------------------
// Name: RenderGetPin()
// Desc: Display PIN entry screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderGetPin( const CXBPinEntry& PinEntry, 
                                 const WCHAR* strUser ) const
{
    m_UI.RenderGetPin( PinEntry, strUser );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectDevice()
// Desc: Display available content enumeration devices
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSelectDevice( DWORD dwCurrItem ) const
{
    m_UI.RenderHeader();
    
    m_UI.DrawText( 320, 140, COLOR_NORMAL, L"Select Content Device",
        XBFONT_CENTER_X );
    
    const WCHAR* const strDevice[] =
    {
        L"DVD",
            L"Hard Disk",
            L"Online Game Content Server"
    };
    
    const FLOAT fYtop = 200.0f;
    const FLOAT fYdelta = 50.0f;
    
    for( DWORD i = 0; i < XONLINEOFFERING_ENUM_DEVICE_MAX; ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_UI.DrawText( 260, fYtop + (fYdelta * i), dwColor, strDevice[i] );
    }
    
    // Show selected item with little triangle
    m_UI.RenderMenuSelector( 220.0f, fYtop + (fYdelta * dwCurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderEnumContent()
// Desc: Content enumeration progress
//-----------------------------------------------------------------------------
VOID UserInterface::RenderEnumContent() const
{
    m_UI.RenderHeader();
    
    m_UI.DrawText( 320, 140, COLOR_NORMAL, L"Enumerating content", 
        XBFONT_CENTER_X );
    m_UI.DrawText( 320, 200, COLOR_NORMAL, L"Press B to cancel", 
        XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectContent()
// Desc: Display content list
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSelectContent( XONLINEOFFERING_ENUM_DEVICE contentDevice, 
                                        const ContentList& contentList,
                                        DWORD dwCurrItem, DWORD dwTopItem ) const
{
    m_UI.RenderHeader();
    
    if( contentList.empty() )
    {
        m_UI.DrawText( 320, 140, COLOR_NORMAL, L"No content available",
            XBFONT_CENTER_X );
        m_UI.DrawText( 320, 180, COLOR_NORMAL, L"Press A to continue", 
            XBFONT_CENTER_X );
        return;
    }
    
    m_UI.DrawText( 320, 100, COLOR_NORMAL, L"Content List",
        XBFONT_CENTER_X );
    
    m_UI.DrawText( 100, 140, COLOR_NORMAL, L"Press A for detailed info" );
    
    switch( contentDevice )
    {
    case XONLINEOFFERING_ENUM_DEVICE_ONLINE:
    case XONLINEOFFERING_ENUM_DEVICE_DVD:
        m_UI.DrawText( 360, 140, COLOR_NORMAL, L"Press Y to install" );
        break;
    case XONLINEOFFERING_ENUM_DEVICE_HD:
        m_UI.DrawText( 360, 140, COLOR_NORMAL, L"Press X to remove" );
        break;
    default:
        assert( FALSE );
        break;
    }
    
    const FLOAT fYtop = 200.0f;
    const FLOAT fYdelta = 40.0f;
    
    DWORD j = 0;
    for( DWORD i = dwTopItem; i < contentList.size() &&
        j < MAX_CONTENT_DISPLAYED; ++i, ++j )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        if( dwCurrItem == i )
        {
            // Show selected item with little triangle
            m_UI.RenderMenuSelector( 160.0f, fYtop + (fYdelta * j ) );
        }
        
        WCHAR strOfferingId[ 64 ];
        wsprintfW( strOfferingId, L"ID: %08X", contentList[i].GetId() );
        
        m_UI.DrawText( 200, fYtop + (fYdelta * j), dwColor, strOfferingId );
    }
    
    // Show ultra-sexy scroll arrows
    BOOL bShowTopArrow = dwTopItem > 0;
    BOOL bShowBtmArrow = dwTopItem + MAX_CONTENT_DISPLAYED < contentList.size();
    if( bShowTopArrow )
        m_UI.DrawText( 170, 170, COLOR_GREEN, L"/\\" );
    if( bShowBtmArrow )
        m_UI.DrawText( 170, 390, COLOR_GREEN, L"\\/" );
}




//-----------------------------------------------------------------------------
// Name: RenderContentInfo()
// Desc: Display detailed information about selected content
//-----------------------------------------------------------------------------
VOID UserInterface::RenderContentInfo( XONLINEOFFERING_ENUM_DEVICE contentDevice, 
                                      const ContentInfo& content ) const
{
    m_UI.RenderHeader();
    
    // Extract content data
    WCHAR strOfferingType[ 64 ] = L"";
    WCHAR strBitFlags[ 12 ] = L"";
    WCHAR strRating[ 12 ] = L"";
    
    if( contentDevice == XONLINEOFFERING_ENUM_DEVICE_HD )
    {
        lstrcpynW( strOfferingType, L"Metadata not stored in this release", 64 );
    }
    else
    {
        wsprintfW( strOfferingType, L"0x%08X", content.GetOfferingType() );
        wsprintfW( strBitFlags, L"0x%08X", content.GetBitFlags() );
        wsprintfW( strRating, L"%u", content.GetRating() );
    }
    
    // Format date and time information
    WCHAR strDate[32];
    WCHAR strTime[32];
    FILETIME ftCreationTime = content.GetCreationDate();
    CXBConfig::FormatDateTime( ftCreationTime, strDate, strTime );
    
    // Convert bytes to blocks
    const DWORD dwBlockSize = CXBStorageDevice::GetBlockSize();
    DWORD dwPackageBytes = content.GetPackageSize();
	DWORD dwInstallBlocks = content.GetInstallSize( );
    DWORD dwPackageBlocks = ( dwPackageBytes + (dwBlockSize-1) ) / dwBlockSize;
    
    // Format blocks
    CHAR strPackageBlocks[32];
    CHAR strInstallBlocks[32];
    CXBConfig::FormatInt( dwPackageBlocks, strPackageBlocks );
    CXBConfig::FormatInt( dwInstallBlocks, strInstallBlocks );
    WCHAR strPackageBlocksW[32];
    WCHAR strInstallBlocksW[32];
    XBUtil_GetWide( strPackageBlocks, strPackageBlocksW, 32 );
    XBUtil_GetWide( strInstallBlocks, strInstallBlocksW, 32 );
    lstrcatW( strPackageBlocksW, L" blocks" );
    lstrcatW( strInstallBlocksW, L" blocks" );
    
    // Column 1
    m_UI.DrawText( 100, 100, COLOR_NORMAL, L"Offering Type" );
    m_UI.DrawText( 100, 130, COLOR_NORMAL, L"Bit Flags" );
    m_UI.DrawText( 100, 160, COLOR_NORMAL, L"Creation Date" );
    m_UI.DrawText( 100, 190, COLOR_NORMAL, L"Rating" );
    m_UI.DrawText( 100, 220, COLOR_NORMAL, L"Package Size" );
    m_UI.DrawText( 100, 250, COLOR_NORMAL, L"Install Size" );
    
    // Column 2
    m_UI.DrawText( 240, 100, COLOR_GREEN, strOfferingType );
    m_UI.DrawText( 240, 130, COLOR_GREEN, strBitFlags );
    m_UI.DrawText( 240, 160, COLOR_GREEN, strDate );
    m_UI.DrawText( 240, 190, COLOR_GREEN, strRating );
    m_UI.DrawText( 240, 220, COLOR_GREEN, strPackageBlocksW );
    m_UI.DrawText( 240, 250, COLOR_GREEN, strInstallBlocksW );
    
    switch( contentDevice )
    {
    case XONLINEOFFERING_ENUM_DEVICE_ONLINE:
    case XONLINEOFFERING_ENUM_DEVICE_DVD:
        m_UI.DrawText( 320, 360, COLOR_NORMAL, L"Press Y to install",
            XBFONT_CENTER_X );
        break;
    case XONLINEOFFERING_ENUM_DEVICE_HD:
        m_UI.DrawText( 320, 360, COLOR_NORMAL, L"Press X to remove",
            XBFONT_CENTER_X );
        break;
    default:
        assert( FALSE );
        break;
    }
    
    m_UI.DrawText( 320, 400, COLOR_NORMAL, L"Press A or B to return to list",
        XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderInstallContent()
// Desc: Display download/installation progress
//-----------------------------------------------------------------------------
VOID UserInterface::RenderInstallContent( FLOAT fPercentComplete, 
                                         DWORD dwBlocksInstalled, 
                                         DWORD dwBlocksTotal ) const
{
    m_UI.RenderHeader();
    
    m_UI.DrawText( 320, 140, COLOR_NORMAL, L"Installing content", 
        XBFONT_CENTER_X );
    m_UI.DrawText( 320, 200, COLOR_NORMAL, L"Press B to cancel", 
        XBFONT_CENTER_X );
    
    // Display visual progress indicator
    D3DXVECTOR4 v4Progress = D3DXVECTOR4( 100, 260, 540, 280 );
    RenderProgress( v4Progress, fPercentComplete );
    
    // Format blocks
    CHAR strBlocksInstalled[32];
    CHAR strBlocksTotal[32];
    CXBConfig::FormatInt( dwBlocksInstalled, strBlocksInstalled );
    CXBConfig::FormatInt( dwBlocksTotal, strBlocksTotal );
    
    // Display block progress indicator
    WCHAR strProgress[ 128 ];
    wsprintfW( strProgress, L"%.*hs of %.*hs blocks", 32, strBlocksInstalled,
        32, strBlocksTotal );
    m_UI.DrawText( 320, 320, COLOR_NORMAL, strProgress, XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderVerifyContent()
// Desc: Display verification progress
//-----------------------------------------------------------------------------
VOID UserInterface::RenderVerifyContent() const
{
    m_UI.RenderHeader();
    
    m_UI.DrawText( 320, 140, COLOR_NORMAL, L"Verifying content", 
        XBFONT_CENTER_X );
    m_UI.DrawText( 320, 200, COLOR_NORMAL, L"Press B to cancel", 
        XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderConfirmRemove()
// Desc: Display removal confirmation
//-----------------------------------------------------------------------------
VOID UserInterface::RenderConfirmRemove( const ContentInfo& content,
                                        DWORD dwCurrItem ) const
{
    m_UI.RenderHeader();
    
    const DWORD NAME_MAX = 128;
    WCHAR strConfirm[ NAME_MAX + 128 ];
    
    /* TODO when content name available
    wsprintfW( strConfirm, L"Are you sure you want to remove\n"
    L"'%.*s' from the hard disk?", NAME_MAX, content.GetName() );
    */
    lstrcpynW( strConfirm, L"Are you sure you want to remove\n"
        L"content from the hard disk?", 128);
    
    m_UI.DrawText( 320, 140, COLOR_NORMAL, strConfirm, XBFONT_CENTER_X );
    
    const WCHAR* const strMenu[] =
    {
        L"Yes",
            L"No",
    };
    
    const FLOAT fYtop = 240.0f;
    const FLOAT fYdelta = 50.0f;
    
    for( DWORD i = 0; i < CONFIRM_MAX; ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : 
    COLOR_NORMAL;
    m_UI.DrawText( 280, fYtop + (fYdelta * i), dwColor, strMenu[i] );
    }
    
    // Show selected item with little triangle
    m_UI.RenderMenuSelector( 240.0f, fYtop + (fYdelta * dwCurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderRemoveContent()
// Desc: Display removal progress
//-----------------------------------------------------------------------------
VOID UserInterface::RenderRemoveContent() const
{
    m_UI.RenderHeader();
    
    m_UI.DrawText( 320, 140, COLOR_NORMAL, L"Removing content", 
        XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderLogginOn()
// Desc: Display login message
//-----------------------------------------------------------------------------
VOID UserInterface::RenderLoggingOn() const
{
    m_UI.RenderLoggingOn();
}




//-----------------------------------------------------------------------------
// Name: RenderError()
// Desc: Display error message
//-----------------------------------------------------------------------------
VOID UserInterface::RenderError() const
{
    m_UI.RenderError();
}




//-----------------------------------------------------------------------------
// Name: RenderProgress
// Desc: Renders a progress bar at the given rect, fPercent full
//-----------------------------------------------------------------------------
VOID UserInterface::RenderProgress( const D3DXVECTOR4& vecBar,
                                   FLOAT fPercentComplete ) const
{
    struct BARVERTEX
    { 
        D3DXVECTOR4 p;
    };
    
    LPDIRECT3DVERTEXBUFFER8 pvbTemp;
    g_pd3dDevice->CreateVertexBuffer( 9 * sizeof( BARVERTEX ), D3DUSAGE_WRITEONLY,
        FVF_BARVERTEX, D3DPOOL_MANAGED, &pvbTemp );
    
    // Create vertices for the filled-in bar and for the outer border
    BARVERTEX* pVertices;
    pvbTemp->Lock( 0, 0, (BYTE **)&pVertices, 0L );
    
    // Quad for filled-in section
    pVertices[0].p = D3DXVECTOR4( vecBar.x - 0.5f, vecBar.w - 0.5f, 1.0f, 1.0f );
    pVertices[1].p = D3DXVECTOR4( vecBar.x - 0.5f, vecBar.y - 0.5f, 1.0f, 1.0f );
    pVertices[2].p = D3DXVECTOR4( vecBar.x + fPercentComplete*(vecBar.z - vecBar.x) - 0.5f,
        vecBar.w - 0.5f, 1.0f, 1.0f );
    pVertices[3].p = D3DXVECTOR4( vecBar.x + fPercentComplete*(vecBar.z - vecBar.x) - 0.5f,
        vecBar.y - 0.5f, 1.0f, 1.0f );
    
    // Line-strip rectangle for border
    pVertices[4].p = D3DXVECTOR4( vecBar.x, vecBar.w, 1.0f, 1.0f );
    pVertices[5].p = D3DXVECTOR4( vecBar.x, vecBar.y, 1.0f, 1.0f );
    pVertices[6].p = D3DXVECTOR4( vecBar.z, vecBar.y, 1.0f, 1.0f );
    pVertices[7].p = D3DXVECTOR4( vecBar.z, vecBar.w, 1.0f, 1.0f );
    pVertices[8].p = D3DXVECTOR4( vecBar.x, vecBar.w, 1.0f, 1.0f );
    pvbTemp->Unlock();
    
    g_pd3dDevice->SetVertexShader( FVF_BARVERTEX );
    g_pd3dDevice->SetStreamSource( 0, pvbTemp, sizeof( BARVERTEX ) );
    g_pd3dDevice->SetTexture( 0, NULL );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    
    // First render the filled-in-section
    g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, COLOR_PROGRESS );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    
    // Then render the linestrip border
    g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, COLOR_BARBORDER );
    g_pd3dDevice->DrawPrimitive( D3DPT_LINESTRIP, 4, 4 );
    
    pvbTemp->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\UserInterface.h ===
//-----------------------------------------------------------------------------
// File: UserInterface.h
//
// Desc: ContentDownload rendering functions
//
// Hist: 09.07.01 - Updated for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef CONTENTDOWNLOAD_UI_H
#define CONTENTDOWNLOAD_UI_H

#include "Common.h"
#include "XBOnline.h"




//-----------------------------------------------------------------------------
// Name: class UserInterface
// Desc: Main UI class for ContentDownload sample
//-----------------------------------------------------------------------------
class UserInterface
{
    CXBOnlineUI m_UI;

    static const D3DCOLOR COLOR_NORMAL    = CXBOnlineUI::COLOR_NORMAL;
    static const D3DCOLOR COLOR_HIGHLIGHT = CXBOnlineUI::COLOR_HIGHLIGHT;
    static const D3DCOLOR COLOR_GREEN     = CXBOnlineUI::COLOR_GREEN;

public:

    explicit UserInterface( WCHAR* );

    HRESULT Initialize();

    // Accessors
    VOID __cdecl SetErrorStr( const WCHAR*, ... );

    // UI functions
    VOID RenderCreateAccount( BOOL bHasMachineAccount ) const;
    VOID RenderSelectAccount( DWORD, const XBUserList& ) const;
    VOID RenderGetPin( const CXBPinEntry&, const WCHAR* ) const;
    VOID RenderSelectDevice( DWORD ) const;
    VOID RenderEnumContent() const;
    VOID RenderSelectContent( XONLINEOFFERING_ENUM_DEVICE, 
                              const ContentList&, DWORD, DWORD ) const;
    VOID RenderContentInfo( XONLINEOFFERING_ENUM_DEVICE, 
                            const ContentInfo& ) const;
    VOID RenderInstallContent( FLOAT, DWORD, DWORD ) const;
    VOID RenderVerifyContent() const;
    VOID RenderConfirmRemove( const ContentInfo&, DWORD ) const;
    VOID RenderRemoveContent() const;
    VOID RenderLoggingOn() const;
    VOID RenderCancel() const;
    VOID RenderError() const;

private:

    // Disabled
    UserInterface();
    UserInterface( const UserInterface& );

    VOID RenderProgress( const D3DXVECTOR4&, FLOAT ) const;

};

#endif // CONTENTDOWNLOAD_UI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\ContentDownload\ContentDownload.h ===
//-----------------------------------------------------------------------------
// File: ContentDownload.h
//
// Desc: Shows Xbox online content enumeration, download, installation
//       and removal.
//
// Hist: 09.10.01 - New for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef CONTENTDOWNLOAD_H
#define CONTENTDOWNLOAD_H

#include "Common.h"
#include "XBApp.h"
#include "UserInterface.h"
#include "XBStopwatch.h"
#include "XBNet.h"
#include "XBOnlineTask.h"



//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// Number of services to authenticate
const DWORD NUM_SERVICES = 1;




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    enum State
    {
        STATE_CREATE_ACCOUNT,   // Create user account
        STATE_SELECT_ACCOUNT,   // Select user account
        STATE_GET_PIN,          // Enter user PIN
        STATE_LOGGING_ON,       // Perform authentication
        STATE_SELECT_DEVICE,    // Allow player to select device
        STATE_ENUM_CONTENT,     // Get list of content on device
        STATE_SELECT_CONTENT,   // Allow player to select content to download
        STATE_CONTENT_INFO,     // Display content detailed information
        STATE_INSTALL_CONTENT,  // Download/install content
        STATE_VERIFY_CONTENT,   // Verify content
        STATE_CONFIRM_REMOVE,   // Verify content removal
        STATE_REMOVE_CONTENT,   // Remove content
        STATE_ERROR,            // Error
    };

    enum Event
    {
        EV_BUTTON_A,
        EV_BUTTON_B,
        EV_BUTTON_X,
        EV_BUTTON_Y,
        EV_BUTTON_BACK,
        EV_UP,
        EV_DOWN,
        EV_NULL
    };

    UserInterface       m_UI;                // UI object
    State               m_State;             // current state
    State               m_NextState;         // return to this state
    DWORD               m_dwCurrItem;        // current selected menu item
    DWORD               m_dwTopItem;         // tracks the index of the top item
    XBUserList          m_UserList;          // list of available accounts
    DWORD               m_dwCurrUser;        // index of curr user in m_UserList
    DWORD               m_dwUserIndex;       // which controller
    WCHAR               m_strUser[ XONLINE_USERNAME_SIZE ]; // current user name
    DWORD               m_pServices[ NUM_SERVICES ];        // List of desired services
    CXBNetLink          m_NetLink;           // Network link checking
    CXBPinEntry         m_PinEntry;          // PIN entry object
    XONLINEOFFERING_ENUM_DEVICE m_EnumDevice; // selected device
    XONLINEOFFERING_ENUM_PARAMS m_EnumParams; // enumerate params
    BOOL                m_bIsLoggedOn;       // TRUE if authenticated
    ContentList         m_ContentList;       // list of content
    DWORD               m_dwCurrContent;     // selected content
    CXBOnlineTask       m_hOnlineTask;       // online task for pumping
    CXBOnlineTask       m_hContentTask;      // content task handle
    BYTE*               m_pEnumBuffer;       // enumeration buffer
    FLOAT               m_fPercentComplete;  // for progress bars
    DWORD               m_dwBlocksInstalled; // blocks installed
    DWORD               m_dwBlocksTotal;     // total blocks to install

public:

    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();

    CXBoxSample();

private:

    Event GetEvent() const;

    VOID UpdateStateCreateAccount( Event );
    VOID UpdateStateSelectAccount( Event );
    VOID UpdateStateGetPin( Event );
    VOID UpdateStateLoggingOn( Event );
    VOID UpdateStateSelectDevice( Event );
    VOID UpdateStateEnumContent( Event );
    VOID UpdateStateSelectContent( Event );
    VOID UpdateStateContentInfo( Event );
    VOID UpdateStateInstallContent( Event );
    VOID UpdateStateVerifyContent( Event );
    VOID UpdateStateConfirmRemove( Event );
    VOID UpdateStateRemoveContent( Event );
    VOID UpdateStateError( Event );

    VOID BeginLogin();
    VOID BeginEnum();
    VOID BeginInstall();
    VOID BeginVerify();
    VOID BeginRemove();

    VOID EndEnum();
    VOID SetPlayerState( DWORD );
    VOID Reset( BOOL bIsError );

};

#endif // CONTENTDOWNLOAD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Friends\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Friends\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Friends\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Friends\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Friends\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Friends\Friends.h ===
//-----------------------------------------------------------------------------
// File: XBoxFriends.h
//
// Desc: Illustrates online friends on Xbox.
//
// Hist: 08.08.01 - New for Aug M1 release 
//       10.19.01 - Updated for Nov release
//       01.18.02 - Updated for Feb release
//       02.15.02 - Updated for Mar release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBOXFRIENDS_H
#define XBOXFRIENDS_H

#include "Common.h"
#include "UserInterface.h"
#include "XBApp.h"
#include "XBNet.h"
#include "XBOnlineTask.h"




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_STATUS_STR = 64;

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// Number of services to authenticate
const DWORD NUM_SERVICES = 1;




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    enum State
    {
        STATE_CREATE_ACCOUNT,       // Create user account
            STATE_SELECT_ACCOUNT,       // Select user account
            STATE_GET_PIN,              // Enter user PIN
            STATE_LOGGING_ON,           // Perform authentication
            
            STATE_FRIEND_LIST,           // Friend list
            STATE_ACTION_MENU,          // Invite/join/remove friend
            STATE_NEW_FRIEND,            // Invite
            
            STATE_CONFIRM_REMOVE,       // Confirm removal action
            STATE_ERROR                 // Error screen
    };
    
    enum Event
    {
        EV_BUTTON_A,
            EV_BUTTON_B,
            EV_BUTTON_X,
            EV_BUTTON_Y,
            EV_BUTTON_BACK,
            EV_BUTTON_BLACK,
            EV_BUTTON_WHITE,
            EV_UP,
            EV_DOWN,
            EV_NULL
    };
    
    UserInterface   m_UI;                 // UI object
    State           m_State;              // current state
    State           m_NextState;          // return to this state
    DWORD           m_dwCurrItem;         // current selected menu item
    DWORD           m_dwTopItem;          // tracks the index of the top item
    XBUserList      m_UserList;           // available accounts
    DWORD           m_dwCurrUser;         // index of curr user in m_UserList
    ULONGLONG       m_qwUserID;           // unique player ID
    DWORD           m_dwUserIndex;        // which controller
    WCHAR           m_strUser[ XONLINE_USERNAME_SIZE ]; // current user name
    CXBNetLink      m_NetLink;            // network link checking
    CXBPinEntry     m_PinEntry;           // PIN entry object
    DWORD           m_pServices[ NUM_SERVICES ]; // desired services
    BOOL            m_bIsLoggedOn;      
    CXBStopWatch    m_StatusTimer;
    WCHAR           m_strStatus[ MAX_STATUS_STR ];
    CXBOnlineTask   m_hOnlineTask;
    CXBOnlineTask   m_hFriendsTask;        // friends online task
    CXBOnlineTask   m_hFriendEnumTask;     // friend enumerate task
    XBUserList      m_PotentialFriendList; // potential friends
    DWORD           m_dwCurrFriend;
    FriendList       m_FriendList;          // current friends
    BOOL            m_bCloaked;           // currently cloaked?
    
public:
    
    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();
    
    CXBoxSample();
    
private:
    
    Event GetEvent() const;
    
    VOID UpdateStateCreateAccount( Event );
    VOID UpdateStateSelectAccount( Event );
    VOID UpdateStateGetPin( Event );
    VOID UpdateStateLoggingOn( Event );
    VOID UpdateStateCancelLogon( Event );
    
    VOID UpdateStateFriendList( Event );
    VOID UpdateStateActionMenu( Event );
    VOID UpdateStateNewFriend( Event );
    
    VOID UpdateStateConfirmRemove( Event );
    VOID UpdateStateError( Event );
    
    VOID BeginLogin();
    VOID BeginFriends();
    
    VOID SetPlayerState( DWORD );
    VOID ProcessNotifications();
    BOOL IsNotificationPending( DWORD );
    VOID UpdateFriends();
    VOID FriendRequest();
    VOID GameInvite();
    VOID AnswerRequest( XONLINE_REQUEST_ANSWER_TYPE );
    VOID AnswerGameInvite( XONLINE_GAMEINVITE_ANSWER_TYPE );
    VOID RemoveFriend();
    VOID SetStatus( const WCHAR* );
    VOID Reset( BOOL bIsError );
    
};




#endif // XBOXFRIENDS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Friends\Common.h ===
//-----------------------------------------------------------------------------
// File: Common.h
//
// Desc: Friends global header
//
// Hist: 10.20.01 - New for Nov release
//       02.15.02 - Updated for Mar release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBOXFRIENDS_COMMON_H
#define XBOXFRIENDS_COMMON_H

#include "xtl.h"
#include "xonline.h"

#pragma warning( disable: 4786 )
#include <vector>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_FRIENDS_DISPLAYED = 5;

enum
{
    // Action menu
    ACTION_INVITE = 0,
    ACTION_JOIN_GAME_ACCEPT,
    ACTION_JOIN_GAME_DECLINE,
    ACTION_JOIN_GAME_REMOVE,
	ACTION_INVITATION_ACCEPT,
    ACTION_INVITATION_DECLINE,
	ACTION_INVITATION_BLOCK,
    ACTION_REMOVE,
    ACTION_MAX,

    // Confirm removal menu
    CONFIRM_REMOVE_YES = 0,
    CONFIRM_REMOVE_NO,
    CONFIRM_REMOVE_MAX
};




//-----------------------------------------------------------------------------
// Typedefs
//-----------------------------------------------------------------------------
typedef std::vector< XONLINE_FRIEND > FriendList;




#endif // XBOXFRIENDS_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Friends\Friends.cpp ===
//-----------------------------------------------------------------------------
// File: Friends.cpp
//
// Desc: Illustrates online friends on Xbox.
//
// Hist: 10.20.01 - New for Aug M1 release 
//       01.21.02 - Updated for Feb release
//       02.15.02 - Updated for Mar release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Friends.h"
#include "XBMemUnit.h"
#include "XBVoice.h"
#include <cassert>
#include <algorithm>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD TITLE_ID = 0xFFFF0110;

const DWORD RANK_PENDING    = 0x01000000;
const DWORD RANK_SAME_TITLE = 0x00100000;
const DWORD RANK_JOINABLE   = 0x00010000;
const DWORD RANK_PLAYING    = 0x00001000;
const DWORD RANK_ONLINE     = 0x00000100;




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: struct MatchUser
// Desc: Predicate for searching the potential friend list
//-----------------------------------------------------------------------------
struct MatchUser
{
    const CHAR* m_strUser;
    
    MatchUser( const CHAR* strUser ) : m_strUser( strUser )
    {
    }
    
    bool operator()( const XONLINE_USER& user ) const
    {
        return( lstrcmpA( user.name, m_strUser ) == 0 );
    }
};




//-----------------------------------------------------------------------------
// Name: struct FriendCompare
// Desc: Predicate for sorting the friend list
//-----------------------------------------------------------------------------
struct FriendCompare
{
    bool operator()( const XONLINE_FRIEND& x, const XONLINE_FRIEND& y ) const
    {
        DWORD dwRankX = GetRank( x );
        DWORD dwRankY = GetRank( y );
        
        // In the case of matching order, friends are sorted alphabetically
        if( dwRankX == dwRankY )
            return( lstrcmpA( x.username, y.username ) > 0 );
        
        return( dwRankX > dwRankY );
    };
    
private:
    
    DWORD GetRank( const XONLINE_FRIEND& x ) const
    {
        // Order:
        //
        // 1) pending invitations
        // 2) online in same title
        // 3) online in different title
        // 4) in game session
        // 5) online, but not in game session
        // 4) offline
        
        DWORD dwRank = 0;
        
        if( x.friendState & XONLINE_FRIENDSTATE_FLAG_REQUEST )
            dwRank += RANK_PENDING;
        
        if( x.friendState & XONLINE_FRIENDSTATE_FLAG_ONLINE )
        {
            if( x.titleID == TITLE_ID )
                dwRank += RANK_SAME_TITLE;
        }
        
        if( x.friendState & XONLINE_FRIENDSTATE_FLAG_JOINABLE )
            dwRank += RANK_JOINABLE;
        
        if( x.friendState & XONLINE_FRIENDSTATE_FLAG_PLAYING )
            dwRank += RANK_PLAYING;
        
        if( x.friendState & XONLINE_FRIENDSTATE_FLAG_ONLINE )
            dwRank += RANK_ONLINE;
        
        return dwRank;
    }
};




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
:
CXBApplication(),
m_UI( m_strFrameRate ),
m_StatusTimer( FALSE )
{
    m_State     = STATE_SELECT_ACCOUNT;
    m_NextState = STATE_SELECT_ACCOUNT;
    
    // Login to matchmaking service for access to friends
    m_pServices[0] = XONLINE_MATCHMAKING_SERVICE;
    
    m_dwCurrItem  = 0;
    m_dwTopItem   = 0;
    m_dwCurrUser  = 0;
    m_dwCurrFriend = 0;
    
    m_qwUserID    = 0;
    m_dwUserIndex = 0;
    m_bIsLoggedOn = FALSE;
    *m_strUser    = 0;
    *m_strStatus  = 0;
    m_bCloaked    = FALSE;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Initialize game UI
    if( FAILED( m_UI.Initialize() ) )
        return E_FAIL;
    
    // Initialize the network stack
    if( FAILED( XBNet_OnlineInit( 0 ) ) )
        return E_FAIL;
    
    // Get information on all accounts for this Xbox
    if( FAILED( XBOnline_GetUserList( m_UserList ) ) )
        return E_FAIL;
    
    // If no accounts, then player needs to create an account.
    // For development purposes, accounts are created using the OnlineSetup
    // tool in the XDK Launcher. For retail Xbox consoles, accounts are
    // created in the Xbox Dashboard.
    if( m_UserList.empty() )
    {
        m_State = STATE_CREATE_ACCOUNT;
        return S_OK;
    }
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Check the physical connection
    if( !m_NetLink.IsActive() )
    {
        m_UI.SetErrorStr( L"This Xbox has lost its online connection" );
        Reset( TRUE );
        return S_OK;
   }
    
    // Maintain our connection once we've logged on
    if( m_bIsLoggedOn )
    {
        
        if( FAILED( m_hOnlineTask.Continue() )||
            FAILED( m_hFriendsTask.Continue() ) )
        {
            m_UI.SetErrorStr( L"Connection was lost. Must relogin" );
            Reset( TRUE );
            return S_OK;
        }
    }
    
    // Clear status string after 3 seconds
    if( m_StatusTimer.GetElapsedSeconds() > 3.0f )
    {
        SetStatus( L"" );
        m_StatusTimer.Stop();
    }
    
    
    Event ev = GetEvent();
    
    switch( m_State )
    {
    case STATE_CREATE_ACCOUNT:   UpdateStateCreateAccount( ev ); break;
    case STATE_SELECT_ACCOUNT:   UpdateStateSelectAccount( ev ); break;
    case STATE_GET_PIN:          UpdateStateGetPin( ev );        break;
    case STATE_LOGGING_ON:       UpdateStateLoggingOn( ev );     break;
        
    case STATE_FRIEND_LIST:      UpdateStateFriendList( ev );       break;
    case STATE_ACTION_MENU:      UpdateStateActionMenu( ev );      break;
    case STATE_NEW_FRIEND:       UpdateStateNewFriend( ev );        break;
        
    case STATE_CONFIRM_REMOVE:   UpdateStateConfirmRemove( ev ); break;
    case STATE_ERROR:            UpdateStateError( ev );         break;
    default:                     assert( FALSE );                break;
    }
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3D
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
        0x000A0A6A, 1.0f, 0L );
    
    switch( m_State )
    {
    case STATE_LOGGING_ON:     m_UI.RenderLoggingOn();     break;
    case STATE_ERROR:          m_UI.RenderError();         break;
        
    case STATE_CREATE_ACCOUNT:
        m_UI.RenderCreateAccount( TRUE );
        break;
    case STATE_SELECT_ACCOUNT:
        m_UI.RenderSelectAccount( m_dwCurrItem, m_UserList );
        break;
    case STATE_GET_PIN:
        m_UI.RenderGetPin( m_PinEntry, m_strUser );
        break;
    case STATE_FRIEND_LIST:
        m_UI.RenderFriendList( m_dwTopItem, m_dwCurrItem, m_FriendList,
            m_strStatus, m_bCloaked );
        break;
    case STATE_ACTION_MENU:
        assert( m_dwCurrFriend < m_FriendList.size() );
        m_UI.RenderActionMenu( m_dwCurrItem, &m_FriendList[ m_dwCurrFriend ] );
        break;
    case STATE_NEW_FRIEND:
        m_UI.RenderNewFriend( m_dwCurrItem, m_PotentialFriendList );
        break;
    case STATE_CONFIRM_REMOVE:
        assert( m_dwCurrFriend < m_FriendList.size() );
        m_UI.RenderConfirmRemove( m_dwCurrItem, 
            &m_FriendList[ m_dwCurrFriend ] );
        break;
    default:
        assert( FALSE );
        break;
    }
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetEvent()
// Desc: Return the state of the controller
//-----------------------------------------------------------------------------
CXBoxSample::Event CXBoxSample::GetEvent() const
{
    // "A" or "Start"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] ||
        m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        return EV_BUTTON_A;
    }
    
    // "B"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
        return EV_BUTTON_B;
    
    // "X"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
        return EV_BUTTON_X;
    
    // "Y"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
        return EV_BUTTON_Y;
    
    // "Back"
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        return EV_BUTTON_BACK;
    
    // "Black"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_BLACK ] )
        return EV_BUTTON_BLACK;
    
    // "White"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_WHITE ] )
        return EV_BUTTON_WHITE;
    
    // Movement
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
        return EV_UP;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        return EV_DOWN;
    
    return EV_NULL;
}




//-----------------------------------------------------------------------------
// Name: UpdateStateCreateAccount()
// Desc: Inform player that account must be generated using external tool
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateCreateAccount( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        
        // Return to Dashboard. Retail Dashboard will include
        // online account creation. Development XDK Launcher
        // includes the Xbox Online Setup Tool for creating accounts.
        LD_LAUNCH_DASHBOARD ld;
        ZeroMemory( &ld, sizeof(ld) );
        ld.dwReason = XLD_LAUNCH_DASHBOARD_MAIN_MENU;
        XLaunchNewImage( NULL, PLAUNCH_DATA( &ld ) );
        break;
        
    default:
        // If any MUs are inserted/removed, need to update the
        // user account list
        DWORD dwInsertions;
        DWORD dwRemovals;
        if( CXBMemUnit::GetMemUnitChanges( dwInsertions, dwRemovals ) )
        {
            m_UserList.clear();
            XBOnline_GetUserList( m_UserList );
            if( m_UserList.empty() )
                m_State = STATE_CREATE_ACCOUNT;
            else
                m_dwCurrItem = 0;
        }
        break;
        
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateSelectAccount()
// Desc: Allow player to select user account
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSelectAccount( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        {
            // Save current account information
            m_dwCurrUser = m_dwCurrItem;
            m_qwUserID = m_UserList[ m_dwCurrUser ].xuid.qwUserID;
            
            // Make WCHAR copy of user name
            XBUtil_GetWide( m_UserList[ m_dwCurrUser ].name, m_strUser, 
                XONLINE_NAME_SIZE );
            
            // If this user doesn't required PIN entry, begin authentication
            DWORD dwPinReq = m_UserList[ m_dwCurrUser ].dwUserOptions & 
                XONLINE_USER_OPTION_REQUIRE_PIN;
            if( !dwPinReq )
            {
                m_State = STATE_LOGGING_ON;
                BeginLogin();
                break;
            }
            
            // Begin PIN input
            m_State = STATE_GET_PIN;
            HRESULT hr = m_PinEntry.BeginInput( m_DefaultGamepad );
            assert( SUCCEEDED(hr) );
            break;
        }
        
    case EV_UP:
        // Move to previous user account; allow wrap to bottom
        if( m_dwCurrItem == 0 )
            m_dwCurrItem = m_UserList.size() - 1;
        else
            --m_dwCurrItem;
        break;
        
    case EV_DOWN:
        // Move to next user account; allow wrap to top
        if( m_dwCurrItem == m_UserList.size() - 1 )
            m_dwCurrItem = 0;
        else
            ++m_dwCurrItem;
        break;
        
    default:
        // If any MUs are inserted/removed, need to update the
        // user account list
        DWORD dwInsertions;
        DWORD dwRemovals;
        if( CXBMemUnit::GetMemUnitChanges( dwInsertions, dwRemovals ) )
        {
            m_UserList.clear();
            XBOnline_GetUserList( m_UserList );
            if( m_UserList.empty() )
                m_State = STATE_CREATE_ACCOUNT;
            else
                m_dwCurrItem = 0;
        }
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateGetPin()
// Desc: PIN entry
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateGetPin( Event ev )
{
    HRESULT hr = m_PinEntry.DecodeInput( m_DefaultGamepad );
    switch( hr )
    {
    case E_ABORT:
        // B or BACK
        m_State = STATE_SELECT_ACCOUNT;
        break;
    case S_OK:
        if( m_PinEntry.IsPinComplete() )
        {
            // Validate PIN
            assert( m_dwCurrUser < m_UserList.size() );
            BYTE* pin = m_UserList[ m_dwCurrUser ].pin;
            if( m_PinEntry.IsPinValid( pin ) )
            {
                m_PinEntry.EndInput();
                
                // PIN is valid; initiate login
                m_State = STATE_LOGGING_ON;
                BeginLogin();
            }
            else
            {
                // The default PIN codes for users created by the Xbox 
                // Online Setup Tool are always "right, down, right, Y"
                m_UI.SetErrorStr( L"That was not the correct pass code" );
                m_State = STATE_ERROR;
                m_NextState = STATE_GET_PIN;
                hr = m_PinEntry.BeginInput( m_DefaultGamepad );
                assert( SUCCEEDED(hr) );
            }
        }
        break;
    default:
        m_UI.SetErrorStr( L"PIN entry failure" );
        m_State = STATE_ERROR;
        m_NextState = STATE_GET_PIN;
        hr = m_PinEntry.BeginInput( m_DefaultGamepad );
        assert( SUCCEEDED(hr) );
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateLoggingOn()
// Desc: Spin during authentication
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateLoggingOn( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        
        // Cancel the task
        m_hOnlineTask.Close();
        m_State = STATE_SELECT_ACCOUNT;
        return;
    }
    
    HRESULT hr;
    
    hr = m_hOnlineTask.Continue();
    if( FAILED( hr ) )
    {
        m_UI.SetErrorStr( L"Connection was lost. Try again." );
        Reset( TRUE );
        return;
    }
    
    // Check login status
    if( hr != XONLINETASK_S_RUNNING )
    {
        BOOL bSuccess = TRUE;
        HRESULT hrService = S_OK;
        
        // Check for general errors
        if( hr != XONLINE_S_LOGON_CONNECTION_ESTABLISHED )
        {
            m_UI.SetErrorStr( L"Login failed.\n\n"
                L"Error %x returned by "
                L"XOnlineTaskContinue", hr );
            bSuccess = FALSE;
        }
        else
        {

            // Next, check if the user was actually logged on
            PXONLINE_USER pLoggedOnUsers = XOnlineGetLogonUsers();
            
            assert( pLoggedOnUsers );
            
            hr = pLoggedOnUsers[ m_dwCurrUser ].hr;
            
            if( FAILED( hr ) )
            {
                m_UI.SetErrorStr( L"User Login failed (Error 0x%x)",
                    hr );
                bSuccess = FALSE;
            }
            else
            {
                // Check for service errors
                for( DWORD i = 0; i < NUM_SERVICES; ++i )
                {
                    if( FAILED( hrService = XOnlineGetServiceInfo( 
                        m_pServices[i],NULL ) ) )
                    {
                        m_UI.SetErrorStr( L"Login failed.\n\n"
                            L"Error 0x%x logging into service %d",
                            hrService, m_pServices[i] );
                        bSuccess    = FALSE;
                        break;
                    }
                }
            }
        }
        
        if( bSuccess )
        {
            // We're now on the system
            m_bIsLoggedOn = TRUE;
            
            // Notify the world
            DWORD dwState = XONLINE_FRIENDSTATE_FLAG_ONLINE |
                XONLINE_FRIENDSTATE_FLAG_PLAYING;
            if( XBVoice_HasDevice() )
                dwState |= XONLINE_FRIENDSTATE_FLAG_VOICE;
            
            SetPlayerState( dwState );
            
            m_State = STATE_FRIEND_LIST;
            m_dwCurrItem = 0;
            
            // Begin handling friend notifications
            BeginFriends();
        }
        else
        {
            Reset( TRUE );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateFriendList()
// Desc: Friend list navigation
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateFriendList( Event ev )
{

    UpdateFriends();

    // Handle the special case of an empty list
    if( m_FriendList.empty() )
    {
        switch( ev )
        {
        case EV_BUTTON_Y:
            m_State = STATE_NEW_FRIEND;
            m_dwCurrItem = 0;
            break;
        }
        return;
    }
    
    // If the list shrunk, may need to update last element ptr
    if( m_dwCurrItem >= m_FriendList.size() )
    {
        m_dwCurrItem = m_FriendList.size() - 1;
        
        // If we're at the top of the displayed list, shift the display
        if( m_dwCurrItem == m_dwTopItem )
        {
            if( m_dwTopItem > 0 )
                --m_dwTopItem;
        }
        
        // If we're at the bottom of the displayed list, shift the display
        if( m_dwCurrItem == m_dwTopItem + MAX_FRIENDS_DISPLAYED - 1 )
        {
            if( m_dwTopItem + MAX_FRIENDS_DISPLAYED < m_FriendList.size() )
                ++m_dwTopItem;
        }
    }
    
    switch( ev )
    {
    case EV_BUTTON_A:
        // Track the current friend
        m_dwCurrFriend = m_dwCurrItem;
        m_State = STATE_ACTION_MENU;
        m_dwCurrItem = 0;
        break;

    case EV_BUTTON_Y:
        m_State = STATE_NEW_FRIEND;
        m_dwCurrItem = 0;
        break;

    case EV_BUTTON_BLACK:
        {
            // Cloak/uncloak ourself
            
            m_bCloaked = !m_bCloaked;
            
            DWORD dwState = XONLINE_FRIENDSTATE_FLAG_ONLINE |
                XONLINE_FRIENDSTATE_FLAG_PLAYING;
            
            if( m_bCloaked )
                dwState |= XONLINE_FRIENDSTATE_FLAG_CLOAKED;
            
            if( XBVoice_HasDevice() )
                dwState |= XONLINE_FRIENDSTATE_FLAG_VOICE;
            
            SetPlayerState( dwState );
            break;
        }
    case EV_UP:
        // If we're at the top of the displayed list, shift the display
        if( m_dwCurrItem == m_dwTopItem )
        {
            if( m_dwTopItem > 0 )
                --m_dwTopItem;
        }
        
        // Move to the previous item
        if( m_dwCurrItem > 0 )
            --m_dwCurrItem;
        
        break;
        
    case EV_DOWN:
        // If we're at the bottom of the displayed list, shift the display
        if( m_dwCurrItem == m_dwTopItem + MAX_FRIENDS_DISPLAYED - 1 )
        {
            if( m_dwTopItem + MAX_FRIENDS_DISPLAYED < m_FriendList.size() )
                ++m_dwTopItem;
        }
        
        // Move to next item
        if( m_dwCurrItem < m_FriendList.size() - 1 )
            ++m_dwCurrItem;
        
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateActionMenu()
// Desc: Friend action menu navigation
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateActionMenu( Event ev )
{
    // Determine the state of the action menu
    assert( m_dwCurrFriend < m_FriendList.size() );
    BOOL bJoinable = m_FriendList[ m_dwCurrFriend ].friendState & 
        XONLINE_FRIENDSTATE_FLAG_PLAYING;
    
    BOOL bFriendRequest = m_FriendList[ m_dwCurrFriend ].friendState & 
        XONLINE_FRIENDSTATE_FLAG_REQUEST;

    BOOL bGameJoinInvite   = bJoinable && 
        ( m_FriendList[ m_dwCurrFriend ].friendState & 
          XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE );
    

    if( bFriendRequest )
    {
        if( m_dwCurrItem != ACTION_INVITATION_ACCEPT &&
            m_dwCurrItem != ACTION_INVITATION_DECLINE && 
            m_dwCurrItem != ACTION_INVITATION_BLOCK )
            m_dwCurrItem =  ACTION_INVITATION_ACCEPT;
    }
    else if( bGameJoinInvite )
    {

        if( m_dwCurrItem != ACTION_JOIN_GAME_ACCEPT &&
            m_dwCurrItem != ACTION_JOIN_GAME_DECLINE &&
            m_dwCurrItem != ACTION_JOIN_GAME_REMOVE )
            m_dwCurrItem =  ACTION_JOIN_GAME_ACCEPT;
        
    }

    switch( ev )
    {
    case EV_BUTTON_A:
        switch( m_dwCurrItem )
        {
        case ACTION_INVITE:
            GameInvite();
            m_UI.SetErrorStr( L"Invitation sent" );
            break;
        case ACTION_JOIN_GAME_ACCEPT:
            AnswerGameInvite( XONLINE_GAMEINVITE_YES );
            m_UI.SetErrorStr( L"Insert game disc" );
            break;
        case ACTION_JOIN_GAME_DECLINE:
            AnswerGameInvite( XONLINE_GAMEINVITE_NO );
            m_UI.SetErrorStr( L"Declined to join game" );
            break;
        case ACTION_JOIN_GAME_REMOVE:
            AnswerGameInvite( XONLINE_GAMEINVITE_REMOVE );
            m_UI.SetErrorStr( L"Friend removed" );
            break;
        case ACTION_INVITATION_ACCEPT:
            AnswerRequest( XONLINE_REQUEST_YES );
            m_UI.SetErrorStr( L"Invitation accepted" );
            break;
        case ACTION_INVITATION_DECLINE:
            AnswerRequest( XONLINE_REQUEST_NO );
            m_UI.SetErrorStr( L"Invitation declined" );
            break;
        case ACTION_INVITATION_BLOCK:
            AnswerRequest( XONLINE_REQUEST_BLOCK  );
            m_UI.SetErrorStr( L"Invitation declined, and blocked" );
            break;
        case ACTION_REMOVE:
            m_State = STATE_CONFIRM_REMOVE;
            m_dwCurrItem = CONFIRM_REMOVE_NO;
            return;
        }
        m_dwTopItem = m_dwCurrItem = 0;
        m_State = STATE_ERROR;
        m_NextState = STATE_FRIEND_LIST;
        break;
        
        case EV_BUTTON_B:
        case EV_BUTTON_BACK:
            m_State = STATE_FRIEND_LIST;
            m_dwCurrItem = 0;
            break;
            
        case EV_UP:
            
            if( bFriendRequest )
            {
                switch( m_dwCurrItem )
                {
                case ACTION_INVITATION_ACCEPT:
                    m_dwCurrItem = ACTION_INVITATION_BLOCK;
                    break;
                case ACTION_INVITATION_DECLINE:
                    m_dwCurrItem = ACTION_INVITATION_ACCEPT;
                    break;
                case ACTION_INVITATION_BLOCK:
                    m_dwCurrItem = ACTION_INVITATION_DECLINE;
                    break;
                default:
                    assert( 0 );
                }
            }
            else 
            {
                if( bGameJoinInvite )
                {
                    switch( m_dwCurrItem )
                    {
                    case ACTION_JOIN_GAME_ACCEPT:
                        m_dwCurrItem = ACTION_JOIN_GAME_REMOVE;
                        break;
                    case ACTION_JOIN_GAME_DECLINE:
                        m_dwCurrItem = ACTION_JOIN_GAME_ACCEPT;
                        break;
                    case ACTION_JOIN_GAME_REMOVE:
                        m_dwCurrItem = ACTION_JOIN_GAME_DECLINE;
                        break;
                    default:
                        assert( 0 );
                    }
                    
                }
                else
                {
                    switch( m_dwCurrItem )
                    {
                    case ACTION_INVITE:
                        m_dwCurrItem = ACTION_REMOVE;
                        break;
                    case ACTION_REMOVE:
                        m_dwCurrItem = ACTION_INVITE;
                        break;
                    default:
                        assert( 0 );
                    }

                }
            }
            break;
            
        case EV_DOWN:
            
            if( bFriendRequest )
            {
                switch( m_dwCurrItem )
                {
                case ACTION_INVITATION_ACCEPT:
                    m_dwCurrItem = ACTION_INVITATION_DECLINE;
                    break;
                case ACTION_INVITATION_DECLINE:
                    m_dwCurrItem = ACTION_INVITATION_BLOCK;
                    break;
                case ACTION_INVITATION_BLOCK:
                    m_dwCurrItem = ACTION_INVITATION_ACCEPT;
                    break;
                default:
                    assert( 0 );
                }
            }
            else 
            {
                if( bGameJoinInvite )
                {
                    switch( m_dwCurrItem )
                    {
                    case ACTION_JOIN_GAME_ACCEPT:
                        m_dwCurrItem = ACTION_JOIN_GAME_DECLINE;
                        break;
                    case ACTION_JOIN_GAME_DECLINE:
                        m_dwCurrItem = ACTION_JOIN_GAME_REMOVE;
                        break;
                    case ACTION_JOIN_GAME_REMOVE:
                        m_dwCurrItem = ACTION_JOIN_GAME_ACCEPT;
                        break;
                    default:
                        assert( 0 );
                    }
                    
                }
                else
                {
                    switch( m_dwCurrItem )
                    {
                    case ACTION_INVITE:
                        m_dwCurrItem = ACTION_REMOVE;
                        break;
                    case ACTION_REMOVE:
                        m_dwCurrItem = ACTION_INVITE;
                        break;
                    default:
                        assert( 0 );
                    }

                }
            }
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateNewFriend()
// Desc: Add new friend
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateNewFriend( Event ev )
{
    // Handle the special case of an empty list
    if( m_PotentialFriendList.empty() )
    {
        switch( ev )
        {
        case EV_BUTTON_A:
        case EV_BUTTON_B:
        case EV_BUTTON_BACK:
            m_State = STATE_FRIEND_LIST;
            m_dwCurrItem = 0;
            break;
        }
        return;
    }
    
    switch( ev )
    {
    case EV_BUTTON_A:
        FriendRequest();
        m_UI.SetErrorStr( L"Friend request issued" );
        m_dwTopItem = m_dwCurrItem = 0;
        m_State = STATE_ERROR;
        m_NextState = STATE_NEW_FRIEND;
        break;
        
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        m_State = STATE_FRIEND_LIST;
        m_dwTopItem = m_dwCurrItem = 0;
        break;
        
    case EV_UP:
        if( m_PotentialFriendList.empty() )
            break;
        
        // If we're at the top of the displayed list, shift the display
        if( m_dwCurrItem == m_dwTopItem )
        {
            if( m_dwTopItem > 0 )
                --m_dwTopItem;
        }
        
        // Move to the previous item
        if( m_dwCurrItem > 0 )
            --m_dwCurrItem;
        
        break;
        
    case EV_DOWN:
        if( m_PotentialFriendList.empty() )
            break;
        
        // If we're at the bottom of the displayed list, shift the display
        if( m_dwCurrItem == m_dwTopItem + MAX_FRIENDS_DISPLAYED - 1 )
        {
            if( m_dwTopItem + MAX_FRIENDS_DISPLAYED < m_PotentialFriendList.size() )
                ++m_dwTopItem;
        }
        
        // Move to next item
        if( m_dwCurrItem < m_PotentialFriendList.size() - 1 )
            ++m_dwCurrItem;
        
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateConfirmRemove()
// Desc: Confirmation dialog for friend removal
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateConfirmRemove( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        if( m_dwCurrItem == CONFIRM_REMOVE_YES )
        {
            RemoveFriend();
            m_UI.SetErrorStr( L"Friend removed" );
            m_dwTopItem = m_dwCurrItem = 0;
            m_State = STATE_ERROR;
            m_NextState = STATE_FRIEND_LIST;
        }
        else // CONFIRM_REMOVE_NO
        {
            m_State = STATE_ACTION_MENU;
            m_dwTopItem = m_dwCurrItem = 0;
        }
        break;
        
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        m_State = STATE_ACTION_MENU;
        m_dwTopItem = m_dwCurrItem = 0;
        break;
        
    case EV_UP:
        if( m_dwCurrItem == 0 )
            m_dwCurrItem = CONFIRM_REMOVE_MAX - 1;
        else
            --m_dwCurrItem;
        break;
        
    case EV_DOWN:
        if( m_dwCurrItem == CONFIRM_REMOVE_MAX - 1 )
            m_dwCurrItem = 0;
        else
            ++m_dwCurrItem;
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateError()
// Desc: Handle error screen
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateError( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        m_State = m_NextState;
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: BeginLogin()
// Desc: Initiate the authentication process
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginLogin()
{
    // Select a reasonable controller for the current player by choosing
    // the first controller found. Game code should do this much more
    // precisely. See below for details.
    for( m_dwUserIndex = 0; m_dwUserIndex < XGetPortCount(); ++m_dwUserIndex )
    {
        if( m_Gamepad[m_dwUserIndex].hDevice )
            break;
    }
    if( m_dwUserIndex >= XGetPortCount() )
        m_dwUserIndex = 0;
    
    // XOnlineLogon() allows a list of up to 4 players (1 per controller)
    // to login in a single call. This sample shows how to authenticate
    // a single user. The list must be a one-to-one match of controller 
    // to player in order for the online system to recognize which player
    // is using which controller.
    XONLINE_USER pUserList[ XGetPortCount() ] = { 0 };
    CopyMemory( &pUserList[ m_dwUserIndex ], &m_UserList[ m_dwCurrUser ],
        sizeof( XONLINE_USER ) );
    
    // Initiate the login process. XOnlineTaskContinue() is used to poll
    // the status of the login.
    HRESULT hr = XOnlineLogon( pUserList, m_pServices, NUM_SERVICES, 
        NULL, &m_hOnlineTask );
    
    if( FAILED(hr) )
    {
        m_hOnlineTask.Close();
        m_UI.SetErrorStr( L"Login failed to start. Error %x", hr );
        m_State = STATE_ERROR;
        m_NextState = STATE_SELECT_ACCOUNT;
    }
}




//-----------------------------------------------------------------------------
// Name: BeginFriends()
// Desc: Initiate friends handling
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginFriends()
{
    // Standard init
    HRESULT hr = XOnlineFriendsStartup( NULL, &m_hFriendsTask );
    if( FAILED(hr) )
    {
        m_UI.SetErrorStr( L"Friends failed to initialize. Error %x", hr );
        Reset( TRUE );
    }
    
    // Query server for latest list of friends
    hr = XOnlineFriendsEnumerate( m_dwUserIndex, NULL, &m_hFriendEnumTask );
    if( FAILED(hr) )
    {
        m_UI.SetErrorStr( L"Friend enum failed to initialize. Error %x", hr );
        Reset( TRUE );
    }
    
    // Build the list of potential friends. The "potential" friend list is
    // contrived for this sample. A real game would typically allow the
    // player to select anybody they happened to be playing with and request
    // that person be their friend. In other words, your game should not
    // be doing this!
    //
    // The list of potential friends starts out as the list of all users
    // known by this particular Xbox.
    m_PotentialFriendList.clear();
    m_PotentialFriendList = m_UserList;
}




//-----------------------------------------------------------------------------
// Name: SetPlayerState()
// Desc: Broadcast current player state for the world
//-----------------------------------------------------------------------------
VOID CXBoxSample::SetPlayerState( DWORD dwState )
{
    BOOL bSuccess = XOnlineNotificationSetState( m_dwUserIndex, dwState,
        XNKID(), 0, NULL );
    assert( bSuccess );
    (VOID)bSuccess; // avoid compiler warning
}




//-----------------------------------------------------------------------------
// Name: IsNotificationPending()
// Desc: TRUE if notification is pending of the given type
//-----------------------------------------------------------------------------
BOOL CXBoxSample::IsNotificationPending( DWORD dwType )
{
    return XOnlineNotificationIsPending( m_dwUserIndex, dwType );
}




//-----------------------------------------------------------------------------
// Name: UpdateFriends()
// Desc: Make sure our local copy of the friend list reflects the server copy
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateFriends()
{
    HRESULT hr = m_hFriendEnumTask.Continue();
    // Enumeration failed
    if( FAILED( hr ) )
    {
        m_UI.SetErrorStr( L"Friend enumeration failed. Error %x", hr );
        Reset( TRUE );
        return;
    }
    
    // Update generic status
    if( IsNotificationPending( XONLINE_NOTIFICATION_TYPE_FRIENDREQUEST ) )
        SetStatus( L"You have received a friend request" );
    else if( IsNotificationPending( XONLINE_NOTIFICATION_TYPE_GAMEINVITE ) )
        SetStatus( L"You have received a game invitation" );
    else
        SetStatus( L"Friend list refreshed" );
    
    m_FriendList.reserve( MAX_FRIENDS );
    m_FriendList.resize( MAX_FRIENDS );
    XONLINE_FRIEND* pFriendList = &m_FriendList[0];
    DWORD dwNumFriends = XOnlineFriendsGetLatest( m_dwUserIndex,
        MAX_FRIENDS,
        pFriendList );
    m_FriendList.resize( dwNumFriends );
    
    // Resort
    std::sort( m_FriendList.begin(), m_FriendList.end(), FriendCompare() );
    
    // Cull the "potential" friend list accordingly
    m_PotentialFriendList.clear();
    m_PotentialFriendList = m_UserList; // XONLINE_USER
    
    // Remove any match between the two lists from the potential
    // friend list, where a match is a matching username
    for( DWORD i = 0; i < m_FriendList.size(); ++i )
    {
        XBUserList::iterator j = std::find_if( 
            m_PotentialFriendList.begin(),
            m_PotentialFriendList.end(),
            MatchUser( m_FriendList[i].username ) );
        if( j != m_PotentialFriendList.end() )
            m_PotentialFriendList.erase( j );
    }
    
    // Remove "ourself" from the list
    XBUserList::iterator j = std::find_if(
        m_PotentialFriendList.begin(),
        m_PotentialFriendList.end(),
        MatchUser( m_UserList[ m_dwCurrUser ].name ) );
    if( j != m_PotentialFriendList.end() )
        m_PotentialFriendList.erase( j );
}




//-----------------------------------------------------------------------------
// Name: FriendRequest()
// Desc: Request that a player be our friend
//-----------------------------------------------------------------------------
VOID CXBoxSample::FriendRequest()
{
    assert( m_dwCurrItem < m_PotentialFriendList.size() );
    HRESULT hr = XOnlineFriendsRequest( m_dwUserIndex, m_PotentialFriendList[ m_dwCurrItem ].xuid );
    assert( SUCCEEDED(hr) );
    (VOID)hr; // avoid compiler warnings
}




//-----------------------------------------------------------------------------
// Name: GameInvite()
// Desc: Invite a friend to the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::GameInvite()
{
    XNKID SessionID = { 0 };
    
    // Only shown as an example; not currently implemented
    assert( m_dwCurrFriend < m_FriendList.size() );
    XONLINE_FRIEND* pFriend = &m_FriendList[ m_dwCurrFriend ];
    HRESULT hr = XOnlineFriendsGameInvite( m_dwUserIndex, SessionID, 1, pFriend );
    (VOID)hr; // avoid compiler warnings
}




//-----------------------------------------------------------------------------
// Name: AnswerRequest()
// Desc: Respond to friend request
//-----------------------------------------------------------------------------
VOID CXBoxSample::AnswerRequest( XONLINE_REQUEST_ANSWER_TYPE Answer )
{
    assert( m_dwCurrFriend < m_FriendList.size() );
    HRESULT hr = XOnlineFriendsAnswerRequest( m_dwUserIndex, &m_FriendList[ m_dwCurrFriend ], Answer );
    assert( SUCCEEDED(hr) );
    (VOID)hr; // avoid compiler warnings
}




//-----------------------------------------------------------------------------
// Name: AnswerGameInvite()
// Desc: Respond to friend request
//-----------------------------------------------------------------------------
VOID CXBoxSample::AnswerGameInvite( XONLINE_GAMEINVITE_ANSWER_TYPE Answer )
{
    assert( m_dwCurrFriend < m_FriendList.size() );
    HRESULT hr = XOnlineFriendsAnswerGameInvite( m_dwUserIndex, &m_FriendList[ m_dwCurrFriend ], Answer );
    assert( SUCCEEDED(hr) );
    (VOID)hr; // avoid compiler warnings
}




//-----------------------------------------------------------------------------
// Name: RemoveFriend()
// Desc: Remove friend from list
//-----------------------------------------------------------------------------
VOID CXBoxSample::RemoveFriend()
{
    assert( m_dwCurrFriend < m_FriendList.size() );
    XONLINE_FRIEND* pFriend = &m_FriendList[ m_dwCurrFriend ];
    HRESULT hr = XOnlineFriendsRemove( m_dwUserIndex, pFriend );
    assert( SUCCEEDED(hr) );
    (VOID)hr; // avoid compiler warnings
}




//-----------------------------------------------------------------------------
// Name: Reset()
// Desc: Prepare to restart the application at the front menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::SetStatus( const WCHAR* strStatus )
{
    lstrcpynW( m_strStatus, strStatus, MAX_STATUS_STR );
    m_StatusTimer.StartZero();
}




//-----------------------------------------------------------------------------
// Name: Reset()
// Desc: Prepare to restart the application at the front menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::Reset( BOOL bIsError )
{
    m_hFriendsTask.Close();
    m_hFriendEnumTask.Close();
    
    if( bIsError )
    {
        m_hOnlineTask.Close();        
        m_State = STATE_ERROR;
        m_NextState = STATE_SELECT_ACCOUNT;
        m_bIsLoggedOn = FALSE;
    }
    else
    {
        m_State = STATE_FRIEND_LIST;
    }
    
    m_dwCurrItem = 0;
    m_dwTopItem = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Friends\UserInterface.h ===
//-----------------------------------------------------------------------------
// File: UserInterface.h
//
// Desc: Friends rendering functions
//
// Hist: 10.20.01 - Updated for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBOXFRIENDS_UI_H
#define XBOXFRIENDS_UI_H

#include "Common.h"
#include "XBOnline.h"




//-----------------------------------------------------------------------------
// Name: class UserInterface
// Desc: Main UI class for Friends sample
//-----------------------------------------------------------------------------
class UserInterface
{
    CXBOnlineUI m_UI;
    
    static const D3DCOLOR COLOR_NORMAL    = CXBOnlineUI::COLOR_NORMAL;
    static const D3DCOLOR COLOR_HIGHLIGHT = CXBOnlineUI::COLOR_HIGHLIGHT;
    static const D3DCOLOR COLOR_GREEN     = CXBOnlineUI::COLOR_GREEN;
    
public:
    
    explicit UserInterface( WCHAR* );
    
    HRESULT Initialize();
    
    // Accessors
    VOID __cdecl SetErrorStr( const WCHAR*, ... );
    
    // UI functions
    VOID RenderCreateAccount( BOOL bHasMachineAccount ) const;
    VOID RenderSelectAccount( DWORD, const XBUserList& ) const;
    VOID RenderGetPin( const CXBPinEntry&, const WCHAR* ) const;
    VOID RenderLoggingOn() const;
    VOID RenderFriendList( DWORD dwTopItem, DWORD dwCurrItem,
        const FriendList& friendList, 
        const WCHAR* strStatus, BOOL bCloaked ) const;
    VOID RenderActionMenu( DWORD dwCurrItem, const XONLINE_FRIEND* ) const;
    VOID RenderNewFriend( DWORD dwCurrItem, 
        const XBUserList& potentialFriendList ) const;
    VOID RenderConfirmRemove( DWORD dwCurrItem, const XONLINE_FRIEND* ) const;
    VOID RenderError() const;
    
private:
    
    static const WCHAR* GetGameName( DWORD );
    
    // Disabled
    UserInterface();
    UserInterface( const UserInterface& );
    
};

#endif // XBOXFRIENDS_UI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\Friends\UserInterface.cpp ===
//-----------------------------------------------------------------------------
// File: UserInterface.cpp
//
// Desc: Friends rendering functions
//
// Hist: 10.20.01 - Updated for Nov release
//       01.21.02 - Updated for Feb release
//       02.15.02 - Updated for Mar release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "UserInterface.h"
#include "Resource.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Name: UserInterface()
// Desc: Constructor
//-----------------------------------------------------------------------------
UserInterface::UserInterface( WCHAR* strFrameRate )
:
m_UI( strFrameRate, L"Friends" )
{
}




//-----------------------------------------------------------------------------
// Name: SetErrorStr()
// Desc: Set error string
//-----------------------------------------------------------------------------
VOID __cdecl UserInterface::SetErrorStr( const WCHAR* strFormat, ... )
{
    va_list pArgList;
    va_start( pArgList, strFormat );
    
    m_UI.SetErrorStr( strFormat, pArgList );
    
    va_end( pArgList );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT UserInterface::Initialize()
{
    return m_UI.Initialize( Resource_NUM_RESOURCES, Resource_MenuSelect_OFFSET );
}




//-----------------------------------------------------------------------------
// Name: RenderCreateAccount()
// Desc: Allow player to launch account creation tool
//-----------------------------------------------------------------------------
VOID UserInterface::RenderCreateAccount( BOOL bHasMachineAccount ) const
{
    m_UI.RenderCreateAccount( bHasMachineAccount );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectAccount()
// Desc: Display list of accounts
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSelectAccount( DWORD dwCurrItem, 
                                        const XBUserList& UserList ) const
{
    m_UI.RenderSelectAccount( dwCurrItem, UserList );
}




//-----------------------------------------------------------------------------
// Name: RenderGetPin()
// Desc: Display PIN entry screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderGetPin( const CXBPinEntry& PinEntry, 
                                 const WCHAR* strUser ) const
{
    m_UI.RenderGetPin( PinEntry, strUser );
}




//-----------------------------------------------------------------------------
// Name: RenderLogginOn()
// Desc: Display login message
//-----------------------------------------------------------------------------
VOID UserInterface::RenderLoggingOn() const
{
    m_UI.RenderLoggingOn();
}




//-----------------------------------------------------------------------------
// Name: RenderFriendList()
// Desc: Display current list of friends
//-----------------------------------------------------------------------------
VOID UserInterface::RenderFriendList( DWORD dwTopItem, DWORD dwCurrItem,
                                    const FriendList& friendList,
                                    const WCHAR* strStatus,
                                    BOOL bCloaked ) const
{
    m_UI.RenderHeader();
    
    if( friendList.empty() )
    {
        m_UI.DrawText( 320, 140, COLOR_NORMAL, L"No friends",
            XBFONT_CENTER_X );
        m_UI.DrawText( 320, 180, COLOR_NORMAL, L"Press Y to add friend", 
            XBFONT_CENTER_X );
        m_UI.DrawText( 320, 220, COLOR_NORMAL, L"Press B to cancel", 
            XBFONT_CENTER_X );
        return;
    }
    
    m_UI.DrawText( 320, 70, COLOR_NORMAL, L"Friend List",
        XBFONT_CENTER_X );
    
    const FLOAT fYtop = 120.0f;
    const FLOAT fYdelta = 30.0f;
    
    DWORD j = 0;
    for( DWORD i = dwTopItem; i < friendList.size() &&
        j < MAX_FRIENDS_DISPLAYED; ++i, ++j )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        if( dwCurrItem == i )
        {
            // Show selected item with little triangle
            m_UI.RenderMenuSelector( 160.0f, fYtop + (fYdelta * j ) );
        }
        
        // Convert user name to wide string
        WCHAR strUser[ XONLINE_USERNAME_SIZE ];
        XBUtil_GetWide( friendList[i].username, strUser, XONLINE_USERNAME_SIZE );
        
        m_UI.DrawText( 200, fYtop + (fYdelta * j), dwColor, strUser );
    }
    
    // Show ultra-sexy scroll arrows
    BOOL bShowTopArrow = dwTopItem > 0;
    BOOL bShowBtmArrow = dwTopItem + MAX_FRIENDS_DISPLAYED < friendList.size();
    if( bShowTopArrow )
        m_UI.DrawText( 170, 100, COLOR_GREEN, L"/\\" );
    if( bShowBtmArrow )
        m_UI.DrawText( 170, 270, COLOR_GREEN, L"\\/" );
    
    // Friend status
    if( !friendList.empty() )
    {
        assert( dwCurrItem < friendList.size() );
        const XONLINE_FRIEND* pFriend = &friendList[dwCurrItem];
        DWORD dwState = pFriend->friendState;
        WCHAR strState[256] = { 0 };
        
        if (  ( dwState & XONLINE_FRIENDSTATE_FLAG_ONLINE ) &&
            !( dwState & XONLINE_FRIENDSTATE_FLAG_CLOAKED ) )
        {
            if( dwState & XONLINE_FRIENDSTATE_FLAG_PLAYING )
			{
				if( dwState & XONLINE_FRIENDSTATE_FLAG_JOINABLE )
				{
					wsprintfW( strState, L"Online playing %.*s (joinable)", 128, 
						GetGameName( pFriend->titleID ) );
				}
				else
					wsprintfW( strState, L"Online playing %.*s", 128, 
						GetGameName( pFriend->titleID ) );
			}
            else 
                wsprintfW( strState, L"Online in %.*s", 128, 
                GetGameName( pFriend->titleID ) );
        }
        else
            lstrcpyW( strState, L"Offline" );
        
        if( dwState & XONLINE_FRIENDSTATE_FLAG_REQUEST )
            lstrcatW( strState, L"\nHas asked you to accept a friend request" );
        else if( dwState & XONLINE_FRIENDSTATE_FLAG_PENDING )
            lstrcatW( strState, L"\nRequest has been sent to friend" );
        else 
        {
            if( dwState & XONLINE_FRIENDSTATE_FLAG_SENTINVITE )
            {
                if( dwState & XONLINE_FRIENDSTATE_FLAG_INVITEACCEPTED )
                    lstrcatW( strState, 
                        L"\nHas accepted your invitation to play" );
                else if( dwState & XONLINE_FRIENDSTATE_FLAG_INVITEREJECTED )                        
                    lstrcatW( strState, 
                        L"\nHas declined your invitation to play" );
                else
                    lstrcatW( strState, 
                        L"\nGame invitation has been sent to friend" );
            }
            
            if( dwState & XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE )
                lstrcatW( strState, 
                    L"\nYou have received an invitaton to play" );
        }

        m_UI.DrawText( 320, 290, COLOR_GREEN, strState, XBFONT_CENTER_X );
    }
    
    // External status
    m_UI.DrawText( 320, 380, COLOR_GREEN, strStatus, XBFONT_CENTER_X );
    
    // Button descriptions
    m_UI.DrawText(  80, 410, COLOR_NORMAL, L"A  Actions" );
    m_UI.DrawText( 200, 410, COLOR_NORMAL, L"Y  New Friend" );
    
    if( bCloaked )
    {
        m_UI.DrawText( 360, 410, COLOR_NORMAL, L"Black  Appear Online" );
    }
    else
    {
        m_UI.DrawText( 360, 410, COLOR_NORMAL, L"Black  Appear Offline" );
    }
}




//-----------------------------------------------------------------------------
// Name: RenderActionMenu()
// Desc: Display invite/join/remove menu
//-----------------------------------------------------------------------------
VOID UserInterface::RenderActionMenu( DWORD dwCurrItem, 
                                     const XONLINE_FRIEND* pFriend ) const
{
    m_UI.RenderHeader();
    
    FLOAT fYtop = 140.0f;
    FLOAT fYdelta = 60.0f;
    
    const WCHAR* const strMenu[] =
    {
            L"Invite %.*s to play this game",
            L"Join %.*s in %.*s",
            L"Decline to join %.*s in %.*s",
            L"Remove %.*s from friend list",
            L"Accept friend request",
            L"Decline friend request",
            L"Never",
            L"Remove from friend list",
    };
    
    // Determine what menu items to display based on the friend state
    assert( pFriend != NULL );
    BOOL bJoinable = pFriend->friendState & XONLINE_FRIENDSTATE_FLAG_PLAYING;
    BOOL bFriendRequest = pFriend->friendState & XONLINE_FRIENDSTATE_FLAG_REQUEST;
    BOOL bGameJoinInvite   = bJoinable && 
        ( pFriend->friendState & XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE );
    
    // Display menu
    DWORD j = 0;
    for( DWORD i = 0; i < ACTION_MAX; ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        
        const WCHAR* strGameName = GetGameName( pFriend->titleID );
        
        // Convert user name to wide string
        WCHAR strUser[ XONLINE_USERNAME_SIZE ];
        XBUtil_GetWide( pFriend->username, strUser, XONLINE_USERNAME_SIZE );
        
        WCHAR strItem[ 32 + XONLINE_USERNAME_SIZE ];
        wsprintfW( strItem, strMenu[i], XONLINE_USERNAME_SIZE, strUser,
            16, strGameName );
        
        // Determine whether or not to display this menu item
        BOOL bDisplay = FALSE;
        switch( i )
        {
        case ACTION_INVITE: 
             bDisplay = !bFriendRequest && !bGameJoinInvite; break;
        case ACTION_JOIN_GAME_ACCEPT:   bDisplay = bGameJoinInvite; break;
        case ACTION_JOIN_GAME_DECLINE:  bDisplay = bGameJoinInvite; break;
        case ACTION_JOIN_GAME_REMOVE:   bDisplay = bGameJoinInvite; break;
        case ACTION_INVITATION_ACCEPT:  bDisplay = bFriendRequest;  break;
        case ACTION_INVITATION_DECLINE: bDisplay = bFriendRequest;  break;
        case ACTION_INVITATION_BLOCK:   bDisplay = bFriendRequest;  break;
        case ACTION_REMOVE:  bDisplay = !bFriendRequest && !bGameJoinInvite; break;
        }
        
        if( bDisplay )
        {
            m_UI.DrawText( 160, fYtop + (fYdelta * j), dwColor, strItem );
            if( dwCurrItem == i )
            {
                // Show selected item with little triangle
                m_UI.RenderMenuSelector( 120.0f, fYtop + (fYdelta * j ) );
            }
            ++j;
        }
    }
    
}




//-----------------------------------------------------------------------------
// Name: RenderNewFriend()
// Desc: Display list of potential new friends
//-----------------------------------------------------------------------------
VOID UserInterface::RenderNewFriend( DWORD dwCurrItem,
                                   const XBUserList& potentialFriendList ) const
{
    m_UI.RenderHeader();
    
    if( potentialFriendList.empty() )
    {
        m_UI.DrawText( 320, 140, COLOR_NORMAL, 
            L"You have exhausted the list of potential friends.\n\n"
            L"Everybody is your friend!\n\n"
            L"Press B to cancel",
            XBFONT_CENTER_X );
        return;
    }
    
    m_UI.DrawText( 320, 140, COLOR_NORMAL, L"Potential new friends",
        XBFONT_CENTER_X );
    
    FLOAT fYtop = 220.0f;
    FLOAT fYdelta = 30.0f;
    
    // Show list of potential friends
    for( DWORD i = 0; i < potentialFriendList.size(); ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        
        // Convert user name to WCHAR string
        WCHAR strUser[ XONLINE_NAME_SIZE ];
        XBUtil_GetWide( potentialFriendList[i].name, strUser, 
            XONLINE_NAME_SIZE );
        
        m_UI.DrawText( 160, fYtop + (fYdelta * i), dwColor, strUser );
    }
    
    // Show selected item with little triangle
    m_UI.RenderMenuSelector( 120.0f, fYtop + (fYdelta * dwCurrItem ) );
    
    // Button descriptions
    m_UI.DrawText(  80, 410, COLOR_NORMAL, L"A  Request" );
    m_UI.DrawText( 360, 410, COLOR_NORMAL, L"B  Back" );
}




//-----------------------------------------------------------------------------
// Name: RenderConfirmRemove()
// Desc: Display confirmation dialog for friend removal
//-----------------------------------------------------------------------------
VOID UserInterface::RenderConfirmRemove( DWORD dwCurrItem, 
                                        const XONLINE_FRIEND* pFriend ) const
{
    m_UI.RenderHeader();
    
    // Convert user name to wide string
    assert( pFriend != NULL );
    WCHAR strUser[ XONLINE_USERNAME_SIZE ];
    XBUtil_GetWide( pFriend->username, strUser, XONLINE_USERNAME_SIZE );
    
    // Build confirmation string
    WCHAR strConfirm[ XONLINE_USERNAME_SIZE + 64 ];
    wsprintfW( strConfirm, L"Are you sure you want to remove\n"
        L"'%.*s' from your friend list?", XONLINE_USERNAME_SIZE,
        strUser );
    
    m_UI.DrawText( 320, 140, COLOR_NORMAL, strConfirm, XBFONT_CENTER_X );
    
    const WCHAR* const strMenu[] =
    {
        L"Yes",
        L"No",
    };
    
    const FLOAT fYtop = 240.0f;
    const FLOAT fYdelta = 50.0f;
    
    for( DWORD i = 0; i < CONFIRM_REMOVE_MAX; ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_UI.DrawText( 280, fYtop + (fYdelta * i), dwColor, strMenu[i] );
    }
    
    // Show selected item with little triangle
    m_UI.RenderMenuSelector( 240.0f, fYtop + (fYdelta * dwCurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderError()
// Desc: Display error message
//-----------------------------------------------------------------------------
VOID UserInterface::RenderError() const
{
    m_UI.RenderError();
}




//-----------------------------------------------------------------------------
// Name: GetGameName()
// Desc: Extract game name given title ID
//-----------------------------------------------------------------------------
const WCHAR* UserInterface::GetGameName( DWORD dwTitleID ) // static
{
    // In future versions of the XOnline API, game name will be available.
    // For now, there's just a simple mapping for each of the online samples.
    
    switch( dwTitleID )
    {
    case 0xffff010b: return L"Auth";
    case 0xffff010c: return L"ContentDownload";
    case 0xffff010d: return L"MatchMaking";
    case 0xffff0111: return L"Friends";
    case 0xffff0112: return L"SimpleAuth";
    case 0xffff0113: return L"SimpleContentDownload";
    default:         return L"Unknown";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\Common.h ===
//-----------------------------------------------------------------------------
// File: Common.h
//
// Desc: Matchmaking global header
//
// Hist: 10.19.01 - New for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef MATCHMAKING_COMMON_H
#define MATCHMAKING_COMMON_H

#include "xtl.h"
#include "xonline.h"
#include "XBRandName.h"
#include "XBNetMsg.h"
#include "XBOnlineTask.h"

#pragma warning( disable: 4786 )
#include <vector>
#include <string>
#include <queue>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_LEVEL_STR       = 16;
const DWORD MAX_STYLE_BLOB      = 9;
const DWORD MAX_SESSION_STR     = 12;
const DWORD MAX_STATUS_STR      = 128;
const DWORD MAX_TYPE_STR        = 8;
const DWORD MAX_SESSION_ATTRIBS = 5;
enum
{
    // Match menu
    MATCH_QUICK = 0,
    MATCH_CUSTOM,
    MATCH_MAX,

    // Customize menu
    CUSTOM_TYPE = 0,
    CUSTOM_LEVEL,
    CUSTOM_STYLE,
    CUSTOM_NAME,
    CUSTOM_FIND,
    CUSTOM_MAX,

    // Game type menu
    TYPE_ANY = 0,
    TYPE_SHORT,
    TYPE_MEDIUM,
    TYPE_LONG,
    TYPE_MAX,

    // Player type menu
    LEVEL_ANY = 0,
    LEVEL_BEGINNER,
    LEVEL_INTERMEDIATE,
    LEVEL_ADVANCED,
    LEVEL_MAX,

    // Game style menu
    STYLE_ANY = 0,
    STYLE_HEAVY,
    STYLE_LIGHT,
    STYLE_MIXED,
    STYLE_MAX,

    // Game menu
    GAME_WAVE = 0,
    GAME_LEAVE,
    GAME_MAX
};


typedef enum
{
    ADD_PLAYER,
    REMOVE_PLAYER
} SESSION_UPDATE_ACTION;

//-----------------------------------------------------------------------------
// Strings
//-----------------------------------------------------------------------------
extern const WCHAR* const strANY;

extern const WCHAR* const strSHORT;
extern const WCHAR* const strMEDIUM;
extern const WCHAR* const strLONG;

extern const WCHAR* const strBEGINNER;
extern const WCHAR* const strINTERMEDIATE;
extern const WCHAR* const strADVANCED;

extern const  CHAR* const strHEAVY;
extern const  CHAR* const strLIGHT;
extern const  CHAR* const strMIXED;

extern const WCHAR* const strHEAVYw;
extern const WCHAR* const strLIGHTw;
extern const WCHAR* const strMIXEDw;




//-----------------------------------------------------------------------------
// Name: class SessionInfo
// Desc: Session information from the matchmaking server
//-----------------------------------------------------------------------------
class SessionInfo
{
    XMATCH_SEARCHRESULT m_xms;

    // Attributes
    // These are placed into a separate structure for
    // the benefit of XOnlineMatchSearchParse. The
    // members are required to be packed on a byte boundaries
    // and the ordering is also important.
    //
#pragma pack(push, 1)

    struct
    {
        ULONGLONG m_qwGameType;
        WCHAR     m_strPlayerLevel[ MAX_LEVEL_STR ];
        WCHAR     m_strSessionName[ MAX_SESSION_STR ];
        WORD      m_wStyleLen;
        BYTE      m_GameStyle[ MAX_STYLE_BLOB ];
        WCHAR     m_strOwnerName[ XONLINE_USERNAME_SIZE ];
    } m_Attributes;

#pragma pack(pop)

public:

    SessionInfo();
    SessionInfo( XMATCH_SEARCHRESULT&, const CXBOnlineTask&, DWORD dwResult );

    XNKID* GetSessionID()              { return &m_xms.SessionID; }
    XNKEY* GetKeyExchangeKey()         { return &m_xms.KeyExchangeKey; }
    XNADDR* GetHostAddr()              { return &m_xms.HostAddress; }

    // Session attributes
    DWORD GetPublicAvail()             { return m_xms.dwPublicAvailable; }
    ULONGLONG GetGameType()            { return m_Attributes.m_qwGameType; }
    WCHAR* GetPlayerLevel()            { return m_Attributes.m_strPlayerLevel; }
    WCHAR* GetSessionName()            { return m_Attributes.m_strSessionName; }
    WCHAR* GetOwnerName()              { return m_Attributes.m_strOwnerName; }

    WORD GetStyleLen()                 { return m_Attributes.m_wStyleLen; }
    BYTE* GetStylePtr()                { return m_Attributes.m_GameStyle; }

    VOID SetGameType( ULONGLONG );
    VOID SetPlayerLevel( const WCHAR* );
    VOID SetSessionName( const WCHAR* );
    VOID SetOwnerName( const WCHAR* );
    VOID SetStyle( const VOID*, WORD );

    VOID GenRandSessionName( const CXBRandName& );

};




//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------
typedef std::vector< std::wstring > SessionNameList;
typedef std::queue< SESSION_UPDATE_ACTION > SessionUpdateQ;
typedef std::vector< SessionInfo >  SessionList;




#endif // MATCHMAKING_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\GameMsg.cpp ===
//-----------------------------------------------------------------------------
// File: GameMsg.cpp
//
// Desc: Implementation of CXBNetMsgHandler derived class
//
// Hist: 10.19.01 - Updated for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "GameMsg.h"
#include "MatchMaking.h"




//-----------------------------------------------------------------------------
// Name: GameMsg
// Desc: Constructor
//-----------------------------------------------------------------------------
GameMsg::GameMsg( CXBoxSample& App )
:
    CXBNetMsgHandler(),
    m_App( App )
{
}




//-----------------------------------------------------------------------------
// Name: OnJoinGame
// Desc: Handle new player joining game
//-----------------------------------------------------------------------------
VOID GameMsg::OnJoinGame( const CXBNetPlayerInfo& playerInfo )
{
    m_App.OnJoinGame( playerInfo );
}




//-----------------------------------------------------------------------------
// Name: OnJoinApproved
// Desc: We've been approved for game entry by the given host
//-----------------------------------------------------------------------------
VOID GameMsg::OnJoinApproved( const CXBNetPlayerInfo& hostInfo )
{
    m_App.OnJoinApproved( hostInfo );
}




//-----------------------------------------------------------------------------
// Name: OnJoinApprovedAddPlayer
// Desc: Receiving information on player already in the game
//-----------------------------------------------------------------------------
VOID GameMsg::OnJoinApprovedAddPlayer( const CXBNetPlayerInfo& playerInfo )
{
    m_App.OnJoinApprovedAddPlayer( playerInfo );
}




//-----------------------------------------------------------------------------
// Name: OnJoinDenied
// Desc: Handle join denied
//-----------------------------------------------------------------------------
VOID GameMsg::OnJoinDenied()
{
    m_App.OnJoinDenied();
}




//-----------------------------------------------------------------------------
// Name: OnPlayerJoined
// Desc: The given player joined our game
//-----------------------------------------------------------------------------
VOID GameMsg::OnPlayerJoined( const CXBNetPlayerInfo& playerInfo )
{
    m_App.OnPlayerJoined( playerInfo );
}




//-----------------------------------------------------------------------------
// Name: OnWave
// Desc: The given player waved to us
//-----------------------------------------------------------------------------
VOID GameMsg::OnWave( const CXBNetPlayerInfo& playerInfo )
{
    m_App.OnWave( playerInfo );
}




//-----------------------------------------------------------------------------
// Name: OnHeartbeat
// Desc: The given player sent us a heartbeat
//-----------------------------------------------------------------------------
VOID GameMsg::OnHeartbeat( const CXBNetPlayerInfo& playerInfo )
{
    m_App.OnHeartbeat( playerInfo );
}




//-----------------------------------------------------------------------------
// Name: OnPlayerDropout
// Desc: The given player left the game
//-----------------------------------------------------------------------------
VOID GameMsg::OnPlayerDropout( const CXBNetPlayerInfo& playerInfo, BOOL bIsHost )
{
    m_App.OnPlayerDropout( playerInfo, bIsHost );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\GameMsg.h ===
//-----------------------------------------------------------------------------
// File: GameMsg.h
//
// Desc: Implementation of CXBNetMsgHandler base
//
// Hist: 10.19.01 - Updated for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef GAMEMSG_H
#define GAMEMSG_H

#include "Common.h"
#include "XBNetMsg.h"

class CXBoxSample; // forward declaration




//-----------------------------------------------------------------------------
// Name: class GameMsg
// Desc: Sends, receives and processes simple network messages
//-----------------------------------------------------------------------------
class GameMsg : public CXBNetMsgHandler
{

    CXBoxSample& m_App;

public:

    explicit GameMsg( CXBoxSample& );

    // Overloads
    virtual VOID OnJoinGame( const CXBNetPlayerInfo& );
    virtual VOID OnJoinApproved( const CXBNetPlayerInfo& );
    virtual VOID OnJoinApprovedAddPlayer( const CXBNetPlayerInfo& );
    virtual VOID OnJoinDenied();
    virtual VOID OnPlayerJoined( const CXBNetPlayerInfo& );
    virtual VOID OnWave( const CXBNetPlayerInfo& );
    virtual VOID OnHeartbeat( const CXBNetPlayerInfo& );
    virtual VOID OnPlayerDropout( const CXBNetPlayerInfo&, BOOL bIsHost );

private:

    // Disabled
    GameMsg();
    GameMsg( const GameMsg& );
    GameMsg& operator=( const GameMsg& );

};

#endif // GAMEMSG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\MatchMaking.h ===
//-----------------------------------------------------------------------------
// File: MatchMaking.h
//
// Desc: Illustrates online matchmaking on Xbox.
//       Allows player to find/create a new multiplayer game, using
//       either the QuickMatch or CustomMatch metaphor.
//       Once game has been chosen, allows players to connect and send
//       messages to other players.
//
// Hist: 08.08.01 - New for Aug M1 release 
//       10.19.01 - Updated for Nov release
//       01.21.02 - Updated for Feb release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef MATCHMAKING_H
#define MATCHMAKING_H

#include "Common.h"
#include "UserInterface.h"
#include "GameMsg.h"
#include "XBApp.h"
#include "XBNet.h"
#include "XBOnlineTask.h"
#include "XBRandName.h"



//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// Number of services to authenticate
const DWORD NUM_SERVICES = 1;




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    enum State
    {
        STATE_CREATE_ACCOUNT,   // Create user account
        STATE_SELECT_ACCOUNT,   // Select user account
        STATE_GET_PIN,          // Enter user PIN
        STATE_LOGGING_ON,       // Perform authentication

        STATE_SELECT_MATCH,     // QuickMatch or CustomMatch
        STATE_OPTIMATCH,        // Specify game parameters
        STATE_SELECT_TYPE,      // Choose game type
        STATE_SELECT_LEVEL,     // Choose player level
        STATE_SELECT_STYLE,     // Choose game style
        STATE_SELECT_NAME,      // Choose game name
        STATE_SELECT_SESSION,   // Choose a game session

        STATE_GAME_SEARCH,      // Searching for game session
        STATE_REQUEST_JOIN,     // Joining game session
        STATE_CREATE_SESSION,   // Creating game session
        STATE_PLAY_GAME,        // Play game session
        STATE_DELETE_SESSION,   // Deleting game session
        STATE_ERROR             // Error screen
    };

    enum Event
    {
        EV_BUTTON_A,
        EV_BUTTON_B,
        EV_BUTTON_BACK,
        EV_UP,
        EV_DOWN,
        EV_NULL
    };

    UserInterface   m_UI;                // UI object
    GameMsg         m_GameMsg;           // game message object
    State           m_State;             // current state
    State           m_NextState;         // return to this state
    DWORD           m_dwCurrItem;        // current selected menu item
    XBUserList      m_UserList;          // available accounts
    DWORD           m_dwCurrUser;        // index of curr user in m_UserList
    ULONGLONG       m_qwUserID;          // unique player ID
    DWORD           m_dwUserIndex;       // which controller
    DWORD           m_dwSessionIndex;    // index of selected session
                                         //    in m_SessionList
    WCHAR           m_strUser[ XONLINE_USERNAME_SIZE ]; // current user name
    CXBNetLink      m_NetLink;           // network link checking
    CXBPinEntry     m_PinEntry;          // PIN entry object
    SessionInfo     m_Session;           // Our session
    CXBOnlineTask   m_hOnlineTask;
    CXBRandName     m_rand;              // random name generator
    BOOL            m_bIsLoggedOn;
    BOOL            m_bIsSessionRegistered;
    BOOL            m_bIsQuickMatch;    // TRUE if QuickMatch
    BOOL            m_bIsHost;          // TRUE if we are host
    CXBOnlineTask   m_hMatchTask;       // matchmaking online task
    XNKID           m_xnSessionID;      // ID for the current session
    XNKEY           m_xnKeyExchangeKey; // Key Exchange Key for the current session
    IN_ADDR         m_inHostAddr;       // "IP" address of host
    DWORD           m_dwSlotsInUse;     // count of players in session
    WCHAR           m_strStatus[ MAX_STATUS_STR ];
    DWORD           m_pServices[ NUM_SERVICES ]; // List of desired services

    CXBStopWatch    m_GameJoinTimer;
    CXBStopWatch    m_HeartbeatTimer;

    SessionNameList   m_SessionNames;     // list of potential game sessions
    SessionList       m_SessionList;      // list of session information
    CXBNetPlayerList  m_Players;          // list of session players
    SessionUpdateQ    m_SessionUpdateQ;   // queue of session updates to apply
    XONLINE_ATTRIBUTE m_SessionAttributes[ MAX_SESSION_ATTRIBS ];
                                          // Session Attributes

public:

    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();

    CXBoxSample();

    VOID OnJoinGame( const CXBNetPlayerInfo& );
    VOID OnJoinApproved( const CXBNetPlayerInfo& );
    VOID OnJoinApprovedAddPlayer( const CXBNetPlayerInfo& );
    VOID OnJoinDenied();
    VOID OnPlayerJoined( const CXBNetPlayerInfo& );
    VOID OnWave( const CXBNetPlayerInfo& );
    VOID OnHeartbeat( const CXBNetPlayerInfo& );
    VOID OnPlayerDropout( const CXBNetPlayerInfo&, BOOL bIsHost );

private:

    Event GetEvent() const;

    VOID UpdateStateCreateAccount( Event );
    VOID UpdateStateSelectAccount( Event );
    VOID UpdateStateGetPin( Event );
    VOID UpdateStateLoggingOn( Event );

    VOID UpdateStateSelectMatch( Event );
    VOID UpdateStateOptiMatch( Event );
    VOID UpdateStateSelectType( Event );
    VOID UpdateStateSelectStyle( Event );
    VOID UpdateStateSelectLevel( Event );
    VOID UpdateStateSelectName( Event );
    VOID UpdateStateSelectSession( Event );

    VOID UpdateStateGameSearch( Event );
    VOID UpdateStateRequestJoin( Event );
    VOID UpdateStateCreateSession( Event );
    VOID UpdateStatePlayGame( Event );
    VOID UpdateStateDeleteSession( Event );
    VOID UpdateStateError( Event );

    VOID BeginLogin();
    VOID BeginSessionSearch();
    VOID BeginCreateSession();
    VOID BeginSessionUpdate( SESSION_UPDATE_ACTION dwAction );
    VOID BeginDeleteSession();
    VOID BeginJoinSession();
    VOID BeginAddPlayer();
    VOID BeginRemovePlayer();

    VOID SendWave();
    VOID LeaveGame();
    VOID __cdecl SetStatus( const WCHAR*, ... );

    VOID CancelMatch();
    VOID SetPlayerState( DWORD );
    VOID Reset( BOOL bIsError );

};




#endif // MATCHMAKING_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\MatchMaking.cpp ===
//-----------------------------------------------------------------------------
// File: MatchMaking.cpp
//
// Desc: Illustrates online matchmaking on Xbox.
//       Allows player to find/create a new multiplayer game, using
//       either the QuickMatch or OptiMatch metaphor.
//       Once game has been chosen, allows players to connect and send
//       messages to other players.
//
// Hist: 08.08.01 - New for Aug M1 release 
// Hist: 01.16.02 - Updated for Feb release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "MatchMaking.h"
#include "XBMemUnit.h"
#include "XBVoice.h"
#include <cassert>
#pragma warning( disable: 4355 )




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_SESSION_NAMES = 6;      // Max names to choose from
const FLOAT PLAYER_HEARTBEAT  = 3.0f;   // every 3 seconds
const DWORD PLAYER_TIMEOUT    = 12000;  // 12 seconds
const FLOAT GAME_JOIN_TIME    = 5.0f;   // 5 seconds
const DWORD MAX_RESULTS       = 5;      // Max sessions to get
const DWORD MAX_RESULTS_LEN   = 2048;   // Results buffer size



// The following search ID has been custom-designed specifically
// for this sample. IT ONLY WORKS FOR THIS SAMPLE. For maximum speed
// and flexibility, game developers will create and establish their
// own search IDs in conjunction with Xbox Developer Support.
// These search functions will be hosted on the Xbox matchmaking
// servers and allow game developers to tailor session searching to
// the requirements of their game.
const DWORD SEARCH_ID_CUSTOM_1 = 1;

// Session attributes
const DWORD XATTRIB_TYPE  = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
X_ATTRIBUTE_DATATYPE_INTEGER     | 0x0001;
const DWORD XATTRIB_LEVEL = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
X_ATTRIBUTE_DATATYPE_STRING      | 0x0002;
const DWORD XATTRIB_SNAME = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
X_ATTRIBUTE_DATATYPE_STRING      | 0x0003;
const DWORD XATTRIB_STYLE = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
X_ATTRIBUTE_DATATYPE_BLOB        | 0x0004;
const DWORD XATTRIB_PNAME = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
X_ATTRIBUTE_DATATYPE_STRING      | 0x0005;




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: class MatchInAddr
// Desc: Predicate functor used to match on IN_ADDRs in player lists
//-----------------------------------------------------------------------------
struct MatchInAddr
{
    IN_ADDR ia;
    
    explicit MatchInAddr( IN_ADDR inaddr )
        : 
    ia( inaddr )
    {
    }
    
    bool operator()( const CXBNetPlayerInfo& playerInfo ) const
    {
        return playerInfo.inAddr.s_addr == ia.s_addr;
    }
};




//-----------------------------------------------------------------------------
// Name: SessionInfo
// Desc: Default Constructor
//-----------------------------------------------------------------------------
SessionInfo::SessionInfo()
{
    ZeroMemory( &m_xms, sizeof( m_xms ) );
    
    m_Attributes.m_qwGameType = ULONGLONG(-1);
    
    *m_Attributes.m_strPlayerLevel = 0;
    *m_Attributes.m_strSessionName = 0;
    
    ZeroMemory( m_Attributes.m_GameStyle, MAX_STYLE_BLOB );
    m_Attributes.m_wStyleLen = 0;
}




//-----------------------------------------------------------------------------
// Name: SessionInfo
// Desc: Constructor
//-----------------------------------------------------------------------------
SessionInfo::SessionInfo( XMATCH_SEARCHRESULT& xms, 
                         const CXBOnlineTask& hSearch, DWORD dwResult )
                         :
m_xms( xms )
{
    m_Attributes.m_qwGameType = ULONGLONG(-1);
    
    *m_Attributes.m_strPlayerLevel = 0;
    *m_Attributes.m_strSessionName = 0;
    *m_Attributes.m_strOwnerName   = 0;
    
    ZeroMemory( m_Attributes.m_GameStyle, MAX_STYLE_BLOB );
    m_Attributes.m_wStyleLen = 0;
    
    XONLINE_ATTRIBUTE_SPEC AttributeSpecs[] = 
    {
        { X_ATTRIBUTE_DATATYPE_INTEGER, sizeof( m_Attributes.m_qwGameType ) },
        { X_ATTRIBUTE_DATATYPE_STRING,  sizeof( m_Attributes.m_strPlayerLevel ) },
        { X_ATTRIBUTE_DATATYPE_STRING,  sizeof( m_Attributes.m_strSessionName ) },
        { X_ATTRIBUTE_DATATYPE_BLOB,    sizeof( m_Attributes.m_GameStyle ) },
        { X_ATTRIBUTE_DATATYPE_STRING,  sizeof( m_Attributes.m_strOwnerName ) }
    };
    
    HRESULT hr;
    
    hr = XOnlineMatchSearchParse( &xms, 5, AttributeSpecs, &m_Attributes );
    
    assert( SUCCEEDED(hr) );
    
    
}




//-----------------------------------------------------------------------------
// Name: SetGameType
// Desc: Set session game type
//-----------------------------------------------------------------------------
VOID SessionInfo::SetGameType( ULONGLONG qwGameType )
{
    m_Attributes.m_qwGameType = qwGameType;
}




//-----------------------------------------------------------------------------
// Name: SetPlayerLevel
// Desc: Set session player level
//-----------------------------------------------------------------------------
VOID SessionInfo::SetPlayerLevel( const WCHAR* strPlayerLevel )
{
    assert( strPlayerLevel != NULL );
    lstrcpynW( m_Attributes.m_strPlayerLevel, strPlayerLevel, MAX_LEVEL_STR );
}




//-----------------------------------------------------------------------------
// Name: SetSessionName
// Desc: Set session name
//-----------------------------------------------------------------------------
VOID SessionInfo::SetSessionName( const WCHAR* strSessionName )
{
    assert( strSessionName != NULL );
    lstrcpynW( m_Attributes.m_strSessionName, strSessionName, MAX_SESSION_STR );
}




//-----------------------------------------------------------------------------
// Name: SetOwnerName
// Desc: Set owner name
//-----------------------------------------------------------------------------
VOID SessionInfo::SetOwnerName( const WCHAR* strOwnerName )
{
    assert( strOwnerName != NULL );
    lstrcpynW( m_Attributes.m_strOwnerName, 
        strOwnerName, XONLINE_USERNAME_SIZE );
}




//-----------------------------------------------------------------------------
// Name: SetStyle
// Desc: Set session style
//-----------------------------------------------------------------------------
VOID SessionInfo::SetStyle( const VOID* pStyle, WORD wStyleLen )
{
    assert( wStyleLen < MAX_STYLE_BLOB );
    
    if( wStyleLen )
    {
        assert( pStyle != NULL );
        CopyMemory( &m_Attributes.m_GameStyle, pStyle, wStyleLen );
    }
    
    m_Attributes.m_wStyleLen = wStyleLen; 
}




//-----------------------------------------------------------------------------
// Name: GenRandSessionName
// Desc: Set name of session to randomly generated value
//-----------------------------------------------------------------------------
VOID SessionInfo::GenRandSessionName( const CXBRandName& rand )
{
    rand.GetName( m_Attributes.m_strSessionName, MAX_SESSION_STR );
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
:
CXBApplication(),
m_UI( m_strFrameRate ),
m_GameMsg( *this ),
m_rand( GetTickCount() )
{
    m_State     = STATE_SELECT_ACCOUNT;
    m_NextState = STATE_SELECT_ACCOUNT;
    
    // Login to matchmaking service
    m_pServices[0] = XONLINE_MATCHMAKING_SERVICE;
    
    m_dwCurrItem     = 0;
    m_dwCurrUser     = 0;
    m_dwUserIndex    = 0;
    m_qwUserID       = 0;
    m_dwSessionIndex = 0;
    
    m_bIsLoggedOn          = FALSE;
    m_bIsSessionRegistered = FALSE;
    m_bIsQuickMatch        = FALSE;
    m_bIsHost              = FALSE;
    
    m_inHostAddr.s_addr = 0;
    m_dwSlotsInUse      = 0;
    
    *m_strUser   = 0;
    *m_strStatus = 0;
    
    ZeroMemory( &m_xnSessionID, sizeof( XNKID ) );
    ZeroMemory( &m_xnKeyExchangeKey, sizeof( XNKEY ) );
    ZeroMemory( &m_SessionAttributes, sizeof( m_SessionAttributes ) );
    
    // Set default session info
    m_Session.SetGameType( TYPE_ANY );
    m_Session.SetPlayerLevel( L"" );
    m_Session.SetOwnerName( L"" );
    m_Session.GenRandSessionName( m_rand );
    m_Session.SetStyle( NULL, 0 );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Initialize game UI
    if( FAILED( m_UI.Initialize() ) )
        return E_FAIL;
    
    // Initialize the network stack
    if( FAILED( XBNet_OnlineInit( 0 ) ) )
        return E_FAIL;
    
    // Get information on all accounts for this Xbox
    if( FAILED( XBOnline_GetUserList( m_UserList ) ) )
        return E_FAIL;
    
    // If no accounts, then player needs to create an account.
    // For development purposes, accounts are created using the OnlineSetup
    // tool in the XDK Launcher. For retail Xbox consoles, accounts are
    // created in the Xbox Dashboard.
    if( m_UserList.empty() )
    {
        m_State = STATE_CREATE_ACCOUNT;
        return S_OK;
    }
    
    if( FAILED( m_GameMsg.Initialize() ) )
        return E_FAIL;
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Check the physical connection
    if( !m_NetLink.IsActive() )
    {
        m_UI.SetErrorStr( L"This Xbox has lost its online connection" );
        m_hOnlineTask.Close();
        m_bIsLoggedOn = FALSE;
        Reset( TRUE );
        m_State = STATE_ERROR;
        m_NextState = STATE_SELECT_ACCOUNT;
    }
    
    // Maintain our connection once we've logged on
    if( m_bIsLoggedOn )
    {
        HRESULT hr = m_hOnlineTask.Continue();    
        if( FAILED( hr ) )
        {
            m_UI.SetErrorStr( L"Connection was lost. Must relogin" );
            m_hOnlineTask.Close();
            m_bIsLoggedOn = FALSE;
            Reset( TRUE );
            m_State = STATE_ERROR;
            m_NextState = STATE_SELECT_ACCOUNT;
            
        }
    }
    
    Event ev = GetEvent();
    
    switch( m_State )
    {
    case STATE_CREATE_ACCOUNT: UpdateStateCreateAccount( ev ); break;
    case STATE_SELECT_ACCOUNT: UpdateStateSelectAccount( ev ); break;
    case STATE_GET_PIN:        UpdateStateGetPin( ev );        break;
    case STATE_LOGGING_ON:     UpdateStateLoggingOn( ev );     break;
        
    case STATE_SELECT_MATCH:   UpdateStateSelectMatch( ev );   break;
    case STATE_OPTIMATCH:      UpdateStateOptiMatch( ev );     break;
    case STATE_SELECT_TYPE:    UpdateStateSelectType( ev );    break;
    case STATE_SELECT_STYLE:   UpdateStateSelectStyle( ev );   break;
    case STATE_SELECT_LEVEL:   UpdateStateSelectLevel( ev );   break;
    case STATE_SELECT_NAME:    UpdateStateSelectName( ev );    break;
    case STATE_SELECT_SESSION: UpdateStateSelectSession( ev ); break;
        
    case STATE_GAME_SEARCH:    UpdateStateGameSearch( ev );    break;
    case STATE_REQUEST_JOIN:   UpdateStateRequestJoin( ev );   break;
    case STATE_CREATE_SESSION: UpdateStateCreateSession( ev ); break;
    case STATE_PLAY_GAME:      UpdateStatePlayGame( ev );      break;
    case STATE_DELETE_SESSION: UpdateStateDeleteSession( ev ); break;
    case STATE_ERROR:          UpdateStateError( ev );         break;
    default:                   assert( FALSE );                break;
    }
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3D
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
        0x000A0A6A, 1.0f, 0L );
    
    switch( m_State )
    {
    case STATE_LOGGING_ON:     m_UI.RenderLoggingOn();     break;
    case STATE_GAME_SEARCH:    m_UI.RenderGameSearch();    break;
    case STATE_REQUEST_JOIN:   m_UI.RenderRequestJoin();   break;
    case STATE_CREATE_SESSION: m_UI.RenderCreateSession(); break;
    case STATE_DELETE_SESSION: m_UI.RenderDeleteSession(); break;
    case STATE_ERROR:          m_UI.RenderError();         break;
        
    case STATE_SELECT_MATCH:   m_UI.RenderSelectMatch( m_dwCurrItem ); break;
    case STATE_SELECT_TYPE:    m_UI.RenderSelectType( m_dwCurrItem );  break;
    case STATE_SELECT_STYLE:   m_UI.RenderSelectStyle( m_dwCurrItem ); break;
    case STATE_SELECT_LEVEL:   m_UI.RenderSelectLevel( m_dwCurrItem ); break;
        
    case STATE_CREATE_ACCOUNT:
        m_UI.RenderCreateAccount( TRUE );
        break;
    case STATE_SELECT_ACCOUNT:
        m_UI.RenderSelectAccount( m_dwCurrItem, m_UserList );
        break;
    case STATE_GET_PIN:
        m_UI.RenderGetPin( m_PinEntry, m_strUser );
        break;
    case STATE_OPTIMATCH:
        m_UI.RenderOptiMatch( m_Session, m_dwCurrItem );
        break;
    case STATE_SELECT_NAME:
        m_UI.RenderSelectName( m_dwCurrItem, m_SessionNames );
        break;
    case STATE_SELECT_SESSION:
        m_UI.RenderSelectSession( m_dwCurrItem, m_SessionList );
        break;
    case STATE_PLAY_GAME:
        {
            // m_Players list doesn't include ourself, so we add one
            // to get the number of total players
            DWORD dwTotalPlayers = m_Players.size() + 1;
            m_UI.RenderPlayGame( m_Session, m_strUser, m_strStatus, 
                dwTotalPlayers, m_dwCurrItem );
            break;
        }
    default:
        assert( FALSE );
        break;
    }
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetEvent()
// Desc: Return the state of the controller
//-----------------------------------------------------------------------------
CXBoxSample::Event CXBoxSample::GetEvent() const
{
    // "A" or "Start"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] ||
        m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        return EV_BUTTON_A;
    }
    
    // "B"
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
        return EV_BUTTON_B;
    
    // "Back"
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        return EV_BUTTON_BACK;
    
    // Movement
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
        return EV_UP;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        return EV_DOWN;
    
    return EV_NULL;
}




//-----------------------------------------------------------------------------
// Name: UpdateStateCreateAccount()
// Desc: Inform player that account must be generated using external tool
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateCreateAccount( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        
        // Return to Dashboard. Retail Dashboard will include
        // online account creation. Development XDK Launcher
        // includes the Xbox Online Setup Tool for creating accounts.
        LD_LAUNCH_DASHBOARD ld;
        ZeroMemory( &ld, sizeof(ld) );
        ld.dwReason = XLD_LAUNCH_DASHBOARD_MAIN_MENU;
        XLaunchNewImage( NULL, PLAUNCH_DATA( &ld ) );
        break;
    default:
        // If any MUs are inserted, update the user list
        // and go to account selection if there are any accounts
        DWORD dwInsertions;
        DWORD dwRemovals;
        if( CXBMemUnit::GetMemUnitChanges( dwInsertions, dwRemovals ) )
        {
            m_UserList.clear();
            XBOnline_GetUserList( m_UserList );
            if( !m_UserList.empty() )
                m_State = STATE_SELECT_ACCOUNT;
        }
        break;
        
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateSelectAccount()
// Desc: Allow player to select user account
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSelectAccount( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        {
            // Save current account information
            m_dwCurrUser = m_dwCurrItem;
            m_qwUserID = m_UserList[ m_dwCurrUser ].xuid.qwUserID;
            assert( XONLINE_USERNAME_SIZE == MAX_PLAYER_STR );
            
            // Make WCHAR copy of user name
            XBUtil_GetWide( m_UserList[ m_dwCurrUser ].name, m_strUser, 
                XONLINE_NAME_SIZE );
            
            // If this user doesn't required PIN entry, begin authentication
            DWORD dwPinReq = m_UserList[ m_dwCurrUser ].dwUserOptions & 
                XONLINE_USER_OPTION_REQUIRE_PIN;
            if( !dwPinReq )
            {
                m_State = STATE_LOGGING_ON;
                BeginLogin();
                break;
            }
            
            // Begin PIN input
            m_State = STATE_GET_PIN;
            HRESULT hr = m_PinEntry.BeginInput( m_DefaultGamepad );
            assert( SUCCEEDED(hr) );
            (VOID)hr; // avoid compiler warning
            break;
        }
        
    case EV_UP:
        // Move to previous user account; allow wrap to bottom
        if( m_dwCurrItem == 0 )
            m_dwCurrItem = m_UserList.size() - 1;
        else
            --m_dwCurrItem;
        break;
        
    case EV_DOWN:
        // Move to next user account; allow wrap to top
        if( m_dwCurrItem == m_UserList.size() - 1 )
            m_dwCurrItem = 0;
        else
            ++m_dwCurrItem;
        break;
        
    default:
        // If any MUs are inserted/removed, need to update the
        // user account list
        DWORD dwInsertions;
        DWORD dwRemovals;
        if( CXBMemUnit::GetMemUnitChanges( dwInsertions, dwRemovals ) )
        {
            m_UserList.clear();
            XBOnline_GetUserList( m_UserList );
            if( m_UserList.empty() )
                m_State = STATE_CREATE_ACCOUNT;
            else
                m_dwCurrItem = 0;
        }
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateGetPin()
// Desc: PIN entry
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateGetPin( Event ev )
{
    HRESULT hr = m_PinEntry.DecodeInput( m_DefaultGamepad );
    switch( hr )
    {
    case E_ABORT:
        // B or BACK
        m_State = STATE_SELECT_ACCOUNT;
        break;
    case S_OK:
        if( m_PinEntry.IsPinComplete() )
        {
            // Validate PIN
            assert( m_dwCurrUser < m_UserList.size() );
            BYTE* pin = m_UserList[ m_dwCurrUser ].pin;
            if( m_PinEntry.IsPinValid( pin ) )
            {
                m_PinEntry.EndInput();
                
                // PIN is valid; initiate login
                m_State = STATE_LOGGING_ON;
                BeginLogin();
            }
            else
            {
                // The default PIN codes for users created by the Xbox 
                // Online Setup Tool are always "right, down, right, Y"
                m_UI.SetErrorStr( L"That was not the correct pass code" );
                m_State = STATE_ERROR;
                m_NextState = STATE_GET_PIN;
                hr = m_PinEntry.BeginInput( m_DefaultGamepad );
                assert( SUCCEEDED(hr) );
            }
        }
        break;
    default:
        m_UI.SetErrorStr( L"PIN entry failure" );
        m_State = STATE_ERROR;
        m_NextState = STATE_GET_PIN;
        hr = m_PinEntry.BeginInput( m_DefaultGamepad );
        assert( SUCCEEDED(hr) );
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateLoggingOn()
// Desc: Spin during authentication
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateLoggingOn( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        
        // Cancel the task
        m_hOnlineTask.Close();
        m_State = STATE_SELECT_ACCOUNT;
        return;
    }
    
    HRESULT hr = m_hOnlineTask.Continue();
    
    if( FAILED( hr ) )
    {
        m_UI.SetErrorStr( L"Login Failed. Try again." );
        m_hOnlineTask.Close();
        Reset( TRUE );
        return;
    }
    
    // Check login status to see if it has completed
    if( hr == XONLINE_S_LOGON_CONNECTION_ESTABLISHED )
    {
        BOOL bSuccess = TRUE;
        HRESULT hrService = S_OK;
        
        // Check for general errors
        if( FAILED(hr) )
        {
			m_UI.SetErrorStr( L"Login failed.\n\n"
				L"Error %x returned by "
				L"XOnlineTaskContinue", hr );
            bSuccess = FALSE;
        }
        else
        {
			// Next, check if the user was actually logged on
			PXONLINE_USER pLoggedOnUsers = XOnlineGetLogonUsers();
			
			assert( pLoggedOnUsers );
			
			hr = pLoggedOnUsers[ m_dwCurrUser ].hr;
			
			if( FAILED( hr ) )
			{
				m_UI.SetErrorStr( L"User Login failed (Error 0x%x)",
					hr );
				bSuccess = FALSE;
			}
            else
			{
				// Check for service errors
				// Check for service errors
				for( DWORD i = 0; i < NUM_SERVICES; ++i )
				{
					if( FAILED( hrService = XOnlineGetServiceInfo( 
						m_pServices[i],NULL ) ) )
					{
						m_UI.SetErrorStr( L"Login failed.\n\n"
							L"Error 0x%x logging into service %d",
							hrService, m_pServices[i] );
						bSuccess = FALSE;
						break;
					}
				}
			}
        }
        
        if( bSuccess )
        {
            // We're now on the system
            m_bIsLoggedOn = TRUE;
            
            // Notify the world
            DWORD dwState = XONLINE_FRIENDSTATE_FLAG_ONLINE;
            if( XBVoice_HasDevice() )
                dwState |= XONLINE_FRIENDSTATE_FLAG_VOICE;
            SetPlayerState( dwState );
            
            // Allow player to select match type
            m_dwCurrItem = 0;
            m_State = STATE_SELECT_MATCH;
        }
        else
        {
            Reset( TRUE );
            m_State = STATE_ERROR;
            m_NextState = STATE_SELECT_ACCOUNT;
            m_hOnlineTask.Close();
        }
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateSelectMatch()
// Desc: Player chooses matchmaking type
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSelectMatch( Event ev )
{
    // If we're not logged in, need to do that before we can start matchmaking
    if( !m_bIsLoggedOn )
    {
        m_State = STATE_SELECT_ACCOUNT;
        return;
    }
    
    switch( ev )
    {
    case EV_BUTTON_A:
        
        // Match type chosen
        if( m_dwCurrItem == MATCH_QUICK )
        {
            // Start lookin' for games
            m_State = STATE_GAME_SEARCH;
            m_bIsQuickMatch = TRUE;
            BeginSessionSearch();
        }
        else
        {
            // Start building search criteria
            m_bIsQuickMatch = FALSE;
            m_dwCurrItem = 0;
            m_State = STATE_OPTIMATCH;
        }
        break;
        
    case EV_UP:
        // Move to previous item; allow wrap to bottom
        if( m_dwCurrItem == 0 )
            m_dwCurrItem = MATCH_MAX - 1;
        else
            --m_dwCurrItem;
        break;
        
    case EV_DOWN:
        // Move to next item; allow wrap to top
        if( m_dwCurrItem == MATCH_MAX - 1 )
            m_dwCurrItem = 0;
        else
            ++m_dwCurrItem;
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateOptiMatch()
// Desc: Player customizes game settings
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateOptiMatch( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        switch( m_dwCurrItem )
        {
        case CUSTOM_TYPE:
            m_State = STATE_SELECT_TYPE;
            m_dwCurrItem = DWORD( m_Session.GetGameType() );
            break;
        case CUSTOM_LEVEL:
            m_State = STATE_SELECT_LEVEL;
            switch( *m_Session.GetPlayerLevel() )
            {
            case 0    : m_dwCurrItem = 0; break; 
            case L'B' : m_dwCurrItem = 1; break;
            case L'I' : m_dwCurrItem = 2; break;
            case L'A' : m_dwCurrItem = 3; break;
            default  : assert( FALSE );  break;
            }
            break;
            case CUSTOM_STYLE:
                m_State = STATE_SELECT_STYLE;
                switch( *m_Session.GetStylePtr() )
                {
                case BYTE(  0  ): m_dwCurrItem = 0; break;
                case BYTE( 'H' ): m_dwCurrItem = 1; break;
                case BYTE( 'L' ): m_dwCurrItem = 2; break;
                case BYTE( 'M' ): m_dwCurrItem = 3; break;
                default:          assert( FALSE );  break;
                }
                if( m_Session.GetStyleLen() == 0 )
                    m_dwCurrItem = 0;
                break;
                case CUSTOM_NAME:
                    m_State = STATE_SELECT_NAME;
                    m_dwCurrItem = 0;
                    
                    // Build a list of potential session names
                    m_SessionNames.clear();
                    for( DWORD i = 0; i < MAX_SESSION_NAMES; ++i )
                    {
                        WCHAR strSessionName[ MAX_SESSION_STR ];
                        m_rand.GetName( strSessionName, MAX_SESSION_STR );
                        m_SessionNames.push_back( strSessionName );
                    }
                    break;
                case CUSTOM_FIND:
                    // Time to initiate search
                    m_State = STATE_GAME_SEARCH;
                    BeginSessionSearch();
                    break;
                default:
                    assert( FALSE );
                    break;
        }
        break;
        
        case EV_BUTTON_B:
        case EV_BUTTON_BACK:
            // Return to match menu
            Reset( FALSE );
            break;
            
        case EV_UP:
            // Move to previous item; allow wrap to bottom
            if( m_dwCurrItem == 0 )
                m_dwCurrItem = CUSTOM_MAX - 1;
            else
                --m_dwCurrItem;
            break;
            
        case EV_DOWN:
            // Move to next item; allow wrap to top
            if( m_dwCurrItem == CUSTOM_MAX - 1 )
                m_dwCurrItem = 0;
            else
                ++m_dwCurrItem;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateSelectType()
// Desc: Select game type
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSelectType( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        // Game type was chosen
        m_Session.SetGameType( m_dwCurrItem );
        // Fall thru to return to previous menu
        
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        // Return to customize menu
        m_State = STATE_OPTIMATCH;
        m_dwCurrItem = 0;
        break;
        
    case EV_UP:
        // Move to previous item; allow wrap to bottom
        if( m_dwCurrItem == 0 )
            m_dwCurrItem = TYPE_MAX - 1;
        else
            --m_dwCurrItem;
        break;
        
    case EV_DOWN:
        // Move to next item; allow wrap to top
        if( m_dwCurrItem == TYPE_MAX - 1 )
            m_dwCurrItem = 0;
        else
            ++m_dwCurrItem;
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateSelectLevel()
// Desc: Select player rating
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSelectLevel( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        // Player level was chosen
        switch( m_dwCurrItem )
        {
        case LEVEL_ANY:
            m_Session.SetPlayerLevel( L"" );
            break;
        case LEVEL_BEGINNER:
            m_Session.SetPlayerLevel( strBEGINNER );
            break;
        case LEVEL_INTERMEDIATE:
            m_Session.SetPlayerLevel( strINTERMEDIATE );
            break;
        case LEVEL_ADVANCED:
            m_Session.SetPlayerLevel( strADVANCED );
            break;
        default:
            assert( FALSE );
            break;
        }
        // Fall thru to return to previous menu
        
        case EV_BUTTON_B:
        case EV_BUTTON_BACK:
            // Return to customize menu
            m_State = STATE_OPTIMATCH;
            m_dwCurrItem = 0;
            break;
            
        case EV_UP:
            // Move to previous item; allow wrap to bottom
            if( m_dwCurrItem == 0 )
                m_dwCurrItem = LEVEL_MAX - 1;
            else
                --m_dwCurrItem;
            break;
            
        case EV_DOWN:
            // Move to next item; allow wrap to top
            if( m_dwCurrItem == LEVEL_MAX - 1 )
                m_dwCurrItem = 0;
            else
                ++m_dwCurrItem;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateSelectStyle()
// Desc: Select game style
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSelectStyle( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        // Game style was chosen
        m_Session.SetStyle( "\0", 0 );
        switch( m_dwCurrItem )
        {
        case STYLE_ANY:
            break;
        case STYLE_HEAVY:
            m_Session.SetStyle( strHEAVY, WORD( lstrlenA( strHEAVY ) ) );
            break;
        case STYLE_LIGHT:
            m_Session.SetStyle( strLIGHT, WORD( lstrlenA( strLIGHT ) ) );
            break;
        case STYLE_MIXED:
            m_Session.SetStyle( strMIXED, WORD( lstrlenA( strMIXED ) ) );
            break;
        default:
            assert( FALSE );
            break;
        }
        // Fall thru to return to previous menu
        
        case EV_BUTTON_B:
        case EV_BUTTON_BACK:
            // Return to customize menu
            m_State = STATE_OPTIMATCH;
            m_dwCurrItem = 0;
            break;
            
        case EV_UP:
            // Move to previous item; allow wrap to bottom
            if( m_dwCurrItem == 0 )
                m_dwCurrItem = STYLE_MAX - 1;
            else
                --m_dwCurrItem;
            break;
            
        case EV_DOWN:
            // Move to next item; allow wrap to top
            if( m_dwCurrItem == STYLE_MAX - 1 )
                m_dwCurrItem = 0;
            else
                ++m_dwCurrItem;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateSelectName()
// Desc: Select game name
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSelectName( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        // Game name was chosen
        m_Session.SetSessionName( m_SessionNames[ m_dwCurrItem ].c_str() );
        // Fall thru to return to previous menu
        
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        // Return to customize menu
        m_State = STATE_OPTIMATCH;
        m_dwCurrItem = 0;
        break;
        
    case EV_UP:
        // Move to previous item; allow wrap to bottom
        if( m_dwCurrItem == 0 )
            m_dwCurrItem = m_SessionNames.size() - 1;
        else
            --m_dwCurrItem;
        break;
        
    case EV_DOWN:
        // Move to next item; allow wrap to top
        if( m_dwCurrItem == m_SessionNames.size() - 1 )
            m_dwCurrItem = 0;
        else
            ++m_dwCurrItem;
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateSelectSession()
// Desc: Select game session
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateSelectSession( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        // Join selected session
        m_dwSessionIndex = m_dwCurrItem;
        m_State = STATE_REQUEST_JOIN;
        BeginJoinSession();
        break;
        
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        // Return to customize menu
        m_State = STATE_OPTIMATCH;
        m_dwCurrItem = 0;
        break;
        
    case EV_UP:
        // Move to previous item; allow wrap to bottom
        if( m_dwCurrItem == 0 )
            m_dwCurrItem = m_SessionList.size() - 1;
        else
            --m_dwCurrItem;
        break;
        
    case EV_DOWN:
        // Move to next item; allow wrap to top
        if( m_dwCurrItem == m_SessionList.size() - 1 )
            m_dwCurrItem = 0;
        else
            ++m_dwCurrItem;
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateGameSearch()
// Desc: Searching for matching game session
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateGameSearch( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        CancelMatch();
        m_dwCurrItem = 0;
        if( m_bIsQuickMatch )
        {
            m_State = STATE_SELECT_MATCH;
        }
        else
        {
            m_State = STATE_OPTIMATCH;
        }
        return;
    }
    
    // Wait for matchmaking server to return results
    HRESULT hr = m_hMatchTask.Continue();
    if( hr != XONLINETASK_S_RUNNING )
    {
        // Handle errors
        if( FAILED(hr) )
        {
            m_hMatchTask.Close();
            m_UI.SetErrorStr( L"Game search failed with error %x", hr );
            Reset( TRUE );
            return;
        }
        
        // Get the list returned by the matchmaking server
        PXMATCH_SEARCHRESULT *ppSearchResult;
        DWORD dwResults;
        hr = XOnlineMatchSearchGetResults( m_hMatchTask, &ppSearchResult,
            &dwResults );
        
        // Handle errors
        if( FAILED(hr) )
        {
            m_hMatchTask.Close();
            m_UI.SetErrorStr( L"Game search get results failed with error %x", hr );
            Reset( TRUE );
            return;
        }
        
        m_SessionList.clear();
        
        // Save the results
        for( DWORD i = 0; i < dwResults; ++i )
        {
            m_SessionList.push_back( SessionInfo( *ppSearchResult[i],
                m_hMatchTask, i ) );
        }
        
        // The search is over
        m_hMatchTask.Close();
        
        // If we found at least one game, join it automatically
        if( dwResults > 0 )
        {
            // If there was more than one session available and
            // this isn't a quick match then display a list of
            // session to select from
            if( !m_bIsQuickMatch )
            {
                m_dwCurrItem = 0;
                m_State = STATE_SELECT_SESSION;
            }
            else
            {
                m_State = STATE_REQUEST_JOIN;
                BeginJoinSession();
            }
        }
        // We didn't find any sessions, so we'll create our own
        else
        {
            m_State = STATE_CREATE_SESSION;
            BeginCreateSession();
        }
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateRequestJoin()
// Desc: Joining session
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateRequestJoin( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        // Cancel request; return to match menu
        Reset( FALSE );
        m_GameJoinTimer.Stop();
        break;
    }
    
    // See if the game has replied
    m_GameMsg.ProcessMessages( m_Players );
    
    // We wait for up to GAME_JOIN_TIME seconds. If the game didn't
    // respond, display an error message, then create our own session.
    if( m_GameJoinTimer.GetElapsedSeconds() > GAME_JOIN_TIME )
    {
        m_GameJoinTimer.Stop();
        m_State = STATE_ERROR;
        m_UI.SetErrorStr( L"Game did not respond" );
        m_NextState = STATE_CREATE_SESSION;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateCreateSession()
// Desc: Creating session
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateCreateSession( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        CancelMatch();
        return;
    }
    
    // Wait for matchmaking server to save new session info
    HRESULT hr = m_hMatchTask.Continue();
    if( hr != XONLINETASK_S_RUNNING )
    {
        // Clear any registered sessions
        if( m_bIsSessionRegistered )
        {
            INT iResult = XNetUnregisterKey( &m_xnSessionID );
            assert( iResult == NO_ERROR );
            (VOID)iResult;
            m_bIsSessionRegistered = FALSE;
            ZeroMemory( &m_xnSessionID, sizeof( XNKID ) );
        }
        
        // Extract the new session ID
        hr = XOnlineMatchSessionGetInfo( m_hMatchTask, &m_xnSessionID, &m_xnKeyExchangeKey );
        
        // Handle errors
        if( FAILED(hr) )
        {
            m_hMatchTask.Close();
            m_UI.SetErrorStr( L"Game session creation failed with error %x", hr );
            Reset( TRUE );
            return;
        }
        INT iKeyRegistered = XNetRegisterKey( &m_xnSessionID, 
            &m_xnKeyExchangeKey );
        
        if( iKeyRegistered != NO_ERROR )
        {
            m_hMatchTask.Close();
            hr = E_FAIL;
            m_UI.SetErrorStr( L"XNetRegisterKey failed");
            Reset( TRUE );
            return;
        }
        
        m_bIsSessionRegistered = TRUE;
        
        // We are now the host of a new game
        m_bIsHost = TRUE;
        m_State = STATE_PLAY_GAME;
        m_dwCurrItem = 0;
        m_HeartbeatTimer.StartZero();
        SetStatus( L"Created Session" );
        
        // Notify the world of our state change
        DWORD dwState = XONLINE_FRIENDSTATE_FLAG_ONLINE |
            XONLINE_FRIENDSTATE_FLAG_PLAYING |
            XONLINE_FRIENDSTATE_FLAG_JOINABLE;
        if( XBVoice_HasDevice() )
            dwState |= XONLINE_FRIENDSTATE_FLAG_VOICE;
        SetPlayerState( dwState );
        
        m_GameMsg.SetUser( m_strUser, m_bIsHost );
        m_GameMsg.SetSessionID( m_xnSessionID );
        
        // Note that the session remains "active" (m_hMatchTask isn't
        // closed), because we want to update the session attributes
        // as players come and go.
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStatePlayGame()
// Desc: Play game
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStatePlayGame( Event ev )
{
    // Handle net messages
    if( m_GameMsg.ProcessMessages( m_Players ) )
        return;
    
    // Send keep-alives
    if( m_HeartbeatTimer.GetElapsedSeconds() > PLAYER_HEARTBEAT )
    {
        m_GameMsg.SendHeartbeat( m_Players );
        m_HeartbeatTimer.StartZero();
    }
    
    // Handle other players dropping
    if( m_GameMsg.ProcessPlayerDropouts( m_Players, PLAYER_TIMEOUT ) )
        return;
    
    // Handle session updates
    if( m_bIsHost )
    {
        HRESULT hr = m_hMatchTask.Continue();
        if( hr != XONLINETASK_S_RUNNING )
        {
            // Handle errors
            if( FAILED(hr) )
            {
                m_hMatchTask.Close();
                m_UI.SetErrorStr( L"XMatch failed with error %x", hr );
                Reset( TRUE );
                return;
            }
            
            // If there are session updates that need to be processed,
            // remove them from the queue and send the update to the
            // matchmaking server.
            if( !m_SessionUpdateQ.empty() )
            {
                BeginSessionUpdate( m_SessionUpdateQ.front() );
                m_SessionUpdateQ.pop();
            }
        }
    }
    
    switch( ev )
    {
    case EV_BUTTON_A:
        switch( m_dwCurrItem )
        {
        case GAME_WAVE:  SendWave();      break;
        case GAME_LEAVE: LeaveGame();     break;
        default:         assert( FALSE ); break;
        }
        break;
        
        case EV_UP:
            // Move to previous item; allow wrap to bottom
            if( m_dwCurrItem == 0 )
                m_dwCurrItem = GAME_MAX - 1;
            else
                --m_dwCurrItem;
            break;
            
        case EV_DOWN:
            // Move to next item; allow wrap to top
            if( m_dwCurrItem == GAME_MAX - 1 )
                m_dwCurrItem = 0;
            else
                ++m_dwCurrItem;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateDeleteSession()
// Desc: Delete game session from matchmaking server
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateDeleteSession( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_B:
    case EV_BUTTON_BACK:
        CancelMatch();
        return;
    }
    
    HRESULT hr = m_hMatchTask.Continue();
    if( hr != XONLINETASK_S_RUNNING )
    {
        m_hMatchTask.Close();
        
        // Handle errors
        if( FAILED(hr) )
        {
            m_UI.SetErrorStr( L"Game session deletion failed with error %x", hr );
            Reset( TRUE );
            return;
        }
        
        // Return to matchmaking
        Reset( FALSE );
    }
}




//-----------------------------------------------------------------------------
// Name: UpdateStateError()
// Desc: Handle error screen
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateStateError( Event ev )
{
    switch( ev )
    {
    case EV_BUTTON_A:
        m_State = m_NextState;
        
        // Special case: if the next state is "create session," we must
        // begin the session creation process
        if( m_State == STATE_CREATE_SESSION )
            BeginCreateSession();
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: BeginLogin()
// Desc: Initiate the authentication process
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginLogin()
{
    // Select a reasonable controller for the current player by choosing
    // the first controller found. Game code should do this much more
    // precisely. See below for details.
    for( m_dwUserIndex = 0; m_dwUserIndex < XGetPortCount(); ++m_dwUserIndex )
    {
        if( m_Gamepad[m_dwUserIndex].hDevice )
            break;
    }
    if( m_dwUserIndex >= XGetPortCount() )
        m_dwUserIndex = 0;
    
    // XOnlineLogon() allows a list of up to 4 players (1 per controller)
    // to login in a single call. This sample shows how to authenticate
    // a single user. The list must be a one-to-one match of controller 
    // to player in order for the online system to recognize which player
    // is using which controller.
    XONLINE_USER pUserList[ XGetPortCount() ] = { 0 };
    CopyMemory( &pUserList[ m_dwUserIndex ], &m_UserList[ m_dwCurrUser ],
        sizeof( XONLINE_USER ) );
    
    // Initiate the login process. XOnlineTaskContinue() is used to poll
    // the status of the login.
    HRESULT hr = XOnlineLogon( pUserList, m_pServices, NUM_SERVICES, 
        NULL, &m_hOnlineTask );
    
    if( FAILED(hr) )
    {
        m_hOnlineTask.Close();
        m_UI.SetErrorStr( L"Login failed to start. Error %x", hr );
        Reset( TRUE );
    }
}




//-----------------------------------------------------------------------------
// Name: BeginSessionSearch()
// Desc: Initiate the game search process
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginSessionSearch()
{
    assert( m_hMatchTask == NULL );
    
    
    // Initialize the search request
    XONLINE_ATTRIBUTE SearchAttributes[ 3 ];
    
    if( !m_bIsQuickMatch )
    {
        // Note: These parameters are specific to the stored procedure
        // SEARCH_ID_CUSTOM_1 for this specific sample (based
        // on Title ID). This method is shown as an example of what
        // games can specify when searching for a particular session.
        // This code ONLY WORKS IN THE CONTEXT OF THIS SAMPLE. 
        // In the future, game developers will create and establish
        // their own stored procedures in conjunction with the Xbox 
        // ATG and Xbox online teams. These stored procedures will 
        // be hosted on the Xbox matchmaking servers and allow game 
        // developers to tailor session searching to the requirements 
        // of their game.
        
        // The first (and only) integer parameter is the game type.
        // To match on any game type, pass -1
        SearchAttributes[0].dwAttributeID = X_ATTRIBUTE_DATATYPE_INTEGER;
        SearchAttributes[0].info.integer.qwValue = 
            ( m_Session.GetGameType() == 0 ) ? -1 : m_Session.GetGameType();
        
        // The first (and only) string parameter is the player level.
        // If level == any, empty specifies match all
        SearchAttributes[1].dwAttributeID = X_ATTRIBUTE_DATATYPE_STRING;
        SearchAttributes[1].info.string.pwszValue = m_Session.GetPlayerLevel();
        
        // The first (and only) blob parameter is the game style.
        // If style == any, 0 length specifies match all
        VOID* pBlob = (VOID*)( m_Session.GetStylePtr() );
        
        SearchAttributes[2].dwAttributeID = X_ATTRIBUTE_DATATYPE_BLOB;
        SearchAttributes[2].info.blob.pvValue = pBlob;
        SearchAttributes[2].info.blob.dwLength = m_Session.GetStyleLen();
        
    }
    else
    {
        // The first (and only) integer parameter is the game type.
        // To match on any game type, pass -1
        SearchAttributes[0].dwAttributeID = X_ATTRIBUTE_DATATYPE_INTEGER;
        SearchAttributes[0].info.integer.qwValue = ULONGLONG(-1);
        
        // The first (and only) string parameter is the player level.
        // If level == any, empty specifies match all
        SearchAttributes[1].dwAttributeID = X_ATTRIBUTE_DATATYPE_STRING;
        SearchAttributes[1].info.string.pwszValue = L"";
        
        // The first (and only) blob parameter is the game style.
        // If style == any, 0 length specifies match all
        SearchAttributes[2].dwAttributeID = X_ATTRIBUTE_DATATYPE_BLOB;
        SearchAttributes[2].info.blob.pvValue = NULL;
        SearchAttributes[2].info.blob.dwLength = 0;
    }
    
    
    HRESULT hr = XOnlineMatchSearch( SEARCH_ID_CUSTOM_1,
        MAX_RESULTS,
        3,
        SearchAttributes,
        MAX_RESULTS_LEN,
        NULL, &m_hMatchTask );
    
    if( FAILED(hr) )
    {
        m_hMatchTask.Close();
        m_UI.SetErrorStr( L"Game search failed to start. Error %x", hr );
        Reset( TRUE );
    }
}




//-----------------------------------------------------------------------------
// Name: BeginCreateSession()
// Desc: Initiate the game session creation process
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginCreateSession()
{
    // Generate a random session name if we don't currently have one
    if( *m_Session.GetSessionName() == 0 )
        m_Session.GenRandSessionName( m_rand );
    
    assert( m_hMatchTask == NULL );
    
    // Initialize the create request
    
    
    // Set session attributes 
    
    // Game type
    //---------------------------------------------------------------------
    // If not specified, default to TYPE_SHORT.
    // Game type is the first and only session integer parameter.
    if( m_Session.GetGameType() == TYPE_ANY )
        m_Session.SetGameType( TYPE_SHORT );
    m_SessionAttributes[0].fChanged = TRUE;
    m_SessionAttributes[0].dwAttributeID = XATTRIB_TYPE;
    m_SessionAttributes[0].info.integer.qwValue = m_Session.GetGameType();
    
    // Player level
    //---------------------------------------------------------------------
    // If not specified, default to LEVEL_BEGINNER.
    // Player level is the first session string parameter.
    if( *m_Session.GetPlayerLevel() == 0 )
        m_Session.SetPlayerLevel( strBEGINNER );    
    m_SessionAttributes[1].fChanged = TRUE;
    m_SessionAttributes[1].dwAttributeID = XATTRIB_LEVEL;
    m_SessionAttributes[1].info.string.pwszValue = m_Session.GetPlayerLevel();
    
    // Session name
    //---------------------------------------------------------------------
    // Always specified.
    // The second session string parameter.
    assert( *m_Session.GetSessionName() != 0 );
    m_SessionAttributes[2].fChanged = TRUE;
    m_SessionAttributes[2].dwAttributeID = XATTRIB_SNAME;
    m_SessionAttributes[2].info.string.pwszValue = m_Session.GetSessionName();
    
    // Game style
    //---------------------------------------------------------------------
    // If not specified, default to STYLE_HEAVY.
    // The first (and only) session blob parameter.
    if( m_Session.GetStyleLen() == 0 )
        m_Session.SetStyle( strHEAVY,  WORD( lstrlenA( strHEAVY ) ) );
    VOID* pBlob = (VOID*)( m_Session.GetStylePtr() );   
    m_SessionAttributes[3].fChanged = TRUE;
    m_SessionAttributes[3].dwAttributeID = XATTRIB_STYLE;
    m_SessionAttributes[3].info.blob.pvValue = pBlob;
    m_SessionAttributes[3].info.blob.dwLength = m_Session.GetStyleLen();
    
    // The first (and only) user parameter is the player name
    m_Session.SetOwnerName( m_strUser );
    m_SessionAttributes[4].fChanged = TRUE;
    m_SessionAttributes[4].dwAttributeID = XATTRIB_PNAME;
    m_SessionAttributes[4].info.string.pwszValue = m_Session.GetOwnerName();
    
    m_dwSlotsInUse = 1;
    
    // Limit the number of players to MAX_PLAYERS public slots and no
    // private (invitation only) slots. Note that we add ourself as a player.
    HRESULT hr = XOnlineMatchSessionCreate( m_dwSlotsInUse, MAX_PLAYERS - m_dwSlotsInUse, // Public Slots
        0, 0, // Private Slots
        MAX_SESSION_ATTRIBS,
        m_SessionAttributes,  // Attributes
        NULL, &m_hMatchTask );
    
    // Reset the changed flag on each attribute
    // so that during the next session update, 
    // needless processing isn't wasted on
    // attributes which have not changed
    for(DWORD i = 0; i < MAX_SESSION_ATTRIBS; ++i)
        m_SessionAttributes[i].fChanged = FALSE;
    
    if( FAILED( hr ) )
    {
        m_hMatchTask.Close();
        m_UI.SetErrorStr( L"Game session failed to start. Error %x", hr );
        Reset( TRUE );
    }
}




//-----------------------------------------------------------------------------
// Name: BeginSessionUpdate()
// Desc: Notify match server about session change
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginSessionUpdate( SESSION_UPDATE_ACTION dwAction )
{
    assert( m_hMatchTask != NULL );
    
    
    if( dwAction == ADD_PLAYER )
        ++m_dwSlotsInUse;
    else // remove player
        --m_dwSlotsInUse;
    
    m_hMatchTask.Close();
    
    HRESULT hr = XOnlineMatchSessionUpdate( m_xnSessionID,
        m_dwSlotsInUse, 
        MAX_PLAYERS - m_dwSlotsInUse,
        0, 0, // Private Slots
        MAX_SESSION_ATTRIBS,
        m_SessionAttributes,  // Attributes
        NULL, &m_hMatchTask );
    
    // Notify the match server
    if( FAILED(hr) )
    {
        m_UI.SetErrorStr( L"Game session failed to update. Error %x", hr );
        Reset( TRUE );
    }
    
}




//-----------------------------------------------------------------------------
// Name: BeginDeleteSession()
// Desc: Initiate the game session removal process
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginDeleteSession()
{
    assert( m_hMatchTask == NULL );
    
    // Initialize the delete request
    HRESULT hr = XOnlineMatchSessionDelete( m_xnSessionID, NULL, &m_hMatchTask );
    if( FAILED(hr) )
    {
        m_hMatchTask.Close();
        m_UI.SetErrorStr( L"Failed to start session deletion. Error %x", hr );
        Reset( TRUE );
    }
}




//-----------------------------------------------------------------------------
// Name: BeginJoinSession()
// Desc: Attempt to join a game
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginJoinSession()
{
    assert( m_SessionList.size() > 0 );
    
    SessionInfo& Session = m_SessionList[ m_dwSessionIndex ];
    
    // Clear any registered sessions
    if( m_bIsSessionRegistered )
    {
        INT iResult = XNetUnregisterKey( &m_xnSessionID );
        assert( iResult == NO_ERROR );
        (VOID)iResult;
        m_bIsSessionRegistered = FALSE;
        ZeroMemory( &m_xnSessionID, sizeof( XNKID ) );
    }
    
    // We found a valid session with an available player slot.
    // Register the session key.
    INT iResult = XNetRegisterKey( Session.GetSessionID(),
        Session.GetKeyExchangeKey() );
    if( iResult != NO_ERROR )
    {
        m_UI.SetErrorStr( L"Unable to establish session with game" );
        Reset( TRUE );
        return;
    }
    m_bIsSessionRegistered = TRUE;
    
    // Save the key ID because we need to unregister it laer
    CopyMemory( &m_xnSessionID, Session.GetSessionID(), sizeof( XNKID ) );
    
    // Store the game name
    m_Session.SetSessionName( Session.GetSessionName() );
    m_Session.SetGameType( Session.GetGameType() );
    m_Session.SetPlayerLevel( Session.GetPlayerLevel() );
    m_Session.SetOwnerName( Session.GetOwnerName () );
    m_Session.SetStyle( Session.GetStylePtr(), Session.GetStyleLen() );
    
    // Convert the XNADDR of the host to the INADDR we'll use to
    // join the game
    iResult = XNetXnAddrToInAddr( Session.GetHostAddr(),
        &m_xnSessionID, &m_inHostAddr );
    assert( iResult == NO_ERROR );
    
    m_GameMsg.SetUser( m_strUser, FALSE );
    m_GameMsg.SetSessionID( m_xnSessionID );
    
    // Request join approval from the game and await a response
    m_GameMsg.SendJoinGame( CXBSockAddr( m_inHostAddr, GameMsg::GAME_PORT ),
        m_strUser, m_qwUserID );
    m_GameJoinTimer.StartZero();
}




//-----------------------------------------------------------------------------
// Name: BeginAddPlayer()
// Desc: Notify match server about new player
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginAddPlayer()
{
    // Match tasks need to be queued up so that there's never 2+
    // XOnlineMatchSessionUpdates in progress at a time
    m_SessionUpdateQ.push( ADD_PLAYER );
}




//-----------------------------------------------------------------------------
// Name: BeginRemovePlayer()
// Desc: Notify match server about player departure
//-----------------------------------------------------------------------------
VOID CXBoxSample::BeginRemovePlayer()
{
    // Match tasks need to be queued up so that there's never 2+
    // XOnlineMatchSessionUpdates in progress at a time
    m_SessionUpdateQ.push( REMOVE_PLAYER );
}




//-----------------------------------------------------------------------------
// Name: SendWave()
// Desc: Wave to all other players in game
//-----------------------------------------------------------------------------
VOID CXBoxSample::SendWave()
{
    // Indicate that you waved
    SetStatus( L"You waved" );
    m_GameMsg.SendWave( m_Players );
}




//-----------------------------------------------------------------------------
// Name: LeaveGame()
// Desc: Exit the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::LeaveGame()
{
    // Other players will detect that we left because they will no longer
    // receive heartbeats
    
    // If the host leaves, remove the session from the matchmaking server
    if( m_bIsHost )
    {
        m_bIsHost = FALSE;
        m_State = STATE_DELETE_SESSION;
        m_hMatchTask.Close();
        m_HeartbeatTimer.Stop();
        m_Players.clear();
        BeginDeleteSession();
    }
    else
    {
        Reset( FALSE );
    }
    
    // Notify the world of our state change
    DWORD dwState = XONLINE_FRIENDSTATE_FLAG_ONLINE;
    if( XBVoice_HasDevice() )
        dwState |= XONLINE_FRIENDSTATE_FLAG_VOICE;
    SetPlayerState( dwState );
}




//-----------------------------------------------------------------------------
// Name: OnJoinGame
// Desc: Handle new player joining game that we host
//-----------------------------------------------------------------------------
VOID CXBoxSample::OnJoinGame( const CXBNetPlayerInfo& playerInfo )
{
    m_Players.push_back( playerInfo );
    SetStatus( L"%.*s has joined the game", MAX_PLAYER_STR, playerInfo.strPlayerName );
    
    // Queue up this request for the matchmaking server
    BeginAddPlayer();
}




//-----------------------------------------------------------------------------
// Name: OnJoinApproved
// Desc: We've been approved for game entry by the given host
//-----------------------------------------------------------------------------
VOID CXBoxSample::OnJoinApproved( const CXBNetPlayerInfo& hostInfo )
{
    m_Players.push_back( hostInfo );
    
    // Enter into the game UI
    m_State = STATE_PLAY_GAME;
    
    // Set the default game item to "wave"
    m_dwCurrItem = GAME_WAVE;
    
    SetStatus( L"You have joined the game" );
    m_HeartbeatTimer.StartZero();
    
    m_GameMsg.SetUser( m_strUser, FALSE );
    
    // Notify the world of our state change
    DWORD dwState = XONLINE_FRIENDSTATE_FLAG_ONLINE |
        XONLINE_FRIENDSTATE_FLAG_PLAYING;
    if( XBVoice_HasDevice() )
        dwState |= XONLINE_FRIENDSTATE_FLAG_VOICE;
    SetPlayerState( dwState );
}




//-----------------------------------------------------------------------------
// Name: OnJoinApprovedAddPlayer
// Desc: Receiving information on others players already in the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::OnJoinApprovedAddPlayer( const CXBNetPlayerInfo& playerInfo )
{
    m_Players.push_back( playerInfo );
}




//-----------------------------------------------------------------------------
// Name: OnJoinDenied
// Desc: Handle join denied
//-----------------------------------------------------------------------------
VOID CXBoxSample::OnJoinDenied()
{
    // Only clients who are not currently playing should receive this message
    assert( m_State != STATE_PLAY_GAME );
    
    // If for some reason we receive a "join denied" message and we're
    // already playing a game, ignore the message.
    if( m_State == STATE_PLAY_GAME )
        return;
    
    // The session we wanted to join is full. Display error
    m_UI.SetErrorStr( L"The session is full.\nChoose another session." );
    m_State = STATE_ERROR;
}




//-----------------------------------------------------------------------------
// Name: OnPlayerJoined
// Desc: The given player joined our game
//-----------------------------------------------------------------------------
VOID CXBoxSample::OnPlayerJoined( const CXBNetPlayerInfo& playerInfo )
{
    MatchInAddr matchInAddr( playerInfo.inAddr );
    
    // First check to make sure the player isn't already in the list.
    // If so, remove the player first.  This can happen if the player
    // drops out of a game and rejoins before the next heartbeat.
    CXBNetPlayerList::iterator i = 
        std::find_if( m_Players.begin(), m_Players.end(), matchInAddr );
    
    if( i != m_Players.end() )
    {       
        m_Players.erase( i );
    }
    
    m_Players.push_back( playerInfo );
    SetStatus( L"%.*s has joined the game", MAX_PLAYER_STR, playerInfo.strPlayerName );
}




//-----------------------------------------------------------------------------
// Name: OnWave
// Desc: The given player waved to us
//-----------------------------------------------------------------------------
VOID CXBoxSample::OnWave( const CXBNetPlayerInfo& playerInfo )
{
    SetStatus( L"%.*s waved", MAX_PLAYER_STR, playerInfo.strPlayerName );
}




//-----------------------------------------------------------------------------
// Name: OnHeartbeat
// Desc: The given player sent us a heartbeat
//-----------------------------------------------------------------------------
VOID CXBoxSample::OnHeartbeat( const CXBNetPlayerInfo& playerInfo )
{
    MatchInAddr matchInAddr( playerInfo.inAddr );
    
    // Find out who sent a heartbeat by matching on name
    CXBNetPlayerList::iterator i = 
        std::find_if( m_Players.begin(), m_Players.end(), matchInAddr );
    
    // We expect that we know about the player
    assert( i != m_Players.end() );
    
    i->dwLastHeartbeat = GetTickCount();
}




//-----------------------------------------------------------------------------
// Name: OnPlayerDropout
// Desc: The given player left the game
//-----------------------------------------------------------------------------
VOID CXBoxSample::OnPlayerDropout( const CXBNetPlayerInfo& playerInfo, BOOL bIsHost )
{
    if( bIsHost )
    {
        SetStatus( L"Host %.*s left game.\nGame closed to new players.",
            MAX_PLAYER_STR, playerInfo.strPlayerName );
        BeginRemovePlayer();
    }
    else
    {
        SetStatus( L"%.*s left the game", MAX_PLAYER_STR, playerInfo.strPlayerName );
    }
    
    MatchInAddr matchInAddr( playerInfo.inAddr );
    
    // Find out who we need to delete by matching on name
    CXBNetPlayerList::iterator i = 
        std::find_if( m_Players.begin(), m_Players.end(), matchInAddr );
    
    // We expect that we know about the player
    assert( i != m_Players.end() );
    
    m_Players.erase( i );
}




//-----------------------------------------------------------------------------
// Name: SetStatus
// Desc: Set the status string
//-----------------------------------------------------------------------------
VOID __cdecl CXBoxSample::SetStatus( const WCHAR* strFormat, ... )
{
    va_list pArgList;
    va_start( pArgList, strFormat );
    
    INT iChars = wvsprintfW( m_strStatus, strFormat, pArgList );
    assert( iChars < MAX_STATUS_STR );
    (VOID)iChars; // avoid compiler warning
    
    va_end( pArgList );
}




//-----------------------------------------------------------------------------
// Name: CancelMatch()
// Desc: Cancel the match task and prepare to return to front menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::CancelMatch()
{
    // Cancel the task
    m_hMatchTask.Close();    
    m_dwCurrItem = 0;
}




//-----------------------------------------------------------------------------
// Name: SetPlayerState()
// Desc: Broadcast current player state for the world
//-----------------------------------------------------------------------------
VOID CXBoxSample::SetPlayerState( DWORD dwState )
{
    BOOL bSuccess = XOnlineNotificationSetState( m_dwUserIndex, dwState,
        m_xnSessionID, 0, NULL );
    assert( bSuccess );
    (VOID)bSuccess; // avoid compiler warning
}




//-----------------------------------------------------------------------------
// Name: Reset()
// Desc: Prepare to restart the application at the front menu
//-----------------------------------------------------------------------------
VOID CXBoxSample::Reset( BOOL bIsError )
{
    m_hMatchTask.Close();
    if( bIsError )
    {
        m_State = STATE_ERROR;
        m_NextState = STATE_SELECT_MATCH;
    }
    else
    {
        m_State = STATE_SELECT_MATCH;
    }
    
    m_dwCurrItem = 0;
    
    m_bIsHost = FALSE;
    m_HeartbeatTimer.Stop();
    m_Players.clear();
    
    // Clear any registered sessions
    if( m_bIsSessionRegistered )
    {
        INT iResult = XNetUnregisterKey( &m_xnSessionID );
        assert( iResult == NO_ERROR );
        (VOID)iResult; // avoid compiler warnings
        m_bIsSessionRegistered = FALSE;
        ZeroMemory( &m_xnSessionID, sizeof( XNKID ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleAuth\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleAuth\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleAuth\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleAuth\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleAuth\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleContentDownload\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleContentDownload\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleContentDownload\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\UserInterface.h ===
//-----------------------------------------------------------------------------
// File: UserInterface.h
//
// Desc: Matchmaking rendering functions
//
// Hist: 10.19.01 - Updated for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef MATCHMAKING_UI_H
#define MATCHMAKING_UI_H

#include "Common.h"
#include "XBOnline.h"




//-----------------------------------------------------------------------------
// Name: class UserInterface
// Desc: Main UI class for Matchmaking sample
//-----------------------------------------------------------------------------
class UserInterface
{
    CXBOnlineUI m_UI;

    static const D3DCOLOR COLOR_NORMAL    = CXBOnlineUI::COLOR_NORMAL;
    static const D3DCOLOR COLOR_HIGHLIGHT = CXBOnlineUI::COLOR_HIGHLIGHT;
    static const D3DCOLOR COLOR_GREEN     = CXBOnlineUI::COLOR_GREEN;

public:

    explicit UserInterface( WCHAR* );

    HRESULT Initialize();

    // Accessors
    VOID __cdecl SetErrorStr( const WCHAR*, ... );

    // UI functions
    VOID RenderSelectMatch( DWORD dwCurrItem ) const;
    VOID RenderOptiMatch(  SessionInfo&, DWORD dwCurrItem ) const;
    VOID RenderSelectType( DWORD dwCurrItem ) const;
    VOID RenderSelectStyle( DWORD dwCurrItem ) const;
    VOID RenderSelectLevel( DWORD dwCurrItem ) const;
    VOID RenderSelectName( DWORD dwCurrItem, const SessionNameList& ) const;
    VOID RenderSelectSession( DWORD dwCurrItem, SessionList& ) const;

    VOID RenderCreateAccount( BOOL bHasMachineAccount ) const;
    VOID RenderSelectAccount( DWORD, XBUserList& ) const;
    VOID RenderGetPin( const CXBPinEntry&, const WCHAR* ) const;
    VOID RenderLoggingOn() const;
    VOID RenderCancel() const;

    VOID RenderGameSearch() const;
    VOID RenderRequestJoin() const;
    VOID RenderCreateSession() const;
    VOID RenderPlayGame( SessionInfo&, WCHAR* strUser,
                         WCHAR* strStatus, DWORD dwPlayerCount, 
                         DWORD dwCurrItem ) const;
    VOID RenderDeleteSession() const;
    VOID RenderError() const;

private:

    // Disabled
    UserInterface();
    UserInterface( const UserInterface& );

};

#endif // MATCHMAKING_UI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\MatchMaking\UserInterface.cpp ===
//-----------------------------------------------------------------------------
// File: UserInterface.cpp
//
// Desc: Matchmaking rendering functions
//
// Hist: 10.19.01 - Updated for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "UserInterface.h"
#include "Resource.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const WCHAR* const strANY          = L"Any";

const WCHAR* const strSHORT        = L"Short";
const WCHAR* const strMEDIUM       = L"Medium";
const WCHAR* const strLONG         = L"Long";

const WCHAR* const strBEGINNER     = L"Beginner";
const WCHAR* const strINTERMEDIATE = L"Intermediate";
const WCHAR* const strADVANCED     = L"Advanced";

const  CHAR* const strHEAVY        =  "Heavy";
const  CHAR* const strLIGHT        =  "Light";
const  CHAR* const strMIXED        =  "Mixed";

const WCHAR* const strHEAVYw       = L"Heavy";
const WCHAR* const strLIGHTw       = L"Light";
const WCHAR* const strMIXEDw       = L"Mixed";




//-----------------------------------------------------------------------------
// Name: UserInterface()
// Desc: Constructor
//-----------------------------------------------------------------------------
UserInterface::UserInterface( WCHAR* strFrameRate )
:
    m_UI( strFrameRate, L"MatchMaking" )
{
}




//-----------------------------------------------------------------------------
// Name: SetErrorStr()
// Desc: Set error string
//-----------------------------------------------------------------------------
VOID __cdecl UserInterface::SetErrorStr( const WCHAR* strFormat, ... )
{
    va_list pArgList;
    va_start( pArgList, strFormat );

    m_UI.SetErrorStr( strFormat, pArgList );

    va_end( pArgList );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT UserInterface::Initialize()
{
    return m_UI.Initialize( Resource_NUM_RESOURCES, Resource_MenuSelect_OFFSET );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectMatch()
// Desc: Display matchmaking menu
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSelectMatch( DWORD dwCurrItem ) const
{
    m_UI.RenderHeader();

    m_UI.DrawText( 320, 140, COLOR_NORMAL, L"Find Game Session",
                   XBFONT_CENTER_X );

    const WCHAR* const strMatch[] =
    {
        L"QuickMatch",
        L"OptiMatch"
    };

    const FLOAT fYtop = 200.0f;
    const FLOAT fYdelta = 50.0f;

    for( DWORD i = 0; i < MATCH_MAX; ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_UI.DrawText( 260, fYtop + (fYdelta * i), dwColor, strMatch[i] );
    }

    // Show selected item with little triangle
    m_UI.RenderMenuSelector( 220.0f, fYtop + (fYdelta * dwCurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderOptiMatch()
// Desc: Display OptiMatch screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderOptiMatch( SessionInfo& session,
                                     DWORD dwCurrItem ) const
{
    m_UI.RenderHeader();

    m_UI.DrawText( 320, 140, COLOR_NORMAL, L"Session Settings",
                   XBFONT_CENTER_X );

    const WCHAR* const strSetting[] =
    {
        L"Set Game Type",
        L"Set Player Level",
        L"Set Game Style",
        L"Set Session Name",
        L"Find Matching Session"
    };

    FLOAT fYtop = 200.0f;
    const FLOAT fYdelta = 40.0f;

    for( DWORD i = 0; i < CUSTOM_MAX; ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : 
                                                COLOR_NORMAL;
        m_UI.DrawText( 160, fYtop + (fYdelta * i), dwColor, strSetting[i] );
    }

    // Show selected item with little triangle
    m_UI.RenderMenuSelector( 120.0f, fYtop + (fYdelta * dwCurrItem ) );

    // Determine current settings as strings
    const WCHAR* strCurrent[ CUSTOM_MAX ];
    switch( session.GetGameType() )
    {
        case TYPE_ANY:    strCurrent[ CUSTOM_TYPE ] = strANY;    break;
        case TYPE_SHORT:  strCurrent[ CUSTOM_TYPE ] = strSHORT;  break;
        case TYPE_MEDIUM: strCurrent[ CUSTOM_TYPE ] = strMEDIUM; break;
        case TYPE_LONG:   strCurrent[ CUSTOM_TYPE ] = strLONG;   break;
        default:          assert( FALSE );                       break;
    }

    switch( *session.GetStylePtr() )
    {
        case BYTE(  0  ): strCurrent[ CUSTOM_STYLE ] = strANY;    break;
        case BYTE( 'H' ): strCurrent[ CUSTOM_STYLE ] = strHEAVYw; break;
        case BYTE( 'L' ): strCurrent[ CUSTOM_STYLE ] = strLIGHTw; break;
        case BYTE( 'M' ): strCurrent[ CUSTOM_STYLE ] = strMIXEDw; break;
        default:          assert( FALSE );                       break;
    }
    if( session.GetStyleLen() == 0 )
        strCurrent[ CUSTOM_STYLE ] = strANY;

    const WCHAR* strPlayerLevel = session.GetPlayerLevel();
    strCurrent[ CUSTOM_LEVEL ] = *strPlayerLevel ? strPlayerLevel : strANY;
    strCurrent[ CUSTOM_NAME ] = session.GetSessionName();
    strCurrent[ CUSTOM_FIND ] = L"";

    // Show current settings
    fYtop = 200.0f;
    for( DWORD i = 0; i < CUSTOM_MAX; ++i )
        m_UI.DrawText( 380, fYtop + (fYdelta * i), COLOR_GREEN, strCurrent[i] );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectType()
// Desc: Display game type screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSelectType( DWORD dwCurrItem ) const
{
    m_UI.RenderHeader();

    m_UI.DrawText( 320, 140, COLOR_NORMAL, L"Game Type",
                   XBFONT_CENTER_X );

    const WCHAR* const strType[] =
    {
        strANY,
        strSHORT,
        strMEDIUM,
        strLONG
    };

    const FLOAT fYtop = 200.0f;
    const FLOAT fYdelta = 50.0f;

    for( DWORD i = 0; i < TYPE_MAX; ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : 
                                                COLOR_NORMAL;
        m_UI.DrawText( 260, fYtop + (fYdelta * i), dwColor, strType[i] );
    }

    // Show selected item with little triangle
    m_UI.RenderMenuSelector( 220.0f, fYtop + (fYdelta * dwCurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectLevel()
// Desc: Display player rating screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSelectLevel( DWORD dwCurrItem ) const
{
    m_UI.RenderHeader();

    m_UI.DrawText( 320, 140, COLOR_NORMAL, L"Player Level", XBFONT_CENTER_X );

    const WCHAR* const strLevel[] =
    {
        strANY,
        strBEGINNER,
        strINTERMEDIATE,
        strADVANCED
    };

    const FLOAT fYtop = 200.0f;
    const FLOAT fYdelta = 50.0f;

    for( DWORD i = 0; i < LEVEL_MAX; ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : 
                                                COLOR_NORMAL;
        m_UI.DrawText( 260, fYtop + (fYdelta * i), dwColor, strLevel[i] );
    }

    // Show selected item with little triangle
    m_UI.RenderMenuSelector( 220.0f, fYtop + (fYdelta * dwCurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectStyle()
// Desc: Display game style screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSelectStyle( DWORD dwCurrItem ) const
{
    m_UI.RenderHeader();

    m_UI.DrawText( 320, 140, COLOR_NORMAL, L"Game Style", XBFONT_CENTER_X );

    const WCHAR* const strStyle[] =
    {
        strANY,
        strHEAVYw,
        strLIGHTw,
        strMIXEDw
    };

    const FLOAT fYtop = 200.0f;
    const FLOAT fYdelta = 50.0f;

    for( DWORD i = 0; i < STYLE_MAX; ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : 
                                                COLOR_NORMAL;
        m_UI.DrawText( 260, fYtop + (fYdelta * i), dwColor, strStyle[i] );
    }

    // Show selected item with little triangle
    m_UI.RenderMenuSelector( 220.0f, fYtop + (fYdelta * dwCurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectName()
// Desc: Display game name screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSelectName( DWORD dwCurrItem, 
                                      const SessionNameList& SessionNames ) const
{
    assert( dwCurrItem < SessionNames.size() );

    m_UI.RenderHeader();
    m_UI.DrawText( 320, 140, COLOR_NORMAL, L"Session Name", XBFONT_CENTER_X );

    const FLOAT fYtop = 200.0f;
    const FLOAT fYdelta = 40.0f;

    for( DWORD i = 0; i < SessionNames.size(); ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_UI.DrawText( 260, fYtop + (fYdelta * i), dwColor, SessionNames[i].c_str() );
    }

    // Show selected item with little triangle
    m_UI.RenderMenuSelector( 220.0f, fYtop + (fYdelta * dwCurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectSession()
// Desc: Display session name screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSelectSession( DWORD dwCurrItem, 
                                         SessionList& Sessions ) const
{
    assert( dwCurrItem < Sessions.size() );

    m_UI.RenderHeader();
    m_UI.DrawText( 320, 120, COLOR_NORMAL, L"Sessions", XBFONT_CENTER_X );

    const FLOAT fYtop      = 200.0f;
    const FLOAT fYdelta    =  40.0f;
    const FLOAT SESSION_POSITION =  70.0f;
    const FLOAT LEVEL_POSITION   = 210.0f;
    const FLOAT STYLE_POSITION   = 340.0f;
    const FLOAT TYPE_POSITION    = 420.0f;
    const FLOAT PLAYER_POSITION  = 480.0f;

    m_UI.DrawText( SESSION_POSITION, 160, COLOR_NORMAL,  L"Session", 0 );
    m_UI.DrawText( LEVEL_POSITION,   160, COLOR_NORMAL,  L"Level", 0 );
    m_UI.DrawText( STYLE_POSITION,   160, COLOR_NORMAL,  L"Style", 0 );
    m_UI.DrawText( TYPE_POSITION,    160, COLOR_NORMAL,  L"Type", 0 );
    m_UI.DrawText( PLAYER_POSITION,  160, COLOR_NORMAL,  L"Open", 0 );

    for( DWORD i = 0; i < Sessions.size(); ++i )
    {
        FLOAT fYPosition = fYtop + (fYdelta * i);
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;

        ULONGLONG qwGameType = Sessions[i].GetGameType();
        PWSTR strType;

        switch (qwGameType)
        {
        case TYPE_SHORT:
            strType = L"Short";
            break;
        case TYPE_MEDIUM:
            strType = L"Med";
            break;
        case TYPE_LONG:
            strType = L"Long";
            break;
        default:
            strType = L"";
            assert(0);
        }

        m_UI.DrawText( SESSION_POSITION, fYPosition, dwColor, 
            Sessions[i].GetSessionName() );
        m_UI.DrawText( LEVEL_POSITION,   fYPosition, dwColor, 
            Sessions[i].GetPlayerLevel() );

        // Fetch the style (which is stored as a blob)
        CHAR  strStyle[ MAX_STYLE_BLOB ];
        WCHAR strStyleW[ MAX_STYLE_BLOB ];

        CopyMemory( strStyle, Sessions[i].GetStylePtr(),  Sessions[i].GetStyleLen() );
        strStyle[ Sessions[i].GetStyleLen() ] = '\0'; // Terminate the string

        XBUtil_GetWide( strStyle, strStyleW, MAX_STYLE_BLOB );

        m_UI.DrawText( STYLE_POSITION,   fYPosition, dwColor, 
            strStyleW ); 
        m_UI.DrawText( TYPE_POSITION,   fYPosition, dwColor, 
            strType ); 

        WCHAR strPlayers[ 32 ];

        wsprintfW( strPlayers, L"%lu", Sessions[i].GetPublicAvail() );
        m_UI.DrawText( PLAYER_POSITION + 20.0f,   fYPosition, dwColor, 
            strPlayers );

    }

    // Show selected item with little triangle
    m_UI.RenderMenuSelector( 40.0f, fYtop + (fYdelta * dwCurrItem ) );

}


//-----------------------------------------------------------------------------
// Name: RenderCreateAccount()
// Desc: Allow player to launch account creation tool
//-----------------------------------------------------------------------------
VOID UserInterface::RenderCreateAccount( BOOL bHasMachineAccount ) const
{
    m_UI.RenderCreateAccount( bHasMachineAccount );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectAccount()
// Desc: Display list of accounts
//-----------------------------------------------------------------------------
VOID UserInterface::RenderSelectAccount( DWORD dwCurrItem, 
                                         XBUserList& UserList ) const
{
    m_UI.RenderSelectAccount( dwCurrItem, UserList );
}




//-----------------------------------------------------------------------------
// Name: RenderGetPin()
// Desc: Display PIN entry screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderGetPin( const CXBPinEntry& PinEntry, 
                                  const WCHAR* strUser ) const
{
    m_UI.RenderGetPin( PinEntry, strUser );
}




//-----------------------------------------------------------------------------
// Name: RenderLogginOn()
// Desc: Display login message
//-----------------------------------------------------------------------------
VOID UserInterface::RenderLoggingOn() const
{
    m_UI.RenderLoggingOn();
}




//-----------------------------------------------------------------------------
// Name: RenderGameSearch()
// Desc: Display game search screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderGameSearch() const
{
    m_UI.RenderHeader();
    m_UI.DrawText( 320, 200, COLOR_NORMAL, L"Searching for Game Sessions", 
                   XBFONT_CENTER_X );
    m_UI.DrawText( 320, 260, COLOR_NORMAL, L"Press B to cancel", 
                   XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderRequestJoin()
// Desc: Display game join screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderRequestJoin() const
{
    m_UI.RenderHeader();
    m_UI.DrawText( 320, 200, COLOR_NORMAL, L"Joining Game", 
                   XBFONT_CENTER_X );
    m_UI.DrawText( 320, 260, COLOR_NORMAL, L"Press B to cancel", 
                   XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderCreateSession()
// Desc: Display game create screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderCreateSession() const
{
    m_UI.RenderHeader();
    m_UI.DrawText( 320, 200, COLOR_NORMAL, L"Registering Game Session", 
                   XBFONT_CENTER_X );
    m_UI.DrawText( 320, 260, COLOR_NORMAL, L"Press B to cancel", 
                   XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderPlayGame()
// Desc: Display game
//-----------------------------------------------------------------------------
VOID UserInterface::RenderPlayGame( SessionInfo& session,
                                    WCHAR* strUser,
                                    WCHAR* strStatus,
                                    DWORD dwPlayerCount,
                                    DWORD dwCurrItem ) const
{
    m_UI.RenderHeader();

    // Game name and player name
    WCHAR strGameInfo[ 32 + MAX_SESSION_STR + MAX_PLAYER_STR ];
    wsprintfW( strGameInfo, L"Session name: %.*s\nYour name: %.*s", 
               MAX_SESSION_STR, session.GetSessionName(), 
               MAX_PLAYER_STR, strUser );
    m_UI.DrawText( 320, 100, COLOR_GREEN, strGameInfo, XBFONT_CENTER_X );

    // Determine current game type as string
    const WCHAR* strType = L"";
    switch( session.GetGameType() )
    {
        case TYPE_SHORT:  strType = strSHORT;  break;
        case TYPE_MEDIUM: strType = strMEDIUM; break;
        case TYPE_LONG:   strType = strLONG;   break;
        default:          assert( FALSE );     break;
    }

    // Determine current game style as string
    const WCHAR* strStyle = L"";
    switch( *session.GetStylePtr() )
    {
        case BYTE( 'H' ): strStyle = strHEAVYw; break;
        case BYTE( 'L' ): strStyle = strLIGHTw; break;
        case BYTE( 'M' ): strStyle = strMIXEDw; break;
        default:          assert( FALSE );      break;
    }

    // Game info
    wsprintfW( strGameInfo, L"Type: %.*s, Level: %.*s, Style: %.*s",
               MAX_TYPE_STR, strType,
               MAX_LEVEL_STR, session.GetPlayerLevel(),
               MAX_STYLE_BLOB + 1, strStyle );
    m_UI.DrawText( 320, 150, COLOR_GREEN, strGameInfo, XBFONT_CENTER_X );

    // Number of players and current status
    wsprintfW( strGameInfo, L"Players in game: %lu", dwPlayerCount );
    m_UI.DrawText( 320, 180, COLOR_GREEN, strGameInfo, XBFONT_CENTER_X );
    m_UI.DrawText( 320, 220, COLOR_GREEN, strStatus, XBFONT_CENTER_X );

    // Game options menu
    const WCHAR* const strMenu[] =
    {
        L"Wave To Other Players",
        L"Leave Game"
    };

    FLOAT fYtop = 280.0f;
    FLOAT fYdelta = 50.0f;

    // Show menu
    for( DWORD i = 0; i < GAME_MAX; ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;
        m_UI.DrawText( 260, fYtop + (fYdelta * i), dwColor, strMenu[i] );
    }

    // Show selected item with little triangle
    m_UI.RenderMenuSelector( 220.0f, fYtop + (fYdelta * dwCurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderDeleteSession()
// Desc: Display game deletion screen
//-----------------------------------------------------------------------------
VOID UserInterface::RenderDeleteSession() const
{
    m_UI.RenderHeader();
    m_UI.DrawText( 320, 200, COLOR_NORMAL, L"Unregistering Game Session", 
                   XBFONT_CENTER_X );
    m_UI.DrawText( 320, 260, COLOR_NORMAL, L"Press B to cancel", 
                   XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderError()
// Desc: Display error message
//-----------------------------------------------------------------------------
VOID UserInterface::RenderError() const
{
    m_UI.RenderError();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleContentDownload\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleContentDownload\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\twowayvoice\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleContentDownload\common.h ===
//-----------------------------------------------------------------------------
// File: Common.h
//
// Desc: SimpleContentDownload global header
//
// Hist: 11.10.01 - New for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef SIMPLECONTENTDOWNLOAD_COMMON_H
#define SIMPLECONTENTDOWNLOAD_COMMON_H

#include "xtl.h"
#include "xonline.h"
#include <string>
#include <vector>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
enum
{
    // Confirm menu
    CONFIRM_YES = 0,
    CONFIRM_NO,
    CONFIRM_MAX
};




//-----------------------------------------------------------------------------
// Name: class ContentInfo
// Desc: Content information from the online catalog; simplifies access to
//       XONLINECATALOG data.
//-----------------------------------------------------------------------------
class ContentInfo
{
    DWORD                     m_dwPackageSize;
    DWORD                     m_dwInstallSize;
    DWORD                     m_dwRating;
    DWORD                     m_dwOfferingType;
    DWORD                     m_dwBitFlags;   
    FILETIME                  m_ftCreationDate;
    XONLINEOFFERING_ID        m_ID;
    std::basic_string< BYTE > m_Data;       // Title-specific data

public:

    ContentInfo()
    :   
        m_dwPackageSize ( 0 ),
        m_dwInstallSize ( 0 ),
        m_dwRating( 0 ),
        m_dwOfferingType( 0 ),
        m_dwBitFlags( 0 ),
        m_ftCreationDate( FILETIME() ),
        m_ID            ( XONLINEOFFERING_ID(0) ),
        m_Data          ()
    {
    }

    explicit ContentInfo( const XONLINEOFFERING_INFO& xOnInfo )
    :   
        m_dwPackageSize ( xOnInfo.cbPackageSize ),
        m_dwInstallSize ( xOnInfo.cbInstallSize ),
        m_dwOfferingType( xOnInfo.dwOfferingType ),
        m_dwBitFlags    ( xOnInfo.dwBitFlags ),
        m_dwRating      ( xOnInfo.dwRating ),
        m_ftCreationDate( xOnInfo.ftActivationDate ),
        m_ID            ( xOnInfo.OfferingId ),
        m_Data          ( xOnInfo.pbTitleSpecificData,
                          xOnInfo.cbTitleSpecificData )
    {
    }

    DWORD GetPackageSize() const     { return m_dwPackageSize; }
    DWORD GetInstallSize() const     { return m_dwInstallSize; }
    DWORD GetOfferingType() const    { return m_dwOfferingType; }
    DWORD GetBitFlags() const        { return m_dwBitFlags; }
    DWORD GetRating() const          { return m_dwRating; }
    FILETIME GetCreationDate() const { return m_ftCreationDate; }
    XONLINEOFFERING_ID GetId() const { return m_ID; }

};




//-----------------------------------------------------------------------------
// Typedefs
//-----------------------------------------------------------------------------
typedef std::vector< ContentInfo > ContentList;




#endif // SIMPLECONTENTDOWNLOAD_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleAuth\SimpleAuth.cpp ===
//-----------------------------------------------------------------------------
// File: SimpleAuth.cpp
//
// Desc: Shows Xbox online authentication protocols.
//
// Hist: 11.01.01 - Created for December Release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "xtl.h"
#include "xonline.h"
#include <vector>
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include "XBNet.h"
#include "XBOnlineTask.h"
#include "XBOnline.h"
#include "XBVoice.h"
#include <cassert>


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_STATUS_STR = 64;


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    // Number of services to authenticate
    static const DWORD NUM_SERVICES = 2;
    
    // Index into m_UserList of acount to use
    static const DWORD DEFAULT_USER_ACCOUNT = 0;     // Just use the first one
    
    // Controller to use for login
    static const DWORD DEFAULT_CONTROLLER = 0;       // Just use the first one
    
    CXBoxSample();
    
    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
    HRESULT         Logon();
    void __cdecl    SetStatus( const WCHAR*, ... );
    void            RenderLoginProgress( DWORD dwElapsedSeconds );
private:
    CXBFont             m_Font;                    // Font object
    CXBOnlineTask       m_hOnlineTask;             // Online task
    CXBNetLink          m_NetLink;                 // Network link checking
    DWORD             m_Services[ NUM_SERVICES ];  // List of desired services
    XBUserList        m_UserList;                  // List of accounts
    WCHAR             m_strStatus[MAX_STATUS_STR]; // Logon/Connection status
    BOOL              m_bIsDone;                   // Finished logon attempt
    XNADDR            m_xnTitleAddress;    // XNet address of this machine/game
    
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
:CXBApplication()
{
    m_strStatus[0] = L'\0';
    m_bIsDone      = FALSE;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetStatus()
// Desc: Set status string
//-----------------------------------------------------------------------------
void __cdecl CXBoxSample::SetStatus( const WCHAR* strFormat, ... )
{
    va_list pArgList;
    va_start( pArgList, strFormat );
    
    INT iChars = wvsprintfW( m_strStatus, strFormat, pArgList );
    assert( iChars < MAX_STATUS_STR );
    (void)iChars; // avoid compiler warning
    
    va_end( pArgList );
}




//-----------------------------------------------------------------------------
// Name: RenderLoginProgress
// Desc: Render login progress
//-----------------------------------------------------------------------------
void CXBoxSample::RenderLoginProgress( DWORD dwElapsedSeconds )
{
    WCHAR strTime[40];
    DWORD dwHours, dwMinutes, dwSeconds;
    
    dwHours   = dwElapsedSeconds / 3600;
    dwMinutes = ( dwElapsedSeconds - dwHours * 3600 ) / 60;
    dwSeconds = dwElapsedSeconds - ( dwHours * 3600 + dwMinutes * 60 );
    
    swprintf( strTime, L"%.2d:%.2d:%.2d", dwHours, dwMinutes, dwSeconds );
    
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, 
        D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
        0x000A0A6A, 1.0f, 0L );
    
    m_Font.Begin();
    m_Font.DrawText(  64, 50, CXBOnlineUI::COLOR_NORMAL, L"SimpleAuth" );
    m_Font.DrawText(  64, 80, CXBOnlineUI::COLOR_NORMAL, L"Logging In" );
    m_Font.DrawText( 450, 50, CXBOnlineUI::COLOR_HIGHLIGHT, strTime );
    m_Font.End();
    
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}




//-----------------------------------------------------------------------------
// Name: Logon
// Desc: Performs user login and authentication
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Logon()
{
    
    // Add whatever services are appropriate for your title, but no
    // more. Each service requires additional authentication time
    // and network traffic.
    m_Services[0] = XONLINE_MATCHMAKING_SERVICE;
    m_Services[1] = XONLINE_BILLING_OFFERING_SERVICE;
    
    // Initialize the network stack
    HRESULT hr = XBNet_OnlineInit( 0 );
    if( FAILED( hr ) )
    {
        SetStatus( L"Network Initialization Failed (error 0x%x)", 
            hr );
        return hr;
    }
    
    // If no accounts, then player needs to create an account.
    // For development purposes, accounts are created using the OnlineSetup
    // tool in the XDK Launcher. For retail Xbox consoles, accounts are
    // created in the Xbox Dashboard.
    
    // Get information on all accounts for this Xbox
    hr = XBOnline_GetUserList( m_UserList );
    if( FAILED( hr ) )
    {
        SetStatus( L"Failed to Retrieve User Accounts (error 0x%x)", 
            hr );
        return hr;
    }
    
    // Make sure there is at least one user account
    if( m_UserList.empty() )
    {
        SetStatus( L"No User Accounts Found" );
        return E_UNEXPECTED;
    }
    
    // XOnlineLogon() allows a list of up to 4 players (1 per controller)
    // to login in a single call. This sample shows how to authenticate
    // a single user. The list must be a one-to-one match of controller 
    // to player in order for the online system to recognize which player
    // is using which controller.  For brevity, we arbitrarily select
    // an account (DEFAULT_PLAYER) and (DEFAULT_CONTROLLER) controller.
    XONLINE_USER Controllers[ XGetPortCount() ] = { 0 };
    
    // Copy account information to selected controller
    Controllers[ DEFAULT_CONTROLLER ] = m_UserList[ DEFAULT_USER_ACCOUNT ];
        
    CXBStopWatch LogonTimer(FALSE); // Elapsed time during login
    
    // Start Logon timer (for display purposes)
    LogonTimer.Start();
    
    // Initiate the login process. XOnlineTaskContinue() is used to poll
    // the status of the login.
    hr = XOnlineLogon( Controllers, m_Services, NUM_SERVICES, 
        NULL, &m_hOnlineTask );
    
    if( FAILED( hr ) )
    {
        SetStatus( L"Logon Failed (error 0x%x)", hr );
        return hr;
    }
    
    
    // Go into a loop, pumping the task and presenting status
    // information until we finish logging on
    do
    {
        RenderLoginProgress( (DWORD) LogonTimer.GetElapsedSeconds() );
        hr = m_hOnlineTask.Continue();
    } while ( hr == XONLINETASK_S_RUNNING );
    
    if( hr != XONLINE_S_LOGON_CONNECTION_ESTABLISHED )
    {
        SetStatus( L"Authentication Failed (0x%x)", 
            hr );
        return hr;
    }   // Check to make sure the services that were requested are available
    
    // Next, check if the user was actually logged on
    PXONLINE_USER pLoggedOnUsers = XOnlineGetLogonUsers();

    assert( pLoggedOnUsers );

    hr = pLoggedOnUsers[ DEFAULT_CONTROLLER ].hr;

    if( FAILED( hr ) )
    {
        SetStatus( L"User Logon Failed (0x%x)", hr );
        return hr;
    }


    // Finally, check to make sure all requested services were available
    for(DWORD i = 0; i < NUM_SERVICES; ++i )
    {
        hr = XOnlineGetServiceInfo( m_Services[i], NULL );
        
        if( FAILED( hr ) )
        {
            SetStatus( L"Service %lu unavailable (0x%x)",
                m_Services[i], hr );
            return hr;
        }
    }
    
    // Notify our friends of our state change
    DWORD dwState = XONLINE_FRIENDSTATE_FLAG_ONLINE;
    
    if( XBVoice_HasDevice() )
        dwState |= XONLINE_FRIENDSTATE_FLAG_VOICE;
    
    if( !XOnlineNotificationSetState(
        DEFAULT_CONTROLLER, dwState, XNKID(), 0, NULL ) )
    {
        SetStatus( L"Failed to Set Player Notification State." );
        return E_UNEXPECTED;
    }
    
    SetStatus( L"Logged On" );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    HRESULT hr;
    
    if(m_bIsDone)
    {
        // If we are logged on, pump the task
        if( m_hOnlineTask.IsOpen() )
        {                       
            hr  = m_hOnlineTask.Continue();
            if( FAILED( hr ) )
            {
                SetStatus( L"Connection was lost (0x%x)", hr );
            }           
        }
        
    }
    else
    {
        
        hr = Logon();
        
        if( FAILED( hr ) )
        {        
            m_hOnlineTask.Close();
        }
        
        // Toggle flag so that we don't attempt another logon
        m_bIsDone = TRUE;
    }
    
    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, 
        D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
        0x000A0A6A, 1.0f, 0L );
    
    m_Font.Begin();
    m_Font.DrawText(  64, 50, CXBOnlineUI::COLOR_NORMAL,     L"SimpleAuth" );
    m_Font.DrawText( 450, 50, CXBOnlineUI::COLOR_HIGHLIGHT, m_strFrameRate );
    m_Font.DrawText(  64, 80, CXBOnlineUI::COLOR_NORMAL, 
        m_strStatus );
    m_Font.End();
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\twowayvoice\resource.h ===
// Automatically generated by the bundler tool from MenuResource.rdf

#define Resource_NUM_RESOURCES 1UL

#define Resource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\networking\SimpleContentDownload\SimpleContentDownload.cpp ===
//-----------------------------------------------------------------------------
// File: SimpleContentDownload.cpp
//
// Desc: Shows Xbox online content enumeration, download, installation
//       and removal.
//
// Hist: 11.09.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "xtl.h"
#include "xonline.h"
#include <vector>
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include "XBNet.h"
#include "XBOnlineTask.h"
#include "XBOnline.h"
#include "XBVoice.h"
#include <cassert>
#include "common.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
};

#define NUM_HELP_CALLOUTS ( sizeof( g_HelpCallouts ) / sizeof( g_HelpCallouts[0] ) )

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_STATUS_STR = 64;

const DWORD MAX_CONTENT_RESULTS   = 5;    // Don't request more than this number


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    
    // Number of services to authenticate
    static const DWORD NUM_SERVICES = 1;
    
    // Index into m_UserList of acount to use
    static const DWORD DEFAULT_USER_ACCOUNT = 0;     // Just use the first one
    
    // Controller to use for login
    static const DWORD DEFAULT_CONTROLLER = 0;       // Just use the first one
    
    CXBoxSample();
    
    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
    
    HRESULT         Logon();
    HRESULT         EnumerateContent();
    HRESULT         DownloadContent();
    HRESULT         VerifyContent();
    HRESULT         RemoveContent();
    void __cdecl    SetStatus( const WCHAR*, ... );
    void            DisplayStatus(BOOL bWaitForKeyPress = FALSE);
private:
    CXBFont             m_Font;                    // Font object
    CXBOnlineTask       m_hLogonTask;             // Online task
    CXBNetLink          m_NetLink;                 // Network link checking
    XBUserList        m_UserList;                  // List of accounts
    WCHAR             m_strStatus[MAX_STATUS_STR]; // Logon/Connection status
    BOOL              m_bIsDone;                   // Finished logon attempt
    XNADDR            m_xnTitleAddress;   // XNet address of this machine/game
    CXBHelp           m_Help;             // Help object
    BOOL              m_bDrawHelp;        // TRUE to draw help screen  
    DWORD             m_pServices[NUM_SERVICES] ;  // services to authenticate
    ContentList       m_ContentList;      // list of content
    DWORD             m_dwContentIndex;   // Index of item to be downloaded
    
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
:CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_strStatus[0] = L'\0';
    m_bIsDone      = FALSE;
    m_pServices[0] = XONLINE_BILLING_OFFERING_SERVICE;
    m_dwContentIndex = 0;
    
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    
    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    
    srand( GetTickCount() ); // for picking random content
    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: SetStatus()
// Desc: Set status string
//-----------------------------------------------------------------------------
void __cdecl CXBoxSample::SetStatus( const WCHAR* strFormat, ... )
{
    va_list pArgList;
    va_start( pArgList, strFormat );
    
    INT iChars = wvsprintfW( m_strStatus, strFormat, pArgList );
    assert( iChars < MAX_STATUS_STR );
    (void)iChars; // avoid compiler warning
    
    va_end( pArgList );
}




//-----------------------------------------------------------------------------
// Name: DisplayStatus()
// Desc: Display Status
//-----------------------------------------------------------------------------
void CXBoxSample::DisplayStatus(BOOL bWaitForKeyPress)
{ 
    
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, 
        D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
        0x000A0A6A, 1.0f, 0L );
    
    m_Font.Begin();
    m_Font.DrawText(  64, 50, CXBOnlineUI::COLOR_NORMAL, L"SimpleContentDownload" );
    m_Font.DrawText(  64, 80, CXBOnlineUI::COLOR_NORMAL, m_strStatus );
    
    if( bWaitForKeyPress )
    {
        m_Font.DrawText(  64, 140, CXBOnlineUI::COLOR_NORMAL, 
            L"Press A to continue" );
    }
    
    m_Font.End();
    
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    
    if( bWaitForKeyPress )
    {
        for(;;)
        {
            // Read the input for all connected gampads, looking for
            // one that has the "A" button pressed
            XBInput_GetInput( m_Gamepad );
            for( DWORD i=0; i<4; i++ )
            {
                if( m_Gamepad[i].hDevice && m_Gamepad[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
                {
                    return;
                }
            }
        }
    }
    
}




//-----------------------------------------------------------------------------
// Name: Logon
// Desc: Performs user login and authentication
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Logon()
{
    
    
    // Initialize the network stack
    HRESULT hr = XBNet_OnlineInit( 0 );
    if( FAILED( hr ) )
    {
        SetStatus( L"Network Initialization Failed (error 0x%x)", 
            hr );
        return hr;
    }
    
    // Get information on all accounts for this Xbox
    hr = XBOnline_GetUserList( m_UserList );
    if( FAILED( hr ) )
    {
        SetStatus( L"Failed to Retrieve User Accounts (error 0x%x)", 
            hr );
        return hr;
    }
    
    // Make sure there is at least one user account
    if( m_UserList.empty() )
    {
        SetStatus( L"No User Accounts Found" );
        return E_UNEXPECTED;
    }
    
    // XOnlineLogon() allows a list of up to 4 players (1 per controller)
    // to login in a single call. This sample shows how to authenticate
    // a single user. The list must be a one-to-one match of controller 
    // to player in order for the online system to recognize which player
    // is using which controller.  For brevity, we arbitrarily select
    // an account (DEFAULT_PLAYER) and (DEFAULT_CONTROLLER) controller.
    XONLINE_USER Controllers[ XGetPortCount() ] = { 0 };
    
    // Copy account information to selected controller
    Controllers[ DEFAULT_CONTROLLER ] = m_UserList[ DEFAULT_USER_ACCOUNT ];
    
    CXBStopWatch LogonTimer(FALSE); // Elapsed time during login
    
    // Start Logon timer (for display purposes)
    LogonTimer.Start();
    
    SetStatus( L"Starting Logon..." );
    DisplayStatus();
    
    // Initiate the login process. XOnlineTaskContinue() is used to poll
    // the status of the login.
    hr = XOnlineLogon( Controllers, m_pServices, NUM_SERVICES, 
        NULL, &m_hLogonTask );
    
    if( FAILED( hr ) )
    {
        SetStatus( L"Logon Failed (error 0x%x)", hr );
        return hr;
    }
    
    // Go into a loop, pumping the task and presenting status
    // information until we finish logging on
    do
    {
        DWORD dwElapsedSeconds = (DWORD) LogonTimer.GetElapsedSeconds();
        DWORD dwHours, dwMinutes, dwSeconds;
        
        dwHours   = dwElapsedSeconds / 3600;
        dwMinutes = ( dwElapsedSeconds - dwHours * 3600 ) / 60;
        dwSeconds = dwElapsedSeconds - ( dwHours * 3600 + dwMinutes * 60 );
        
        SetStatus( L"Logging On (%.2d:%.2d:%.2d)", dwHours, dwMinutes, dwSeconds ); 
        
        DisplayStatus();
        
        hr = m_hLogonTask.Continue();
    } while ( hr == XONLINETASK_S_RUNNING );
    
    if( hr != XONLINE_S_LOGON_CONNECTION_ESTABLISHED )
    {
        SetStatus( L"Authentication Failed (0x%x)", 
            hr );
        return hr;
    }

    // Next, check if the user was actually logged on
    PXONLINE_USER pLoggedOnUsers = XOnlineGetLogonUsers();

    assert( pLoggedOnUsers );

    hr = pLoggedOnUsers[ DEFAULT_CONTROLLER ].hr;

    if( FAILED( hr ) )
    {
        SetStatus( L"User Logon Failed (0x%x)", hr );
        return hr;
    }

    for( DWORD i = 0; i < NUM_SERVICES; ++i )
    {
        hr = XOnlineGetServiceInfo( m_pServices[i], NULL );
        
        if( FAILED( hr ) )
        {
            SetStatus( L"Service %d Unavailable (0x%x)",
                m_pServices[i], hr );
            return hr;
        }
    }

    
    // Notify the world of our state change
    DWORD dwState = XONLINE_FRIENDSTATE_FLAG_ONLINE;
    
    if( XBVoice_HasDevice() )
        dwState |= XONLINE_FRIENDSTATE_FLAG_VOICE;
    
    if(!XOnlineNotificationSetState(
        DEFAULT_CONTROLLER, dwState, XNKID(), 0, NULL ) )
    {
        SetStatus( L"Failed to Set Player Notification State." );
        return E_UNEXPECTED;
    }
    
    SetStatus( L"Logged On" );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: EnumerateContent
// Desc: Enumerate Content
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::EnumerateContent()
{
    
    
    XONLINEOFFERING_ENUM_PARAMS EnumParams;
    
    // Look for content created after this date. This is an optional parameter.
    // If NULL is passed, all items are enumerated.
    SYSTEMTIME SysTime = { 0 };
    SysTime.wYear = 2001;
    SysTime.wMonth = 1;
    SysTime.wDay = 1;
    BOOL bSuccess = SystemTimeToFileTime( &SysTime, &EnumParams.ftActiveAfter );
    assert( bSuccess );
    (VOID)bSuccess;
    
    EnumParams.dwOfferingType = 0xffffffff; // All offering types
    EnumParams.dwBitFilter    = 0xffffffff;    // All offers
    EnumParams.dwMaxResults   = MAX_CONTENT_RESULTS; 
    EnumParams.dwDescriptionIndex = 0;
    
    // Determine the buffer size required for enumeration
    DWORD dwBufferSize = XOnlineOfferingEnumerateMaxSize( &EnumParams, 0 ); 
    
    CXBOnlineTask hContentTask;
    
    SetStatus( L"Enumerating Content..." );
    DisplayStatus();
    
    // Initiate the online enumeration
    HRESULT hr = XOnlineOfferingEnumerate( XONLINEOFFERING_ENUM_DEVICE_ONLINE, 
        DEFAULT_USER_ACCOUNT, &EnumParams, 
        NULL, dwBufferSize,
        NULL, &hContentTask );
    
    if( FAILED( hr ) )
    {
        SetStatus( L"XOnlineOfferingEnumerate Failed (error 0x%x)", hr );
        return hr;
    }
    
    CXBStopWatch EnumTimer(FALSE); // Elapsed time during enumeration
    
    // Start Logon timer (for display purposes)
    EnumTimer.Start();
    
    BOOL bPartial;
    
    for(;;)
    {
        DWORD dwElapsedSeconds = (DWORD) EnumTimer.GetElapsedSeconds();
        DWORD dwHours, dwMinutes, dwSeconds;
        
        dwHours   = dwElapsedSeconds / 3600;
        dwMinutes = ( dwElapsedSeconds - dwHours * 3600 ) / 60;
        dwSeconds = dwElapsedSeconds - ( dwHours * 3600 + dwMinutes * 60 );
        
        SetStatus( L"Enumerating (%.2d:%.2d:%.2d)", dwHours, dwMinutes, dwSeconds ); 
        
        DisplayStatus();     
        
        hr = m_hLogonTask.Continue(); 
        
        // Handle errors
        if( FAILED( hr ) )
        {
            SetStatus( L"Connection was lost (error 0x%x)", hr );
            break;
        }
        
        hr = hContentTask.Continue();
        
        if( hr != XONLINETASK_S_RUNNING )
        {
            // Handle errors
            if( FAILED( hr ) )
            {
                SetStatus( L"Enumeration Failed (error 0x%x)", hr );
                break;
            }
            
            // Extract the results
            PXONLINEOFFERING_INFO* ppInfo;
            DWORD dwItems;
            
            hr = XOnlineOfferingEnumerateGetResults( hContentTask,
                &ppInfo, &dwItems, &bPartial );
            
            // Handle errors
            if( FAILED(hr) )
            {
                SetStatus( L"Enumeration failed with error 0x%x", hr  );
                break;
            }
            
            // Save the results
            for( DWORD i = 0; i < dwItems; ++i )
            {
                m_ContentList.push_back( ContentInfo( *ppInfo[i] ) );
            }
            
            if( !bPartial )
            {
                break;
            }
        }
        
    }
    
    if( SUCCEEDED( hr ) )
    {
        DWORD dwSize = m_ContentList.size();
        if( dwSize == 0 )
        {
            hr = E_UNEXPECTED;
            SetStatus( L"No New Content" );
        }
        else
        {
            SetStatus( L"Enumeration Succeeded (%lu Items enumerated)", dwSize );
            DisplayStatus(TRUE);
        }
    }
    
    return hr;
    
    
}




//-----------------------------------------------------------------------------
// Name: DownloadContent
// Desc: Download Content
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadContent()
{
    CXBOnlineTask hContentTask;
    
    // Pick a random entry...
    m_dwContentIndex = rand() % m_ContentList.size();
    
    XONLINEOFFERING_ID id = m_ContentList[ m_dwContentIndex ].GetId();
    
    SetStatus( L"Starting Download of Item %lu", id );
    DisplayStatus();
    
    // Initiate the installation of the selected content
    HRESULT hr = XOnlineContentInstall( id, NULL, &hContentTask );
    if( FAILED( hr ) )
    {
        SetStatus( L"XOnlineContentInstall Failed (error 0x%x)", hr );
        return hr;
    }
    
    // Pump the tasks...
    do
    {
        hr = m_hLogonTask.Continue(); 
        // Handle errors
        if( FAILED( hr ) )
        {
            SetStatus( L"Connection was lost (error 0x%x)", hr );
            return hr;
        }
        
        // Determine the download progress
        DWORD dwPercent;
        ULONGLONG ullBytesInstalled;
        ULONGLONG ullBytesTotal;
        hr = XOnlineContentInstallGetProgress( hContentTask,
            &dwPercent, &ullBytesInstalled, &ullBytesTotal );
        
        SetStatus( L"Downloading %lu ... %lu%% complete", id, 
            dwPercent );
        
        DisplayStatus();
        hr = hContentTask.Continue();
        
    } while ( hr == XONLINETASK_S_RUNNING );
    
    if( SUCCEEDED( hr ) )
    {
        
        char strDirectory[ MAX_PATH ];
        DWORD cbDirectory = sizeof( strDirectory );
        
        hr = XOnlineContentGetRootDirectory( id, FALSE, &cbDirectory, 
            strDirectory );
        if( FAILED( hr ) )
        {
            SetStatus( L"GetRootDirectory Failed (error 0x%x)", hr );
        }  
        else
        {
            
            WCHAR strUnicodeDirectory [ MAX_PATH ];
            XBUtil_GetWide( strDirectory , strUnicodeDirectory, 
                cbDirectory + 1 );
            
            SetStatus( L"Downloaded into %s", strUnicodeDirectory );
            DisplayStatus( TRUE );
        }
    }
    else
    {
        SetStatus( L"Download Failed (error 0x%x)", hr );       
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: VerifyContent
// Desc: Verify Downloaded Content
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::VerifyContent()
{
    CXBOnlineTask hContentTask;
    
    XONLINEOFFERING_ID id = m_ContentList[ m_dwContentIndex ].GetId();
    
    // The verification buffer must be a minimum of two sectors in size.
    // If the buffer is not provided by the title, it will be automatically
    // created
    DWORD dwBufferSize = XGetDiskSectorSize( "U:\\" ) * 2;
    
    SetStatus( L"Verifying Content..." );
    DisplayStatus();
    
    // Initiate the verification of the selected content
    HRESULT hr = XOnlineContentVerify( id, NULL, &dwBufferSize,
        NULL, &hContentTask );
    
    if( FAILED( hr ) )
    {
        SetStatus( L"XOnlineContentVerify Failed (error 0x%x)", hr );
        return hr;
    }
    
    do
    {
        hr = m_hLogonTask.Continue();
        if( FAILED( hr ) )
        {
            SetStatus( L"Connection was lost (error 0x%x)"